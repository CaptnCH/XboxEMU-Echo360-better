#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 8210AD18h
// Function '?CompactArguments@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210AD18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210AD18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210AD18);
		  /* 8210AD18h */ case    0:  		/* stw R11, <#[R10 + 20]> */
		/* 8210AD18h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 8210AD18h case    0:*/		return 0x8210AD1C;
		  /* 8210AD1Ch */ case    1:  		/* bc 12, CR6_LT, -156 */
		/* 8210AD1Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x8210AC80;  }
		/* 8210AD1Ch case    1:*/		return 0x8210AD20;
		  /* 8210AD20h */ case    2:  		/* lwz R11, <#[R23 + 12]> */
		/* 8210AD20h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210AD20h case    2:*/		return 0x8210AD24;
		  /* 8210AD24h */ case    3:  		/* addi R11, R11, -1 */
		/* 8210AD24h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8210AD24h case    3:*/		return 0x8210AD28;
		  /* 8210AD28h */ case    4:  		/* cmplw CR6, R11, R25 */
		/* 8210AD28h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 8210AD28h case    4:*/		return 0x8210AD2C;
		  /* 8210AD2Ch */ case    5:  		/* bc 4, CR6_GT, 40 */
		/* 8210AD2Ch case    5:*/		if ( !regs.CR[6].gt ) { return 0x8210AD54;  }
		/* 8210AD2Ch case    5:*/		return 0x8210AD30;
		  /* 8210AD30h */ case    6:  		/* subf R10, R25, R11 */
		/* 8210AD30h case    6:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R25,regs.R11);
		/* 8210AD30h case    6:*/		return 0x8210AD34;
		  /* 8210AD34h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210AD34h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210AD34h case    7:*/		return 0x8210AD38;
		  /* 8210AD38h */ case    8:  		/* mtspr CTR, R10 */
		/* 8210AD38h case    8:*/		regs.CTR = regs.R10;
		/* 8210AD38h case    8:*/		return 0x8210AD3C;
		  /* 8210AD3Ch */ case    9:  		/* lwz R10, <#[R23 + 24]> */
		/* 8210AD3Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000018) );
		/* 8210AD3Ch case    9:*/		return 0x8210AD40;
		  /* 8210AD40h */ case   10:  		/* add R10, R10, R11 */
		/* 8210AD40h case   10:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8210AD40h case   10:*/		return 0x8210AD44;
		  /* 8210AD44h */ case   11:  		/* addi R11, R11, -4 */
		/* 8210AD44h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8210AD44h case   11:*/		return 0x8210AD48;
		  /* 8210AD48h */ case   12:  		/* lwz R9, <#[R10 - 4]> */
		/* 8210AD48h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 8210AD48h case   12:*/		return 0x8210AD4C;
		  /* 8210AD4Ch */ case   13:  		/* stw R9, <#[R10]> */
		/* 8210AD4Ch case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8210AD4Ch case   13:*/		return 0x8210AD50;
		  /* 8210AD50h */ case   14:  		/* bc 16, CR0_LT, -20 */
		/* 8210AD50h case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210AD3C;  }
		/* 8210AD50h case   14:*/		return 0x8210AD54;
	}
	return 0x8210AD54;
} // Block from 8210AD18h-8210AD54h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8210AD54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210AD54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210AD54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210AD54);
		  /* 8210AD54h */ case    0:  		/* lwz R11, <#[R23 + 24]> */
		/* 8210AD54h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000018) );
		/* 8210AD54h case    0:*/		return 0x8210AD58;
		  /* 8210AD58h */ case    1:  		/* mr R3, R30 */
		/* 8210AD58h case    1:*/		regs.R3 = regs.R30;
		/* 8210AD58h case    1:*/		return 0x8210AD5C;
		  /* 8210AD5Ch */ case    2:  		/* stwx R29, <#[R11 + R26]> */
		/* 8210AD5Ch case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 8210AD5Ch case    2:*/		return 0x8210AD60;
		  /* 8210AD60h */ case    3:  		/* lwz R11, <#[R23 + 24]> */
		/* 8210AD60h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000018) );
		/* 8210AD60h case    3:*/		return 0x8210AD64;
		  /* 8210AD64h */ case    4:  		/* add R11, R11, R26 */
		/* 8210AD64h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R26);
		/* 8210AD64h case    4:*/		return 0x8210AD68;
		  /* 8210AD68h */ case    5:  		/* stw R28, <#[R11 + 4]> */
		/* 8210AD68h case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000004) );
		/* 8210AD68h case    5:*/		return 0x8210AD6C;
		  /* 8210AD6Ch */ case    6:  		/* bl 1123924 */
		/* 8210AD6Ch case    6:*/		regs.LR = 0x8210AD70; return 0x8221D3C0;
		/* 8210AD6Ch case    6:*/		return 0x8210AD70;
		  /* 8210AD70h */ case    7:  		/* mr R3, R30 */
		/* 8210AD70h case    7:*/		regs.R3 = regs.R30;
		/* 8210AD70h case    7:*/		return 0x8210AD74;
		  /* 8210AD74h */ case    8:  		/* bl -59268 */
		/* 8210AD74h case    8:*/		regs.LR = 0x8210AD78; return 0x820FC5F0;
		/* 8210AD74h case    8:*/		return 0x8210AD78;
		  /* 8210AD78h */ case    9:  		/* lwz R11, <#[R23 + 12]> */
		/* 8210AD78h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210AD78h case    9:*/		return 0x8210AD7C;
		  /* 8210AD7Ch */ case   10:  		/* addi R19, R19, 1 */
		/* 8210AD7Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x1);
		/* 8210AD7Ch case   10:*/		return 0x8210AD80;
		  /* 8210AD80h */ case   11:  		/* addi R11, R11, -1 */
		/* 8210AD80h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8210AD80h case   11:*/		return 0x8210AD84;
		  /* 8210AD84h */ case   12:  		/* stw R19, <#[R1 + 80]> */
		/* 8210AD84h case   12:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000050) );
		/* 8210AD84h case   12:*/		return 0x8210AD88;
		  /* 8210AD88h */ case   13:  		/* mr R20, R17 */
		/* 8210AD88h case   13:*/		regs.R20 = regs.R17;
		/* 8210AD88h case   13:*/		return 0x8210AD8C;
		  /* 8210AD8Ch */ case   14:  		/* stw R11, <#[R23 + 12]> */
		/* 8210AD8Ch case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210AD8Ch case   14:*/		return 0x8210AD90;
	}
	return 0x8210AD90;
} // Block from 8210AD54h-8210AD90h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8210AD90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210AD90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210AD90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210AD90);
		  /* 8210AD90h */ case    0:  		/* lwz R11, <#[R23 + 12]> */
		/* 8210AD90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210AD90h case    0:*/		return 0x8210AD94;
		  /* 8210AD94h */ case    1:  		/* addi R25, R25, 1 */
		/* 8210AD94h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 8210AD94h case    1:*/		return 0x8210AD98;
		  /* 8210AD98h */ case    2:  		/* addi R26, R26, 4 */
		/* 8210AD98h case    2:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 8210AD98h case    2:*/		return 0x8210AD9C;
		  /* 8210AD9Ch */ case    3:  		/* cmplw CR6, R25, R11 */
		/* 8210AD9Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 8210AD9Ch case    3:*/		return 0x8210ADA0;
		  /* 8210ADA0h */ case    4:  		/* bc 12, CR6_LT, -492 */
		/* 8210ADA0h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210ABB4;  }
		/* 8210ADA0h case    4:*/		return 0x8210ADA4;
		  /* 8210ADA4h */ case    5:  		/* cmpwi CR6, R20, 0 */
		/* 8210ADA4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 8210ADA4h case    5:*/		return 0x8210ADA8;
		  /* 8210ADA8h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 8210ADA8h case    6:*/		if ( regs.CR[6].eq ) { return 0x8210ADB4;  }
		/* 8210ADA8h case    6:*/		return 0x8210ADAC;
		  /* 8210ADACh */ case    7:  		/* mr R3, R23 */
		/* 8210ADACh case    7:*/		regs.R3 = regs.R23;
		/* 8210ADACh case    7:*/		return 0x8210ADB0;
		  /* 8210ADB0h */ case    8:  		/* bl -21016 */
		/* 8210ADB0h case    8:*/		regs.LR = 0x8210ADB4; return 0x82105B98;
		/* 8210ADB0h case    8:*/		return 0x8210ADB4;
	}
	return 0x8210ADB4;
} // Block from 8210AD90h-8210ADB4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8210ADB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210ADB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210ADB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210ADB4);
		  /* 8210ADB4h */ case    0:  		/* lwz R11, <#[R23 + 108]> */
		/* 8210ADB4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000006C) );
		/* 8210ADB4h case    0:*/		return 0x8210ADB8;
		  /* 8210ADB8h */ case    1:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 8210ADB8h case    1:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 8210ADB8h case    1:*/		return 0x8210ADBC;
		  /* 8210ADBCh */ case    2:  		/* bc 12, CR0_EQ, 488 */
		/* 8210ADBCh case    2:*/		if ( regs.CR[0].eq ) { return 0x8210AFA4;  }
		/* 8210ADBCh case    2:*/		return 0x8210ADC0;
		  /* 8210ADC0h */ case    3:  		/* lwz R22, <#[R23 + 12]> */
		/* 8210ADC0h case    3:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210ADC0h case    3:*/		return 0x8210ADC4;
		  /* 8210ADC4h */ case    4:  		/* mr R24, R15 */
		/* 8210ADC4h case    4:*/		regs.R24 = regs.R15;
		/* 8210ADC4h case    4:*/		return 0x8210ADC8;
		  /* 8210ADC8h */ case    5:  		/* cmplwi CR6, R22, 0 */
		/* 8210ADC8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 8210ADC8h case    5:*/		return 0x8210ADCC;
		  /* 8210ADCCh */ case    6:  		/* bc 12, CR6_EQ, 472 */
		/* 8210ADCCh case    6:*/		if ( regs.CR[6].eq ) { return 0x8210AFA4;  }
		/* 8210ADCCh case    6:*/		return 0x8210ADD0;
		  /* 8210ADD0h */ case    7:  		/* mr R25, R15 */
		/* 8210ADD0h case    7:*/		regs.R25 = regs.R15;
		/* 8210ADD0h case    7:*/		return 0x8210ADD4;
		  /* 8210ADD4h */ case    8:  		/* lwz R11, <#[R23 + 24]> */
		/* 8210ADD4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000018) );
		/* 8210ADD4h case    8:*/		return 0x8210ADD8;
		  /* 8210ADD8h */ case    9:  		/* lwzx R29, <#[R11 + R25]> */
		/* 8210ADD8h case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 8210ADD8h case    9:*/		return 0x8210ADDC;
		  /* 8210ADDCh */ case   10:  		/* lwz R11, <#[R29]> */
		/* 8210ADDCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8210ADDCh case   10:*/		return 0x8210ADE0;
		  /* 8210ADE0h */ case   11:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 8210ADE0h case   11:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 8210ADE0h case   11:*/		return 0x8210ADE4;
		  /* 8210ADE4h */ case   12:  		/* bc 12, CR0_EQ, 432 */
		/* 8210ADE4h case   12:*/		if ( regs.CR[0].eq ) { return 0x8210AF94;  }
		/* 8210ADE4h case   12:*/		return 0x8210ADE8;
		  /* 8210ADE8h */ case   13:  		/* lwz R4, <#[R29 + 12]> */
		/* 8210ADE8h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x0000000C) );
		/* 8210ADE8h case   13:*/		return 0x8210ADEC;
		  /* 8210ADECh */ case   14:  		/* cmplwi CR6, R4, 0 */
		/* 8210ADECh case   14:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8210ADECh case   14:*/		return 0x8210ADF0;
		  /* 8210ADF0h */ case   15:  		/* bc 12, CR6_EQ, 420 */
		/* 8210ADF0h case   15:*/		if ( regs.CR[6].eq ) { return 0x8210AF94;  }
		/* 8210ADF0h case   15:*/		return 0x8210ADF4;
		  /* 8210ADF4h */ case   16:  		/* lwz R11, <#[R29 + 16]> */
		/* 8210ADF4h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 8210ADF4h case   16:*/		return 0x8210ADF8;
		  /* 8210ADF8h */ case   17:  		/* lwz R7, <#[R23 + 20]> */
		/* 8210ADF8h case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R23 + 0x00000014) );
		/* 8210ADF8h case   17:*/		return 0x8210ADFC;
		  /* 8210ADFCh */ case   18:  		/* lwz R10, <#[R23 + 16]> */
		/* 8210ADFCh case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000010) );
		/* 8210ADFCh case   18:*/		return 0x8210AE00;
		  /* 8210AE00h */ case   19:  		/* lwz R11, <#[R11]> */
		/* 8210AE00h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8210AE00h case   19:*/		return 0x8210AE04;
		  /* 8210AE04h */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210AE04h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210AE04h case   20:*/		return 0x8210AE08;
		  /* 8210AE08h */ case   21:  		/* lwzx R11, <#[R11 + R7]> */
		/* 8210AE08h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 8210AE08h case   21:*/		return 0x8210AE0C;
		  /* 8210AE0Ch */ case   22:  		/* lwz R11, <#[R11 + 4]> */
		/* 8210AE0Ch case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8210AE0Ch case   22:*/		return 0x8210AE10;
		  /* 8210AE10h */ case   23:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210AE10h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210AE10h case   23:*/		return 0x8210AE14;
		  /* 8210AE14h */ case   24:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210AE14h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210AE14h case   24:*/		return 0x8210AE18;
		  /* 8210AE18h */ case   25:  		/* lwz R11, <#[R11 + 4]> */
		/* 8210AE18h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8210AE18h case   25:*/		return 0x8210AE1C;
		  /* 8210AE1Ch */ case   26:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 8210AE1Ch case   26:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 8210AE1Ch case   26:*/		return 0x8210AE20;
		  /* 8210AE20h */ case   27:  		/* bc 12, CR0_EQ, 372 */
		/* 8210AE20h case   27:*/		if ( regs.CR[0].eq ) { return 0x8210AF94;  }
		/* 8210AE20h case   27:*/		return 0x8210AE24;
		  /* 8210AE24h */ case   28:  		/* lwz R8, <#[R29 + 4]> */
		/* 8210AE24h case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000004) );
		/* 8210AE24h case   28:*/		return 0x8210AE28;
		  /* 8210AE28h */ case   29:  		/* mr R11, R15 */
		/* 8210AE28h case   29:*/		regs.R11 = regs.R15;
		/* 8210AE28h case   29:*/		return 0x8210AE2C;
		  /* 8210AE2Ch */ case   30:  		/* cmplwi CR6, R8, 0 */
		/* 8210AE2Ch case   30:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8210AE2Ch case   30:*/		return 0x8210AE30;
		  /* 8210AE30h */ case   31:  		/* bc 12, CR6_EQ, 52 */
		/* 8210AE30h case   31:*/		if ( regs.CR[6].eq ) { return 0x8210AE64;  }
		/* 8210AE30h case   31:*/		return 0x8210AE34;
		  /* 8210AE34h */ case   32:  		/* lwz R9, <#[R29 + 8]> */
		/* 8210AE34h case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 8210AE34h case   32:*/		return 0x8210AE38;
		  /* 8210AE38h */ case   33:  		/* mr R10, R15 */
		/* 8210AE38h case   33:*/		regs.R10 = regs.R15;
		/* 8210AE38h case   33:*/		return 0x8210AE3C;
		  /* 8210AE3Ch */ case   34:  		/* lwzx R6, <#[R9 + R10]> */
		/* 8210AE3Ch case   34:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210AE3Ch case   34:*/		return 0x8210AE40;
		  /* 8210AE40h */ case   35:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 8210AE40h case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 8210AE40h case   35:*/		return 0x8210AE44;
		  /* 8210AE44h */ case   36:  		/* lwzx R6, <#[R6 + R7]> */
		/* 8210AE44h case   36:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R7 + 0x00000000) );
		/* 8210AE44h case   36:*/		return 0x8210AE48;
		  /* 8210AE48h */ case   37:  		/* lwz R6, <#[R6 + 16]> */
		/* 8210AE48h case   37:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000010) );
		/* 8210AE48h case   37:*/		return 0x8210AE4C;
		  /* 8210AE4Ch */ case   38:  		/* cmplw CR6, R11, R6 */
		/* 8210AE4Ch case   38:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 8210AE4Ch case   38:*/		return 0x8210AE50;
		  /* 8210AE50h */ case   39:  		/* bc 4, CR6_EQ, 20 */
		/* 8210AE50h case   39:*/		if ( !regs.CR[6].eq ) { return 0x8210AE64;  }
		/* 8210AE50h case   39:*/		return 0x8210AE54;
		  /* 8210AE54h */ case   40:  		/* addi R11, R11, 1 */
		/* 8210AE54h case   40:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210AE54h case   40:*/		return 0x8210AE58;
		  /* 8210AE58h */ case   41:  		/* addi R10, R10, 4 */
		/* 8210AE58h case   41:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210AE58h case   41:*/		return 0x8210AE5C;
		  /* 8210AE5Ch */ case   42:  		/* cmplw CR6, R11, R8 */
		/* 8210AE5Ch case   42:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8210AE5Ch case   42:*/		return 0x8210AE60;
		  /* 8210AE60h */ case   43:  		/* bc 12, CR6_LT, -36 */
		/* 8210AE60h case   43:*/		if ( regs.CR[6].lt ) { return 0x8210AE3C;  }
		/* 8210AE60h case   43:*/		return 0x8210AE64;
	}
	return 0x8210AE64;
} // Block from 8210ADB4h-8210AE64h (44 instructions)

//////////////////////////////////////////////////////
// Block at 8210AE64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210AE64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210AE64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210AE64);
		  /* 8210AE64h */ case    0:  		/* cmplw CR6, R11, R8 */
		/* 8210AE64h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8210AE64h case    0:*/		return 0x8210AE68;
		  /* 8210AE68h */ case    1:  		/* bc 12, CR6_EQ, 300 */
		/* 8210AE68h case    1:*/		if ( regs.CR[6].eq ) { return 0x8210AF94;  }
		/* 8210AE68h case    1:*/		return 0x8210AE6C;
		  /* 8210AE6Ch */ case    2:  		/* mr R6, R18 */
		/* 8210AE6Ch case    2:*/		regs.R6 = regs.R18;
		/* 8210AE6Ch case    2:*/		return 0x8210AE70;
		  /* 8210AE70h */ case    3:  		/* rlwimi R4, R17, 28, 0, 11 */
		/* 8210AE70h case    3:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R4,regs.R17);
		/* 8210AE70h case    3:*/		return 0x8210AE74;
		  /* 8210AE74h */ case    4:  		/* mr R5, R18 */
		/* 8210AE74h case    4:*/		regs.R5 = regs.R18;
		/* 8210AE74h case    4:*/		return 0x8210AE78;
		  /* 8210AE78h */ case    5:  		/* mr R3, R23 */
		/* 8210AE78h case    5:*/		regs.R3 = regs.R23;
		/* 8210AE78h case    5:*/		return 0x8210AE7C;
		  /* 8210AE7Ch */ case    6:  		/* bl -56244 */
		/* 8210AE7Ch case    6:*/		regs.LR = 0x8210AE80; return 0x820FD2C8;
		/* 8210AE7Ch case    6:*/		return 0x8210AE80;
		  /* 8210AE80h */ case    7:  		/* cmpwi CR6, R3, -1 */
		/* 8210AE80h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8210AE80h case    7:*/		return 0x8210AE84;
		  /* 8210AE84h */ case    8:  		/* bc 12, CR6_EQ, 6932 */
		/* 8210AE84h case    8:*/		if ( regs.CR[6].eq ) { return 0x8210C998;  }
		/* 8210AE84h case    8:*/		return 0x8210AE88;
		  /* 8210AE88h */ case    9:  		/* lwz R11, <#[R23 + 24]> */
		/* 8210AE88h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000018) );
		/* 8210AE88h case    9:*/		return 0x8210AE8C;
		  /* 8210AE8Ch */ case   10:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 8210AE8Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 8210AE8Ch case   10:*/		return 0x8210AE90;
		  /* 8210AE90h */ case   11:  		/* mr R4, R29 */
		/* 8210AE90h case   11:*/		regs.R4 = regs.R29;
		/* 8210AE90h case   11:*/		return 0x8210AE94;
		  /* 8210AE94h */ case   12:  		/* lwzx R30, <#[R10 + R11]> */
		/* 8210AE94h case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210AE94h case   12:*/		return 0x8210AE98;
		  /* 8210AE98h */ case   13:  		/* mr R3, R30 */
		/* 8210AE98h case   13:*/		regs.R3 = regs.R30;
		/* 8210AE98h case   13:*/		return 0x8210AE9C;
		  /* 8210AE9Ch */ case   14:  		/* bl -61356 */
		/* 8210AE9Ch case   14:*/		regs.LR = 0x8210AEA0; return 0x820FBEF0;
		/* 8210AE9Ch case   14:*/		return 0x8210AEA0;
		  /* 8210AEA0h */ case   15:  		/* lwz R11, <#[R29 + 16]> */
		/* 8210AEA0h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 8210AEA0h case   15:*/		return 0x8210AEA4;
		  /* 8210AEA4h */ case   16:  		/* lwz R10, <#[R23 + 20]> */
		/* 8210AEA4h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000014) );
		/* 8210AEA4h case   16:*/		return 0x8210AEA8;
		  /* 8210AEA8h */ case   17:  		/* mr R28, R15 */
		/* 8210AEA8h case   17:*/		regs.R28 = regs.R15;
		/* 8210AEA8h case   17:*/		return 0x8210AEAC;
		  /* 8210AEACh */ case   18:  		/* lwz R9, <#[R29 + 12]> */
		/* 8210AEACh case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x0000000C) );
		/* 8210AEACh case   18:*/		return 0x8210AEB0;
		  /* 8210AEB0h */ case   19:  		/* cmplwi CR6, R9, 0 */
		/* 8210AEB0h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8210AEB0h case   19:*/		return 0x8210AEB4;
		  /* 8210AEB4h */ case   20:  		/* lwz R11, <#[R11]> */
		/* 8210AEB4h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8210AEB4h case   20:*/		return 0x8210AEB8;
		  /* 8210AEB8h */ case   21:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210AEB8h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210AEB8h case   21:*/		return 0x8210AEBC;
		  /* 8210AEBCh */ case   22:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210AEBCh case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210AEBCh case   22:*/		return 0x8210AEC0;
		  /* 8210AEC0h */ case   23:  		/* lwz R27, <#[R11 + 24]> */
		/* 8210AEC0h case   23:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000018) );
		/* 8210AEC0h case   23:*/		return 0x8210AEC4;
		  /* 8210AEC4h */ case   24:  		/* lwz R26, <#[R11 + 20]> */
		/* 8210AEC4h case   24:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x00000014) );
		/* 8210AEC4h case   24:*/		return 0x8210AEC8;
		  /* 8210AEC8h */ case   25:  		/* bc 4, CR6_GT, 192 */
		/* 8210AEC8h case   25:*/		if ( !regs.CR[6].gt ) { return 0x8210AF88;  }
		/* 8210AEC8h case   25:*/		return 0x8210AECC;
		  /* 8210AECCh */ case   26:  		/* mr R31, R15 */
		/* 8210AECCh case   26:*/		regs.R31 = regs.R15;
		/* 8210AECCh case   26:*/		return 0x8210AED0;
		  /* 8210AED0h */ case   27:  		/* lwz R11, <#[R29 + 16]> */
		/* 8210AED0h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 8210AED0h case   27:*/		return 0x8210AED4;
		  /* 8210AED4h */ case   28:  		/* mr R6, R28 */
		/* 8210AED4h case   28:*/		regs.R6 = regs.R28;
		/* 8210AED4h case   28:*/		return 0x8210AED8;
		  /* 8210AED8h */ case   29:  		/* lwz R10, <#[R30 + 16]> */
		/* 8210AED8h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 8210AED8h case   29:*/		return 0x8210AEDC;
		  /* 8210AEDCh */ case   30:  		/* mr R5, R19 */
		/* 8210AEDCh case   30:*/		regs.R5 = regs.R19;
		/* 8210AEDCh case   30:*/		return 0x8210AEE0;
		  /* 8210AEE0h */ case   31:  		/* mr R3, R23 */
		/* 8210AEE0h case   31:*/		regs.R3 = regs.R23;
		/* 8210AEE0h case   31:*/		return 0x8210AEE4;
		  /* 8210AEE4h */ case   32:  		/* fmr FR1, FR31 */
		/* 8210AEE4h case   32:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8210AEE4h case   32:*/		return 0x8210AEE8;
		  /* 8210AEE8h */ case   33:  		/* lwzx R11, <#[R31 + R11]> */
		/* 8210AEE8h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8210AEE8h case   33:*/		return 0x8210AEEC;
		  /* 8210AEECh */ case   34:  		/* stwx R11, <#[R10 + R31]> */
		/* 8210AEECh case   34:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 8210AEECh case   34:*/		return 0x8210AEF0;
		  /* 8210AEF0h */ case   35:  		/* lwz R4, <#[R23 + 136]> */
		/* 8210AEF0h case   35:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R23 + 0x00000088) );
		/* 8210AEF0h case   35:*/		return 0x8210AEF4;
		  /* 8210AEF4h */ case   36:  		/* bl -56524 */
		/* 8210AEF4h case   36:*/		regs.LR = 0x8210AEF8; return 0x820FD228;
		/* 8210AEF4h case   36:*/		return 0x8210AEF8;
		  /* 8210AEF8h */ case   37:  		/* lwz R11, <#[R29 + 16]> */
		/* 8210AEF8h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 8210AEF8h case   37:*/		return 0x8210AEFC;
		  /* 8210AEFCh */ case   38:  		/* stwx R3, <#[R31 + R11]> */
		/* 8210AEFCh case   38:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8210AEFCh case   38:*/		return 0x8210AF00;
	}
	return 0x8210AF00;
} // Block from 8210AE64h-8210AF00h (39 instructions)

//////////////////////////////////////////////////////
// Block at 8210AF00h
// Function '?MarkVarying@CProgram@D3DXShader@@AAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210AF00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210AF00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210AF00);
		  /* 8210AF00h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 8210AF00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8210AF00h case    0:*/		return 0x8210AF04;
		  /* 8210AF04h */ case    1:  		/* stwx R3, <#[R31 + R11]> */
		/* 8210AF04h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8210AF04h case    1:*/		return 0x8210AF08;
		  /* 8210AF08h */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 8210AF08h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8210AF08h case    2:*/		return 0x8210AF0C;
		  /* 8210AF0Ch */ case    3:  		/* lwzx R11, <#[R31 + R11]> */
		/* 8210AF0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8210AF0Ch case    3:*/		return 0x8210AF10;
		  /* 8210AF10h */ case    4:  		/* cmpwi CR6, R11, -1 */
		/* 8210AF10h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210AF10h case    4:*/		return 0x8210AF14;
		  /* 8210AF14h */ case    5:  		/* bc 12, CR6_EQ, 6788 */
		/* 8210AF14h case    5:*/		if ( regs.CR[6].eq ) { return 0x8210C998;  }
		/* 8210AF14h case    5:*/		return 0x8210AF18;
		  /* 8210AF18h */ case    6:  		/* lwz R11, <#[R30 + 8]> */
		/* 8210AF18h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8210AF18h case    6:*/		return 0x8210AF1C;
		  /* 8210AF1Ch */ case    7:  		/* addi R28, R28, 1 */
		/* 8210AF1Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8210AF1Ch case    7:*/		return 0x8210AF20;
		  /* 8210AF20h */ case    8:  		/* lwz R10, <#[R23 + 20]> */
		/* 8210AF20h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000014) );
		/* 8210AF20h case    8:*/		return 0x8210AF24;
		  /* 8210AF24h */ case    9:  		/* lwzx R11, <#[R31 + R11]> */
		/* 8210AF24h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8210AF24h case    9:*/		return 0x8210AF28;
		  /* 8210AF28h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210AF28h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210AF28h case   10:*/		return 0x8210AF2C;
		  /* 8210AF2Ch */ case   11:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210AF2Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210AF2Ch case   11:*/		return 0x8210AF30;
		  /* 8210AF30h */ case   12:  		/* stw R27, <#[R11 + 24]> */
		/* 8210AF30h case   12:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000018) );
		/* 8210AF30h case   12:*/		return 0x8210AF34;
		  /* 8210AF34h */ case   13:  		/* lwz R11, <#[R30 + 8]> */
		/* 8210AF34h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8210AF34h case   13:*/		return 0x8210AF38;
		  /* 8210AF38h */ case   14:  		/* lwz R10, <#[R23 + 20]> */
		/* 8210AF38h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000014) );
		/* 8210AF38h case   14:*/		return 0x8210AF3C;
		  /* 8210AF3Ch */ case   15:  		/* lwzx R11, <#[R31 + R11]> */
		/* 8210AF3Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8210AF3Ch case   15:*/		return 0x8210AF40;
		  /* 8210AF40h */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210AF40h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210AF40h case   16:*/		return 0x8210AF44;
		  /* 8210AF44h */ case   17:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210AF44h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210AF44h case   17:*/		return 0x8210AF48;
		  /* 8210AF48h */ case   18:  		/* stw R26, <#[R11 + 20]> */
		/* 8210AF48h case   18:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000014) );
		/* 8210AF48h case   18:*/		return 0x8210AF4C;
		  /* 8210AF4Ch */ case   19:  		/* lwz R11, <#[R30 + 8]> */
		/* 8210AF4Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8210AF4Ch case   19:*/		return 0x8210AF50;
		  /* 8210AF50h */ case   20:  		/* lwz R10, <#[R30 + 16]> */
		/* 8210AF50h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 8210AF50h case   20:*/		return 0x8210AF54;
		  /* 8210AF54h */ case   21:  		/* lwz R9, <#[R23 + 20]> */
		/* 8210AF54h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000014) );
		/* 8210AF54h case   21:*/		return 0x8210AF58;
		  /* 8210AF58h */ case   22:  		/* lwzx R11, <#[R31 + R11]> */
		/* 8210AF58h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8210AF58h case   22:*/		return 0x8210AF5C;
		  /* 8210AF5Ch */ case   23:  		/* lwzx R10, <#[R10 + R31]> */
		/* 8210AF5Ch case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 8210AF5Ch case   23:*/		return 0x8210AF60;
		  /* 8210AF60h */ case   24:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210AF60h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210AF60h case   24:*/		return 0x8210AF64;
		  /* 8210AF64h */ case   25:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210AF64h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210AF64h case   25:*/		return 0x8210AF68;
		  /* 8210AF68h */ case   26:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210AF68h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210AF68h case   26:*/		return 0x8210AF6C;
		  /* 8210AF6Ch */ case   27:  		/* lwz R10, <#[R10]> */
		/* 8210AF6Ch case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 8210AF6Ch case   27:*/		return 0x8210AF70;
		  /* 8210AF70h */ case   28:  		/* addi R31, R31, 4 */
		/* 8210AF70h case   28:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8210AF70h case   28:*/		return 0x8210AF74;
		  /* 8210AF74h */ case   29:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210AF74h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210AF74h case   29:*/		return 0x8210AF78;
		  /* 8210AF78h */ case   30:  		/* stw R10, <#[R11]> */
		/* 8210AF78h case   30:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210AF78h case   30:*/		return 0x8210AF7C;
		  /* 8210AF7Ch */ case   31:  		/* lwz R11, <#[R29 + 12]> */
		/* 8210AF7Ch case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 8210AF7Ch case   31:*/		return 0x8210AF80;
		  /* 8210AF80h */ case   32:  		/* cmplw CR6, R28, R11 */
		/* 8210AF80h case   32:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 8210AF80h case   32:*/		return 0x8210AF84;
		  /* 8210AF84h */ case   33:  		/* bc 12, CR6_LT, -180 */
		/* 8210AF84h case   33:*/		if ( regs.CR[6].lt ) { return 0x8210AED0;  }
		/* 8210AF84h case   33:*/		return 0x8210AF88;
	}
	return 0x8210AF88;
} // Block from 8210AF00h-8210AF88h (34 instructions)

//////////////////////////////////////////////////////
// Block at 8210AF88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210AF88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210AF88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210AF88);
		  /* 8210AF88h */ case    0:  		/* addi R19, R19, 1 */
		/* 8210AF88h case    0:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x1);
		/* 8210AF88h case    0:*/		return 0x8210AF8C;
		  /* 8210AF8Ch */ case    1:  		/* mr R20, R17 */
		/* 8210AF8Ch case    1:*/		regs.R20 = regs.R17;
		/* 8210AF8Ch case    1:*/		return 0x8210AF90;
		  /* 8210AF90h */ case    2:  		/* stw R19, <#[R1 + 80]> */
		/* 8210AF90h case    2:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000050) );
		/* 8210AF90h case    2:*/		return 0x8210AF94;
	}
	return 0x8210AF94;
} // Block from 8210AF88h-8210AF94h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210AF94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210AF94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210AF94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210AF94);
		  /* 8210AF94h */ case    0:  		/* addi R24, R24, 1 */
		/* 8210AF94h case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 8210AF94h case    0:*/		return 0x8210AF98;
		  /* 8210AF98h */ case    1:  		/* addi R25, R25, 4 */
		/* 8210AF98h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 8210AF98h case    1:*/		return 0x8210AF9C;
		  /* 8210AF9Ch */ case    2:  		/* cmplw CR6, R24, R22 */
		/* 8210AF9Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R22);
		/* 8210AF9Ch case    2:*/		return 0x8210AFA0;
		  /* 8210AFA0h */ case    3:  		/* bc 12, CR6_LT, -460 */
		/* 8210AFA0h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210ADD4;  }
		/* 8210AFA0h case    3:*/		return 0x8210AFA4;
	}
	return 0x8210AFA4;
} // Block from 8210AF94h-8210AFA4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210AFA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210AFA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210AFA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210AFA4);
		  /* 8210AFA4h */ case    0:  		/* lwz R11, <#[R23 + 76]> */
		/* 8210AFA4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000004C) );
		/* 8210AFA4h case    0:*/		return 0x8210AFA8;
		  /* 8210AFA8h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8210AFA8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210AFA8h case    1:*/		return 0x8210AFAC;
		  /* 8210AFACh */ case    2:  		/* bc 12, CR6_EQ, 260 */
		/* 8210AFACh case    2:*/		if ( regs.CR[6].eq ) { return 0x8210B0B0;  }
		/* 8210AFACh case    2:*/		return 0x8210AFB0;
		  /* 8210AFB0h */ case    3:  		/* lwz R11, <#[R23 + 112]> */
		/* 8210AFB0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000070) );
		/* 8210AFB0h case    3:*/		return 0x8210AFB4;
		  /* 8210AFB4h */ case    4:  		/* rlwinm. R11, R11, 0, 6, 6 */
		/* 8210AFB4h case    4:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R11,regs.R11);
		/* 8210AFB4h case    4:*/		return 0x8210AFB8;
		  /* 8210AFB8h */ case    5:  		/* bc 4, CR0_EQ, 248 */
		/* 8210AFB8h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8210B0B0;  }
		/* 8210AFB8h case    5:*/		return 0x8210AFBC;
		  /* 8210AFBCh */ case    6:  		/* lwz R11, <#[R23 + 12]> */
		/* 8210AFBCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210AFBCh case    6:*/		return 0x8210AFC0;
		  /* 8210AFC0h */ case    7:  		/* mr R29, R15 */
		/* 8210AFC0h case    7:*/		regs.R29 = regs.R15;
		/* 8210AFC0h case    7:*/		return 0x8210AFC4;
		  /* 8210AFC4h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 8210AFC4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210AFC4h case    8:*/		return 0x8210AFC8;
		  /* 8210AFC8h */ case    9:  		/* bc 4, CR6_GT, 232 */
		/* 8210AFC8h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8210B0B0;  }
		/* 8210AFC8h case    9:*/		return 0x8210AFCC;
		  /* 8210AFCCh */ case   10:  		/* lwz R11, <#[R23 + 24]> */
		/* 8210AFCCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000018) );
		/* 8210AFCCh case   10:*/		return 0x8210AFD0;
		  /* 8210AFD0h */ case   11:  		/* rlwinm R10, R29, 2, 0, 29 */
		/* 8210AFD0h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R29);
		/* 8210AFD0h case   11:*/		return 0x8210AFD4;
		  /* 8210AFD4h */ case   12:  		/* lis R9, 24576 */
		/* 8210AFD4h case   12:*/		cpu::op::lis<0>(regs,&regs.R9,0x6000);
		/* 8210AFD4h case   12:*/		return 0x8210AFD8;
		  /* 8210AFD8h */ case   13:  		/* lwzx R27, <#[R10 + R11]> */
		/* 8210AFD8h case   13:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210AFD8h case   13:*/		return 0x8210AFDC;
		  /* 8210AFDCh */ case   14:  		/* lwz R11, <#[R27]> */
		/* 8210AFDCh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8210AFDCh case   14:*/		return 0x8210AFE0;
		  /* 8210AFE0h */ case   15:  		/* rlwinm R11, R11, 0, 0, 3 */
		/* 8210AFE0h case   15:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R11,regs.R11);
		/* 8210AFE0h case   15:*/		return 0x8210AFE4;
		  /* 8210AFE4h */ case   16:  		/* cmplw CR6, R11, R9 */
		/* 8210AFE4h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210AFE4h case   16:*/		return 0x8210AFE8;
		  /* 8210AFE8h */ case   17:  		/* bc 4, CR6_EQ, 180 */
		/* 8210AFE8h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8210B09C;  }
		/* 8210AFE8h case   17:*/		return 0x8210AFEC;
		  /* 8210AFECh */ case   18:  		/* li R4, 1 */
		/* 8210AFECh case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8210AFECh case   18:*/		return 0x8210AFF0;
		  /* 8210AFF0h */ case   19:  		/* mr R28, R17 */
		/* 8210AFF0h case   19:*/		regs.R28 = regs.R17;
		/* 8210AFF0h case   19:*/		return 0x8210AFF4;
		  /* 8210AFF4h */ case   20:  		/* b 148 */
		/* 8210AFF4h case   20:*/		return 0x8210B088;
		/* 8210AFF4h case   20:*/		return 0x8210AFF8;
		  /* 8210AFF8h */ case   21:  		/* lwz R5, <#[R1 + 88]> */
		/* 8210AFF8h case   21:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000058) );
		/* 8210AFF8h case   21:*/		return 0x8210AFFC;
		  /* 8210AFFCh */ case   22:  		/* mr R11, R15 */
		/* 8210AFFCh case   22:*/		regs.R11 = regs.R15;
		/* 8210AFFCh case   22:*/		return 0x8210B000;
		  /* 8210B000h */ case   23:  		/* cmplwi CR6, R3, 0 */
		/* 8210B000h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8210B000h case   23:*/		return 0x8210B004;
		  /* 8210B004h */ case   24:  		/* bc 12, CR6_EQ, 52 */
		/* 8210B004h case   24:*/		if ( regs.CR[6].eq ) { return 0x8210B038;  }
		/* 8210B004h case   24:*/		return 0x8210B008;
		  /* 8210B008h */ case   25:  		/* lwz R9, <#[R23 + 20]> */
		/* 8210B008h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000014) );
		/* 8210B008h case   25:*/		return 0x8210B00C;
		  /* 8210B00Ch */ case   26:  		/* mr R10, R5 */
		/* 8210B00Ch case   26:*/		regs.R10 = regs.R5;
		/* 8210B00Ch case   26:*/		return 0x8210B010;
		  /* 8210B010h */ case   27:  		/* lwz R8, <#[R10]> */
		/* 8210B010h case   27:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8210B010h case   27:*/		return 0x8210B014;
		  /* 8210B014h */ case   28:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8210B014h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8210B014h case   28:*/		return 0x8210B018;
		  /* 8210B018h */ case   29:  		/* lwzx R8, <#[R8 + R9]> */
		/* 8210B018h case   29:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 8210B018h case   29:*/		return 0x8210B01C;
		  /* 8210B01Ch */ case   30:  		/* lwz R8, <#[R8 + 16]> */
		/* 8210B01Ch case   30:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000010) );
		/* 8210B01Ch case   30:*/		return 0x8210B020;
		  /* 8210B020h */ case   31:  		/* cmplw CR6, R8, R11 */
		/* 8210B020h case   31:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8210B020h case   31:*/		return 0x8210B024;
		  /* 8210B024h */ case   32:  		/* bc 4, CR6_EQ, 20 */
		/* 8210B024h case   32:*/		if ( !regs.CR[6].eq ) { return 0x8210B038;  }
		/* 8210B024h case   32:*/		return 0x8210B028;
		  /* 8210B028h */ case   33:  		/* addi R11, R11, 1 */
		/* 8210B028h case   33:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210B028h case   33:*/		return 0x8210B02C;
		  /* 8210B02Ch */ case   34:  		/* addi R10, R10, 4 */
		/* 8210B02Ch case   34:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210B02Ch case   34:*/		return 0x8210B030;
		  /* 8210B030h */ case   35:  		/* cmplw CR6, R11, R3 */
		/* 8210B030h case   35:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R3);
		/* 8210B030h case   35:*/		return 0x8210B034;
		  /* 8210B034h */ case   36:  		/* bc 12, CR6_LT, -36 */
		/* 8210B034h case   36:*/		if ( regs.CR[6].lt ) { return 0x8210B010;  }
		/* 8210B034h case   36:*/		return 0x8210B038;
	}
	return 0x8210B038;
} // Block from 8210AFA4h-8210B038h (37 instructions)

//////////////////////////////////////////////////////
// Block at 8210B038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B038);
		  /* 8210B038h */ case    0:  		/* cmplw CR6, R11, R3 */
		/* 8210B038h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R3);
		/* 8210B038h case    0:*/		return 0x8210B03C;
		  /* 8210B03Ch */ case    1:  		/* bc 12, CR6_EQ, 68 */
		/* 8210B03Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8210B080;  }
		/* 8210B03Ch case    1:*/		return 0x8210B040;
		  /* 8210B040h */ case    2:  		/* mr R6, R3 */
		/* 8210B040h case    2:*/		regs.R6 = regs.R3;
		/* 8210B040h case    2:*/		return 0x8210B044;
		  /* 8210B044h */ case    3:  		/* lwz R30, <#[R23 + 12]> */
		/* 8210B044h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210B044h case    3:*/		return 0x8210B048;
		  /* 8210B048h */ case    4:  		/* addi R7, R1, 80 */
		/* 8210B048h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 8210B048h case    4:*/		return 0x8210B04C;
		  /* 8210B04Ch */ case    5:  		/* mr R4, R29 */
		/* 8210B04Ch case    5:*/		regs.R4 = regs.R29;
		/* 8210B04Ch case    5:*/		return 0x8210B050;
		  /* 8210B050h */ case    6:  		/* mr R3, R23 */
		/* 8210B050h case    6:*/		regs.R3 = regs.R23;
		/* 8210B050h case    6:*/		return 0x8210B054;
		  /* 8210B054h */ case    7:  		/* bl -47500 */
		/* 8210B054h case    7:*/		regs.LR = 0x8210B058; return 0x820FF6C8;
		/* 8210B054h case    7:*/		return 0x8210B058;
		  /* 8210B058h */ case    8:  		/* or. R31, R3, R3 */
		/* 8210B058h case    8:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 8210B058h case    8:*/		return 0x8210B05C;
		  /* 8210B05Ch */ case    9:  		/* bc 12, CR0_LT, 6432 */
		/* 8210B05Ch case    9:*/		if ( regs.CR[0].lt ) { return 0x8210C97C;  }
		/* 8210B05Ch case    9:*/		return 0x8210B060;
		  /* 8210B060h */ case   10:  		/* lwz R11, <#[R23 + 12]> */
		/* 8210B060h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210B060h case   10:*/		return 0x8210B064;
		  /* 8210B064h */ case   11:  		/* cmplw CR6, R11, R30 */
		/* 8210B064h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 8210B064h case   11:*/		return 0x8210B068;
		  /* 8210B068h */ case   12:  		/* bc 12, CR6_EQ, 20 */
		/* 8210B068h case   12:*/		if ( regs.CR[6].eq ) { return 0x8210B07C;  }
		/* 8210B068h case   12:*/		return 0x8210B06C;
		  /* 8210B06Ch */ case   13:  		/* subf R11, R30, R11 */
		/* 8210B06Ch case   13:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 8210B06Ch case   13:*/		return 0x8210B070;
		  /* 8210B070h */ case   14:  		/* mr R3, R23 */
		/* 8210B070h case   14:*/		regs.R3 = regs.R23;
		/* 8210B070h case   14:*/		return 0x8210B074;
		  /* 8210B074h */ case   15:  		/* add R29, R11, R29 */
		/* 8210B074h case   15:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R29);
		/* 8210B074h case   15:*/		return 0x8210B078;
		  /* 8210B078h */ case   16:  		/* bl -21728 */
		/* 8210B078h case   16:*/		regs.LR = 0x8210B07C; return 0x82105B98;
		/* 8210B078h case   16:*/		return 0x8210B07C;
	}
	return 0x8210B07C;
} // Block from 8210B038h-8210B07Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8210B07Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B07C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B07C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B07C);
		  /* 8210B07Ch */ case    0:  		/* mr R20, R17 */
		/* 8210B07Ch case    0:*/		regs.R20 = regs.R17;
		/* 8210B07Ch case    0:*/		return 0x8210B080;
	}
	return 0x8210B080;
} // Block from 8210B07Ch-8210B080h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210B080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B080);
		  /* 8210B080h */ case    0:  		/* addi R28, R28, 1 */
		/* 8210B080h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8210B080h case    0:*/		return 0x8210B084;
		  /* 8210B084h */ case    1:  		/* mr R4, R28 */
		/* 8210B084h case    1:*/		regs.R4 = regs.R28;
		/* 8210B084h case    1:*/		return 0x8210B088;
	}
	return 0x8210B088;
} // Block from 8210B080h-8210B088h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210B088h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B088);
		  /* 8210B088h */ case    0:  		/* addi R5, R1, 88 */
		/* 8210B088h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 8210B088h case    0:*/		return 0x8210B08C;
		  /* 8210B08Ch */ case    1:  		/* mr R3, R27 */
		/* 8210B08Ch case    1:*/		regs.R3 = regs.R27;
		/* 8210B08Ch case    1:*/		return 0x8210B090;
		  /* 8210B090h */ case    2:  		/* bl -61816 */
		/* 8210B090h case    2:*/		regs.LR = 0x8210B094; return 0x820FBF18;
		/* 8210B090h case    2:*/		return 0x8210B094;
		  /* 8210B094h */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 8210B094h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210B094h case    3:*/		return 0x8210B098;
		  /* 8210B098h */ case    4:  		/* bc 4, CR0_EQ, -160 */
		/* 8210B098h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8210AFF8;  }
		/* 8210B098h case    4:*/		return 0x8210B09C;
	}
	return 0x8210B09C;
} // Block from 8210B088h-8210B09Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210B09Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B09C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B09C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B09C);
		  /* 8210B09Ch */ case    0:  		/* lwz R11, <#[R23 + 12]> */
		/* 8210B09Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210B09Ch case    0:*/		return 0x8210B0A0;
		  /* 8210B0A0h */ case    1:  		/* addi R29, R29, 1 */
		/* 8210B0A0h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8210B0A0h case    1:*/		return 0x8210B0A4;
		  /* 8210B0A4h */ case    2:  		/* cmplw CR6, R29, R11 */
		/* 8210B0A4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8210B0A4h case    2:*/		return 0x8210B0A8;
		  /* 8210B0A8h */ case    3:  		/* bc 12, CR6_LT, -220 */
		/* 8210B0A8h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210AFCC;  }
		/* 8210B0A8h case    3:*/		return 0x8210B0AC;
		  /* 8210B0ACh */ case    4:  		/* lwz R19, <#[R1 + 80]> */
		/* 8210B0ACh case    4:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R1 + 0x00000050) );
		/* 8210B0ACh case    4:*/		return 0x8210B0B0;
	}
	return 0x8210B0B0;
} // Block from 8210B09Ch-8210B0B0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210B0B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B0B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B0B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B0B0);
		  /* 8210B0B0h */ case    0:  		/* lwz R11, <#[R23 + 76]> */
		/* 8210B0B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000004C) );
		/* 8210B0B0h case    0:*/		return 0x8210B0B4;
		  /* 8210B0B4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8210B0B4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210B0B4h case    1:*/		return 0x8210B0B8;
		  /* 8210B0B8h */ case    2:  		/* bc 12, CR6_EQ, 876 */
		/* 8210B0B8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8210B424;  }
		/* 8210B0B8h case    2:*/		return 0x8210B0BC;
		  /* 8210B0BCh */ case    3:  		/* lwz R11, <#[R23 + 12]> */
		/* 8210B0BCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210B0BCh case    3:*/		return 0x8210B0C0;
		  /* 8210B0C0h */ case    4:  		/* mr R21, R15 */
		/* 8210B0C0h case    4:*/		regs.R21 = regs.R15;
		/* 8210B0C0h case    4:*/		return 0x8210B0C4;
		  /* 8210B0C4h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8210B0C4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210B0C4h case    5:*/		return 0x8210B0C8;
		  /* 8210B0C8h */ case    6:  		/* bc 4, CR6_GT, 860 */
		/* 8210B0C8h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8210B424;  }
		/* 8210B0C8h case    6:*/		return 0x8210B0CC;
		  /* 8210B0CCh */ case    7:  		/* mr R22, R15 */
		/* 8210B0CCh case    7:*/		regs.R22 = regs.R15;
		/* 8210B0CCh case    7:*/		return 0x8210B0D0;
		  /* 8210B0D0h */ case    8:  		/* lwz R11, <#[R23 + 24]> */
		/* 8210B0D0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000018) );
		/* 8210B0D0h case    8:*/		return 0x8210B0D4;
		  /* 8210B0D4h */ case    9:  		/* lis R10, 4352 */
		/* 8210B0D4h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x1100);
		/* 8210B0D4h case    9:*/		return 0x8210B0D8;
		  /* 8210B0D8h */ case   10:  		/* lwzx R30, <#[R11 + R22]> */
		/* 8210B0D8h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R22 + 0x00000000) );
		/* 8210B0D8h case   10:*/		return 0x8210B0DC;
		  /* 8210B0DCh */ case   11:  		/* lwz R11, <#[R30]> */
		/* 8210B0DCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8210B0DCh case   11:*/		return 0x8210B0E0;
		  /* 8210B0E0h */ case   12:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 8210B0E0h case   12:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 8210B0E0h case   12:*/		return 0x8210B0E4;
		  /* 8210B0E4h */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 8210B0E4h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210B0E4h case   13:*/		return 0x8210B0E8;
		  /* 8210B0E8h */ case   14:  		/* bc 4, CR6_EQ, 808 */
		/* 8210B0E8h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8210B410;  }
		/* 8210B0E8h case   14:*/		return 0x8210B0EC;
		  /* 8210B0ECh */ case   15:  		/* lwz R11, <#[R30 + 4]> */
		/* 8210B0ECh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8210B0ECh case   15:*/		return 0x8210B0F0;
		  /* 8210B0F0h */ case   16:  		/* cmplwi CR6, R11, 4 */
		/* 8210B0F0h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 8210B0F0h case   16:*/		return 0x8210B0F4;
		  /* 8210B0F4h */ case   17:  		/* bc 4, CR6_EQ, 200 */
		/* 8210B0F4h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8210B1BC;  }
		/* 8210B0F4h case   17:*/		return 0x8210B0F8;
		  /* 8210B0F8h */ case   18:  		/* lwz R8, <#[R30 + 8]> */
		/* 8210B0F8h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000008) );
		/* 8210B0F8h case   18:*/		return 0x8210B0FC;
		  /* 8210B0FCh */ case   19:  		/* lwz R7, <#[R23 + 20]> */
		/* 8210B0FCh case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R23 + 0x00000014) );
		/* 8210B0FCh case   19:*/		return 0x8210B100;
		  /* 8210B100h */ case   20:  		/* lwz R11, <#[R23 + 16]> */
		/* 8210B100h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000010) );
		/* 8210B100h case   20:*/		return 0x8210B104;
		  /* 8210B104h */ case   21:  		/* lwz R10, <#[R8]> */
		/* 8210B104h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8210B104h case   21:*/		return 0x8210B108;
		  /* 8210B108h */ case   22:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210B108h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210B108h case   22:*/		return 0x8210B10C;
		  /* 8210B10Ch */ case   23:  		/* lwzx R10, <#[R10 + R7]> */
		/* 8210B10Ch case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 8210B10Ch case   23:*/		return 0x8210B110;
		  /* 8210B110h */ case   24:  		/* lwz R10, <#[R10 + 4]> */
		/* 8210B110h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8210B110h case   24:*/		return 0x8210B114;
		  /* 8210B114h */ case   25:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210B114h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210B114h case   25:*/		return 0x8210B118;
		  /* 8210B118h */ case   26:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8210B118h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210B118h case   26:*/		return 0x8210B11C;
		  /* 8210B11Ch */ case   27:  		/* lwz R11, <#[R11 + 4]> */
		/* 8210B11Ch case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8210B11Ch case   27:*/		return 0x8210B120;
		  /* 8210B120h */ case   28:  		/* rlwinm. R11, R11, 0, 22, 22 */
		/* 8210B120h case   28:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R11,regs.R11);
		/* 8210B120h case   28:*/		return 0x8210B124;
		  /* 8210B124h */ case   29:  		/* bc 4, CR0_EQ, 152 */
		/* 8210B124h case   29:*/		if ( !regs.CR[0].eq ) { return 0x8210B1BC;  }
		/* 8210B124h case   29:*/		return 0x8210B128;
		  /* 8210B128h */ case   30:  		/* li R9, 4 */
		/* 8210B128h case   30:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 8210B128h case   30:*/		return 0x8210B12C;
		  /* 8210B12Ch */ case   31:  		/* mr R10, R15 */
		/* 8210B12Ch case   31:*/		regs.R10 = regs.R15;
		/* 8210B12Ch case   31:*/		return 0x8210B130;
		  /* 8210B130h */ case   32:  		/* mr R11, R15 */
		/* 8210B130h case   32:*/		regs.R11 = regs.R15;
		/* 8210B130h case   32:*/		return 0x8210B134;
		  /* 8210B134h */ case   33:  		/* mtspr CTR, R9 */
		/* 8210B134h case   33:*/		regs.CTR = regs.R9;
		/* 8210B134h case   33:*/		return 0x8210B138;
		  /* 8210B138h */ case   34:  		/* lwzx R9, <#[R8 + R11]> */
		/* 8210B138h case   34:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8210B138h case   34:*/		return 0x8210B13C;
		  /* 8210B13Ch */ case   35:  		/* addi R11, R11, 4 */
		/* 8210B13Ch case   35:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210B13Ch case   35:*/		return 0x8210B140;
		  /* 8210B140h */ case   36:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210B140h case   36:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210B140h case   36:*/		return 0x8210B144;
		  /* 8210B144h */ case   37:  		/* lwzx R9, <#[R9 + R7]> */
		/* 8210B144h case   37:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 8210B144h case   37:*/		return 0x8210B148;
		  /* 8210B148h */ case   38:  		/* lwz R9, <#[R9 + 16]> */
		/* 8210B148h case   38:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000010) );
		/* 8210B148h case   38:*/		return 0x8210B14C;
		  /* 8210B14Ch */ case   39:  		/* slw R9, R17, R9 */
		/* 8210B14Ch case   39:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R17,regs.R9);
		/* 8210B14Ch case   39:*/		return 0x8210B150;
		  /* 8210B150h */ case   40:  		/* or R10, R9, R10 */
		/* 8210B150h case   40:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8210B150h case   40:*/		return 0x8210B154;
		  /* 8210B154h */ case   41:  		/* bc 16, CR0_LT, -28 */
		/* 8210B154h case   41:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210B138;  }
		/* 8210B154h case   41:*/		return 0x8210B158;
		  /* 8210B158h */ case   42:  		/* cmplwi CR6, R10, 15 */
		/* 8210B158h case   42:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000000F);
		/* 8210B158h case   42:*/		return 0x8210B15C;
		  /* 8210B15Ch */ case   43:  		/* bc 4, CR6_EQ, 96 */
		/* 8210B15Ch case   43:*/		if ( !regs.CR[6].eq ) { return 0x8210B1BC;  }
		/* 8210B15Ch case   43:*/		return 0x8210B160;
		  /* 8210B160h */ case   44:  		/* li R10, 4 */
		/* 8210B160h case   44:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 8210B160h case   44:*/		return 0x8210B164;
		  /* 8210B164h */ case   45:  		/* lwz R9, <#[R30 + 8]> */
		/* 8210B164h case   45:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 8210B164h case   45:*/		return 0x8210B168;
		  /* 8210B168h */ case   46:  		/* mr R11, R15 */
		/* 8210B168h case   46:*/		regs.R11 = regs.R15;
		/* 8210B168h case   46:*/		return 0x8210B16C;
		  /* 8210B16Ch */ case   47:  		/* mtspr CTR, R10 */
		/* 8210B16Ch case   47:*/		regs.CTR = regs.R10;
		/* 8210B16Ch case   47:*/		return 0x8210B170;
		  /* 8210B170h */ case   48:  		/* lwzx R10, <#[R11 + R9]> */
		/* 8210B170h case   48:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210B170h case   48:*/		return 0x8210B174;
		  /* 8210B174h */ case   49:  		/* addi R8, R1, 96 */
		/* 8210B174h case   49:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 8210B174h case   49:*/		return 0x8210B178;
		  /* 8210B178h */ case   50:  		/* addi R11, R11, 4 */
		/* 8210B178h case   50:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210B178h case   50:*/		return 0x8210B17C;
		  /* 8210B17Ch */ case   51:  		/* rlwinm R6, R10, 2, 0, 29 */
		/* 8210B17Ch case   51:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R10);
		/* 8210B17Ch case   51:*/		return 0x8210B180;
		  /* 8210B180h */ case   52:  		/* lwzx R6, <#[R6 + R7]> */
		/* 8210B180h case   52:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R7 + 0x00000000) );
		/* 8210B180h case   52:*/		return 0x8210B184;
		  /* 8210B184h */ case   53:  		/* lwz R6, <#[R6 + 16]> */
		/* 8210B184h case   53:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000010) );
		/* 8210B184h case   53:*/		return 0x8210B188;
		  /* 8210B188h */ case   54:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 8210B188h case   54:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 8210B188h case   54:*/		return 0x8210B18C;
		  /* 8210B18Ch */ case   55:  		/* stwx R10, <#[R6 + R8]> */
		/* 8210B18Ch case   55:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R6 + regs.R8 + 0x00000000) );
		/* 8210B18Ch case   55:*/		return 0x8210B190;
		  /* 8210B190h */ case   56:  		/* bc 16, CR0_LT, -32 */
		/* 8210B190h case   56:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210B170;  }
		/* 8210B190h case   56:*/		return 0x8210B194;
		  /* 8210B194h */ case   57:  		/* li R10, 4 */
		/* 8210B194h case   57:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 8210B194h case   57:*/		return 0x8210B198;
		  /* 8210B198h */ case   58:  		/* mr R11, R15 */
		/* 8210B198h case   58:*/		regs.R11 = regs.R15;
		/* 8210B198h case   58:*/		return 0x8210B19C;
		  /* 8210B19Ch */ case   59:  		/* mtspr CTR, R10 */
		/* 8210B19Ch case   59:*/		regs.CTR = regs.R10;
		/* 8210B19Ch case   59:*/		return 0x8210B1A0;
		  /* 8210B1A0h */ case   60:  		/* addi R10, R1, 96 */
		/* 8210B1A0h case   60:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 8210B1A0h case   60:*/		return 0x8210B1A4;
		  /* 8210B1A4h */ case   61:  		/* lwz R9, <#[R30 + 8]> */
		/* 8210B1A4h case   61:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 8210B1A4h case   61:*/		return 0x8210B1A8;
		  /* 8210B1A8h */ case   62:  		/* lwzx R10, <#[R11 + R10]> */
		/* 8210B1A8h case   62:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210B1A8h case   62:*/		return 0x8210B1AC;
		  /* 8210B1ACh */ case   63:  		/* stwx R10, <#[R11 + R9]> */
		/* 8210B1ACh case   63:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210B1ACh case   63:*/		return 0x8210B1B0;
		  /* 8210B1B0h */ case   64:  		/* addi R11, R11, 4 */
		/* 8210B1B0h case   64:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210B1B0h case   64:*/		return 0x8210B1B4;
		  /* 8210B1B4h */ case   65:  		/* bc 16, CR0_LT, -20 */
		/* 8210B1B4h case   65:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210B1A0;  }
		/* 8210B1B4h case   65:*/		return 0x8210B1B8;
		  /* 8210B1B8h */ case   66:  		/* b 600 */
		/* 8210B1B8h case   66:*/		return 0x8210B410;
		/* 8210B1B8h case   66:*/		return 0x8210B1BC;
	}
	return 0x8210B1BC;
} // Block from 8210B0B0h-8210B1BCh (67 instructions)

//////////////////////////////////////////////////////
// Block at 8210B1BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B1BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B1BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B1BC);
		  /* 8210B1BCh */ case    0:  		/* lis R4, 4096 */
		/* 8210B1BCh case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x1000);
		/* 8210B1BCh case    0:*/		return 0x8210B1C0;
		  /* 8210B1C0h */ case    1:  		/* mr R6, R18 */
		/* 8210B1C0h case    1:*/		regs.R6 = regs.R18;
		/* 8210B1C0h case    1:*/		return 0x8210B1C4;
		  /* 8210B1C4h */ case    2:  		/* mr R5, R18 */
		/* 8210B1C4h case    2:*/		regs.R5 = regs.R18;
		/* 8210B1C4h case    2:*/		return 0x8210B1C8;
		  /* 8210B1C8h */ case    3:  		/* ori R4, R4, 4 */
		/* 8210B1C8h case    3:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x4);
		/* 8210B1C8h case    3:*/		return 0x8210B1CC;
		  /* 8210B1CCh */ case    4:  		/* mr R3, R23 */
		/* 8210B1CCh case    4:*/		regs.R3 = regs.R23;
		/* 8210B1CCh case    4:*/		return 0x8210B1D0;
		  /* 8210B1D0h */ case    5:  		/* bl -57096 */
		/* 8210B1D0h case    5:*/		regs.LR = 0x8210B1D4; return 0x820FD2C8;
		/* 8210B1D0h case    5:*/		return 0x8210B1D4;
		  /* 8210B1D4h */ case    6:  		/* lis R4, 4352 */
		/* 8210B1D4h case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x1100);
		/* 8210B1D4h case    6:*/		return 0x8210B1D8;
		  /* 8210B1D8h */ case    7:  		/* mr R25, R3 */
		/* 8210B1D8h case    7:*/		regs.R25 = regs.R3;
		/* 8210B1D8h case    7:*/		return 0x8210B1DC;
		  /* 8210B1DCh */ case    8:  		/* mr R6, R18 */
		/* 8210B1DCh case    8:*/		regs.R6 = regs.R18;
		/* 8210B1DCh case    8:*/		return 0x8210B1E0;
		  /* 8210B1E0h */ case    9:  		/* mr R5, R18 */
		/* 8210B1E0h case    9:*/		regs.R5 = regs.R18;
		/* 8210B1E0h case    9:*/		return 0x8210B1E4;
		  /* 8210B1E4h */ case   10:  		/* ori R4, R4, 4 */
		/* 8210B1E4h case   10:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x4);
		/* 8210B1E4h case   10:*/		return 0x8210B1E8;
		  /* 8210B1E8h */ case   11:  		/* mr R3, R23 */
		/* 8210B1E8h case   11:*/		regs.R3 = regs.R23;
		/* 8210B1E8h case   11:*/		return 0x8210B1EC;
		  /* 8210B1ECh */ case   12:  		/* bl -57124 */
		/* 8210B1ECh case   12:*/		regs.LR = 0x8210B1F0; return 0x820FD2C8;
		/* 8210B1ECh case   12:*/		return 0x8210B1F0;
		  /* 8210B1F0h */ case   13:  		/* cmpwi CR6, R25, -1 */
		/* 8210B1F0h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R25,0xFFFFFFFF);
		/* 8210B1F0h case   13:*/		return 0x8210B1F4;
		  /* 8210B1F4h */ case   14:  		/* bc 12, CR6_EQ, 6052 */
		/* 8210B1F4h case   14:*/		if ( regs.CR[6].eq ) { return 0x8210C998;  }
		/* 8210B1F4h case   14:*/		return 0x8210B1F8;
		  /* 8210B1F8h */ case   15:  		/* cmpwi CR6, R3, -1 */
		/* 8210B1F8h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8210B1F8h case   15:*/		return 0x8210B1FC;
		  /* 8210B1FCh */ case   16:  		/* bc 12, CR6_EQ, 6044 */
		/* 8210B1FCh case   16:*/		if ( regs.CR[6].eq ) { return 0x8210C998;  }
		/* 8210B1FCh case   16:*/		return 0x8210B200;
		  /* 8210B200h */ case   17:  		/* lwz R11, <#[R23 + 24]> */
		/* 8210B200h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000018) );
		/* 8210B200h case   17:*/		return 0x8210B204;
		  /* 8210B204h */ case   18:  		/* rlwinm R24, R25, 2, 0, 29 */
		/* 8210B204h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R24,regs.R25);
		/* 8210B204h case   18:*/		return 0x8210B208;
		  /* 8210B208h */ case   19:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 8210B208h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 8210B208h case   19:*/		return 0x8210B20C;
		  /* 8210B20Ch */ case   20:  		/* mr R4, R30 */
		/* 8210B20Ch case   20:*/		regs.R4 = regs.R30;
		/* 8210B20Ch case   20:*/		return 0x8210B210;
		  /* 8210B210h */ case   21:  		/* lwzx R29, <#[R11 + R24]> */
		/* 8210B210h case   21:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R24 + 0x00000000) );
		/* 8210B210h case   21:*/		return 0x8210B214;
		  /* 8210B214h */ case   22:  		/* lwzx R26, <#[R10 + R11]> */
		/* 8210B214h case   22:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210B214h case   22:*/		return 0x8210B218;
		  /* 8210B218h */ case   23:  		/* mr R3, R29 */
		/* 8210B218h case   23:*/		regs.R3 = regs.R29;
		/* 8210B218h case   23:*/		return 0x8210B21C;
		  /* 8210B21Ch */ case   24:  		/* bl -62252 */
		/* 8210B21Ch case   24:*/		regs.LR = 0x8210B220; return 0x820FBEF0;
		/* 8210B21Ch case   24:*/		return 0x8210B220;
		  /* 8210B220h */ case   25:  		/* mr R4, R30 */
		/* 8210B220h case   25:*/		regs.R4 = regs.R30;
		/* 8210B220h case   25:*/		return 0x8210B224;
		  /* 8210B224h */ case   26:  		/* mr R3, R26 */
		/* 8210B224h case   26:*/		regs.R3 = regs.R26;
		/* 8210B224h case   26:*/		return 0x8210B228;
		  /* 8210B228h */ case   27:  		/* bl -62264 */
		/* 8210B228h case   27:*/		regs.LR = 0x8210B22C; return 0x820FBEF0;
		/* 8210B228h case   27:*/		return 0x8210B22C;
		  /* 8210B22Ch */ case   28:  		/* mr R27, R15 */
		/* 8210B22Ch case   28:*/		regs.R27 = regs.R15;
		/* 8210B22Ch case   28:*/		return 0x8210B230;
		  /* 8210B230h */ case   29:  		/* mr R31, R15 */
		/* 8210B230h case   29:*/		regs.R31 = regs.R15;
		/* 8210B230h case   29:*/		return 0x8210B234;
		  /* 8210B234h */ case   30:  		/* lwz R11, <#[R30 + 4]> */
		/* 8210B234h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8210B234h case   30:*/		return 0x8210B238;
		  /* 8210B238h */ case   31:  		/* cmplw CR6, R27, R11 */
		/* 8210B238h case   31:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 8210B238h case   31:*/		return 0x8210B23C;
		  /* 8210B23Ch */ case   32:  		/* bc 4, CR6_LT, 12 */
		/* 8210B23Ch case   32:*/		if ( !regs.CR[6].lt ) { return 0x8210B248;  }
		/* 8210B23Ch case   32:*/		return 0x8210B240;
		  /* 8210B240h */ case   33:  		/* mr R11, R27 */
		/* 8210B240h case   33:*/		regs.R11 = regs.R27;
		/* 8210B240h case   33:*/		return 0x8210B244;
		  /* 8210B244h */ case   34:  		/* b 8 */
		/* 8210B244h case   34:*/		return 0x8210B24C;
		/* 8210B244h case   34:*/		return 0x8210B248;
	}
	return 0x8210B248;
} // Block from 8210B1BCh-8210B248h (35 instructions)

//////////////////////////////////////////////////////
// Block at 8210B248h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B248);
		  /* 8210B248h */ case    0:  		/* addi R11, R11, -1 */
		/* 8210B248h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8210B248h case    0:*/		return 0x8210B24C;
	}
	return 0x8210B24C;
} // Block from 8210B248h-8210B24Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210B24Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B24C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B24C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B24C);
		  /* 8210B24Ch */ case    0:  		/* lwz R10, <#[R30 + 8]> */
		/* 8210B24Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 8210B24Ch case    0:*/		return 0x8210B250;
		  /* 8210B250h */ case    1:  		/* rlwinm R28, R11, 2, 0, 29 */
		/* 8210B250h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R11);
		/* 8210B250h case    1:*/		return 0x8210B254;
		  /* 8210B254h */ case    2:  		/* lwz R11, <#[R29 + 8]> */
		/* 8210B254h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8210B254h case    2:*/		return 0x8210B258;
		  /* 8210B258h */ case    3:  		/* mr R6, R27 */
		/* 8210B258h case    3:*/		regs.R6 = regs.R27;
		/* 8210B258h case    3:*/		return 0x8210B25C;
		  /* 8210B25Ch */ case    4:  		/* mr R5, R19 */
		/* 8210B25Ch case    4:*/		regs.R5 = regs.R19;
		/* 8210B25Ch case    4:*/		return 0x8210B260;
		  /* 8210B260h */ case    5:  		/* fmr FR1, FR31 */
		/* 8210B260h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8210B260h case    5:*/		return 0x8210B264;
		  /* 8210B264h */ case    6:  		/* mr R3, R23 */
		/* 8210B264h case    6:*/		regs.R3 = regs.R23;
		/* 8210B264h case    6:*/		return 0x8210B268;
		  /* 8210B268h */ case    7:  		/* lwzx R10, <#[R28 + R10]> */
		/* 8210B268h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + regs.R10 + 0x00000000) );
		/* 8210B268h case    7:*/		return 0x8210B26C;
		  /* 8210B26Ch */ case    8:  		/* stwx R10, <#[R11 + R31]> */
		/* 8210B26Ch case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 8210B26Ch case    8:*/		return 0x8210B270;
		  /* 8210B270h */ case    9:  		/* lwz R4, <#[R23 + 136]> */
		/* 8210B270h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R23 + 0x00000088) );
		/* 8210B270h case    9:*/		return 0x8210B274;
		  /* 8210B274h */ case   10:  		/* bl -57420 */
		/* 8210B274h case   10:*/		regs.LR = 0x8210B278; return 0x820FD228;
		/* 8210B274h case   10:*/		return 0x8210B278;
		  /* 8210B278h */ case   11:  		/* lwz R11, <#[R29 + 16]> */
		/* 8210B278h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 8210B278h case   11:*/		return 0x8210B27C;
		  /* 8210B27Ch */ case   12:  		/* stwx R3, <#[R31 + R11]> */
		/* 8210B27Ch case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8210B27Ch case   12:*/		return 0x8210B280;
		  /* 8210B280h */ case   13:  		/* lwz R11, <#[R30 + 16]> */
		/* 8210B280h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8210B280h case   13:*/		return 0x8210B284;
		  /* 8210B284h */ case   14:  		/* lwz R9, <#[R23 + 20]> */
		/* 8210B284h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000014) );
		/* 8210B284h case   14:*/		return 0x8210B288;
		  /* 8210B288h */ case   15:  		/* lwz R10, <#[R29 + 16]> */
		/* 8210B288h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000010) );
		/* 8210B288h case   15:*/		return 0x8210B28C;
		  /* 8210B28Ch */ case   16:  		/* lwzx R11, <#[R11 + R28]> */
		/* 8210B28Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8210B28Ch case   16:*/		return 0x8210B290;
		  /* 8210B290h */ case   17:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210B290h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210B290h case   17:*/		return 0x8210B294;
		  /* 8210B294h */ case   18:  		/* lwzx R10, <#[R31 + R10]> */
		/* 8210B294h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 8210B294h case   18:*/		return 0x8210B298;
		  /* 8210B298h */ case   19:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210B298h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210B298h case   19:*/		return 0x8210B29C;
		  /* 8210B29Ch */ case   20:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210B29Ch case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210B29Ch case   20:*/		return 0x8210B2A0;
		  /* 8210B2A0h */ case   21:  		/* lwz R11, <#[R11 + 20]> */
		/* 8210B2A0h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8210B2A0h case   21:*/		return 0x8210B2A4;
		  /* 8210B2A4h */ case   22:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210B2A4h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210B2A4h case   22:*/		return 0x8210B2A8;
		  /* 8210B2A8h */ case   23:  		/* stw R11, <#[R10 + 20]> */
		/* 8210B2A8h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 8210B2A8h case   23:*/		return 0x8210B2AC;
		  /* 8210B2ACh */ case   24:  		/* lwz R10, <#[R29 + 16]> */
		/* 8210B2ACh case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000010) );
		/* 8210B2ACh case   24:*/		return 0x8210B2B0;
		  /* 8210B2B0h */ case   25:  		/* lwz R9, <#[R23 + 20]> */
		/* 8210B2B0h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000014) );
		/* 8210B2B0h case   25:*/		return 0x8210B2B4;
		  /* 8210B2B4h */ case   26:  		/* lwz R11, <#[R30 + 16]> */
		/* 8210B2B4h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8210B2B4h case   26:*/		return 0x8210B2B8;
		  /* 8210B2B8h */ case   27:  		/* lwzx R10, <#[R31 + R10]> */
		/* 8210B2B8h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 8210B2B8h case   27:*/		return 0x8210B2BC;
		  /* 8210B2BCh */ case   28:  		/* lwzx R11, <#[R11 + R28]> */
		/* 8210B2BCh case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8210B2BCh case   28:*/		return 0x8210B2C0;
		  /* 8210B2C0h */ case   29:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210B2C0h case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210B2C0h case   29:*/		return 0x8210B2C4;
		  /* 8210B2C4h */ case   30:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210B2C4h case   30:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210B2C4h case   30:*/		return 0x8210B2C8;
		  /* 8210B2C8h */ case   31:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210B2C8h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210B2C8h case   31:*/		return 0x8210B2CC;
		  /* 8210B2CCh */ case   32:  		/* lwz R11, <#[R11 + 24]> */
		/* 8210B2CCh case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8210B2CCh case   32:*/		return 0x8210B2D0;
		  /* 8210B2D0h */ case   33:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210B2D0h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210B2D0h case   33:*/		return 0x8210B2D4;
		  /* 8210B2D4h */ case   34:  		/* stw R11, <#[R10 + 24]> */
		/* 8210B2D4h case   34:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000018) );
		/* 8210B2D4h case   34:*/		return 0x8210B2D8;
		  /* 8210B2D8h */ case   35:  		/* lwz R11, <#[R29 + 16]> */
		/* 8210B2D8h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 8210B2D8h case   35:*/		return 0x8210B2DC;
		  /* 8210B2DCh */ case   36:  		/* lwzx R11, <#[R31 + R11]> */
		/* 8210B2DCh case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8210B2DCh case   36:*/		return 0x8210B2E0;
		  /* 8210B2E0h */ case   37:  		/* cmpwi CR6, R11, -1 */
		/* 8210B2E0h case   37:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210B2E0h case   37:*/		return 0x8210B2E4;
		  /* 8210B2E4h */ case   38:  		/* bc 12, CR6_EQ, 5812 */
		/* 8210B2E4h case   38:*/		if ( regs.CR[6].eq ) { return 0x8210C998;  }
		/* 8210B2E4h case   38:*/		return 0x8210B2E8;
		  /* 8210B2E8h */ case   39:  		/* lwz R11, <#[R29 + 16]> */
		/* 8210B2E8h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 8210B2E8h case   39:*/		return 0x8210B2EC;
		  /* 8210B2ECh */ case   40:  		/* mr R6, R27 */
		/* 8210B2ECh case   40:*/		regs.R6 = regs.R27;
		/* 8210B2ECh case   40:*/		return 0x8210B2F0;
	}
	return 0x8210B2F0;
} // Block from 8210B24Ch-8210B2F0h (41 instructions)

//////////////////////////////////////////////////////
// Block at 8210B2F0h
// Function '?VectorizeLeft@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B2F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B2F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B2F0);
		  /* 8210B2F0h */ case    0:  		/* lwz R10, <#[R26 + 8]> */
		/* 8210B2F0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000008) );
		/* 8210B2F0h case    0:*/		return 0x8210B2F4;
		  /* 8210B2F4h */ case    1:  		/* mr R3, R23 */
		/* 8210B2F4h case    1:*/		regs.R3 = regs.R23;
		/* 8210B2F4h case    1:*/		return 0x8210B2F8;
		  /* 8210B2F8h */ case    2:  		/* fmr FR1, FR31 */
		/* 8210B2F8h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8210B2F8h case    2:*/		return 0x8210B2FC;
		  /* 8210B2FCh */ case    3:  		/* lwzx R11, <#[R31 + R11]> */
		/* 8210B2FCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8210B2FCh case    3:*/		return 0x8210B300;
		  /* 8210B300h */ case    4:  		/* stwx R11, <#[R10 + R31]> */
		/* 8210B300h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 8210B300h case    4:*/		return 0x8210B304;
		  /* 8210B304h */ case    5:  		/* lwz R4, <#[R23 + 168]> */
		/* 8210B304h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R23 + 0x000000A8) );
		/* 8210B304h case    5:*/		return 0x8210B308;
		  /* 8210B308h */ case    6:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 8210B308h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 8210B308h case    6:*/		return 0x8210B30C;
		  /* 8210B30Ch */ case    7:  		/* lwz R10, <#[R23 + 16]> */
		/* 8210B30Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000010) );
		/* 8210B30Ch case    7:*/		return 0x8210B310;
		  /* 8210B310h */ case    8:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210B310h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210B310h case    8:*/		return 0x8210B314;
		  /* 8210B314h */ case    9:  		/* lwz R5, <#[R11 + 8]> */
		/* 8210B314h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000008) );
		/* 8210B314h case    9:*/		return 0x8210B318;
		  /* 8210B318h */ case   10:  		/* bl -57584 */
		/* 8210B318h case   10:*/		regs.LR = 0x8210B31C; return 0x820FD228;
		/* 8210B318h case   10:*/		return 0x8210B31C;
		  /* 8210B31Ch */ case   11:  		/* lwz R11, <#[R26 + 16]> */
		/* 8210B31Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 8210B31Ch case   11:*/		return 0x8210B320;
		  /* 8210B320h */ case   12:  		/* addi R27, R27, 1 */
		/* 8210B320h case   12:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8210B320h case   12:*/		return 0x8210B324;
		  /* 8210B324h */ case   13:  		/* stwx R3, <#[R31 + R11]> */
		/* 8210B324h case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8210B324h case   13:*/		return 0x8210B328;
		  /* 8210B328h */ case   14:  		/* lwz R11, <#[R30 + 16]> */
		/* 8210B328h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8210B328h case   14:*/		return 0x8210B32C;
		  /* 8210B32Ch */ case   15:  		/* lwz R10, <#[R26 + 16]> */
		/* 8210B32Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000010) );
		/* 8210B32Ch case   15:*/		return 0x8210B330;
		  /* 8210B330h */ case   16:  		/* lwz R9, <#[R23 + 20]> */
		/* 8210B330h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000014) );
		/* 8210B330h case   16:*/		return 0x8210B334;
		  /* 8210B334h */ case   17:  		/* lwzx R10, <#[R31 + R10]> */
		/* 8210B334h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 8210B334h case   17:*/		return 0x8210B338;
		  /* 8210B338h */ case   18:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210B338h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210B338h case   18:*/		return 0x8210B33C;
		  /* 8210B33Ch */ case   19:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210B33Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210B33Ch case   19:*/		return 0x8210B340;
		  /* 8210B340h */ case   20:  		/* lwzx R11, <#[R11 + R28]> */
		/* 8210B340h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8210B340h case   20:*/		return 0x8210B344;
		  /* 8210B344h */ case   21:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210B344h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210B344h case   21:*/		return 0x8210B348;
		  /* 8210B348h */ case   22:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210B348h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210B348h case   22:*/		return 0x8210B34C;
		  /* 8210B34Ch */ case   23:  		/* lwz R11, <#[R11 + 20]> */
		/* 8210B34Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8210B34Ch case   23:*/		return 0x8210B350;
		  /* 8210B350h */ case   24:  		/* stw R11, <#[R10 + 20]> */
		/* 8210B350h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 8210B350h case   24:*/		return 0x8210B354;
		  /* 8210B354h */ case   25:  		/* lwz R9, <#[R23 + 20]> */
		/* 8210B354h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000014) );
		/* 8210B354h case   25:*/		return 0x8210B358;
		  /* 8210B358h */ case   26:  		/* lwz R11, <#[R26 + 16]> */
		/* 8210B358h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 8210B358h case   26:*/		return 0x8210B35C;
		  /* 8210B35Ch */ case   27:  		/* lwz R10, <#[R30 + 16]> */
		/* 8210B35Ch case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 8210B35Ch case   27:*/		return 0x8210B360;
		  /* 8210B360h */ case   28:  		/* lwzx R11, <#[R31 + R11]> */
		/* 8210B360h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8210B360h case   28:*/		return 0x8210B364;
		  /* 8210B364h */ case   29:  		/* addi R31, R31, 4 */
		/* 8210B364h case   29:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8210B364h case   29:*/		return 0x8210B368;
		  /* 8210B368h */ case   30:  		/* lwzx R10, <#[R10 + R28]> */
		/* 8210B368h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 8210B368h case   30:*/		return 0x8210B36C;
		  /* 8210B36Ch */ case   31:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210B36Ch case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210B36Ch case   31:*/		return 0x8210B370;
		  /* 8210B370h */ case   32:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210B370h case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210B370h case   32:*/		return 0x8210B374;
		  /* 8210B374h */ case   33:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210B374h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210B374h case   33:*/		return 0x8210B378;
		  /* 8210B378h */ case   34:  		/* lwz R10, <#[R10 + 24]> */
		/* 8210B378h case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 8210B378h case   34:*/		return 0x8210B37C;
		  /* 8210B37Ch */ case   35:  		/* cmplwi CR6, R31, 16 */
		/* 8210B37Ch case   35:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000010);
		/* 8210B37Ch case   35:*/		return 0x8210B380;
		  /* 8210B380h */ case   36:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210B380h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210B380h case   36:*/		return 0x8210B384;
		  /* 8210B384h */ case   37:  		/* stw R10, <#[R11 + 24]> */
		/* 8210B384h case   37:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 8210B384h case   37:*/		return 0x8210B388;
		  /* 8210B388h */ case   38:  		/* bc 12, CR6_LT, -340 */
		/* 8210B388h case   38:*/		if ( regs.CR[6].lt ) { return 0x8210B234;  }
		/* 8210B388h case   38:*/		return 0x8210B38C;
		  /* 8210B38Ch */ case   39:  		/* lwz R11, <#[R23 + 168]> */
		/* 8210B38Ch case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x000000A8) );
		/* 8210B38Ch case   39:*/		return 0x8210B390;
		  /* 8210B390h */ case   40:  		/* cmplw CR6, R25, R21 */
		/* 8210B390h case   40:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R21);
		/* 8210B390h case   40:*/		return 0x8210B394;
		  /* 8210B394h */ case   41:  		/* lwz R10, <#[R23 + 16]> */
		/* 8210B394h case   41:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000010) );
		/* 8210B394h case   41:*/		return 0x8210B398;
		  /* 8210B398h */ case   42:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210B398h case   42:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210B398h case   42:*/		return 0x8210B39C;
		  /* 8210B39Ch */ case   43:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210B39Ch case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210B39Ch case   43:*/		return 0x8210B3A0;
		  /* 8210B3A0h */ case   44:  		/* lwz R10, <#[R11 + 8]> */
		/* 8210B3A0h case   44:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8210B3A0h case   44:*/		return 0x8210B3A4;
		  /* 8210B3A4h */ case   45:  		/* addi R10, R10, 1 */
		/* 8210B3A4h case   45:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210B3A4h case   45:*/		return 0x8210B3A8;
		  /* 8210B3A8h */ case   46:  		/* stw R10, <#[R11 + 8]> */
		/* 8210B3A8h case   46:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8210B3A8h case   46:*/		return 0x8210B3AC;
		  /* 8210B3ACh */ case   47:  		/* bc 4, CR6_GT, 40 */
		/* 8210B3ACh case   47:*/		if ( !regs.CR[6].gt ) { return 0x8210B3D4;  }
		/* 8210B3ACh case   47:*/		return 0x8210B3B0;
		  /* 8210B3B0h */ case   48:  		/* subf R10, R21, R25 */
		/* 8210B3B0h case   48:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R21,regs.R25);
		/* 8210B3B0h case   48:*/		return 0x8210B3B4;
		  /* 8210B3B4h */ case   49:  		/* mr R11, R24 */
		/* 8210B3B4h case   49:*/		regs.R11 = regs.R24;
		/* 8210B3B4h case   49:*/		return 0x8210B3B8;
		  /* 8210B3B8h */ case   50:  		/* mtspr CTR, R10 */
		/* 8210B3B8h case   50:*/		regs.CTR = regs.R10;
		/* 8210B3B8h case   50:*/		return 0x8210B3BC;
		  /* 8210B3BCh */ case   51:  		/* lwz R10, <#[R23 + 24]> */
		/* 8210B3BCh case   51:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000018) );
		/* 8210B3BCh case   51:*/		return 0x8210B3C0;
		  /* 8210B3C0h */ case   52:  		/* add R10, R10, R11 */
		/* 8210B3C0h case   52:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8210B3C0h case   52:*/		return 0x8210B3C4;
		  /* 8210B3C4h */ case   53:  		/* addi R11, R11, -4 */
		/* 8210B3C4h case   53:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8210B3C4h case   53:*/		return 0x8210B3C8;
		  /* 8210B3C8h */ case   54:  		/* lwz R9, <#[R10 - 4]> */
		/* 8210B3C8h case   54:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 8210B3C8h case   54:*/		return 0x8210B3CC;
		  /* 8210B3CCh */ case   55:  		/* stw R9, <#[R10]> */
		/* 8210B3CCh case   55:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8210B3CCh case   55:*/		return 0x8210B3D0;
		  /* 8210B3D0h */ case   56:  		/* bc 16, CR0_LT, -20 */
		/* 8210B3D0h case   56:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210B3BC;  }
		/* 8210B3D0h case   56:*/		return 0x8210B3D4;
	}
	return 0x8210B3D4;
} // Block from 8210B2F0h-8210B3D4h (57 instructions)

//////////////////////////////////////////////////////
// Block at 8210B3D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B3D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B3D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B3D4);
		  /* 8210B3D4h */ case    0:  		/* lwz R11, <#[R23 + 24]> */
		/* 8210B3D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000018) );
		/* 8210B3D4h case    0:*/		return 0x8210B3D8;
		  /* 8210B3D8h */ case    1:  		/* mr R3, R30 */
		/* 8210B3D8h case    1:*/		regs.R3 = regs.R30;
		/* 8210B3D8h case    1:*/		return 0x8210B3DC;
		  /* 8210B3DCh */ case    2:  		/* addi R21, R21, 1 */
		/* 8210B3DCh case    2:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 8210B3DCh case    2:*/		return 0x8210B3E0;
		  /* 8210B3E0h */ case    3:  		/* stwx R29, <#[R11 + R22]> */
		/* 8210B3E0h case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + regs.R22 + 0x00000000) );
		/* 8210B3E0h case    3:*/		return 0x8210B3E4;
		  /* 8210B3E4h */ case    4:  		/* addi R22, R22, 4 */
		/* 8210B3E4h case    4:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x4);
		/* 8210B3E4h case    4:*/		return 0x8210B3E8;
		  /* 8210B3E8h */ case    5:  		/* bl 1122264 */
		/* 8210B3E8h case    5:*/		regs.LR = 0x8210B3EC; return 0x8221D3C0;
		/* 8210B3E8h case    5:*/		return 0x8210B3EC;
		  /* 8210B3ECh */ case    6:  		/* mr R3, R30 */
		/* 8210B3ECh case    6:*/		regs.R3 = regs.R30;
		/* 8210B3ECh case    6:*/		return 0x8210B3F0;
		  /* 8210B3F0h */ case    7:  		/* bl -60928 */
		/* 8210B3F0h case    7:*/		regs.LR = 0x8210B3F4; return 0x820FC5F0;
		/* 8210B3F0h case    7:*/		return 0x8210B3F4;
		  /* 8210B3F4h */ case    8:  		/* lwz R11, <#[R23 + 12]> */
		/* 8210B3F4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210B3F4h case    8:*/		return 0x8210B3F8;
		  /* 8210B3F8h */ case    9:  		/* addi R19, R19, 1 */
		/* 8210B3F8h case    9:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x1);
		/* 8210B3F8h case    9:*/		return 0x8210B3FC;
		  /* 8210B3FCh */ case   10:  		/* addi R11, R11, -1 */
		/* 8210B3FCh case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8210B3FCh case   10:*/		return 0x8210B400;
		  /* 8210B400h */ case   11:  		/* mr R20, R17 */
		/* 8210B400h case   11:*/		regs.R20 = regs.R17;
		/* 8210B400h case   11:*/		return 0x8210B404;
		  /* 8210B404h */ case   12:  		/* stw R11, <#[R23 + 12]> */
		/* 8210B404h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210B404h case   12:*/		return 0x8210B408;
		  /* 8210B408h */ case   13:  		/* lwz R11, <#[R23 + 24]> */
		/* 8210B408h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000018) );
		/* 8210B408h case   13:*/		return 0x8210B40C;
		  /* 8210B40Ch */ case   14:  		/* stwx R26, <#[R11 + R22]> */
		/* 8210B40Ch case   14:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + regs.R22 + 0x00000000) );
		/* 8210B40Ch case   14:*/		return 0x8210B410;
	}
	return 0x8210B410;
} // Block from 8210B3D4h-8210B410h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8210B410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B410);
		  /* 8210B410h */ case    0:  		/* lwz R11, <#[R23 + 12]> */
		/* 8210B410h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210B410h case    0:*/		return 0x8210B414;
		  /* 8210B414h */ case    1:  		/* addi R21, R21, 1 */
		/* 8210B414h case    1:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 8210B414h case    1:*/		return 0x8210B418;
		  /* 8210B418h */ case    2:  		/* addi R22, R22, 4 */
		/* 8210B418h case    2:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x4);
		/* 8210B418h case    2:*/		return 0x8210B41C;
		  /* 8210B41Ch */ case    3:  		/* cmplw CR6, R21, R11 */
		/* 8210B41Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R11);
		/* 8210B41Ch case    3:*/		return 0x8210B420;
		  /* 8210B420h */ case    4:  		/* bc 12, CR6_LT, -848 */
		/* 8210B420h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210B0D0;  }
		/* 8210B420h case    4:*/		return 0x8210B424;
	}
	return 0x8210B424;
} // Block from 8210B410h-8210B424h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210B424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B424);
		  /* 8210B424h */ case    0:  		/* lwz R11, <#[R23 + 108]> */
		/* 8210B424h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000006C) );
		/* 8210B424h case    0:*/		return 0x8210B428;
		  /* 8210B428h */ case    1:  		/* lis R14, 4096 */
		/* 8210B428h case    1:*/		cpu::op::lis<0>(regs,&regs.R14,0x1000);
		/* 8210B428h case    1:*/		return 0x8210B42C;
		  /* 8210B42Ch */ case    2:  		/* rlwinm. R10, R11, 0, 3, 3 */
		/* 8210B42Ch case    2:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R10,regs.R11);
		/* 8210B42Ch case    2:*/		return 0x8210B430;
		  /* 8210B430h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 8210B430h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8210B43C;  }
		/* 8210B430h case    3:*/		return 0x8210B434;
		  /* 8210B434h */ case    4:  		/* rlwinm. R11, R11, 0, 2, 2 */
		/* 8210B434h case    4:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R11,regs.R11);
		/* 8210B434h case    4:*/		return 0x8210B438;
		  /* 8210B438h */ case    5:  		/* bc 12, CR0_EQ, 1788 */
		/* 8210B438h case    5:*/		if ( regs.CR[0].eq ) { return 0x8210BB34;  }
		/* 8210B438h case    5:*/		return 0x8210B43C;
	}
	return 0x8210B43C;
} // Block from 8210B424h-8210B43Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210B43Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B43C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B43C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B43C);
		  /* 8210B43Ch */ case    0:  		/* lwz R11, <#[R23 + 12]> */
		/* 8210B43Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210B43Ch case    0:*/		return 0x8210B440;
		  /* 8210B440h */ case    1:  		/* mr R25, R15 */
		/* 8210B440h case    1:*/		regs.R25 = regs.R15;
		/* 8210B440h case    1:*/		return 0x8210B444;
		  /* 8210B444h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8210B444h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210B444h case    2:*/		return 0x8210B448;
		  /* 8210B448h */ case    3:  		/* bc 4, CR6_GT, 716 */
		/* 8210B448h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210B714;  }
		/* 8210B448h case    3:*/		return 0x8210B44C;
		  /* 8210B44Ch */ case    4:  		/* lwz R11, <#[R23 + 24]> */
		/* 8210B44Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000018) );
		/* 8210B44Ch case    4:*/		return 0x8210B450;
		  /* 8210B450h */ case    5:  		/* rlwinm R24, R25, 2, 0, 29 */
		/* 8210B450h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R24,regs.R25);
		/* 8210B450h case    5:*/		return 0x8210B454;
		  /* 8210B454h */ case    6:  		/* lwzx R29, <#[R11 + R24]> */
		/* 8210B454h case    6:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R24 + 0x00000000) );
		/* 8210B454h case    6:*/		return 0x8210B458;
		  /* 8210B458h */ case    7:  		/* lwz R11, <#[R29]> */
		/* 8210B458h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8210B458h case    7:*/		return 0x8210B45C;
		  /* 8210B45Ch */ case    8:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 8210B45Ch case    8:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 8210B45Ch case    8:*/		return 0x8210B460;
		  /* 8210B460h */ case    9:  		/* cmplw CR6, R11, R14 */
		/* 8210B460h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 8210B460h case    9:*/		return 0x8210B464;
		  /* 8210B464h */ case   10:  		/* bc 4, CR6_EQ, 672 */
		/* 8210B464h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8210B704;  }
		/* 8210B464h case   10:*/		return 0x8210B468;
		  /* 8210B468h */ case   11:  		/* lwz R11, <#[R29 + 16]> */
		/* 8210B468h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 8210B468h case   11:*/		return 0x8210B46C;
		  /* 8210B46Ch */ case   12:  		/* lwz R9, <#[R23 + 20]> */
		/* 8210B46Ch case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000014) );
		/* 8210B46Ch case   12:*/		return 0x8210B470;
		  /* 8210B470h */ case   13:  		/* lwz R10, <#[R23 + 16]> */
		/* 8210B470h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000010) );
		/* 8210B470h case   13:*/		return 0x8210B474;
		  /* 8210B474h */ case   14:  		/* lwz R11, <#[R11]> */
		/* 8210B474h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8210B474h case   14:*/		return 0x8210B478;
		  /* 8210B478h */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210B478h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210B478h case   15:*/		return 0x8210B47C;
		  /* 8210B47Ch */ case   16:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210B47Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210B47Ch case   16:*/		return 0x8210B480;
		  /* 8210B480h */ case   17:  		/* lwz R11, <#[R11 + 4]> */
		/* 8210B480h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8210B480h case   17:*/		return 0x8210B484;
		  /* 8210B484h */ case   18:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210B484h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210B484h case   18:*/		return 0x8210B488;
		  /* 8210B488h */ case   19:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210B488h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210B488h case   19:*/		return 0x8210B48C;
		  /* 8210B48Ch */ case   20:  		/* lwz R11, <#[R11 + 4]> */
		/* 8210B48Ch case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8210B48Ch case   20:*/		return 0x8210B490;
		  /* 8210B490h */ case   21:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 8210B490h case   21:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 8210B490h case   21:*/		return 0x8210B494;
		  /* 8210B494h */ case   22:  		/* bc 4, CR0_EQ, 624 */
		/* 8210B494h case   22:*/		if ( !regs.CR[0].eq ) { return 0x8210B704;  }
		/* 8210B494h case   22:*/		return 0x8210B498;
		  /* 8210B498h */ case   23:  		/* lwz R6, <#[R29 + 12]> */
		/* 8210B498h case   23:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R29 + 0x0000000C) );
		/* 8210B498h case   23:*/		return 0x8210B49C;
		  /* 8210B49Ch */ case   24:  		/* mr R7, R15 */
		/* 8210B49Ch case   24:*/		regs.R7 = regs.R15;
		/* 8210B49Ch case   24:*/		return 0x8210B4A0;
		  /* 8210B4A0h */ case   25:  		/* cmplwi CR6, R6, 0 */
		/* 8210B4A0h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8210B4A0h case   25:*/		return 0x8210B4A4;
		  /* 8210B4A4h */ case   26:  		/* bc 12, CR6_EQ, 68 */
		/* 8210B4A4h case   26:*/		if ( regs.CR[6].eq ) { return 0x8210B4E8;  }
		/* 8210B4A4h case   26:*/		return 0x8210B4A8;
		  /* 8210B4A8h */ case   27:  		/* lwz R10, <#[R29 + 8]> */
		/* 8210B4A8h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 8210B4A8h case   27:*/		return 0x8210B4AC;
		  /* 8210B4ACh */ case   28:  		/* mr R11, R15 */
		/* 8210B4ACh case   28:*/		regs.R11 = regs.R15;
		/* 8210B4ACh case   28:*/		return 0x8210B4B0;
		  /* 8210B4B0h */ case   29:  		/* lwz R8, <#[R10]> */
		/* 8210B4B0h case   29:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8210B4B0h case   29:*/		return 0x8210B4B4;
		  /* 8210B4B4h */ case   30:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8210B4B4h case   30:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8210B4B4h case   30:*/		return 0x8210B4B8;
		  /* 8210B4B8h */ case   31:  		/* lwzx R8, <#[R8 + R9]> */
		/* 8210B4B8h case   31:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 8210B4B8h case   31:*/		return 0x8210B4BC;
		  /* 8210B4BCh */ case   32:  		/* lwz R8, <#[R8 + 72]> */
		/* 8210B4BCh case   32:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000048) );
		/* 8210B4BCh case   32:*/		return 0x8210B4C0;
		  /* 8210B4C0h */ case   33:  		/* lwzx R5, <#[R11 + R10]> */
		/* 8210B4C0h case   33:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210B4C0h case   33:*/		return 0x8210B4C4;
		  /* 8210B4C4h */ case   34:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 8210B4C4h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 8210B4C4h case   34:*/		return 0x8210B4C8;
		  /* 8210B4C8h */ case   35:  		/* lwzx R5, <#[R5 + R9]> */
		/* 8210B4C8h case   35:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R9 + 0x00000000) );
		/* 8210B4C8h case   35:*/		return 0x8210B4CC;
		  /* 8210B4CCh */ case   36:  		/* lwz R5, <#[R5 + 72]> */
		/* 8210B4CCh case   36:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000048) );
		/* 8210B4CCh case   36:*/		return 0x8210B4D0;
		  /* 8210B4D0h */ case   37:  		/* cmplw CR6, R8, R5 */
		/* 8210B4D0h case   37:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R5);
		/* 8210B4D0h case   37:*/		return 0x8210B4D4;
		  /* 8210B4D4h */ case   38:  		/* bc 4, CR6_EQ, 20 */
		/* 8210B4D4h case   38:*/		if ( !regs.CR[6].eq ) { return 0x8210B4E8;  }
		/* 8210B4D4h case   38:*/		return 0x8210B4D8;
		  /* 8210B4D8h */ case   39:  		/* addi R7, R7, 1 */
		/* 8210B4D8h case   39:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8210B4D8h case   39:*/		return 0x8210B4DC;
		  /* 8210B4DCh */ case   40:  		/* addi R11, R11, 4 */
		/* 8210B4DCh case   40:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210B4DCh case   40:*/		return 0x8210B4E0;
		  /* 8210B4E0h */ case   41:  		/* cmplw CR6, R7, R6 */
		/* 8210B4E0h case   41:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 8210B4E0h case   41:*/		return 0x8210B4E4;
		  /* 8210B4E4h */ case   42:  		/* bc 12, CR6_LT, -36 */
		/* 8210B4E4h case   42:*/		if ( regs.CR[6].lt ) { return 0x8210B4C0;  }
		/* 8210B4E4h case   42:*/		return 0x8210B4E8;
	}
	return 0x8210B4E8;
} // Block from 8210B43Ch-8210B4E8h (43 instructions)

//////////////////////////////////////////////////////
// Block at 8210B4E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B4E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B4E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B4E8);
		  /* 8210B4E8h */ case    0:  		/* cmplw CR6, R7, R6 */
		/* 8210B4E8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 8210B4E8h case    0:*/		return 0x8210B4EC;
		  /* 8210B4ECh */ case    1:  		/* bc 12, CR6_EQ, 536 */
		/* 8210B4ECh case    1:*/		if ( regs.CR[6].eq ) { return 0x8210B704;  }
		/* 8210B4ECh case    1:*/		return 0x8210B4F0;
		  /* 8210B4F0h */ case    2:  		/* lwz R11, <#[R29 + 4]> */
		/* 8210B4F0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8210B4F0h case    2:*/		return 0x8210B4F4;
		  /* 8210B4F4h */ case    3:  		/* mr R28, R15 */
		/* 8210B4F4h case    3:*/		regs.R28 = regs.R15;
		/* 8210B4F4h case    3:*/		return 0x8210B4F8;
		  /* 8210B4F8h */ case    4:  		/* mr R30, R15 */
		/* 8210B4F8h case    4:*/		regs.R30 = regs.R15;
		/* 8210B4F8h case    4:*/		return 0x8210B4FC;
		  /* 8210B4FCh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8210B4FCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210B4FCh case    5:*/		return 0x8210B500;
		  /* 8210B500h */ case    6:  		/* bc 12, CR6_EQ, 312 */
		/* 8210B500h case    6:*/		if ( regs.CR[6].eq ) { return 0x8210B638;  }
		/* 8210B500h case    6:*/		return 0x8210B504;
		  /* 8210B504h */ case    7:  		/* mr R26, R15 */
		/* 8210B504h case    7:*/		regs.R26 = regs.R15;
		/* 8210B504h case    7:*/		return 0x8210B508;
		  /* 8210B508h */ case    8:  		/* lwz R6, <#[R29 + 8]> */
		/* 8210B508h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R29 + 0x00000008) );
		/* 8210B508h case    8:*/		return 0x8210B50C;
		  /* 8210B50Ch */ case    9:  		/* lwzx R10, <#[R26 + R6]> */
		/* 8210B50Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + regs.R6 + 0x00000000) );
		/* 8210B50Ch case    9:*/		return 0x8210B510;
		  /* 8210B510h */ case   10:  		/* cmpwi CR6, R10, -1 */
		/* 8210B510h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210B510h case   10:*/		return 0x8210B514;
		  /* 8210B514h */ case   11:  		/* bc 12, CR6_EQ, 276 */
		/* 8210B514h case   11:*/		if ( regs.CR[6].eq ) { return 0x8210B628;  }
		/* 8210B514h case   11:*/		return 0x8210B518;
		  /* 8210B518h */ case   12:  		/* lwz R9, <#[R23 + 20]> */
		/* 8210B518h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000014) );
		/* 8210B518h case   12:*/		return 0x8210B51C;
		  /* 8210B51Ch */ case   13:  		/* rlwinm R8, R10, 2, 0, 29 */
		/* 8210B51Ch case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R10);
		/* 8210B51Ch case   13:*/		return 0x8210B520;
		  /* 8210B520h */ case   14:  		/* mr R4, R15 */
		/* 8210B520h case   14:*/		regs.R4 = regs.R15;
		/* 8210B520h case   14:*/		return 0x8210B524;
		  /* 8210B524h */ case   15:  		/* mr R10, R30 */
		/* 8210B524h case   15:*/		regs.R10 = regs.R30;
		/* 8210B524h case   15:*/		return 0x8210B528;
		  /* 8210B528h */ case   16:  		/* cmplw CR6, R30, R11 */
		/* 8210B528h case   16:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8210B528h case   16:*/		return 0x8210B52C;
		  /* 8210B52Ch */ case   17:  		/* lwzx R8, <#[R8 + R9]> */
		/* 8210B52Ch case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 8210B52Ch case   17:*/		return 0x8210B530;
		  /* 8210B530h */ case   18:  		/* lwz R27, <#[R8 + 72]> */
		/* 8210B530h case   18:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R8 + 0x00000048) );
		/* 8210B530h case   18:*/		return 0x8210B534;
		  /* 8210B534h */ case   19:  		/* bc 4, CR6_LT, 60 */
		/* 8210B534h case   19:*/		if ( !regs.CR[6].lt ) { return 0x8210B570;  }
		/* 8210B534h case   19:*/		return 0x8210B538;
		  /* 8210B538h */ case   20:  		/* mr R7, R26 */
		/* 8210B538h case   20:*/		regs.R7 = regs.R26;
		/* 8210B538h case   20:*/		return 0x8210B53C;
		  /* 8210B53Ch */ case   21:  		/* lwzx R8, <#[R7 + R6]> */
		/* 8210B53Ch case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R6 + 0x00000000) );
		/* 8210B53Ch case   21:*/		return 0x8210B540;
		  /* 8210B540h */ case   22:  		/* cmpwi CR6, R8, -1 */
		/* 8210B540h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 8210B540h case   22:*/		return 0x8210B544;
		  /* 8210B544h */ case   23:  		/* bc 12, CR6_EQ, 28 */
		/* 8210B544h case   23:*/		if ( regs.CR[6].eq ) { return 0x8210B560;  }
		/* 8210B544h case   23:*/		return 0x8210B548;
		  /* 8210B548h */ case   24:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8210B548h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8210B548h case   24:*/		return 0x8210B54C;
		  /* 8210B54Ch */ case   25:  		/* lwzx R8, <#[R8 + R9]> */
		/* 8210B54Ch case   25:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 8210B54Ch case   25:*/		return 0x8210B550;
		  /* 8210B550h */ case   26:  		/* lwz R8, <#[R8 + 72]> */
		/* 8210B550h case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000048) );
		/* 8210B550h case   26:*/		return 0x8210B554;
		  /* 8210B554h */ case   27:  		/* cmplw CR6, R27, R8 */
		/* 8210B554h case   27:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R8);
		/* 8210B554h case   27:*/		return 0x8210B558;
		  /* 8210B558h */ case   28:  		/* bc 4, CR6_EQ, 8 */
		/* 8210B558h case   28:*/		if ( !regs.CR[6].eq ) { return 0x8210B560;  }
		/* 8210B558h case   28:*/		return 0x8210B55C;
		  /* 8210B55Ch */ case   29:  		/* addi R4, R4, 1 */
		/* 8210B55Ch case   29:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 8210B55Ch case   29:*/		return 0x8210B560;
	}
	return 0x8210B560;
} // Block from 8210B4E8h-8210B560h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8210B560h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B560);
		  /* 8210B560h */ case    0:  		/* addi R10, R10, 1 */
		/* 8210B560h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210B560h case    0:*/		return 0x8210B564;
		  /* 8210B564h */ case    1:  		/* addi R7, R7, 4 */
		/* 8210B564h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 8210B564h case    1:*/		return 0x8210B568;
		  /* 8210B568h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 8210B568h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8210B568h case    2:*/		return 0x8210B56C;
		  /* 8210B56Ch */ case    3:  		/* bc 12, CR6_LT, -48 */
		/* 8210B56Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8210B53C;  }
		/* 8210B56Ch case    3:*/		return 0x8210B570;
	}
	return 0x8210B570;
} // Block from 8210B560h-8210B570h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210B570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B570);
		  /* 8210B570h */ case    0:  		/* mr R6, R18 */
		/* 8210B570h case    0:*/		regs.R6 = regs.R18;
		/* 8210B570h case    0:*/		return 0x8210B574;
		  /* 8210B574h */ case    1:  		/* rlwimi R4, R17, 28, 0, 11 */
		/* 8210B574h case    1:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R4,regs.R17);
		/* 8210B574h case    1:*/		return 0x8210B578;
		  /* 8210B578h */ case    2:  		/* mr R5, R18 */
		/* 8210B578h case    2:*/		regs.R5 = regs.R18;
		/* 8210B578h case    2:*/		return 0x8210B57C;
		  /* 8210B57Ch */ case    3:  		/* mr R3, R23 */
		/* 8210B57Ch case    3:*/		regs.R3 = regs.R23;
		/* 8210B57Ch case    3:*/		return 0x8210B580;
		  /* 8210B580h */ case    4:  		/* bl -58040 */
		/* 8210B580h case    4:*/		regs.LR = 0x8210B584; return 0x820FD2C8;
		/* 8210B580h case    4:*/		return 0x8210B584;
		  /* 8210B584h */ case    5:  		/* cmpwi CR6, R3, -1 */
		/* 8210B584h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8210B584h case    5:*/		return 0x8210B588;
		  /* 8210B588h */ case    6:  		/* bc 12, CR6_EQ, 5136 */
		/* 8210B588h case    6:*/		if ( regs.CR[6].eq ) { return 0x8210C998;  }
		/* 8210B588h case    6:*/		return 0x8210B58C;
		  /* 8210B58Ch */ case    7:  		/* lwz R11, <#[R23 + 24]> */
		/* 8210B58Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000018) );
		/* 8210B58Ch case    7:*/		return 0x8210B590;
		  /* 8210B590h */ case    8:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 8210B590h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 8210B590h case    8:*/		return 0x8210B594;
		  /* 8210B594h */ case    9:  		/* mr R4, R29 */
		/* 8210B594h case    9:*/		regs.R4 = regs.R29;
		/* 8210B594h case    9:*/		return 0x8210B598;
		  /* 8210B598h */ case   10:  		/* lwzx R31, <#[R10 + R11]> */
		/* 8210B598h case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210B598h case   10:*/		return 0x8210B59C;
		  /* 8210B59Ch */ case   11:  		/* mr R3, R31 */
		/* 8210B59Ch case   11:*/		regs.R3 = regs.R31;
		/* 8210B59Ch case   11:*/		return 0x8210B5A0;
		  /* 8210B5A0h */ case   12:  		/* bl -63152 */
		/* 8210B5A0h case   12:*/		regs.LR = 0x8210B5A4; return 0x820FBEF0;
		/* 8210B5A0h case   12:*/		return 0x8210B5A4;
		  /* 8210B5A4h */ case   13:  		/* lwz R11, <#[R29 + 4]> */
		/* 8210B5A4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8210B5A4h case   13:*/		return 0x8210B5A8;
		  /* 8210B5A8h */ case   14:  		/* addi R28, R28, 1 */
		/* 8210B5A8h case   14:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8210B5A8h case   14:*/		return 0x8210B5AC;
		  /* 8210B5ACh */ case   15:  		/* mr R8, R30 */
		/* 8210B5ACh case   15:*/		regs.R8 = regs.R30;
		/* 8210B5ACh case   15:*/		return 0x8210B5B0;
		  /* 8210B5B0h */ case   16:  		/* cmplw CR6, R30, R11 */
		/* 8210B5B0h case   16:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8210B5B0h case   16:*/		return 0x8210B5B4;
		  /* 8210B5B4h */ case   17:  		/* bc 4, CR6_LT, 116 */
		/* 8210B5B4h case   17:*/		if ( !regs.CR[6].lt ) { return 0x8210B628;  }
		/* 8210B5B4h case   17:*/		return 0x8210B5B8;
		  /* 8210B5B8h */ case   18:  		/* mr R10, R26 */
		/* 8210B5B8h case   18:*/		regs.R10 = regs.R26;
		/* 8210B5B8h case   18:*/		return 0x8210B5BC;
		  /* 8210B5BCh */ case   19:  		/* mr R9, R15 */
		/* 8210B5BCh case   19:*/		regs.R9 = regs.R15;
		/* 8210B5BCh case   19:*/		return 0x8210B5C0;
		  /* 8210B5C0h */ case   20:  		/* lwz R11, <#[R29 + 8]> */
		/* 8210B5C0h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8210B5C0h case   20:*/		return 0x8210B5C4;
		  /* 8210B5C4h */ case   21:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210B5C4h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210B5C4h case   21:*/		return 0x8210B5C8;
		  /* 8210B5C8h */ case   22:  		/* cmpwi CR6, R11, -1 */
		/* 8210B5C8h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210B5C8h case   22:*/		return 0x8210B5CC;
		  /* 8210B5CCh */ case   23:  		/* bc 12, CR6_EQ, 72 */
		/* 8210B5CCh case   23:*/		if ( regs.CR[6].eq ) { return 0x8210B614;  }
		/* 8210B5CCh case   23:*/		return 0x8210B5D0;
		  /* 8210B5D0h */ case   24:  		/* lwz R7, <#[R23 + 20]> */
		/* 8210B5D0h case   24:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R23 + 0x00000014) );
		/* 8210B5D0h case   24:*/		return 0x8210B5D4;
		  /* 8210B5D4h */ case   25:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210B5D4h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210B5D4h case   25:*/		return 0x8210B5D8;
		  /* 8210B5D8h */ case   26:  		/* lwzx R11, <#[R11 + R7]> */
		/* 8210B5D8h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 8210B5D8h case   26:*/		return 0x8210B5DC;
		  /* 8210B5DCh */ case   27:  		/* lwz R11, <#[R11 + 72]> */
		/* 8210B5DCh case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 8210B5DCh case   27:*/		return 0x8210B5E0;
		  /* 8210B5E0h */ case   28:  		/* cmplw CR6, R27, R11 */
		/* 8210B5E0h case   28:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 8210B5E0h case   28:*/		return 0x8210B5E4;
		  /* 8210B5E4h */ case   29:  		/* bc 4, CR6_EQ, 48 */
		/* 8210B5E4h case   29:*/		if ( !regs.CR[6].eq ) { return 0x8210B614;  }
		/* 8210B5E4h case   29:*/		return 0x8210B5E8;
		  /* 8210B5E8h */ case   30:  		/* lwz R11, <#[R29 + 8]> */
		/* 8210B5E8h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8210B5E8h case   30:*/		return 0x8210B5EC;
		  /* 8210B5ECh */ case   31:  		/* lwz R7, <#[R31 + 8]> */
		/* 8210B5ECh case   31:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000008) );
		/* 8210B5ECh case   31:*/		return 0x8210B5F0;
		  /* 8210B5F0h */ case   32:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210B5F0h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210B5F0h case   32:*/		return 0x8210B5F4;
		  /* 8210B5F4h */ case   33:  		/* stwx R11, <#[R7 + R9]> */
		/* 8210B5F4h case   33:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 8210B5F4h case   33:*/		return 0x8210B5F8;
		  /* 8210B5F8h */ case   34:  		/* lwz R7, <#[R31 + 16]> */
		/* 8210B5F8h case   34:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000010) );
		/* 8210B5F8h case   34:*/		return 0x8210B5FC;
		  /* 8210B5FCh */ case   35:  		/* lwz R11, <#[R29 + 16]> */
		/* 8210B5FCh case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 8210B5FCh case   35:*/		return 0x8210B600;
		  /* 8210B600h */ case   36:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8210B600h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210B600h case   36:*/		return 0x8210B604;
		  /* 8210B604h */ case   37:  		/* stwx R11, <#[R7 + R9]> */
		/* 8210B604h case   37:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 8210B604h case   37:*/		return 0x8210B608;
		  /* 8210B608h */ case   38:  		/* addi R9, R9, 4 */
		/* 8210B608h case   38:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8210B608h case   38:*/		return 0x8210B60C;
		  /* 8210B60Ch */ case   39:  		/* lwz R11, <#[R29 + 8]> */
		/* 8210B60Ch case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8210B60Ch case   39:*/		return 0x8210B610;
		  /* 8210B610h */ case   40:  		/* stwx R18, <#[R11 + R10]> */
		/* 8210B610h case   40:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210B610h case   40:*/		return 0x8210B614;
	}
	return 0x8210B614;
} // Block from 8210B570h-8210B614h (41 instructions)

//////////////////////////////////////////////////////
// Block at 8210B614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B614);
		  /* 8210B614h */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 8210B614h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8210B614h case    0:*/		return 0x8210B618;
		  /* 8210B618h */ case    1:  		/* addi R8, R8, 1 */
		/* 8210B618h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8210B618h case    1:*/		return 0x8210B61C;
		  /* 8210B61Ch */ case    2:  		/* addi R10, R10, 4 */
		/* 8210B61Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210B61Ch case    2:*/		return 0x8210B620;
		  /* 8210B620h */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 8210B620h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8210B620h case    3:*/		return 0x8210B624;
		  /* 8210B624h */ case    4:  		/* bc 12, CR6_LT, -100 */
		/* 8210B624h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210B5C0;  }
		/* 8210B624h case    4:*/		return 0x8210B628;
	}
	return 0x8210B628;
} // Block from 8210B614h-8210B628h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210B628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B628);
		  /* 8210B628h */ case    0:  		/* addi R30, R30, 1 */
		/* 8210B628h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8210B628h case    0:*/		return 0x8210B62C;
		  /* 8210B62Ch */ case    1:  		/* addi R26, R26, 4 */
		/* 8210B62Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 8210B62Ch case    1:*/		return 0x8210B630;
		  /* 8210B630h */ case    2:  		/* cmplw CR6, R30, R11 */
		/* 8210B630h case    2:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8210B630h case    2:*/		return 0x8210B634;
		  /* 8210B634h */ case    3:  		/* bc 12, CR6_LT, -300 */
		/* 8210B634h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210B508;  }
		/* 8210B634h case    3:*/		return 0x8210B638;
	}
	return 0x8210B638;
} // Block from 8210B628h-8210B638h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210B638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B638);
		  /* 8210B638h */ case    0:  		/* mr R8, R15 */
		/* 8210B638h case    0:*/		regs.R8 = regs.R15;
		/* 8210B638h case    0:*/		return 0x8210B63C;
		  /* 8210B63Ch */ case    1:  		/* cmplwi CR6, R28, 0 */
		/* 8210B63Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8210B63Ch case    1:*/		return 0x8210B640;
		  /* 8210B640h */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 8210B640h case    2:*/		if ( regs.CR[6].eq ) { return 0x8210B670;  }
		/* 8210B640h case    2:*/		return 0x8210B644;
		  /* 8210B644h */ case    3:  		/* lwz R9, <#[R23 + 12]> */
		/* 8210B644h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210B644h case    3:*/		return 0x8210B648;
		  /* 8210B648h */ case    4:  		/* addi R11, R1, 92 */
		/* 8210B648h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x5C);
		/* 8210B648h case    4:*/		return 0x8210B64C;
		  /* 8210B64Ch */ case    5:  		/* lwz R10, <#[R23 + 24]> */
		/* 8210B64Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000018) );
		/* 8210B64Ch case    5:*/		return 0x8210B650;
		  /* 8210B650h */ case    6:  		/* mtspr CTR, R28 */
		/* 8210B650h case    6:*/		regs.CTR = regs.R28;
		/* 8210B650h case    6:*/		return 0x8210B654;
		  /* 8210B654h */ case    7:  		/* subf R9, R28, R9 */
		/* 8210B654h case    7:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R28,regs.R9);
		/* 8210B654h case    7:*/		return 0x8210B658;
		  /* 8210B658h */ case    8:  		/* add R7, R9, R8 */
		/* 8210B658h case    8:*/		cpu::op::add<0>(regs,&regs.R7,regs.R9,regs.R8);
		/* 8210B658h case    8:*/		return 0x8210B65C;
		  /* 8210B65Ch */ case    9:  		/* addi R8, R8, 1 */
		/* 8210B65Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8210B65Ch case    9:*/		return 0x8210B660;
		  /* 8210B660h */ case   10:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 8210B660h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 8210B660h case   10:*/		return 0x8210B664;
		  /* 8210B664h */ case   11:  		/* lwzx R7, <#[R7 + R10]> */
		/* 8210B664h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 8210B664h case   11:*/		return 0x8210B668;
	}
	return 0x8210B668;
} // Block from 8210B638h-8210B668h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8210B668h
// Function '?PropagateSwizzles@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B668);
		  /* 8210B668h */ case    0:  		/* stwu R7, <#[R11 + 4]> */
		/* 8210B668h case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8210B668h case    0:*/		return 0x8210B66C;
		  /* 8210B66Ch */ case    1:  		/* bc 16, CR0_LT, -20 */
		/* 8210B66Ch case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210B658;  }
		/* 8210B66Ch case    1:*/		return 0x8210B670;
	}
	return 0x8210B670;
} // Block from 8210B668h-8210B670h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210B670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B670);
		  /* 8210B670h */ case    0:  		/* lwz R11, <#[R23 + 12]> */
		/* 8210B670h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210B670h case    0:*/		return 0x8210B674;
		  /* 8210B674h */ case    1:  		/* subf R11, R28, R11 */
		/* 8210B674h case    1:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 8210B674h case    1:*/		return 0x8210B678;
		  /* 8210B678h */ case    2:  		/* addi R11, R11, -1 */
		/* 8210B678h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8210B678h case    2:*/		return 0x8210B67C;
		  /* 8210B67Ch */ case    3:  		/* cmplw CR6, R11, R25 */
		/* 8210B67Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 8210B67Ch case    3:*/		return 0x8210B680;
		  /* 8210B680h */ case    4:  		/* bc 4, CR6_GT, 52 */
		/* 8210B680h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8210B6B4;  }
		/* 8210B680h case    4:*/		return 0x8210B684;
		  /* 8210B684h */ case    5:  		/* subf R9, R25, R11 */
		/* 8210B684h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R25,regs.R11);
		/* 8210B684h case    5:*/		return 0x8210B688;
		  /* 8210B688h */ case    6:  		/* add R8, R28, R11 */
		/* 8210B688h case    6:*/		cpu::op::add<0>(regs,&regs.R8,regs.R28,regs.R11);
		/* 8210B688h case    6:*/		return 0x8210B68C;
		  /* 8210B68Ch */ case    7:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 8210B68Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 8210B68Ch case    7:*/		return 0x8210B690;
		  /* 8210B690h */ case    8:  		/* rlwinm R11, R8, 2, 0, 29 */
		/* 8210B690h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R8);
		/* 8210B690h case    8:*/		return 0x8210B694;
		  /* 8210B694h */ case    9:  		/* mtspr CTR, R9 */
		/* 8210B694h case    9:*/		regs.CTR = regs.R9;
		/* 8210B694h case    9:*/		return 0x8210B698;
		  /* 8210B698h */ case   10:  		/* lwz R9, <#[R23 + 24]> */
		/* 8210B698h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000018) );
		/* 8210B698h case   10:*/		return 0x8210B69C;
		  /* 8210B69Ch */ case   11:  		/* add R8, R9, R11 */
		/* 8210B69Ch case   11:*/		cpu::op::add<0>(regs,&regs.R8,regs.R9,regs.R11);
		/* 8210B69Ch case   11:*/		return 0x8210B6A0;
		  /* 8210B6A0h */ case   12:  		/* addi R11, R11, -4 */
		/* 8210B6A0h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8210B6A0h case   12:*/		return 0x8210B6A4;
		  /* 8210B6A4h */ case   13:  		/* lwzx R9, <#[R9 + R10]> */
		/* 8210B6A4h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210B6A4h case   13:*/		return 0x8210B6A8;
		  /* 8210B6A8h */ case   14:  		/* addi R10, R10, -4 */
		/* 8210B6A8h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 8210B6A8h case   14:*/		return 0x8210B6AC;
		  /* 8210B6ACh */ case   15:  		/* stw R9, <#[R8 - 4]> */
		/* 8210B6ACh case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + 0xFFFFFFFC) );
		/* 8210B6ACh case   15:*/		return 0x8210B6B0;
		  /* 8210B6B0h */ case   16:  		/* bc 16, CR0_LT, -24 */
		/* 8210B6B0h case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210B698;  }
		/* 8210B6B0h case   16:*/		return 0x8210B6B4;
	}
	return 0x8210B6B4;
} // Block from 8210B670h-8210B6B4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8210B6B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B6B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B6B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B6B4);
		  /* 8210B6B4h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 8210B6B4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8210B6B4h case    0:*/		return 0x8210B6B8;
		  /* 8210B6B8h */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 8210B6B8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8210B6DC;  }
		/* 8210B6B8h case    1:*/		return 0x8210B6BC;
		  /* 8210B6BCh */ case    2:  		/* addi R10, R1, 92 */
		/* 8210B6BCh case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x5C);
		/* 8210B6BCh case    2:*/		return 0x8210B6C0;
		  /* 8210B6C0h */ case    3:  		/* mtspr CTR, R28 */
		/* 8210B6C0h case    3:*/		regs.CTR = regs.R28;
		/* 8210B6C0h case    3:*/		return 0x8210B6C4;
		  /* 8210B6C4h */ case    4:  		/* mr R11, R24 */
		/* 8210B6C4h case    4:*/		regs.R11 = regs.R24;
		/* 8210B6C4h case    4:*/		return 0x8210B6C8;
		  /* 8210B6C8h */ case    5:  		/* lwzu R9, <#[R10 + 4]> */
		/* 8210B6C8h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8210B6C8h case    5:*/		return 0x8210B6CC;
		  /* 8210B6CCh */ case    6:  		/* lwz R8, <#[R23 + 24]> */
		/* 8210B6CCh case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R23 + 0x00000018) );
		/* 8210B6CCh case    6:*/		return 0x8210B6D0;
		  /* 8210B6D0h */ case    7:  		/* stwx R9, <#[R11 + R8]> */
		/* 8210B6D0h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8210B6D0h case    7:*/		return 0x8210B6D4;
		  /* 8210B6D4h */ case    8:  		/* addi R11, R11, 4 */
		/* 8210B6D4h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210B6D4h case    8:*/		return 0x8210B6D8;
		  /* 8210B6D8h */ case    9:  		/* bc 16, CR0_LT, -16 */
		/* 8210B6D8h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210B6C8;  }
		/* 8210B6D8h case    9:*/		return 0x8210B6DC;
	}
	return 0x8210B6DC;
} // Block from 8210B6B4h-8210B6DCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 8210B6DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B6DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B6DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B6DC);
		  /* 8210B6DCh */ case    0:  		/* mr R3, R29 */
		/* 8210B6DCh case    0:*/		regs.R3 = regs.R29;
		/* 8210B6DCh case    0:*/		return 0x8210B6E0;
		  /* 8210B6E0h */ case    1:  		/* bl 1121504 */
		/* 8210B6E0h case    1:*/		regs.LR = 0x8210B6E4; return 0x8221D3C0;
		/* 8210B6E0h case    1:*/		return 0x8210B6E4;
		  /* 8210B6E4h */ case    2:  		/* mr R3, R29 */
		/* 8210B6E4h case    2:*/		regs.R3 = regs.R29;
		/* 8210B6E4h case    2:*/		return 0x8210B6E8;
		  /* 8210B6E8h */ case    3:  		/* bl -61688 */
		/* 8210B6E8h case    3:*/		regs.LR = 0x8210B6EC; return 0x820FC5F0;
		/* 8210B6E8h case    3:*/		return 0x8210B6EC;
		  /* 8210B6ECh */ case    4:  		/* add R11, R28, R25 */
		/* 8210B6ECh case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R28,regs.R25);
		/* 8210B6ECh case    4:*/		return 0x8210B6F0;
		  /* 8210B6F0h */ case    5:  		/* mr R20, R17 */
		/* 8210B6F0h case    5:*/		regs.R20 = regs.R17;
		/* 8210B6F0h case    5:*/		return 0x8210B6F4;
		  /* 8210B6F4h */ case    6:  		/* addi R25, R11, -1 */
		/* 8210B6F4h case    6:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R11,0xFFFFFFFF);
		/* 8210B6F4h case    6:*/		return 0x8210B6F8;
		  /* 8210B6F8h */ case    7:  		/* lwz R11, <#[R23 + 12]> */
		/* 8210B6F8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210B6F8h case    7:*/		return 0x8210B6FC;
		  /* 8210B6FCh */ case    8:  		/* addi R11, R11, -1 */
		/* 8210B6FCh case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8210B6FCh case    8:*/		return 0x8210B700;
		  /* 8210B700h */ case    9:  		/* stw R11, <#[R23 + 12]> */
		/* 8210B700h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210B700h case    9:*/		return 0x8210B704;
	}
	return 0x8210B704;
} // Block from 8210B6DCh-8210B704h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8210B704h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B704( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B704) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B704);
		  /* 8210B704h */ case    0:  		/* lwz R11, <#[R23 + 12]> */
		/* 8210B704h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210B704h case    0:*/		return 0x8210B708;
		  /* 8210B708h */ case    1:  		/* addi R25, R25, 1 */
		/* 8210B708h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 8210B708h case    1:*/		return 0x8210B70C;
		  /* 8210B70Ch */ case    2:  		/* cmplw CR6, R25, R11 */
		/* 8210B70Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 8210B70Ch case    2:*/		return 0x8210B710;
		  /* 8210B710h */ case    3:  		/* bc 12, CR6_LT, -708 */
		/* 8210B710h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210B44C;  }
		/* 8210B710h case    3:*/		return 0x8210B714;
	}
	return 0x8210B714;
} // Block from 8210B704h-8210B714h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210B714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B714);
		  /* 8210B714h */ case    0:  		/* lwz R11, <#[R23 + 12]> */
		/* 8210B714h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210B714h case    0:*/		return 0x8210B718;
		  /* 8210B718h */ case    1:  		/* mr R25, R15 */
		/* 8210B718h case    1:*/		regs.R25 = regs.R15;
		/* 8210B718h case    1:*/		return 0x8210B71C;
		  /* 8210B71Ch */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8210B71Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210B71Ch case    2:*/		return 0x8210B720;
		  /* 8210B720h */ case    3:  		/* bc 4, CR6_GT, 1044 */
		/* 8210B720h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210BB34;  }
		/* 8210B720h case    3:*/		return 0x8210B724;
		  /* 8210B724h */ case    4:  		/* lwz R11, <#[R23 + 24]> */
		/* 8210B724h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000018) );
		/* 8210B724h case    4:*/		return 0x8210B728;
		  /* 8210B728h */ case    5:  		/* rlwinm R24, R25, 2, 0, 29 */
		/* 8210B728h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R24,regs.R25);
		/* 8210B728h case    5:*/		return 0x8210B72C;
		  /* 8210B72Ch */ case    6:  		/* lwzx R31, <#[R11 + R24]> */
		/* 8210B72Ch case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R24 + 0x00000000) );
		/* 8210B72Ch case    6:*/		return 0x8210B730;
		  /* 8210B730h */ case    7:  		/* lwz R11, <#[R31]> */
		/* 8210B730h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8210B730h case    7:*/		return 0x8210B734;
		  /* 8210B734h */ case    8:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 8210B734h case    8:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 8210B734h case    8:*/		return 0x8210B738;
		  /* 8210B738h */ case    9:  		/* cmplw CR6, R11, R14 */
		/* 8210B738h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 8210B738h case    9:*/		return 0x8210B73C;
		  /* 8210B73Ch */ case   10:  		/* bc 4, CR6_EQ, 1000 */
		/* 8210B73Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x8210BB24;  }
		/* 8210B73Ch case   10:*/		return 0x8210B740;
		  /* 8210B740h */ case   11:  		/* lwz R11, <#[R31 + 16]> */
		/* 8210B740h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8210B740h case   11:*/		return 0x8210B744;
		  /* 8210B744h */ case   12:  		/* lwz R3, <#[R23 + 20]> */
		/* 8210B744h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000014) );
		/* 8210B744h case   12:*/		return 0x8210B748;
		  /* 8210B748h */ case   13:  		/* lwz R10, <#[R23 + 16]> */
		/* 8210B748h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000010) );
		/* 8210B748h case   13:*/		return 0x8210B74C;
		  /* 8210B74Ch */ case   14:  		/* lwz R9, <#[R11]> */
		/* 8210B74Ch case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8210B74Ch case   14:*/		return 0x8210B750;
		  /* 8210B750h */ case   15:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210B750h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210B750h case   15:*/		return 0x8210B754;
		  /* 8210B754h */ case   16:  		/* lwzx R9, <#[R9 + R3]> */
		/* 8210B754h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8210B754h case   16:*/		return 0x8210B758;
		  /* 8210B758h */ case   17:  		/* lwz R9, <#[R9 + 4]> */
		/* 8210B758h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 8210B758h case   17:*/		return 0x8210B75C;
		  /* 8210B75Ch */ case   18:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210B75Ch case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210B75Ch case   18:*/		return 0x8210B760;
		  /* 8210B760h */ case   19:  		/* lwzx R10, <#[R9 + R10]> */
		/* 8210B760h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210B760h case   19:*/		return 0x8210B764;
		  /* 8210B764h */ case   20:  		/* lwz R10, <#[R10 + 4]> */
		/* 8210B764h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8210B764h case   20:*/		return 0x8210B768;
		  /* 8210B768h */ case   21:  		/* rlwinm. R10, R10, 0, 26, 26 */
		/* 8210B768h case   21:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R10,regs.R10);
		/* 8210B768h case   21:*/		return 0x8210B76C;
		  /* 8210B76Ch */ case   22:  		/* bc 4, CR0_EQ, 952 */
		/* 8210B76Ch case   22:*/		if ( !regs.CR[0].eq ) { return 0x8210BB24;  }
		/* 8210B76Ch case   22:*/		return 0x8210B770;
		  /* 8210B770h */ case   23:  		/* lwz R30, <#[R31 + 12]> */
		/* 8210B770h case   23:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210B770h case   23:*/		return 0x8210B774;
		  /* 8210B774h */ case   24:  		/* mr R4, R15 */
		/* 8210B774h case   24:*/		regs.R4 = regs.R15;
		/* 8210B774h case   24:*/		return 0x8210B778;
		  /* 8210B778h */ case   25:  		/* mr R28, R15 */
		/* 8210B778h case   25:*/		regs.R28 = regs.R15;
		/* 8210B778h case   25:*/		return 0x8210B77C;
		  /* 8210B77Ch */ case   26:  		/* mr R6, R15 */
		/* 8210B77Ch case   26:*/		regs.R6 = regs.R15;
		/* 8210B77Ch case   26:*/		return 0x8210B780;
		  /* 8210B780h */ case   27:  		/* cmplwi CR6, R30, 0 */
		/* 8210B780h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8210B780h case   27:*/		return 0x8210B784;
		  /* 8210B784h */ case   28:  		/* bc 12, CR6_EQ, 164 */
		/* 8210B784h case   28:*/		if ( regs.CR[6].eq ) { return 0x8210B828;  }
		/* 8210B784h case   28:*/		return 0x8210B788;
		  /* 8210B788h */ case   29:  		/* lwz R8, <#[R31 + 8]> */
		/* 8210B788h case   29:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 8210B788h case   29:*/		return 0x8210B78C;
		  /* 8210B78Ch */ case   30:  		/* mr R7, R15 */
		/* 8210B78Ch case   30:*/		regs.R7 = regs.R15;
		/* 8210B78Ch case   30:*/		return 0x8210B790;
		  /* 8210B790h */ case   31:  		/* subf R29, R8, R11 */
		/* 8210B790h case   31:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R8,regs.R11);
		/* 8210B790h case   31:*/		return 0x8210B794;
		  /* 8210B794h */ case   32:  		/* lwzx R11, <#[R29 + R8]> */
		/* 8210B794h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R8 + 0x00000000) );
		/* 8210B794h case   32:*/		return 0x8210B798;
		  /* 8210B798h */ case   33:  		/* lwz R10, <#[R8]> */
		/* 8210B798h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8210B798h case   33:*/		return 0x8210B79C;
		  /* 8210B79Ch */ case   34:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210B79Ch case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210B79Ch case   34:*/		return 0x8210B7A0;
		  /* 8210B7A0h */ case   35:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210B7A0h case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210B7A0h case   35:*/		return 0x8210B7A4;
		  /* 8210B7A4h */ case   36:  		/* lwzx R11, <#[R11 + R3]> */
		/* 8210B7A4h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8210B7A4h case   36:*/		return 0x8210B7A8;
		  /* 8210B7A8h */ case   37:  		/* lwzx R10, <#[R10 + R3]> */
		/* 8210B7A8h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 8210B7A8h case   37:*/		return 0x8210B7AC;
		  /* 8210B7ACh */ case   38:  		/* lwz R11, <#[R11 + 16]> */
		/* 8210B7ACh case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 8210B7ACh case   38:*/		return 0x8210B7B0;
		  /* 8210B7B0h */ case   39:  		/* lwz R10, <#[R10 + 16]> */
		/* 8210B7B0h case   39:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 8210B7B0h case   39:*/		return 0x8210B7B4;
		  /* 8210B7B4h */ case   40:  		/* cmplw CR6, R11, R10 */
		/* 8210B7B4h case   40:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210B7B4h case   40:*/		return 0x8210B7B8;
		  /* 8210B7B8h */ case   41:  		/* bc 4, CR6_EQ, 8 */
		/* 8210B7B8h case   41:*/		if ( !regs.CR[6].eq ) { return 0x8210B7C0;  }
		/* 8210B7B8h case   41:*/		return 0x8210B7BC;
		  /* 8210B7BCh */ case   42:  		/* addi R4, R4, 1 */
		/* 8210B7BCh case   42:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 8210B7BCh case   42:*/		return 0x8210B7C0;
	}
	return 0x8210B7C0;
} // Block from 8210B714h-8210B7C0h (43 instructions)

//////////////////////////////////////////////////////
// Block at 8210B7C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B7C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B7C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B7C0);
		  /* 8210B7C0h */ case    0:  		/* mr R5, R15 */
		/* 8210B7C0h case    0:*/		regs.R5 = regs.R15;
		/* 8210B7C0h case    0:*/		return 0x8210B7C4;
		  /* 8210B7C4h */ case    1:  		/* cmplwi CR6, R6, 0 */
		/* 8210B7C4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8210B7C4h case    1:*/		return 0x8210B7C8;
		  /* 8210B7C8h */ case    2:  		/* bc 12, CR6_EQ, 76 */
		/* 8210B7C8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8210B814;  }
		/* 8210B7C8h case    2:*/		return 0x8210B7CC;
		  /* 8210B7CCh */ case    3:  		/* lwz R10, <#[R31 + 8]> */
		/* 8210B7CCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8210B7CCh case    3:*/		return 0x8210B7D0;
		  /* 8210B7D0h */ case    4:  		/* mr R11, R15 */
		/* 8210B7D0h case    4:*/		regs.R11 = regs.R15;
		/* 8210B7D0h case    4:*/		return 0x8210B7D4;
		  /* 8210B7D4h */ case    5:  		/* lwzx R9, <#[R7 + R10]> */
		/* 8210B7D4h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 8210B7D4h case    5:*/		return 0x8210B7D8;
		  /* 8210B7D8h */ case    6:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210B7D8h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210B7D8h case    6:*/		return 0x8210B7DC;
		  /* 8210B7DCh */ case    7:  		/* lwzx R9, <#[R9 + R3]> */
		/* 8210B7DCh case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8210B7DCh case    7:*/		return 0x8210B7E0;
		  /* 8210B7E0h */ case    8:  		/* lwz R9, <#[R9 + 16]> */
		/* 8210B7E0h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000010) );
		/* 8210B7E0h case    8:*/		return 0x8210B7E4;
		  /* 8210B7E4h */ case    9:  		/* lwzx R27, <#[R11 + R10]> */
		/* 8210B7E4h case    9:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210B7E4h case    9:*/		return 0x8210B7E8;
		  /* 8210B7E8h */ case   10:  		/* rlwinm R27, R27, 2, 0, 29 */
		/* 8210B7E8h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R27);
		/* 8210B7E8h case   10:*/		return 0x8210B7EC;
		  /* 8210B7ECh */ case   11:  		/* lwzx R27, <#[R27 + R3]> */
		/* 8210B7ECh case   11:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R27 + regs.R3 + 0x00000000) );
		/* 8210B7ECh case   11:*/		return 0x8210B7F0;
		  /* 8210B7F0h */ case   12:  		/* lwz R27, <#[R27 + 16]> */
		/* 8210B7F0h case   12:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R27 + 0x00000010) );
		/* 8210B7F0h case   12:*/		return 0x8210B7F4;
		  /* 8210B7F4h */ case   13:  		/* cmplw CR6, R27, R9 */
		/* 8210B7F4h case   13:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R9);
		/* 8210B7F4h case   13:*/		return 0x8210B7F8;
		  /* 8210B7F8h */ case   14:  		/* bc 12, CR6_EQ, 24 */
		/* 8210B7F8h case   14:*/		if ( regs.CR[6].eq ) { return 0x8210B810;  }
		/* 8210B7F8h case   14:*/		return 0x8210B7FC;
		  /* 8210B7FCh */ case   15:  		/* addi R5, R5, 1 */
		/* 8210B7FCh case   15:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 8210B7FCh case   15:*/		return 0x8210B800;
		  /* 8210B800h */ case   16:  		/* addi R11, R11, 4 */
		/* 8210B800h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210B800h case   16:*/		return 0x8210B804;
		  /* 8210B804h */ case   17:  		/* cmplw CR6, R5, R6 */
		/* 8210B804h case   17:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R6);
		/* 8210B804h case   17:*/		return 0x8210B808;
		  /* 8210B808h */ case   18:  		/* bc 12, CR6_LT, -36 */
		/* 8210B808h case   18:*/		if ( regs.CR[6].lt ) { return 0x8210B7E4;  }
		/* 8210B808h case   18:*/		return 0x8210B80C;
		  /* 8210B80Ch */ case   19:  		/* b 8 */
		/* 8210B80Ch case   19:*/		return 0x8210B814;
		/* 8210B80Ch case   19:*/		return 0x8210B810;
	}
	return 0x8210B810;
} // Block from 8210B7C0h-8210B810h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8210B810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B810);
		  /* 8210B810h */ case    0:  		/* addi R28, R28, 1 */
		/* 8210B810h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8210B810h case    0:*/		return 0x8210B814;
	}
	return 0x8210B814;
} // Block from 8210B810h-8210B814h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210B814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B814);
		  /* 8210B814h */ case    0:  		/* addi R6, R6, 1 */
		/* 8210B814h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8210B814h case    0:*/		return 0x8210B818;
		  /* 8210B818h */ case    1:  		/* addi R7, R7, 4 */
		/* 8210B818h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 8210B818h case    1:*/		return 0x8210B81C;
		  /* 8210B81Ch */ case    2:  		/* addi R8, R8, 4 */
		/* 8210B81Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 8210B81Ch case    2:*/		return 0x8210B820;
		  /* 8210B820h */ case    3:  		/* cmplw CR6, R6, R30 */
		/* 8210B820h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R30);
		/* 8210B820h case    3:*/		return 0x8210B824;
		  /* 8210B824h */ case    4:  		/* bc 12, CR6_LT, -144 */
		/* 8210B824h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210B794;  }
		/* 8210B824h case    4:*/		return 0x8210B828;
	}
	return 0x8210B828;
} // Block from 8210B814h-8210B828h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210B828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B828);
		  /* 8210B828h */ case    0:  		/* cmplw CR6, R4, R30 */
		/* 8210B828h case    0:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R30);
		/* 8210B828h case    0:*/		return 0x8210B82C;
		  /* 8210B82Ch */ case    1:  		/* bc 12, CR6_EQ, 760 */
		/* 8210B82Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8210BB24;  }
		/* 8210B82Ch case    1:*/		return 0x8210B830;
		  /* 8210B830h */ case    2:  		/* addi R11, R28, 1 */
		/* 8210B830h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0x1);
		/* 8210B830h case    2:*/		return 0x8210B834;
		  /* 8210B834h */ case    3:  		/* cmplw CR6, R11, R30 */
		/* 8210B834h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 8210B834h case    3:*/		return 0x8210B838;
		  /* 8210B838h */ case    4:  		/* bc 12, CR6_EQ, 748 */
		/* 8210B838h case    4:*/		if ( regs.CR[6].eq ) { return 0x8210BB24;  }
		/* 8210B838h case    4:*/		return 0x8210B83C;
		  /* 8210B83Ch */ case    5:  		/* cmplwi CR6, R4, 1 */
		/* 8210B83Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000001);
		/* 8210B83Ch case    5:*/		return 0x8210B840;
		  /* 8210B840h */ case    6:  		/* bc 12, CR6_GT, 12 */
		/* 8210B840h case    6:*/		if ( regs.CR[6].gt ) { return 0x8210B84C;  }
		/* 8210B840h case    6:*/		return 0x8210B844;
		  /* 8210B844h */ case    7:  		/* cmplwi CR6, R28, 0 */
		/* 8210B844h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8210B844h case    7:*/		return 0x8210B848;
		  /* 8210B848h */ case    8:  		/* bc 12, CR6_EQ, 732 */
		/* 8210B848h case    8:*/		if ( regs.CR[6].eq ) { return 0x8210BB24;  }
		/* 8210B848h case    8:*/		return 0x8210B84C;
	}
	return 0x8210B84C;
} // Block from 8210B828h-8210B84Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8210B84Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B84C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B84C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B84C);
		  /* 8210B84Ch */ case    0:  		/* mr R28, R15 */
		/* 8210B84Ch case    0:*/		regs.R28 = regs.R15;
		/* 8210B84Ch case    0:*/		return 0x8210B850;
		  /* 8210B850h */ case    1:  		/* cmplwi CR6, R4, 1 */
		/* 8210B850h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000001);
		/* 8210B850h case    1:*/		return 0x8210B854;
		  /* 8210B854h */ case    2:  		/* bc 4, CR6_GT, 192 */
		/* 8210B854h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8210B914;  }
		/* 8210B854h case    2:*/		return 0x8210B858;
		  /* 8210B858h */ case    3:  		/* mr R6, R18 */
		/* 8210B858h case    3:*/		regs.R6 = regs.R18;
		/* 8210B858h case    3:*/		return 0x8210B85C;
		  /* 8210B85Ch */ case    4:  		/* rlwimi R4, R17, 28, 0, 11 */
		/* 8210B85Ch case    4:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R4,regs.R17);
		/* 8210B85Ch case    4:*/		return 0x8210B860;
		  /* 8210B860h */ case    5:  		/* mr R5, R18 */
		/* 8210B860h case    5:*/		regs.R5 = regs.R18;
		/* 8210B860h case    5:*/		return 0x8210B864;
		  /* 8210B864h */ case    6:  		/* mr R3, R23 */
		/* 8210B864h case    6:*/		regs.R3 = regs.R23;
		/* 8210B864h case    6:*/		return 0x8210B868;
		  /* 8210B868h */ case    7:  		/* bl -58784 */
		/* 8210B868h case    7:*/		regs.LR = 0x8210B86C; return 0x820FD2C8;
		/* 8210B868h case    7:*/		return 0x8210B86C;
		  /* 8210B86Ch */ case    8:  		/* cmpwi CR6, R3, -1 */
		/* 8210B86Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8210B86Ch case    8:*/		return 0x8210B870;
		  /* 8210B870h */ case    9:  		/* bc 12, CR6_EQ, 4392 */
		/* 8210B870h case    9:*/		if ( regs.CR[6].eq ) { return 0x8210C998;  }
		/* 8210B870h case    9:*/		return 0x8210B874;
		  /* 8210B874h */ case   10:  		/* lwz R11, <#[R23 + 24]> */
		/* 8210B874h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000018) );
		/* 8210B874h case   10:*/		return 0x8210B878;
		  /* 8210B878h */ case   11:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 8210B878h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 8210B878h case   11:*/		return 0x8210B87C;
		  /* 8210B87Ch */ case   12:  		/* mr R4, R31 */
		/* 8210B87Ch case   12:*/		regs.R4 = regs.R31;
		/* 8210B87Ch case   12:*/		return 0x8210B880;
		  /* 8210B880h */ case   13:  		/* lwzx R30, <#[R10 + R11]> */
		/* 8210B880h case   13:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210B880h case   13:*/		return 0x8210B884;
		  /* 8210B884h */ case   14:  		/* mr R3, R30 */
		/* 8210B884h case   14:*/		regs.R3 = regs.R30;
		/* 8210B884h case   14:*/		return 0x8210B888;
		  /* 8210B888h */ case   15:  		/* bl -63896 */
		/* 8210B888h case   15:*/		regs.LR = 0x8210B88C; return 0x820FBEF0;
		/* 8210B888h case   15:*/		return 0x8210B88C;
		  /* 8210B88Ch */ case   16:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210B88Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210B88Ch case   16:*/		return 0x8210B890;
		  /* 8210B890h */ case   17:  		/* mr R28, R17 */
		/* 8210B890h case   17:*/		regs.R28 = regs.R17;
		/* 8210B890h case   17:*/		return 0x8210B894;
		  /* 8210B894h */ case   18:  		/* mr R8, R15 */
		/* 8210B894h case   18:*/		regs.R8 = regs.R15;
		/* 8210B894h case   18:*/		return 0x8210B898;
		  /* 8210B898h */ case   19:  		/* cmplwi CR6, R11, 0 */
		/* 8210B898h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210B898h case   19:*/		return 0x8210B89C;
		  /* 8210B89Ch */ case   20:  		/* bc 4, CR6_GT, 120 */
		/* 8210B89Ch case   20:*/		if ( !regs.CR[6].gt ) { return 0x8210B914;  }
		/* 8210B89Ch case   20:*/		return 0x8210B8A0;
		  /* 8210B8A0h */ case   21:  		/* mr R11, R15 */
		/* 8210B8A0h case   21:*/		regs.R11 = regs.R15;
		/* 8210B8A0h case   21:*/		return 0x8210B8A4;
		  /* 8210B8A4h */ case   22:  		/* mr R10, R15 */
		/* 8210B8A4h case   22:*/		regs.R10 = regs.R15;
		/* 8210B8A4h case   22:*/		return 0x8210B8A8;
		  /* 8210B8A8h */ case   23:  		/* lwz R9, <#[R31 + 16]> */
		/* 8210B8A8h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 8210B8A8h case   23:*/		return 0x8210B8AC;
		  /* 8210B8ACh */ case   24:  		/* lwz R7, <#[R31 + 8]> */
		/* 8210B8ACh case   24:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000008) );
		/* 8210B8ACh case   24:*/		return 0x8210B8B0;
		  /* 8210B8B0h */ case   25:  		/* lwz R6, <#[R23 + 20]> */
		/* 8210B8B0h case   25:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R23 + 0x00000014) );
		/* 8210B8B0h case   25:*/		return 0x8210B8B4;
		  /* 8210B8B4h */ case   26:  		/* lwzx R9, <#[R11 + R9]> */
		/* 8210B8B4h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210B8B4h case   26:*/		return 0x8210B8B8;
		  /* 8210B8B8h */ case   27:  		/* lwzx R7, <#[R11 + R7]> */
		/* 8210B8B8h case   27:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 8210B8B8h case   27:*/		return 0x8210B8BC;
		  /* 8210B8BCh */ case   28:  		/* rlwinm R5, R9, 2, 0, 29 */
		/* 8210B8BCh case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R9);
		/* 8210B8BCh case   28:*/		return 0x8210B8C0;
		  /* 8210B8C0h */ case   29:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 8210B8C0h case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 8210B8C0h case   29:*/		return 0x8210B8C4;
		  /* 8210B8C4h */ case   30:  		/* lwzx R5, <#[R5 + R6]> */
		/* 8210B8C4h case   30:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R6 + 0x00000000) );
		/* 8210B8C4h case   30:*/		return 0x8210B8C8;
		  /* 8210B8C8h */ case   31:  		/* lwzx R7, <#[R7 + R6]> */
		/* 8210B8C8h case   31:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R6 + 0x00000000) );
		/* 8210B8C8h case   31:*/		return 0x8210B8CC;
		  /* 8210B8CCh */ case   32:  		/* lwz R6, <#[R5 + 16]> */
		/* 8210B8CCh case   32:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R5 + 0x00000010) );
		/* 8210B8CCh case   32:*/		return 0x8210B8D0;
		  /* 8210B8D0h */ case   33:  		/* lwz R7, <#[R7 + 16]> */
		/* 8210B8D0h case   33:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000010) );
		/* 8210B8D0h case   33:*/		return 0x8210B8D4;
		  /* 8210B8D4h */ case   34:  		/* cmplw CR6, R6, R7 */
		/* 8210B8D4h case   34:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R7);
		/* 8210B8D4h case   34:*/		return 0x8210B8D8;
		  /* 8210B8D8h */ case   35:  		/* bc 4, CR6_EQ, 40 */
		/* 8210B8D8h case   35:*/		if ( !regs.CR[6].eq ) { return 0x8210B900;  }
		/* 8210B8D8h case   35:*/		return 0x8210B8DC;
		  /* 8210B8DCh */ case   36:  		/* lwz R7, <#[R30 + 16]> */
		/* 8210B8DCh case   36:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000010) );
		/* 8210B8DCh case   36:*/		return 0x8210B8E0;
		  /* 8210B8E0h */ case   37:  		/* stwx R9, <#[R7 + R10]> */
		/* 8210B8E0h case   37:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 8210B8E0h case   37:*/		return 0x8210B8E4;
		  /* 8210B8E4h */ case   38:  		/* lwz R7, <#[R30 + 8]> */
		/* 8210B8E4h case   38:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000008) );
		/* 8210B8E4h case   38:*/		return 0x8210B8E8;
		  /* 8210B8E8h */ case   39:  		/* lwz R9, <#[R31 + 8]> */
		/* 8210B8E8h case   39:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 8210B8E8h case   39:*/		return 0x8210B8EC;
		  /* 8210B8ECh */ case   40:  		/* lwzx R9, <#[R11 + R9]> */
		/* 8210B8ECh case   40:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210B8ECh case   40:*/		return 0x8210B8F0;
		  /* 8210B8F0h */ case   41:  		/* stwx R9, <#[R7 + R10]> */
		/* 8210B8F0h case   41:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 8210B8F0h case   41:*/		return 0x8210B8F4;
		  /* 8210B8F4h */ case   42:  		/* addi R10, R10, 4 */
		/* 8210B8F4h case   42:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210B8F4h case   42:*/		return 0x8210B8F8;
		  /* 8210B8F8h */ case   43:  		/* lwz R9, <#[R31 + 8]> */
		/* 8210B8F8h case   43:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 8210B8F8h case   43:*/		return 0x8210B8FC;
		  /* 8210B8FCh */ case   44:  		/* stwx R18, <#[R11 + R9]> */
		/* 8210B8FCh case   44:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210B8FCh case   44:*/		return 0x8210B900;
	}
	return 0x8210B900;
} // Block from 8210B84Ch-8210B900h (45 instructions)

//////////////////////////////////////////////////////
// Block at 8210B900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B900);
		  /* 8210B900h */ case    0:  		/* lwz R9, <#[R31 + 12]> */
		/* 8210B900h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210B900h case    0:*/		return 0x8210B904;
		  /* 8210B904h */ case    1:  		/* addi R8, R8, 1 */
		/* 8210B904h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8210B904h case    1:*/		return 0x8210B908;
		  /* 8210B908h */ case    2:  		/* addi R11, R11, 4 */
		/* 8210B908h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210B908h case    2:*/		return 0x8210B90C;
		  /* 8210B90Ch */ case    3:  		/* cmplw CR6, R8, R9 */
		/* 8210B90Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8210B90Ch case    3:*/		return 0x8210B910;
		  /* 8210B910h */ case    4:  		/* bc 12, CR6_LT, -104 */
		/* 8210B910h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210B8A8;  }
		/* 8210B910h case    4:*/		return 0x8210B914;
	}
	return 0x8210B914;
} // Block from 8210B900h-8210B914h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210B914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B914);
		  /* 8210B914h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8210B914h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8210B914h case    0:*/		return 0x8210B918;
		  /* 8210B918h */ case    1:  		/* mr R29, R15 */
		/* 8210B918h case    1:*/		regs.R29 = regs.R15;
		/* 8210B918h case    1:*/		return 0x8210B91C;
		  /* 8210B91Ch */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8210B91Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210B91Ch case    2:*/		return 0x8210B920;
		  /* 8210B920h */ case    3:  		/* bc 12, CR6_EQ, 312 */
		/* 8210B920h case    3:*/		if ( regs.CR[6].eq ) { return 0x8210BA58;  }
		/* 8210B920h case    3:*/		return 0x8210B924;
		  /* 8210B924h */ case    4:  		/* mr R26, R15 */
		/* 8210B924h case    4:*/		regs.R26 = regs.R15;
		/* 8210B924h case    4:*/		return 0x8210B928;
		  /* 8210B928h */ case    5:  		/* lwz R6, <#[R31 + 8]> */
		/* 8210B928h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000008) );
		/* 8210B928h case    5:*/		return 0x8210B92C;
		  /* 8210B92Ch */ case    6:  		/* lwzx R10, <#[R26 + R6]> */
		/* 8210B92Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + regs.R6 + 0x00000000) );
		/* 8210B92Ch case    6:*/		return 0x8210B930;
		  /* 8210B930h */ case    7:  		/* cmpwi CR6, R10, -1 */
		/* 8210B930h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210B930h case    7:*/		return 0x8210B934;
		  /* 8210B934h */ case    8:  		/* bc 12, CR6_EQ, 276 */
		/* 8210B934h case    8:*/		if ( regs.CR[6].eq ) { return 0x8210BA48;  }
		/* 8210B934h case    8:*/		return 0x8210B938;
		  /* 8210B938h */ case    9:  		/* lwz R9, <#[R23 + 20]> */
		/* 8210B938h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000014) );
		/* 8210B938h case    9:*/		return 0x8210B93C;
		  /* 8210B93Ch */ case   10:  		/* rlwinm R8, R10, 2, 0, 29 */
		/* 8210B93Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R10);
		/* 8210B93Ch case   10:*/		return 0x8210B940;
		  /* 8210B940h */ case   11:  		/* mr R4, R15 */
		/* 8210B940h case   11:*/		regs.R4 = regs.R15;
		/* 8210B940h case   11:*/		return 0x8210B944;
		  /* 8210B944h */ case   12:  		/* mr R10, R29 */
		/* 8210B944h case   12:*/		regs.R10 = regs.R29;
		/* 8210B944h case   12:*/		return 0x8210B948;
		  /* 8210B948h */ case   13:  		/* cmplw CR6, R29, R11 */
		/* 8210B948h case   13:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8210B948h case   13:*/		return 0x8210B94C;
		  /* 8210B94Ch */ case   14:  		/* lwzx R8, <#[R8 + R9]> */
		/* 8210B94Ch case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 8210B94Ch case   14:*/		return 0x8210B950;
		  /* 8210B950h */ case   15:  		/* lwz R27, <#[R8 + 16]> */
		/* 8210B950h case   15:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R8 + 0x00000010) );
		/* 8210B950h case   15:*/		return 0x8210B954;
		  /* 8210B954h */ case   16:  		/* bc 4, CR6_LT, 60 */
		/* 8210B954h case   16:*/		if ( !regs.CR[6].lt ) { return 0x8210B990;  }
		/* 8210B954h case   16:*/		return 0x8210B958;
		  /* 8210B958h */ case   17:  		/* mr R7, R26 */
		/* 8210B958h case   17:*/		regs.R7 = regs.R26;
		/* 8210B958h case   17:*/		return 0x8210B95C;
		  /* 8210B95Ch */ case   18:  		/* lwzx R8, <#[R7 + R6]> */
		/* 8210B95Ch case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R6 + 0x00000000) );
		/* 8210B95Ch case   18:*/		return 0x8210B960;
		  /* 8210B960h */ case   19:  		/* cmpwi CR6, R8, -1 */
		/* 8210B960h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 8210B960h case   19:*/		return 0x8210B964;
		  /* 8210B964h */ case   20:  		/* bc 12, CR6_EQ, 28 */
		/* 8210B964h case   20:*/		if ( regs.CR[6].eq ) { return 0x8210B980;  }
		/* 8210B964h case   20:*/		return 0x8210B968;
		  /* 8210B968h */ case   21:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8210B968h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8210B968h case   21:*/		return 0x8210B96C;
		  /* 8210B96Ch */ case   22:  		/* lwzx R8, <#[R8 + R9]> */
		/* 8210B96Ch case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 8210B96Ch case   22:*/		return 0x8210B970;
		  /* 8210B970h */ case   23:  		/* lwz R8, <#[R8 + 16]> */
		/* 8210B970h case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000010) );
		/* 8210B970h case   23:*/		return 0x8210B974;
		  /* 8210B974h */ case   24:  		/* cmplw CR6, R27, R8 */
		/* 8210B974h case   24:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R8);
		/* 8210B974h case   24:*/		return 0x8210B978;
		  /* 8210B978h */ case   25:  		/* bc 4, CR6_EQ, 8 */
		/* 8210B978h case   25:*/		if ( !regs.CR[6].eq ) { return 0x8210B980;  }
		/* 8210B978h case   25:*/		return 0x8210B97C;
		  /* 8210B97Ch */ case   26:  		/* addi R4, R4, 1 */
		/* 8210B97Ch case   26:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 8210B97Ch case   26:*/		return 0x8210B980;
	}
	return 0x8210B980;
} // Block from 8210B914h-8210B980h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8210B980h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B980);
		  /* 8210B980h */ case    0:  		/* addi R10, R10, 1 */
		/* 8210B980h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210B980h case    0:*/		return 0x8210B984;
		  /* 8210B984h */ case    1:  		/* addi R7, R7, 4 */
		/* 8210B984h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 8210B984h case    1:*/		return 0x8210B988;
		  /* 8210B988h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 8210B988h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8210B988h case    2:*/		return 0x8210B98C;
		  /* 8210B98Ch */ case    3:  		/* bc 12, CR6_LT, -48 */
		/* 8210B98Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8210B95C;  }
		/* 8210B98Ch case    3:*/		return 0x8210B990;
	}
	return 0x8210B990;
} // Block from 8210B980h-8210B990h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210B990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210B990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210B990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210B990);
		  /* 8210B990h */ case    0:  		/* mr R6, R18 */
		/* 8210B990h case    0:*/		regs.R6 = regs.R18;
		/* 8210B990h case    0:*/		return 0x8210B994;
		  /* 8210B994h */ case    1:  		/* rlwimi R4, R17, 28, 0, 11 */
		/* 8210B994h case    1:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R4,regs.R17);
		/* 8210B994h case    1:*/		return 0x8210B998;
		  /* 8210B998h */ case    2:  		/* mr R5, R18 */
		/* 8210B998h case    2:*/		regs.R5 = regs.R18;
		/* 8210B998h case    2:*/		return 0x8210B99C;
		  /* 8210B99Ch */ case    3:  		/* mr R3, R23 */
		/* 8210B99Ch case    3:*/		regs.R3 = regs.R23;
		/* 8210B99Ch case    3:*/		return 0x8210B9A0;
		  /* 8210B9A0h */ case    4:  		/* bl -59096 */
		/* 8210B9A0h case    4:*/		regs.LR = 0x8210B9A4; return 0x820FD2C8;
		/* 8210B9A0h case    4:*/		return 0x8210B9A4;
		  /* 8210B9A4h */ case    5:  		/* cmpwi CR6, R3, -1 */
		/* 8210B9A4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8210B9A4h case    5:*/		return 0x8210B9A8;
		  /* 8210B9A8h */ case    6:  		/* bc 12, CR6_EQ, 4080 */
		/* 8210B9A8h case    6:*/		if ( regs.CR[6].eq ) { return 0x8210C998;  }
		/* 8210B9A8h case    6:*/		return 0x8210B9AC;
		  /* 8210B9ACh */ case    7:  		/* lwz R11, <#[R23 + 24]> */
		/* 8210B9ACh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000018) );
		/* 8210B9ACh case    7:*/		return 0x8210B9B0;
		  /* 8210B9B0h */ case    8:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 8210B9B0h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 8210B9B0h case    8:*/		return 0x8210B9B4;
		  /* 8210B9B4h */ case    9:  		/* mr R4, R31 */
		/* 8210B9B4h case    9:*/		regs.R4 = regs.R31;
		/* 8210B9B4h case    9:*/		return 0x8210B9B8;
		  /* 8210B9B8h */ case   10:  		/* lwzx R30, <#[R10 + R11]> */
		/* 8210B9B8h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210B9B8h case   10:*/		return 0x8210B9BC;
		  /* 8210B9BCh */ case   11:  		/* mr R3, R30 */
		/* 8210B9BCh case   11:*/		regs.R3 = regs.R30;
		/* 8210B9BCh case   11:*/		return 0x8210B9C0;
		  /* 8210B9C0h */ case   12:  		/* bl -64208 */
		/* 8210B9C0h case   12:*/		regs.LR = 0x8210B9C4; return 0x820FBEF0;
		/* 8210B9C0h case   12:*/		return 0x8210B9C4;
		  /* 8210B9C4h */ case   13:  		/* lwz R11, <#[R31 + 4]> */
		/* 8210B9C4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8210B9C4h case   13:*/		return 0x8210B9C8;
		  /* 8210B9C8h */ case   14:  		/* addi R28, R28, 1 */
		/* 8210B9C8h case   14:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8210B9C8h case   14:*/		return 0x8210B9CC;
		  /* 8210B9CCh */ case   15:  		/* mr R8, R29 */
		/* 8210B9CCh case   15:*/		regs.R8 = regs.R29;
		/* 8210B9CCh case   15:*/		return 0x8210B9D0;
		  /* 8210B9D0h */ case   16:  		/* cmplw CR6, R29, R11 */
		/* 8210B9D0h case   16:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8210B9D0h case   16:*/		return 0x8210B9D4;
		  /* 8210B9D4h */ case   17:  		/* bc 4, CR6_LT, 116 */
		/* 8210B9D4h case   17:*/		if ( !regs.CR[6].lt ) { return 0x8210BA48;  }
		/* 8210B9D4h case   17:*/		return 0x8210B9D8;
		  /* 8210B9D8h */ case   18:  		/* mr R10, R26 */
		/* 8210B9D8h case   18:*/		regs.R10 = regs.R26;
		/* 8210B9D8h case   18:*/		return 0x8210B9DC;
		  /* 8210B9DCh */ case   19:  		/* mr R9, R15 */
		/* 8210B9DCh case   19:*/		regs.R9 = regs.R15;
		/* 8210B9DCh case   19:*/		return 0x8210B9E0;
		  /* 8210B9E0h */ case   20:  		/* lwz R11, <#[R31 + 8]> */
		/* 8210B9E0h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8210B9E0h case   20:*/		return 0x8210B9E4;
		  /* 8210B9E4h */ case   21:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8210B9E4h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210B9E4h case   21:*/		return 0x8210B9E8;
		  /* 8210B9E8h */ case   22:  		/* cmpwi CR6, R11, -1 */
		/* 8210B9E8h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210B9E8h case   22:*/		return 0x8210B9EC;
		  /* 8210B9ECh */ case   23:  		/* bc 12, CR6_EQ, 72 */
		/* 8210B9ECh case   23:*/		if ( regs.CR[6].eq ) { return 0x8210BA34;  }
		/* 8210B9ECh case   23:*/		return 0x8210B9F0;
		  /* 8210B9F0h */ case   24:  		/* lwz R7, <#[R23 + 20]> */
		/* 8210B9F0h case   24:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R23 + 0x00000014) );
		/* 8210B9F0h case   24:*/		return 0x8210B9F4;
		  /* 8210B9F4h */ case   25:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210B9F4h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210B9F4h case   25:*/		return 0x8210B9F8;
		  /* 8210B9F8h */ case   26:  		/* lwzx R11, <#[R11 + R7]> */
		/* 8210B9F8h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 8210B9F8h case   26:*/		return 0x8210B9FC;
		  /* 8210B9FCh */ case   27:  		/* lwz R11, <#[R11 + 16]> */
		/* 8210B9FCh case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 8210B9FCh case   27:*/		return 0x8210BA00;
		  /* 8210BA00h */ case   28:  		/* cmplw CR6, R27, R11 */
		/* 8210BA00h case   28:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 8210BA00h case   28:*/		return 0x8210BA04;
		  /* 8210BA04h */ case   29:  		/* bc 4, CR6_EQ, 48 */
		/* 8210BA04h case   29:*/		if ( !regs.CR[6].eq ) { return 0x8210BA34;  }
		/* 8210BA04h case   29:*/		return 0x8210BA08;
		  /* 8210BA08h */ case   30:  		/* lwz R11, <#[R31 + 16]> */
		/* 8210BA08h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8210BA08h case   30:*/		return 0x8210BA0C;
		  /* 8210BA0Ch */ case   31:  		/* lwz R7, <#[R30 + 16]> */
		/* 8210BA0Ch case   31:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000010) );
		/* 8210BA0Ch case   31:*/		return 0x8210BA10;
		  /* 8210BA10h */ case   32:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8210BA10h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210BA10h case   32:*/		return 0x8210BA14;
		  /* 8210BA14h */ case   33:  		/* stwx R11, <#[R7 + R9]> */
		/* 8210BA14h case   33:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 8210BA14h case   33:*/		return 0x8210BA18;
		  /* 8210BA18h */ case   34:  		/* lwz R11, <#[R31 + 8]> */
		/* 8210BA18h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8210BA18h case   34:*/		return 0x8210BA1C;
		  /* 8210BA1Ch */ case   35:  		/* lwz R7, <#[R30 + 8]> */
		/* 8210BA1Ch case   35:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000008) );
		/* 8210BA1Ch case   35:*/		return 0x8210BA20;
		  /* 8210BA20h */ case   36:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8210BA20h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210BA20h case   36:*/		return 0x8210BA24;
		  /* 8210BA24h */ case   37:  		/* stwx R11, <#[R7 + R9]> */
		/* 8210BA24h case   37:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 8210BA24h case   37:*/		return 0x8210BA28;
		  /* 8210BA28h */ case   38:  		/* addi R9, R9, 4 */
		/* 8210BA28h case   38:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8210BA28h case   38:*/		return 0x8210BA2C;
		  /* 8210BA2Ch */ case   39:  		/* lwz R11, <#[R31 + 8]> */
		/* 8210BA2Ch case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8210BA2Ch case   39:*/		return 0x8210BA30;
		  /* 8210BA30h */ case   40:  		/* stwx R18, <#[R10 + R11]> */
		/* 8210BA30h case   40:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210BA30h case   40:*/		return 0x8210BA34;
	}
	return 0x8210BA34;
} // Block from 8210B990h-8210BA34h (41 instructions)

//////////////////////////////////////////////////////
// Block at 8210BA34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BA34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BA34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BA34);
		  /* 8210BA34h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8210BA34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8210BA34h case    0:*/		return 0x8210BA38;
		  /* 8210BA38h */ case    1:  		/* addi R8, R8, 1 */
		/* 8210BA38h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8210BA38h case    1:*/		return 0x8210BA3C;
		  /* 8210BA3Ch */ case    2:  		/* addi R10, R10, 4 */
		/* 8210BA3Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210BA3Ch case    2:*/		return 0x8210BA40;
		  /* 8210BA40h */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 8210BA40h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8210BA40h case    3:*/		return 0x8210BA44;
		  /* 8210BA44h */ case    4:  		/* bc 12, CR6_LT, -100 */
		/* 8210BA44h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210B9E0;  }
		/* 8210BA44h case    4:*/		return 0x8210BA48;
	}
	return 0x8210BA48;
} // Block from 8210BA34h-8210BA48h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210BA48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BA48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BA48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BA48);
		  /* 8210BA48h */ case    0:  		/* addi R29, R29, 1 */
		/* 8210BA48h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8210BA48h case    0:*/		return 0x8210BA4C;
		  /* 8210BA4Ch */ case    1:  		/* addi R26, R26, 4 */
		/* 8210BA4Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 8210BA4Ch case    1:*/		return 0x8210BA50;
		  /* 8210BA50h */ case    2:  		/* cmplw CR6, R29, R11 */
		/* 8210BA50h case    2:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8210BA50h case    2:*/		return 0x8210BA54;
		  /* 8210BA54h */ case    3:  		/* bc 12, CR6_LT, -300 */
		/* 8210BA54h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210B928;  }
		/* 8210BA54h case    3:*/		return 0x8210BA58;
	}
	return 0x8210BA58;
} // Block from 8210BA48h-8210BA58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210BA58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BA58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BA58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BA58);
		  /* 8210BA58h */ case    0:  		/* mr R8, R15 */
		/* 8210BA58h case    0:*/		regs.R8 = regs.R15;
		/* 8210BA58h case    0:*/		return 0x8210BA5C;
		  /* 8210BA5Ch */ case    1:  		/* cmplwi CR6, R28, 0 */
		/* 8210BA5Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8210BA5Ch case    1:*/		return 0x8210BA60;
		  /* 8210BA60h */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 8210BA60h case    2:*/		if ( regs.CR[6].eq ) { return 0x8210BA90;  }
		/* 8210BA60h case    2:*/		return 0x8210BA64;
		  /* 8210BA64h */ case    3:  		/* lwz R9, <#[R23 + 12]> */
		/* 8210BA64h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210BA64h case    3:*/		return 0x8210BA68;
		  /* 8210BA68h */ case    4:  		/* addi R11, R1, 92 */
		/* 8210BA68h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x5C);
		/* 8210BA68h case    4:*/		return 0x8210BA6C;
		  /* 8210BA6Ch */ case    5:  		/* lwz R10, <#[R23 + 24]> */
		/* 8210BA6Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000018) );
		/* 8210BA6Ch case    5:*/		return 0x8210BA70;
		  /* 8210BA70h */ case    6:  		/* mtspr CTR, R28 */
		/* 8210BA70h case    6:*/		regs.CTR = regs.R28;
		/* 8210BA70h case    6:*/		return 0x8210BA74;
		  /* 8210BA74h */ case    7:  		/* subf R9, R28, R9 */
		/* 8210BA74h case    7:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R28,regs.R9);
		/* 8210BA74h case    7:*/		return 0x8210BA78;
		  /* 8210BA78h */ case    8:  		/* add R7, R8, R9 */
		/* 8210BA78h case    8:*/		cpu::op::add<0>(regs,&regs.R7,regs.R8,regs.R9);
		/* 8210BA78h case    8:*/		return 0x8210BA7C;
		  /* 8210BA7Ch */ case    9:  		/* addi R8, R8, 1 */
		/* 8210BA7Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8210BA7Ch case    9:*/		return 0x8210BA80;
		  /* 8210BA80h */ case   10:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 8210BA80h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 8210BA80h case   10:*/		return 0x8210BA84;
		  /* 8210BA84h */ case   11:  		/* lwzx R7, <#[R7 + R10]> */
		/* 8210BA84h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 8210BA84h case   11:*/		return 0x8210BA88;
		  /* 8210BA88h */ case   12:  		/* stwu R7, <#[R11 + 4]> */
		/* 8210BA88h case   12:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8210BA88h case   12:*/		return 0x8210BA8C;
		  /* 8210BA8Ch */ case   13:  		/* bc 16, CR0_LT, -20 */
		/* 8210BA8Ch case   13:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210BA78;  }
		/* 8210BA8Ch case   13:*/		return 0x8210BA90;
	}
	return 0x8210BA90;
} // Block from 8210BA58h-8210BA90h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8210BA90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BA90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BA90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BA90);
		  /* 8210BA90h */ case    0:  		/* lwz R11, <#[R23 + 12]> */
		/* 8210BA90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210BA90h case    0:*/		return 0x8210BA94;
		  /* 8210BA94h */ case    1:  		/* subf R11, R28, R11 */
		/* 8210BA94h case    1:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 8210BA94h case    1:*/		return 0x8210BA98;
		  /* 8210BA98h */ case    2:  		/* addi R11, R11, -1 */
		/* 8210BA98h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8210BA98h case    2:*/		return 0x8210BA9C;
		  /* 8210BA9Ch */ case    3:  		/* cmplw CR6, R11, R25 */
		/* 8210BA9Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 8210BA9Ch case    3:*/		return 0x8210BAA0;
		  /* 8210BAA0h */ case    4:  		/* bc 4, CR6_GT, 52 */
		/* 8210BAA0h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8210BAD4;  }
		/* 8210BAA0h case    4:*/		return 0x8210BAA4;
		  /* 8210BAA4h */ case    5:  		/* subf R9, R25, R11 */
		/* 8210BAA4h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R25,regs.R11);
		/* 8210BAA4h case    5:*/		return 0x8210BAA8;
		  /* 8210BAA8h */ case    6:  		/* add R8, R11, R28 */
		/* 8210BAA8h case    6:*/		cpu::op::add<0>(regs,&regs.R8,regs.R11,regs.R28);
		/* 8210BAA8h case    6:*/		return 0x8210BAAC;
		  /* 8210BAACh */ case    7:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 8210BAACh case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 8210BAACh case    7:*/		return 0x8210BAB0;
		  /* 8210BAB0h */ case    8:  		/* rlwinm R11, R8, 2, 0, 29 */
		/* 8210BAB0h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R8);
		/* 8210BAB0h case    8:*/		return 0x8210BAB4;
		  /* 8210BAB4h */ case    9:  		/* mtspr CTR, R9 */
		/* 8210BAB4h case    9:*/		regs.CTR = regs.R9;
		/* 8210BAB4h case    9:*/		return 0x8210BAB8;
		  /* 8210BAB8h */ case   10:  		/* lwz R9, <#[R23 + 24]> */
		/* 8210BAB8h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000018) );
		/* 8210BAB8h case   10:*/		return 0x8210BABC;
		  /* 8210BABCh */ case   11:  		/* add R8, R11, R9 */
		/* 8210BABCh case   11:*/		cpu::op::add<0>(regs,&regs.R8,regs.R11,regs.R9);
		/* 8210BABCh case   11:*/		return 0x8210BAC0;
		  /* 8210BAC0h */ case   12:  		/* addi R11, R11, -4 */
		/* 8210BAC0h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8210BAC0h case   12:*/		return 0x8210BAC4;
		  /* 8210BAC4h */ case   13:  		/* lwzx R9, <#[R10 + R9]> */
		/* 8210BAC4h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210BAC4h case   13:*/		return 0x8210BAC8;
		  /* 8210BAC8h */ case   14:  		/* addi R10, R10, -4 */
		/* 8210BAC8h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 8210BAC8h case   14:*/		return 0x8210BACC;
		  /* 8210BACCh */ case   15:  		/* stw R9, <#[R8 - 4]> */
		/* 8210BACCh case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + 0xFFFFFFFC) );
		/* 8210BACCh case   15:*/		return 0x8210BAD0;
		  /* 8210BAD0h */ case   16:  		/* bc 16, CR0_LT, -24 */
		/* 8210BAD0h case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210BAB8;  }
		/* 8210BAD0h case   16:*/		return 0x8210BAD4;
	}
	return 0x8210BAD4;
} // Block from 8210BA90h-8210BAD4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8210BAD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BAD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BAD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BAD4);
		  /* 8210BAD4h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 8210BAD4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8210BAD4h case    0:*/		return 0x8210BAD8;
		  /* 8210BAD8h */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 8210BAD8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8210BAFC;  }
		/* 8210BAD8h case    1:*/		return 0x8210BADC;
		  /* 8210BADCh */ case    2:  		/* addi R10, R1, 92 */
		/* 8210BADCh case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x5C);
		/* 8210BADCh case    2:*/		return 0x8210BAE0;
		  /* 8210BAE0h */ case    3:  		/* mtspr CTR, R28 */
		/* 8210BAE0h case    3:*/		regs.CTR = regs.R28;
		/* 8210BAE0h case    3:*/		return 0x8210BAE4;
		  /* 8210BAE4h */ case    4:  		/* mr R11, R24 */
		/* 8210BAE4h case    4:*/		regs.R11 = regs.R24;
		/* 8210BAE4h case    4:*/		return 0x8210BAE8;
		  /* 8210BAE8h */ case    5:  		/* lwzu R9, <#[R10 + 4]> */
		/* 8210BAE8h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8210BAE8h case    5:*/		return 0x8210BAEC;
		  /* 8210BAECh */ case    6:  		/* lwz R8, <#[R23 + 24]> */
		/* 8210BAECh case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R23 + 0x00000018) );
		/* 8210BAECh case    6:*/		return 0x8210BAF0;
		  /* 8210BAF0h */ case    7:  		/* stwx R9, <#[R8 + R11]> */
		/* 8210BAF0h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8210BAF0h case    7:*/		return 0x8210BAF4;
		  /* 8210BAF4h */ case    8:  		/* addi R11, R11, 4 */
		/* 8210BAF4h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210BAF4h case    8:*/		return 0x8210BAF8;
		  /* 8210BAF8h */ case    9:  		/* bc 16, CR0_LT, -16 */
		/* 8210BAF8h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210BAE8;  }
		/* 8210BAF8h case    9:*/		return 0x8210BAFC;
	}
	return 0x8210BAFC;
} // Block from 8210BAD4h-8210BAFCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 8210BAFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BAFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BAFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BAFC);
		  /* 8210BAFCh */ case    0:  		/* mr R3, R31 */
		/* 8210BAFCh case    0:*/		regs.R3 = regs.R31;
		/* 8210BAFCh case    0:*/		return 0x8210BB00;
		  /* 8210BB00h */ case    1:  		/* bl 1120448 */
		/* 8210BB00h case    1:*/		regs.LR = 0x8210BB04; return 0x8221D3C0;
		/* 8210BB00h case    1:*/		return 0x8210BB04;
		  /* 8210BB04h */ case    2:  		/* mr R3, R31 */
		/* 8210BB04h case    2:*/		regs.R3 = regs.R31;
		/* 8210BB04h case    2:*/		return 0x8210BB08;
		  /* 8210BB08h */ case    3:  		/* bl -62744 */
		/* 8210BB08h case    3:*/		regs.LR = 0x8210BB0C; return 0x820FC5F0;
		/* 8210BB08h case    3:*/		return 0x8210BB0C;
		  /* 8210BB0Ch */ case    4:  		/* add R11, R28, R25 */
		/* 8210BB0Ch case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R28,regs.R25);
		/* 8210BB0Ch case    4:*/		return 0x8210BB10;
		  /* 8210BB10h */ case    5:  		/* mr R20, R17 */
		/* 8210BB10h case    5:*/		regs.R20 = regs.R17;
		/* 8210BB10h case    5:*/		return 0x8210BB14;
		  /* 8210BB14h */ case    6:  		/* addi R25, R11, -1 */
		/* 8210BB14h case    6:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R11,0xFFFFFFFF);
		/* 8210BB14h case    6:*/		return 0x8210BB18;
		  /* 8210BB18h */ case    7:  		/* lwz R11, <#[R23 + 12]> */
		/* 8210BB18h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210BB18h case    7:*/		return 0x8210BB1C;
		  /* 8210BB1Ch */ case    8:  		/* addi R11, R11, -1 */
		/* 8210BB1Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8210BB1Ch case    8:*/		return 0x8210BB20;
		  /* 8210BB20h */ case    9:  		/* stw R11, <#[R23 + 12]> */
		/* 8210BB20h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210BB20h case    9:*/		return 0x8210BB24;
	}
	return 0x8210BB24;
} // Block from 8210BAFCh-8210BB24h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8210BB24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BB24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BB24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BB24);
		  /* 8210BB24h */ case    0:  		/* lwz R11, <#[R23 + 12]> */
		/* 8210BB24h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210BB24h case    0:*/		return 0x8210BB28;
		  /* 8210BB28h */ case    1:  		/* addi R25, R25, 1 */
		/* 8210BB28h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 8210BB28h case    1:*/		return 0x8210BB2C;
		  /* 8210BB2Ch */ case    2:  		/* cmplw CR6, R25, R11 */
		/* 8210BB2Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 8210BB2Ch case    2:*/		return 0x8210BB30;
		  /* 8210BB30h */ case    3:  		/* bc 12, CR6_LT, -1036 */
		/* 8210BB30h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210B724;  }
		/* 8210BB30h case    3:*/		return 0x8210BB34;
	}
	return 0x8210BB34;
} // Block from 8210BB24h-8210BB34h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210BB34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BB34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BB34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BB34);
		  /* 8210BB34h */ case    0:  		/* cmpwi CR6, R20, 0 */
		/* 8210BB34h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 8210BB34h case    0:*/		return 0x8210BB38;
		  /* 8210BB38h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8210BB38h case    1:*/		if ( regs.CR[6].eq ) { return 0x8210BB44;  }
		/* 8210BB38h case    1:*/		return 0x8210BB3C;
		  /* 8210BB3Ch */ case    2:  		/* mr R3, R23 */
		/* 8210BB3Ch case    2:*/		regs.R3 = regs.R23;
		/* 8210BB3Ch case    2:*/		return 0x8210BB40;
		  /* 8210BB40h */ case    3:  		/* bl -24488 */
		/* 8210BB40h case    3:*/		regs.LR = 0x8210BB44; return 0x82105B98;
		/* 8210BB40h case    3:*/		return 0x8210BB44;
	}
	return 0x8210BB44;
} // Block from 8210BB34h-8210BB44h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210BB44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BB44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BB44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BB44);
		  /* 8210BB44h */ case    0:  		/* rlwinm R31, R19, 2, 0, 29 */
		/* 8210BB44h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R19);
		/* 8210BB44h case    0:*/		return 0x8210BB48;
		  /* 8210BB48h */ case    1:  		/* lis R4, 9345 */
		/* 8210BB48h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210BB48h case    1:*/		return 0x8210BB4C;
		  /* 8210BB4Ch */ case    2:  		/* mr R3, R31 */
		/* 8210BB4Ch case    2:*/		regs.R3 = regs.R31;
		/* 8210BB4Ch case    2:*/		return 0x8210BB50;
		  /* 8210BB50h */ case    3:  		/* bl -538960 */
		/* 8210BB50h case    3:*/		regs.LR = 0x8210BB54; return 0x82088200;
		/* 8210BB50h case    3:*/		return 0x8210BB54;
		  /* 8210BB54h */ case    4:  		/* or. R21, R3, R3 */
		/* 8210BB54h case    4:*/		cpu::op::or<1>(regs,&regs.R21,regs.R3,regs.R3);
		/* 8210BB54h case    4:*/		return 0x8210BB58;
		  /* 8210BB58h */ case    5:  		/* stw R21, <#[R1 + 84]> */
		/* 8210BB58h case    5:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000054) );
		/* 8210BB58h case    5:*/		return 0x8210BB5C;
		  /* 8210BB5Ch */ case    6:  		/* bc 12, CR0_EQ, 3644 */
		/* 8210BB5Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x8210C998;  }
		/* 8210BB5Ch case    6:*/		return 0x8210BB60;
		  /* 8210BB60h */ case    7:  		/* mr R5, R31 */
		/* 8210BB60h case    7:*/		regs.R5 = regs.R31;
		/* 8210BB60h case    7:*/		return 0x8210BB64;
		  /* 8210BB64h */ case    8:  		/* li R4, 0 */
		/* 8210BB64h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8210BB64h case    8:*/		return 0x8210BB68;
		  /* 8210BB68h */ case    9:  		/* mr R3, R21 */
		/* 8210BB68h case    9:*/		regs.R3 = regs.R21;
		/* 8210BB68h case    9:*/		return 0x8210BB6C;
		  /* 8210BB6Ch */ case   10:  		/* bl -501804 */
		/* 8210BB6Ch case   10:*/		regs.LR = 0x8210BB70; return 0x82091340;
		/* 8210BB6Ch case   10:*/		return 0x8210BB70;
		  /* 8210BB70h */ case   11:  		/* lwz R11, <#[R23 + 8]> */
		/* 8210BB70h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 8210BB70h case   11:*/		return 0x8210BB74;
		  /* 8210BB74h */ case   12:  		/* mr R8, R15 */
		/* 8210BB74h case   12:*/		regs.R8 = regs.R15;
		/* 8210BB74h case   12:*/		return 0x8210BB78;
		  /* 8210BB78h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 8210BB78h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210BB78h case   13:*/		return 0x8210BB7C;
		  /* 8210BB7Ch */ case   14:  		/* bc 4, CR6_GT, 88 */
		/* 8210BB7Ch case   14:*/		if ( !regs.CR[6].gt ) { return 0x8210BBD4;  }
		/* 8210BB7Ch case   14:*/		return 0x8210BB80;
		  /* 8210BB80h */ case   15:  		/* mr R9, R15 */
		/* 8210BB80h case   15:*/		regs.R9 = regs.R15;
		/* 8210BB80h case   15:*/		return 0x8210BB84;
		  /* 8210BB84h */ case   16:  		/* lwz R11, <#[R23 + 20]> */
		/* 8210BB84h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000014) );
		/* 8210BB84h case   16:*/		return 0x8210BB88;
		  /* 8210BB88h */ case   17:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210BB88h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210BB88h case   17:*/		return 0x8210BB8C;
		  /* 8210BB8Ch */ case   18:  		/* stw R15, <#[R11 + 92]> */
		/* 8210BB8Ch case   18:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R11 + 0x0000005C) );
		/* 8210BB8Ch case   18:*/		return 0x8210BB90;
		  /* 8210BB90h */ case   19:  		/* lwz R10, <#[R11 + 4]> */
		/* 8210BB90h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210BB90h case   19:*/		return 0x8210BB94;
		  /* 8210BB94h */ case   20:  		/* lwz R7, <#[R23 + 136]> */
		/* 8210BB94h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R23 + 0x00000088) );
		/* 8210BB94h case   20:*/		return 0x8210BB98;
		  /* 8210BB98h */ case   21:  		/* cmplw CR6, R7, R10 */
		/* 8210BB98h case   21:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 8210BB98h case   21:*/		return 0x8210BB9C;
		  /* 8210BB9Ch */ case   22:  		/* bc 4, CR6_EQ, 36 */
		/* 8210BB9Ch case   22:*/		if ( !regs.CR[6].eq ) { return 0x8210BBC0;  }
		/* 8210BB9Ch case   22:*/		return 0x8210BBA0;
		  /* 8210BBA0h */ case   23:  		/* lwz R10, <#[R11 + 12]> */
		/* 8210BBA0h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210BBA0h case   23:*/		return 0x8210BBA4;
		  /* 8210BBA4h */ case   24:  		/* lwz R11, <#[R11 + 16]> */
		/* 8210BBA4h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 8210BBA4h case   24:*/		return 0x8210BBA8;
		  /* 8210BBA8h */ case   25:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210BBA8h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210BBA8h case   25:*/		return 0x8210BBAC;
		  /* 8210BBACh */ case   26:  		/* lwzx R7, <#[R10 + R21]> */
		/* 8210BBACh case   26:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R21 + 0x00000000) );
		/* 8210BBACh case   26:*/		return 0x8210BBB0;
		  /* 8210BBB0h */ case   27:  		/* cmplw CR6, R11, R7 */
		/* 8210BBB0h case   27:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 8210BBB0h case   27:*/		return 0x8210BBB4;
		  /* 8210BBB4h */ case   28:  		/* bc 12, CR6_LT, 12 */
		/* 8210BBB4h case   28:*/		if ( regs.CR[6].lt ) { return 0x8210BBC0;  }
		/* 8210BBB4h case   28:*/		return 0x8210BBB8;
		  /* 8210BBB8h */ case   29:  		/* addi R11, R11, 1 */
		/* 8210BBB8h case   29:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210BBB8h case   29:*/		return 0x8210BBBC;
		  /* 8210BBBCh */ case   30:  		/* stwx R11, <#[R10 + R21]> */
		/* 8210BBBCh case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R21 + 0x00000000) );
		/* 8210BBBCh case   30:*/		return 0x8210BBC0;
	}
	return 0x8210BBC0;
} // Block from 8210BB44h-8210BBC0h (31 instructions)

//////////////////////////////////////////////////////
// Block at 8210BBC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BBC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BBC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BBC0);
		  /* 8210BBC0h */ case    0:  		/* lwz R11, <#[R23 + 8]> */
		/* 8210BBC0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 8210BBC0h case    0:*/		return 0x8210BBC4;
		  /* 8210BBC4h */ case    1:  		/* addi R8, R8, 1 */
		/* 8210BBC4h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8210BBC4h case    1:*/		return 0x8210BBC8;
		  /* 8210BBC8h */ case    2:  		/* addi R9, R9, 4 */
		/* 8210BBC8h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8210BBC8h case    2:*/		return 0x8210BBCC;
		  /* 8210BBCCh */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 8210BBCCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8210BBCCh case    3:*/		return 0x8210BBD0;
		  /* 8210BBD0h */ case    4:  		/* bc 12, CR6_LT, -76 */
		/* 8210BBD0h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210BB84;  }
		/* 8210BBD0h case    4:*/		return 0x8210BBD4;
	}
	return 0x8210BBD4;
} // Block from 8210BBC0h-8210BBD4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210BBD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BBD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BBD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BBD4);
		  /* 8210BBD4h */ case    0:  		/* lwz R18, <#[R23 + 12]> */
		/* 8210BBD4h case    0:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210BBD4h case    0:*/		return 0x8210BBD8;
		  /* 8210BBD8h */ case    1:  		/* cmplwi CR6, R18, 0 */
		/* 8210BBD8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 8210BBD8h case    1:*/		return 0x8210BBDC;
		  /* 8210BBDCh */ case    2:  		/* bc 12, CR6_EQ, 3484 */
		/* 8210BBDCh case    2:*/		if ( regs.CR[6].eq ) { return 0x8210C978;  }
		/* 8210BBDCh case    2:*/		return 0x8210BBE0;
		  /* 8210BBE0h */ case    3:  		/* lis R16, 16384 */
		/* 8210BBE0h case    3:*/		cpu::op::lis<0>(regs,&regs.R16,0x4000);
		/* 8210BBE0h case    3:*/		return 0x8210BBE4;
		  /* 8210BBE4h */ case    4:  		/* lis R17, 8304 */
		/* 8210BBE4h case    4:*/		cpu::op::lis<0>(regs,&regs.R17,0x2070);
		/* 8210BBE4h case    4:*/		return 0x8210BBE8;
		  /* 8210BBE8h */ case    5:  		/* addi R18, R18, -1 */
		/* 8210BBE8h case    5:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R18,0xFFFFFFFF);
		/* 8210BBE8h case    5:*/		return 0x8210BBEC;
		  /* 8210BBECh */ case    6:  		/* lwz R11, <#[R23 + 24]> */
		/* 8210BBECh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000018) );
		/* 8210BBECh case    6:*/		return 0x8210BBF0;
		  /* 8210BBF0h */ case    7:  		/* rlwinm R10, R18, 2, 0, 29 */
		/* 8210BBF0h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R18);
		/* 8210BBF0h case    7:*/		return 0x8210BBF4;
		  /* 8210BBF4h */ case    8:  		/* lwzx R20, <#[R10 + R11]> */
		/* 8210BBF4h case    8:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210BBF4h case    8:*/		return 0x8210BBF8;
		  /* 8210BBF8h */ case    9:  		/* lwz R11, <#[R20]> */
		/* 8210BBF8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 8210BBF8h case    9:*/		return 0x8210BBFC;
		  /* 8210BBFCh */ case   10:  		/* rlwinm. R10, R11, 0, 0, 11 */
		/* 8210BBFCh case   10:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R10,regs.R11);
		/* 8210BBFCh case   10:*/		return 0x8210BC00;
		  /* 8210BC00h */ case   11:  		/* bc 12, CR0_EQ, 3436 */
		/* 8210BC00h case   11:*/		if ( regs.CR[0].eq ) { return 0x8210C96C;  }
		/* 8210BC00h case   11:*/		return 0x8210BC04;
		  /* 8210BC04h */ case   12:  		/* lwz R10, <#[R20 + 4]> */
		/* 8210BC04h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x00000004) );
		/* 8210BC04h case   12:*/		return 0x8210BC08;
		  /* 8210BC08h */ case   13:  		/* rlwinm R31, R11, 0, 12, 31 */
		/* 8210BC08h case   13:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R31,regs.R11);
		/* 8210BC08h case   13:*/		return 0x8210BC0C;
		  /* 8210BC0Ch */ case   14:  		/* lwz R9, <#[R20 + 12]> */
		/* 8210BC0Ch case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R20 + 0x0000000C) );
		/* 8210BC0Ch case   14:*/		return 0x8210BC10;
		  /* 8210BC10h */ case   15:  		/* divwu R29, R10, R31 */
		/* 8210BC10h case   15:*/		cpu::op::divwu<0>(regs,&regs.R29,regs.R10,regs.R31);
		/* 8210BC10h case   15:*/		return 0x8210BC14;
		  /* 8210BC14h */ case   16:  		/* twi 6, R31, 0 */
		/* 8210BC14h case   16:*/		cpu::op::tw<6>(regs, 0x8210BC14, regs.R31, 0x00000000);
		/* 8210BC14h case   16:*/		return 0x8210BC18;
		  /* 8210BC18h */ case   17:  		/* cmplwi CR6, R9, 0 */
		/* 8210BC18h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8210BC18h case   17:*/		return 0x8210BC1C;
		  /* 8210BC1Ch */ case   18:  		/* bc 12, CR6_EQ, 152 */
		/* 8210BC1Ch case   18:*/		if ( regs.CR[6].eq ) { return 0x8210BCB4;  }
		/* 8210BC1Ch case   18:*/		return 0x8210BC20;
		  /* 8210BC20h */ case   19:  		/* rlwinm R11, R11, 0, 0, 3 */
		/* 8210BC20h case   19:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R11,regs.R11);
		/* 8210BC20h case   19:*/		return 0x8210BC24;
		  /* 8210BC24h */ case   20:  		/* cmplw CR6, R11, R14 */
		/* 8210BC24h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 8210BC24h case   20:*/		return 0x8210BC28;
		  /* 8210BC28h */ case   21:  		/* bc 12, CR6_LT, 140 */
		/* 8210BC28h case   21:*/		if ( regs.CR[6].lt ) { return 0x8210BCB4;  }
		/* 8210BC28h case   21:*/		return 0x8210BC2C;
		  /* 8210BC2Ch */ case   22:  		/* cmplw CR6, R11, R16 */
		/* 8210BC2Ch case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R16);
		/* 8210BC2Ch case   22:*/		return 0x8210BC30;
		  /* 8210BC30h */ case   23:  		/* bc 12, CR6_GT, 132 */
		/* 8210BC30h case   23:*/		if ( regs.CR[6].gt ) { return 0x8210BCB4;  }
		/* 8210BC30h case   23:*/		return 0x8210BC34;
		  /* 8210BC34h */ case   24:  		/* li R7, 1 */
		/* 8210BC34h case   24:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8210BC34h case   24:*/		return 0x8210BC38;
		  /* 8210BC38h */ case   25:  		/* lwz R4, <#[R20 + 16]> */
		/* 8210BC38h case   25:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R20 + 0x00000010) );
		/* 8210BC38h case   25:*/		return 0x8210BC3C;
		  /* 8210BC3Ch */ case   26:  		/* mr R6, R31 */
		/* 8210BC3Ch case   26:*/		regs.R6 = regs.R31;
		/* 8210BC3Ch case   26:*/		return 0x8210BC40;
		  /* 8210BC40h */ case   27:  		/* addi R5, R1, 176 */
		/* 8210BC40h case   27:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xB0);
		/* 8210BC40h case   27:*/		return 0x8210BC44;
		  /* 8210BC44h */ case   28:  		/* mr R3, R23 */
		/* 8210BC44h case   28:*/		regs.R3 = regs.R23;
		/* 8210BC44h case   28:*/		return 0x8210BC48;
		  /* 8210BC48h */ case   29:  		/* bl -43856 */
		/* 8210BC48h case   29:*/		regs.LR = 0x8210BC4C; return 0x821010F8;
		/* 8210BC48h case   29:*/		return 0x8210BC4C;
		  /* 8210BC4Ch */ case   30:  		/* mr R30, R15 */
		/* 8210BC4Ch case   30:*/		regs.R30 = regs.R15;
		/* 8210BC4Ch case   30:*/		return 0x8210BC50;
		  /* 8210BC50h */ case   31:  		/* cmplwi CR6, R29, 0 */
		/* 8210BC50h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8210BC50h case   31:*/		return 0x8210BC54;
		  /* 8210BC54h */ case   32:  		/* bc 12, CR6_EQ, 96 */
		/* 8210BC54h case   32:*/		if ( regs.CR[6].eq ) { return 0x8210BCB4;  }
		/* 8210BC54h case   32:*/		return 0x8210BC58;
		  /* 8210BC58h */ case   33:  		/* lwz R10, <#[R20 + 12]> */
		/* 8210BC58h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x0000000C) );
		/* 8210BC58h case   33:*/		return 0x8210BC5C;
		  /* 8210BC5Ch */ case   34:  		/* cmplwi CR6, R31, 0 */
		/* 8210BC5Ch case   34:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8210BC5Ch case   34:*/		return 0x8210BC60;
		  /* 8210BC60h */ case   35:  		/* lwz R11, <#[R20 + 8]> */
		/* 8210BC60h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000008) );
		/* 8210BC60h case   35:*/		return 0x8210BC64;
		  /* 8210BC64h */ case   36:  		/* mullw R10, R10, R30 */
		/* 8210BC64h case   36:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R10,regs.R30);
		/* 8210BC64h case   36:*/		return 0x8210BC68;
		  /* 8210BC68h */ case   37:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210BC68h case   37:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210BC68h case   37:*/		return 0x8210BC6C;
		  /* 8210BC6Ch */ case   38:  		/* add R3, R10, R11 */
		/* 8210BC6Ch case   38:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8210BC6Ch case   38:*/		return 0x8210BC70;
		  /* 8210BC70h */ case   39:  		/* bc 12, CR6_EQ, 56 */
		/* 8210BC70h case   39:*/		if ( regs.CR[6].eq ) { return 0x8210BCA8;  }
		/* 8210BC70h case   39:*/		return 0x8210BC74;
		  /* 8210BC74h */ case   40:  		/* mr R11, R15 */
		/* 8210BC74h case   40:*/		regs.R11 = regs.R15;
		/* 8210BC74h case   40:*/		return 0x8210BC78;
		  /* 8210BC78h */ case   41:  		/* mtspr CTR, R31 */
		/* 8210BC78h case   41:*/		regs.CTR = regs.R31;
		/* 8210BC78h case   41:*/		return 0x8210BC7C;
		  /* 8210BC7Ch */ case   42:  		/* addi R10, R1, 176 */
		/* 8210BC7Ch case   42:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xB0);
		/* 8210BC7Ch case   42:*/		return 0x8210BC80;
		  /* 8210BC80h */ case   43:  		/* addi R9, R1, 208 */
		/* 8210BC80h case   43:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xD0);
		/* 8210BC80h case   43:*/		return 0x8210BC84;
		  /* 8210BC84h */ case   44:  		/* lwzx R10, <#[R11 + R10]> */
		/* 8210BC84h case   44:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210BC84h case   44:*/		return 0x8210BC88;
		  /* 8210BC88h */ case   45:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210BC88h case   45:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210BC88h case   45:*/		return 0x8210BC8C;
		  /* 8210BC8Ch */ case   46:  		/* lwzx R10, <#[R10 + R3]> */
		/* 8210BC8Ch case   46:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 8210BC8Ch case   46:*/		return 0x8210BC90;
		  /* 8210BC90h */ case   47:  		/* stwx R10, <#[R11 + R9]> */
		/* 8210BC90h case   47:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210BC90h case   47:*/		return 0x8210BC94;
		  /* 8210BC94h */ case   48:  		/* addi R11, R11, 4 */
		/* 8210BC94h case   48:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210BC94h case   48:*/		return 0x8210BC98;
		  /* 8210BC98h */ case   49:  		/* bc 16, CR0_LT, -28 */
		/* 8210BC98h case   49:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210BC7C;  }
		/* 8210BC98h case   49:*/		return 0x8210BC9C;
		  /* 8210BC9Ch */ case   50:  		/* addi R4, R1, 208 */
		/* 8210BC9Ch case   50:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xD0);
		/* 8210BC9Ch case   50:*/		return 0x8210BCA0;
		  /* 8210BCA0h */ case   51:  		/* rlwinm R5, R31, 2, 0, 29 */
		/* 8210BCA0h case   51:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R31);
		/* 8210BCA0h case   51:*/		return 0x8210BCA4;
		  /* 8210BCA4h */ case   52:  		/* bl -499308 */
		/* 8210BCA4h case   52:*/		regs.LR = 0x8210BCA8; return 0x82091E38;
		/* 8210BCA4h case   52:*/		return 0x8210BCA8;
	}
	return 0x8210BCA8;
} // Block from 8210BBD4h-8210BCA8h (53 instructions)

//////////////////////////////////////////////////////
// Block at 8210BCA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BCA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BCA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BCA8);
		  /* 8210BCA8h */ case    0:  		/* addi R30, R30, 1 */
		/* 8210BCA8h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8210BCA8h case    0:*/		return 0x8210BCAC;
		  /* 8210BCACh */ case    1:  		/* cmplw CR6, R30, R29 */
		/* 8210BCACh case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R29);
		/* 8210BCACh case    1:*/		return 0x8210BCB0;
		  /* 8210BCB0h */ case    2:  		/* bc 12, CR6_LT, -88 */
		/* 8210BCB0h case    2:*/		if ( regs.CR[6].lt ) { return 0x8210BC58;  }
		/* 8210BCB0h case    2:*/		return 0x8210BCB4;
	}
	return 0x8210BCB4;
} // Block from 8210BCA8h-8210BCB4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210BCB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BCB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BCB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BCB4);
		  /* 8210BCB4h */ case    0:  		/* addi R11, R1, 112 */
		/* 8210BCB4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 8210BCB4h case    0:*/		return 0x8210BCB8;
		  /* 8210BCB8h */ case    1:  		/* lwz R26, <#[R20]> */
		/* 8210BCB8h case    1:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R20 + 0x00000000) );
		/* 8210BCB8h case    1:*/		return 0x8210BCBC;
		  /* 8210BCBCh */ case    2:  		/* rlwinm R10, R26, 0, 0, 11 */
		/* 8210BCBCh case    2:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R26);
		/* 8210BCBCh case    2:*/		return 0x8210BCC0;
		  /* 8210BCC0h */ case    3:  		/* cmplw CR6, R10, R14 */
		/* 8210BCC0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R14);
		/* 8210BCC0h case    3:*/		return 0x8210BCC4;
		  /* 8210BCC4h */ case    4:  		/* std R15, <#[R11]> */
		/* 8210BCC4h case    4:*/		cpu::mem::store64( regs, regs.R15, (uint32)(regs.R11 + 0x00000000) );
		/* 8210BCC4h case    4:*/		return 0x8210BCC8;
		  /* 8210BCC8h */ case    5:  		/* std R15, <#[R11 + 8]> */
		/* 8210BCC8h case    5:*/		cpu::mem::store64( regs, regs.R15, (uint32)(regs.R11 + 0x00000008) );
		/* 8210BCC8h case    5:*/		return 0x8210BCCC;
		  /* 8210BCCCh */ case    6:  		/* bc 4, CR6_EQ, 488 */
		/* 8210BCCCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x8210BEB4;  }
		/* 8210BCCCh case    6:*/		return 0x8210BCD0;
		  /* 8210BCD0h */ case    7:  		/* lwz R11, <#[R20 + 16]> */
		/* 8210BCD0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000010) );
		/* 8210BCD0h case    7:*/		return 0x8210BCD4;
		  /* 8210BCD4h */ case    8:  		/* lwz R5, <#[R23 + 20]> */
		/* 8210BCD4h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R23 + 0x00000014) );
		/* 8210BCD4h case    8:*/		return 0x8210BCD8;
		  /* 8210BCD8h */ case    9:  		/* lwz R10, <#[R23 + 16]> */
		/* 8210BCD8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000010) );
		/* 8210BCD8h case    9:*/		return 0x8210BCDC;
		  /* 8210BCDCh */ case   10:  		/* lwz R11, <#[R11]> */
		/* 8210BCDCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8210BCDCh case   10:*/		return 0x8210BCE0;
		  /* 8210BCE0h */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210BCE0h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210BCE0h case   11:*/		return 0x8210BCE4;
		  /* 8210BCE4h */ case   12:  		/* lwzx R28, <#[R11 + R5]> */
		/* 8210BCE4h case   12:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 8210BCE4h case   12:*/		return 0x8210BCE8;
		  /* 8210BCE8h */ case   13:  		/* lwz R11, <#[R28 + 4]> */
		/* 8210BCE8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8210BCE8h case   13:*/		return 0x8210BCEC;
		  /* 8210BCECh */ case   14:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210BCECh case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210BCECh case   14:*/		return 0x8210BCF0;
		  /* 8210BCF0h */ case   15:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210BCF0h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210BCF0h case   15:*/		return 0x8210BCF4;
		  /* 8210BCF4h */ case   16:  		/* lwz R27, <#[R11 + 4]> */
		/* 8210BCF4h case   16:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000004) );
		/* 8210BCF4h case   16:*/		return 0x8210BCF8;
		  /* 8210BCF8h */ case   17:  		/* rlwinm. R11, R27, 0, 29, 29 */
		/* 8210BCF8h case   17:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R27);
		/* 8210BCF8h case   17:*/		return 0x8210BCFC;
		  /* 8210BCFCh */ case   18:  		/* bc 4, CR0_EQ, 440 */
		/* 8210BCFCh case   18:*/		if ( !regs.CR[0].eq ) { return 0x8210BEB4;  }
		/* 8210BCFCh case   18:*/		return 0x8210BD00;
		  /* 8210BD00h */ case   19:  		/* lwz R11, <#[R23 + 108]> */
		/* 8210BD00h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000006C) );
		/* 8210BD00h case   19:*/		return 0x8210BD04;
		  /* 8210BD04h */ case   20:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 8210BD04h case   20:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 8210BD04h case   20:*/		return 0x8210BD08;
		  /* 8210BD08h */ case   21:  		/* bc 12, CR0_EQ, 12 */
		/* 8210BD08h case   21:*/		if ( regs.CR[0].eq ) { return 0x8210BD14;  }
		/* 8210BD08h case   21:*/		return 0x8210BD0C;
		  /* 8210BD0Ch */ case   22:  		/* rlwinm. R11, R27, 0, 26, 26 */
		/* 8210BD0Ch case   22:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R27);
		/* 8210BD0Ch case   22:*/		return 0x8210BD10;
		  /* 8210BD10h */ case   23:  		/* bc 4, CR0_EQ, 420 */
		/* 8210BD10h case   23:*/		if ( !regs.CR[0].eq ) { return 0x8210BEB4;  }
		/* 8210BD10h case   23:*/		return 0x8210BD14;
	}
	return 0x8210BD14;
} // Block from 8210BCB4h-8210BD14h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8210BD14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BD14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BD14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BD14);
		  /* 8210BD14h */ case    0:  		/* lwz R11, <#[R20 + 8]> */
		/* 8210BD14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000008) );
		/* 8210BD14h case    0:*/		return 0x8210BD18;
		  /* 8210BD18h */ case    1:  		/* lwz R10, <#[R23 + 136]> */
		/* 8210BD18h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000088) );
		/* 8210BD18h case    1:*/		return 0x8210BD1C;
		  /* 8210BD1Ch */ case    2:  		/* lwz R9, <#[R11]> */
		/* 8210BD1Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8210BD1Ch case    2:*/		return 0x8210BD20;
		  /* 8210BD20h */ case    3:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210BD20h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210BD20h case    3:*/		return 0x8210BD24;
		  /* 8210BD24h */ case    4:  		/* lwzx R9, <#[R9 + R5]> */
		/* 8210BD24h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R5 + 0x00000000) );
		/* 8210BD24h case    4:*/		return 0x8210BD28;
		  /* 8210BD28h */ case    5:  		/* lwz R9, <#[R9 + 4]> */
		/* 8210BD28h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 8210BD28h case    5:*/		return 0x8210BD2C;
		  /* 8210BD2Ch */ case    6:  		/* cmplw CR6, R10, R9 */
		/* 8210BD2Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8210BD2Ch case    6:*/		return 0x8210BD30;
		  /* 8210BD30h */ case    7:  		/* bc 4, CR6_EQ, 388 */
		/* 8210BD30h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8210BEB4;  }
		/* 8210BD30h case    7:*/		return 0x8210BD34;
		  /* 8210BD34h */ case    8:  		/* lwz R10, <#[R20 + 4]> */
		/* 8210BD34h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x00000004) );
		/* 8210BD34h case    8:*/		return 0x8210BD38;
		  /* 8210BD38h */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 8210BD38h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8210BD38h case    9:*/		return 0x8210BD3C;
		  /* 8210BD3Ch */ case   10:  		/* bc 4, CR6_GT, 376 */
		/* 8210BD3Ch case   10:*/		if ( !regs.CR[6].gt ) { return 0x8210BEB4;  }
		/* 8210BD3Ch case   10:*/		return 0x8210BD40;
		  /* 8210BD40h */ case   11:  		/* rlwinm R10, R10, 0, 0, 31 */
		/* 8210BD40h case   11:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R10);
		/* 8210BD40h case   11:*/		return 0x8210BD44;
		  /* 8210BD44h */ case   12:  		/* lwz R30, <#[R23 + 24]> */
		/* 8210BD44h case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R23 + 0x00000018) );
		/* 8210BD44h case   12:*/		return 0x8210BD48;
		  /* 8210BD48h */ case   13:  		/* addi R9, R1, 112 */
		/* 8210BD48h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 8210BD48h case   13:*/		return 0x8210BD4C;
		  /* 8210BD4Ch */ case   14:  		/* addi R31, R1, 112 */
		/* 8210BD4Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0x70);
		/* 8210BD4Ch case   14:*/		return 0x8210BD50;
		  /* 8210BD50h */ case   15:  		/* subf R29, R9, R11 */
		/* 8210BD50h case   15:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R9,regs.R11);
		/* 8210BD50h case   15:*/		return 0x8210BD54;
		  /* 8210BD54h */ case   16:  		/* mtspr CTR, R10 */
		/* 8210BD54h case   16:*/		regs.CTR = regs.R10;
		/* 8210BD54h case   16:*/		return 0x8210BD58;
		  /* 8210BD58h */ case   17:  		/* lwzx R11, <#[R29 + R31]> */
		/* 8210BD58h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R31 + 0x00000000) );
		/* 8210BD58h case   17:*/		return 0x8210BD5C;
		  /* 8210BD5Ch */ case   18:  		/* lis R10, 24640 */
		/* 8210BD5Ch case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0x6040);
		/* 8210BD5Ch case   18:*/		return 0x8210BD60;
		  /* 8210BD60h */ case   19:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210BD60h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210BD60h case   19:*/		return 0x8210BD64;
		  /* 8210BD64h */ case   20:  		/* lwzx R11, <#[R11 + R5]> */
		/* 8210BD64h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 8210BD64h case   20:*/		return 0x8210BD68;
		  /* 8210BD68h */ case   21:  		/* lwz R4, <#[R11 + 72]> */
		/* 8210BD68h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000048) );
		/* 8210BD68h case   21:*/		return 0x8210BD6C;
		  /* 8210BD6Ch */ case   22:  		/* rlwinm R9, R4, 2, 0, 29 */
		/* 8210BD6Ch case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R4);
		/* 8210BD6Ch case   22:*/		return 0x8210BD70;
		  /* 8210BD70h */ case   23:  		/* lwzx R6, <#[R9 + R30]> */
		/* 8210BD70h case   23:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 8210BD70h case   23:*/		return 0x8210BD74;
		  /* 8210BD74h */ case   24:  		/* lwz R9, <#[R6]> */
		/* 8210BD74h case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000000) );
		/* 8210BD74h case   24:*/		return 0x8210BD78;
		  /* 8210BD78h */ case   25:  		/* rlwinm R3, R9, 0, 0, 11 */
		/* 8210BD78h case   25:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R3,regs.R9);
		/* 8210BD78h case   25:*/		return 0x8210BD7C;
		  /* 8210BD7Ch */ case   26:  		/* cmplw CR6, R3, R10 */
		/* 8210BD7Ch case   26:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 8210BD7Ch case   26:*/		return 0x8210BD80;
		  /* 8210BD80h */ case   27:  		/* bc 12, CR6_EQ, 28 */
		/* 8210BD80h case   27:*/		if ( regs.CR[6].eq ) { return 0x8210BD9C;  }
		/* 8210BD80h case   27:*/		return 0x8210BD84;
		  /* 8210BD84h */ case   28:  		/* lis R10, 24720 */
		/* 8210BD84h case   28:*/		cpu::op::lis<0>(regs,&regs.R10,0x6090);
		/* 8210BD84h case   28:*/		return 0x8210BD88;
		  /* 8210BD88h */ case   29:  		/* cmplw CR6, R3, R10 */
		/* 8210BD88h case   29:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 8210BD88h case   29:*/		return 0x8210BD8C;
		  /* 8210BD8Ch */ case   30:  		/* bc 12, CR6_EQ, 16 */
		/* 8210BD8Ch case   30:*/		if ( regs.CR[6].eq ) { return 0x8210BD9C;  }
		/* 8210BD8Ch case   30:*/		return 0x8210BD90;
		  /* 8210BD90h */ case   31:  		/* lis R10, 24800 */
		/* 8210BD90h case   31:*/		cpu::op::lis<0>(regs,&regs.R10,0x60E0);
		/* 8210BD90h case   31:*/		return 0x8210BD94;
		  /* 8210BD94h */ case   32:  		/* cmplw CR6, R3, R10 */
		/* 8210BD94h case   32:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 8210BD94h case   32:*/		return 0x8210BD98;
		  /* 8210BD98h */ case   33:  		/* bc 4, CR6_EQ, 12 */
		/* 8210BD98h case   33:*/		if ( !regs.CR[6].eq ) { return 0x8210BDA4;  }
		/* 8210BD98h case   33:*/		return 0x8210BD9C;
	}
	return 0x8210BD9C;
} // Block from 8210BD14h-8210BD9Ch (34 instructions)

//////////////////////////////////////////////////////
// Block at 8210BD9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BD9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BD9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BD9C);
		  /* 8210BD9Ch */ case    0:  		/* rlwinm. R10, R27, 0, 26, 26 */
		/* 8210BD9Ch case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R10,regs.R27);
		/* 8210BD9Ch case    0:*/		return 0x8210BDA0;
		  /* 8210BDA0h */ case    1:  		/* bc 4, CR0_EQ, 268 */
		/* 8210BDA0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8210BEAC;  }
		/* 8210BDA0h case    1:*/		return 0x8210BDA4;
	}
	return 0x8210BDA4;
} // Block from 8210BD9Ch-8210BDA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210BDA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BDA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BDA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BDA4);
		  /* 8210BDA4h */ case    0:  		/* lwz R10, <#[R23 + 204]> */
		/* 8210BDA4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x000000CC) );
		/* 8210BDA4h case    0:*/		return 0x8210BDA8;
		  /* 8210BDA8h */ case    1:  		/* rlwinm. R10, R10, 0, 29, 29 */
		/* 8210BDA8h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R10);
		/* 8210BDA8h case    1:*/		return 0x8210BDAC;
		  /* 8210BDACh */ case    2:  		/* bc 12, CR0_EQ, 36 */
		/* 8210BDACh case    2:*/		if ( regs.CR[0].eq ) { return 0x8210BDD0;  }
		/* 8210BDACh case    2:*/		return 0x8210BDB0;
		  /* 8210BDB0h */ case    3:  		/* lwz R9, <#[R28 + 96]> */
		/* 8210BDB0h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000060) );
		/* 8210BDB0h case    3:*/		return 0x8210BDB4;
		  /* 8210BDB4h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 8210BDB4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8210BDB4h case    4:*/		return 0x8210BDB8;
		  /* 8210BDB8h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 8210BDB8h case    5:*/		if ( regs.CR[6].eq ) { return 0x8210BDD0;  }
		/* 8210BDB8h case    5:*/		return 0x8210BDBC;
		  /* 8210BDBCh */ case    6:  		/* lwz R10, <#[R11 + 96]> */
		/* 8210BDBCh case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000060) );
		/* 8210BDBCh case    6:*/		return 0x8210BDC0;
		  /* 8210BDC0h */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 8210BDC0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8210BDC0h case    7:*/		return 0x8210BDC4;
		  /* 8210BDC4h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 8210BDC4h case    8:*/		if ( regs.CR[6].eq ) { return 0x8210BDD0;  }
		/* 8210BDC4h case    8:*/		return 0x8210BDC8;
		  /* 8210BDC8h */ case    9:  		/* cmplw CR6, R9, R10 */
		/* 8210BDC8h case    9:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 8210BDC8h case    9:*/		return 0x8210BDCC;
		  /* 8210BDCCh */ case   10:  		/* bc 4, CR6_EQ, 224 */
		/* 8210BDCCh case   10:*/		if ( !regs.CR[6].eq ) { return 0x8210BEAC;  }
		/* 8210BDCCh case   10:*/		return 0x8210BDD0;
	}
	return 0x8210BDD0;
} // Block from 8210BDA4h-8210BDD0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8210BDD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BDD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BDD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BDD0);
		  /* 8210BDD0h */ case    0:  		/* lwz R10, <#[R28 + 24]> */
		/* 8210BDD0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000018) );
		/* 8210BDD0h case    0:*/		return 0x8210BDD4;
		  /* 8210BDD4h */ case    1:  		/* lwz R9, <#[R11 + 24]> */
		/* 8210BDD4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000018) );
		/* 8210BDD4h case    1:*/		return 0x8210BDD8;
		  /* 8210BDD8h */ case    2:  		/* cmpw CR6, R10, R9 */
		/* 8210BDD8h case    2:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R9);
		/* 8210BDD8h case    2:*/		return 0x8210BDDC;
		  /* 8210BDDCh */ case    3:  		/* bc 4, CR6_EQ, 208 */
		/* 8210BDDCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x8210BEAC;  }
		/* 8210BDDCh case    3:*/		return 0x8210BDE0;
		  /* 8210BDE0h */ case    4:  		/* lwz R10, <#[R28 + 20]> */
		/* 8210BDE0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000014) );
		/* 8210BDE0h case    4:*/		return 0x8210BDE4;
		  /* 8210BDE4h */ case    5:  		/* lwz R11, <#[R11 + 20]> */
		/* 8210BDE4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8210BDE4h case    5:*/		return 0x8210BDE8;
		  /* 8210BDE8h */ case    6:  		/* cmplw CR6, R10, R11 */
		/* 8210BDE8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8210BDE8h case    6:*/		return 0x8210BDEC;
		  /* 8210BDECh */ case    7:  		/* bc 4, CR6_EQ, 192 */
		/* 8210BDECh case    7:*/		if ( !regs.CR[6].eq ) { return 0x8210BEAC;  }
		/* 8210BDECh case    7:*/		return 0x8210BDF0;
		  /* 8210BDF0h */ case    8:  		/* lwz R7, <#[R6 + 12]> */
		/* 8210BDF0h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R6 + 0x0000000C) );
		/* 8210BDF0h case    8:*/		return 0x8210BDF4;
		  /* 8210BDF4h */ case    9:  		/* mr R9, R15 */
		/* 8210BDF4h case    9:*/		regs.R9 = regs.R15;
		/* 8210BDF4h case    9:*/		return 0x8210BDF8;
		  /* 8210BDF8h */ case   10:  		/* cmplwi CR6, R7, 0 */
		/* 8210BDF8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8210BDF8h case   10:*/		return 0x8210BDFC;
		  /* 8210BDFCh */ case   11:  		/* bc 12, CR6_EQ, 64 */
		/* 8210BDFCh case   11:*/		if ( regs.CR[6].eq ) { return 0x8210BE3C;  }
		/* 8210BDFCh case   11:*/		return 0x8210BE00;
		  /* 8210BE00h */ case   12:  		/* lwz R8, <#[R6 + 16]> */
		/* 8210BE00h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + 0x00000010) );
		/* 8210BE00h case   12:*/		return 0x8210BE04;
		  /* 8210BE04h */ case   13:  		/* mr R11, R15 */
		/* 8210BE04h case   13:*/		regs.R11 = regs.R15;
		/* 8210BE04h case   13:*/		return 0x8210BE08;
		  /* 8210BE08h */ case   14:  		/* lwzx R10, <#[R8 + R11]> */
		/* 8210BE08h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8210BE08h case   14:*/		return 0x8210BE0C;
		  /* 8210BE0Ch */ case   15:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210BE0Ch case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210BE0Ch case   15:*/		return 0x8210BE10;
		  /* 8210BE10h */ case   16:  		/* lwzx R10, <#[R10 + R5]> */
		/* 8210BE10h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 8210BE10h case   16:*/		return 0x8210BE14;
		  /* 8210BE14h */ case   17:  		/* lwz R25, <#[R10 + 84]> */
		/* 8210BE14h case   17:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R10 + 0x00000054) );
		/* 8210BE14h case   17:*/		return 0x8210BE18;
		  /* 8210BE18h */ case   18:  		/* cmplw CR6, R18, R25 */
		/* 8210BE18h case   18:*/		cpu::op::cmplw<6>(regs,regs.R18,regs.R25);
		/* 8210BE18h case   18:*/		return 0x8210BE1C;
		  /* 8210BE1Ch */ case   19:  		/* bc 4, CR6_EQ, 32 */
		/* 8210BE1Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x8210BE3C;  }
		/* 8210BE1Ch case   19:*/		return 0x8210BE20;
		  /* 8210BE20h */ case   20:  		/* lwz R10, <#[R10 + 88]> */
		/* 8210BE20h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000058) );
		/* 8210BE20h case   20:*/		return 0x8210BE24;
		  /* 8210BE24h */ case   21:  		/* cmplw CR6, R18, R10 */
		/* 8210BE24h case   21:*/		cpu::op::cmplw<6>(regs,regs.R18,regs.R10);
		/* 8210BE24h case   21:*/		return 0x8210BE28;
		  /* 8210BE28h */ case   22:  		/* bc 4, CR6_EQ, 20 */
		/* 8210BE28h case   22:*/		if ( !regs.CR[6].eq ) { return 0x8210BE3C;  }
		/* 8210BE28h case   22:*/		return 0x8210BE2C;
		  /* 8210BE2Ch */ case   23:  		/* addi R9, R9, 1 */
		/* 8210BE2Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8210BE2Ch case   23:*/		return 0x8210BE30;
		  /* 8210BE30h */ case   24:  		/* addi R11, R11, 4 */
		/* 8210BE30h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210BE30h case   24:*/		return 0x8210BE34;
		  /* 8210BE34h */ case   25:  		/* cmplw CR6, R9, R7 */
		/* 8210BE34h case   25:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 8210BE34h case   25:*/		return 0x8210BE38;
		  /* 8210BE38h */ case   26:  		/* bc 12, CR6_LT, -48 */
		/* 8210BE38h case   26:*/		if ( regs.CR[6].lt ) { return 0x8210BE08;  }
		/* 8210BE38h case   26:*/		return 0x8210BE3C;
	}
	return 0x8210BE3C;
} // Block from 8210BDD0h-8210BE3Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 8210BE3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BE3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BE3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BE3C);
		  /* 8210BE3Ch */ case    0:  		/* cmplw CR6, R9, R7 */
		/* 8210BE3Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 8210BE3Ch case    0:*/		return 0x8210BE40;
		  /* 8210BE40h */ case    1:  		/* bc 4, CR6_EQ, 108 */
		/* 8210BE40h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210BEAC;  }
		/* 8210BE40h case    1:*/		return 0x8210BE44;
		  /* 8210BE44h */ case    2:  		/* mr R9, R15 */
		/* 8210BE44h case    2:*/		regs.R9 = regs.R15;
		/* 8210BE44h case    2:*/		return 0x8210BE48;
		  /* 8210BE48h */ case    3:  		/* cmplwi CR6, R7, 0 */
		/* 8210BE48h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8210BE48h case    3:*/		return 0x8210BE4C;
		  /* 8210BE4Ch */ case    4:  		/* bc 12, CR6_EQ, 72 */
		/* 8210BE4Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x8210BE94;  }
		/* 8210BE4Ch case    4:*/		return 0x8210BE50;
		  /* 8210BE50h */ case    5:  		/* lwz R8, <#[R6 + 16]> */
		/* 8210BE50h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + 0x00000010) );
		/* 8210BE50h case    5:*/		return 0x8210BE54;
		  /* 8210BE54h */ case    6:  		/* mr R11, R15 */
		/* 8210BE54h case    6:*/		regs.R11 = regs.R15;
		/* 8210BE54h case    6:*/		return 0x8210BE58;
		  /* 8210BE58h */ case    7:  		/* lwzx R10, <#[R8 + R11]> */
		/* 8210BE58h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8210BE58h case    7:*/		return 0x8210BE5C;
		  /* 8210BE5Ch */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210BE5Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210BE5Ch case    8:*/		return 0x8210BE60;
		  /* 8210BE60h */ case    9:  		/* lwzx R10, <#[R10 + R5]> */
		/* 8210BE60h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 8210BE60h case    9:*/		return 0x8210BE64;
		  /* 8210BE64h */ case   10:  		/* lwz R10, <#[R10 + 20]> */
		/* 8210BE64h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 8210BE64h case   10:*/		return 0x8210BE68;
		  /* 8210BE68h */ case   11:  		/* cmpwi CR6, R10, -1 */
		/* 8210BE68h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210BE68h case   11:*/		return 0x8210BE6C;
		  /* 8210BE6Ch */ case   12:  		/* bc 12, CR6_EQ, 24 */
		/* 8210BE6Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x8210BE84;  }
		/* 8210BE6Ch case   12:*/		return 0x8210BE70;
		  /* 8210BE70h */ case   13:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210BE70h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210BE70h case   13:*/		return 0x8210BE74;
		  /* 8210BE74h */ case   14:  		/* lwzx R10, <#[R10 + R5]> */
		/* 8210BE74h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 8210BE74h case   14:*/		return 0x8210BE78;
		  /* 8210BE78h */ case   15:  		/* lwz R10, <#[R10 + 72]> */
		/* 8210BE78h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000048) );
		/* 8210BE78h case   15:*/		return 0x8210BE7C;
		  /* 8210BE7Ch */ case   16:  		/* cmplw CR6, R10, R4 */
		/* 8210BE7Ch case   16:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R4);
		/* 8210BE7Ch case   16:*/		return 0x8210BE80;
		  /* 8210BE80h */ case   17:  		/* bc 4, CR6_LT, 20 */
		/* 8210BE80h case   17:*/		if ( !regs.CR[6].lt ) { return 0x8210BE94;  }
		/* 8210BE80h case   17:*/		return 0x8210BE84;
	}
	return 0x8210BE84;
} // Block from 8210BE3Ch-8210BE84h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8210BE84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BE84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BE84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BE84);
		  /* 8210BE84h */ case    0:  		/* addi R9, R9, 1 */
		/* 8210BE84h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8210BE84h case    0:*/		return 0x8210BE88;
		  /* 8210BE88h */ case    1:  		/* addi R11, R11, 4 */
		/* 8210BE88h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210BE88h case    1:*/		return 0x8210BE8C;
		  /* 8210BE8Ch */ case    2:  		/* cmplw CR6, R9, R7 */
		/* 8210BE8Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 8210BE8Ch case    2:*/		return 0x8210BE90;
		  /* 8210BE90h */ case    3:  		/* bc 12, CR6_LT, -56 */
		/* 8210BE90h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210BE58;  }
		/* 8210BE90h case    3:*/		return 0x8210BE94;
	}
	return 0x8210BE94;
} // Block from 8210BE84h-8210BE94h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210BE94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BE94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BE94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BE94);
		  /* 8210BE94h */ case    0:  		/* cmplw CR6, R9, R7 */
		/* 8210BE94h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 8210BE94h case    0:*/		return 0x8210BE98;
		  /* 8210BE98h */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 8210BE98h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210BEAC;  }
		/* 8210BE98h case    1:*/		return 0x8210BE9C;
		  /* 8210BE9Ch */ case    2:  		/* cmplw CR6, R3, R17 */
		/* 8210BE9Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R17);
		/* 8210BE9Ch case    2:*/		return 0x8210BEA0;
		  /* 8210BEA0h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 8210BEA0h case    3:*/		if ( regs.CR[6].eq ) { return 0x8210BEAC;  }
		/* 8210BEA0h case    3:*/		return 0x8210BEA4;
		  /* 8210BEA4h */ case    4:  		/* li R11, 1 */
		/* 8210BEA4h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8210BEA4h case    4:*/		return 0x8210BEA8;
		  /* 8210BEA8h */ case    5:  		/* stw R11, <#[R31]> */
		/* 8210BEA8h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8210BEA8h case    5:*/		return 0x8210BEAC;
	}
	return 0x8210BEAC;
} // Block from 8210BE94h-8210BEACh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210BEACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BEAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BEAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BEAC);
		  /* 8210BEACh */ case    0:  		/* addi R31, R31, 4 */
		/* 8210BEACh case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8210BEACh case    0:*/		return 0x8210BEB0;
		  /* 8210BEB0h */ case    1:  		/* bc 16, CR0_LT, -344 */
		/* 8210BEB0h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210BD58;  }
		/* 8210BEB0h case    1:*/		return 0x8210BEB4;
	}
	return 0x8210BEB4;
} // Block from 8210BEACh-8210BEB4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210BEB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BEB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BEB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BEB4);
		  /* 8210BEB4h */ case    0:  		/* rlwinm R11, R26, 0, 0, 3 */
		/* 8210BEB4h case    0:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R11,regs.R26);
		/* 8210BEB4h case    0:*/		return 0x8210BEB8;
		  /* 8210BEB8h */ case    1:  		/* cmplw CR6, R11, R14 */
		/* 8210BEB8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 8210BEB8h case    1:*/		return 0x8210BEBC;
		  /* 8210BEBCh */ case    2:  		/* bc 12, CR6_LT, 88 */
		/* 8210BEBCh case    2:*/		if ( regs.CR[6].lt ) { return 0x8210BF14;  }
		/* 8210BEBCh case    2:*/		return 0x8210BEC0;
		  /* 8210BEC0h */ case    3:  		/* cmplw CR6, R11, R16 */
		/* 8210BEC0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R16);
		/* 8210BEC0h case    3:*/		return 0x8210BEC4;
		  /* 8210BEC4h */ case    4:  		/* bc 12, CR6_GT, 80 */
		/* 8210BEC4h case    4:*/		if ( regs.CR[6].gt ) { return 0x8210BF14;  }
		/* 8210BEC4h case    4:*/		return 0x8210BEC8;
		  /* 8210BEC8h */ case    5:  		/* lwz R11, <#[R20 + 12]> */
		/* 8210BEC8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x0000000C) );
		/* 8210BEC8h case    5:*/		return 0x8210BECC;
		  /* 8210BECCh */ case    6:  		/* mr R7, R15 */
		/* 8210BECCh case    6:*/		regs.R7 = regs.R15;
		/* 8210BECCh case    6:*/		return 0x8210BED0;
		  /* 8210BED0h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8210BED0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210BED0h case    7:*/		return 0x8210BED4;
		  /* 8210BED4h */ case    8:  		/* bc 4, CR6_GT, 92 */
		/* 8210BED4h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8210BF30;  }
		/* 8210BED4h case    8:*/		return 0x8210BED8;
		  /* 8210BED8h */ case    9:  		/* lwz R10, <#[R20 + 16]> */
		/* 8210BED8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x00000010) );
		/* 8210BED8h case    9:*/		return 0x8210BEDC;
		  /* 8210BEDCh */ case   10:  		/* mr R11, R15 */
		/* 8210BEDCh case   10:*/		regs.R11 = regs.R15;
		/* 8210BEDCh case   10:*/		return 0x8210BEE0;
		  /* 8210BEE0h */ case   11:  		/* lwz R9, <#[R23 + 20]> */
		/* 8210BEE0h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000014) );
		/* 8210BEE0h case   11:*/		return 0x8210BEE4;
		  /* 8210BEE4h */ case   12:  		/* lwz R8, <#[R20 + 12]> */
		/* 8210BEE4h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R20 + 0x0000000C) );
		/* 8210BEE4h case   12:*/		return 0x8210BEE8;
		  /* 8210BEE8h */ case   13:  		/* lwzx R6, <#[R10 + R11]> */
		/* 8210BEE8h case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210BEE8h case   13:*/		return 0x8210BEEC;
		  /* 8210BEECh */ case   14:  		/* addi R5, R1, 96 */
		/* 8210BEECh case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 8210BEECh case   14:*/		return 0x8210BEF0;
		  /* 8210BEF0h */ case   15:  		/* addi R7, R7, 1 */
		/* 8210BEF0h case   15:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8210BEF0h case   15:*/		return 0x8210BEF4;
		  /* 8210BEF4h */ case   16:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 8210BEF4h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 8210BEF4h case   16:*/		return 0x8210BEF8;
		  /* 8210BEF8h */ case   17:  		/* cmplw CR6, R7, R8 */
		/* 8210BEF8h case   17:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 8210BEF8h case   17:*/		return 0x8210BEFC;
		  /* 8210BEFCh */ case   18:  		/* lwzx R6, <#[R6 + R9]> */
		/* 8210BEFCh case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R9 + 0x00000000) );
		/* 8210BEFCh case   18:*/		return 0x8210BF00;
		  /* 8210BF00h */ case   19:  		/* lwz R6, <#[R6 + 16]> */
		/* 8210BF00h case   19:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000010) );
		/* 8210BF00h case   19:*/		return 0x8210BF04;
		  /* 8210BF04h */ case   20:  		/* stwx R6, <#[R11 + R5]> */
		/* 8210BF04h case   20:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 8210BF04h case   20:*/		return 0x8210BF08;
		  /* 8210BF08h */ case   21:  		/* addi R11, R11, 4 */
		/* 8210BF08h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210BF08h case   21:*/		return 0x8210BF0C;
		  /* 8210BF0Ch */ case   22:  		/* bc 12, CR6_LT, -36 */
		/* 8210BF0Ch case   22:*/		if ( regs.CR[6].lt ) { return 0x8210BEE8;  }
		/* 8210BF0Ch case   22:*/		return 0x8210BF10;
		  /* 8210BF10h */ case   23:  		/* b 32 */
		/* 8210BF10h case   23:*/		return 0x8210BF30;
		/* 8210BF10h case   23:*/		return 0x8210BF14;
	}
	return 0x8210BF14;
} // Block from 8210BEB4h-8210BF14h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8210BF14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BF14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BF14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BF14);
		  /* 8210BF14h */ case    0:  		/* li R10, 4 */
		/* 8210BF14h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 8210BF14h case    0:*/		return 0x8210BF18;
		  /* 8210BF18h */ case    1:  		/* addi R9, R1, 92 */
		/* 8210BF18h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x5C);
		/* 8210BF18h case    1:*/		return 0x8210BF1C;
		  /* 8210BF1Ch */ case    2:  		/* mr R11, R15 */
		/* 8210BF1Ch case    2:*/		regs.R11 = regs.R15;
		/* 8210BF1Ch case    2:*/		return 0x8210BF20;
		  /* 8210BF20h */ case    3:  		/* mtspr CTR, R10 */
		/* 8210BF20h case    3:*/		regs.CTR = regs.R10;
		/* 8210BF20h case    3:*/		return 0x8210BF24;
		  /* 8210BF24h */ case    4:  		/* stwu R11, <#[R9 + 4]> */
		/* 8210BF24h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 8210BF24h case    4:*/		return 0x8210BF28;
		  /* 8210BF28h */ case    5:  		/* addi R11, R11, 1 */
		/* 8210BF28h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210BF28h case    5:*/		return 0x8210BF2C;
		  /* 8210BF2Ch */ case    6:  		/* bc 16, CR0_LT, -8 */
		/* 8210BF2Ch case    6:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210BF24;  }
		/* 8210BF2Ch case    6:*/		return 0x8210BF30;
	}
	return 0x8210BF30;
} // Block from 8210BF14h-8210BF30h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210BF30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BF30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BF30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BF30);
		  /* 8210BF30h */ case    0:  		/* li R4, 0 */
		/* 8210BF30h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8210BF30h case    0:*/		return 0x8210BF34;
		  /* 8210BF34h */ case    1:  		/* mr R19, R15 */
		/* 8210BF34h case    1:*/		regs.R19 = regs.R15;
		/* 8210BF34h case    1:*/		return 0x8210BF38;
		  /* 8210BF38h */ case    2:  		/* b 2340 */
		/* 8210BF38h case    2:*/		return 0x8210C85C;
		/* 8210BF38h case    2:*/		return 0x8210BF3C;
		  /* 8210BF3Ch */ case    3:  		/* addi R11, R1, 128 */
		/* 8210BF3Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 8210BF3Ch case    3:*/		return 0x8210BF40;
		  /* 8210BF40h */ case    4:  		/* lwz R22, <#[R1 + 80]> */
		/* 8210BF40h case    4:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000050) );
		/* 8210BF40h case    4:*/		return 0x8210BF44;
		  /* 8210BF44h */ case    5:  		/* mr R24, R15 */
		/* 8210BF44h case    5:*/		regs.R24 = regs.R15;
		/* 8210BF44h case    5:*/		return 0x8210BF48;
		  /* 8210BF48h */ case    6:  		/* mr R25, R15 */
		/* 8210BF48h case    6:*/		regs.R25 = regs.R15;
		/* 8210BF48h case    6:*/		return 0x8210BF4C;
		  /* 8210BF4Ch */ case    7:  		/* mr R26, R15 */
		/* 8210BF4Ch case    7:*/		regs.R26 = regs.R15;
		/* 8210BF4Ch case    7:*/		return 0x8210BF50;
		  /* 8210BF50h */ case    8:  		/* cmplwi CR6, R21, 0 */
		/* 8210BF50h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 8210BF50h case    8:*/		return 0x8210BF54;
		  /* 8210BF54h */ case    9:  		/* std R15, <#[R11]> */
		/* 8210BF54h case    9:*/		cpu::mem::store64( regs, regs.R15, (uint32)(regs.R11 + 0x00000000) );
		/* 8210BF54h case    9:*/		return 0x8210BF58;
		  /* 8210BF58h */ case   10:  		/* std R15, <#[R11 + 8]> */
		/* 8210BF58h case   10:*/		cpu::mem::store64( regs, regs.R15, (uint32)(regs.R11 + 0x00000008) );
		/* 8210BF58h case   10:*/		return 0x8210BF5C;
		  /* 8210BF5Ch */ case   11:  		/* bc 12, CR6_EQ, 504 */
		/* 8210BF5Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x8210C154;  }
		/* 8210BF5Ch case   11:*/		return 0x8210BF60;
		  /* 8210BF60h */ case   12:  		/* mr R27, R15 */
		/* 8210BF60h case   12:*/		regs.R27 = regs.R15;
		/* 8210BF60h case   12:*/		return 0x8210BF64;
		  /* 8210BF64h */ case   13:  		/* lwzx R29, <#[R22 + R27]> */
		/* 8210BF64h case   13:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R22 + regs.R27 + 0x00000000) );
		/* 8210BF64h case   13:*/		return 0x8210BF68;
		  /* 8210BF68h */ case   14:  		/* lwz R28, <#[R23 + 20]> */
		/* 8210BF68h case   14:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R23 + 0x00000014) );
		/* 8210BF68h case   14:*/		return 0x8210BF6C;
		  /* 8210BF6Ch */ case   15:  		/* rlwinm R11, R29, 2, 0, 29 */
		/* 8210BF6Ch case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R29);
		/* 8210BF6Ch case   15:*/		return 0x8210BF70;
		  /* 8210BF70h */ case   16:  		/* lwz R10, <#[R23 + 136]> */
		/* 8210BF70h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000088) );
		/* 8210BF70h case   16:*/		return 0x8210BF74;
		  /* 8210BF74h */ case   17:  		/* lwzx R30, <#[R11 + R28]> */
		/* 8210BF74h case   17:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8210BF74h case   17:*/		return 0x8210BF78;
		  /* 8210BF78h */ case   18:  		/* lwz R11, <#[R30 + 4]> */
		/* 8210BF78h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8210BF78h case   18:*/		return 0x8210BF7C;
		  /* 8210BF7Ch */ case   19:  		/* cmplw CR6, R10, R11 */
		/* 8210BF7Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8210BF7Ch case   19:*/		return 0x8210BF80;
		  /* 8210BF80h */ case   20:  		/* bc 4, CR6_EQ, 448 */
		/* 8210BF80h case   20:*/		if ( !regs.CR[6].eq ) { return 0x8210C140;  }
		/* 8210BF80h case   20:*/		return 0x8210BF84;
		  /* 8210BF84h */ case   21:  		/* lwz R11, <#[R30 + 72]> */
		/* 8210BF84h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000048) );
		/* 8210BF84h case   21:*/		return 0x8210BF88;
		  /* 8210BF88h */ case   22:  		/* cmpwi CR6, R11, -1 */
		/* 8210BF88h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210BF88h case   22:*/		return 0x8210BF8C;
		  /* 8210BF8Ch */ case   23:  		/* bc 12, CR6_EQ, 436 */
		/* 8210BF8Ch case   23:*/		if ( regs.CR[6].eq ) { return 0x8210C140;  }
		/* 8210BF8Ch case   23:*/		return 0x8210BF90;
		  /* 8210BF90h */ case   24:  		/* lwz R4, <#[R30 + 92]> */
		/* 8210BF90h case   24:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000005C) );
		/* 8210BF90h case   24:*/		return 0x8210BF94;
		  /* 8210BF94h */ case   25:  		/* cmplwi CR6, R4, 0 */
		/* 8210BF94h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8210BF94h case   25:*/		return 0x8210BF98;
		  /* 8210BF98h */ case   26:  		/* bc 12, CR6_EQ, 8 */
		/* 8210BF98h case   26:*/		if ( regs.CR[6].eq ) { return 0x8210BFA0;  }
		/* 8210BF98h case   26:*/		return 0x8210BF9C;
		  /* 8210BF9Ch */ case   27:  		/* li R24, 1 */
		/* 8210BF9Ch case   27:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 8210BF9Ch case   27:*/		return 0x8210BFA0;
	}
	return 0x8210BFA0;
} // Block from 8210BF30h-8210BFA0h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8210BFA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BFA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BFA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BFA0);
		  /* 8210BFA0h */ case    0:  		/* lwz R8, <#[R30 + 16]> */
		/* 8210BFA0h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000010) );
		/* 8210BFA0h case    0:*/		return 0x8210BFA4;
		  /* 8210BFA4h */ case    1:  		/* addi R6, R1, 128 */
		/* 8210BFA4h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x80);
		/* 8210BFA4h case    1:*/		return 0x8210BFA8;
		  /* 8210BFA8h */ case    2:  		/* rlwinm R5, R8, 2, 0, 29 */
		/* 8210BFA8h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R8);
		/* 8210BFA8h case    2:*/		return 0x8210BFAC;
		  /* 8210BFACh */ case    3:  		/* lwzx R10, <#[R5 + R6]> */
		/* 8210BFACh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + regs.R6 + 0x00000000) );
		/* 8210BFACh case    3:*/		return 0x8210BFB0;
		  /* 8210BFB0h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 8210BFB0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8210BFB0h case    4:*/		return 0x8210BFB4;
		  /* 8210BFB4h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 8210BFB4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8210BFBC;  }
		/* 8210BFB4h case    5:*/		return 0x8210BFB8;
		  /* 8210BFB8h */ case    6:  		/* addi R25, R25, 1 */
		/* 8210BFB8h case    6:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 8210BFB8h case    6:*/		return 0x8210BFBC;
	}
	return 0x8210BFBC;
} // Block from 8210BFA0h-8210BFBCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210BFBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210BFBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210BFBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210BFBC);
		  /* 8210BFBCh */ case    0:  		/* lwz R9, <#[R23 + 24]> */
		/* 8210BFBCh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000018) );
		/* 8210BFBCh case    0:*/		return 0x8210BFC0;
		  /* 8210BFC0h */ case    1:  		/* rlwinm R7, R11, 2, 0, 29 */
		/* 8210BFC0h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R11);
		/* 8210BFC0h case    1:*/		return 0x8210BFC4;
		  /* 8210BFC4h */ case    2:  		/* lwz R10, <#[R30 + 16]> */
		/* 8210BFC4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 8210BFC4h case    2:*/		return 0x8210BFC8;
		  /* 8210BFC8h */ case    3:  		/* addi R11, R1, 128 */
		/* 8210BFC8h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 8210BFC8h case    3:*/		return 0x8210BFCC;
		  /* 8210BFCCh */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210BFCCh case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210BFCCh case    4:*/		return 0x8210BFD0;
		  /* 8210BFD0h */ case    5:  		/* lwzx R3, <#[R7 + R9]> */
		/* 8210BFD0h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 8210BFD0h case    5:*/		return 0x8210BFD4;
		  /* 8210BFD4h */ case    6:  		/* lwzx R9, <#[R10 + R11]> */
		/* 8210BFD4h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210BFD4h case    6:*/		return 0x8210BFD8;
		  /* 8210BFD8h */ case    7:  		/* lwz R7, <#[R3]> */
		/* 8210BFD8h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000000) );
		/* 8210BFD8h case    7:*/		return 0x8210BFDC;
		  /* 8210BFDCh */ case    8:  		/* addi R31, R9, 1 */
		/* 8210BFDCh case    8:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R9,0x1);
		/* 8210BFDCh case    8:*/		return 0x8210BFE0;
		  /* 8210BFE0h */ case    9:  		/* rlwinm R9, R7, 0, 0, 11 */
		/* 8210BFE0h case    9:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R9,regs.R7);
		/* 8210BFE0h case    9:*/		return 0x8210BFE4;
		  /* 8210BFE4h */ case   10:  		/* stwx R31, <#[R10 + R11]> */
		/* 8210BFE4h case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210BFE4h case   10:*/		return 0x8210BFE8;
		  /* 8210BFE8h */ case   11:  		/* cmplw CR6, R9, R17 */
		/* 8210BFE8h case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R17);
		/* 8210BFE8h case   11:*/		return 0x8210BFEC;
		  /* 8210BFECh */ case   12:  		/* bc 12, CR6_EQ, 456 */
		/* 8210BFECh case   12:*/		if ( regs.CR[6].eq ) { return 0x8210C1B4;  }
		/* 8210BFECh case   12:*/		return 0x8210BFF0;
		  /* 8210BFF0h */ case   13:  		/* lis R11, 8320 */
		/* 8210BFF0h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0x2080);
		/* 8210BFF0h case   13:*/		return 0x8210BFF4;
		  /* 8210BFF4h */ case   14:  		/* cmplw CR6, R9, R11 */
		/* 8210BFF4h case   14:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8210BFF4h case   14:*/		return 0x8210BFF8;
		  /* 8210BFF8h */ case   15:  		/* bc 12, CR6_EQ, 444 */
		/* 8210BFF8h case   15:*/		if ( regs.CR[6].eq ) { return 0x8210C1B4;  }
		/* 8210BFF8h case   15:*/		return 0x8210BFFC;
		  /* 8210BFFCh */ case   16:  		/* lis R11, 8336 */
		/* 8210BFFCh case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0x2090);
		/* 8210BFFCh case   16:*/		return 0x8210C000;
		  /* 8210C000h */ case   17:  		/* cmplw CR6, R9, R11 */
		/* 8210C000h case   17:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8210C000h case   17:*/		return 0x8210C004;
		  /* 8210C004h */ case   18:  		/* bc 12, CR6_EQ, 432 */
		/* 8210C004h case   18:*/		if ( regs.CR[6].eq ) { return 0x8210C1B4;  }
		/* 8210C004h case   18:*/		return 0x8210C008;
		  /* 8210C008h */ case   19:  		/* rlwinm R11, R7, 0, 0, 3 */
		/* 8210C008h case   19:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R11,regs.R7);
		/* 8210C008h case   19:*/		return 0x8210C00C;
		  /* 8210C00Ch */ case   20:  		/* lis R14, 4096 */
		/* 8210C00Ch case   20:*/		cpu::op::lis<0>(regs,&regs.R14,0x1000);
		/* 8210C00Ch case   20:*/		return 0x8210C010;
		  /* 8210C010h */ case   21:  		/* cmplw CR6, R11, R14 */
		/* 8210C010h case   21:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 8210C010h case   21:*/		return 0x8210C014;
		  /* 8210C014h */ case   22:  		/* bc 12, CR6_LT, 376 */
		/* 8210C014h case   22:*/		if ( regs.CR[6].lt ) { return 0x8210C18C;  }
		/* 8210C014h case   22:*/		return 0x8210C018;
		  /* 8210C018h */ case   23:  		/* cmplw CR6, R11, R16 */
		/* 8210C018h case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R16);
		/* 8210C018h case   23:*/		return 0x8210C01C;
		  /* 8210C01Ch */ case   24:  		/* bc 12, CR6_GT, 368 */
		/* 8210C01Ch case   24:*/		if ( regs.CR[6].gt ) { return 0x8210C18C;  }
		/* 8210C01Ch case   24:*/		return 0x8210C020;
		  /* 8210C020h */ case   25:  		/* cmplwi CR6, R4, 0 */
		/* 8210C020h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8210C020h case   25:*/		return 0x8210C024;
		  /* 8210C024h */ case   26:  		/* bc 12, CR6_EQ, 224 */
		/* 8210C024h case   26:*/		if ( regs.CR[6].eq ) { return 0x8210C104;  }
		/* 8210C024h case   26:*/		return 0x8210C028;
		  /* 8210C028h */ case   27:  		/* addi R11, R1, 96 */
		/* 8210C028h case   27:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 8210C028h case   27:*/		return 0x8210C02C;
		  /* 8210C02Ch */ case   28:  		/* lwzx R4, <#[R27 + R11]> */
		/* 8210C02Ch case   28:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + regs.R11 + 0x00000000) );
		/* 8210C02Ch case   28:*/		return 0x8210C030;
		  /* 8210C030h */ case   29:  		/* cmplw CR6, R4, R8 */
		/* 8210C030h case   29:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R8);
		/* 8210C030h case   29:*/		return 0x8210C034;
		  /* 8210C034h */ case   30:  		/* bc 12, CR6_EQ, 208 */
		/* 8210C034h case   30:*/		if ( regs.CR[6].eq ) { return 0x8210C104;  }
		/* 8210C034h case   30:*/		return 0x8210C038;
		  /* 8210C038h */ case   31:  		/* lwz R8, <#[R3 + 12]> */
		/* 8210C038h case   31:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x0000000C) );
		/* 8210C038h case   31:*/		return 0x8210C03C;
		  /* 8210C03Ch */ case   32:  		/* li R6, -1 */
		/* 8210C03Ch case   32:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFF);
		/* 8210C03Ch case   32:*/		return 0x8210C040;
		  /* 8210C040h */ case   33:  		/* mr R11, R15 */
		/* 8210C040h case   33:*/		regs.R11 = regs.R15;
		/* 8210C040h case   33:*/		return 0x8210C044;
		  /* 8210C044h */ case   34:  		/* mr R5, R6 */
		/* 8210C044h case   34:*/		regs.R5 = regs.R6;
		/* 8210C044h case   34:*/		return 0x8210C048;
		  /* 8210C048h */ case   35:  		/* cmplwi CR6, R8, 0 */
		/* 8210C048h case   35:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8210C048h case   35:*/		return 0x8210C04C;
		  /* 8210C04Ch */ case   36:  		/* bc 12, CR6_EQ, 184 */
		/* 8210C04Ch case   36:*/		if ( regs.CR[6].eq ) { return 0x8210C104;  }
		/* 8210C04Ch case   36:*/		return 0x8210C050;
		  /* 8210C050h */ case   37:  		/* lwz R31, <#[R3 + 16]> */
		/* 8210C050h case   37:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000010) );
		/* 8210C050h case   37:*/		return 0x8210C054;
		  /* 8210C054h */ case   38:  		/* mr R9, R15 */
		/* 8210C054h case   38:*/		regs.R9 = regs.R15;
		/* 8210C054h case   38:*/		return 0x8210C058;
		  /* 8210C058h */ case   39:  		/* lwzx R10, <#[R31 + R9]> */
		/* 8210C058h case   39:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + regs.R9 + 0x00000000) );
		/* 8210C058h case   39:*/		return 0x8210C05C;
		  /* 8210C05Ch */ case   40:  		/* cmplw CR6, R29, R10 */
		/* 8210C05Ch case   40:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R10);
		/* 8210C05Ch case   40:*/		return 0x8210C060;
		  /* 8210C060h */ case   41:  		/* bc 4, CR6_EQ, 8 */
		/* 8210C060h case   41:*/		if ( !regs.CR[6].eq ) { return 0x8210C068;  }
		/* 8210C060h case   41:*/		return 0x8210C064;
		  /* 8210C064h */ case   42:  		/* mr R5, R11 */
		/* 8210C064h case   42:*/		regs.R5 = regs.R11;
		/* 8210C064h case   42:*/		return 0x8210C068;
	}
	return 0x8210C068;
} // Block from 8210BFBCh-8210C068h (43 instructions)

//////////////////////////////////////////////////////
// Block at 8210C068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C068);
		  /* 8210C068h */ case    0:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210C068h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210C068h case    0:*/		return 0x8210C06C;
		  /* 8210C06Ch */ case    1:  		/* lwzx R10, <#[R10 + R28]> */
		/* 8210C06Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 8210C06Ch case    1:*/		return 0x8210C070;
		  /* 8210C070h */ case    2:  		/* lwz R10, <#[R10 + 16]> */
		/* 8210C070h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 8210C070h case    2:*/		return 0x8210C074;
		  /* 8210C074h */ case    3:  		/* cmplw CR6, R4, R10 */
		/* 8210C074h case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 8210C074h case    3:*/		return 0x8210C078;
		  /* 8210C078h */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 8210C078h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8210C080;  }
		/* 8210C078h case    4:*/		return 0x8210C07C;
		  /* 8210C07Ch */ case    5:  		/* mr R6, R11 */
		/* 8210C07Ch case    5:*/		regs.R6 = regs.R11;
		/* 8210C07Ch case    5:*/		return 0x8210C080;
	}
	return 0x8210C080;
} // Block from 8210C068h-8210C080h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210C080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C080);
		  /* 8210C080h */ case    0:  		/* addi R11, R11, 1 */
		/* 8210C080h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210C080h case    0:*/		return 0x8210C084;
		  /* 8210C084h */ case    1:  		/* addi R9, R9, 4 */
		/* 8210C084h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8210C084h case    1:*/		return 0x8210C088;
		  /* 8210C088h */ case    2:  		/* cmplw CR6, R11, R8 */
		/* 8210C088h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8210C088h case    2:*/		return 0x8210C08C;
		  /* 8210C08Ch */ case    3:  		/* bc 12, CR6_LT, -52 */
		/* 8210C08Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8210C058;  }
		/* 8210C08Ch case    3:*/		return 0x8210C090;
		  /* 8210C090h */ case    4:  		/* cmpwi CR6, R5, -1 */
		/* 8210C090h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R5,0xFFFFFFFF);
		/* 8210C090h case    4:*/		return 0x8210C094;
		  /* 8210C094h */ case    5:  		/* bc 12, CR6_EQ, 112 */
		/* 8210C094h case    5:*/		if ( regs.CR[6].eq ) { return 0x8210C104;  }
		/* 8210C094h case    5:*/		return 0x8210C098;
		  /* 8210C098h */ case    6:  		/* cmpwi CR6, R6, -1 */
		/* 8210C098h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R6,0xFFFFFFFF);
		/* 8210C098h case    6:*/		return 0x8210C09C;
		  /* 8210C09Ch */ case    7:  		/* bc 12, CR6_EQ, 104 */
		/* 8210C09Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x8210C104;  }
		/* 8210C09Ch case    7:*/		return 0x8210C0A0;
		  /* 8210C0A0h */ case    8:  		/* lwz R11, <#[R3 + 4]> */
		/* 8210C0A0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8210C0A0h case    8:*/		return 0x8210C0A4;
		  /* 8210C0A4h */ case    9:  		/* rlwinm R9, R7, 0, 12, 31 */
		/* 8210C0A4h case    9:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R9,regs.R7);
		/* 8210C0A4h case    9:*/		return 0x8210C0A8;
		  /* 8210C0A8h */ case   10:  		/* mr R10, R15 */
		/* 8210C0A8h case   10:*/		regs.R10 = regs.R15;
		/* 8210C0A8h case   10:*/		return 0x8210C0AC;
		  /* 8210C0ACh */ case   11:  		/* divwu. R7, R11, R9 */
		/* 8210C0ACh case   11:*/		cpu::op::divwu<1>(regs,&regs.R7,regs.R11,regs.R9);
		/* 8210C0ACh case   11:*/		return 0x8210C0B0;
		  /* 8210C0B0h */ case   12:  		/* twi 6, R9, 0 */
		/* 8210C0B0h case   12:*/		cpu::op::tw<6>(regs, 0x8210C0B0, regs.R9, 0x00000000);
		/* 8210C0B0h case   12:*/		return 0x8210C0B4;
		  /* 8210C0B4h */ case   13:  		/* bc 12, CR0_EQ, 60 */
		/* 8210C0B4h case   13:*/		if ( regs.CR[0].eq ) { return 0x8210C0F0;  }
		/* 8210C0B4h case   13:*/		return 0x8210C0B8;
		  /* 8210C0B8h */ case   14:  		/* lwz R8, <#[R3 + 12]> */
		/* 8210C0B8h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x0000000C) );
		/* 8210C0B8h case   14:*/		return 0x8210C0BC;
		  /* 8210C0BCh */ case   15:  		/* lwz R9, <#[R3 + 8]> */
		/* 8210C0BCh case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 8210C0BCh case   15:*/		return 0x8210C0C0;
		  /* 8210C0C0h */ case   16:  		/* mullw R11, R8, R10 */
		/* 8210C0C0h case   16:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R8,regs.R10);
		/* 8210C0C0h case   16:*/		return 0x8210C0C4;
		  /* 8210C0C4h */ case   17:  		/* add R4, R11, R6 */
		/* 8210C0C4h case   17:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R6);
		/* 8210C0C4h case   17:*/		return 0x8210C0C8;
		  /* 8210C0C8h */ case   18:  		/* add R11, R11, R5 */
		/* 8210C0C8h case   18:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 8210C0C8h case   18:*/		return 0x8210C0CC;
		  /* 8210C0CCh */ case   19:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 8210C0CCh case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 8210C0CCh case   19:*/		return 0x8210C0D0;
		  /* 8210C0D0h */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210C0D0h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210C0D0h case   20:*/		return 0x8210C0D4;
		  /* 8210C0D4h */ case   21:  		/* lwzx R4, <#[R4 + R9]> */
		/* 8210C0D4h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + regs.R9 + 0x00000000) );
		/* 8210C0D4h case   21:*/		return 0x8210C0D8;
		  /* 8210C0D8h */ case   22:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210C0D8h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210C0D8h case   22:*/		return 0x8210C0DC;
		  /* 8210C0DCh */ case   23:  		/* cmplw CR6, R11, R4 */
		/* 8210C0DCh case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 8210C0DCh case   23:*/		return 0x8210C0E0;
		  /* 8210C0E0h */ case   24:  		/* bc 4, CR6_EQ, 16 */
		/* 8210C0E0h case   24:*/		if ( !regs.CR[6].eq ) { return 0x8210C0F0;  }
		/* 8210C0E0h case   24:*/		return 0x8210C0E4;
		  /* 8210C0E4h */ case   25:  		/* addi R10, R10, 1 */
		/* 8210C0E4h case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210C0E4h case   25:*/		return 0x8210C0E8;
		  /* 8210C0E8h */ case   26:  		/* cmplw CR6, R10, R7 */
		/* 8210C0E8h case   26:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 8210C0E8h case   26:*/		return 0x8210C0EC;
		  /* 8210C0ECh */ case   27:  		/* bc 12, CR6_LT, -44 */
		/* 8210C0ECh case   27:*/		if ( regs.CR[6].lt ) { return 0x8210C0C0;  }
		/* 8210C0ECh case   27:*/		return 0x8210C0F0;
	}
	return 0x8210C0F0;
} // Block from 8210C080h-8210C0F0h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8210C0F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C0F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C0F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C0F0);
		  /* 8210C0F0h */ case    0:  		/* cmplw CR6, R10, R7 */
		/* 8210C0F0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 8210C0F0h case    0:*/		return 0x8210C0F4;
		  /* 8210C0F4h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8210C0F4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210C104;  }
		/* 8210C0F4h case    1:*/		return 0x8210C0F8;
		  /* 8210C0F8h */ case    2:  		/* rlwinm R11, R6, 2, 0, 29 */
		/* 8210C0F8h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R6);
		/* 8210C0F8h case    2:*/		return 0x8210C0FC;
		  /* 8210C0FCh */ case    3:  		/* lwzx R11, <#[R11 + R31]> */
		/* 8210C0FCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 8210C0FCh case    3:*/		return 0x8210C100;
		  /* 8210C100h */ case    4:  		/* stwx R11, <#[R22 + R27]> */
		/* 8210C100h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R22 + regs.R27 + 0x00000000) );
		/* 8210C100h case    4:*/		return 0x8210C104;
	}
	return 0x8210C104;
} // Block from 8210C0F0h-8210C104h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210C104h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C104( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C104) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C104);
		  /* 8210C104h */ case    0:  		/* bl -65868 */
		/* 8210C104h case    0:*/		regs.LR = 0x8210C108; return 0x820FBFB8;
		/* 8210C104h case    0:*/		return 0x8210C108;
		  /* 8210C108h */ case    1:  		/* cmpwi CR0, R3, 0 */
		/* 8210C108h case    1:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210C108h case    1:*/		return 0x8210C10C;
		  /* 8210C10Ch */ case    2:  		/* bc 12, CR0_EQ, 32 */
		/* 8210C10Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8210C12C;  }
		/* 8210C10Ch case    2:*/		return 0x8210C110;
		  /* 8210C110h */ case    3:  		/* lwz R11, <#[R30 + 16]> */
		/* 8210C110h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8210C110h case    3:*/		return 0x8210C114;
		  /* 8210C114h */ case    4:  		/* addi R10, R1, 128 */
		/* 8210C114h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 8210C114h case    4:*/		return 0x8210C118;
		  /* 8210C118h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210C118h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210C118h case    5:*/		return 0x8210C11C;
		  /* 8210C11Ch */ case    6:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210C11Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210C11Ch case    6:*/		return 0x8210C120;
		  /* 8210C120h */ case    7:  		/* cmplwi CR6, R11, 1 */
		/* 8210C120h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8210C120h case    7:*/		return 0x8210C124;
		  /* 8210C124h */ case    8:  		/* bc 4, CR6_GT, 8 */
		/* 8210C124h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8210C12C;  }
		/* 8210C124h case    8:*/		return 0x8210C128;
		  /* 8210C128h */ case    9:  		/* li R24, 1 */
		/* 8210C128h case    9:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 8210C128h case    9:*/		return 0x8210C12C;
	}
	return 0x8210C12C;
} // Block from 8210C104h-8210C12Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8210C12Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C12C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C12C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C12C);
		  /* 8210C12Ch */ case    0:  		/* lwz R22, <#[R1 + 80]> */
		/* 8210C12Ch case    0:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000050) );
		/* 8210C12Ch case    0:*/		return 0x8210C130;
		  /* 8210C130h */ case    1:  		/* addi R26, R26, 1 */
		/* 8210C130h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 8210C130h case    1:*/		return 0x8210C134;
		  /* 8210C134h */ case    2:  		/* addi R27, R27, 4 */
		/* 8210C134h case    2:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 8210C134h case    2:*/		return 0x8210C138;
		  /* 8210C138h */ case    3:  		/* cmplw CR6, R26, R21 */
		/* 8210C138h case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R21);
		/* 8210C138h case    3:*/		return 0x8210C13C;
		  /* 8210C13Ch */ case    4:  		/* bc 12, CR6_LT, -472 */
		/* 8210C13Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x8210BF64;  }
		/* 8210C13Ch case    4:*/		return 0x8210C140;
	}
	return 0x8210C140;
} // Block from 8210C12Ch-8210C140h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210C140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C140);
		  /* 8210C140h */ case    0:  		/* cmplw CR6, R26, R21 */
		/* 8210C140h case    0:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R21);
		/* 8210C140h case    0:*/		return 0x8210C144;
		  /* 8210C144h */ case    1:  		/* bc 4, CR6_LT, 8 */
		/* 8210C144h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8210C14C;  }
		/* 8210C144h case    1:*/		return 0x8210C148;
		  /* 8210C148h */ case    2:  		/* li R24, 1 */
		/* 8210C148h case    2:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 8210C148h case    2:*/		return 0x8210C14C;
	}
	return 0x8210C14C;
} // Block from 8210C140h-8210C14Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210C14Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C14C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C14C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C14C);
		  /* 8210C14Ch */ case    0:  		/* cmpwi CR6, R24, 0 */
		/* 8210C14Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 8210C14Ch case    0:*/		return 0x8210C150;
		  /* 8210C150h */ case    1:  		/* bc 4, CR6_EQ, 224 */
		/* 8210C150h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210C230;  }
		/* 8210C150h case    1:*/		return 0x8210C154;
	}
	return 0x8210C154;
} // Block from 8210C14Ch-8210C154h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210C154h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C154( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C154) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C154);
		  /* 8210C154h */ case    0:  		/* lwz R11, <#[R20]> */
		/* 8210C154h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 8210C154h case    0:*/		return 0x8210C158;
		  /* 8210C158h */ case    1:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 8210C158h case    1:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 8210C158h case    1:*/		return 0x8210C15C;
		  /* 8210C15Ch */ case    2:  		/* cmplw CR6, R11, R14 */
		/* 8210C15Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 8210C15Ch case    2:*/		return 0x8210C160;
		  /* 8210C160h */ case    3:  		/* bc 12, CR6_EQ, 108 */
		/* 8210C160h case    3:*/		if ( regs.CR[6].eq ) { return 0x8210C1CC;  }
		/* 8210C160h case    3:*/		return 0x8210C164;
		  /* 8210C164h */ case    4:  		/* mr R10, R15 */
		/* 8210C164h case    4:*/		regs.R10 = regs.R15;
		/* 8210C164h case    4:*/		return 0x8210C168;
		  /* 8210C168h */ case    5:  		/* addi R11, R1, 128 */
		/* 8210C168h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 8210C168h case    5:*/		return 0x8210C16C;
		  /* 8210C16Ch */ case    6:  		/* lwz R9, <#[R11]> */
		/* 8210C16Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8210C16Ch case    6:*/		return 0x8210C170;
		  /* 8210C170h */ case    7:  		/* cmplw CR6, R9, R21 */
		/* 8210C170h case    7:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R21);
		/* 8210C170h case    7:*/		return 0x8210C174;
		  /* 8210C174h */ case    8:  		/* bc 12, CR6_EQ, 76 */
		/* 8210C174h case    8:*/		if ( regs.CR[6].eq ) { return 0x8210C1C0;  }
		/* 8210C174h case    8:*/		return 0x8210C178;
		  /* 8210C178h */ case    9:  		/* addi R10, R10, 1 */
		/* 8210C178h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210C178h case    9:*/		return 0x8210C17C;
		  /* 8210C17Ch */ case   10:  		/* addi R11, R11, 4 */
		/* 8210C17Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210C17Ch case   10:*/		return 0x8210C180;
		  /* 8210C180h */ case   11:  		/* cmplwi CR6, R10, 4 */
		/* 8210C180h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 8210C180h case   11:*/		return 0x8210C184;
		  /* 8210C184h */ case   12:  		/* bc 12, CR6_LT, -24 */
		/* 8210C184h case   12:*/		if ( regs.CR[6].lt ) { return 0x8210C16C;  }
		/* 8210C184h case   12:*/		return 0x8210C188;
		  /* 8210C188h */ case   13:  		/* b 60 */
		/* 8210C188h case   13:*/		return 0x8210C1C4;
		/* 8210C188h case   13:*/		return 0x8210C18C;
	}
	return 0x8210C18C;
} // Block from 8210C154h-8210C18Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8210C18Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C18C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C18C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C18C);
		  /* 8210C18Ch */ case    0:  		/* lwz R11, <#[R3 + 12]> */
		/* 8210C18Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8210C18Ch case    0:*/		return 0x8210C190;
		  /* 8210C190h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 8210C190h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8210C190h case    1:*/		return 0x8210C194;
		  /* 8210C194h */ case    2:  		/* bc 4, CR6_GT, 12 */
		/* 8210C194h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8210C1A0;  }
		/* 8210C194h case    2:*/		return 0x8210C198;
		  /* 8210C198h */ case    3:  		/* cmplw CR6, R26, R8 */
		/* 8210C198h case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R8);
		/* 8210C198h case    3:*/		return 0x8210C19C;
		  /* 8210C19Ch */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 8210C19Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x8210C1AC;  }
		/* 8210C19Ch case    4:*/		return 0x8210C1A0;
	}
	return 0x8210C1A0;
} // Block from 8210C18Ch-8210C1A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210C1A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C1A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C1A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C1A0);
		  /* 8210C1A0h */ case    0:  		/* lwzx R11, <#[R5 + R6]> */
		/* 8210C1A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + regs.R6 + 0x00000000) );
		/* 8210C1A0h case    0:*/		return 0x8210C1A4;
		  /* 8210C1A4h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 8210C1A4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8210C1A4h case    1:*/		return 0x8210C1A8;
		  /* 8210C1A8h */ case    2:  		/* bc 4, CR6_GT, -120 */
		/* 8210C1A8h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8210C130;  }
		/* 8210C1A8h case    2:*/		return 0x8210C1AC;
	}
	return 0x8210C1AC;
} // Block from 8210C1A0h-8210C1ACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210C1ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C1AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C1AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C1AC);
		  /* 8210C1ACh */ case    0:  		/* li R24, 1 */
		/* 8210C1ACh case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 8210C1ACh case    0:*/		return 0x8210C1B0;
		  /* 8210C1B0h */ case    1:  		/* b -128 */
		/* 8210C1B0h case    1:*/		return 0x8210C130;
		/* 8210C1B0h case    1:*/		return 0x8210C1B4;
	}
	return 0x8210C1B4;
} // Block from 8210C1ACh-8210C1B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210C1B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C1B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C1B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C1B4);
		  /* 8210C1B4h */ case    0:  		/* li R24, 1 */
		/* 8210C1B4h case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 8210C1B4h case    0:*/		return 0x8210C1B8;
		  /* 8210C1B8h */ case    1:  		/* lis R14, 4096 */
		/* 8210C1B8h case    1:*/		cpu::op::lis<0>(regs,&regs.R14,0x1000);
		/* 8210C1B8h case    1:*/		return 0x8210C1BC;
		  /* 8210C1BCh */ case    2:  		/* b -140 */
		/* 8210C1BCh case    2:*/		return 0x8210C130;
		/* 8210C1BCh case    2:*/		return 0x8210C1C0;
	}
	return 0x8210C1C0;
} // Block from 8210C1B4h-8210C1C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210C1C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C1C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C1C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C1C0);
		  /* 8210C1C0h */ case    0:  		/* li R24, 1 */
		/* 8210C1C0h case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 8210C1C0h case    0:*/		return 0x8210C1C4;
	}
	return 0x8210C1C4;
} // Block from 8210C1C0h-8210C1C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210C1C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C1C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C1C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C1C4);
		  /* 8210C1C4h */ case    0:  		/* cmpwi CR6, R24, 0 */
		/* 8210C1C4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 8210C1C4h case    0:*/		return 0x8210C1C8;
		  /* 8210C1C8h */ case    1:  		/* bc 4, CR6_EQ, 104 */
		/* 8210C1C8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210C230;  }
		/* 8210C1C8h case    1:*/		return 0x8210C1CC;
	}
	return 0x8210C1CC;
} // Block from 8210C1C4h-8210C1CCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210C1CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C1CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C1CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C1CC);
		  /* 8210C1CCh */ case    0:  		/* lwz R11, <#[R22]> */
		/* 8210C1CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 8210C1CCh case    0:*/		return 0x8210C1D0;
		  /* 8210C1D0h */ case    1:  		/* lwz R10, <#[R23 + 20]> */
		/* 8210C1D0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000014) );
		/* 8210C1D0h case    1:*/		return 0x8210C1D4;
		  /* 8210C1D4h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210C1D4h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210C1D4h case    2:*/		return 0x8210C1D8;
		  /* 8210C1D8h */ case    3:  		/* lwz R9, <#[R1 + 84]> */
		/* 8210C1D8h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 8210C1D8h case    3:*/		return 0x8210C1DC;
		  /* 8210C1DCh */ case    4:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210C1DCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210C1DCh case    4:*/		return 0x8210C1E0;
		  /* 8210C1E0h */ case    5:  		/* lwz R11, <#[R11 + 12]> */
		/* 8210C1E0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210C1E0h case    5:*/		return 0x8210C1E4;
		  /* 8210C1E4h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210C1E4h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210C1E4h case    6:*/		return 0x8210C1E8;
		  /* 8210C1E8h */ case    7:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210C1E8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210C1E8h case    7:*/		return 0x8210C1EC;
		  /* 8210C1ECh */ case    8:  		/* cmplw CR6, R25, R11 */
		/* 8210C1ECh case    8:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 8210C1ECh case    8:*/		return 0x8210C1F0;
		  /* 8210C1F0h */ case    9:  		/* bc 12, CR6_EQ, 64 */
		/* 8210C1F0h case    9:*/		if ( regs.CR[6].eq ) { return 0x8210C230;  }
		/* 8210C1F0h case    9:*/		return 0x8210C1F4;
		  /* 8210C1F4h */ case   10:  		/* lwz R10, <#[R20 + 12]> */
		/* 8210C1F4h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x0000000C) );
		/* 8210C1F4h case   10:*/		return 0x8210C1F8;
		  /* 8210C1F8h */ case   11:  		/* mr R11, R15 */
		/* 8210C1F8h case   11:*/		regs.R11 = regs.R15;
		/* 8210C1F8h case   11:*/		return 0x8210C1FC;
		  /* 8210C1FCh */ case   12:  		/* cmplwi CR6, R10, 0 */
		/* 8210C1FCh case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8210C1FCh case   12:*/		return 0x8210C200;
		  /* 8210C200h */ case   13:  		/* bc 4, CR6_GT, 48 */
		/* 8210C200h case   13:*/		if ( !regs.CR[6].gt ) { return 0x8210C230;  }
		/* 8210C200h case   13:*/		return 0x8210C204;
		  /* 8210C204h */ case   14:  		/* addi R10, R1, 112 */
		/* 8210C204h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 8210C204h case   14:*/		return 0x8210C208;
		  /* 8210C208h */ case   15:  		/* lwz R9, <#[R10]> */
		/* 8210C208h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8210C208h case   15:*/		return 0x8210C20C;
		  /* 8210C20Ch */ case   16:  		/* cmpwi CR6, R9, 0 */
		/* 8210C20Ch case   16:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 8210C20Ch case   16:*/		return 0x8210C210;
		  /* 8210C210h */ case   17:  		/* bc 12, CR6_EQ, 28 */
		/* 8210C210h case   17:*/		if ( regs.CR[6].eq ) { return 0x8210C22C;  }
		/* 8210C210h case   17:*/		return 0x8210C214;
		  /* 8210C214h */ case   18:  		/* lwz R9, <#[R20 + 12]> */
		/* 8210C214h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R20 + 0x0000000C) );
		/* 8210C214h case   18:*/		return 0x8210C218;
		  /* 8210C218h */ case   19:  		/* addi R11, R11, 1 */
		/* 8210C218h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210C218h case   19:*/		return 0x8210C21C;
		  /* 8210C21Ch */ case   20:  		/* addi R10, R10, 4 */
		/* 8210C21Ch case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210C21Ch case   20:*/		return 0x8210C220;
		  /* 8210C220h */ case   21:  		/* cmplw CR6, R11, R9 */
		/* 8210C220h case   21:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210C220h case   21:*/		return 0x8210C224;
		  /* 8210C224h */ case   22:  		/* bc 12, CR6_LT, -28 */
		/* 8210C224h case   22:*/		if ( regs.CR[6].lt ) { return 0x8210C208;  }
		/* 8210C224h case   22:*/		return 0x8210C228;
		  /* 8210C228h */ case   23:  		/* b 8 */
		/* 8210C228h case   23:*/		return 0x8210C230;
		/* 8210C228h case   23:*/		return 0x8210C22C;
	}
	return 0x8210C22C;
} // Block from 8210C1CCh-8210C22Ch (24 instructions)

//////////////////////////////////////////////////////
// Block at 8210C22Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C22C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C22C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C22C);
		  /* 8210C22Ch */ case    0:  		/* li R24, 1 */
		/* 8210C22Ch case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 8210C22Ch case    0:*/		return 0x8210C230;
	}
	return 0x8210C230;
} // Block from 8210C22Ch-8210C230h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210C230h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C230);
		  /* 8210C230h */ case    0:  		/* mr R28, R15 */
		/* 8210C230h case    0:*/		regs.R28 = regs.R15;
		/* 8210C230h case    0:*/		return 0x8210C234;
		  /* 8210C234h */ case    1:  		/* cmplwi CR6, R21, 0 */
		/* 8210C234h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 8210C234h case    1:*/		return 0x8210C238;
		  /* 8210C238h */ case    2:  		/* bc 12, CR6_EQ, 356 */
		/* 8210C238h case    2:*/		if ( regs.CR[6].eq ) { return 0x8210C39C;  }
		/* 8210C238h case    2:*/		return 0x8210C23C;
		  /* 8210C23Ch */ case    3:  		/* addi R11, R1, 112 */
		/* 8210C23Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 8210C23Ch case    3:*/		return 0x8210C240;
		  /* 8210C240h */ case    4:  		/* mr R31, R15 */
		/* 8210C240h case    4:*/		regs.R31 = regs.R15;
		/* 8210C240h case    4:*/		return 0x8210C244;
		  /* 8210C244h */ case    5:  		/* mr R30, R22 */
		/* 8210C244h case    5:*/		regs.R30 = regs.R22;
		/* 8210C244h case    5:*/		return 0x8210C248;
		  /* 8210C248h */ case    6:  		/* subf R29, R22, R11 */
		/* 8210C248h case    6:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R22,regs.R11);
		/* 8210C248h case    6:*/		return 0x8210C24C;
		  /* 8210C24Ch */ case    7:  		/* lwzx R11, <#[R30 + R29]> */
		/* 8210C24Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R29 + 0x00000000) );
		/* 8210C24Ch case    7:*/		return 0x8210C250;
		  /* 8210C250h */ case    8:  		/* cmpwi CR6, R11, 0 */
		/* 8210C250h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8210C250h case    8:*/		return 0x8210C254;
		  /* 8210C254h */ case    9:  		/* bc 12, CR6_EQ, 308 */
		/* 8210C254h case    9:*/		if ( regs.CR[6].eq ) { return 0x8210C388;  }
		/* 8210C254h case    9:*/		return 0x8210C258;
		  /* 8210C258h */ case   10:  		/* lwz R11, <#[R30]> */
		/* 8210C258h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8210C258h case   10:*/		return 0x8210C25C;
		  /* 8210C25Ch */ case   11:  		/* lwz R7, <#[R23 + 20]> */
		/* 8210C25Ch case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R23 + 0x00000014) );
		/* 8210C25Ch case   11:*/		return 0x8210C260;
		  /* 8210C260h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210C260h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210C260h case   12:*/		return 0x8210C264;
		  /* 8210C264h */ case   13:  		/* lwzx R11, <#[R11 + R7]> */
		/* 8210C264h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 8210C264h case   13:*/		return 0x8210C268;
		  /* 8210C268h */ case   14:  		/* lwz R11, <#[R11 + 72]> */
		/* 8210C268h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 8210C268h case   14:*/		return 0x8210C26C;
		  /* 8210C26Ch */ case   15:  		/* cmpwi CR6, R11, -1 */
		/* 8210C26Ch case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210C26Ch case   15:*/		return 0x8210C270;
		  /* 8210C270h */ case   16:  		/* bc 12, CR6_EQ, 300 */
		/* 8210C270h case   16:*/		if ( regs.CR[6].eq ) { return 0x8210C39C;  }
		/* 8210C270h case   16:*/		return 0x8210C274;
		  /* 8210C274h */ case   17:  		/* lwz R10, <#[R20 + 16]> */
		/* 8210C274h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x00000010) );
		/* 8210C274h case   17:*/		return 0x8210C278;
		  /* 8210C278h */ case   18:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210C278h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210C278h case   18:*/		return 0x8210C27C;
		  /* 8210C27Ch */ case   19:  		/* lwz R9, <#[R23 + 24]> */
		/* 8210C27Ch case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000018) );
		/* 8210C27Ch case   19:*/		return 0x8210C280;
		  /* 8210C280h */ case   20:  		/* lwzx R10, <#[R10 + R31]> */
		/* 8210C280h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 8210C280h case   20:*/		return 0x8210C284;
		  /* 8210C284h */ case   21:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210C284h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210C284h case   21:*/		return 0x8210C288;
		  /* 8210C288h */ case   22:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210C288h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210C288h case   22:*/		return 0x8210C28C;
		  /* 8210C28Ch */ case   23:  		/* lwz R4, <#[R11 + 12]> */
		/* 8210C28Ch case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210C28Ch case   23:*/		return 0x8210C290;
		  /* 8210C290h */ case   24:  		/* lwzx R10, <#[R10 + R7]> */
		/* 8210C290h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 8210C290h case   24:*/		return 0x8210C294;
		  /* 8210C294h */ case   25:  		/* cmplwi CR6, R4, 0 */
		/* 8210C294h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8210C294h case   25:*/		return 0x8210C298;
		  /* 8210C298h */ case   26:  		/* lwz R3, <#[R10 + 4]> */
		/* 8210C298h case   26:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x00000004) );
		/* 8210C298h case   26:*/		return 0x8210C29C;
		  /* 8210C29Ch */ case   27:  		/* bc 12, CR6_EQ, 236 */
		/* 8210C29Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x8210C388;  }
		/* 8210C29Ch case   27:*/		return 0x8210C2A0;
		  /* 8210C2A0h */ case   28:  		/* lwz R8, <#[R11 + 16]> */
		/* 8210C2A0h case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 8210C2A0h case   28:*/		return 0x8210C2A4;
		  /* 8210C2A4h */ case   29:  		/* mr R9, R15 */
		/* 8210C2A4h case   29:*/		regs.R9 = regs.R15;
		/* 8210C2A4h case   29:*/		return 0x8210C2A8;
		  /* 8210C2A8h */ case   30:  		/* mr R11, R22 */
		/* 8210C2A8h case   30:*/		regs.R11 = regs.R22;
		/* 8210C2A8h case   30:*/		return 0x8210C2AC;
		  /* 8210C2ACh */ case   31:  		/* lwz R10, <#[R8]> */
		/* 8210C2ACh case   31:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8210C2ACh case   31:*/		return 0x8210C2B0;
		  /* 8210C2B0h */ case   32:  		/* rlwinm R6, R10, 2, 0, 29 */
		/* 8210C2B0h case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R10);
		/* 8210C2B0h case   32:*/		return 0x8210C2B4;
		  /* 8210C2B4h */ case   33:  		/* lwzx R6, <#[R6 + R7]> */
		/* 8210C2B4h case   33:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R7 + 0x00000000) );
		/* 8210C2B4h case   33:*/		return 0x8210C2B8;
		  /* 8210C2B8h */ case   34:  		/* lwz R5, <#[R6 + 4]> */
		/* 8210C2B8h case   34:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R6 + 0x00000004) );
		/* 8210C2B8h case   34:*/		return 0x8210C2BC;
		  /* 8210C2BCh */ case   35:  		/* lwzx R6, <#[R29 + R11]> */
		/* 8210C2BCh case   35:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 8210C2BCh case   35:*/		return 0x8210C2C0;
		  /* 8210C2C0h */ case   36:  		/* cmpwi CR6, R6, 0 */
		/* 8210C2C0h case   36:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 8210C2C0h case   36:*/		return 0x8210C2C4;
		  /* 8210C2C4h */ case   37:  		/* bc 12, CR6_EQ, 16 */
		/* 8210C2C4h case   37:*/		if ( regs.CR[6].eq ) { return 0x8210C2D4;  }
		/* 8210C2C4h case   37:*/		return 0x8210C2C8;
		  /* 8210C2C8h */ case   38:  		/* lwz R6, <#[R11]> */
		/* 8210C2C8h case   38:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8210C2C8h case   38:*/		return 0x8210C2CC;
		  /* 8210C2CCh */ case   39:  		/* cmplw CR6, R10, R6 */
		/* 8210C2CCh case   39:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 8210C2CCh case   39:*/		return 0x8210C2D0;
		  /* 8210C2D0h */ case   40:  		/* bc 12, CR6_EQ, 24 */
		/* 8210C2D0h case   40:*/		if ( regs.CR[6].eq ) { return 0x8210C2E8;  }
		/* 8210C2D0h case   40:*/		return 0x8210C2D4;
	}
	return 0x8210C2D4;
} // Block from 8210C230h-8210C2D4h (41 instructions)

//////////////////////////////////////////////////////
// Block at 8210C2D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C2D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C2D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C2D4);
		  /* 8210C2D4h */ case    0:  		/* addi R9, R9, 1 */
		/* 8210C2D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8210C2D4h case    0:*/		return 0x8210C2D8;
		  /* 8210C2D8h */ case    1:  		/* addi R11, R11, 4 */
		/* 8210C2D8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210C2D8h case    1:*/		return 0x8210C2DC;
		  /* 8210C2DCh */ case    2:  		/* cmplw CR6, R9, R21 */
		/* 8210C2DCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R21);
		/* 8210C2DCh case    2:*/		return 0x8210C2E0;
		  /* 8210C2E0h */ case    3:  		/* bc 12, CR6_LT, -36 */
		/* 8210C2E0h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210C2BC;  }
		/* 8210C2E0h case    3:*/		return 0x8210C2E4;
		  /* 8210C2E4h */ case    4:  		/* b 8 */
		/* 8210C2E4h case    4:*/		return 0x8210C2EC;
		/* 8210C2E4h case    4:*/		return 0x8210C2E8;
	}
	return 0x8210C2E8;
} // Block from 8210C2D4h-8210C2E8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210C2E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C2E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C2E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C2E8);
		  /* 8210C2E8h */ case    0:  		/* mr R5, R3 */
		/* 8210C2E8h case    0:*/		regs.R5 = regs.R3;
		/* 8210C2E8h case    0:*/		return 0x8210C2EC;
	}
	return 0x8210C2EC;
} // Block from 8210C2E8h-8210C2ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210C2ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C2EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C2EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C2EC);
		  /* 8210C2ECh */ case    0:  		/* li R6, 1 */
		/* 8210C2ECh case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8210C2ECh case    0:*/		return 0x8210C2F0;
		  /* 8210C2F0h */ case    1:  		/* cmplwi CR6, R4, 1 */
		/* 8210C2F0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000001);
		/* 8210C2F0h case    1:*/		return 0x8210C2F4;
		  /* 8210C2F4h */ case    2:  		/* bc 4, CR6_GT, 140 */
		/* 8210C2F4h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8210C380;  }
		/* 8210C2F4h case    2:*/		return 0x8210C2F8;
		  /* 8210C2F8h */ case    3:  		/* addi R9, R8, 4 */
		/* 8210C2F8h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R8,0x4);
		/* 8210C2F8h case    3:*/		return 0x8210C2FC;
		  /* 8210C2FCh */ case    4:  		/* mr R10, R15 */
		/* 8210C2FCh case    4:*/		regs.R10 = regs.R15;
		/* 8210C2FCh case    4:*/		return 0x8210C300;
		  /* 8210C300h */ case    5:  		/* mr R11, R22 */
		/* 8210C300h case    5:*/		regs.R11 = regs.R22;
		/* 8210C300h case    5:*/		return 0x8210C304;
		  /* 8210C304h */ case    6:  		/* lwzx R8, <#[R11 + R29]> */
		/* 8210C304h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 8210C304h case    6:*/		return 0x8210C308;
		  /* 8210C308h */ case    7:  		/* cmpwi CR6, R8, 0 */
		/* 8210C308h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 8210C308h case    7:*/		return 0x8210C30C;
		  /* 8210C30Ch */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 8210C30Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x8210C320;  }
		/* 8210C30Ch case    8:*/		return 0x8210C310;
		  /* 8210C310h */ case    9:  		/* lwz R8, <#[R9]> */
		/* 8210C310h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 8210C310h case    9:*/		return 0x8210C314;
		  /* 8210C314h */ case   10:  		/* lwz R27, <#[R11]> */
		/* 8210C314h case   10:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000000) );
		/* 8210C314h case   10:*/		return 0x8210C318;
		  /* 8210C318h */ case   11:  		/* cmplw CR6, R8, R27 */
		/* 8210C318h case   11:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R27);
		/* 8210C318h case   11:*/		return 0x8210C31C;
		  /* 8210C31Ch */ case   12:  		/* bc 12, CR6_EQ, 24 */
		/* 8210C31Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x8210C334;  }
		/* 8210C31Ch case   12:*/		return 0x8210C320;
	}
	return 0x8210C320;
} // Block from 8210C2ECh-8210C320h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8210C320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C320);
		  /* 8210C320h */ case    0:  		/* addi R10, R10, 1 */
		/* 8210C320h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210C320h case    0:*/		return 0x8210C324;
		  /* 8210C324h */ case    1:  		/* addi R11, R11, 4 */
		/* 8210C324h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210C324h case    1:*/		return 0x8210C328;
		  /* 8210C328h */ case    2:  		/* cmplw CR6, R10, R21 */
		/* 8210C328h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R21);
		/* 8210C328h case    2:*/		return 0x8210C32C;
		  /* 8210C32Ch */ case    3:  		/* bc 12, CR6_LT, -40 */
		/* 8210C32Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8210C304;  }
		/* 8210C32Ch case    3:*/		return 0x8210C330;
		  /* 8210C330h */ case    4:  		/* b 16 */
		/* 8210C330h case    4:*/		return 0x8210C340;
		/* 8210C330h case    4:*/		return 0x8210C334;
	}
	return 0x8210C334;
} // Block from 8210C320h-8210C334h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210C334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C334);
		  /* 8210C334h */ case    0:  		/* cmplw CR6, R5, R3 */
		/* 8210C334h case    0:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R3);
		/* 8210C334h case    0:*/		return 0x8210C338;
		  /* 8210C338h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 8210C338h case    1:*/		if ( regs.CR[6].eq ) { return 0x8210C340;  }
		/* 8210C338h case    1:*/		return 0x8210C33C;
		  /* 8210C33Ch */ case    2:  		/* li R24, 1 */
		/* 8210C33Ch case    2:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 8210C33Ch case    2:*/		return 0x8210C340;
	}
	return 0x8210C340;
} // Block from 8210C334h-8210C340h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210C340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C340);
		  /* 8210C340h */ case    0:  		/* cmpwi CR6, R24, 0 */
		/* 8210C340h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 8210C340h case    0:*/		return 0x8210C344;
		  /* 8210C344h */ case    1:  		/* bc 4, CR6_EQ, 96 */
		/* 8210C344h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210C3A4;  }
		/* 8210C344h case    1:*/		return 0x8210C348;
		  /* 8210C348h */ case    2:  		/* cmplw CR6, R10, R21 */
		/* 8210C348h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R21);
		/* 8210C348h case    2:*/		return 0x8210C34C;
		  /* 8210C34Ch */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 8210C34Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8210C368;  }
		/* 8210C34Ch case    3:*/		return 0x8210C350;
		  /* 8210C350h */ case    4:  		/* lwz R11, <#[R9]> */
		/* 8210C350h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8210C350h case    4:*/		return 0x8210C354;
		  /* 8210C354h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210C354h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210C354h case    5:*/		return 0x8210C358;
		  /* 8210C358h */ case    6:  		/* lwzx R11, <#[R11 + R7]> */
		/* 8210C358h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 8210C358h case    6:*/		return 0x8210C35C;
		  /* 8210C35Ch */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 8210C35Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8210C35Ch case    7:*/		return 0x8210C360;
		  /* 8210C360h */ case    8:  		/* cmplw CR6, R11, R5 */
		/* 8210C360h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 8210C360h case    8:*/		return 0x8210C364;
		  /* 8210C364h */ case    9:  		/* bc 4, CR6_EQ, 24 */
		/* 8210C364h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8210C37C;  }
		/* 8210C364h case    9:*/		return 0x8210C368;
	}
	return 0x8210C368;
} // Block from 8210C340h-8210C368h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8210C368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C368);
		  /* 8210C368h */ case    0:  		/* addi R6, R6, 1 */
		/* 8210C368h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8210C368h case    0:*/		return 0x8210C36C;
		  /* 8210C36Ch */ case    1:  		/* addi R9, R9, 4 */
		/* 8210C36Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8210C36Ch case    1:*/		return 0x8210C370;
		  /* 8210C370h */ case    2:  		/* cmplw CR6, R6, R4 */
		/* 8210C370h case    2:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R4);
		/* 8210C370h case    2:*/		return 0x8210C374;
		  /* 8210C374h */ case    3:  		/* bc 12, CR6_LT, -120 */
		/* 8210C374h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210C2FC;  }
		/* 8210C374h case    3:*/		return 0x8210C378;
		  /* 8210C378h */ case    4:  		/* b 16 */
		/* 8210C378h case    4:*/		return 0x8210C388;
		/* 8210C378h case    4:*/		return 0x8210C37C;
	}
	return 0x8210C37C;
} // Block from 8210C368h-8210C37Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210C37Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C37C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C37C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C37C);
		  /* 8210C37Ch */ case    0:  		/* li R24, 1 */
		/* 8210C37Ch case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 8210C37Ch case    0:*/		return 0x8210C380;
	}
	return 0x8210C380;
} // Block from 8210C37Ch-8210C380h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210C380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C380);
		  /* 8210C380h */ case    0:  		/* cmpwi CR6, R24, 0 */
		/* 8210C380h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 8210C380h case    0:*/		return 0x8210C384;
		  /* 8210C384h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 8210C384h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210C3A4;  }
		/* 8210C384h case    1:*/		return 0x8210C388;
	}
	return 0x8210C388;
} // Block from 8210C380h-8210C388h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210C388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C388);
		  /* 8210C388h */ case    0:  		/* addi R28, R28, 1 */
		/* 8210C388h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8210C388h case    0:*/		return 0x8210C38C;
		  /* 8210C38Ch */ case    1:  		/* addi R31, R31, 4 */
		/* 8210C38Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8210C38Ch case    1:*/		return 0x8210C390;
		  /* 8210C390h */ case    2:  		/* addi R30, R30, 4 */
		/* 8210C390h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8210C390h case    2:*/		return 0x8210C394;
		  /* 8210C394h */ case    3:  		/* cmplw CR6, R28, R21 */
		/* 8210C394h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R21);
		/* 8210C394h case    3:*/		return 0x8210C398;
		  /* 8210C398h */ case    4:  		/* bc 12, CR6_LT, -332 */
		/* 8210C398h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210C24C;  }
		/* 8210C398h case    4:*/		return 0x8210C39C;
	}
	return 0x8210C39C;
} // Block from 8210C388h-8210C39Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210C39Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C39C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C39C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C39C);
		  /* 8210C39Ch */ case    0:  		/* cmpwi CR6, R24, 0 */
		/* 8210C39Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 8210C39Ch case    0:*/		return 0x8210C3A0;
		  /* 8210C3A0h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 8210C3A0h case    1:*/		if ( regs.CR[6].eq ) { return 0x8210C3B4;  }
		/* 8210C3A0h case    1:*/		return 0x8210C3A4;
	}
	return 0x8210C3A4;
} // Block from 8210C39Ch-8210C3A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210C3A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C3A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C3A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C3A4);
		  /* 8210C3A4h */ case    0:  		/* addi R11, R1, 112 */
		/* 8210C3A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 8210C3A4h case    0:*/		return 0x8210C3A8;
		  /* 8210C3A8h */ case    1:  		/* std R15, <#[R11]> */
		/* 8210C3A8h case    1:*/		cpu::mem::store64( regs, regs.R15, (uint32)(regs.R11 + 0x00000000) );
		/* 8210C3A8h case    1:*/		return 0x8210C3AC;
		  /* 8210C3ACh */ case    2:  		/* std R15, <#[R11 + 8]> */
		/* 8210C3ACh case    2:*/		cpu::mem::store64( regs, regs.R15, (uint32)(regs.R11 + 0x00000008) );
		/* 8210C3ACh case    2:*/		return 0x8210C3B0;
		  /* 8210C3B0h */ case    3:  		/* b 1188 */
		/* 8210C3B0h case    3:*/		return 0x8210C854;
		/* 8210C3B0h case    3:*/		return 0x8210C3B4;
	}
	return 0x8210C3B4;
} // Block from 8210C3A4h-8210C3B4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210C3B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C3B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C3B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C3B4);
		  /* 8210C3B4h */ case    0:  		/* mr R29, R15 */
		/* 8210C3B4h case    0:*/		regs.R29 = regs.R15;
		/* 8210C3B4h case    0:*/		return 0x8210C3B8;
		  /* 8210C3B8h */ case    1:  		/* cmplwi CR6, R21, 0 */
		/* 8210C3B8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 8210C3B8h case    1:*/		return 0x8210C3BC;
		  /* 8210C3BCh */ case    2:  		/* bc 12, CR6_EQ, 392 */
		/* 8210C3BCh case    2:*/		if ( regs.CR[6].eq ) { return 0x8210C544;  }
		/* 8210C3BCh case    2:*/		return 0x8210C3C0;
		  /* 8210C3C0h */ case    3:  		/* mr R30, R15 */
		/* 8210C3C0h case    3:*/		regs.R30 = regs.R15;
		/* 8210C3C0h case    3:*/		return 0x8210C3C4;
		  /* 8210C3C4h */ case    4:  		/* addi R11, R1, 112 */
		/* 8210C3C4h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 8210C3C4h case    4:*/		return 0x8210C3C8;
		  /* 8210C3C8h */ case    5:  		/* lwzx R11, <#[R30 + R11]> */
		/* 8210C3C8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8210C3C8h case    5:*/		return 0x8210C3CC;
		  /* 8210C3CCh */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 8210C3CCh case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8210C3CCh case    6:*/		return 0x8210C3D0;
		  /* 8210C3D0h */ case    7:  		/* bc 12, CR6_EQ, 128 */
		/* 8210C3D0h case    7:*/		if ( regs.CR[6].eq ) { return 0x8210C450;  }
		/* 8210C3D0h case    7:*/		return 0x8210C3D4;
		  /* 8210C3D4h */ case    8:  		/* lwz R10, <#[R20 + 16]> */
		/* 8210C3D4h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x00000010) );
		/* 8210C3D4h case    8:*/		return 0x8210C3D8;
		  /* 8210C3D8h */ case    9:  		/* addi R9, R1, 144 */
		/* 8210C3D8h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x90);
		/* 8210C3D8h case    9:*/		return 0x8210C3DC;
		  /* 8210C3DCh */ case   10:  		/* lwz R11, <#[R23 + 20]> */
		/* 8210C3DCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000014) );
		/* 8210C3DCh case   10:*/		return 0x8210C3E0;
		  /* 8210C3E0h */ case   11:  		/* lwzx R8, <#[R10 + R30]> */
		/* 8210C3E0h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 8210C3E0h case   11:*/		return 0x8210C3E4;
		  /* 8210C3E4h */ case   12:  		/* rlwinm R7, R8, 2, 0, 29 */
		/* 8210C3E4h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R8);
		/* 8210C3E4h case   12:*/		return 0x8210C3E8;
		  /* 8210C3E8h */ case   13:  		/* stwx R8, <#[R30 + R9]> */
		/* 8210C3E8h case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + regs.R9 + 0x00000000) );
		/* 8210C3E8h case   13:*/		return 0x8210C3EC;
		  /* 8210C3ECh */ case   14:  		/* lwzx R9, <#[R7 + R11]> */
		/* 8210C3ECh case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 8210C3ECh case   14:*/		return 0x8210C3F0;
		  /* 8210C3F0h */ case   15:  		/* lwz R9, <#[R9 + 96]> */
		/* 8210C3F0h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000060) );
		/* 8210C3F0h case   15:*/		return 0x8210C3F4;
		  /* 8210C3F4h */ case   16:  		/* cmplwi CR6, R9, 0 */
		/* 8210C3F4h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8210C3F4h case   16:*/		return 0x8210C3F8;
		  /* 8210C3F8h */ case   17:  		/* bc 4, CR6_EQ, 316 */
		/* 8210C3F8h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8210C534;  }
		/* 8210C3F8h case   17:*/		return 0x8210C3FC;
		  /* 8210C3FCh */ case   18:  		/* lwz R9, <#[R20 + 8]> */
		/* 8210C3FCh case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R20 + 0x00000008) );
		/* 8210C3FCh case   18:*/		return 0x8210C400;
		  /* 8210C400h */ case   19:  		/* rlwinm R10, R8, 0, 0, 31 */
		/* 8210C400h case   19:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R8);
		/* 8210C400h case   19:*/		return 0x8210C404;
		  /* 8210C404h */ case   20:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210C404h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210C404h case   20:*/		return 0x8210C408;
		  /* 8210C408h */ case   21:  		/* lwzx R9, <#[R30 + R9]> */
		/* 8210C408h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + regs.R9 + 0x00000000) );
		/* 8210C408h case   21:*/		return 0x8210C40C;
		  /* 8210C40Ch */ case   22:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210C40Ch case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210C40Ch case   22:*/		return 0x8210C410;
		  /* 8210C410h */ case   23:  		/* lwzx R10, <#[R10 + R11]> */
		/* 8210C410h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210C410h case   23:*/		return 0x8210C414;
		  /* 8210C414h */ case   24:  		/* lwzx R11, <#[R9 + R11]> */
		/* 8210C414h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8210C414h case   24:*/		return 0x8210C418;
		  /* 8210C418h */ case   25:  		/* lwz R11, <#[R11 + 96]> */
		/* 8210C418h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000060) );
		/* 8210C418h case   25:*/		return 0x8210C41C;
		  /* 8210C41Ch */ case   26:  		/* stw R11, <#[R10 + 96]> */
		/* 8210C41Ch case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000060) );
		/* 8210C41Ch case   26:*/		return 0x8210C420;
		  /* 8210C420h */ case   27:  		/* lwz R10, <#[R20 + 16]> */
		/* 8210C420h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x00000010) );
		/* 8210C420h case   27:*/		return 0x8210C424;
		  /* 8210C424h */ case   28:  		/* lwz R11, <#[R20 + 8]> */
		/* 8210C424h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000008) );
		/* 8210C424h case   28:*/		return 0x8210C428;
		  /* 8210C428h */ case   29:  		/* lwz R9, <#[R23 + 20]> */
		/* 8210C428h case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000014) );
		/* 8210C428h case   29:*/		return 0x8210C42C;
		  /* 8210C42Ch */ case   30:  		/* lwzx R10, <#[R10 + R30]> */
		/* 8210C42Ch case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 8210C42Ch case   30:*/		return 0x8210C430;
		  /* 8210C430h */ case   31:  		/* lwzx R11, <#[R30 + R11]> */
		/* 8210C430h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8210C430h case   31:*/		return 0x8210C434;
		  /* 8210C434h */ case   32:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210C434h case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210C434h case   32:*/		return 0x8210C438;
		  /* 8210C438h */ case   33:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210C438h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210C438h case   33:*/		return 0x8210C43C;
		  /* 8210C43Ch */ case   34:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210C43Ch case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210C43Ch case   34:*/		return 0x8210C440;
		  /* 8210C440h */ case   35:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210C440h case   35:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210C440h case   35:*/		return 0x8210C444;
		  /* 8210C444h */ case   36:  		/* lwz R11, <#[R11 + 100]> */
		/* 8210C444h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000064) );
		/* 8210C444h case   36:*/		return 0x8210C448;
		  /* 8210C448h */ case   37:  		/* stw R11, <#[R10 + 100]> */
		/* 8210C448h case   37:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000064) );
		/* 8210C448h case   37:*/		return 0x8210C44C;
		  /* 8210C44Ch */ case   38:  		/* b 228 */
		/* 8210C44Ch case   38:*/		return 0x8210C530;
		/* 8210C44Ch case   38:*/		return 0x8210C450;
	}
	return 0x8210C450;
} // Block from 8210C3B4h-8210C450h (39 instructions)

//////////////////////////////////////////////////////
// Block at 8210C450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C450);
		  /* 8210C450h */ case    0:  		/* lwzx R11, <#[R22 + R30]> */
		/* 8210C450h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + regs.R30 + 0x00000000) );
		/* 8210C450h case    0:*/		return 0x8210C454;
		  /* 8210C454h */ case    1:  		/* addi R10, R1, 128 */
		/* 8210C454h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 8210C454h case    1:*/		return 0x8210C458;
		  /* 8210C458h */ case    2:  		/* lwz R9, <#[R23 + 20]> */
		/* 8210C458h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000014) );
		/* 8210C458h case    2:*/		return 0x8210C45C;
		  /* 8210C45Ch */ case    3:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 8210C45Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 8210C45Ch case    3:*/		return 0x8210C460;
		  /* 8210C460h */ case    4:  		/* lwzx R31, <#[R8 + R9]> */
		/* 8210C460h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 8210C460h case    4:*/		return 0x8210C464;
		  /* 8210C464h */ case    5:  		/* lwz R9, <#[R31 + 16]> */
		/* 8210C464h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 8210C464h case    5:*/		return 0x8210C468;
		  /* 8210C468h */ case    6:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210C468h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210C468h case    6:*/		return 0x8210C46C;
		  /* 8210C46Ch */ case    7:  		/* lwzx R10, <#[R9 + R10]> */
		/* 8210C46Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210C46Ch case    7:*/		return 0x8210C470;
		  /* 8210C470h */ case    8:  		/* cmplwi CR6, R10, 1 */
		/* 8210C470h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 8210C470h case    8:*/		return 0x8210C474;
		  /* 8210C474h */ case    9:  		/* bc 4, CR6_EQ, 28 */
		/* 8210C474h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8210C490;  }
		/* 8210C474h case    9:*/		return 0x8210C478;
		  /* 8210C478h */ case   10:  		/* addi R10, R1, 96 */
		/* 8210C478h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 8210C478h case   10:*/		return 0x8210C47C;
		  /* 8210C47Ch */ case   11:  		/* addi R9, R1, 144 */
		/* 8210C47Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x90);
		/* 8210C47Ch case   11:*/		return 0x8210C480;
		  /* 8210C480h */ case   12:  		/* lwzx R10, <#[R30 + R10]> */
		/* 8210C480h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + regs.R10 + 0x00000000) );
		/* 8210C480h case   12:*/		return 0x8210C484;
		  /* 8210C484h */ case   13:  		/* stwx R11, <#[R30 + R9]> */
		/* 8210C484h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + regs.R9 + 0x00000000) );
		/* 8210C484h case   13:*/		return 0x8210C488;
		  /* 8210C488h */ case   14:  		/* stw R10, <#[R31 + 16]> */
		/* 8210C488h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 8210C488h case   14:*/		return 0x8210C48C;
		  /* 8210C48Ch */ case   15:  		/* b 164 */
		/* 8210C48Ch case   15:*/		return 0x8210C530;
		/* 8210C48Ch case   15:*/		return 0x8210C490;
	}
	return 0x8210C490;
} // Block from 8210C450h-8210C490h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8210C490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C490);
		  /* 8210C490h */ case    0:  		/* addi R11, R1, 96 */
		/* 8210C490h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 8210C490h case    0:*/		return 0x8210C494;
		  /* 8210C494h */ case    1:  		/* lwz R4, <#[R31 + 4]> */
		/* 8210C494h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000004) );
		/* 8210C494h case    1:*/		return 0x8210C498;
		  /* 8210C498h */ case    2:  		/* mr R3, R23 */
		/* 8210C498h case    2:*/		regs.R3 = regs.R23;
		/* 8210C498h case    2:*/		return 0x8210C49C;
		  /* 8210C49Ch */ case    3:  		/* lwz R5, <#[R31 + 12]> */
		/* 8210C49Ch case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210C49Ch case    3:*/		return 0x8210C4A0;
		  /* 8210C4A0h */ case    4:  		/* fmr FR1, FR31 */
		/* 8210C4A0h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8210C4A0h case    4:*/		return 0x8210C4A4;
		  /* 8210C4A4h */ case    5:  		/* lwzx R6, <#[R30 + R11]> */
		/* 8210C4A4h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8210C4A4h case    5:*/		return 0x8210C4A8;
		  /* 8210C4A8h */ case    6:  		/* bl -62080 */
		/* 8210C4A8h case    6:*/		regs.LR = 0x8210C4AC; return 0x820FD228;
		/* 8210C4A8h case    6:*/		return 0x8210C4AC;
		  /* 8210C4ACh */ case    7:  		/* addi R11, R1, 144 */
		/* 8210C4ACh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x90);
		/* 8210C4ACh case    7:*/		return 0x8210C4B0;
		  /* 8210C4B0h */ case    8:  		/* cmpwi CR6, R3, -1 */
		/* 8210C4B0h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8210C4B0h case    8:*/		return 0x8210C4B4;
		  /* 8210C4B4h */ case    9:  		/* stwx R3, <#[R30 + R11]> */
		/* 8210C4B4h case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8210C4B4h case    9:*/		return 0x8210C4B8;
		  /* 8210C4B8h */ case   10:  		/* bc 12, CR6_EQ, 1248 */
		/* 8210C4B8h case   10:*/		if ( regs.CR[6].eq ) { return 0x8210C998;  }
		/* 8210C4B8h case   10:*/		return 0x8210C4BC;
		  /* 8210C4BCh */ case   11:  		/* lwz R11, <#[R23 + 20]> */
		/* 8210C4BCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000014) );
		/* 8210C4BCh case   11:*/		return 0x8210C4C0;
		  /* 8210C4C0h */ case   12:  		/* rlwinm R28, R3, 2, 0, 29 */
		/* 8210C4C0h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R3);
		/* 8210C4C0h case   12:*/		return 0x8210C4C4;
		  /* 8210C4C4h */ case   13:  		/* mr R4, R31 */
		/* 8210C4C4h case   13:*/		regs.R4 = regs.R31;
		/* 8210C4C4h case   13:*/		return 0x8210C4C8;
		  /* 8210C4C8h */ case   14:  		/* lwzx R3, <#[R28 + R11]> */
		/* 8210C4C8h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 8210C4C8h case   14:*/		return 0x8210C4CC;
		  /* 8210C4CCh */ case   15:  		/* bl -63532 */
		/* 8210C4CCh case   15:*/		regs.LR = 0x8210C4D0; return 0x820FCCA0;
		/* 8210C4CCh case   15:*/		return 0x8210C4D0;
		  /* 8210C4D0h */ case   16:  		/* lwz R11, <#[R23 + 20]> */
		/* 8210C4D0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000014) );
		/* 8210C4D0h case   16:*/		return 0x8210C4D4;
		  /* 8210C4D4h */ case   17:  		/* addi R10, R1, 128 */
		/* 8210C4D4h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 8210C4D4h case   17:*/		return 0x8210C4D8;
		  /* 8210C4D8h */ case   18:  		/* lwz R9, <#[R31]> */
		/* 8210C4D8h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8210C4D8h case   18:*/		return 0x8210C4DC;
		  /* 8210C4DCh */ case   19:  		/* lwz R8, <#[R1 + 84]> */
		/* 8210C4DCh case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 8210C4DCh case   19:*/		return 0x8210C4E0;
		  /* 8210C4E0h */ case   20:  		/* lwzx R11, <#[R28 + R11]> */
		/* 8210C4E0h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 8210C4E0h case   20:*/		return 0x8210C4E4;
		  /* 8210C4E4h */ case   21:  		/* stw R9, <#[R11]> */
		/* 8210C4E4h case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8210C4E4h case   21:*/		return 0x8210C4E8;
		  /* 8210C4E8h */ case   22:  		/* lwz R11, <#[R23 + 20]> */
		/* 8210C4E8h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000014) );
		/* 8210C4E8h case   22:*/		return 0x8210C4EC;
		  /* 8210C4ECh */ case   23:  		/* lwz R9, <#[R31 + 24]> */
		/* 8210C4ECh case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 8210C4ECh case   23:*/		return 0x8210C4F0;
		  /* 8210C4F0h */ case   24:  		/* lwzx R11, <#[R28 + R11]> */
		/* 8210C4F0h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 8210C4F0h case   24:*/		return 0x8210C4F4;
		  /* 8210C4F4h */ case   25:  		/* stw R9, <#[R11 + 24]> */
		/* 8210C4F4h case   25:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000018) );
		/* 8210C4F4h case   25:*/		return 0x8210C4F8;
		  /* 8210C4F8h */ case   26:  		/* lwz R11, <#[R23 + 20]> */
		/* 8210C4F8h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000014) );
		/* 8210C4F8h case   26:*/		return 0x8210C4FC;
		  /* 8210C4FCh */ case   27:  		/* lwz R9, <#[R31 + 20]> */
		/* 8210C4FCh case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 8210C4FCh case   27:*/		return 0x8210C500;
		  /* 8210C500h */ case   28:  		/* lwzx R11, <#[R28 + R11]> */
		/* 8210C500h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 8210C500h case   28:*/		return 0x8210C504;
		  /* 8210C504h */ case   29:  		/* stw R9, <#[R11 + 20]> */
		/* 8210C504h case   29:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 8210C504h case   29:*/		return 0x8210C508;
		  /* 8210C508h */ case   30:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210C508h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210C508h case   30:*/		return 0x8210C50C;
		  /* 8210C50Ch */ case   31:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210C50Ch case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210C50Ch case   31:*/		return 0x8210C510;
		  /* 8210C510h */ case   32:  		/* lwzx R9, <#[R11 + R8]> */
		/* 8210C510h case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8210C510h case   32:*/		return 0x8210C514;
		  /* 8210C514h */ case   33:  		/* addi R9, R9, 1 */
		/* 8210C514h case   33:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8210C514h case   33:*/		return 0x8210C518;
		  /* 8210C518h */ case   34:  		/* stwx R9, <#[R11 + R8]> */
		/* 8210C518h case   34:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8210C518h case   34:*/		return 0x8210C51C;
		  /* 8210C51Ch */ case   35:  		/* lwz R11, <#[R31 + 16]> */
		/* 8210C51Ch case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8210C51Ch case   35:*/		return 0x8210C520;
		  /* 8210C520h */ case   36:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210C520h case   36:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210C520h case   36:*/		return 0x8210C524;
		  /* 8210C524h */ case   37:  		/* lwzx R9, <#[R11 + R10]> */
		/* 8210C524h case   37:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210C524h case   37:*/		return 0x8210C528;
		  /* 8210C528h */ case   38:  		/* addi R9, R9, -1 */
		/* 8210C528h case   38:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8210C528h case   38:*/		return 0x8210C52C;
		  /* 8210C52Ch */ case   39:  		/* stwx R9, <#[R11 + R10]> */
		/* 8210C52Ch case   39:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210C52Ch case   39:*/		return 0x8210C530;
	}
	return 0x8210C530;
} // Block from 8210C490h-8210C530h (40 instructions)

//////////////////////////////////////////////////////
// Block at 8210C530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C530);
		  /* 8210C530h */ case    0:  		/* lwz R22, <#[R1 + 80]> */
		/* 8210C530h case    0:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000050) );
		/* 8210C530h case    0:*/		return 0x8210C534;
	}
	return 0x8210C534;
} // Block from 8210C530h-8210C534h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210C534h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C534( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C534) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C534);
		  /* 8210C534h */ case    0:  		/* addi R29, R29, 1 */
		/* 8210C534h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8210C534h case    0:*/		return 0x8210C538;
		  /* 8210C538h */ case    1:  		/* addi R30, R30, 4 */
		/* 8210C538h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8210C538h case    1:*/		return 0x8210C53C;
		  /* 8210C53Ch */ case    2:  		/* cmplw CR6, R29, R21 */
		/* 8210C53Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R21);
		/* 8210C53Ch case    2:*/		return 0x8210C540;
		  /* 8210C540h */ case    3:  		/* bc 12, CR6_LT, -380 */
		/* 8210C540h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210C3C4;  }
		/* 8210C540h case    3:*/		return 0x8210C544;
	}
	return 0x8210C544;
} // Block from 8210C534h-8210C544h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210C544h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C544( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C544) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C544);
		  /* 8210C544h */ case    0:  		/* mr R25, R15 */
		/* 8210C544h case    0:*/		regs.R25 = regs.R15;
		/* 8210C544h case    0:*/		return 0x8210C548;
		  /* 8210C548h */ case    1:  		/* cmplwi CR6, R21, 0 */
		/* 8210C548h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 8210C548h case    1:*/		return 0x8210C54C;
		  /* 8210C54Ch */ case    2:  		/* bc 12, CR6_EQ, 776 */
		/* 8210C54Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8210C854;  }
		/* 8210C54Ch case    2:*/		return 0x8210C550;
		  /* 8210C550h */ case    3:  		/* mr R24, R15 */
		/* 8210C550h case    3:*/		regs.R24 = regs.R15;
		/* 8210C550h case    3:*/		return 0x8210C554;
		  /* 8210C554h */ case    4:  		/* lwzx R11, <#[R24 + R22]> */
		/* 8210C554h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + regs.R22 + 0x00000000) );
		/* 8210C554h case    4:*/		return 0x8210C558;
		  /* 8210C558h */ case    5:  		/* lwz R10, <#[R23 + 20]> */
		/* 8210C558h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000014) );
		/* 8210C558h case    5:*/		return 0x8210C55C;
		  /* 8210C55Ch */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210C55Ch case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210C55Ch case    6:*/		return 0x8210C560;
		  /* 8210C560h */ case    7:  		/* lwzx R26, <#[R11 + R10]> */
		/* 8210C560h case    7:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210C560h case    7:*/		return 0x8210C564;
		  /* 8210C564h */ case    8:  		/* lwz R11, <#[R26 + 92]> */
		/* 8210C564h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000005C) );
		/* 8210C564h case    8:*/		return 0x8210C568;
		  /* 8210C568h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 8210C568h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210C568h case    9:*/		return 0x8210C56C;
		  /* 8210C56Ch */ case   10:  		/* bc 4, CR6_EQ, 656 */
		/* 8210C56Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x8210C7FC;  }
		/* 8210C56Ch case   10:*/		return 0x8210C570;
		  /* 8210C570h */ case   11:  		/* mr R28, R15 */
		/* 8210C570h case   11:*/		regs.R28 = regs.R15;
		/* 8210C570h case   11:*/		return 0x8210C574;
		  /* 8210C574h */ case   12:  		/* cmplw CR6, R25, R21 */
		/* 8210C574h case   12:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R21);
		/* 8210C574h case   12:*/		return 0x8210C578;
		  /* 8210C578h */ case   13:  		/* bc 4, CR6_LT, 104 */
		/* 8210C578h case   13:*/		if ( !regs.CR[6].lt ) { return 0x8210C5E0;  }
		/* 8210C578h case   13:*/		return 0x8210C57C;
		  /* 8210C57Ch */ case   14:  		/* subf R9, R25, R21 */
		/* 8210C57Ch case   14:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R25,regs.R21);
		/* 8210C57Ch case   14:*/		return 0x8210C580;
		  /* 8210C580h */ case   15:  		/* mr R10, R24 */
		/* 8210C580h case   15:*/		regs.R10 = regs.R24;
		/* 8210C580h case   15:*/		return 0x8210C584;
		  /* 8210C584h */ case   16:  		/* mr R11, R15 */
		/* 8210C584h case   16:*/		regs.R11 = regs.R15;
		/* 8210C584h case   16:*/		return 0x8210C588;
		  /* 8210C588h */ case   17:  		/* mtspr CTR, R9 */
		/* 8210C588h case   17:*/		regs.CTR = regs.R9;
		/* 8210C588h case   17:*/		return 0x8210C58C;
		  /* 8210C58Ch */ case   18:  		/* lwzx R9, <#[R22 + R10]> */
		/* 8210C58Ch case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R22 + regs.R10 + 0x00000000) );
		/* 8210C58Ch case   18:*/		return 0x8210C590;
		  /* 8210C590h */ case   19:  		/* lwz R8, <#[R23 + 20]> */
		/* 8210C590h case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R23 + 0x00000014) );
		/* 8210C590h case   19:*/		return 0x8210C594;
		  /* 8210C594h */ case   20:  		/* rlwinm R7, R9, 2, 0, 29 */
		/* 8210C594h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R9);
		/* 8210C594h case   20:*/		return 0x8210C598;
		  /* 8210C598h */ case   21:  		/* lwz R6, <#[R26 + 72]> */
		/* 8210C598h case   21:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R26 + 0x00000048) );
		/* 8210C598h case   21:*/		return 0x8210C59C;
		  /* 8210C59Ch */ case   22:  		/* lwzx R8, <#[R7 + R8]> */
		/* 8210C59Ch case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 8210C59Ch case   22:*/		return 0x8210C5A0;
		  /* 8210C5A0h */ case   23:  		/* lwz R7, <#[R8 + 72]> */
		/* 8210C5A0h case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x00000048) );
		/* 8210C5A0h case   23:*/		return 0x8210C5A4;
		  /* 8210C5A4h */ case   24:  		/* cmplw CR6, R6, R7 */
		/* 8210C5A4h case   24:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R7);
		/* 8210C5A4h case   24:*/		return 0x8210C5A8;
		  /* 8210C5A8h */ case   25:  		/* bc 4, CR6_EQ, 48 */
		/* 8210C5A8h case   25:*/		if ( !regs.CR[6].eq ) { return 0x8210C5D8;  }
		/* 8210C5A8h case   25:*/		return 0x8210C5AC;
		  /* 8210C5ACh */ case   26:  		/* li R7, 1 */
		/* 8210C5ACh case   26:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8210C5ACh case   26:*/		return 0x8210C5B0;
		  /* 8210C5B0h */ case   27:  		/* addi R6, R1, 144 */
		/* 8210C5B0h case   27:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x90);
		/* 8210C5B0h case   27:*/		return 0x8210C5B4;
		  /* 8210C5B4h */ case   28:  		/* stw R7, <#[R8 + 92]> */
		/* 8210C5B4h case   28:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R8 + 0x0000005C) );
		/* 8210C5B4h case   28:*/		return 0x8210C5B8;
		  /* 8210C5B8h */ case   29:  		/* addi R8, R1, 160 */
		/* 8210C5B8h case   29:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xA0);
		/* 8210C5B8h case   29:*/		return 0x8210C5BC;
		  /* 8210C5BCh */ case   30:  		/* addi R7, R1, 192 */
		/* 8210C5BCh case   30:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xC0);
		/* 8210C5BCh case   30:*/		return 0x8210C5C0;
		  /* 8210C5C0h */ case   31:  		/* addi R28, R28, 1 */
		/* 8210C5C0h case   31:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8210C5C0h case   31:*/		return 0x8210C5C4;
		  /* 8210C5C4h */ case   32:  		/* lwzx R6, <#[R10 + R6]> */
		/* 8210C5C4h case   32:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 8210C5C4h case   32:*/		return 0x8210C5C8;
		  /* 8210C5C8h */ case   33:  		/* stwx R9, <#[R11 + R8]> */
		/* 8210C5C8h case   33:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8210C5C8h case   33:*/		return 0x8210C5CC;
		  /* 8210C5CCh */ case   34:  		/* stwx R6, <#[R11 + R7]> */
		/* 8210C5CCh case   34:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 8210C5CCh case   34:*/		return 0x8210C5D0;
		  /* 8210C5D0h */ case   35:  		/* addi R11, R11, 4 */
		/* 8210C5D0h case   35:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210C5D0h case   35:*/		return 0x8210C5D4;
		  /* 8210C5D4h */ case   36:  		/* lwz R22, <#[R1 + 80]> */
		/* 8210C5D4h case   36:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000050) );
		/* 8210C5D4h case   36:*/		return 0x8210C5D8;
	}
	return 0x8210C5D8;
} // Block from 8210C544h-8210C5D8h (37 instructions)

//////////////////////////////////////////////////////
// Block at 8210C5D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C5D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C5D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C5D8);
		  /* 8210C5D8h */ case    0:  		/* addi R10, R10, 4 */
		/* 8210C5D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210C5D8h case    0:*/		return 0x8210C5DC;
		  /* 8210C5DCh */ case    1:  		/* bc 16, CR0_LT, -80 */
		/* 8210C5DCh case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210C58C;  }
		/* 8210C5DCh case    1:*/		return 0x8210C5E0;
	}
	return 0x8210C5E0;
} // Block from 8210C5D8h-8210C5E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210C5E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C5E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C5E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C5E0);
		  /* 8210C5E0h */ case    0:  		/* lwz R11, <#[R26 + 72]> */
		/* 8210C5E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000048) );
		/* 8210C5E0h case    0:*/		return 0x8210C5E4;
		  /* 8210C5E4h */ case    1:  		/* lwz R10, <#[R23 + 24]> */
		/* 8210C5E4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000018) );
		/* 8210C5E4h case    1:*/		return 0x8210C5E8;
		  /* 8210C5E8h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210C5E8h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210C5E8h case    2:*/		return 0x8210C5EC;
		  /* 8210C5ECh */ case    3:  		/* lwzx R29, <#[R11 + R10]> */
		/* 8210C5ECh case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210C5ECh case    3:*/		return 0x8210C5F0;
		  /* 8210C5F0h */ case    4:  		/* lwz R11, <#[R29]> */
		/* 8210C5F0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8210C5F0h case    4:*/		return 0x8210C5F4;
		  /* 8210C5F4h */ case    5:  		/* rlwinm R10, R11, 0, 0, 3 */
		/* 8210C5F4h case    5:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R10,regs.R11);
		/* 8210C5F4h case    5:*/		return 0x8210C5F8;
		  /* 8210C5F8h */ case    6:  		/* cmplw CR6, R10, R14 */
		/* 8210C5F8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R14);
		/* 8210C5F8h case    6:*/		return 0x8210C5FC;
		  /* 8210C5FCh */ case    7:  		/* bc 12, CR6_LT, 404 */
		/* 8210C5FCh case    7:*/		if ( regs.CR[6].lt ) { return 0x8210C790;  }
		/* 8210C5FCh case    7:*/		return 0x8210C600;
		  /* 8210C600h */ case    8:  		/* cmplw CR6, R10, R16 */
		/* 8210C600h case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R16);
		/* 8210C600h case    8:*/		return 0x8210C604;
		  /* 8210C604h */ case    9:  		/* bc 12, CR6_GT, 396 */
		/* 8210C604h case    9:*/		if ( regs.CR[6].gt ) { return 0x8210C790;  }
		/* 8210C604h case    9:*/		return 0x8210C608;
		  /* 8210C608h */ case   10:  		/* lwz R10, <#[R29 + 4]> */
		/* 8210C608h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 8210C608h case   10:*/		return 0x8210C60C;
		  /* 8210C60Ch */ case   11:  		/* rlwinm R11, R11, 0, 12, 31 */
		/* 8210C60Ch case   11:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R11);
		/* 8210C60Ch case   11:*/		return 0x8210C610;
		  /* 8210C610h */ case   12:  		/* cmplwi CR6, R28, 0 */
		/* 8210C610h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8210C610h case   12:*/		return 0x8210C614;
		  /* 8210C614h */ case   13:  		/* divwu R27, R10, R11 */
		/* 8210C614h case   13:*/		cpu::op::divwu<0>(regs,&regs.R27,regs.R10,regs.R11);
		/* 8210C614h case   13:*/		return 0x8210C618;
		  /* 8210C618h */ case   14:  		/* twi 6, R11, 0 */
		/* 8210C618h case   14:*/		cpu::op::tw<6>(regs, 0x8210C618, regs.R11, 0x00000000);
		/* 8210C618h case   14:*/		return 0x8210C61C;
		  /* 8210C61Ch */ case   15:  		/* bc 12, CR6_EQ, 92 */
		/* 8210C61Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x8210C678;  }
		/* 8210C61Ch case   15:*/		return 0x8210C620;
		  /* 8210C620h */ case   16:  		/* lwz R6, <#[R29 + 12]> */
		/* 8210C620h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R29 + 0x0000000C) );
		/* 8210C620h case   16:*/		return 0x8210C624;
		  /* 8210C624h */ case   17:  		/* mr R10, R15 */
		/* 8210C624h case   17:*/		regs.R10 = regs.R15;
		/* 8210C624h case   17:*/		return 0x8210C628;
		  /* 8210C628h */ case   18:  		/* mtspr CTR, R28 */
		/* 8210C628h case   18:*/		regs.CTR = regs.R28;
		/* 8210C628h case   18:*/		return 0x8210C62C;
		  /* 8210C62Ch */ case   19:  		/* mr R7, R15 */
		/* 8210C62Ch case   19:*/		regs.R7 = regs.R15;
		/* 8210C62Ch case   19:*/		return 0x8210C630;
		  /* 8210C630h */ case   20:  		/* cmplwi CR6, R6, 0 */
		/* 8210C630h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8210C630h case   20:*/		return 0x8210C634;
		  /* 8210C634h */ case   21:  		/* bc 12, CR6_EQ, 60 */
		/* 8210C634h case   21:*/		if ( regs.CR[6].eq ) { return 0x8210C670;  }
		/* 8210C634h case   21:*/		return 0x8210C638;
		  /* 8210C638h */ case   22:  		/* addi R8, R1, 160 */
		/* 8210C638h case   22:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xA0);
		/* 8210C638h case   22:*/		return 0x8210C63C;
		  /* 8210C63Ch */ case   23:  		/* lwz R9, <#[R29 + 16]> */
		/* 8210C63Ch case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000010) );
		/* 8210C63Ch case   23:*/		return 0x8210C640;
		  /* 8210C640h */ case   24:  		/* mr R11, R15 */
		/* 8210C640h case   24:*/		regs.R11 = regs.R15;
		/* 8210C640h case   24:*/		return 0x8210C644;
		  /* 8210C644h */ case   25:  		/* lwzx R8, <#[R10 + R8]> */
		/* 8210C644h case   25:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 8210C644h case   25:*/		return 0x8210C648;
		  /* 8210C648h */ case   26:  		/* lwzx R5, <#[R11 + R9]> */
		/* 8210C648h case   26:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210C648h case   26:*/		return 0x8210C64C;
		  /* 8210C64Ch */ case   27:  		/* cmplw CR6, R5, R8 */
		/* 8210C64Ch case   27:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R8);
		/* 8210C64Ch case   27:*/		return 0x8210C650;
		  /* 8210C650h */ case   28:  		/* bc 12, CR6_EQ, 24 */
		/* 8210C650h case   28:*/		if ( regs.CR[6].eq ) { return 0x8210C668;  }
		/* 8210C650h case   28:*/		return 0x8210C654;
		  /* 8210C654h */ case   29:  		/* addi R7, R7, 1 */
		/* 8210C654h case   29:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8210C654h case   29:*/		return 0x8210C658;
		  /* 8210C658h */ case   30:  		/* addi R11, R11, 4 */
		/* 8210C658h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210C658h case   30:*/		return 0x8210C65C;
		  /* 8210C65Ch */ case   31:  		/* cmplw CR6, R7, R6 */
		/* 8210C65Ch case   31:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 8210C65Ch case   31:*/		return 0x8210C660;
		  /* 8210C660h */ case   32:  		/* bc 12, CR6_LT, -24 */
		/* 8210C660h case   32:*/		if ( regs.CR[6].lt ) { return 0x8210C648;  }
		/* 8210C660h case   32:*/		return 0x8210C664;
		  /* 8210C664h */ case   33:  		/* b 12 */
		/* 8210C664h case   33:*/		return 0x8210C670;
		/* 8210C664h case   33:*/		return 0x8210C668;
	}
	return 0x8210C668;
} // Block from 8210C5E0h-8210C668h (34 instructions)

//////////////////////////////////////////////////////
// Block at 8210C668h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C668);
		  /* 8210C668h */ case    0:  		/* addi R11, R1, 224 */
		/* 8210C668h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xE0);
		/* 8210C668h case    0:*/		return 0x8210C66C;
		  /* 8210C66Ch */ case    1:  		/* stwx R7, <#[R10 + R11]> */
		/* 8210C66Ch case    1:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210C66Ch case    1:*/		return 0x8210C670;
	}
	return 0x8210C670;
} // Block from 8210C668h-8210C670h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210C670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C670);
		  /* 8210C670h */ case    0:  		/* addi R10, R10, 4 */
		/* 8210C670h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210C670h case    0:*/		return 0x8210C674;
		  /* 8210C674h */ case    1:  		/* bc 16, CR0_LT, -72 */
		/* 8210C674h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210C62C;  }
		/* 8210C674h case    1:*/		return 0x8210C678;
	}
	return 0x8210C678;
} // Block from 8210C670h-8210C678h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210C678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C678);
		  /* 8210C678h */ case    0:  		/* li R3, 116 */
		/* 8210C678h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x74);
		/* 8210C678h case    0:*/		return 0x8210C67C;
		  /* 8210C67Ch */ case    1:  		/* bl -65764 */
		/* 8210C67Ch case    1:*/		regs.LR = 0x8210C680; return 0x820FC598;
		/* 8210C67Ch case    1:*/		return 0x8210C680;
		  /* 8210C680h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 8210C680h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210C680h case    2:*/		return 0x8210C684;
		  /* 8210C684h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 8210C684h case    3:*/		if ( regs.CR[0].eq ) { return 0x8210C694;  }
		/* 8210C684h case    3:*/		return 0x8210C688;
		  /* 8210C688h */ case    4:  		/* bl -67560 */
		/* 8210C688h case    4:*/		regs.LR = 0x8210C68C; return 0x820FBEA0;
		/* 8210C688h case    4:*/		return 0x8210C68C;
		  /* 8210C68Ch */ case    5:  		/* mr R30, R3 */
		/* 8210C68Ch case    5:*/		regs.R30 = regs.R3;
		/* 8210C68Ch case    5:*/		return 0x8210C690;
		  /* 8210C690h */ case    6:  		/* b 8 */
		/* 8210C690h case    6:*/		return 0x8210C698;
		/* 8210C690h case    6:*/		return 0x8210C694;
	}
	return 0x8210C694;
} // Block from 8210C678h-8210C694h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210C694h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C694( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C694) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C694);
		  /* 8210C694h */ case    0:  		/* mr R30, R15 */
		/* 8210C694h case    0:*/		regs.R30 = regs.R15;
		/* 8210C694h case    0:*/		return 0x8210C698;
	}
	return 0x8210C698;
} // Block from 8210C694h-8210C698h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210C698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C698);
		  /* 8210C698h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 8210C698h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8210C698h case    0:*/		return 0x8210C69C;
		  /* 8210C69Ch */ case    1:  		/* bc 12, CR6_EQ, 764 */
		/* 8210C69Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8210C998;  }
		/* 8210C69Ch case    1:*/		return 0x8210C6A0;
		  /* 8210C6A0h */ case    2:  		/* lwz R4, <#[R29]> */
		/* 8210C6A0h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000000) );
		/* 8210C6A0h case    2:*/		return 0x8210C6A4;
		  /* 8210C6A4h */ case    3:  		/* li R7, 0 */
		/* 8210C6A4h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8210C6A4h case    3:*/		return 0x8210C6A8;
		  /* 8210C6A8h */ case    4:  		/* mr R6, R28 */
		/* 8210C6A8h case    4:*/		regs.R6 = regs.R28;
		/* 8210C6A8h case    4:*/		return 0x8210C6AC;
		  /* 8210C6ACh */ case    5:  		/* rlwimi R4, R28, 0, 12, 31 */
		/* 8210C6ACh case    5:*/		cpu::op::rlwimi<0,0,12,31>(regs,&regs.R4,regs.R28);
		/* 8210C6ACh case    5:*/		return 0x8210C6B0;
		  /* 8210C6B0h */ case    6:  		/* mullw R5, R27, R28 */
		/* 8210C6B0h case    6:*/		cpu::op::mullw<0>(regs,&regs.R5,regs.R27,regs.R28);
		/* 8210C6B0h case    6:*/		return 0x8210C6B4;
		  /* 8210C6B4h */ case    7:  		/* mr R3, R30 */
		/* 8210C6B4h case    7:*/		regs.R3 = regs.R30;
		/* 8210C6B4h case    7:*/		return 0x8210C6B8;
		  /* 8210C6B8h */ case    8:  		/* bl -65672 */
		/* 8210C6B8h case    8:*/		regs.LR = 0x8210C6BC; return 0x820FC630;
		/* 8210C6B8h case    8:*/		return 0x8210C6BC;
		  /* 8210C6BCh */ case    9:  		/* or. R31, R3, R3 */
		/* 8210C6BCh case    9:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 8210C6BCh case    9:*/		return 0x8210C6C0;
		  /* 8210C6C0h */ case   10:  		/* bc 12, CR0_LT, 744 */
		/* 8210C6C0h case   10:*/		if ( regs.CR[0].lt ) { return 0x8210C9A8;  }
		/* 8210C6C0h case   10:*/		return 0x8210C6C4;
		  /* 8210C6C4h */ case   11:  		/* mr R4, R29 */
		/* 8210C6C4h case   11:*/		regs.R4 = regs.R29;
		/* 8210C6C4h case   11:*/		return 0x8210C6C8;
		  /* 8210C6C8h */ case   12:  		/* mr R3, R30 */
		/* 8210C6C8h case   12:*/		regs.R3 = regs.R30;
		/* 8210C6C8h case   12:*/		return 0x8210C6CC;
		  /* 8210C6CCh */ case   13:  		/* bl -67548 */
		/* 8210C6CCh case   13:*/		regs.LR = 0x8210C6D0; return 0x820FBEF0;
		/* 8210C6CCh case   13:*/		return 0x8210C6D0;
		  /* 8210C6D0h */ case   14:  		/* or. R31, R3, R3 */
		/* 8210C6D0h case   14:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 8210C6D0h case   14:*/		return 0x8210C6D4;
		  /* 8210C6D4h */ case   15:  		/* bc 12, CR0_LT, 724 */
		/* 8210C6D4h case   15:*/		if ( regs.CR[0].lt ) { return 0x8210C9A8;  }
		/* 8210C6D4h case   15:*/		return 0x8210C6D8;
		  /* 8210C6D8h */ case   16:  		/* cmplwi CR6, R28, 0 */
		/* 8210C6D8h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8210C6D8h case   16:*/		return 0x8210C6DC;
		  /* 8210C6DCh */ case   17:  		/* bc 12, CR6_EQ, 116 */
		/* 8210C6DCh case   17:*/		if ( regs.CR[6].eq ) { return 0x8210C750;  }
		/* 8210C6DCh case   17:*/		return 0x8210C6E0;
		  /* 8210C6E0h */ case   18:  		/* mr R10, R15 */
		/* 8210C6E0h case   18:*/		regs.R10 = regs.R15;
		/* 8210C6E0h case   18:*/		return 0x8210C6E4;
		  /* 8210C6E4h */ case   19:  		/* mr R5, R28 */
		/* 8210C6E4h case   19:*/		regs.R5 = regs.R28;
		/* 8210C6E4h case   19:*/		return 0x8210C6E8;
		  /* 8210C6E8h */ case   20:  		/* addi R11, R1, 192 */
		/* 8210C6E8h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xC0);
		/* 8210C6E8h case   20:*/		return 0x8210C6EC;
		  /* 8210C6ECh */ case   21:  		/* lwz R8, <#[R30 + 16]> */
		/* 8210C6ECh case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000010) );
		/* 8210C6ECh case   21:*/		return 0x8210C6F0;
		  /* 8210C6F0h */ case   22:  		/* mr R9, R15 */
		/* 8210C6F0h case   22:*/		regs.R9 = regs.R15;
		/* 8210C6F0h case   22:*/		return 0x8210C6F4;
		  /* 8210C6F4h */ case   23:  		/* cmplwi CR6, R27, 0 */
		/* 8210C6F4h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8210C6F4h case   23:*/		return 0x8210C6F8;
		  /* 8210C6F8h */ case   24:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8210C6F8h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210C6F8h case   24:*/		return 0x8210C6FC;
		  /* 8210C6FCh */ case   25:  		/* stwx R11, <#[R10 + R8]> */
		/* 8210C6FCh case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 8210C6FCh case   25:*/		return 0x8210C700;
		  /* 8210C700h */ case   26:  		/* bc 12, CR6_EQ, 68 */
		/* 8210C700h case   26:*/		if ( regs.CR[6].eq ) { return 0x8210C744;  }
		/* 8210C700h case   26:*/		return 0x8210C704;
		  /* 8210C704h */ case   27:  		/* addi R8, R1, 224 */
		/* 8210C704h case   27:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xE0);
		/* 8210C704h case   27:*/		return 0x8210C708;
		  /* 8210C708h */ case   28:  		/* mtspr CTR, R27 */
		/* 8210C708h case   28:*/		regs.CTR = regs.R27;
		/* 8210C708h case   28:*/		return 0x8210C70C;
		  /* 8210C70Ch */ case   29:  		/* rlwinm R7, R28, 2, 0, 29 */
		/* 8210C70Ch case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R28);
		/* 8210C70Ch case   29:*/		return 0x8210C710;
		  /* 8210C710h */ case   30:  		/* mr R11, R10 */
		/* 8210C710h case   30:*/		regs.R11 = regs.R10;
		/* 8210C710h case   30:*/		return 0x8210C714;
		  /* 8210C714h */ case   31:  		/* lwzx R6, <#[R10 + R8]> */
		/* 8210C714h case   31:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 8210C714h case   31:*/		return 0x8210C718;
		  /* 8210C718h */ case   32:  		/* lwz R8, <#[R29 + 12]> */
		/* 8210C718h case   32:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x0000000C) );
		/* 8210C718h case   32:*/		return 0x8210C71C;
		  /* 8210C71Ch */ case   33:  		/* lwz R4, <#[R29 + 8]> */
		/* 8210C71Ch case   33:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000008) );
		/* 8210C71Ch case   33:*/		return 0x8210C720;
		  /* 8210C720h */ case   34:  		/* mullw R8, R9, R8 */
		/* 8210C720h case   34:*/		cpu::op::mullw<0>(regs,&regs.R8,regs.R9,regs.R8);
		/* 8210C720h case   34:*/		return 0x8210C724;
		  /* 8210C724h */ case   35:  		/* lwz R3, <#[R30 + 8]> */
		/* 8210C724h case   35:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000008) );
		/* 8210C724h case   35:*/		return 0x8210C728;
		  /* 8210C728h */ case   36:  		/* add R8, R8, R6 */
		/* 8210C728h case   36:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R6);
		/* 8210C728h case   36:*/		return 0x8210C72C;
		  /* 8210C72Ch */ case   37:  		/* addi R9, R9, 1 */
		/* 8210C72Ch case   37:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8210C72Ch case   37:*/		return 0x8210C730;
		  /* 8210C730h */ case   38:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8210C730h case   38:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8210C730h case   38:*/		return 0x8210C734;
		  /* 8210C734h */ case   39:  		/* lwzx R8, <#[R8 + R4]> */
		/* 8210C734h case   39:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R4 + 0x00000000) );
		/* 8210C734h case   39:*/		return 0x8210C738;
		  /* 8210C738h */ case   40:  		/* stwx R8, <#[R11 + R3]> */
		/* 8210C738h case   40:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8210C738h case   40:*/		return 0x8210C73C;
		  /* 8210C73Ch */ case   41:  		/* add R11, R11, R7 */
		/* 8210C73Ch case   41:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 8210C73Ch case   41:*/		return 0x8210C740;
		  /* 8210C740h */ case   42:  		/* bc 16, CR0_LT, -40 */
		/* 8210C740h case   42:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210C718;  }
		/* 8210C740h case   42:*/		return 0x8210C744;
	}
	return 0x8210C744;
} // Block from 8210C698h-8210C744h (43 instructions)

//////////////////////////////////////////////////////
// Block at 8210C744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C744);
		  /* 8210C744h */ case    0:  		/* addic. R5, R5, -1 */
		/* 8210C744h case    0:*/		cpu::op::addic<1>(regs,&regs.R5,regs.R5,0xFFFFFFFF);
		/* 8210C744h case    0:*/		return 0x8210C748;
		  /* 8210C748h */ case    1:  		/* addi R10, R10, 4 */
		/* 8210C748h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210C748h case    1:*/		return 0x8210C74C;
		  /* 8210C74Ch */ case    2:  		/* bc 4, CR0_EQ, -100 */
		/* 8210C74Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x8210C6E8;  }
		/* 8210C74Ch case    2:*/		return 0x8210C750;
	}
	return 0x8210C750;
} // Block from 8210C744h-8210C750h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210C750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C750);
		  /* 8210C750h */ case    0:  		/* lwz R11, <#[R26 + 72]> */
		/* 8210C750h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000048) );
		/* 8210C750h case    0:*/		return 0x8210C754;
		  /* 8210C754h */ case    1:  		/* lwz R10, <#[R23 + 24]> */
		/* 8210C754h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000018) );
		/* 8210C754h case    1:*/		return 0x8210C758;
		  /* 8210C758h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210C758h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210C758h case    2:*/		return 0x8210C75C;
		  /* 8210C75Ch */ case    3:  		/* lwzx R31, <#[R11 + R10]> */
		/* 8210C75Ch case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210C75Ch case    3:*/		return 0x8210C760;
		  /* 8210C760h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8210C760h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8210C760h case    4:*/		return 0x8210C764;
		  /* 8210C764h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 8210C764h case    5:*/		if ( regs.CR[6].eq ) { return 0x8210C778;  }
		/* 8210C764h case    5:*/		return 0x8210C768;
		  /* 8210C768h */ case    6:  		/* mr R3, R31 */
		/* 8210C768h case    6:*/		regs.R3 = regs.R31;
		/* 8210C768h case    6:*/		return 0x8210C76C;
		  /* 8210C76Ch */ case    7:  		/* bl 1117268 */
		/* 8210C76Ch case    7:*/		regs.LR = 0x8210C770; return 0x8221D3C0;
		/* 8210C76Ch case    7:*/		return 0x8210C770;
		  /* 8210C770h */ case    8:  		/* mr R3, R31 */
		/* 8210C770h case    8:*/		regs.R3 = regs.R31;
		/* 8210C770h case    8:*/		return 0x8210C774;
		  /* 8210C774h */ case    9:  		/* bl -65924 */
		/* 8210C774h case    9:*/		regs.LR = 0x8210C778; return 0x820FC5F0;
		/* 8210C774h case    9:*/		return 0x8210C778;
	}
	return 0x8210C778;
} // Block from 8210C750h-8210C778h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8210C778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C778);
		  /* 8210C778h */ case    0:  		/* lwz R11, <#[R26 + 72]> */
		/* 8210C778h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000048) );
		/* 8210C778h case    0:*/		return 0x8210C77C;
		  /* 8210C77Ch */ case    1:  		/* lwz R10, <#[R23 + 24]> */
		/* 8210C77Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000018) );
		/* 8210C77Ch case    1:*/		return 0x8210C780;
		  /* 8210C780h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210C780h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210C780h case    2:*/		return 0x8210C784;
		  /* 8210C784h */ case    3:  		/* stwx R30, <#[R11 + R10]> */
		/* 8210C784h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210C784h case    3:*/		return 0x8210C788;
		  /* 8210C788h */ case    4:  		/* lwz R22, <#[R1 + 80]> */
		/* 8210C788h case    4:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000050) );
		/* 8210C788h case    4:*/		return 0x8210C78C;
		  /* 8210C78Ch */ case    5:  		/* b 112 */
		/* 8210C78Ch case    5:*/		return 0x8210C7FC;
		/* 8210C78Ch case    5:*/		return 0x8210C790;
	}
	return 0x8210C790;
} // Block from 8210C778h-8210C790h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210C790h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C790);
		  /* 8210C790h */ case    0:  		/* lwz R11, <#[R29 + 12]> */
		/* 8210C790h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 8210C790h case    0:*/		return 0x8210C794;
		  /* 8210C794h */ case    1:  		/* mr R6, R15 */
		/* 8210C794h case    1:*/		regs.R6 = regs.R15;
		/* 8210C794h case    1:*/		return 0x8210C798;
		  /* 8210C798h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8210C798h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210C798h case    2:*/		return 0x8210C79C;
		  /* 8210C79Ch */ case    3:  		/* bc 4, CR6_GT, 96 */
		/* 8210C79Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210C7FC;  }
		/* 8210C79Ch case    3:*/		return 0x8210C7A0;
		  /* 8210C7A0h */ case    4:  		/* mr R9, R15 */
		/* 8210C7A0h case    4:*/		regs.R9 = regs.R15;
		/* 8210C7A0h case    4:*/		return 0x8210C7A4;
		  /* 8210C7A4h */ case    5:  		/* lwz R8, <#[R29 + 16]> */
		/* 8210C7A4h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000010) );
		/* 8210C7A4h case    5:*/		return 0x8210C7A8;
		  /* 8210C7A8h */ case    6:  		/* mr R11, R15 */
		/* 8210C7A8h case    6:*/		regs.R11 = regs.R15;
		/* 8210C7A8h case    6:*/		return 0x8210C7AC;
		  /* 8210C7ACh */ case    7:  		/* mr R10, R22 */
		/* 8210C7ACh case    7:*/		regs.R10 = regs.R22;
		/* 8210C7ACh case    7:*/		return 0x8210C7B0;
		  /* 8210C7B0h */ case    8:  		/* lwzx R7, <#[R9 + R8]> */
		/* 8210C7B0h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 8210C7B0h case    8:*/		return 0x8210C7B4;
		  /* 8210C7B4h */ case    9:  		/* lwz R5, <#[R10]> */
		/* 8210C7B4h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000000) );
		/* 8210C7B4h case    9:*/		return 0x8210C7B8;
		  /* 8210C7B8h */ case   10:  		/* cmplw CR6, R7, R5 */
		/* 8210C7B8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R5);
		/* 8210C7B8h case   10:*/		return 0x8210C7BC;
		  /* 8210C7BCh */ case   11:  		/* bc 12, CR6_EQ, 24 */
		/* 8210C7BCh case   11:*/		if ( regs.CR[6].eq ) { return 0x8210C7D4;  }
		/* 8210C7BCh case   11:*/		return 0x8210C7C0;
		  /* 8210C7C0h */ case   12:  		/* addi R11, R11, 1 */
		/* 8210C7C0h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210C7C0h case   12:*/		return 0x8210C7C4;
		  /* 8210C7C4h */ case   13:  		/* addi R10, R10, 4 */
		/* 8210C7C4h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210C7C4h case   13:*/		return 0x8210C7C8;
		  /* 8210C7C8h */ case   14:  		/* cmplw CR6, R11, R21 */
		/* 8210C7C8h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R21);
		/* 8210C7C8h case   14:*/		return 0x8210C7CC;
		  /* 8210C7CCh */ case   15:  		/* bc 12, CR6_LT, -24 */
		/* 8210C7CCh case   15:*/		if ( regs.CR[6].lt ) { return 0x8210C7B4;  }
		/* 8210C7CCh case   15:*/		return 0x8210C7D0;
		  /* 8210C7D0h */ case   16:  		/* b 24 */
		/* 8210C7D0h case   16:*/		return 0x8210C7E8;
		/* 8210C7D0h case   16:*/		return 0x8210C7D4;
	}
	return 0x8210C7D4;
} // Block from 8210C790h-8210C7D4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8210C7D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C7D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C7D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C7D4);
		  /* 8210C7D4h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210C7D4h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210C7D4h case    0:*/		return 0x8210C7D8;
		  /* 8210C7D8h */ case    1:  		/* addi R10, R1, 144 */
		/* 8210C7D8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 8210C7D8h case    1:*/		return 0x8210C7DC;
		  /* 8210C7DCh */ case    2:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210C7DCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210C7DCh case    2:*/		return 0x8210C7E0;
		  /* 8210C7E0h */ case    3:  		/* stwx R11, <#[R9 + R8]> */
		/* 8210C7E0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 8210C7E0h case    3:*/		return 0x8210C7E4;
		  /* 8210C7E4h */ case    4:  		/* lwz R22, <#[R1 + 80]> */
		/* 8210C7E4h case    4:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000050) );
		/* 8210C7E4h case    4:*/		return 0x8210C7E8;
	}
	return 0x8210C7E8;
} // Block from 8210C7D4h-8210C7E8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210C7E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C7E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C7E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C7E8);
		  /* 8210C7E8h */ case    0:  		/* lwz R11, <#[R29 + 12]> */
		/* 8210C7E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 8210C7E8h case    0:*/		return 0x8210C7EC;
		  /* 8210C7ECh */ case    1:  		/* addi R6, R6, 1 */
		/* 8210C7ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8210C7ECh case    1:*/		return 0x8210C7F0;
		  /* 8210C7F0h */ case    2:  		/* addi R9, R9, 4 */
		/* 8210C7F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8210C7F0h case    2:*/		return 0x8210C7F4;
		  /* 8210C7F4h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 8210C7F4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 8210C7F4h case    3:*/		return 0x8210C7F8;
		  /* 8210C7F8h */ case    4:  		/* bc 12, CR6_LT, -84 */
		/* 8210C7F8h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210C7A4;  }
		/* 8210C7F8h case    4:*/		return 0x8210C7FC;
	}
	return 0x8210C7FC;
} // Block from 8210C7E8h-8210C7FCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210C7FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C7FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C7FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C7FC);
		  /* 8210C7FCh */ case    0:  		/* addi R25, R25, 1 */
		/* 8210C7FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 8210C7FCh case    0:*/		return 0x8210C800;
		  /* 8210C800h */ case    1:  		/* addi R24, R24, 4 */
		/* 8210C800h case    1:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x4);
		/* 8210C800h case    1:*/		return 0x8210C804;
		  /* 8210C804h */ case    2:  		/* cmplw CR6, R25, R21 */
		/* 8210C804h case    2:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R21);
		/* 8210C804h case    2:*/		return 0x8210C808;
		  /* 8210C808h */ case    3:  		/* bc 12, CR6_LT, -692 */
		/* 8210C808h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210C554;  }
		/* 8210C808h case    3:*/		return 0x8210C80C;
		  /* 8210C80Ch */ case    4:  		/* cmplwi CR6, R21, 0 */
		/* 8210C80Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 8210C80Ch case    4:*/		return 0x8210C810;
		  /* 8210C810h */ case    5:  		/* bc 12, CR6_EQ, 68 */
		/* 8210C810h case    5:*/		if ( regs.CR[6].eq ) { return 0x8210C854;  }
		/* 8210C810h case    5:*/		return 0x8210C814;
		  /* 8210C814h */ case    6:  		/* mtspr CTR, R21 */
		/* 8210C814h case    6:*/		regs.CTR = regs.R21;
		/* 8210C814h case    6:*/		return 0x8210C818;
		  /* 8210C818h */ case    7:  		/* mr R11, R15 */
		/* 8210C818h case    7:*/		regs.R11 = regs.R15;
		/* 8210C818h case    7:*/		return 0x8210C81C;
		  /* 8210C81Ch */ case    8:  		/* b 8 */
		/* 8210C81Ch case    8:*/		return 0x8210C824;
		/* 8210C81Ch case    8:*/		return 0x8210C820;
		  /* 8210C820h */ case    9:  		/* lwz R22, <#[R1 + 80]> */
		/* 8210C820h case    9:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000050) );
		/* 8210C820h case    9:*/		return 0x8210C824;
	}
	return 0x8210C824;
} // Block from 8210C7FCh-8210C824h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8210C824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C824);
		  /* 8210C824h */ case    0:  		/* addi R10, R1, 144 */
		/* 8210C824h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 8210C824h case    0:*/		return 0x8210C828;
		  /* 8210C828h */ case    1:  		/* li R9, 1 */
		/* 8210C828h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8210C828h case    1:*/		return 0x8210C82C;
		  /* 8210C82Ch */ case    2:  		/* lwzx R10, <#[R11 + R10]> */
		/* 8210C82Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210C82Ch case    2:*/		return 0x8210C830;
		  /* 8210C830h */ case    3:  		/* stwx R10, <#[R11 + R22]> */
		/* 8210C830h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R22 + 0x00000000) );
		/* 8210C830h case    3:*/		return 0x8210C834;
		  /* 8210C834h */ case    4:  		/* lwz R10, <#[R1 + 80]> */
		/* 8210C834h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8210C834h case    4:*/		return 0x8210C838;
		  /* 8210C838h */ case    5:  		/* lwz R8, <#[R23 + 20]> */
		/* 8210C838h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R23 + 0x00000014) );
		/* 8210C838h case    5:*/		return 0x8210C83C;
		  /* 8210C83Ch */ case    6:  		/* lwzx R10, <#[R11 + R10]> */
		/* 8210C83Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210C83Ch case    6:*/		return 0x8210C840;
		  /* 8210C840h */ case    7:  		/* addi R11, R11, 4 */
		/* 8210C840h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210C840h case    7:*/		return 0x8210C844;
		  /* 8210C844h */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210C844h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210C844h case    8:*/		return 0x8210C848;
		  /* 8210C848h */ case    9:  		/* lwzx R10, <#[R10 + R8]> */
		/* 8210C848h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 8210C848h case    9:*/		return 0x8210C84C;
		  /* 8210C84Ch */ case   10:  		/* stw R9, <#[R10 + 92]> */
		/* 8210C84Ch case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x0000005C) );
		/* 8210C84Ch case   10:*/		return 0x8210C850;
		  /* 8210C850h */ case   11:  		/* bc 16, CR0_LT, -48 */
		/* 8210C850h case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210C820;  }
		/* 8210C850h case   11:*/		return 0x8210C854;
	}
	return 0x8210C854;
} // Block from 8210C824h-8210C854h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8210C854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C854);
		  /* 8210C854h */ case    0:  		/* addi R19, R19, 1 */
		/* 8210C854h case    0:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x1);
		/* 8210C854h case    0:*/		return 0x8210C858;
		  /* 8210C858h */ case    1:  		/* mr R4, R19 */
		/* 8210C858h case    1:*/		regs.R4 = regs.R19;
		/* 8210C858h case    1:*/		return 0x8210C85C;
	}
	return 0x8210C85C;
} // Block from 8210C854h-8210C85Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210C85Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C85C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C85C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C85C);
		  /* 8210C85Ch */ case    0:  		/* addi R5, R1, 80 */
		/* 8210C85Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8210C85Ch case    0:*/		return 0x8210C860;
		  /* 8210C860h */ case    1:  		/* mr R3, R20 */
		/* 8210C860h case    1:*/		regs.R3 = regs.R20;
		/* 8210C860h case    1:*/		return 0x8210C864;
		  /* 8210C864h */ case    2:  		/* bl -67916 */
		/* 8210C864h case    2:*/		regs.LR = 0x8210C868; return 0x820FBF18;
		/* 8210C864h case    2:*/		return 0x8210C868;
		  /* 8210C868h */ case    3:  		/* or. R21, R3, R3 */
		/* 8210C868h case    3:*/		cpu::op::or<1>(regs,&regs.R21,regs.R3,regs.R3);
		/* 8210C868h case    3:*/		return 0x8210C86C;
		  /* 8210C86Ch */ case    4:  		/* bc 4, CR0_EQ, -2352 */
		/* 8210C86Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x8210BF3C;  }
		/* 8210C86Ch case    4:*/		return 0x8210C870;
		  /* 8210C870h */ case    5:  		/* lwz R11, <#[R20]> */
		/* 8210C870h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 8210C870h case    5:*/		return 0x8210C874;
		  /* 8210C874h */ case    6:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 8210C874h case    6:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 8210C874h case    6:*/		return 0x8210C878;
		  /* 8210C878h */ case    7:  		/* cmplw CR6, R11, R14 */
		/* 8210C878h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 8210C878h case    7:*/		return 0x8210C87C;
		  /* 8210C87Ch */ case    8:  		/* bc 4, CR6_EQ, 240 */
		/* 8210C87Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x8210C96C;  }
		/* 8210C87Ch case    8:*/		return 0x8210C880;
		  /* 8210C880h */ case    9:  		/* lwz R11, <#[R20 + 12]> */
		/* 8210C880h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x0000000C) );
		/* 8210C880h case    9:*/		return 0x8210C884;
		  /* 8210C884h */ case   10:  		/* mr R7, R15 */
		/* 8210C884h case   10:*/		regs.R7 = regs.R15;
		/* 8210C884h case   10:*/		return 0x8210C888;
		  /* 8210C888h */ case   11:  		/* mr R6, R15 */
		/* 8210C888h case   11:*/		regs.R6 = regs.R15;
		/* 8210C888h case   11:*/		return 0x8210C88C;
		  /* 8210C88Ch */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 8210C88Ch case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210C88Ch case   12:*/		return 0x8210C890;
		  /* 8210C890h */ case   13:  		/* bc 4, CR6_GT, 204 */
		/* 8210C890h case   13:*/		if ( !regs.CR[6].gt ) { return 0x8210C95C;  }
		/* 8210C890h case   13:*/		return 0x8210C894;
		  /* 8210C894h */ case   14:  		/* mr R11, R15 */
		/* 8210C894h case   14:*/		regs.R11 = regs.R15;
		/* 8210C894h case   14:*/		return 0x8210C898;
		  /* 8210C898h */ case   15:  		/* mr R8, R15 */
		/* 8210C898h case   15:*/		regs.R8 = regs.R15;
		/* 8210C898h case   15:*/		return 0x8210C89C;
		  /* 8210C89Ch */ case   16:  		/* addi R10, R1, 112 */
		/* 8210C89Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 8210C89Ch case   16:*/		return 0x8210C8A0;
		  /* 8210C8A0h */ case   17:  		/* lwzx R10, <#[R8 + R10]> */
		/* 8210C8A0h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 8210C8A0h case   17:*/		return 0x8210C8A4;
		  /* 8210C8A4h */ case   18:  		/* cmpwi CR6, R10, 0 */
		/* 8210C8A4h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8210C8A4h case   18:*/		return 0x8210C8A8;
		  /* 8210C8A8h */ case   19:  		/* bc 4, CR6_EQ, 40 */
		/* 8210C8A8h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8210C8D0;  }
		/* 8210C8A8h case   19:*/		return 0x8210C8AC;
		  /* 8210C8ACh */ case   20:  		/* lwz R10, <#[R20 + 16]> */
		/* 8210C8ACh case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x00000010) );
		/* 8210C8ACh case   20:*/		return 0x8210C8B0;
		  /* 8210C8B0h */ case   21:  		/* addi R7, R7, 1 */
		/* 8210C8B0h case   21:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8210C8B0h case   21:*/		return 0x8210C8B4;
		  /* 8210C8B4h */ case   22:  		/* lwzx R9, <#[R8 + R10]> */
		/* 8210C8B4h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 8210C8B4h case   22:*/		return 0x8210C8B8;
		  /* 8210C8B8h */ case   23:  		/* stwx R9, <#[R11 + R10]> */
		/* 8210C8B8h case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210C8B8h case   23:*/		return 0x8210C8BC;
		  /* 8210C8BCh */ case   24:  		/* lwz R10, <#[R20 + 8]> */
		/* 8210C8BCh case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x00000008) );
		/* 8210C8BCh case   24:*/		return 0x8210C8C0;
		  /* 8210C8C0h */ case   25:  		/* lwzx R9, <#[R8 + R10]> */
		/* 8210C8C0h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 8210C8C0h case   25:*/		return 0x8210C8C4;
		  /* 8210C8C4h */ case   26:  		/* stwx R9, <#[R11 + R10]> */
		/* 8210C8C4h case   26:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210C8C4h case   26:*/		return 0x8210C8C8;
		  /* 8210C8C8h */ case   27:  		/* addi R11, R11, 4 */
		/* 8210C8C8h case   27:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210C8C8h case   27:*/		return 0x8210C8CC;
		  /* 8210C8CCh */ case   28:  		/* b 104 */
		/* 8210C8CCh case   28:*/		return 0x8210C934;
		/* 8210C8CCh case   28:*/		return 0x8210C8D0;
	}
	return 0x8210C8D0;
} // Block from 8210C85Ch-8210C8D0h (29 instructions)

//////////////////////////////////////////////////////
// Block at 8210C8D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C8D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C8D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C8D0);
		  /* 8210C8D0h */ case    0:  		/* lwz R9, <#[R20 + 16]> */
		/* 8210C8D0h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R20 + 0x00000010) );
		/* 8210C8D0h case    0:*/		return 0x8210C8D4;
		  /* 8210C8D4h */ case    1:  		/* lwz R10, <#[R23 + 20]> */
		/* 8210C8D4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000014) );
		/* 8210C8D4h case    1:*/		return 0x8210C8D8;
		  /* 8210C8D8h */ case    2:  		/* lwzx R9, <#[R11 + R9]> */
		/* 8210C8D8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210C8D8h case    2:*/		return 0x8210C8DC;
		  /* 8210C8DCh */ case    3:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210C8DCh case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210C8DCh case    3:*/		return 0x8210C8E0;
		  /* 8210C8E0h */ case    4:  		/* lwzx R9, <#[R9 + R10]> */
		/* 8210C8E0h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210C8E0h case    4:*/		return 0x8210C8E4;
		  /* 8210C8E4h */ case    5:  		/* lwz R5, <#[R9 + 96]> */
		/* 8210C8E4h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000060) );
		/* 8210C8E4h case    5:*/		return 0x8210C8E8;
		  /* 8210C8E8h */ case    6:  		/* cmplwi CR6, R5, 0 */
		/* 8210C8E8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8210C8E8h case    6:*/		return 0x8210C8EC;
		  /* 8210C8ECh */ case    7:  		/* bc 4, CR6_EQ, 72 */
		/* 8210C8ECh case    7:*/		if ( !regs.CR[6].eq ) { return 0x8210C934;  }
		/* 8210C8ECh case    7:*/		return 0x8210C8F0;
		  /* 8210C8F0h */ case    8:  		/* lwz R5, <#[R20 + 8]> */
		/* 8210C8F0h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R20 + 0x00000008) );
		/* 8210C8F0h case    8:*/		return 0x8210C8F4;
		  /* 8210C8F4h */ case    9:  		/* lwzx R5, <#[R11 + R5]> */
		/* 8210C8F4h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 8210C8F4h case    9:*/		return 0x8210C8F8;
		  /* 8210C8F8h */ case   10:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 8210C8F8h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 8210C8F8h case   10:*/		return 0x8210C8FC;
		  /* 8210C8FCh */ case   11:  		/* lwzx R10, <#[R5 + R10]> */
		/* 8210C8FCh case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + regs.R10 + 0x00000000) );
		/* 8210C8FCh case   11:*/		return 0x8210C900;
		  /* 8210C900h */ case   12:  		/* lwz R10, <#[R10 + 96]> */
		/* 8210C900h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000060) );
		/* 8210C900h case   12:*/		return 0x8210C904;
		  /* 8210C904h */ case   13:  		/* stw R10, <#[R9 + 96]> */
		/* 8210C904h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000060) );
		/* 8210C904h case   13:*/		return 0x8210C908;
		  /* 8210C908h */ case   14:  		/* lwz R10, <#[R23 + 20]> */
		/* 8210C908h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000014) );
		/* 8210C908h case   14:*/		return 0x8210C90C;
		  /* 8210C90Ch */ case   15:  		/* lwz R5, <#[R20 + 16]> */
		/* 8210C90Ch case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R20 + 0x00000010) );
		/* 8210C90Ch case   15:*/		return 0x8210C910;
		  /* 8210C910h */ case   16:  		/* lwz R9, <#[R20 + 8]> */
		/* 8210C910h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R20 + 0x00000008) );
		/* 8210C910h case   16:*/		return 0x8210C914;
		  /* 8210C914h */ case   17:  		/* lwzx R5, <#[R11 + R5]> */
		/* 8210C914h case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 8210C914h case   17:*/		return 0x8210C918;
		  /* 8210C918h */ case   18:  		/* lwzx R9, <#[R11 + R9]> */
		/* 8210C918h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210C918h case   18:*/		return 0x8210C91C;
		  /* 8210C91Ch */ case   19:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210C91Ch case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210C91Ch case   19:*/		return 0x8210C920;
		  /* 8210C920h */ case   20:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 8210C920h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 8210C920h case   20:*/		return 0x8210C924;
		  /* 8210C924h */ case   21:  		/* lwzx R9, <#[R9 + R10]> */
		/* 8210C924h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210C924h case   21:*/		return 0x8210C928;
		  /* 8210C928h */ case   22:  		/* lwz R9, <#[R9 + 100]> */
		/* 8210C928h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000064) );
		/* 8210C928h case   22:*/		return 0x8210C92C;
		  /* 8210C92Ch */ case   23:  		/* lwzx R10, <#[R5 + R10]> */
		/* 8210C92Ch case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + regs.R10 + 0x00000000) );
		/* 8210C92Ch case   23:*/		return 0x8210C930;
		  /* 8210C930h */ case   24:  		/* stw R9, <#[R10 + 100]> */
		/* 8210C930h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000064) );
		/* 8210C930h case   24:*/		return 0x8210C934;
	}
	return 0x8210C934;
} // Block from 8210C8D0h-8210C934h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8210C934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C934);
		  /* 8210C934h */ case    0:  		/* lwz R10, <#[R20 + 12]> */
		/* 8210C934h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x0000000C) );
		/* 8210C934h case    0:*/		return 0x8210C938;
		  /* 8210C938h */ case    1:  		/* addi R6, R6, 1 */
		/* 8210C938h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8210C938h case    1:*/		return 0x8210C93C;
		  /* 8210C93Ch */ case    2:  		/* addi R8, R8, 4 */
		/* 8210C93Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 8210C93Ch case    2:*/		return 0x8210C940;
		  /* 8210C940h */ case    3:  		/* cmplw CR6, R6, R10 */
		/* 8210C940h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 8210C940h case    3:*/		return 0x8210C944;
		  /* 8210C944h */ case    4:  		/* bc 12, CR6_LT, -168 */
		/* 8210C944h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210C89C;  }
		/* 8210C944h case    4:*/		return 0x8210C948;
		  /* 8210C948h */ case    5:  		/* cmplwi CR6, R7, 0 */
		/* 8210C948h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8210C948h case    5:*/		return 0x8210C94C;
		  /* 8210C94Ch */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 8210C94Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x8210C95C;  }
		/* 8210C94Ch case    6:*/		return 0x8210C950;
		  /* 8210C950h */ case    7:  		/* rlwinm R11, R7, 0, 12, 31 */
		/* 8210C950h case    7:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R7);
		/* 8210C950h case    7:*/		return 0x8210C954;
		  /* 8210C954h */ case    8:  		/* oris R11, R11, 4096 */
		/* 8210C954h case    8:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 8210C954h case    8:*/		return 0x8210C958;
		  /* 8210C958h */ case    9:  		/* b 8 */
		/* 8210C958h case    9:*/		return 0x8210C960;
		/* 8210C958h case    9:*/		return 0x8210C95C;
	}
	return 0x8210C95C;
} // Block from 8210C934h-8210C95Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8210C95Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C95C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C95C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C95C);
		  /* 8210C95Ch */ case    0:  		/* mr R11, R15 */
		/* 8210C95Ch case    0:*/		regs.R11 = regs.R15;
		/* 8210C95Ch case    0:*/		return 0x8210C960;
	}
	return 0x8210C960;
} // Block from 8210C95Ch-8210C960h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210C960h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C960);
		  /* 8210C960h */ case    0:  		/* stw R11, <#[R20]> */
		/* 8210C960h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 8210C960h case    0:*/		return 0x8210C964;
		  /* 8210C964h */ case    1:  		/* stw R7, <#[R20 + 4]> */
		/* 8210C964h case    1:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R20 + 0x00000004) );
		/* 8210C964h case    1:*/		return 0x8210C968;
		  /* 8210C968h */ case    2:  		/* stw R7, <#[R20 + 12]> */
		/* 8210C968h case    2:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R20 + 0x0000000C) );
		/* 8210C968h case    2:*/		return 0x8210C96C;
	}
	return 0x8210C96C;
} // Block from 8210C960h-8210C96Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210C96Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C96C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C96C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C96C);
		  /* 8210C96Ch */ case    0:  		/* cmplwi CR6, R18, 0 */
		/* 8210C96Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 8210C96Ch case    0:*/		return 0x8210C970;
		  /* 8210C970h */ case    1:  		/* bc 4, CR6_EQ, -3464 */
		/* 8210C970h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210BBE8;  }
		/* 8210C970h case    1:*/		return 0x8210C974;
		  /* 8210C974h */ case    2:  		/* lwz R21, <#[R1 + 84]> */
		/* 8210C974h case    2:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000054) );
		/* 8210C974h case    2:*/		return 0x8210C978;
	}
	return 0x8210C978;
} // Block from 8210C96Ch-8210C978h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210C978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C978);
		  /* 8210C978h */ case    0:  		/* mr R31, R15 */
		/* 8210C978h case    0:*/		regs.R31 = regs.R15;
		/* 8210C978h case    0:*/		return 0x8210C97C;
	}
	return 0x8210C97C;
} // Block from 8210C978h-8210C97Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210C97Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C97C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C97C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C97C);
		  /* 8210C97Ch */ case    0:  		/* lis R4, 9345 */
		/* 8210C97Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210C97Ch case    0:*/		return 0x8210C980;
		  /* 8210C980h */ case    1:  		/* mr R3, R21 */
		/* 8210C980h case    1:*/		regs.R3 = regs.R21;
		/* 8210C980h case    1:*/		return 0x8210C984;
		  /* 8210C984h */ case    2:  		/* bl -542284 */
		/* 8210C984h case    2:*/		regs.LR = 0x8210C988; return 0x82088338;
		/* 8210C984h case    2:*/		return 0x8210C988;
		  /* 8210C988h */ case    3:  		/* mr R3, R31 */
		/* 8210C988h case    3:*/		regs.R3 = regs.R31;
		/* 8210C988h case    3:*/		return 0x8210C98C;
		  /* 8210C98Ch */ case    4:  		/* addi R1, R1, 400 */
		/* 8210C98Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x190);
		/* 8210C98Ch case    4:*/		return 0x8210C990;
		  /* 8210C990h */ case    5:  		/* lfd FR31, <#[R1 - 160]> */
		/* 8210C990h case    5:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8210C990h case    5:*/		return 0x8210C994;
		  /* 8210C994h */ case    6:  		/* b -505636 */
		/* 8210C994h case    6:*/		return 0x82091270;
		/* 8210C994h case    6:*/		return 0x8210C998;
	}
	return 0x8210C998;
} // Block from 8210C97Ch-8210C998h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210C998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C998);
		  /* 8210C998h */ case    0:  		/* lis R31, -32761 */
		/* 8210C998h case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8007);
		/* 8210C998h case    0:*/		return 0x8210C99C;
		  /* 8210C99Ch */ case    1:  		/* lwz R21, <#[R1 + 84]> */
		/* 8210C99Ch case    1:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000054) );
		/* 8210C99Ch case    1:*/		return 0x8210C9A0;
		  /* 8210C9A0h */ case    2:  		/* ori R31, R31, 14 */
		/* 8210C9A0h case    2:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xE);
		/* 8210C9A0h case    2:*/		return 0x8210C9A4;
		  /* 8210C9A4h */ case    3:  		/* b -40 */
		/* 8210C9A4h case    3:*/		return 0x8210C97C;
		/* 8210C9A4h case    3:*/		return 0x8210C9A8;
	}
	return 0x8210C9A8;
} // Block from 8210C998h-8210C9A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210C9A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C9A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C9A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C9A8);
		  /* 8210C9A8h */ case    0:  		/* mr R3, R30 */
		/* 8210C9A8h case    0:*/		regs.R3 = regs.R30;
		/* 8210C9A8h case    0:*/		return 0x8210C9AC;
		  /* 8210C9ACh */ case    1:  		/* bl 1116692 */
		/* 8210C9ACh case    1:*/		regs.LR = 0x8210C9B0; return 0x8221D3C0;
		/* 8210C9ACh case    1:*/		return 0x8210C9B0;
		  /* 8210C9B0h */ case    2:  		/* mr R3, R30 */
		/* 8210C9B0h case    2:*/		regs.R3 = regs.R30;
		/* 8210C9B0h case    2:*/		return 0x8210C9B4;
		  /* 8210C9B4h */ case    3:  		/* bl -66500 */
		/* 8210C9B4h case    3:*/		regs.LR = 0x8210C9B8; return 0x820FC5F0;
		/* 8210C9B4h case    3:*/		return 0x8210C9B8;
		  /* 8210C9B8h */ case    4:  		/* lwz R21, <#[R1 + 84]> */
		/* 8210C9B8h case    4:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000054) );
		/* 8210C9B8h case    4:*/		return 0x8210C9BC;
		  /* 8210C9BCh */ case    5:  		/* b -64 */
		/* 8210C9BCh case    5:*/		return 0x8210C97C;
		/* 8210C9BCh case    5:*/		return 0x8210C9C0;
	}
	return 0x8210C9C0;
} // Block from 8210C9A8h-8210C9C0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210C9C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210C9C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210C9C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210C9C0);
		  /* 8210C9C0h */ case    0:  		/* mfspr R12, LR */
		/* 8210C9C0h case    0:*/		regs.R12 = regs.LR;
		/* 8210C9C0h case    0:*/		return 0x8210C9C4;
		  /* 8210C9C4h */ case    1:  		/* bl -505728 */
		/* 8210C9C4h case    1:*/		regs.LR = 0x8210C9C8; return 0x82091244;
		/* 8210C9C4h case    1:*/		return 0x8210C9C8;
		  /* 8210C9C8h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 8210C9C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 8210C9C8h case    2:*/		return 0x8210C9CC;
		  /* 8210C9CCh */ case    3:  		/* lwz R9, <#[R3 + 8]> */
		/* 8210C9CCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 8210C9CCh case    3:*/		return 0x8210C9D0;
		  /* 8210C9D0h */ case    4:  		/* mr R31, R3 */
		/* 8210C9D0h case    4:*/		regs.R31 = regs.R3;
		/* 8210C9D0h case    4:*/		return 0x8210C9D4;
		  /* 8210C9D4h */ case    5:  		/* mr R23, R4 */
		/* 8210C9D4h case    5:*/		regs.R23 = regs.R4;
		/* 8210C9D4h case    5:*/		return 0x8210C9D8;
		  /* 8210C9D8h */ case    6:  		/* li R24, 0 */
		/* 8210C9D8h case    6:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 8210C9D8h case    6:*/		return 0x8210C9DC;
		  /* 8210C9DCh */ case    7:  		/* li R25, 0 */
		/* 8210C9DCh case    7:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 8210C9DCh case    7:*/		return 0x8210C9E0;
		  /* 8210C9E0h */ case    8:  		/* li R8, 0 */
		/* 8210C9E0h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8210C9E0h case    8:*/		return 0x8210C9E4;
		  /* 8210C9E4h */ case    9:  		/* cmplwi CR6, R9, 0 */
		/* 8210C9E4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8210C9E4h case    9:*/		return 0x8210C9E8;
		  /* 8210C9E8h */ case   10:  		/* bc 12, CR6_EQ, 64 */
		/* 8210C9E8h case   10:*/		if ( regs.CR[6].eq ) { return 0x8210CA28;  }
		/* 8210C9E8h case   10:*/		return 0x8210C9EC;
		  /* 8210C9ECh */ case   11:  		/* lwz R7, <#[R3 + 20]> */
		/* 8210C9ECh case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000014) );
		/* 8210C9ECh case   11:*/		return 0x8210C9F0;
		  /* 8210C9F0h */ case   12:  		/* li R10, 0 */
		/* 8210C9F0h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210C9F0h case   12:*/		return 0x8210C9F4;
		  /* 8210C9F4h */ case   13:  		/* lwz R6, <#[R3 + 136]> */
		/* 8210C9F4h case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000088) );
		/* 8210C9F4h case   13:*/		return 0x8210C9F8;
		  /* 8210C9F8h */ case   14:  		/* lwzx R11, <#[R10 + R7]> */
		/* 8210C9F8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 8210C9F8h case   14:*/		return 0x8210C9FC;
		  /* 8210C9FCh */ case   15:  		/* lwz R5, <#[R11 + 4]> */
		/* 8210C9FCh case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000004) );
		/* 8210C9FCh case   15:*/		return 0x8210CA00;
		  /* 8210CA00h */ case   16:  		/* cmplw CR6, R6, R5 */
		/* 8210CA00h case   16:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R5);
		/* 8210CA00h case   16:*/		return 0x8210CA04;
		  /* 8210CA04h */ case   17:  		/* bc 4, CR6_EQ, 20 */
		/* 8210CA04h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8210CA18;  }
		/* 8210CA04h case   17:*/		return 0x8210CA08;
		  /* 8210CA08h */ case   18:  		/* lwz R11, <#[R11 + 12]> */
		/* 8210CA08h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210CA08h case   18:*/		return 0x8210CA0C;
		  /* 8210CA0Ch */ case   19:  		/* cmplw CR6, R25, R11 */
		/* 8210CA0Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 8210CA0Ch case   19:*/		return 0x8210CA10;
		  /* 8210CA10h */ case   20:  		/* bc 12, CR6_GT, 8 */
		/* 8210CA10h case   20:*/		if ( regs.CR[6].gt ) { return 0x8210CA18;  }
		/* 8210CA10h case   20:*/		return 0x8210CA14;
		  /* 8210CA14h */ case   21:  		/* addi R25, R11, 1 */
		/* 8210CA14h case   21:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R11,0x1);
		/* 8210CA14h case   21:*/		return 0x8210CA18;
	}
	return 0x8210CA18;
} // Block from 8210C9C0h-8210CA18h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8210CA18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CA18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CA18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CA18);
		  /* 8210CA18h */ case    0:  		/* addi R8, R8, 1 */
		/* 8210CA18h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8210CA18h case    0:*/		return 0x8210CA1C;
		  /* 8210CA1Ch */ case    1:  		/* addi R10, R10, 4 */
		/* 8210CA1Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210CA1Ch case    1:*/		return 0x8210CA20;
		  /* 8210CA20h */ case    2:  		/* cmplw CR6, R8, R9 */
		/* 8210CA20h case    2:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8210CA20h case    2:*/		return 0x8210CA24;
		  /* 8210CA24h */ case    3:  		/* bc 12, CR6_LT, -44 */
		/* 8210CA24h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210C9F8;  }
		/* 8210CA24h case    3:*/		return 0x8210CA28;
	}
	return 0x8210CA28;
} // Block from 8210CA18h-8210CA28h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210CA28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CA28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CA28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CA28);
		  /* 8210CA28h */ case    0:  		/* mr R3, R31 */
		/* 8210CA28h case    0:*/		regs.R3 = regs.R31;
		/* 8210CA28h case    0:*/		return 0x8210CA2C;
		  /* 8210CA2Ch */ case    1:  		/* bl -28308 */
		/* 8210CA2Ch case    1:*/		regs.LR = 0x8210CA30; return 0x82105B98;
		/* 8210CA2Ch case    1:*/		return 0x8210CA30;
		  /* 8210CA30h */ case    2:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210CA30h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210CA30h case    2:*/		return 0x8210CA34;
		  /* 8210CA34h */ case    3:  		/* li R26, 0 */
		/* 8210CA34h case    3:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8210CA34h case    3:*/		return 0x8210CA38;
		  /* 8210CA38h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8210CA38h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210CA38h case    4:*/		return 0x8210CA3C;
		  /* 8210CA3Ch */ case    5:  		/* bc 12, CR6_EQ, 308 */
		/* 8210CA3Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x8210CB70;  }
		/* 8210CA3Ch case    5:*/		return 0x8210CA40;
		  /* 8210CA40h */ case    6:  		/* li R27, 0 */
		/* 8210CA40h case    6:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8210CA40h case    6:*/		return 0x8210CA44;
		  /* 8210CA44h */ case    7:  		/* lwz R11, <#[R31 + 24]> */
		/* 8210CA44h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8210CA44h case    7:*/		return 0x8210CA48;
		  /* 8210CA48h */ case    8:  		/* lwzx R30, <#[R27 + R11]> */
		/* 8210CA48h case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + regs.R11 + 0x00000000) );
		/* 8210CA48h case    8:*/		return 0x8210CA4C;
		  /* 8210CA4Ch */ case    9:  		/* lwz R11, <#[R30]> */
		/* 8210CA4Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8210CA4Ch case    9:*/		return 0x8210CA50;
		  /* 8210CA50h */ case   10:  		/* rlwinm. R10, R11, 0, 0, 11 */
		/* 8210CA50h case   10:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R10,regs.R11);
		/* 8210CA50h case   10:*/		return 0x8210CA54;
		  /* 8210CA54h */ case   11:  		/* bc 12, CR0_EQ, 264 */
		/* 8210CA54h case   11:*/		if ( regs.CR[0].eq ) { return 0x8210CB5C;  }
		/* 8210CA54h case   11:*/		return 0x8210CA58;
		  /* 8210CA58h */ case   12:  		/* lwz R10, <#[R30 + 4]> */
		/* 8210CA58h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 8210CA58h case   12:*/		return 0x8210CA5C;
		  /* 8210CA5Ch */ case   13:  		/* rlwinm R11, R11, 0, 12, 31 */
		/* 8210CA5Ch case   13:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R11);
		/* 8210CA5Ch case   13:*/		return 0x8210CA60;
		  /* 8210CA60h */ case   14:  		/* li R9, 0 */
		/* 8210CA60h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8210CA60h case   14:*/		return 0x8210CA64;
		  /* 8210CA64h */ case   15:  		/* divwu. R28, R10, R11 */
		/* 8210CA64h case   15:*/		cpu::op::divwu<1>(regs,&regs.R28,regs.R10,regs.R11);
		/* 8210CA64h case   15:*/		return 0x8210CA68;
		  /* 8210CA68h */ case   16:  		/* twi 6, R11, 0 */
		/* 8210CA68h case   16:*/		cpu::op::tw<6>(regs, 0x8210CA68, regs.R11, 0x00000000);
		/* 8210CA68h case   16:*/		return 0x8210CA6C;
		  /* 8210CA6Ch */ case   17:  		/* stw R9, <#[R30 + 36]> */
		/* 8210CA6Ch case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000024) );
		/* 8210CA6Ch case   17:*/		return 0x8210CA70;
		  /* 8210CA70h */ case   18:  		/* li R29, 0 */
		/* 8210CA70h case   18:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8210CA70h case   18:*/		return 0x8210CA74;
		  /* 8210CA74h */ case   19:  		/* bc 12, CR0_EQ, 232 */
		/* 8210CA74h case   19:*/		if ( regs.CR[0].eq ) { return 0x8210CB5C;  }
		/* 8210CA74h case   19:*/		return 0x8210CA78;
		  /* 8210CA78h */ case   20:  		/* addi R5, R1, 80 */
		/* 8210CA78h case   20:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8210CA78h case   20:*/		return 0x8210CA7C;
		  /* 8210CA7Ch */ case   21:  		/* mr R4, R29 */
		/* 8210CA7Ch case   21:*/		regs.R4 = regs.R29;
		/* 8210CA7Ch case   21:*/		return 0x8210CA80;
		  /* 8210CA80h */ case   22:  		/* mr R3, R30 */
		/* 8210CA80h case   22:*/		regs.R3 = regs.R30;
		/* 8210CA80h case   22:*/		return 0x8210CA84;
		  /* 8210CA84h */ case   23:  		/* bl -68460 */
		/* 8210CA84h case   23:*/		regs.LR = 0x8210CA88; return 0x820FBF18;
		/* 8210CA84h case   23:*/		return 0x8210CA88;
		  /* 8210CA88h */ case   24:  		/* lwz R5, <#[R1 + 80]> */
		/* 8210CA88h case   24:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 8210CA88h case   24:*/		return 0x8210CA8C;
		  /* 8210CA8Ch */ case   25:  		/* lwz R9, <#[R31 + 20]> */
		/* 8210CA8Ch case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 8210CA8Ch case   25:*/		return 0x8210CA90;
		  /* 8210CA90h */ case   26:  		/* lwz R8, <#[R31 + 136]> */
		/* 8210CA90h case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000088) );
		/* 8210CA90h case   26:*/		return 0x8210CA94;
		  /* 8210CA94h */ case   27:  		/* lwz R11, <#[R5]> */
		/* 8210CA94h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8210CA94h case   27:*/		return 0x8210CA98;
		  /* 8210CA98h */ case   28:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210CA98h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210CA98h case   28:*/		return 0x8210CA9C;
		  /* 8210CA9Ch */ case   29:  		/* lwzx R6, <#[R11 + R9]> */
		/* 8210CA9Ch case   29:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210CA9Ch case   29:*/		return 0x8210CAA0;
		  /* 8210CAA0h */ case   30:  		/* lwz R11, <#[R6 + 4]> */
		/* 8210CAA0h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000004) );
		/* 8210CAA0h case   30:*/		return 0x8210CAA4;
		  /* 8210CAA4h */ case   31:  		/* cmplw CR6, R8, R11 */
		/* 8210CAA4h case   31:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8210CAA4h case   31:*/		return 0x8210CAA8;
		  /* 8210CAA8h */ case   32:  		/* bc 4, CR6_EQ, 168 */
		/* 8210CAA8h case   32:*/		if ( !regs.CR[6].eq ) { return 0x8210CB50;  }
		/* 8210CAA8h case   32:*/		return 0x8210CAAC;
		  /* 8210CAACh */ case   33:  		/* li R7, 1 */
		/* 8210CAACh case   33:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8210CAACh case   33:*/		return 0x8210CAB0;
		  /* 8210CAB0h */ case   34:  		/* cmplwi CR6, R3, 1 */
		/* 8210CAB0h case   34:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000001);
		/* 8210CAB0h case   34:*/		return 0x8210CAB4;
		  /* 8210CAB4h */ case   35:  		/* bc 4, CR6_GT, 64 */
		/* 8210CAB4h case   35:*/		if ( !regs.CR[6].gt ) { return 0x8210CAF4;  }
		/* 8210CAB4h case   35:*/		return 0x8210CAB8;
		  /* 8210CAB8h */ case   36:  		/* addi R11, R5, 4 */
		/* 8210CAB8h case   36:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0x4);
		/* 8210CAB8h case   36:*/		return 0x8210CABC;
		  /* 8210CABCh */ case   37:  		/* lwz R10, <#[R11]> */
		/* 8210CABCh case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210CABCh case   37:*/		return 0x8210CAC0;
		  /* 8210CAC0h */ case   38:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210CAC0h case   38:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210CAC0h case   38:*/		return 0x8210CAC4;
		  /* 8210CAC4h */ case   39:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210CAC4h case   39:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210CAC4h case   39:*/		return 0x8210CAC8;
		  /* 8210CAC8h */ case   40:  		/* lwz R4, <#[R10 + 4]> */
		/* 8210CAC8h case   40:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000004) );
		/* 8210CAC8h case   40:*/		return 0x8210CACC;
		  /* 8210CACCh */ case   41:  		/* cmplw CR6, R8, R4 */
		/* 8210CACCh case   41:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R4);
		/* 8210CACCh case   41:*/		return 0x8210CAD0;
		  /* 8210CAD0h */ case   42:  		/* bc 4, CR6_EQ, 20 */
		/* 8210CAD0h case   42:*/		if ( !regs.CR[6].eq ) { return 0x8210CAE4;  }
		/* 8210CAD0h case   42:*/		return 0x8210CAD4;
		  /* 8210CAD4h */ case   43:  		/* lwz R10, <#[R10 + 72]> */
		/* 8210CAD4h case   43:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000048) );
		/* 8210CAD4h case   43:*/		return 0x8210CAD8;
		  /* 8210CAD8h */ case   44:  		/* lwz R4, <#[R6 + 72]> */
		/* 8210CAD8h case   44:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R6 + 0x00000048) );
		/* 8210CAD8h case   44:*/		return 0x8210CADC;
		  /* 8210CADCh */ case   45:  		/* cmplw CR6, R10, R4 */
		/* 8210CADCh case   45:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R4);
		/* 8210CADCh case   45:*/		return 0x8210CAE0;
		  /* 8210CAE0h */ case   46:  		/* bc 4, CR6_EQ, 20 */
		/* 8210CAE0h case   46:*/		if ( !regs.CR[6].eq ) { return 0x8210CAF4;  }
		/* 8210CAE0h case   46:*/		return 0x8210CAE4;
	}
	return 0x8210CAE4;
} // Block from 8210CA28h-8210CAE4h (47 instructions)

//////////////////////////////////////////////////////
// Block at 8210CAE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CAE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CAE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CAE4);
		  /* 8210CAE4h */ case    0:  		/* addi R7, R7, 1 */
		/* 8210CAE4h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8210CAE4h case    0:*/		return 0x8210CAE8;
		  /* 8210CAE8h */ case    1:  		/* addi R11, R11, 4 */
		/* 8210CAE8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210CAE8h case    1:*/		return 0x8210CAEC;
		  /* 8210CAECh */ case    2:  		/* cmplw CR6, R7, R3 */
		/* 8210CAECh case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R3);
		/* 8210CAECh case    2:*/		return 0x8210CAF0;
		  /* 8210CAF0h */ case    3:  		/* bc 12, CR6_LT, -52 */
		/* 8210CAF0h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210CABC;  }
		/* 8210CAF0h case    3:*/		return 0x8210CAF4;
	}
	return 0x8210CAF4;
} // Block from 8210CAE4h-8210CAF4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210CAF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CAF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CAF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CAF4);
		  /* 8210CAF4h */ case    0:  		/* cmplw CR6, R7, R3 */
		/* 8210CAF4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R3);
		/* 8210CAF4h case    0:*/		return 0x8210CAF8;
		  /* 8210CAF8h */ case    1:  		/* bc 12, CR6_EQ, 88 */
		/* 8210CAF8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8210CB50;  }
		/* 8210CAF8h case    1:*/		return 0x8210CAFC;
		  /* 8210CAFCh */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 8210CAFCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8210CAFCh case    2:*/		return 0x8210CB00;
		  /* 8210CB00h */ case    3:  		/* bc 12, CR6_EQ, 80 */
		/* 8210CB00h case    3:*/		if ( regs.CR[6].eq ) { return 0x8210CB50;  }
		/* 8210CB00h case    3:*/		return 0x8210CB04;
		  /* 8210CB04h */ case    4:  		/* li R10, 0 */
		/* 8210CB04h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210CB04h case    4:*/		return 0x8210CB08;
		  /* 8210CB08h */ case    5:  		/* mtspr CTR, R3 */
		/* 8210CB08h case    5:*/		regs.CTR = regs.R3;
		/* 8210CB08h case    5:*/		return 0x8210CB0C;
		  /* 8210CB0Ch */ case    6:  		/* lwzx R11, <#[R10 + R5]> */
		/* 8210CB0Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 8210CB0Ch case    6:*/		return 0x8210CB10;
		  /* 8210CB10h */ case    7:  		/* lwz R9, <#[R31 + 20]> */
		/* 8210CB10h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 8210CB10h case    7:*/		return 0x8210CB14;
		  /* 8210CB14h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210CB14h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210CB14h case    8:*/		return 0x8210CB18;
		  /* 8210CB18h */ case    9:  		/* lwz R8, <#[R31 + 136]> */
		/* 8210CB18h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000088) );
		/* 8210CB18h case    9:*/		return 0x8210CB1C;
		  /* 8210CB1Ch */ case   10:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210CB1Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210CB1Ch case   10:*/		return 0x8210CB20;
		  /* 8210CB20h */ case   11:  		/* lwz R9, <#[R11 + 4]> */
		/* 8210CB20h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8210CB20h case   11:*/		return 0x8210CB24;
		  /* 8210CB24h */ case   12:  		/* cmplw CR6, R8, R9 */
		/* 8210CB24h case   12:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8210CB24h case   12:*/		return 0x8210CB28;
		  /* 8210CB28h */ case   13:  		/* bc 4, CR6_EQ, 32 */
		/* 8210CB28h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8210CB48;  }
		/* 8210CB28h case   13:*/		return 0x8210CB2C;
		  /* 8210CB2Ch */ case   14:  		/* lwz R11, <#[R11 + 72]> */
		/* 8210CB2Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 8210CB2Ch case   14:*/		return 0x8210CB30;
		  /* 8210CB30h */ case   15:  		/* li R9, 1 */
		/* 8210CB30h case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8210CB30h case   15:*/		return 0x8210CB34;
		  /* 8210CB34h */ case   16:  		/* lwz R8, <#[R31 + 24]> */
		/* 8210CB34h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000018) );
		/* 8210CB34h case   16:*/		return 0x8210CB38;
		  /* 8210CB38h */ case   17:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210CB38h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210CB38h case   17:*/		return 0x8210CB3C;
		  /* 8210CB3Ch */ case   18:  		/* lwzx R11, <#[R11 + R8]> */
		/* 8210CB3Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8210CB3Ch case   18:*/		return 0x8210CB40;
		  /* 8210CB40h */ case   19:  		/* stw R9, <#[R11 + 36]> */
		/* 8210CB40h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000024) );
		/* 8210CB40h case   19:*/		return 0x8210CB44;
		  /* 8210CB44h */ case   20:  		/* lwz R5, <#[R1 + 80]> */
		/* 8210CB44h case   20:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 8210CB44h case   20:*/		return 0x8210CB48;
	}
	return 0x8210CB48;
} // Block from 8210CAF4h-8210CB48h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8210CB48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CB48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CB48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CB48);
		  /* 8210CB48h */ case    0:  		/* addi R10, R10, 4 */
		/* 8210CB48h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210CB48h case    0:*/		return 0x8210CB4C;
		  /* 8210CB4Ch */ case    1:  		/* bc 16, CR0_LT, -64 */
		/* 8210CB4Ch case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210CB0C;  }
		/* 8210CB4Ch case    1:*/		return 0x8210CB50;
	}
	return 0x8210CB50;
} // Block from 8210CB48h-8210CB50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210CB50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CB50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CB50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CB50);
		  /* 8210CB50h */ case    0:  		/* addi R29, R29, 1 */
		/* 8210CB50h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8210CB50h case    0:*/		return 0x8210CB54;
		  /* 8210CB54h */ case    1:  		/* cmplw CR6, R29, R28 */
		/* 8210CB54h case    1:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R28);
		/* 8210CB54h case    1:*/		return 0x8210CB58;
		  /* 8210CB58h */ case    2:  		/* bc 12, CR6_LT, -224 */
		/* 8210CB58h case    2:*/		if ( regs.CR[6].lt ) { return 0x8210CA78;  }
		/* 8210CB58h case    2:*/		return 0x8210CB5C;
	}
	return 0x8210CB5C;
} // Block from 8210CB50h-8210CB5Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210CB5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CB5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CB5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CB5C);
		  /* 8210CB5Ch */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210CB5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210CB5Ch case    0:*/		return 0x8210CB60;
		  /* 8210CB60h */ case    1:  		/* addi R26, R26, 1 */
		/* 8210CB60h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 8210CB60h case    1:*/		return 0x8210CB64;
		  /* 8210CB64h */ case    2:  		/* addi R27, R27, 4 */
		/* 8210CB64h case    2:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 8210CB64h case    2:*/		return 0x8210CB68;
		  /* 8210CB68h */ case    3:  		/* cmplw CR6, R26, R11 */
		/* 8210CB68h case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 8210CB68h case    3:*/		return 0x8210CB6C;
		  /* 8210CB6Ch */ case    4:  		/* bc 12, CR6_LT, -296 */
		/* 8210CB6Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x8210CA44;  }
		/* 8210CB6Ch case    4:*/		return 0x8210CB70;
	}
	return 0x8210CB70;
} // Block from 8210CB5Ch-8210CB70h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210CB70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CB70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CB70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CB70);
		  /* 8210CB70h */ case    0:  		/* li R4, 0 */
		/* 8210CB70h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8210CB70h case    0:*/		return 0x8210CB74;
		  /* 8210CB74h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8210CB74h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210CB74h case    1:*/		return 0x8210CB78;
		  /* 8210CB78h */ case    2:  		/* bc 12, CR6_EQ, 392 */
		/* 8210CB78h case    2:*/		if ( regs.CR[6].eq ) { return 0x8210CD00;  }
		/* 8210CB78h case    2:*/		return 0x8210CB7C;
		  /* 8210CB7Ch */ case    3:  		/* li R5, 0 */
		/* 8210CB7Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8210CB7Ch case    3:*/		return 0x8210CB80;
		  /* 8210CB80h */ case    4:  		/* lwz R11, <#[R31 + 24]> */
		/* 8210CB80h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8210CB80h case    4:*/		return 0x8210CB84;
		  /* 8210CB84h */ case    5:  		/* lwzx R9, <#[R5 + R11]> */
		/* 8210CB84h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 8210CB84h case    5:*/		return 0x8210CB88;
		  /* 8210CB88h */ case    6:  		/* lwz R11, <#[R9]> */
		/* 8210CB88h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8210CB88h case    6:*/		return 0x8210CB8C;
		  /* 8210CB8Ch */ case    7:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 8210CB8Ch case    7:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 8210CB8Ch case    7:*/		return 0x8210CB90;
		  /* 8210CB90h */ case    8:  		/* bc 12, CR0_EQ, 348 */
		/* 8210CB90h case    8:*/		if ( regs.CR[0].eq ) { return 0x8210CCEC;  }
		/* 8210CB90h case    8:*/		return 0x8210CB94;
		  /* 8210CB94h */ case    9:  		/* lwz R11, <#[R9 + 36]> */
		/* 8210CB94h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000024) );
		/* 8210CB94h case    9:*/		return 0x8210CB98;
		  /* 8210CB98h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 8210CB98h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210CB98h case   10:*/		return 0x8210CB9C;
		  /* 8210CB9Ch */ case   11:  		/* bc 4, CR6_EQ, 336 */
		/* 8210CB9Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x8210CCEC;  }
		/* 8210CB9Ch case   11:*/		return 0x8210CBA0;
		  /* 8210CBA0h */ case   12:  		/* lwz R7, <#[R9 + 16]> */
		/* 8210CBA0h case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000010) );
		/* 8210CBA0h case   12:*/		return 0x8210CBA4;
		  /* 8210CBA4h */ case   13:  		/* lwz R6, <#[R31 + 20]> */
		/* 8210CBA4h case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000014) );
		/* 8210CBA4h case   13:*/		return 0x8210CBA8;
		  /* 8210CBA8h */ case   14:  		/* lwz R11, <#[R31 + 136]> */
		/* 8210CBA8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000088) );
		/* 8210CBA8h case   14:*/		return 0x8210CBAC;
		  /* 8210CBACh */ case   15:  		/* lwz R10, <#[R7]> */
		/* 8210CBACh case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 8210CBACh case   15:*/		return 0x8210CBB0;
		  /* 8210CBB0h */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210CBB0h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210CBB0h case   16:*/		return 0x8210CBB4;
		  /* 8210CBB4h */ case   17:  		/* lwzx R10, <#[R10 + R6]> */
		/* 8210CBB4h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 8210CBB4h case   17:*/		return 0x8210CBB8;
		  /* 8210CBB8h */ case   18:  		/* lwz R10, <#[R10 + 4]> */
		/* 8210CBB8h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8210CBB8h case   18:*/		return 0x8210CBBC;
		  /* 8210CBBCh */ case   19:  		/* cmplw CR6, R11, R10 */
		/* 8210CBBCh case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210CBBCh case   19:*/		return 0x8210CBC0;
		  /* 8210CBC0h */ case   20:  		/* bc 4, CR6_EQ, 300 */
		/* 8210CBC0h case   20:*/		if ( !regs.CR[6].eq ) { return 0x8210CCEC;  }
		/* 8210CBC0h case   20:*/		return 0x8210CBC4;
		  /* 8210CBC4h */ case   21:  		/* lwz R8, <#[R9 + 12]> */
		/* 8210CBC4h case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x0000000C) );
		/* 8210CBC4h case   21:*/		return 0x8210CBC8;
		  /* 8210CBC8h */ case   22:  		/* cmpwi CR6, R23, 0 */
		/* 8210CBC8h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 8210CBC8h case   22:*/		return 0x8210CBCC;
		  /* 8210CBCCh */ case   23:  		/* bc 12, CR6_EQ, 156 */
		/* 8210CBCCh case   23:*/		if ( regs.CR[6].eq ) { return 0x8210CC68;  }
		/* 8210CBCCh case   23:*/		return 0x8210CBD0;
		  /* 8210CBD0h */ case   24:  		/* li R11, 0 */
		/* 8210CBD0h case   24:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210CBD0h case   24:*/		return 0x8210CBD4;
		  /* 8210CBD4h */ case   25:  		/* cmplwi CR6, R8, 0 */
		/* 8210CBD4h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8210CBD4h case   25:*/		return 0x8210CBD8;
		  /* 8210CBD8h */ case   26:  		/* bc 12, CR6_EQ, 48 */
		/* 8210CBD8h case   26:*/		if ( regs.CR[6].eq ) { return 0x8210CC08;  }
		/* 8210CBD8h case   26:*/		return 0x8210CBDC;
		  /* 8210CBDCh */ case   27:  		/* li R10, 0 */
		/* 8210CBDCh case   27:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210CBDCh case   27:*/		return 0x8210CBE0;
		  /* 8210CBE0h */ case   28:  		/* lwzx R3, <#[R10 + R7]> */
		/* 8210CBE0h case   28:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 8210CBE0h case   28:*/		return 0x8210CBE4;
		  /* 8210CBE4h */ case   29:  		/* rlwinm R3, R3, 2, 0, 29 */
		/* 8210CBE4h case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R3);
		/* 8210CBE4h case   29:*/		return 0x8210CBE8;
		  /* 8210CBE8h */ case   30:  		/* lwzx R3, <#[R3 + R6]> */
		/* 8210CBE8h case   30:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + regs.R6 + 0x00000000) );
		/* 8210CBE8h case   30:*/		return 0x8210CBEC;
		  /* 8210CBECh */ case   31:  		/* lwz R3, <#[R3 + 16]> */
		/* 8210CBECh case   31:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000010) );
		/* 8210CBECh case   31:*/		return 0x8210CBF0;
		  /* 8210CBF0h */ case   32:  		/* cmplw CR6, R11, R3 */
		/* 8210CBF0h case   32:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R3);
		/* 8210CBF0h case   32:*/		return 0x8210CBF4;
		  /* 8210CBF4h */ case   33:  		/* bc 4, CR6_EQ, 20 */
		/* 8210CBF4h case   33:*/		if ( !regs.CR[6].eq ) { return 0x8210CC08;  }
		/* 8210CBF4h case   33:*/		return 0x8210CBF8;
		  /* 8210CBF8h */ case   34:  		/* addi R11, R11, 1 */
		/* 8210CBF8h case   34:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210CBF8h case   34:*/		return 0x8210CBFC;
		  /* 8210CBFCh */ case   35:  		/* addi R10, R10, 4 */
		/* 8210CBFCh case   35:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210CBFCh case   35:*/		return 0x8210CC00;
		  /* 8210CC00h */ case   36:  		/* cmplw CR6, R11, R8 */
		/* 8210CC00h case   36:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8210CC00h case   36:*/		return 0x8210CC04;
		  /* 8210CC04h */ case   37:  		/* bc 12, CR6_LT, -36 */
		/* 8210CC04h case   37:*/		if ( regs.CR[6].lt ) { return 0x8210CBE0;  }
		/* 8210CC04h case   37:*/		return 0x8210CC08;
	}
	return 0x8210CC08;
} // Block from 8210CB70h-8210CC08h (38 instructions)

//////////////////////////////////////////////////////
// Block at 8210CC08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CC08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CC08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CC08);
		  /* 8210CC08h */ case    0:  		/* cmplw CR6, R11, R8 */
		/* 8210CC08h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8210CC08h case    0:*/		return 0x8210CC0C;
		  /* 8210CC0Ch */ case    1:  		/* bc 12, CR6_EQ, 224 */
		/* 8210CC0Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8210CCEC;  }
		/* 8210CC0Ch case    1:*/		return 0x8210CC10;
		  /* 8210CC10h */ case    2:  		/* li R10, 0 */
		/* 8210CC10h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210CC10h case    2:*/		return 0x8210CC14;
		  /* 8210CC14h */ case    3:  		/* cmplwi CR6, R8, 0 */
		/* 8210CC14h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8210CC14h case    3:*/		return 0x8210CC18;
		  /* 8210CC18h */ case    4:  		/* bc 12, CR6_EQ, 204 */
		/* 8210CC18h case    4:*/		if ( regs.CR[6].eq ) { return 0x8210CCE4;  }
		/* 8210CC18h case    4:*/		return 0x8210CC1C;
		  /* 8210CC1Ch */ case    5:  		/* li R11, 0 */
		/* 8210CC1Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210CC1Ch case    5:*/		return 0x8210CC20;
		  /* 8210CC20h */ case    6:  		/* lwz R8, <#[R9 + 16]> */
		/* 8210CC20h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000010) );
		/* 8210CC20h case    6:*/		return 0x8210CC24;
		  /* 8210CC24h */ case    7:  		/* lwz R7, <#[R31 + 20]> */
		/* 8210CC24h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000014) );
		/* 8210CC24h case    7:*/		return 0x8210CC28;
		  /* 8210CC28h */ case    8:  		/* lwzx R8, <#[R11 + R8]> */
		/* 8210CC28h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8210CC28h case    8:*/		return 0x8210CC2C;
		  /* 8210CC2Ch */ case    9:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8210CC2Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8210CC2Ch case    9:*/		return 0x8210CC30;
		  /* 8210CC30h */ case   10:  		/* lwzx R8, <#[R8 + R7]> */
		/* 8210CC30h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 8210CC30h case   10:*/		return 0x8210CC34;
		  /* 8210CC34h */ case   11:  		/* stw R25, <#[R8 + 12]> */
		/* 8210CC34h case   11:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R8 + 0x0000000C) );
		/* 8210CC34h case   11:*/		return 0x8210CC38;
		  /* 8210CC38h */ case   12:  		/* lwz R7, <#[R31 + 20]> */
		/* 8210CC38h case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000014) );
		/* 8210CC38h case   12:*/		return 0x8210CC3C;
		  /* 8210CC3Ch */ case   13:  		/* lwz R8, <#[R9 + 16]> */
		/* 8210CC3Ch case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000010) );
		/* 8210CC3Ch case   13:*/		return 0x8210CC40;
		  /* 8210CC40h */ case   14:  		/* lwzx R8, <#[R11 + R8]> */
		/* 8210CC40h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8210CC40h case   14:*/		return 0x8210CC44;
		  /* 8210CC44h */ case   15:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8210CC44h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8210CC44h case   15:*/		return 0x8210CC48;
		  /* 8210CC48h */ case   16:  		/* lwzx R8, <#[R8 + R7]> */
		/* 8210CC48h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 8210CC48h case   16:*/		return 0x8210CC4C;
		  /* 8210CC4Ch */ case   17:  		/* addi R11, R11, 4 */
		/* 8210CC4Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210CC4Ch case   17:*/		return 0x8210CC50;
		  /* 8210CC50h */ case   18:  		/* stw R10, <#[R8 + 16]> */
		/* 8210CC50h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000010) );
		/* 8210CC50h case   18:*/		return 0x8210CC54;
		  /* 8210CC54h */ case   19:  		/* addi R10, R10, 1 */
		/* 8210CC54h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210CC54h case   19:*/		return 0x8210CC58;
		  /* 8210CC58h */ case   20:  		/* lwz R8, <#[R9 + 12]> */
		/* 8210CC58h case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x0000000C) );
		/* 8210CC58h case   20:*/		return 0x8210CC5C;
		  /* 8210CC5Ch */ case   21:  		/* cmplw CR6, R10, R8 */
		/* 8210CC5Ch case   21:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8210CC5Ch case   21:*/		return 0x8210CC60;
		  /* 8210CC60h */ case   22:  		/* bc 12, CR6_LT, -64 */
		/* 8210CC60h case   22:*/		if ( regs.CR[6].lt ) { return 0x8210CC20;  }
		/* 8210CC60h case   22:*/		return 0x8210CC64;
		  /* 8210CC64h */ case   23:  		/* b 128 */
		/* 8210CC64h case   23:*/		return 0x8210CCE4;
		/* 8210CC64h case   23:*/		return 0x8210CC68;
	}
	return 0x8210CC68;
} // Block from 8210CC08h-8210CC68h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8210CC68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CC68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CC68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CC68);
		  /* 8210CC68h */ case    0:  		/* li R10, 0 */
		/* 8210CC68h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210CC68h case    0:*/		return 0x8210CC6C;
		  /* 8210CC6Ch */ case    1:  		/* cmplwi CR6, R8, 0 */
		/* 8210CC6Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8210CC6Ch case    1:*/		return 0x8210CC70;
		  /* 8210CC70h */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 8210CC70h case    2:*/		if ( regs.CR[6].eq ) { return 0x8210CCA0;  }
		/* 8210CC70h case    2:*/		return 0x8210CC74;
		  /* 8210CC74h */ case    3:  		/* li R11, 0 */
		/* 8210CC74h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210CC74h case    3:*/		return 0x8210CC78;
		  /* 8210CC78h */ case    4:  		/* lwzx R3, <#[R11 + R7]> */
		/* 8210CC78h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 8210CC78h case    4:*/		return 0x8210CC7C;
		  /* 8210CC7Ch */ case    5:  		/* rlwinm R3, R3, 2, 0, 29 */
		/* 8210CC7Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R3);
		/* 8210CC7Ch case    5:*/		return 0x8210CC80;
		  /* 8210CC80h */ case    6:  		/* lwzx R3, <#[R3 + R6]> */
		/* 8210CC80h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + regs.R6 + 0x00000000) );
		/* 8210CC80h case    6:*/		return 0x8210CC84;
		  /* 8210CC84h */ case    7:  		/* lwz R3, <#[R3 + 16]> */
		/* 8210CC84h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000010) );
		/* 8210CC84h case    7:*/		return 0x8210CC88;
		  /* 8210CC88h */ case    8:  		/* cmplwi CR6, R3, 0 */
		/* 8210CC88h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8210CC88h case    8:*/		return 0x8210CC8C;
		  /* 8210CC8Ch */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 8210CC8Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x8210CCA0;  }
		/* 8210CC8Ch case    9:*/		return 0x8210CC90;
		  /* 8210CC90h */ case   10:  		/* addi R10, R10, 1 */
		/* 8210CC90h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210CC90h case   10:*/		return 0x8210CC94;
		  /* 8210CC94h */ case   11:  		/* addi R11, R11, 4 */
		/* 8210CC94h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210CC94h case   11:*/		return 0x8210CC98;
		  /* 8210CC98h */ case   12:  		/* cmplw CR6, R10, R8 */
		/* 8210CC98h case   12:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8210CC98h case   12:*/		return 0x8210CC9C;
		  /* 8210CC9Ch */ case   13:  		/* bc 12, CR6_LT, -36 */
		/* 8210CC9Ch case   13:*/		if ( regs.CR[6].lt ) { return 0x8210CC78;  }
		/* 8210CC9Ch case   13:*/		return 0x8210CCA0;
	}
	return 0x8210CCA0;
} // Block from 8210CC68h-8210CCA0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8210CCA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CCA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CCA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CCA0);
		  /* 8210CCA0h */ case    0:  		/* cmplw CR6, R10, R8 */
		/* 8210CCA0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8210CCA0h case    0:*/		return 0x8210CCA4;
		  /* 8210CCA4h */ case    1:  		/* bc 12, CR6_LT, 72 */
		/* 8210CCA4h case    1:*/		if ( regs.CR[6].lt ) { return 0x8210CCEC;  }
		/* 8210CCA4h case    1:*/		return 0x8210CCA8;
		  /* 8210CCA8h */ case    2:  		/* li R10, 0 */
		/* 8210CCA8h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210CCA8h case    2:*/		return 0x8210CCAC;
		  /* 8210CCACh */ case    3:  		/* cmplwi CR6, R8, 0 */
		/* 8210CCACh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8210CCACh case    3:*/		return 0x8210CCB0;
		  /* 8210CCB0h */ case    4:  		/* bc 12, CR6_EQ, 52 */
		/* 8210CCB0h case    4:*/		if ( regs.CR[6].eq ) { return 0x8210CCE4;  }
		/* 8210CCB0h case    4:*/		return 0x8210CCB4;
		  /* 8210CCB4h */ case    5:  		/* li R11, 0 */
		/* 8210CCB4h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210CCB4h case    5:*/		return 0x8210CCB8;
		  /* 8210CCB8h */ case    6:  		/* lwz R8, <#[R9 + 16]> */
		/* 8210CCB8h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000010) );
		/* 8210CCB8h case    6:*/		return 0x8210CCBC;
		  /* 8210CCBCh */ case    7:  		/* addi R10, R10, 1 */
		/* 8210CCBCh case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210CCBCh case    7:*/		return 0x8210CCC0;
		  /* 8210CCC0h */ case    8:  		/* lwz R7, <#[R31 + 20]> */
		/* 8210CCC0h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000014) );
		/* 8210CCC0h case    8:*/		return 0x8210CCC4;
		  /* 8210CCC4h */ case    9:  		/* lwzx R8, <#[R11 + R8]> */
		/* 8210CCC4h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8210CCC4h case    9:*/		return 0x8210CCC8;
		  /* 8210CCC8h */ case   10:  		/* addi R11, R11, 4 */
		/* 8210CCC8h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210CCC8h case   10:*/		return 0x8210CCCC;
		  /* 8210CCCCh */ case   11:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8210CCCCh case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8210CCCCh case   11:*/		return 0x8210CCD0;
		  /* 8210CCD0h */ case   12:  		/* lwzx R8, <#[R8 + R7]> */
		/* 8210CCD0h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 8210CCD0h case   12:*/		return 0x8210CCD4;
		  /* 8210CCD4h */ case   13:  		/* stw R25, <#[R8 + 12]> */
		/* 8210CCD4h case   13:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R8 + 0x0000000C) );
		/* 8210CCD4h case   13:*/		return 0x8210CCD8;
		  /* 8210CCD8h */ case   14:  		/* lwz R8, <#[R9 + 12]> */
		/* 8210CCD8h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x0000000C) );
		/* 8210CCD8h case   14:*/		return 0x8210CCDC;
		  /* 8210CCDCh */ case   15:  		/* cmplw CR6, R10, R8 */
		/* 8210CCDCh case   15:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8210CCDCh case   15:*/		return 0x8210CCE0;
		  /* 8210CCE0h */ case   16:  		/* bc 12, CR6_LT, -40 */
		/* 8210CCE0h case   16:*/		if ( regs.CR[6].lt ) { return 0x8210CCB8;  }
		/* 8210CCE0h case   16:*/		return 0x8210CCE4;
	}
	return 0x8210CCE4;
} // Block from 8210CCA0h-8210CCE4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8210CCE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CCE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CCE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CCE4);
		  /* 8210CCE4h */ case    0:  		/* addi R25, R25, 1 */
		/* 8210CCE4h case    0:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 8210CCE4h case    0:*/		return 0x8210CCE8;
		  /* 8210CCE8h */ case    1:  		/* li R24, 1 */
		/* 8210CCE8h case    1:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 8210CCE8h case    1:*/		return 0x8210CCEC;
	}
	return 0x8210CCEC;
} // Block from 8210CCE4h-8210CCECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210CCECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CCEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CCEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CCEC);
		  /* 8210CCECh */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210CCECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210CCECh case    0:*/		return 0x8210CCF0;
		  /* 8210CCF0h */ case    1:  		/* addi R4, R4, 1 */
		/* 8210CCF0h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 8210CCF0h case    1:*/		return 0x8210CCF4;
		  /* 8210CCF4h */ case    2:  		/* addi R5, R5, 4 */
		/* 8210CCF4h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 8210CCF4h case    2:*/		return 0x8210CCF8;
		  /* 8210CCF8h */ case    3:  		/* cmplw CR6, R4, R11 */
		/* 8210CCF8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 8210CCF8h case    3:*/		return 0x8210CCFC;
		  /* 8210CCFCh */ case    4:  		/* bc 12, CR6_LT, -380 */
		/* 8210CCFCh case    4:*/		if ( regs.CR[6].lt ) { return 0x8210CB80;  }
		/* 8210CCFCh case    4:*/		return 0x8210CD00;
	}
	return 0x8210CD00;
} // Block from 8210CCECh-8210CD00h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210CD00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CD00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CD00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CD00);
		  /* 8210CD00h */ case    0:  		/* cntlzw R11, R24 */
		/* 8210CD00h case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R24);
		/* 8210CD00h case    0:*/		return 0x8210CD04;
		  /* 8210CD04h */ case    1:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 8210CD04h case    1:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 8210CD04h case    1:*/		return 0x8210CD08;
		  /* 8210CD08h */ case    2:  		/* addi R1, R1, 176 */
		/* 8210CD08h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 8210CD08h case    2:*/		return 0x8210CD0C;
		  /* 8210CD0Ch */ case    3:  		/* b -506488 */
		/* 8210CD0Ch case    3:*/		return 0x82091294;
		/* 8210CD0Ch case    3:*/		return 0x8210CD10;
	}
	return 0x8210CD10;
} // Block from 8210CD00h-8210CD10h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210CD10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CD10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CD10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CD10);
		  /* 8210CD10h */ case    0:  		/* mfspr R12, LR */
		/* 8210CD10h case    0:*/		regs.R12 = regs.LR;
		/* 8210CD10h case    0:*/		return 0x8210CD14;
		  /* 8210CD14h */ case    1:  		/* bl -506596 */
		/* 8210CD14h case    1:*/		regs.LR = 0x8210CD18; return 0x82091230;
		/* 8210CD14h case    1:*/		return 0x8210CD18;
		  /* 8210CD18h */ case    2:  		/* stwu R1, <#[R1 - 272]> */
		/* 8210CD18h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEF0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEF0);
		/* 8210CD18h case    2:*/		return 0x8210CD1C;
		  /* 8210CD1Ch */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 8210CD1Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8210CD1Ch case    3:*/		return 0x8210CD20;
		  /* 8210CD20h */ case    4:  		/* li R21, 0 */
		/* 8210CD20h case    4:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 8210CD20h case    4:*/		return 0x8210CD24;
		  /* 8210CD24h */ case    5:  		/* mr R28, R3 */
		/* 8210CD24h case    5:*/		regs.R28 = regs.R3;
		/* 8210CD24h case    5:*/		return 0x8210CD28;
		  /* 8210CD28h */ case    6:  		/* mr R29, R21 */
		/* 8210CD28h case    6:*/		regs.R29 = regs.R21;
		/* 8210CD28h case    6:*/		return 0x8210CD2C;
		  /* 8210CD2Ch */ case    7:  		/* mr R7, R21 */
		/* 8210CD2Ch case    7:*/		regs.R7 = regs.R21;
		/* 8210CD2Ch case    7:*/		return 0x8210CD30;
		  /* 8210CD30h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 8210CD30h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210CD30h case    8:*/		return 0x8210CD34;
		  /* 8210CD34h */ case    9:  		/* bc 4, CR6_GT, 72 */
		/* 8210CD34h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8210CD7C;  }
		/* 8210CD34h case    9:*/		return 0x8210CD38;
		  /* 8210CD38h */ case   10:  		/* lwz R8, <#[R3 + 16]> */
		/* 8210CD38h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000010) );
		/* 8210CD38h case   10:*/		return 0x8210CD3C;
		  /* 8210CD3Ch */ case   11:  		/* mr R11, R21 */
		/* 8210CD3Ch case   11:*/		regs.R11 = regs.R21;
		/* 8210CD3Ch case   11:*/		return 0x8210CD40;
		  /* 8210CD40h */ case   12:  		/* lwz R6, <#[R3 + 4]> */
		/* 8210CD40h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000004) );
		/* 8210CD40h case   12:*/		return 0x8210CD44;
		  /* 8210CD44h */ case   13:  		/* lwzx R9, <#[R8 + R11]> */
		/* 8210CD44h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8210CD44h case   13:*/		return 0x8210CD48;
		  /* 8210CD48h */ case   14:  		/* lwz R10, <#[R9 + 4]> */
		/* 8210CD48h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 8210CD48h case   14:*/		return 0x8210CD4C;
		  /* 8210CD4Ch */ case   15:  		/* rlwinm. R5, R10, 0, 23, 23 */
		/* 8210CD4Ch case   15:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R5,regs.R10);
		/* 8210CD4Ch case   15:*/		return 0x8210CD50;
		  /* 8210CD50h */ case   16:  		/* bc 12, CR0_EQ, 28 */
		/* 8210CD50h case   16:*/		if ( regs.CR[0].eq ) { return 0x8210CD6C;  }
		/* 8210CD50h case   16:*/		return 0x8210CD54;
		  /* 8210CD54h */ case   17:  		/* rlwinm. R5, R10, 0, 21, 21 */
		/* 8210CD54h case   17:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R5,regs.R10);
		/* 8210CD54h case   17:*/		return 0x8210CD58;
		  /* 8210CD58h */ case   18:  		/* bc 4, CR0_EQ, 12 */
		/* 8210CD58h case   18:*/		if ( !regs.CR[0].eq ) { return 0x8210CD64;  }
		/* 8210CD58h case   18:*/		return 0x8210CD5C;
		  /* 8210CD5Ch */ case   19:  		/* rlwinm. R10, R10, 0, 20, 20 */
		/* 8210CD5Ch case   19:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R10,regs.R10);
		/* 8210CD5Ch case   19:*/		return 0x8210CD60;
		  /* 8210CD60h */ case   20:  		/* bc 12, CR0_EQ, 12 */
		/* 8210CD60h case   20:*/		if ( regs.CR[0].eq ) { return 0x8210CD6C;  }
		/* 8210CD60h case   20:*/		return 0x8210CD64;
	}
	return 0x8210CD64;
} // Block from 8210CD10h-8210CD64h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8210CD64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CD64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CD64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CD64);
		  /* 8210CD64h */ case    0:  		/* lwz R10, <#[R9 + 8]> */
		/* 8210CD64h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000008) );
		/* 8210CD64h case    0:*/		return 0x8210CD68;
		  /* 8210CD68h */ case    1:  		/* add R29, R10, R29 */
		/* 8210CD68h case    1:*/		cpu::op::add<0>(regs,&regs.R29,regs.R10,regs.R29);
		/* 8210CD68h case    1:*/		return 0x8210CD6C;
	}
	return 0x8210CD6C;
} // Block from 8210CD64h-8210CD6Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210CD6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CD6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CD6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CD6C);
		  /* 8210CD6Ch */ case    0:  		/* addi R7, R7, 1 */
		/* 8210CD6Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8210CD6Ch case    0:*/		return 0x8210CD70;
		  /* 8210CD70h */ case    1:  		/* addi R11, R11, 4 */
		/* 8210CD70h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210CD70h case    1:*/		return 0x8210CD74;
		  /* 8210CD74h */ case    2:  		/* cmplw CR6, R7, R6 */
		/* 8210CD74h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 8210CD74h case    2:*/		return 0x8210CD78;
		  /* 8210CD78h */ case    3:  		/* bc 12, CR6_LT, -52 */
		/* 8210CD78h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210CD44;  }
		/* 8210CD78h case    3:*/		return 0x8210CD7C;
	}
	return 0x8210CD7C;
} // Block from 8210CD6Ch-8210CD7Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210CD7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CD7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CD7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CD7C);
		  /* 8210CD7Ch */ case    0:  		/* lwz R11, <#[R28 + 12]> */
		/* 8210CD7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000000C) );
		/* 8210CD7Ch case    0:*/		return 0x8210CD80;
		  /* 8210CD80h */ case    1:  		/* lis R4, 9345 */
		/* 8210CD80h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210CD80h case    1:*/		return 0x8210CD84;
		  /* 8210CD84h */ case    2:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 8210CD84h case    2:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 8210CD84h case    2:*/		return 0x8210CD88;
		  /* 8210CD88h */ case    3:  		/* add R11, R11, R29 */
		/* 8210CD88h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8210CD88h case    3:*/		return 0x8210CD8C;
		  /* 8210CD8Ch */ case    4:  		/* rlwinm R31, R11, 4, 0, 27 */
		/* 8210CD8Ch case    4:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R31,regs.R11);
		/* 8210CD8Ch case    4:*/		return 0x8210CD90;
		  /* 8210CD90h */ case    5:  		/* mr R3, R31 */
		/* 8210CD90h case    5:*/		regs.R3 = regs.R31;
		/* 8210CD90h case    5:*/		return 0x8210CD94;
		  /* 8210CD94h */ case    6:  		/* bl -543636 */
		/* 8210CD94h case    6:*/		regs.LR = 0x8210CD98; return 0x82088200;
		/* 8210CD94h case    6:*/		return 0x8210CD98;
		  /* 8210CD98h */ case    7:  		/* or. R20, R3, R3 */
		/* 8210CD98h case    7:*/		cpu::op::or<1>(regs,&regs.R20,regs.R3,regs.R3);
		/* 8210CD98h case    7:*/		return 0x8210CD9C;
		  /* 8210CD9Ch */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 8210CD9Ch case    8:*/		if ( !regs.CR[0].eq ) { return 0x8210CDAC;  }
		/* 8210CD9Ch case    8:*/		return 0x8210CDA0;
		  /* 8210CDA0h */ case    9:  		/* lis R3, -32761 */
		/* 8210CDA0h case    9:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 8210CDA0h case    9:*/		return 0x8210CDA4;
		  /* 8210CDA4h */ case   10:  		/* ori R3, R3, 14 */
		/* 8210CDA4h case   10:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 8210CDA4h case   10:*/		return 0x8210CDA8;
		  /* 8210CDA8h */ case   11:  		/* b 1988 */
		/* 8210CDA8h case   11:*/		return 0x8210D56C;
		/* 8210CDA8h case   11:*/		return 0x8210CDAC;
	}
	return 0x8210CDAC;
} // Block from 8210CD7Ch-8210CDACh (12 instructions)

//////////////////////////////////////////////////////
// Block at 8210CDACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CDAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CDAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CDAC);
		  /* 8210CDACh */ case    0:  		/* mr R5, R31 */
		/* 8210CDACh case    0:*/		regs.R5 = regs.R31;
		/* 8210CDACh case    0:*/		return 0x8210CDB0;
		  /* 8210CDB0h */ case    1:  		/* li R4, 255 */
		/* 8210CDB0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xFF);
		/* 8210CDB0h case    1:*/		return 0x8210CDB4;
		  /* 8210CDB4h */ case    2:  		/* mr R3, R20 */
		/* 8210CDB4h case    2:*/		regs.R3 = regs.R20;
		/* 8210CDB4h case    2:*/		return 0x8210CDB8;
		  /* 8210CDB8h */ case    3:  		/* bl -506488 */
		/* 8210CDB8h case    3:*/		regs.LR = 0x8210CDBC; return 0x82091340;
		/* 8210CDB8h case    3:*/		return 0x8210CDBC;
		  /* 8210CDBCh */ case    4:  		/* lwz R10, <#[R28 + 8]> */
		/* 8210CDBCh case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 8210CDBCh case    4:*/		return 0x8210CDC0;
		  /* 8210CDC0h */ case    5:  		/* mr R18, R21 */
		/* 8210CDC0h case    5:*/		regs.R18 = regs.R21;
		/* 8210CDC0h case    5:*/		return 0x8210CDC4;
		  /* 8210CDC4h */ case    6:  		/* mr R11, R21 */
		/* 8210CDC4h case    6:*/		regs.R11 = regs.R21;
		/* 8210CDC4h case    6:*/		return 0x8210CDC8;
		  /* 8210CDC8h */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 8210CDC8h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8210CDC8h case    7:*/		return 0x8210CDCC;
		  /* 8210CDCCh */ case    8:  		/* bc 4, CR6_GT, 40 */
		/* 8210CDCCh case    8:*/		if ( !regs.CR[6].gt ) { return 0x8210CDF4;  }
		/* 8210CDCCh case    8:*/		return 0x8210CDD0;
		  /* 8210CDD0h */ case    9:  		/* mr R10, R21 */
		/* 8210CDD0h case    9:*/		regs.R10 = regs.R21;
		/* 8210CDD0h case    9:*/		return 0x8210CDD4;
		  /* 8210CDD4h */ case   10:  		/* lwz R9, <#[R28 + 20]> */
		/* 8210CDD4h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000014) );
		/* 8210CDD4h case   10:*/		return 0x8210CDD8;
		  /* 8210CDD8h */ case   11:  		/* lwzx R9, <#[R10 + R9]> */
		/* 8210CDD8h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210CDD8h case   11:*/		return 0x8210CDDC;
		  /* 8210CDDCh */ case   12:  		/* addi R10, R10, 4 */
		/* 8210CDDCh case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210CDDCh case   12:*/		return 0x8210CDE0;
		  /* 8210CDE0h */ case   13:  		/* stw R11, <#[R9 + 48]> */
		/* 8210CDE0h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000030) );
		/* 8210CDE0h case   13:*/		return 0x8210CDE4;
		  /* 8210CDE4h */ case   14:  		/* addi R11, R11, 1 */
		/* 8210CDE4h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210CDE4h case   14:*/		return 0x8210CDE8;
		  /* 8210CDE8h */ case   15:  		/* lwz R9, <#[R28 + 8]> */
		/* 8210CDE8h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 8210CDE8h case   15:*/		return 0x8210CDEC;
		  /* 8210CDECh */ case   16:  		/* cmplw CR6, R11, R9 */
		/* 8210CDECh case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210CDECh case   16:*/		return 0x8210CDF0;
		  /* 8210CDF0h */ case   17:  		/* bc 12, CR6_LT, -28 */
		/* 8210CDF0h case   17:*/		if ( regs.CR[6].lt ) { return 0x8210CDD4;  }
		/* 8210CDF0h case   17:*/		return 0x8210CDF4;
	}
	return 0x8210CDF4;
} // Block from 8210CDACh-8210CDF4h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8210CDF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CDF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CDF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CDF4);
		  /* 8210CDF4h */ case    0:  		/* lwz R11, <#[R28 + 4]> */
		/* 8210CDF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8210CDF4h case    0:*/		return 0x8210CDF8;
		  /* 8210CDF8h */ case    1:  		/* mr R31, R21 */
		/* 8210CDF8h case    1:*/		regs.R31 = regs.R21;
		/* 8210CDF8h case    1:*/		return 0x8210CDFC;
		  /* 8210CDFCh */ case    2:  		/* li R19, 1 */
		/* 8210CDFCh case    2:*/		cpu::op::li<0>(regs,&regs.R19,0x1);
		/* 8210CDFCh case    2:*/		return 0x8210CE00;
		  /* 8210CE00h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8210CE00h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210CE00h case    3:*/		return 0x8210CE04;
		  /* 8210CE04h */ case    4:  		/* bc 4, CR6_GT, 484 */
		/* 8210CE04h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8210CFE8;  }
		/* 8210CE04h case    4:*/		return 0x8210CE08;
		  /* 8210CE08h */ case    5:  		/* mr R30, R21 */
		/* 8210CE08h case    5:*/		regs.R30 = regs.R21;
		/* 8210CE08h case    5:*/		return 0x8210CE0C;
		  /* 8210CE0Ch */ case    6:  		/* lwz R11, <#[R28 + 16]> */
		/* 8210CE0Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 8210CE0Ch case    6:*/		return 0x8210CE10;
		  /* 8210CE10h */ case    7:  		/* lwzx R11, <#[R30 + R11]> */
		/* 8210CE10h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8210CE10h case    7:*/		return 0x8210CE14;
		  /* 8210CE14h */ case    8:  		/* lwz R4, <#[R11 + 4]> */
		/* 8210CE14h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 8210CE14h case    8:*/		return 0x8210CE18;
		  /* 8210CE18h */ case    9:  		/* rlwinm. R11, R4, 0, 23, 23 */
		/* 8210CE18h case    9:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R4);
		/* 8210CE18h case    9:*/		return 0x8210CE1C;
		  /* 8210CE1Ch */ case   10:  		/* bc 12, CR0_EQ, 424 */
		/* 8210CE1Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x8210CFC4;  }
		/* 8210CE1Ch case   10:*/		return 0x8210CE20;
		  /* 8210CE20h */ case   11:  		/* rlwinm. R11, R4, 0, 21, 21 */
		/* 8210CE20h case   11:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R11,regs.R4);
		/* 8210CE20h case   11:*/		return 0x8210CE24;
		  /* 8210CE24h */ case   12:  		/* bc 4, CR0_EQ, 12 */
		/* 8210CE24h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8210CE30;  }
		/* 8210CE24h case   12:*/		return 0x8210CE28;
		  /* 8210CE28h */ case   13:  		/* rlwinm. R11, R4, 0, 20, 20 */
		/* 8210CE28h case   13:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R4);
		/* 8210CE28h case   13:*/		return 0x8210CE2C;
		  /* 8210CE2Ch */ case   14:  		/* bc 12, CR0_EQ, 408 */
		/* 8210CE2Ch case   14:*/		if ( regs.CR[0].eq ) { return 0x8210CFC4;  }
		/* 8210CE2Ch case   14:*/		return 0x8210CE30;
	}
	return 0x8210CE30;
} // Block from 8210CDF4h-8210CE30h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8210CE30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CE30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CE30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CE30);
		  /* 8210CE30h */ case    0:  		/* mr R3, R21 */
		/* 8210CE30h case    0:*/		regs.R3 = regs.R21;
		/* 8210CE30h case    0:*/		return 0x8210CE34;
		  /* 8210CE34h */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 8210CE34h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8210CE34h case    1:*/		return 0x8210CE38;
		  /* 8210CE38h */ case    2:  		/* bc 12, CR6_EQ, 164 */
		/* 8210CE38h case    2:*/		if ( regs.CR[6].eq ) { return 0x8210CEDC;  }
		/* 8210CE38h case    2:*/		return 0x8210CE3C;
		  /* 8210CE3Ch */ case    3:  		/* lwz R5, <#[R28 + 8]> */
		/* 8210CE3Ch case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x00000008) );
		/* 8210CE3Ch case    3:*/		return 0x8210CE40;
		  /* 8210CE40h */ case    4:  		/* mr R6, R21 */
		/* 8210CE40h case    4:*/		regs.R6 = regs.R21;
		/* 8210CE40h case    4:*/		return 0x8210CE44;
		  /* 8210CE44h */ case    5:  		/* cmplwi CR6, R5, 0 */
		/* 8210CE44h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8210CE44h case    5:*/		return 0x8210CE48;
		  /* 8210CE48h */ case    6:  		/* bc 12, CR6_EQ, 128 */
		/* 8210CE48h case    6:*/		if ( regs.CR[6].eq ) { return 0x8210CEC8;  }
		/* 8210CE48h case    6:*/		return 0x8210CE4C;
		  /* 8210CE4Ch */ case    7:  		/* lwz R7, <#[R28 + 20]> */
		/* 8210CE4Ch case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R28 + 0x00000014) );
		/* 8210CE4Ch case    7:*/		return 0x8210CE50;
		  /* 8210CE50h */ case    8:  		/* mr R8, R21 */
		/* 8210CE50h case    8:*/		regs.R8 = regs.R21;
		/* 8210CE50h case    8:*/		return 0x8210CE54;
		  /* 8210CE54h */ case    9:  		/* lwzx R11, <#[R8 + R7]> */
		/* 8210CE54h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 8210CE54h case    9:*/		return 0x8210CE58;
		  /* 8210CE58h */ case   10:  		/* lwz R10, <#[R11 + 4]> */
		/* 8210CE58h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210CE58h case   10:*/		return 0x8210CE5C;
		  /* 8210CE5Ch */ case   11:  		/* cmplw CR6, R10, R31 */
		/* 8210CE5Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 8210CE5Ch case   11:*/		return 0x8210CE60;
		  /* 8210CE60h */ case   12:  		/* bc 4, CR6_EQ, 84 */
		/* 8210CE60h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8210CEB4;  }
		/* 8210CE60h case   12:*/		return 0x8210CE64;
		  /* 8210CE64h */ case   13:  		/* lwz R10, <#[R11 + 8]> */
		/* 8210CE64h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8210CE64h case   13:*/		return 0x8210CE68;
		  /* 8210CE68h */ case   14:  		/* cmpwi CR6, R10, -1 */
		/* 8210CE68h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210CE68h case   14:*/		return 0x8210CE6C;
		  /* 8210CE6Ch */ case   15:  		/* bc 4, CR6_EQ, 72 */
		/* 8210CE6Ch case   15:*/		if ( !regs.CR[6].eq ) { return 0x8210CEB4;  }
		/* 8210CE6Ch case   15:*/		return 0x8210CE70;
		  /* 8210CE70h */ case   16:  		/* lwz R10, <#[R11 + 12]> */
		/* 8210CE70h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210CE70h case   16:*/		return 0x8210CE74;
		  /* 8210CE74h */ case   17:  		/* lwz R9, <#[R11 + 16]> */
		/* 8210CE74h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 8210CE74h case   17:*/		return 0x8210CE78;
		  /* 8210CE78h */ case   18:  		/* add R10, R10, R3 */
		/* 8210CE78h case   18:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 8210CE78h case   18:*/		return 0x8210CE7C;
		  /* 8210CE7Ch */ case   19:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210CE7Ch case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210CE7Ch case   19:*/		return 0x8210CE80;
		  /* 8210CE80h */ case   20:  		/* add R10, R10, R9 */
		/* 8210CE80h case   20:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8210CE80h case   20:*/		return 0x8210CE84;
		  /* 8210CE84h */ case   21:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210CE84h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210CE84h case   21:*/		return 0x8210CE88;
		  /* 8210CE88h */ case   22:  		/* lwzx R10, <#[R10 + R20]> */
		/* 8210CE88h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R20 + 0x00000000) );
		/* 8210CE88h case   22:*/		return 0x8210CE8C;
		  /* 8210CE8Ch */ case   23:  		/* cmpwi CR6, R10, -1 */
		/* 8210CE8Ch case   23:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210CE8Ch case   23:*/		return 0x8210CE90;
		  /* 8210CE90h */ case   24:  		/* bc 12, CR6_EQ, 36 */
		/* 8210CE90h case   24:*/		if ( regs.CR[6].eq ) { return 0x8210CEB4;  }
		/* 8210CE90h case   24:*/		return 0x8210CE94;
		  /* 8210CE94h */ case   25:  		/* rlwinm. R9, R4, 0, 20, 20 */
		/* 8210CE94h case   25:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R9,regs.R4);
		/* 8210CE94h case   25:*/		return 0x8210CE98;
		  /* 8210CE98h */ case   26:  		/* bc 4, CR0_EQ, 48 */
		/* 8210CE98h case   26:*/		if ( !regs.CR[0].eq ) { return 0x8210CEC8;  }
		/* 8210CE98h case   26:*/		return 0x8210CE9C;
		  /* 8210CE9Ch */ case   27:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210CE9Ch case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210CE9Ch case   27:*/		return 0x8210CEA0;
		  /* 8210CEA0h */ case   28:  		/* lfd FR0, <#[R11 + 32]> */
		/* 8210CEA0h case   28:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 8210CEA0h case   28:*/		return 0x8210CEA4;
		  /* 8210CEA4h */ case   29:  		/* lwzx R11, <#[R10 + R7]> */
		/* 8210CEA4h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 8210CEA4h case   29:*/		return 0x8210CEA8;
		  /* 8210CEA8h */ case   30:  		/* lfd FR13, <#[R11 + 32]> */
		/* 8210CEA8h case   30:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 8210CEA8h case   30:*/		return 0x8210CEAC;
		  /* 8210CEACh */ case   31:  		/* fcmpu CR6, FR0, FR13 */
		/* 8210CEACh case   31:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 8210CEACh case   31:*/		return 0x8210CEB0;
		  /* 8210CEB0h */ case   32:  		/* bc 4, CR6_EQ, 24 */
		/* 8210CEB0h case   32:*/		if ( !regs.CR[6].eq ) { return 0x8210CEC8;  }
		/* 8210CEB0h case   32:*/		return 0x8210CEB4;
	}
	return 0x8210CEB4;
} // Block from 8210CE30h-8210CEB4h (33 instructions)

//////////////////////////////////////////////////////
// Block at 8210CEB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CEB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CEB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CEB4);
		  /* 8210CEB4h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 8210CEB4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8210CEB4h case    0:*/		return 0x8210CEB8;
		  /* 8210CEB8h */ case    1:  		/* addi R6, R6, 1 */
		/* 8210CEB8h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8210CEB8h case    1:*/		return 0x8210CEBC;
		  /* 8210CEBCh */ case    2:  		/* addi R8, R8, 4 */
		/* 8210CEBCh case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 8210CEBCh case    2:*/		return 0x8210CEC0;
		  /* 8210CEC0h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 8210CEC0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 8210CEC0h case    3:*/		return 0x8210CEC4;
		  /* 8210CEC4h */ case    4:  		/* bc 12, CR6_LT, -112 */
		/* 8210CEC4h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210CE54;  }
		/* 8210CEC4h case    4:*/		return 0x8210CEC8;
	}
	return 0x8210CEC8;
} // Block from 8210CEB4h-8210CEC8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210CEC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CEC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CEC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CEC8);
		  /* 8210CEC8h */ case    0:  		/* cmplw CR6, R6, R5 */
		/* 8210CEC8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R5);
		/* 8210CEC8h case    0:*/		return 0x8210CECC;
		  /* 8210CECCh */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8210CECCh case    1:*/		if ( regs.CR[6].eq ) { return 0x8210CEDC;  }
		/* 8210CECCh case    1:*/		return 0x8210CED0;
		  /* 8210CED0h */ case    2:  		/* addi R3, R3, 1 */
		/* 8210CED0h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 8210CED0h case    2:*/		return 0x8210CED4;
		  /* 8210CED4h */ case    3:  		/* cmplw CR6, R3, R29 */
		/* 8210CED4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R29);
		/* 8210CED4h case    3:*/		return 0x8210CED8;
		  /* 8210CED8h */ case    4:  		/* bc 12, CR6_LT, -152 */
		/* 8210CED8h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210CE40;  }
		/* 8210CED8h case    4:*/		return 0x8210CEDC;
	}
	return 0x8210CEDC;
} // Block from 8210CEC8h-8210CEDCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210CEDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CEDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CEDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CEDC);
		  /* 8210CEDCh */ case    0:  		/* rlwinm. R11, R4, 0, 20, 20 */
		/* 8210CEDCh case    0:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R4);
		/* 8210CEDCh case    0:*/		return 0x8210CEE0;
		  /* 8210CEE0h */ case    1:  		/* lwz R11, <#[R28 + 8]> */
		/* 8210CEE0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8210CEE0h case    1:*/		return 0x8210CEE4;
		  /* 8210CEE4h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8210CEE4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210CEE4h case    2:*/		return 0x8210CEE8;
		  /* 8210CEE8h */ case    3:  		/* bc 4, CR0_EQ, 140 */
		/* 8210CEE8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8210CF74;  }
		/* 8210CEE8h case    3:*/		return 0x8210CEEC;
		  /* 8210CEECh */ case    4:  		/* mr R8, R21 */
		/* 8210CEECh case    4:*/		regs.R8 = regs.R21;
		/* 8210CEECh case    4:*/		return 0x8210CEF0;
		  /* 8210CEF0h */ case    5:  		/* bc 4, CR6_GT, 212 */
		/* 8210CEF0h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8210CFC4;  }
		/* 8210CEF0h case    5:*/		return 0x8210CEF4;
		  /* 8210CEF4h */ case    6:  		/* mr R7, R21 */
		/* 8210CEF4h case    6:*/		regs.R7 = regs.R21;
		/* 8210CEF4h case    6:*/		return 0x8210CEF8;
		  /* 8210CEF8h */ case    7:  		/* lwz R11, <#[R28 + 20]> */
		/* 8210CEF8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 8210CEF8h case    7:*/		return 0x8210CEFC;
		  /* 8210CEFCh */ case    8:  		/* lwzx R11, <#[R7 + R11]> */
		/* 8210CEFCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 8210CEFCh case    8:*/		return 0x8210CF00;
		  /* 8210CF00h */ case    9:  		/* lwz R10, <#[R11 + 4]> */
		/* 8210CF00h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210CF00h case    9:*/		return 0x8210CF04;
		  /* 8210CF04h */ case   10:  		/* cmplw CR6, R10, R31 */
		/* 8210CF04h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 8210CF04h case   10:*/		return 0x8210CF08;
		  /* 8210CF08h */ case   11:  		/* bc 4, CR6_EQ, 84 */
		/* 8210CF08h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8210CF5C;  }
		/* 8210CF08h case   11:*/		return 0x8210CF0C;
		  /* 8210CF0Ch */ case   12:  		/* lwz R10, <#[R11 + 12]> */
		/* 8210CF0Ch case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210CF0Ch case   12:*/		return 0x8210CF10;
		  /* 8210CF10h */ case   13:  		/* lwz R9, <#[R11 + 8]> */
		/* 8210CF10h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8210CF10h case   13:*/		return 0x8210CF14;
		  /* 8210CF14h */ case   14:  		/* add R10, R10, R3 */
		/* 8210CF14h case   14:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 8210CF14h case   14:*/		return 0x8210CF18;
		  /* 8210CF18h */ case   15:  		/* cmpwi CR6, R9, -1 */
		/* 8210CF18h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 8210CF18h case   15:*/		return 0x8210CF1C;
		  /* 8210CF1Ch */ case   16:  		/* stw R10, <#[R11 + 12]> */
		/* 8210CF1Ch case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210CF1Ch case   16:*/		return 0x8210CF20;
		  /* 8210CF20h */ case   17:  		/* bc 4, CR6_EQ, 60 */
		/* 8210CF20h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8210CF5C;  }
		/* 8210CF20h case   17:*/		return 0x8210CF24;
		  /* 8210CF24h */ case   18:  		/* lwz R9, <#[R11 + 16]> */
		/* 8210CF24h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 8210CF24h case   18:*/		return 0x8210CF28;
		  /* 8210CF28h */ case   19:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210CF28h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210CF28h case   19:*/		return 0x8210CF2C;
		  /* 8210CF2Ch */ case   20:  		/* add R10, R10, R9 */
		/* 8210CF2Ch case   20:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8210CF2Ch case   20:*/		return 0x8210CF30;
		  /* 8210CF30h */ case   21:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210CF30h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210CF30h case   21:*/		return 0x8210CF34;
		  /* 8210CF34h */ case   22:  		/* lwzx R9, <#[R10 + R20]> */
		/* 8210CF34h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R20 + 0x00000000) );
		/* 8210CF34h case   22:*/		return 0x8210CF38;
		  /* 8210CF38h */ case   23:  		/* cmpwi CR6, R9, -1 */
		/* 8210CF38h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 8210CF38h case   23:*/		return 0x8210CF3C;
		  /* 8210CF3Ch */ case   24:  		/* bc 4, CR6_EQ, 12 */
		/* 8210CF3Ch case   24:*/		if ( !regs.CR[6].eq ) { return 0x8210CF48;  }
		/* 8210CF3Ch case   24:*/		return 0x8210CF40;
		  /* 8210CF40h */ case   25:  		/* stwx R8, <#[R10 + R20]> */
		/* 8210CF40h case   25:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + regs.R20 + 0x00000000) );
		/* 8210CF40h case   25:*/		return 0x8210CF44;
		  /* 8210CF44h */ case   26:  		/* b 24 */
		/* 8210CF44h case   26:*/		return 0x8210CF5C;
		/* 8210CF44h case   26:*/		return 0x8210CF48;
	}
	return 0x8210CF48;
} // Block from 8210CEDCh-8210CF48h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8210CF48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CF48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CF48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CF48);
		  /* 8210CF48h */ case    0:  		/* lwz R9, <#[R28 + 116]> */
		/* 8210CF48h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000074) );
		/* 8210CF48h case    0:*/		return 0x8210CF4C;
		  /* 8210CF4Ch */ case    1:  		/* mr R18, R19 */
		/* 8210CF4Ch case    1:*/		regs.R18 = regs.R19;
		/* 8210CF4Ch case    1:*/		return 0x8210CF50;
		  /* 8210CF50h */ case    2:  		/* stw R9, <#[R11 + 4]> */
		/* 8210CF50h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8210CF50h case    2:*/		return 0x8210CF54;
		  /* 8210CF54h */ case    3:  		/* lwzx R10, <#[R10 + R20]> */
		/* 8210CF54h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R20 + 0x00000000) );
		/* 8210CF54h case    3:*/		return 0x8210CF58;
		  /* 8210CF58h */ case    4:  		/* stw R10, <#[R11 + 48]> */
		/* 8210CF58h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 8210CF58h case    4:*/		return 0x8210CF5C;
	}
	return 0x8210CF5C;
} // Block from 8210CF48h-8210CF5Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210CF5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CF5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CF5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CF5C);
		  /* 8210CF5Ch */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 8210CF5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8210CF5Ch case    0:*/		return 0x8210CF60;
		  /* 8210CF60h */ case    1:  		/* addi R8, R8, 1 */
		/* 8210CF60h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8210CF60h case    1:*/		return 0x8210CF64;
		  /* 8210CF64h */ case    2:  		/* addi R7, R7, 4 */
		/* 8210CF64h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 8210CF64h case    2:*/		return 0x8210CF68;
		  /* 8210CF68h */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 8210CF68h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8210CF68h case    3:*/		return 0x8210CF6C;
		  /* 8210CF6Ch */ case    4:  		/* bc 12, CR6_LT, -116 */
		/* 8210CF6Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x8210CEF8;  }
		/* 8210CF6Ch case    4:*/		return 0x8210CF70;
		  /* 8210CF70h */ case    5:  		/* b 84 */
		/* 8210CF70h case    5:*/		return 0x8210CFC4;
		/* 8210CF70h case    5:*/		return 0x8210CF74;
	}
	return 0x8210CF74;
} // Block from 8210CF5Ch-8210CF74h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210CF74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CF74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CF74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CF74);
		  /* 8210CF74h */ case    0:  		/* mr R9, R21 */
		/* 8210CF74h case    0:*/		regs.R9 = regs.R21;
		/* 8210CF74h case    0:*/		return 0x8210CF78;
		  /* 8210CF78h */ case    1:  		/* bc 4, CR6_GT, 76 */
		/* 8210CF78h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8210CFC4;  }
		/* 8210CF78h case    1:*/		return 0x8210CF7C;
		  /* 8210CF7Ch */ case    2:  		/* mr R8, R21 */
		/* 8210CF7Ch case    2:*/		regs.R8 = regs.R21;
		/* 8210CF7Ch case    2:*/		return 0x8210CF80;
		  /* 8210CF80h */ case    3:  		/* lwz R11, <#[R28 + 20]> */
		/* 8210CF80h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 8210CF80h case    3:*/		return 0x8210CF84;
		  /* 8210CF84h */ case    4:  		/* lwzx R11, <#[R8 + R11]> */
		/* 8210CF84h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8210CF84h case    4:*/		return 0x8210CF88;
		  /* 8210CF88h */ case    5:  		/* lwz R10, <#[R11 + 4]> */
		/* 8210CF88h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210CF88h case    5:*/		return 0x8210CF8C;
		  /* 8210CF8Ch */ case    6:  		/* cmplw CR6, R10, R31 */
		/* 8210CF8Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 8210CF8Ch case    6:*/		return 0x8210CF90;
		  /* 8210CF90h */ case    7:  		/* bc 4, CR6_EQ, 32 */
		/* 8210CF90h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8210CFB0;  }
		/* 8210CF90h case    7:*/		return 0x8210CF94;
		  /* 8210CF94h */ case    8:  		/* lwz R10, <#[R11 + 12]> */
		/* 8210CF94h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210CF94h case    8:*/		return 0x8210CF98;
		  /* 8210CF98h */ case    9:  		/* lwz R11, <#[R11 + 16]> */
		/* 8210CF98h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 8210CF98h case    9:*/		return 0x8210CF9C;
		  /* 8210CF9Ch */ case   10:  		/* add R10, R10, R3 */
		/* 8210CF9Ch case   10:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 8210CF9Ch case   10:*/		return 0x8210CFA0;
		  /* 8210CFA0h */ case   11:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210CFA0h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210CFA0h case   11:*/		return 0x8210CFA4;
		  /* 8210CFA4h */ case   12:  		/* add R11, R10, R11 */
		/* 8210CFA4h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8210CFA4h case   12:*/		return 0x8210CFA8;
		  /* 8210CFA8h */ case   13:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210CFA8h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210CFA8h case   13:*/		return 0x8210CFAC;
		  /* 8210CFACh */ case   14:  		/* stwx R9, <#[R11 + R20]> */
		/* 8210CFACh case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R20 + 0x00000000) );
		/* 8210CFACh case   14:*/		return 0x8210CFB0;
	}
	return 0x8210CFB0;
} // Block from 8210CF74h-8210CFB0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8210CFB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CFB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CFB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CFB0);
		  /* 8210CFB0h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 8210CFB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8210CFB0h case    0:*/		return 0x8210CFB4;
		  /* 8210CFB4h */ case    1:  		/* addi R9, R9, 1 */
		/* 8210CFB4h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8210CFB4h case    1:*/		return 0x8210CFB8;
		  /* 8210CFB8h */ case    2:  		/* addi R8, R8, 4 */
		/* 8210CFB8h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 8210CFB8h case    2:*/		return 0x8210CFBC;
		  /* 8210CFBCh */ case    3:  		/* cmplw CR6, R9, R11 */
		/* 8210CFBCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8210CFBCh case    3:*/		return 0x8210CFC0;
		  /* 8210CFC0h */ case    4:  		/* bc 12, CR6_LT, -64 */
		/* 8210CFC0h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210CF80;  }
		/* 8210CFC0h case    4:*/		return 0x8210CFC4;
	}
	return 0x8210CFC4;
} // Block from 8210CFB0h-8210CFC4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210CFC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CFC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CFC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CFC4);
		  /* 8210CFC4h */ case    0:  		/* lwz R11, <#[R28 + 4]> */
		/* 8210CFC4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8210CFC4h case    0:*/		return 0x8210CFC8;
		  /* 8210CFC8h */ case    1:  		/* addi R31, R31, 1 */
		/* 8210CFC8h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8210CFC8h case    1:*/		return 0x8210CFCC;
		  /* 8210CFCCh */ case    2:  		/* addi R30, R30, 4 */
		/* 8210CFCCh case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8210CFCCh case    2:*/		return 0x8210CFD0;
		  /* 8210CFD0h */ case    3:  		/* cmplw CR6, R31, R11 */
		/* 8210CFD0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8210CFD0h case    3:*/		return 0x8210CFD4;
		  /* 8210CFD4h */ case    4:  		/* bc 12, CR6_LT, -456 */
		/* 8210CFD4h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210CE0C;  }
		/* 8210CFD4h case    4:*/		return 0x8210CFD8;
		  /* 8210CFD8h */ case    5:  		/* cmpwi CR6, R18, 0 */
		/* 8210CFD8h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R18,0x00000000);
		/* 8210CFD8h case    5:*/		return 0x8210CFDC;
		  /* 8210CFDCh */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 8210CFDCh case    6:*/		if ( regs.CR[6].eq ) { return 0x8210CFE8;  }
		/* 8210CFDCh case    6:*/		return 0x8210CFE0;
		  /* 8210CFE0h */ case    7:  		/* mr R3, R28 */
		/* 8210CFE0h case    7:*/		regs.R3 = regs.R28;
		/* 8210CFE0h case    7:*/		return 0x8210CFE4;
		  /* 8210CFE4h */ case    8:  		/* bl -27588 */
		/* 8210CFE4h case    8:*/		regs.LR = 0x8210CFE8; return 0x82106420;
		/* 8210CFE4h case    8:*/		return 0x8210CFE8;
	}
	return 0x8210CFE8;
} // Block from 8210CFC4h-8210CFE8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8210CFE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210CFE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210CFE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210CFE8);
		  /* 8210CFE8h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 8210CFE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8210CFE8h case    0:*/		return 0x8210CFEC;
		  /* 8210CFECh */ case    1:  		/* mr R8, R21 */
		/* 8210CFECh case    1:*/		regs.R8 = regs.R21;
		/* 8210CFECh case    1:*/		return 0x8210CFF0;
		  /* 8210CFF0h */ case    2:  		/* li R22, -1 */
		/* 8210CFF0h case    2:*/		cpu::op::li<0>(regs,&regs.R22,0xFFFFFFFF);
		/* 8210CFF0h case    2:*/		return 0x8210CFF4;
		  /* 8210CFF4h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8210CFF4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210CFF4h case    3:*/		return 0x8210CFF8;
		  /* 8210CFF8h */ case    4:  		/* bc 4, CR6_GT, 92 */
		/* 8210CFF8h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8210D054;  }
		/* 8210CFF8h case    4:*/		return 0x8210CFFC;
		  /* 8210CFFCh */ case    5:  		/* mr R9, R21 */
		/* 8210CFFCh case    5:*/		regs.R9 = regs.R21;
		/* 8210CFFCh case    5:*/		return 0x8210D000;
		  /* 8210D000h */ case    6:  		/* lwz R11, <#[R28 + 20]> */
		/* 8210D000h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 8210D000h case    6:*/		return 0x8210D004;
		  /* 8210D004h */ case    7:  		/* lwz R10, <#[R28 + 16]> */
		/* 8210D004h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000010) );
		/* 8210D004h case    7:*/		return 0x8210D008;
		  /* 8210D008h */ case    8:  		/* lwzx R11, <#[R9 + R11]> */
		/* 8210D008h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8210D008h case    8:*/		return 0x8210D00C;
		  /* 8210D00Ch */ case    9:  		/* lwz R7, <#[R11 + 4]> */
		/* 8210D00Ch case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 8210D00Ch case    9:*/		return 0x8210D010;
		  /* 8210D010h */ case   10:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 8210D010h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 8210D010h case   10:*/		return 0x8210D014;
		  /* 8210D014h */ case   11:  		/* lwzx R10, <#[R7 + R10]> */
		/* 8210D014h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 8210D014h case   11:*/		return 0x8210D018;
		  /* 8210D018h */ case   12:  		/* lwz R10, <#[R10 + 4]> */
		/* 8210D018h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8210D018h case   12:*/		return 0x8210D01C;
		  /* 8210D01Ch */ case   13:  		/* rlwinm. R7, R10, 0, 23, 23 */
		/* 8210D01Ch case   13:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R7,regs.R10);
		/* 8210D01Ch case   13:*/		return 0x8210D020;
		  /* 8210D020h */ case   14:  		/* bc 12, CR0_EQ, 32 */
		/* 8210D020h case   14:*/		if ( regs.CR[0].eq ) { return 0x8210D040;  }
		/* 8210D020h case   14:*/		return 0x8210D024;
		  /* 8210D024h */ case   15:  		/* rlwinm. R7, R10, 0, 21, 21 */
		/* 8210D024h case   15:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R7,regs.R10);
		/* 8210D024h case   15:*/		return 0x8210D028;
		  /* 8210D028h */ case   16:  		/* bc 4, CR0_EQ, 24 */
		/* 8210D028h case   16:*/		if ( !regs.CR[0].eq ) { return 0x8210D040;  }
		/* 8210D028h case   16:*/		return 0x8210D02C;
		  /* 8210D02Ch */ case   17:  		/* rlwinm. R10, R10, 0, 20, 20 */
		/* 8210D02Ch case   17:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R10,regs.R10);
		/* 8210D02Ch case   17:*/		return 0x8210D030;
		  /* 8210D030h */ case   18:  		/* bc 4, CR0_EQ, 16 */
		/* 8210D030h case   18:*/		if ( !regs.CR[0].eq ) { return 0x8210D040;  }
		/* 8210D030h case   18:*/		return 0x8210D034;
		  /* 8210D034h */ case   19:  		/* stw R22, <#[R11 + 12]> */
		/* 8210D034h case   19:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210D034h case   19:*/		return 0x8210D038;
		  /* 8210D038h */ case   20:  		/* lwz R10, <#[R28 + 120]> */
		/* 8210D038h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000078) );
		/* 8210D038h case   20:*/		return 0x8210D03C;
		  /* 8210D03Ch */ case   21:  		/* stw R10, <#[R11 + 4]> */
		/* 8210D03Ch case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210D03Ch case   21:*/		return 0x8210D040;
	}
	return 0x8210D040;
} // Block from 8210CFE8h-8210D040h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8210D040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D040);
		  /* 8210D040h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 8210D040h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8210D040h case    0:*/		return 0x8210D044;
		  /* 8210D044h */ case    1:  		/* addi R8, R8, 1 */
		/* 8210D044h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8210D044h case    1:*/		return 0x8210D048;
		  /* 8210D048h */ case    2:  		/* addi R9, R9, 4 */
		/* 8210D048h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8210D048h case    2:*/		return 0x8210D04C;
		  /* 8210D04Ch */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 8210D04Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8210D04Ch case    3:*/		return 0x8210D050;
		  /* 8210D050h */ case    4:  		/* bc 12, CR6_LT, -80 */
		/* 8210D050h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210D000;  }
		/* 8210D050h case    4:*/		return 0x8210D054;
	}
	return 0x8210D054;
} // Block from 8210D040h-8210D054h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210D054h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D054( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D054) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D054);
		  /* 8210D054h */ case    0:  		/* lwz R11, <#[R28 + 12]> */
		/* 8210D054h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000000C) );
		/* 8210D054h case    0:*/		return 0x8210D058;
		  /* 8210D058h */ case    1:  		/* mr R23, R21 */
		/* 8210D058h case    1:*/		regs.R23 = regs.R21;
		/* 8210D058h case    1:*/		return 0x8210D05C;
		  /* 8210D05Ch */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8210D05Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210D05Ch case    2:*/		return 0x8210D060;
		  /* 8210D060h */ case    3:  		/* bc 4, CR6_GT, 908 */
		/* 8210D060h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210D3EC;  }
		/* 8210D060h case    3:*/		return 0x8210D064;
		  /* 8210D064h */ case    4:  		/* mr R24, R21 */
		/* 8210D064h case    4:*/		regs.R24 = regs.R21;
		/* 8210D064h case    4:*/		return 0x8210D068;
		  /* 8210D068h */ case    5:  		/* li R25, -1 */
		/* 8210D068h case    5:*/		cpu::op::li<0>(regs,&regs.R25,0xFFFFFFFF);
		/* 8210D068h case    5:*/		return 0x8210D06C;
		  /* 8210D06Ch */ case    6:  		/* lwz R11, <#[R28 + 24]> */
		/* 8210D06Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000018) );
		/* 8210D06Ch case    6:*/		return 0x8210D070;
		  /* 8210D070h */ case    7:  		/* lwzx R26, <#[R24 + R11]> */
		/* 8210D070h case    7:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R24 + regs.R11 + 0x00000000) );
		/* 8210D070h case    7:*/		return 0x8210D074;
		  /* 8210D074h */ case    8:  		/* lwz R11, <#[R26]> */
		/* 8210D074h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8210D074h case    8:*/		return 0x8210D078;
		  /* 8210D078h */ case    9:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 8210D078h case    9:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 8210D078h case    9:*/		return 0x8210D07C;
		  /* 8210D07Ch */ case   10:  		/* bc 12, CR0_EQ, 860 */
		/* 8210D07Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x8210D3D8;  }
		/* 8210D07Ch case   10:*/		return 0x8210D080;
		  /* 8210D080h */ case   11:  		/* addi R11, R1, 96 */
		/* 8210D080h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 8210D080h case   11:*/		return 0x8210D084;
		  /* 8210D084h */ case   12:  		/* addi R10, R1, 112 */
		/* 8210D084h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 8210D084h case   12:*/		return 0x8210D088;
		  /* 8210D088h */ case   13:  		/* addi R5, R1, 84 */
		/* 8210D088h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 8210D088h case   13:*/		return 0x8210D08C;
		  /* 8210D08Ch */ case   14:  		/* li R4, 0 */
		/* 8210D08Ch case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8210D08Ch case   14:*/		return 0x8210D090;
		  /* 8210D090h */ case   15:  		/* mr R3, R26 */
		/* 8210D090h case   15:*/		regs.R3 = regs.R26;
		/* 8210D090h case   15:*/		return 0x8210D094;
		  /* 8210D094h */ case   16:  		/* std R25, <#[R11]> */
		/* 8210D094h case   16:*/		cpu::mem::store64( regs, regs.R25, (uint32)(regs.R11 + 0x00000000) );
		/* 8210D094h case   16:*/		return 0x8210D098;
		  /* 8210D098h */ case   17:  		/* mr R31, R21 */
		/* 8210D098h case   17:*/		regs.R31 = regs.R21;
		/* 8210D098h case   17:*/		return 0x8210D09C;
		  /* 8210D09Ch */ case   18:  		/* std R21, <#[R10]> */
		/* 8210D09Ch case   18:*/		cpu::mem::store64( regs, regs.R21, (uint32)(regs.R10 + 0x00000000) );
		/* 8210D09Ch case   18:*/		return 0x8210D0A0;
		  /* 8210D0A0h */ case   19:  		/* mr R27, R21 */
		/* 8210D0A0h case   19:*/		regs.R27 = regs.R21;
		/* 8210D0A0h case   19:*/		return 0x8210D0A4;
		  /* 8210D0A4h */ case   20:  		/* std R25, <#[R11 + 8]> */
		/* 8210D0A4h case   20:*/		cpu::mem::store64( regs, regs.R25, (uint32)(regs.R11 + 0x00000008) );
		/* 8210D0A4h case   20:*/		return 0x8210D0A8;
		  /* 8210D0A8h */ case   21:  		/* std R21, <#[R10 + 8]> */
		/* 8210D0A8h case   21:*/		cpu::mem::store64( regs, regs.R21, (uint32)(regs.R10 + 0x00000008) );
		/* 8210D0A8h case   21:*/		return 0x8210D0AC;
		  /* 8210D0ACh */ case   22:  		/* mr R29, R21 */
		/* 8210D0ACh case   22:*/		regs.R29 = regs.R21;
		/* 8210D0ACh case   22:*/		return 0x8210D0B0;
		  /* 8210D0B0h */ case   23:  		/* bl -70040 */
		/* 8210D0B0h case   23:*/		regs.LR = 0x8210D0B4; return 0x820FBF18;
		/* 8210D0B0h case   23:*/		return 0x8210D0B4;
		  /* 8210D0B4h */ case   24:  		/* cmplwi CR0, R3, 0 */
		/* 8210D0B4h case   24:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210D0B4h case   24:*/		return 0x8210D0B8;
		  /* 8210D0B8h */ case   25:  		/* bc 12, CR0_EQ, 380 */
		/* 8210D0B8h case   25:*/		if ( regs.CR[0].eq ) { return 0x8210D234;  }
		/* 8210D0B8h case   25:*/		return 0x8210D0BC;
		  /* 8210D0BCh */ case   26:  		/* addi R30, R1, 128 */
		/* 8210D0BCh case   26:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0x80);
		/* 8210D0BCh case   26:*/		return 0x8210D0C0;
		  /* 8210D0C0h */ case   27:  		/* lwz R8, <#[R1 + 84]> */
		/* 8210D0C0h case   27:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 8210D0C0h case   27:*/		return 0x8210D0C4;
		  /* 8210D0C4h */ case   28:  		/* lwz R5, <#[R28 + 20]> */
		/* 8210D0C4h case   28:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x00000014) );
		/* 8210D0C4h case   28:*/		return 0x8210D0C8;
		  /* 8210D0C8h */ case   29:  		/* lwz R11, <#[R28 + 120]> */
		/* 8210D0C8h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000078) );
		/* 8210D0C8h case   29:*/		return 0x8210D0CC;
		  /* 8210D0CCh */ case   30:  		/* lwz R10, <#[R8]> */
		/* 8210D0CCh case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8210D0CCh case   30:*/		return 0x8210D0D0;
		  /* 8210D0D0h */ case   31:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210D0D0h case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210D0D0h case   31:*/		return 0x8210D0D4;
		  /* 8210D0D4h */ case   32:  		/* lwzx R9, <#[R10 + R5]> */
		/* 8210D0D4h case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 8210D0D4h case   32:*/		return 0x8210D0D8;
		  /* 8210D0D8h */ case   33:  		/* lwz R10, <#[R9 + 4]> */
		/* 8210D0D8h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 8210D0D8h case   33:*/		return 0x8210D0DC;
		  /* 8210D0DCh */ case   34:  		/* cmplw CR6, R11, R10 */
		/* 8210D0DCh case   34:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210D0DCh case   34:*/		return 0x8210D0E0;
		  /* 8210D0E0h */ case   35:  		/* bc 4, CR6_EQ, 300 */
		/* 8210D0E0h case   35:*/		if ( !regs.CR[6].eq ) { return 0x8210D20C;  }
		/* 8210D0E0h case   35:*/		return 0x8210D0E4;
		  /* 8210D0E4h */ case   36:  		/* lwz R11, <#[R9 + 8]> */
		/* 8210D0E4h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 8210D0E4h case   36:*/		return 0x8210D0E8;
		  /* 8210D0E8h */ case   37:  		/* cmpwi CR6, R11, -1 */
		/* 8210D0E8h case   37:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210D0E8h case   37:*/		return 0x8210D0EC;
		  /* 8210D0ECh */ case   38:  		/* bc 4, CR6_EQ, 288 */
		/* 8210D0ECh case   38:*/		if ( !regs.CR[6].eq ) { return 0x8210D20C;  }
		/* 8210D0ECh case   38:*/		return 0x8210D0F0;
		  /* 8210D0F0h */ case   39:  		/* lwz R11, <#[R28 + 108]> */
		/* 8210D0F0h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000006C) );
		/* 8210D0F0h case   39:*/		return 0x8210D0F4;
		  /* 8210D0F4h */ case   40:  		/* mr R10, R19 */
		/* 8210D0F4h case   40:*/		regs.R10 = regs.R19;
		/* 8210D0F4h case   40:*/		return 0x8210D0F8;
		  /* 8210D0F8h */ case   41:  		/* cmplwi CR6, R3, 1 */
		/* 8210D0F8h case   41:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000001);
		/* 8210D0F8h case   41:*/		return 0x8210D0FC;
		  /* 8210D0FCh */ case   42:  		/* nor R11, R11, R11 */
		/* 8210D0FCh case   42:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8210D0FCh case   42:*/		return 0x8210D100;
		  /* 8210D100h */ case   43:  		/* rlwinm R11, R11, 4, 31, 31 */
		/* 8210D100h case   43:*/		cpu::op::rlwinm<0,4,31,31>(regs,&regs.R11,regs.R11);
		/* 8210D100h case   43:*/		return 0x8210D104;
		  /* 8210D104h */ case   44:  		/* stw R11, <#[R30]> */
		/* 8210D104h case   44:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8210D104h case   44:*/		return 0x8210D108;
		  /* 8210D108h */ case   45:  		/* bc 4, CR6_GT, 68 */
		/* 8210D108h case   45:*/		if ( !regs.CR[6].gt ) { return 0x8210D14C;  }
		/* 8210D108h case   45:*/		return 0x8210D10C;
		  /* 8210D10Ch */ case   46:  		/* addi R11, R8, 4 */
		/* 8210D10Ch case   46:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0x4);
		/* 8210D10Ch case   46:*/		return 0x8210D110;
		  /* 8210D110h */ case   47:  		/* lwz R7, <#[R30]> */
		/* 8210D110h case   47:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000000) );
		/* 8210D110h case   47:*/		return 0x8210D114;
		  /* 8210D114h */ case   48:  		/* cmpwi CR6, R7, 0 */
		/* 8210D114h case   48:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 8210D114h case   48:*/		return 0x8210D118;
		  /* 8210D118h */ case   49:  		/* bc 12, CR6_EQ, 52 */
		/* 8210D118h case   49:*/		if ( regs.CR[6].eq ) { return 0x8210D14C;  }
		/* 8210D118h case   49:*/		return 0x8210D11C;
		  /* 8210D11Ch */ case   50:  		/* lwz R7, <#[R11]> */
		/* 8210D11Ch case   50:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8210D11Ch case   50:*/		return 0x8210D120;
		  /* 8210D120h */ case   51:  		/* lfd FR0, <#[R9 + 32]> */
		/* 8210D120h case   51:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000020) );
		/* 8210D120h case   51:*/		return 0x8210D124;
		  /* 8210D124h */ case   52:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 8210D124h case   52:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 8210D124h case   52:*/		return 0x8210D128;
		  /* 8210D128h */ case   53:  		/* lwzx R7, <#[R7 + R5]> */
		/* 8210D128h case   53:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R5 + 0x00000000) );
		/* 8210D128h case   53:*/		return 0x8210D12C;
		  /* 8210D12Ch */ case   54:  		/* lfd FR13, <#[R7 + 32]> */
		/* 8210D12Ch case   54:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R7 + 0x00000020) );
		/* 8210D12Ch case   54:*/		return 0x8210D130;
		  /* 8210D130h */ case   55:  		/* fcmpu CR6, FR0, FR13 */
		/* 8210D130h case   55:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 8210D130h case   55:*/		return 0x8210D134;
		  /* 8210D134h */ case   56:  		/* bc 12, CR6_EQ, 8 */
		/* 8210D134h case   56:*/		if ( regs.CR[6].eq ) { return 0x8210D13C;  }
		/* 8210D134h case   56:*/		return 0x8210D138;
		  /* 8210D138h */ case   57:  		/* stw R21, <#[R30]> */
		/* 8210D138h case   57:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R30 + 0x00000000) );
		/* 8210D138h case   57:*/		return 0x8210D13C;
	}
	return 0x8210D13C;
} // Block from 8210D054h-8210D13Ch (58 instructions)

//////////////////////////////////////////////////////
// Block at 8210D13Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D13C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D13C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D13C);
		  /* 8210D13Ch */ case    0:  		/* addi R10, R10, 1 */
		/* 8210D13Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210D13Ch case    0:*/		return 0x8210D140;
		  /* 8210D140h */ case    1:  		/* addi R11, R11, 4 */
		/* 8210D140h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210D140h case    1:*/		return 0x8210D144;
		  /* 8210D144h */ case    2:  		/* cmplw CR6, R10, R3 */
		/* 8210D144h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R3);
		/* 8210D144h case    2:*/		return 0x8210D148;
		  /* 8210D148h */ case    3:  		/* bc 12, CR6_LT, -56 */
		/* 8210D148h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210D110;  }
		/* 8210D148h case    3:*/		return 0x8210D14C;
	}
	return 0x8210D14C;
} // Block from 8210D13Ch-8210D14Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210D14Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D14C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D14C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D14C);
		  /* 8210D14Ch */ case    0:  		/* mr R7, R21 */
		/* 8210D14Ch case    0:*/		regs.R7 = regs.R21;
		/* 8210D14Ch case    0:*/		return 0x8210D150;
		  /* 8210D150h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8210D150h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8210D150h case    1:*/		return 0x8210D154;
		  /* 8210D154h */ case    2:  		/* bc 12, CR6_EQ, 176 */
		/* 8210D154h case    2:*/		if ( regs.CR[6].eq ) { return 0x8210D204;  }
		/* 8210D154h case    2:*/		return 0x8210D158;
		  /* 8210D158h */ case    3:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 8210D158h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 8210D158h case    3:*/		return 0x8210D15C;
		  /* 8210D15Ch */ case    4:  		/* addi R11, R1, 96 */
		/* 8210D15Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 8210D15Ch case    4:*/		return 0x8210D160;
		  /* 8210D160h */ case    5:  		/* add R11, R10, R11 */
		/* 8210D160h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8210D160h case    5:*/		return 0x8210D164;
		  /* 8210D164h */ case    6:  		/* addi R6, R11, -4 */
		/* 8210D164h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFFFC);
		/* 8210D164h case    6:*/		return 0x8210D168;
		  /* 8210D168h */ case    7:  		/* lwz R9, <#[R8]> */
		/* 8210D168h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 8210D168h case    7:*/		return 0x8210D16C;
		  /* 8210D16Ch */ case    8:  		/* mr R11, R21 */
		/* 8210D16Ch case    8:*/		regs.R11 = regs.R21;
		/* 8210D16Ch case    8:*/		return 0x8210D170;
		  /* 8210D170h */ case    9:  		/* cmplwi CR6, R31, 0 */
		/* 8210D170h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8210D170h case    9:*/		return 0x8210D174;
		  /* 8210D174h */ case   10:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 8210D174h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 8210D174h case   10:*/		return 0x8210D178;
		  /* 8210D178h */ case   11:  		/* lwzx R10, <#[R10 + R5]> */
		/* 8210D178h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 8210D178h case   11:*/		return 0x8210D17C;
		  /* 8210D17Ch */ case   12:  		/* bc 12, CR6_EQ, 60 */
		/* 8210D17Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x8210D1B8;  }
		/* 8210D17Ch case   12:*/		return 0x8210D180;
		  /* 8210D180h */ case   13:  		/* lfd FR0, <#[R10 + 32]> */
		/* 8210D180h case   13:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 8210D180h case   13:*/		return 0x8210D184;
		  /* 8210D184h */ case   14:  		/* addi R10, R1, 96 */
		/* 8210D184h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 8210D184h case   14:*/		return 0x8210D188;
		  /* 8210D188h */ case   15:  		/* lwz R4, <#[R10]> */
		/* 8210D188h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000000) );
		/* 8210D188h case   15:*/		return 0x8210D18C;
		  /* 8210D18Ch */ case   16:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 8210D18Ch case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 8210D18Ch case   16:*/		return 0x8210D190;
		  /* 8210D190h */ case   17:  		/* lwzx R4, <#[R4 + R5]> */
		/* 8210D190h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + regs.R5 + 0x00000000) );
		/* 8210D190h case   17:*/		return 0x8210D194;
		  /* 8210D194h */ case   18:  		/* lfd FR13, <#[R4 + 32]> */
		/* 8210D194h case   18:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R4 + 0x00000020) );
		/* 8210D194h case   18:*/		return 0x8210D198;
		  /* 8210D198h */ case   19:  		/* fcmpu CR6, FR13, FR0 */
		/* 8210D198h case   19:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 8210D198h case   19:*/		return 0x8210D19C;
		  /* 8210D19Ch */ case   20:  		/* bc 12, CR6_EQ, 20 */
		/* 8210D19Ch case   20:*/		if ( regs.CR[6].eq ) { return 0x8210D1B0;  }
		/* 8210D19Ch case   20:*/		return 0x8210D1A0;
		  /* 8210D1A0h */ case   21:  		/* addi R11, R11, 1 */
		/* 8210D1A0h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210D1A0h case   21:*/		return 0x8210D1A4;
		  /* 8210D1A4h */ case   22:  		/* addi R10, R10, 4 */
		/* 8210D1A4h case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210D1A4h case   22:*/		return 0x8210D1A8;
		  /* 8210D1A8h */ case   23:  		/* cmplw CR6, R11, R31 */
		/* 8210D1A8h case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 8210D1A8h case   23:*/		return 0x8210D1AC;
		  /* 8210D1ACh */ case   24:  		/* bc 12, CR6_LT, -36 */
		/* 8210D1ACh case   24:*/		if ( regs.CR[6].lt ) { return 0x8210D188;  }
		/* 8210D1ACh case   24:*/		return 0x8210D1B0;
	}
	return 0x8210D1B0;
} // Block from 8210D14Ch-8210D1B0h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8210D1B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D1B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D1B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D1B0);
		  /* 8210D1B0h */ case    0:  		/* cmplwi CR6, R11, 4 */
		/* 8210D1B0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 8210D1B0h case    0:*/		return 0x8210D1B4;
		  /* 8210D1B4h */ case    1:  		/* bc 12, CR6_EQ, 76 */
		/* 8210D1B4h case    1:*/		if ( regs.CR[6].eq ) { return 0x8210D200;  }
		/* 8210D1B4h case    1:*/		return 0x8210D1B8;
	}
	return 0x8210D1B8;
} // Block from 8210D1B0h-8210D1B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210D1B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D1B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D1B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D1B8);
		  /* 8210D1B8h */ case    0:  		/* cmplw CR6, R11, R31 */
		/* 8210D1B8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 8210D1B8h case    0:*/		return 0x8210D1BC;
		  /* 8210D1BCh */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 8210D1BCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210D1C8;  }
		/* 8210D1BCh case    1:*/		return 0x8210D1C0;
		  /* 8210D1C0h */ case    2:  		/* stwu R9, <#[R6 + 4]> */
		/* 8210D1C0h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R6 + 0x00000004) );
		regs.R6 = (uint32)(regs.R6 + 0x00000004);
		/* 8210D1C0h case    2:*/		return 0x8210D1C4;
		  /* 8210D1C4h */ case    3:  		/* addi R31, R31, 1 */
		/* 8210D1C4h case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8210D1C4h case    3:*/		return 0x8210D1C8;
	}
	return 0x8210D1C8;
} // Block from 8210D1B8h-8210D1C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210D1C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D1C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D1C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D1C8);
		  /* 8210D1C8h */ case    0:  		/* lwz R10, <#[R30]> */
		/* 8210D1C8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8210D1C8h case    0:*/		return 0x8210D1CC;
		  /* 8210D1CCh */ case    1:  		/* cmpwi CR6, R10, 0 */
		/* 8210D1CCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8210D1CCh case    1:*/		return 0x8210D1D0;
		  /* 8210D1D0h */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 8210D1D0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8210D1EC;  }
		/* 8210D1D0h case    2:*/		return 0x8210D1D4;
		  /* 8210D1D4h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210D1D4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210D1D4h case    3:*/		return 0x8210D1D8;
		  /* 8210D1D8h */ case    4:  		/* addi R10, R1, 112 */
		/* 8210D1D8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 8210D1D8h case    4:*/		return 0x8210D1DC;
		  /* 8210D1DCh */ case    5:  		/* slw R9, R19, R7 */
		/* 8210D1DCh case    5:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R19,regs.R7);
		/* 8210D1DCh case    5:*/		return 0x8210D1E0;
		  /* 8210D1E0h */ case    6:  		/* lwzx R4, <#[R11 + R10]> */
		/* 8210D1E0h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210D1E0h case    6:*/		return 0x8210D1E4;
		  /* 8210D1E4h */ case    7:  		/* or R9, R9, R4 */
		/* 8210D1E4h case    7:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R4);
		/* 8210D1E4h case    7:*/		return 0x8210D1E8;
		  /* 8210D1E8h */ case    8:  		/* stwx R9, <#[R11 + R10]> */
		/* 8210D1E8h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210D1E8h case    8:*/		return 0x8210D1EC;
	}
	return 0x8210D1EC;
} // Block from 8210D1C8h-8210D1ECh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8210D1ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D1EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D1EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D1EC);
		  /* 8210D1ECh */ case    0:  		/* addi R7, R7, 1 */
		/* 8210D1ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8210D1ECh case    0:*/		return 0x8210D1F0;
		  /* 8210D1F0h */ case    1:  		/* addi R8, R8, 4 */
		/* 8210D1F0h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 8210D1F0h case    1:*/		return 0x8210D1F4;
		  /* 8210D1F4h */ case    2:  		/* cmplw CR6, R7, R3 */
		/* 8210D1F4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R3);
		/* 8210D1F4h case    2:*/		return 0x8210D1F8;
		  /* 8210D1F8h */ case    3:  		/* bc 12, CR6_LT, -144 */
		/* 8210D1F8h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210D168;  }
		/* 8210D1F8h case    3:*/		return 0x8210D1FC;
		  /* 8210D1FCh */ case    4:  		/* b 8 */
		/* 8210D1FCh case    4:*/		return 0x8210D204;
		/* 8210D1FCh case    4:*/		return 0x8210D200;
	}
	return 0x8210D200;
} // Block from 8210D1ECh-8210D200h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210D200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D200);
		  /* 8210D200h */ case    0:  		/* mr R27, R19 */
		/* 8210D200h case    0:*/		regs.R27 = regs.R19;
		/* 8210D200h case    0:*/		return 0x8210D204;
	}
	return 0x8210D204;
} // Block from 8210D200h-8210D204h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210D204h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D204( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D204) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D204);
		  /* 8210D204h */ case    0:  		/* cmpwi CR6, R27, 0 */
		/* 8210D204h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 8210D204h case    0:*/		return 0x8210D208;
		  /* 8210D208h */ case    1:  		/* bc 4, CR6_EQ, 184 */
		/* 8210D208h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210D2C0;  }
		/* 8210D208h case    1:*/		return 0x8210D20C;
	}
	return 0x8210D20C;
} // Block from 8210D204h-8210D20Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210D20Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D20C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D20C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D20C);
		  /* 8210D20Ch */ case    0:  		/* addi R29, R29, 1 */
		/* 8210D20Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8210D20Ch case    0:*/		return 0x8210D210;
		  /* 8210D210h */ case    1:  		/* addi R5, R1, 84 */
		/* 8210D210h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 8210D210h case    1:*/		return 0x8210D214;
		  /* 8210D214h */ case    2:  		/* mr R4, R29 */
		/* 8210D214h case    2:*/		regs.R4 = regs.R29;
		/* 8210D214h case    2:*/		return 0x8210D218;
		  /* 8210D218h */ case    3:  		/* mr R3, R26 */
		/* 8210D218h case    3:*/		regs.R3 = regs.R26;
		/* 8210D218h case    3:*/		return 0x8210D21C;
		  /* 8210D21Ch */ case    4:  		/* addi R30, R30, 4 */
		/* 8210D21Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8210D21Ch case    4:*/		return 0x8210D220;
		  /* 8210D220h */ case    5:  		/* bl -70408 */
		/* 8210D220h case    5:*/		regs.LR = 0x8210D224; return 0x820FBF18;
		/* 8210D220h case    5:*/		return 0x8210D224;
		  /* 8210D224h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 8210D224h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210D224h case    6:*/		return 0x8210D228;
		  /* 8210D228h */ case    7:  		/* bc 4, CR0_EQ, -360 */
		/* 8210D228h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8210D0C0;  }
		/* 8210D228h case    7:*/		return 0x8210D22C;
		  /* 8210D22Ch */ case    8:  		/* cmpwi CR6, R27, 0 */
		/* 8210D22Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 8210D22Ch case    8:*/		return 0x8210D230;
		  /* 8210D230h */ case    9:  		/* bc 4, CR6_EQ, 144 */
		/* 8210D230h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8210D2C0;  }
		/* 8210D230h case    9:*/		return 0x8210D234;
	}
	return 0x8210D234;
} // Block from 8210D20Ch-8210D234h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8210D234h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D234);
		  /* 8210D234h */ case    0:  		/* addi R6, R1, 112 */
		/* 8210D234h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x70);
		/* 8210D234h case    0:*/		return 0x8210D238;
		  /* 8210D238h */ case    1:  		/* addi R5, R1, 96 */
		/* 8210D238h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 8210D238h case    1:*/		return 0x8210D23C;
		  /* 8210D23Ch */ case    2:  		/* mr R4, R20 */
		/* 8210D23Ch case    2:*/		regs.R4 = regs.R20;
		/* 8210D23Ch case    2:*/		return 0x8210D240;
		  /* 8210D240h */ case    3:  		/* mr R3, R28 */
		/* 8210D240h case    3:*/		regs.R3 = regs.R28;
		/* 8210D240h case    3:*/		return 0x8210D244;
		  /* 8210D244h */ case    4:  		/* bl -52580 */
		/* 8210D244h case    4:*/		regs.LR = 0x8210D248; return 0x821004E0;
		/* 8210D244h case    4:*/		return 0x8210D248;
		  /* 8210D248h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 8210D248h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210D248h case    5:*/		return 0x8210D24C;
		  /* 8210D24Ch */ case    6:  		/* bc 12, CR0_LT, 116 */
		/* 8210D24Ch case    6:*/		if ( regs.CR[0].lt ) { return 0x8210D2C0;  }
		/* 8210D24Ch case    6:*/		return 0x8210D250;
		  /* 8210D250h */ case    7:  		/* li R4, 0 */
		/* 8210D250h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8210D250h case    7:*/		return 0x8210D254;
		  /* 8210D254h */ case    8:  		/* mr R31, R21 */
		/* 8210D254h case    8:*/		regs.R31 = regs.R21;
		/* 8210D254h case    8:*/		return 0x8210D258;
		  /* 8210D258h */ case    9:  		/* b 76 */
		/* 8210D258h case    9:*/		return 0x8210D2A4;
		/* 8210D258h case    9:*/		return 0x8210D25C;
		  /* 8210D25Ch */ case   10:  		/* lwz R5, <#[R1 + 88]> */
		/* 8210D25Ch case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000058) );
		/* 8210D25Ch case   10:*/		return 0x8210D260;
		  /* 8210D260h */ case   11:  		/* lwz R11, <#[R28 + 20]> */
		/* 8210D260h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 8210D260h case   11:*/		return 0x8210D264;
		  /* 8210D264h */ case   12:  		/* lwz R10, <#[R28 + 120]> */
		/* 8210D264h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000078) );
		/* 8210D264h case   12:*/		return 0x8210D268;
		  /* 8210D268h */ case   13:  		/* lwz R9, <#[R5]> */
		/* 8210D268h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000000) );
		/* 8210D268h case   13:*/		return 0x8210D26C;
		  /* 8210D26Ch */ case   14:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210D26Ch case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210D26Ch case   14:*/		return 0x8210D270;
		  /* 8210D270h */ case   15:  		/* lwzx R11, <#[R9 + R11]> */
		/* 8210D270h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8210D270h case   15:*/		return 0x8210D274;
		  /* 8210D274h */ case   16:  		/* lwz R9, <#[R11 + 4]> */
		/* 8210D274h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8210D274h case   16:*/		return 0x8210D278;
		  /* 8210D278h */ case   17:  		/* cmplw CR6, R10, R9 */
		/* 8210D278h case   17:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8210D278h case   17:*/		return 0x8210D27C;
		  /* 8210D27Ch */ case   18:  		/* bc 4, CR6_EQ, 32 */
		/* 8210D27Ch case   18:*/		if ( !regs.CR[6].eq ) { return 0x8210D29C;  }
		/* 8210D27Ch case   18:*/		return 0x8210D280;
		  /* 8210D280h */ case   19:  		/* lwz R11, <#[R11 + 8]> */
		/* 8210D280h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8210D280h case   19:*/		return 0x8210D284;
		  /* 8210D284h */ case   20:  		/* cmpwi CR6, R11, -1 */
		/* 8210D284h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210D284h case   20:*/		return 0x8210D288;
		  /* 8210D288h */ case   21:  		/* bc 4, CR6_EQ, 20 */
		/* 8210D288h case   21:*/		if ( !regs.CR[6].eq ) { return 0x8210D29C;  }
		/* 8210D288h case   21:*/		return 0x8210D28C;
		  /* 8210D28Ch */ case   22:  		/* mr R6, R3 */
		/* 8210D28Ch case   22:*/		regs.R6 = regs.R3;
		/* 8210D28Ch case   22:*/		return 0x8210D290;
		  /* 8210D290h */ case   23:  		/* addi R4, R1, 96 */
		/* 8210D290h case   23:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 8210D290h case   23:*/		return 0x8210D294;
		  /* 8210D294h */ case   24:  		/* mr R3, R28 */
		/* 8210D294h case   24:*/		regs.R3 = regs.R28;
		/* 8210D294h case   24:*/		return 0x8210D298;
		  /* 8210D298h */ case   25:  		/* bl -53104 */
		/* 8210D298h case   25:*/		regs.LR = 0x8210D29C; return 0x82100328;
		/* 8210D298h case   25:*/		return 0x8210D29C;
	}
	return 0x8210D29C;
} // Block from 8210D234h-8210D29Ch (26 instructions)

//////////////////////////////////////////////////////
// Block at 8210D29Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D29C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D29C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D29C);
		  /* 8210D29Ch */ case    0:  		/* addi R31, R31, 1 */
		/* 8210D29Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8210D29Ch case    0:*/		return 0x8210D2A0;
		  /* 8210D2A0h */ case    1:  		/* mr R4, R31 */
		/* 8210D2A0h case    1:*/		regs.R4 = regs.R31;
		/* 8210D2A0h case    1:*/		return 0x8210D2A4;
	}
	return 0x8210D2A4;
} // Block from 8210D29Ch-8210D2A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210D2A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D2A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D2A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D2A4);
		  /* 8210D2A4h */ case    0:  		/* addi R5, R1, 88 */
		/* 8210D2A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 8210D2A4h case    0:*/		return 0x8210D2A8;
		  /* 8210D2A8h */ case    1:  		/* mr R3, R26 */
		/* 8210D2A8h case    1:*/		regs.R3 = regs.R26;
		/* 8210D2A8h case    1:*/		return 0x8210D2AC;
		  /* 8210D2ACh */ case    2:  		/* bl -70548 */
		/* 8210D2ACh case    2:*/		regs.LR = 0x8210D2B0; return 0x820FBF18;
		/* 8210D2ACh case    2:*/		return 0x8210D2B0;
		  /* 8210D2B0h */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 8210D2B0h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210D2B0h case    3:*/		return 0x8210D2B4;
		  /* 8210D2B4h */ case    4:  		/* bc 4, CR0_EQ, -88 */
		/* 8210D2B4h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8210D25C;  }
		/* 8210D2B4h case    4:*/		return 0x8210D2B8;
		  /* 8210D2B8h */ case    5:  		/* mr R18, R19 */
		/* 8210D2B8h case    5:*/		regs.R18 = regs.R19;
		/* 8210D2B8h case    5:*/		return 0x8210D2BC;
		  /* 8210D2BCh */ case    6:  		/* b 284 */
		/* 8210D2BCh case    6:*/		return 0x8210D3D8;
		/* 8210D2BCh case    6:*/		return 0x8210D2C0;
	}
	return 0x8210D2C0;
} // Block from 8210D2A4h-8210D2C0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210D2C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D2C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D2C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D2C0);
		  /* 8210D2C0h */ case    0:  		/* li R4, 0 */
		/* 8210D2C0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8210D2C0h case    0:*/		return 0x8210D2C4;
		  /* 8210D2C4h */ case    1:  		/* mr R27, R21 */
		/* 8210D2C4h case    1:*/		regs.R27 = regs.R21;
		/* 8210D2C4h case    1:*/		return 0x8210D2C8;
		  /* 8210D2C8h */ case    2:  		/* b 252 */
		/* 8210D2C8h case    2:*/		return 0x8210D3C4;
		/* 8210D2C8h case    2:*/		return 0x8210D2CC;
		  /* 8210D2CCh */ case    3:  		/* lwz R4, <#[R1 + 80]> */
		/* 8210D2CCh case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 8210D2CCh case    3:*/		return 0x8210D2D0;
		  /* 8210D2D0h */ case    4:  		/* lwz R11, <#[R28 + 20]> */
		/* 8210D2D0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 8210D2D0h case    4:*/		return 0x8210D2D4;
		  /* 8210D2D4h */ case    5:  		/* lwz R10, <#[R28 + 120]> */
		/* 8210D2D4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000078) );
		/* 8210D2D4h case    5:*/		return 0x8210D2D8;
		  /* 8210D2D8h */ case    6:  		/* lwz R9, <#[R4]> */
		/* 8210D2D8h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000000) );
		/* 8210D2D8h case    6:*/		return 0x8210D2DC;
		  /* 8210D2DCh */ case    7:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210D2DCh case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210D2DCh case    7:*/		return 0x8210D2E0;
		  /* 8210D2E0h */ case    8:  		/* lwzx R11, <#[R9 + R11]> */
		/* 8210D2E0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8210D2E0h case    8:*/		return 0x8210D2E4;
		  /* 8210D2E4h */ case    9:  		/* lwz R9, <#[R11 + 4]> */
		/* 8210D2E4h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8210D2E4h case    9:*/		return 0x8210D2E8;
		  /* 8210D2E8h */ case   10:  		/* cmplw CR6, R10, R9 */
		/* 8210D2E8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8210D2E8h case   10:*/		return 0x8210D2EC;
		  /* 8210D2ECh */ case   11:  		/* bc 4, CR6_EQ, 208 */
		/* 8210D2ECh case   11:*/		if ( !regs.CR[6].eq ) { return 0x8210D3BC;  }
		/* 8210D2ECh case   11:*/		return 0x8210D2F0;
		  /* 8210D2F0h */ case   12:  		/* lwz R11, <#[R11 + 8]> */
		/* 8210D2F0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8210D2F0h case   12:*/		return 0x8210D2F4;
		  /* 8210D2F4h */ case   13:  		/* cmpwi CR6, R11, -1 */
		/* 8210D2F4h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210D2F4h case   13:*/		return 0x8210D2F8;
		  /* 8210D2F8h */ case   14:  		/* bc 4, CR6_EQ, 196 */
		/* 8210D2F8h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8210D3BC;  }
		/* 8210D2F8h case   14:*/		return 0x8210D2FC;
		  /* 8210D2FCh */ case   15:  		/* mr R29, R21 */
		/* 8210D2FCh case   15:*/		regs.R29 = regs.R21;
		/* 8210D2FCh case   15:*/		return 0x8210D300;
		  /* 8210D300h */ case   16:  		/* cmplwi CR6, R31, 0 */
		/* 8210D300h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8210D300h case   16:*/		return 0x8210D304;
		  /* 8210D304h */ case   17:  		/* bc 12, CR6_EQ, 52 */
		/* 8210D304h case   17:*/		if ( regs.CR[6].eq ) { return 0x8210D338;  }
		/* 8210D304h case   17:*/		return 0x8210D308;
		  /* 8210D308h */ case   18:  		/* addi R3, R1, 96 */
		/* 8210D308h case   18:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8210D308h case   18:*/		return 0x8210D30C;
		  /* 8210D30Ch */ case   19:  		/* rlwinm R5, R31, 2, 0, 29 */
		/* 8210D30Ch case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R31);
		/* 8210D30Ch case   19:*/		return 0x8210D310;
		  /* 8210D310h */ case   20:  		/* mr R30, R31 */
		/* 8210D310h case   20:*/		regs.R30 = regs.R31;
		/* 8210D310h case   20:*/		return 0x8210D314;
		  /* 8210D314h */ case   21:  		/* bl -505052 */
		/* 8210D314h case   21:*/		regs.LR = 0x8210D318; return 0x82091E38;
		/* 8210D314h case   21:*/		return 0x8210D318;
		  /* 8210D318h */ case   22:  		/* mr R11, R21 */
		/* 8210D318h case   22:*/		regs.R11 = regs.R21;
		/* 8210D318h case   22:*/		return 0x8210D31C;
		  /* 8210D31Ch */ case   23:  		/* addi R10, R1, 112 */
		/* 8210D31Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 8210D31Ch case   23:*/		return 0x8210D320;
		  /* 8210D320h */ case   24:  		/* slw R9, R19, R29 */
		/* 8210D320h case   24:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R19,regs.R29);
		/* 8210D320h case   24:*/		return 0x8210D324;
		  /* 8210D324h */ case   25:  		/* stwx R9, <#[R11 + R10]> */
		/* 8210D324h case   25:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210D324h case   25:*/		return 0x8210D328;
		  /* 8210D328h */ case   26:  		/* addic. R30, R30, -1 */
		/* 8210D328h case   26:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 8210D328h case   26:*/		return 0x8210D32C;
		  /* 8210D32Ch */ case   27:  		/* addi R29, R29, 1 */
		/* 8210D32Ch case   27:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8210D32Ch case   27:*/		return 0x8210D330;
		  /* 8210D330h */ case   28:  		/* addi R11, R11, 4 */
		/* 8210D330h case   28:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210D330h case   28:*/		return 0x8210D334;
		  /* 8210D334h */ case   29:  		/* bc 4, CR0_EQ, -24 */
		/* 8210D334h case   29:*/		if ( !regs.CR[0].eq ) { return 0x8210D31C;  }
		/* 8210D334h case   29:*/		return 0x8210D338;
	}
	return 0x8210D338;
} // Block from 8210D2C0h-8210D338h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8210D338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D338);
		  /* 8210D338h */ case    0:  		/* cmplwi CR6, R31, 4 */
		/* 8210D338h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000004);
		/* 8210D338h case    0:*/		return 0x8210D33C;
		  /* 8210D33Ch */ case    1:  		/* bc 4, CR6_LT, 88 */
		/* 8210D33Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x8210D394;  }
		/* 8210D33Ch case    1:*/		return 0x8210D340;
		  /* 8210D340h */ case    2:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 8210D340h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 8210D340h case    2:*/		return 0x8210D344;
		  /* 8210D344h */ case    3:  		/* addi R9, R1, 112 */
		/* 8210D344h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 8210D344h case    3:*/		return 0x8210D348;
		  /* 8210D348h */ case    4:  		/* subfic R10, R31, 4 */
		/* 8210D348h case    4:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R31,0x4);
		/* 8210D348h case    4:*/		return 0x8210D34C;
		  /* 8210D34Ch */ case    5:  		/* addi R7, R1, 96 */
		/* 8210D34Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 8210D34Ch case    5:*/		return 0x8210D350;
		  /* 8210D350h */ case    6:  		/* add R8, R11, R9 */
		/* 8210D350h case    6:*/		cpu::op::add<0>(regs,&regs.R8,regs.R11,regs.R9);
		/* 8210D350h case    6:*/		return 0x8210D354;
		  /* 8210D354h */ case    7:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210D354h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210D354h case    7:*/		return 0x8210D358;
		  /* 8210D358h */ case    8:  		/* add R7, R11, R7 */
		/* 8210D358h case    8:*/		cpu::op::add<0>(regs,&regs.R7,regs.R11,regs.R7);
		/* 8210D358h case    8:*/		return 0x8210D35C;
		  /* 8210D35Ch */ case    9:  		/* addi R11, R8, -4 */
		/* 8210D35Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0xFFFFFFFC);
		/* 8210D35Ch case    9:*/		return 0x8210D360;
		  /* 8210D360h */ case   10:  		/* rlwinm. R9, R10, 30, 2, 31 */
		/* 8210D360h case   10:*/		cpu::op::rlwinm<1,30,2,31>(regs,&regs.R9,regs.R10);
		/* 8210D360h case   10:*/		return 0x8210D364;
		  /* 8210D364h */ case   11:  		/* mr R8, R21 */
		/* 8210D364h case   11:*/		regs.R8 = regs.R21;
		/* 8210D364h case   11:*/		return 0x8210D368;
		  /* 8210D368h */ case   12:  		/* bc 12, CR0_EQ, 16 */
		/* 8210D368h case   12:*/		if ( regs.CR[0].eq ) { return 0x8210D378;  }
		/* 8210D368h case   12:*/		return 0x8210D36C;
		  /* 8210D36Ch */ case   13:  		/* mtspr CTR, R9 */
		/* 8210D36Ch case   13:*/		regs.CTR = regs.R9;
		/* 8210D36Ch case   13:*/		return 0x8210D370;
		  /* 8210D370h */ case   14:  		/* stwu R8, <#[R11 + 4]> */
		/* 8210D370h case   14:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8210D370h case   14:*/		return 0x8210D374;
		  /* 8210D374h */ case   15:  		/* bc 16, CR0_LT, -4 */
		/* 8210D374h case   15:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210D370;  }
		/* 8210D374h case   15:*/		return 0x8210D378;
	}
	return 0x8210D378;
} // Block from 8210D338h-8210D378h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8210D378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D378);
		  /* 8210D378h */ case    0:  		/* rlwinm. R11, R10, 30, 2, 31 */
		/* 8210D378h case    0:*/		cpu::op::rlwinm<1,30,2,31>(regs,&regs.R11,regs.R10);
		/* 8210D378h case    0:*/		return 0x8210D37C;
		  /* 8210D37Ch */ case    1:  		/* addi R10, R7, -4 */
		/* 8210D37Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R7,0xFFFFFFFC);
		/* 8210D37Ch case    1:*/		return 0x8210D380;
		  /* 8210D380h */ case    2:  		/* mr R9, R22 */
		/* 8210D380h case    2:*/		regs.R9 = regs.R22;
		/* 8210D380h case    2:*/		return 0x8210D384;
		  /* 8210D384h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 8210D384h case    3:*/		if ( regs.CR[0].eq ) { return 0x8210D394;  }
		/* 8210D384h case    3:*/		return 0x8210D388;
		  /* 8210D388h */ case    4:  		/* mtspr CTR, R11 */
		/* 8210D388h case    4:*/		regs.CTR = regs.R11;
		/* 8210D388h case    4:*/		return 0x8210D38C;
		  /* 8210D38Ch */ case    5:  		/* stwu R9, <#[R10 + 4]> */
		/* 8210D38Ch case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8210D38Ch case    5:*/		return 0x8210D390;
		  /* 8210D390h */ case    6:  		/* bc 16, CR0_LT, -4 */
		/* 8210D390h case    6:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210D38C;  }
		/* 8210D390h case    6:*/		return 0x8210D394;
	}
	return 0x8210D394;
} // Block from 8210D378h-8210D394h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210D394h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D394( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D394) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D394);
		  /* 8210D394h */ case    0:  		/* addi R6, R1, 112 */
		/* 8210D394h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x70);
		/* 8210D394h case    0:*/		return 0x8210D398;
		  /* 8210D398h */ case    1:  		/* addi R5, R1, 96 */
		/* 8210D398h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 8210D398h case    1:*/		return 0x8210D39C;
		  /* 8210D39Ch */ case    2:  		/* mr R4, R20 */
		/* 8210D39Ch case    2:*/		regs.R4 = regs.R20;
		/* 8210D39Ch case    2:*/		return 0x8210D3A0;
		  /* 8210D3A0h */ case    3:  		/* mr R3, R28 */
		/* 8210D3A0h case    3:*/		regs.R3 = regs.R28;
		/* 8210D3A0h case    3:*/		return 0x8210D3A4;
		  /* 8210D3A4h */ case    4:  		/* bl -52932 */
		/* 8210D3A4h case    4:*/		regs.LR = 0x8210D3A8; return 0x821004E0;
		/* 8210D3A4h case    4:*/		return 0x8210D3A8;
		  /* 8210D3A8h */ case    5:  		/* mr R6, R31 */
		/* 8210D3A8h case    5:*/		regs.R6 = regs.R31;
		/* 8210D3A8h case    5:*/		return 0x8210D3AC;
		  /* 8210D3ACh */ case    6:  		/* addi R4, R1, 96 */
		/* 8210D3ACh case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 8210D3ACh case    6:*/		return 0x8210D3B0;
		  /* 8210D3B0h */ case    7:  		/* lwz R5, <#[R1 + 80]> */
		/* 8210D3B0h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 8210D3B0h case    7:*/		return 0x8210D3B4;
		  /* 8210D3B4h */ case    8:  		/* mr R3, R28 */
		/* 8210D3B4h case    8:*/		regs.R3 = regs.R28;
		/* 8210D3B4h case    8:*/		return 0x8210D3B8;
		  /* 8210D3B8h */ case    9:  		/* bl -53392 */
		/* 8210D3B8h case    9:*/		regs.LR = 0x8210D3BC; return 0x82100328;
		/* 8210D3B8h case    9:*/		return 0x8210D3BC;
	}
	return 0x8210D3BC;
} // Block from 8210D394h-8210D3BCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 8210D3BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D3BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D3BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D3BC);
		  /* 8210D3BCh */ case    0:  		/* addi R27, R27, 1 */
		/* 8210D3BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8210D3BCh case    0:*/		return 0x8210D3C0;
		  /* 8210D3C0h */ case    1:  		/* mr R4, R27 */
		/* 8210D3C0h case    1:*/		regs.R4 = regs.R27;
		/* 8210D3C0h case    1:*/		return 0x8210D3C4;
	}
	return 0x8210D3C4;
} // Block from 8210D3BCh-8210D3C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210D3C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D3C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D3C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D3C4);
		  /* 8210D3C4h */ case    0:  		/* addi R5, R1, 80 */
		/* 8210D3C4h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8210D3C4h case    0:*/		return 0x8210D3C8;
		  /* 8210D3C8h */ case    1:  		/* mr R3, R26 */
		/* 8210D3C8h case    1:*/		regs.R3 = regs.R26;
		/* 8210D3C8h case    1:*/		return 0x8210D3CC;
		  /* 8210D3CCh */ case    2:  		/* bl -70836 */
		/* 8210D3CCh case    2:*/		regs.LR = 0x8210D3D0; return 0x820FBF18;
		/* 8210D3CCh case    2:*/		return 0x8210D3D0;
		  /* 8210D3D0h */ case    3:  		/* or. R31, R3, R3 */
		/* 8210D3D0h case    3:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 8210D3D0h case    3:*/		return 0x8210D3D4;
		  /* 8210D3D4h */ case    4:  		/* bc 4, CR0_EQ, -264 */
		/* 8210D3D4h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8210D2CC;  }
		/* 8210D3D4h case    4:*/		return 0x8210D3D8;
	}
	return 0x8210D3D8;
} // Block from 8210D3C4h-8210D3D8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210D3D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D3D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D3D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D3D8);
		  /* 8210D3D8h */ case    0:  		/* lwz R11, <#[R28 + 12]> */
		/* 8210D3D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000000C) );
		/* 8210D3D8h case    0:*/		return 0x8210D3DC;
		  /* 8210D3DCh */ case    1:  		/* addi R23, R23, 1 */
		/* 8210D3DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 8210D3DCh case    1:*/		return 0x8210D3E0;
		  /* 8210D3E0h */ case    2:  		/* addi R24, R24, 4 */
		/* 8210D3E0h case    2:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x4);
		/* 8210D3E0h case    2:*/		return 0x8210D3E4;
		  /* 8210D3E4h */ case    3:  		/* cmplw CR6, R23, R11 */
		/* 8210D3E4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R11);
		/* 8210D3E4h case    3:*/		return 0x8210D3E8;
		  /* 8210D3E8h */ case    4:  		/* bc 12, CR6_LT, -892 */
		/* 8210D3E8h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210D06C;  }
		/* 8210D3E8h case    4:*/		return 0x8210D3EC;
	}
	return 0x8210D3EC;
} // Block from 8210D3D8h-8210D3ECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210D3ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D3EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D3EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D3EC);
		  /* 8210D3ECh */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 8210D3ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8210D3ECh case    0:*/		return 0x8210D3F0;
		  /* 8210D3F0h */ case    1:  		/* mr R6, R21 */
		/* 8210D3F0h case    1:*/		regs.R6 = regs.R21;
		/* 8210D3F0h case    1:*/		return 0x8210D3F4;
		  /* 8210D3F4h */ case    2:  		/* mr R7, R21 */
		/* 8210D3F4h case    2:*/		regs.R7 = regs.R21;
		/* 8210D3F4h case    2:*/		return 0x8210D3F8;
		  /* 8210D3F8h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8210D3F8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210D3F8h case    3:*/		return 0x8210D3FC;
		  /* 8210D3FCh */ case    4:  		/* bc 4, CR6_GT, 136 */
		/* 8210D3FCh case    4:*/		if ( !regs.CR[6].gt ) { return 0x8210D484;  }
		/* 8210D3FCh case    4:*/		return 0x8210D400;
		  /* 8210D400h */ case    5:  		/* mr R8, R21 */
		/* 8210D400h case    5:*/		regs.R8 = regs.R21;
		/* 8210D400h case    5:*/		return 0x8210D404;
		  /* 8210D404h */ case    6:  		/* lwz R11, <#[R28 + 20]> */
		/* 8210D404h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 8210D404h case    6:*/		return 0x8210D408;
		  /* 8210D408h */ case    7:  		/* lwz R9, <#[R28 + 16]> */
		/* 8210D408h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000010) );
		/* 8210D408h case    7:*/		return 0x8210D40C;
		  /* 8210D40Ch */ case    8:  		/* lwz R10, <#[R28 + 120]> */
		/* 8210D40Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000078) );
		/* 8210D40Ch case    8:*/		return 0x8210D410;
		  /* 8210D410h */ case    9:  		/* lwzx R11, <#[R8 + R11]> */
		/* 8210D410h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8210D410h case    9:*/		return 0x8210D414;
		  /* 8210D414h */ case   10:  		/* lwz R5, <#[R11 + 4]> */
		/* 8210D414h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000004) );
		/* 8210D414h case   10:*/		return 0x8210D418;
		  /* 8210D418h */ case   11:  		/* rlwinm R4, R5, 2, 0, 29 */
		/* 8210D418h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R5);
		/* 8210D418h case   11:*/		return 0x8210D41C;
		  /* 8210D41Ch */ case   12:  		/* cmplw CR6, R10, R5 */
		/* 8210D41Ch case   12:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R5);
		/* 8210D41Ch case   12:*/		return 0x8210D420;
		  /* 8210D420h */ case   13:  		/* lwzx R9, <#[R4 + R9]> */
		/* 8210D420h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + regs.R9 + 0x00000000) );
		/* 8210D420h case   13:*/		return 0x8210D424;
		  /* 8210D424h */ case   14:  		/* bc 4, CR6_EQ, 28 */
		/* 8210D424h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8210D440;  }
		/* 8210D424h case   14:*/		return 0x8210D428;
		  /* 8210D428h */ case   15:  		/* lwz R5, <#[R11 + 12]> */
		/* 8210D428h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210D428h case   15:*/		return 0x8210D42C;
		  /* 8210D42Ch */ case   16:  		/* cmpwi CR6, R5, -1 */
		/* 8210D42Ch case   16:*/		cpu::op::cmpwi<6>(regs,regs.R5,0xFFFFFFFF);
		/* 8210D42Ch case   16:*/		return 0x8210D430;
		  /* 8210D430h */ case   17:  		/* bc 4, CR6_EQ, 16 */
		/* 8210D430h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8210D440;  }
		/* 8210D430h case   17:*/		return 0x8210D434;
		  /* 8210D434h */ case   18:  		/* lwz R10, <#[R28 + 116]> */
		/* 8210D434h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000074) );
		/* 8210D434h case   18:*/		return 0x8210D438;
		  /* 8210D438h */ case   19:  		/* stw R10, <#[R11 + 4]> */
		/* 8210D438h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210D438h case   19:*/		return 0x8210D43C;
		  /* 8210D43Ch */ case   20:  		/* b 52 */
		/* 8210D43Ch case   20:*/		return 0x8210D470;
		/* 8210D43Ch case   20:*/		return 0x8210D440;
	}
	return 0x8210D440;
} // Block from 8210D3ECh-8210D440h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8210D440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D440);
		  /* 8210D440h */ case    0:  		/* lwz R9, <#[R9 + 4]> */
		/* 8210D440h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 8210D440h case    0:*/		return 0x8210D444;
		  /* 8210D444h */ case    1:  		/* rlwinm. R5, R9, 0, 23, 23 */
		/* 8210D444h case    1:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R5,regs.R9);
		/* 8210D444h case    1:*/		return 0x8210D448;
		  /* 8210D448h */ case    2:  		/* bc 12, CR0_EQ, 40 */
		/* 8210D448h case    2:*/		if ( regs.CR[0].eq ) { return 0x8210D470;  }
		/* 8210D448h case    2:*/		return 0x8210D44C;
		  /* 8210D44Ch */ case    3:  		/* rlwinm. R5, R9, 0, 25, 25 */
		/* 8210D44Ch case    3:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R5,regs.R9);
		/* 8210D44Ch case    3:*/		return 0x8210D450;
		  /* 8210D450h */ case    4:  		/* bc 12, CR0_EQ, 32 */
		/* 8210D450h case    4:*/		if ( regs.CR[0].eq ) { return 0x8210D470;  }
		/* 8210D450h case    4:*/		return 0x8210D454;
		  /* 8210D454h */ case    5:  		/* rlwinm. R9, R9, 0, 20, 20 */
		/* 8210D454h case    5:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R9,regs.R9);
		/* 8210D454h case    5:*/		return 0x8210D458;
		  /* 8210D458h */ case    6:  		/* bc 4, CR0_EQ, 24 */
		/* 8210D458h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8210D470;  }
		/* 8210D458h case    6:*/		return 0x8210D45C;
		  /* 8210D45Ch */ case    7:  		/* lwz R9, <#[R11 + 8]> */
		/* 8210D45Ch case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8210D45Ch case    7:*/		return 0x8210D460;
		  /* 8210D460h */ case    8:  		/* stw R10, <#[R11 + 4]> */
		/* 8210D460h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210D460h case    8:*/		return 0x8210D464;
		  /* 8210D464h */ case    9:  		/* cmpwi CR6, R9, -1 */
		/* 8210D464h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 8210D464h case    9:*/		return 0x8210D468;
		  /* 8210D468h */ case   10:  		/* bc 12, CR6_EQ, 8 */
		/* 8210D468h case   10:*/		if ( regs.CR[6].eq ) { return 0x8210D470;  }
		/* 8210D468h case   10:*/		return 0x8210D46C;
		  /* 8210D46Ch */ case   11:  		/* mr R6, R19 */
		/* 8210D46Ch case   11:*/		regs.R6 = regs.R19;
		/* 8210D46Ch case   11:*/		return 0x8210D470;
	}
	return 0x8210D470;
} // Block from 8210D440h-8210D470h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8210D470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D470);
		  /* 8210D470h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 8210D470h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8210D470h case    0:*/		return 0x8210D474;
		  /* 8210D474h */ case    1:  		/* addi R7, R7, 1 */
		/* 8210D474h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8210D474h case    1:*/		return 0x8210D478;
		  /* 8210D478h */ case    2:  		/* addi R8, R8, 4 */
		/* 8210D478h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 8210D478h case    2:*/		return 0x8210D47C;
		  /* 8210D47Ch */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 8210D47Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 8210D47Ch case    3:*/		return 0x8210D480;
		  /* 8210D480h */ case    4:  		/* bc 12, CR6_LT, -124 */
		/* 8210D480h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210D404;  }
		/* 8210D480h case    4:*/		return 0x8210D484;
	}
	return 0x8210D484;
} // Block from 8210D470h-8210D484h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210D484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D484);
		  /* 8210D484h */ case    0:  		/* lwz R11, <#[R28 + 120]> */
		/* 8210D484h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000078) );
		/* 8210D484h case    0:*/		return 0x8210D488;
		  /* 8210D488h */ case    1:  		/* cmpwi CR6, R6, 0 */
		/* 8210D488h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 8210D488h case    1:*/		return 0x8210D48C;
		  /* 8210D48Ch */ case    2:  		/* lwz R10, <#[R28 + 16]> */
		/* 8210D48Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000010) );
		/* 8210D48Ch case    2:*/		return 0x8210D490;
		  /* 8210D490h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210D490h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210D490h case    3:*/		return 0x8210D494;
		  /* 8210D494h */ case    4:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210D494h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210D494h case    4:*/		return 0x8210D498;
		  /* 8210D498h */ case    5:  		/* lwz R10, <#[R11 + 4]> */
		/* 8210D498h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210D498h case    5:*/		return 0x8210D49C;
		  /* 8210D49Ch */ case    6:  		/* ori R10, R10, 64 */
		/* 8210D49Ch case    6:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x40);
		/* 8210D49Ch case    6:*/		return 0x8210D4A0;
		  /* 8210D4A0h */ case    7:  		/* stw R10, <#[R11 + 4]> */
		/* 8210D4A0h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210D4A0h case    7:*/		return 0x8210D4A4;
		  /* 8210D4A4h */ case    8:  		/* bc 12, CR6_EQ, 32 */
		/* 8210D4A4h case    8:*/		if ( regs.CR[6].eq ) { return 0x8210D4C4;  }
		/* 8210D4A4h case    8:*/		return 0x8210D4A8;
		  /* 8210D4A8h */ case    9:  		/* lwz R11, <#[R28 + 120]> */
		/* 8210D4A8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000078) );
		/* 8210D4A8h case    9:*/		return 0x8210D4AC;
		  /* 8210D4ACh */ case   10:  		/* lwz R10, <#[R28 + 16]> */
		/* 8210D4ACh case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000010) );
		/* 8210D4ACh case   10:*/		return 0x8210D4B0;
		  /* 8210D4B0h */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210D4B0h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210D4B0h case   11:*/		return 0x8210D4B4;
		  /* 8210D4B4h */ case   12:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210D4B4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210D4B4h case   12:*/		return 0x8210D4B8;
		  /* 8210D4B8h */ case   13:  		/* lwz R10, <#[R11 + 4]> */
		/* 8210D4B8h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210D4B8h case   13:*/		return 0x8210D4BC;
		  /* 8210D4BCh */ case   14:  		/* ori R10, R10, 1024 */
		/* 8210D4BCh case   14:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x400);
		/* 8210D4BCh case   14:*/		return 0x8210D4C0;
		  /* 8210D4C0h */ case   15:  		/* stw R10, <#[R11 + 4]> */
		/* 8210D4C0h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210D4C0h case   15:*/		return 0x8210D4C4;
	}
	return 0x8210D4C4;
} // Block from 8210D484h-8210D4C4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8210D4C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D4C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D4C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D4C4);
		  /* 8210D4C4h */ case    0:  		/* lwz R11, <#[R28 + 120]> */
		/* 8210D4C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000078) );
		/* 8210D4C4h case    0:*/		return 0x8210D4C8;
		  /* 8210D4C8h */ case    1:  		/* mr R8, R21 */
		/* 8210D4C8h case    1:*/		regs.R8 = regs.R21;
		/* 8210D4C8h case    1:*/		return 0x8210D4CC;
		  /* 8210D4CCh */ case    2:  		/* lwz R10, <#[R28 + 16]> */
		/* 8210D4CCh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000010) );
		/* 8210D4CCh case    2:*/		return 0x8210D4D0;
		  /* 8210D4D0h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210D4D0h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210D4D0h case    3:*/		return 0x8210D4D4;
		  /* 8210D4D4h */ case    4:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210D4D4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210D4D4h case    4:*/		return 0x8210D4D8;
		  /* 8210D4D8h */ case    5:  		/* stw R21, <#[R11 + 8]> */
		/* 8210D4D8h case    5:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R11 + 0x00000008) );
		/* 8210D4D8h case    5:*/		return 0x8210D4DC;
		  /* 8210D4DCh */ case    6:  		/* lwz R11, <#[R28 + 8]> */
		/* 8210D4DCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8210D4DCh case    6:*/		return 0x8210D4E0;
		  /* 8210D4E0h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8210D4E0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210D4E0h case    7:*/		return 0x8210D4E4;
		  /* 8210D4E4h */ case    8:  		/* bc 4, CR6_GT, 100 */
		/* 8210D4E4h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8210D548;  }
		/* 8210D4E4h case    8:*/		return 0x8210D4E8;
		  /* 8210D4E8h */ case    9:  		/* mr R9, R21 */
		/* 8210D4E8h case    9:*/		regs.R9 = regs.R21;
		/* 8210D4E8h case    9:*/		return 0x8210D4EC;
		  /* 8210D4ECh */ case   10:  		/* lwz R11, <#[R28 + 20]> */
		/* 8210D4ECh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 8210D4ECh case   10:*/		return 0x8210D4F0;
		  /* 8210D4F0h */ case   11:  		/* lwz R10, <#[R28 + 120]> */
		/* 8210D4F0h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000078) );
		/* 8210D4F0h case   11:*/		return 0x8210D4F4;
		  /* 8210D4F4h */ case   12:  		/* lwzx R11, <#[R9 + R11]> */
		/* 8210D4F4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8210D4F4h case   12:*/		return 0x8210D4F8;
		  /* 8210D4F8h */ case   13:  		/* lwz R7, <#[R11 + 4]> */
		/* 8210D4F8h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 8210D4F8h case   13:*/		return 0x8210D4FC;
		  /* 8210D4FCh */ case   14:  		/* cmplw CR6, R10, R7 */
		/* 8210D4FCh case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 8210D4FCh case   14:*/		return 0x8210D500;
		  /* 8210D500h */ case   15:  		/* bc 4, CR6_EQ, 52 */
		/* 8210D500h case   15:*/		if ( !regs.CR[6].eq ) { return 0x8210D534;  }
		/* 8210D500h case   15:*/		return 0x8210D504;
		  /* 8210D504h */ case   16:  		/* lwz R7, <#[R11 + 8]> */
		/* 8210D504h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 8210D504h case   16:*/		return 0x8210D508;
		  /* 8210D508h */ case   17:  		/* cmpwi CR6, R7, -1 */
		/* 8210D508h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R7,0xFFFFFFFF);
		/* 8210D508h case   17:*/		return 0x8210D50C;
		  /* 8210D50Ch */ case   18:  		/* bc 4, CR6_EQ, 40 */
		/* 8210D50Ch case   18:*/		if ( !regs.CR[6].eq ) { return 0x8210D534;  }
		/* 8210D50Ch case   18:*/		return 0x8210D510;
		  /* 8210D510h */ case   19:  		/* lwz R7, <#[R28 + 16]> */
		/* 8210D510h case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R28 + 0x00000010) );
		/* 8210D510h case   19:*/		return 0x8210D514;
		  /* 8210D514h */ case   20:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210D514h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210D514h case   20:*/		return 0x8210D518;
		  /* 8210D518h */ case   21:  		/* lwz R11, <#[R11 + 12]> */
		/* 8210D518h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210D518h case   21:*/		return 0x8210D51C;
		  /* 8210D51Ch */ case   22:  		/* lwzx R10, <#[R10 + R7]> */
		/* 8210D51Ch case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 8210D51Ch case   22:*/		return 0x8210D520;
		  /* 8210D520h */ case   23:  		/* lwz R7, <#[R10 + 8]> */
		/* 8210D520h case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000008) );
		/* 8210D520h case   23:*/		return 0x8210D524;
		  /* 8210D524h */ case   24:  		/* cmplw CR6, R7, R11 */
		/* 8210D524h case   24:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 8210D524h case   24:*/		return 0x8210D528;
	}
	return 0x8210D528;
} // Block from 8210D4C4h-8210D528h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8210D528h
// Function '?SplitRegisters@CProgram@D3DXShader@@IAAJH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D528);
		  /* 8210D528h */ case    0:  		/* bc 12, CR6_GT, 12 */
		/* 8210D528h case    0:*/		if ( regs.CR[6].gt ) { return 0x8210D534;  }
		/* 8210D528h case    0:*/		return 0x8210D52C;
		  /* 8210D52Ch */ case    1:  		/* addi R11, R11, 1 */
		/* 8210D52Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210D52Ch case    1:*/		return 0x8210D530;
		  /* 8210D530h */ case    2:  		/* stw R11, <#[R10 + 8]> */
		/* 8210D530h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8210D530h case    2:*/		return 0x8210D534;
	}
	return 0x8210D534;
} // Block from 8210D528h-8210D534h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210D534h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D534( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D534) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D534);
		  /* 8210D534h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 8210D534h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8210D534h case    0:*/		return 0x8210D538;
		  /* 8210D538h */ case    1:  		/* addi R8, R8, 1 */
		/* 8210D538h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8210D538h case    1:*/		return 0x8210D53C;
		  /* 8210D53Ch */ case    2:  		/* addi R9, R9, 4 */
		/* 8210D53Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8210D53Ch case    2:*/		return 0x8210D540;
		  /* 8210D540h */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 8210D540h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8210D540h case    3:*/		return 0x8210D544;
		  /* 8210D544h */ case    4:  		/* bc 12, CR6_LT, -88 */
		/* 8210D544h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210D4EC;  }
		/* 8210D544h case    4:*/		return 0x8210D548;
	}
	return 0x8210D548;
} // Block from 8210D534h-8210D548h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210D548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D548);
		  /* 8210D548h */ case    0:  		/* cmpwi CR6, R18, 0 */
		/* 8210D548h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R18,0x00000000);
		/* 8210D548h case    0:*/		return 0x8210D54C;
		  /* 8210D54Ch */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8210D54Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8210D558;  }
		/* 8210D54Ch case    1:*/		return 0x8210D550;
		  /* 8210D550h */ case    2:  		/* mr R3, R28 */
		/* 8210D550h case    2:*/		regs.R3 = regs.R28;
		/* 8210D550h case    2:*/		return 0x8210D554;
		  /* 8210D554h */ case    3:  		/* bl -24044 */
		/* 8210D554h case    3:*/		regs.LR = 0x8210D558; return 0x82107768;
		/* 8210D554h case    3:*/		return 0x8210D558;
	}
	return 0x8210D558;
} // Block from 8210D548h-8210D558h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210D558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D558);
		  /* 8210D558h */ case    0:  		/* stw R19, <#[R28 + 220]> */
		/* 8210D558h case    0:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R28 + 0x000000DC) );
		/* 8210D558h case    0:*/		return 0x8210D55C;
		  /* 8210D55Ch */ case    1:  		/* lis R4, 9345 */
		/* 8210D55Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210D55Ch case    1:*/		return 0x8210D560;
		  /* 8210D560h */ case    2:  		/* mr R3, R20 */
		/* 8210D560h case    2:*/		regs.R3 = regs.R20;
		/* 8210D560h case    2:*/		return 0x8210D564;
		  /* 8210D564h */ case    3:  		/* bl -545324 */
		/* 8210D564h case    3:*/		regs.LR = 0x8210D568; return 0x82088338;
		/* 8210D564h case    3:*/		return 0x8210D568;
		  /* 8210D568h */ case    4:  		/* li R3, 0 */
		/* 8210D568h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8210D568h case    4:*/		return 0x8210D56C;
	}
	return 0x8210D56C;
} // Block from 8210D558h-8210D56Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210D56Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D56C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D56C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D56C);
		  /* 8210D56Ch */ case    0:  		/* addi R1, R1, 272 */
		/* 8210D56Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x110);
		/* 8210D56Ch case    0:*/		return 0x8210D570;
		  /* 8210D570h */ case    1:  		/* b -508656 */
		/* 8210D570h case    1:*/		return 0x82091280;
		/* 8210D570h case    1:*/		return 0x8210D574;
		  /* 8210D574h */ case    2:  		/* nop */
		/* 8210D574h case    2:*/		cpu::op::nop();
		/* 8210D574h case    2:*/		return 0x8210D578;
	}
	return 0x8210D578;
} // Block from 8210D56Ch-8210D578h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210D578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D578);
		  /* 8210D578h */ case    0:  		/* mfspr R12, LR */
		/* 8210D578h case    0:*/		regs.R12 = regs.LR;
		/* 8210D578h case    0:*/		return 0x8210D57C;
		  /* 8210D57Ch */ case    1:  		/* bl -508728 */
		/* 8210D57Ch case    1:*/		regs.LR = 0x8210D580; return 0x82091244;
		/* 8210D57Ch case    1:*/		return 0x8210D580;
		  /* 8210D580h */ case    2:  		/* stwu R1, <#[R1 - 272]> */
		/* 8210D580h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEF0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEF0);
		/* 8210D580h case    2:*/		return 0x8210D584;
		  /* 8210D584h */ case    3:  		/* li R26, 0 */
		/* 8210D584h case    3:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8210D584h case    3:*/		return 0x8210D588;
		  /* 8210D588h */ case    4:  		/* mr R31, R3 */
		/* 8210D588h case    4:*/		regs.R31 = regs.R3;
		/* 8210D588h case    4:*/		return 0x8210D58C;
		  /* 8210D58Ch */ case    5:  		/* mr R23, R26 */
		/* 8210D58Ch case    5:*/		regs.R23 = regs.R26;
		/* 8210D58Ch case    5:*/		return 0x8210D590;
		  /* 8210D590h */ case    6:  		/* mr R25, R26 */
		/* 8210D590h case    6:*/		regs.R25 = regs.R26;
		/* 8210D590h case    6:*/		return 0x8210D594;
		  /* 8210D594h */ case    7:  		/* mr R24, R26 */
		/* 8210D594h case    7:*/		regs.R24 = regs.R26;
		/* 8210D594h case    7:*/		return 0x8210D598;
		  /* 8210D598h */ case    8:  		/* bl -47416 */
		/* 8210D598h case    8:*/		regs.LR = 0x8210D59C; return 0x82101C60;
		/* 8210D598h case    8:*/		return 0x8210D59C;
		  /* 8210D59Ch */ case    9:  		/* or. R30, R3, R3 */
		/* 8210D59Ch case    9:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 8210D59Ch case    9:*/		return 0x8210D5A0;
		  /* 8210D5A0h */ case   10:  		/* bc 12, CR0_LT, 1112 */
		/* 8210D5A0h case   10:*/		if ( regs.CR[0].lt ) { return 0x8210D9F8;  }
		/* 8210D5A0h case   10:*/		return 0x8210D5A4;
		  /* 8210D5A4h */ case   11:  		/* mr R3, R31 */
		/* 8210D5A4h case   11:*/		regs.R3 = regs.R31;
		/* 8210D5A4h case   11:*/		return 0x8210D5A8;
		  /* 8210D5A8h */ case   12:  		/* bl -30024 */
		/* 8210D5A8h case   12:*/		regs.LR = 0x8210D5AC; return 0x82106060;
		/* 8210D5A8h case   12:*/		return 0x8210D5AC;
		  /* 8210D5ACh */ case   13:  		/* or. R30, R3, R3 */
		/* 8210D5ACh case   13:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 8210D5ACh case   13:*/		return 0x8210D5B0;
		  /* 8210D5B0h */ case   14:  		/* bc 12, CR0_LT, 1096 */
		/* 8210D5B0h case   14:*/		if ( regs.CR[0].lt ) { return 0x8210D9F8;  }
		/* 8210D5B0h case   14:*/		return 0x8210D5B4;
		  /* 8210D5B4h */ case   15:  		/* lwz R11, <#[R31 + 108]> */
		/* 8210D5B4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 8210D5B4h case   15:*/		return 0x8210D5B8;
		  /* 8210D5B8h */ case   16:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 8210D5B8h case   16:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 8210D5B8h case   16:*/		return 0x8210D5BC;
		  /* 8210D5BCh */ case   17:  		/* bc 4, CR0_EQ, 12 */
		/* 8210D5BCh case   17:*/		if ( !regs.CR[0].eq ) { return 0x8210D5C8;  }
		/* 8210D5BCh case   17:*/		return 0x8210D5C0;
		  /* 8210D5C0h */ case   18:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 8210D5C0h case   18:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 8210D5C0h case   18:*/		return 0x8210D5C4;
		  /* 8210D5C4h */ case   19:  		/* bc 12, CR0_EQ, 228 */
		/* 8210D5C4h case   19:*/		if ( regs.CR[0].eq ) { return 0x8210D6A8;  }
		/* 8210D5C4h case   19:*/		return 0x8210D5C8;
	}
	return 0x8210D5C8;
} // Block from 8210D578h-8210D5C8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8210D5C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D5C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D5C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D5C8);
		  /* 8210D5C8h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210D5C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210D5C8h case    0:*/		return 0x8210D5CC;
		  /* 8210D5CCh */ case    1:  		/* mr R10, R26 */
		/* 8210D5CCh case    1:*/		regs.R10 = regs.R26;
		/* 8210D5CCh case    1:*/		return 0x8210D5D0;
		  /* 8210D5D0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8210D5D0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210D5D0h case    2:*/		return 0x8210D5D4;
		  /* 8210D5D4h */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 8210D5D4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8210D5FC;  }
		/* 8210D5D4h case    3:*/		return 0x8210D5D8;
		  /* 8210D5D8h */ case    4:  		/* mr R9, R26 */
		/* 8210D5D8h case    4:*/		regs.R9 = regs.R26;
		/* 8210D5D8h case    4:*/		return 0x8210D5DC;
		  /* 8210D5DCh */ case    5:  		/* lwz R11, <#[R31 + 24]> */
		/* 8210D5DCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8210D5DCh case    5:*/		return 0x8210D5E0;
		  /* 8210D5E0h */ case    6:  		/* addi R10, R10, 1 */
		/* 8210D5E0h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210D5E0h case    6:*/		return 0x8210D5E4;
		  /* 8210D5E4h */ case    7:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210D5E4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210D5E4h case    7:*/		return 0x8210D5E8;
		  /* 8210D5E8h */ case    8:  		/* addi R9, R9, 4 */
		/* 8210D5E8h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8210D5E8h case    8:*/		return 0x8210D5EC;
		  /* 8210D5ECh */ case    9:  		/* stw R26, <#[R11 + 44]> */
		/* 8210D5ECh case    9:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x0000002C) );
		/* 8210D5ECh case    9:*/		return 0x8210D5F0;
		  /* 8210D5F0h */ case   10:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210D5F0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210D5F0h case   10:*/		return 0x8210D5F4;
		  /* 8210D5F4h */ case   11:  		/* cmplw CR6, R10, R11 */
		/* 8210D5F4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8210D5F4h case   11:*/		return 0x8210D5F8;
		  /* 8210D5F8h */ case   12:  		/* bc 12, CR6_LT, -28 */
		/* 8210D5F8h case   12:*/		if ( regs.CR[6].lt ) { return 0x8210D5DC;  }
		/* 8210D5F8h case   12:*/		return 0x8210D5FC;
	}
	return 0x8210D5FC;
} // Block from 8210D5C8h-8210D5FCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 8210D5FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D5FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D5FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D5FC);
		  /* 8210D5FCh */ case    0:  		/* mr R5, R11 */
		/* 8210D5FCh case    0:*/		regs.R5 = regs.R11;
		/* 8210D5FCh case    0:*/		return 0x8210D600;
		  /* 8210D600h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 8210D600h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8210D600h case    1:*/		return 0x8210D604;
		  /* 8210D604h */ case    2:  		/* bc 12, CR0_EQ, 164 */
		/* 8210D604h case    2:*/		if ( regs.CR[0].eq ) { return 0x8210D6A8;  }
		/* 8210D604h case    2:*/		return 0x8210D608;
		  /* 8210D608h */ case    3:  		/* rlwinm R6, R11, 2, 0, 29 */
		/* 8210D608h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R11);
		/* 8210D608h case    3:*/		return 0x8210D60C;
		  /* 8210D60Ch */ case    4:  		/* lwz R11, <#[R31 + 24]> */
		/* 8210D60Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8210D60Ch case    4:*/		return 0x8210D610;
		  /* 8210D610h */ case    5:  		/* addi R6, R6, -4 */
		/* 8210D610h case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0xFFFFFFFC);
		/* 8210D610h case    5:*/		return 0x8210D614;
		  /* 8210D614h */ case    6:  		/* addi R5, R5, -1 */
		/* 8210D614h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0xFFFFFFFF);
		/* 8210D614h case    6:*/		return 0x8210D618;
		  /* 8210D618h */ case    7:  		/* lwzx R11, <#[R11 + R6]> */
		/* 8210D618h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 8210D618h case    7:*/		return 0x8210D61C;
		  /* 8210D61Ch */ case    8:  		/* lwz R10, <#[R11]> */
		/* 8210D61Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210D61Ch case    8:*/		return 0x8210D620;
		  /* 8210D620h */ case    9:  		/* rlwinm. R9, R10, 0, 0, 11 */
		/* 8210D620h case    9:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R9,regs.R10);
		/* 8210D620h case    9:*/		return 0x8210D624;
		  /* 8210D624h */ case   10:  		/* bc 12, CR0_EQ, 124 */
		/* 8210D624h case   10:*/		if ( regs.CR[0].eq ) { return 0x8210D6A0;  }
		/* 8210D624h case   10:*/		return 0x8210D628;
		  /* 8210D628h */ case   11:  		/* rlwinm R10, R10, 0, 0, 3 */
		/* 8210D628h case   11:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R10,regs.R10);
		/* 8210D628h case   11:*/		return 0x8210D62C;
		  /* 8210D62Ch */ case   12:  		/* lwz R8, <#[R11 + 44]> */
		/* 8210D62Ch case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000002C) );
		/* 8210D62Ch case   12:*/		return 0x8210D630;
		  /* 8210D630h */ case   13:  		/* lis R7, 24576 */
		/* 8210D630h case   13:*/		cpu::op::lis<0>(regs,&regs.R7,0x6000);
		/* 8210D630h case   13:*/		return 0x8210D634;
		  /* 8210D634h */ case   14:  		/* cmplw CR6, R10, R7 */
		/* 8210D634h case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 8210D634h case   14:*/		return 0x8210D638;
		  /* 8210D638h */ case   15:  		/* bc 12, CR6_EQ, 16 */
		/* 8210D638h case   15:*/		if ( regs.CR[6].eq ) { return 0x8210D648;  }
		/* 8210D638h case   15:*/		return 0x8210D63C;
		  /* 8210D63Ch */ case   16:  		/* lis R10, 4352 */
		/* 8210D63Ch case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0x1100);
		/* 8210D63Ch case   16:*/		return 0x8210D640;
		  /* 8210D640h */ case   17:  		/* cmplw CR6, R9, R10 */
		/* 8210D640h case   17:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 8210D640h case   17:*/		return 0x8210D644;
		  /* 8210D644h */ case   18:  		/* bc 4, CR6_EQ, 16 */
		/* 8210D644h case   18:*/		if ( !regs.CR[6].eq ) { return 0x8210D654;  }
		/* 8210D644h case   18:*/		return 0x8210D648;
	}
	return 0x8210D648;
} // Block from 8210D5FCh-8210D648h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8210D648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D648);
		  /* 8210D648h */ case    0:  		/* addi R10, R8, 1 */
		/* 8210D648h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R8,0x1);
		/* 8210D648h case    0:*/		return 0x8210D64C;
		  /* 8210D64Ch */ case    1:  		/* addi R8, R8, 2 */
		/* 8210D64Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x2);
		/* 8210D64Ch case    1:*/		return 0x8210D650;
		  /* 8210D650h */ case    2:  		/* stw R10, <#[R11 + 44]> */
		/* 8210D650h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000002C) );
		/* 8210D650h case    2:*/		return 0x8210D654;
	}
	return 0x8210D654;
} // Block from 8210D648h-8210D654h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210D654h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D654( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D654) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D654);
		  /* 8210D654h */ case    0:  		/* lwz R10, <#[R11 + 20]> */
		/* 8210D654h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 8210D654h case    0:*/		return 0x8210D658;
		  /* 8210D658h */ case    1:  		/* mr R7, R26 */
		/* 8210D658h case    1:*/		regs.R7 = regs.R26;
		/* 8210D658h case    1:*/		return 0x8210D65C;
		  /* 8210D65Ch */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 8210D65Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8210D65Ch case    2:*/		return 0x8210D660;
		  /* 8210D660h */ case    3:  		/* bc 4, CR6_GT, 64 */
		/* 8210D660h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210D6A0;  }
		/* 8210D660h case    3:*/		return 0x8210D664;
		  /* 8210D664h */ case    4:  		/* mr R9, R26 */
		/* 8210D664h case    4:*/		regs.R9 = regs.R26;
		/* 8210D664h case    4:*/		return 0x8210D668;
		  /* 8210D668h */ case    5:  		/* lwz R10, <#[R11 + 24]> */
		/* 8210D668h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 8210D668h case    5:*/		return 0x8210D66C;
		  /* 8210D66Ch */ case    6:  		/* lwz R4, <#[R31 + 24]> */
		/* 8210D66Ch case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 8210D66Ch case    6:*/		return 0x8210D670;
		  /* 8210D670h */ case    7:  		/* lwzx R10, <#[R9 + R10]> */
		/* 8210D670h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210D670h case    7:*/		return 0x8210D674;
		  /* 8210D674h */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210D674h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210D674h case    8:*/		return 0x8210D678;
		  /* 8210D678h */ case    9:  		/* lwzx R10, <#[R10 + R4]> */
		/* 8210D678h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 8210D678h case    9:*/		return 0x8210D67C;
		  /* 8210D67Ch */ case   10:  		/* lwz R4, <#[R10 + 44]> */
		/* 8210D67Ch case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x0000002C) );
		/* 8210D67Ch case   10:*/		return 0x8210D680;
		  /* 8210D680h */ case   11:  		/* cmplw CR6, R4, R8 */
		/* 8210D680h case   11:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R8);
		/* 8210D680h case   11:*/		return 0x8210D684;
		  /* 8210D684h */ case   12:  		/* bc 4, CR6_LT, 8 */
		/* 8210D684h case   12:*/		if ( !regs.CR[6].lt ) { return 0x8210D68C;  }
		/* 8210D684h case   12:*/		return 0x8210D688;
		  /* 8210D688h */ case   13:  		/* stw R8, <#[R10 + 44]> */
		/* 8210D688h case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x0000002C) );
		/* 8210D688h case   13:*/		return 0x8210D68C;
	}
	return 0x8210D68C;
} // Block from 8210D654h-8210D68Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8210D68Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D68C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D68C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D68C);
		  /* 8210D68Ch */ case    0:  		/* lwz R10, <#[R11 + 20]> */
		/* 8210D68Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 8210D68Ch case    0:*/		return 0x8210D690;
		  /* 8210D690h */ case    1:  		/* addi R7, R7, 1 */
		/* 8210D690h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8210D690h case    1:*/		return 0x8210D694;
		  /* 8210D694h */ case    2:  		/* addi R9, R9, 4 */
		/* 8210D694h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8210D694h case    2:*/		return 0x8210D698;
		  /* 8210D698h */ case    3:  		/* cmplw CR6, R7, R10 */
		/* 8210D698h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 8210D698h case    3:*/		return 0x8210D69C;
		  /* 8210D69Ch */ case    4:  		/* bc 12, CR6_LT, -52 */
		/* 8210D69Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x8210D668;  }
		/* 8210D69Ch case    4:*/		return 0x8210D6A0;
	}
	return 0x8210D6A0;
} // Block from 8210D68Ch-8210D6A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210D6A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D6A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D6A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D6A0);
		  /* 8210D6A0h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 8210D6A0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8210D6A0h case    0:*/		return 0x8210D6A4;
		  /* 8210D6A4h */ case    1:  		/* bc 4, CR6_EQ, -152 */
		/* 8210D6A4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210D60C;  }
		/* 8210D6A4h case    1:*/		return 0x8210D6A8;
	}
	return 0x8210D6A8;
} // Block from 8210D6A0h-8210D6A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210D6A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D6A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D6A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D6A8);
		  /* 8210D6A8h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210D6A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210D6A8h case    0:*/		return 0x8210D6AC;
		  /* 8210D6ACh */ case    1:  		/* mr R4, R26 */
		/* 8210D6ACh case    1:*/		regs.R4 = regs.R26;
		/* 8210D6ACh case    1:*/		return 0x8210D6B0;
		  /* 8210D6B0h */ case    2:  		/* mr R5, R26 */
		/* 8210D6B0h case    2:*/		regs.R5 = regs.R26;
		/* 8210D6B0h case    2:*/		return 0x8210D6B4;
		  /* 8210D6B4h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8210D6B4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210D6B4h case    3:*/		return 0x8210D6B8;
		  /* 8210D6B8h */ case    4:  		/* bc 12, CR6_EQ, 180 */
		/* 8210D6B8h case    4:*/		if ( regs.CR[6].eq ) { return 0x8210D76C;  }
		/* 8210D6B8h case    4:*/		return 0x8210D6BC;
		  /* 8210D6BCh */ case    5:  		/* mr R6, R26 */
		/* 8210D6BCh case    5:*/		regs.R6 = regs.R26;
		/* 8210D6BCh case    5:*/		return 0x8210D6C0;
		  /* 8210D6C0h */ case    6:  		/* lwz R11, <#[R31 + 24]> */
		/* 8210D6C0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8210D6C0h case    6:*/		return 0x8210D6C4;
		  /* 8210D6C4h */ case    7:  		/* lwzx R11, <#[R11 + R6]> */
		/* 8210D6C4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 8210D6C4h case    7:*/		return 0x8210D6C8;
		  /* 8210D6C8h */ case    8:  		/* lwz R10, <#[R11]> */
		/* 8210D6C8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210D6C8h case    8:*/		return 0x8210D6CC;
		  /* 8210D6CCh */ case    9:  		/* rlwinm. R7, R10, 0, 0, 11 */
		/* 8210D6CCh case    9:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R7,regs.R10);
		/* 8210D6CCh case    9:*/		return 0x8210D6D0;
		  /* 8210D6D0h */ case   10:  		/* bc 12, CR0_EQ, 136 */
		/* 8210D6D0h case   10:*/		if ( regs.CR[0].eq ) { return 0x8210D758;  }
		/* 8210D6D0h case   10:*/		return 0x8210D6D4;
		  /* 8210D6D4h */ case   11:  		/* lwz R10, <#[R11 + 16]> */
		/* 8210D6D4h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 8210D6D4h case   11:*/		return 0x8210D6D8;
		  /* 8210D6D8h */ case   12:  		/* lwz R9, <#[R31 + 20]> */
		/* 8210D6D8h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 8210D6D8h case   12:*/		return 0x8210D6DC;
		  /* 8210D6DCh */ case   13:  		/* lwz R3, <#[R31 + 16]> */
		/* 8210D6DCh case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8210D6DCh case   13:*/		return 0x8210D6E0;
		  /* 8210D6E0h */ case   14:  		/* lwz R10, <#[R10]> */
		/* 8210D6E0h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 8210D6E0h case   14:*/		return 0x8210D6E4;
		  /* 8210D6E4h */ case   15:  		/* rlwinm R8, R10, 2, 0, 29 */
		/* 8210D6E4h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R10);
		/* 8210D6E4h case   15:*/		return 0x8210D6E8;
		  /* 8210D6E8h */ case   16:  		/* lwzx R8, <#[R8 + R9]> */
		/* 8210D6E8h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 8210D6E8h case   16:*/		return 0x8210D6EC;
		  /* 8210D6ECh */ case   17:  		/* lwz R30, <#[R8 + 4]> */
		/* 8210D6ECh case   17:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R8 + 0x00000004) );
		/* 8210D6ECh case   17:*/		return 0x8210D6F0;
		  /* 8210D6F0h */ case   18:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 8210D6F0h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 8210D6F0h case   18:*/		return 0x8210D6F4;
		  /* 8210D6F4h */ case   19:  		/* lwzx R3, <#[R30 + R3]> */
		/* 8210D6F4h case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + regs.R3 + 0x00000000) );
		/* 8210D6F4h case   19:*/		return 0x8210D6F8;
		  /* 8210D6F8h */ case   20:  		/* lwz R3, <#[R3 + 4]> */
		/* 8210D6F8h case   20:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000004) );
		/* 8210D6F8h case   20:*/		return 0x8210D6FC;
		  /* 8210D6FCh */ case   21:  		/* rlwinm. R3, R3, 0, 28, 28 */
		/* 8210D6FCh case   21:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R3,regs.R3);
		/* 8210D6FCh case   21:*/		return 0x8210D700;
		  /* 8210D700h */ case   22:  		/* bc 4, CR0_EQ, 68 */
		/* 8210D700h case   22:*/		if ( !regs.CR[0].eq ) { return 0x8210D744;  }
		/* 8210D700h case   22:*/		return 0x8210D704;
		  /* 8210D704h */ case   23:  		/* lis R10, 8304 */
		/* 8210D704h case   23:*/		cpu::op::lis<0>(regs,&regs.R10,0x2070);
		/* 8210D704h case   23:*/		return 0x8210D708;
		  /* 8210D708h */ case   24:  		/* cmplw CR6, R7, R10 */
		/* 8210D708h case   24:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 8210D708h case   24:*/		return 0x8210D70C;
		  /* 8210D70Ch */ case   25:  		/* bc 12, CR6_EQ, 36 */
		/* 8210D70Ch case   25:*/		if ( regs.CR[6].eq ) { return 0x8210D730;  }
		/* 8210D70Ch case   25:*/		return 0x8210D710;
		  /* 8210D710h */ case   26:  		/* lis R10, 8320 */
		/* 8210D710h case   26:*/		cpu::op::lis<0>(regs,&regs.R10,0x2080);
		/* 8210D710h case   26:*/		return 0x8210D714;
		  /* 8210D714h */ case   27:  		/* cmplw CR6, R7, R10 */
		/* 8210D714h case   27:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 8210D714h case   27:*/		return 0x8210D718;
		  /* 8210D718h */ case   28:  		/* bc 12, CR6_EQ, 24 */
		/* 8210D718h case   28:*/		if ( regs.CR[6].eq ) { return 0x8210D730;  }
		/* 8210D718h case   28:*/		return 0x8210D71C;
		  /* 8210D71Ch */ case   29:  		/* lis R10, 4432 */
		/* 8210D71Ch case   29:*/		cpu::op::lis<0>(regs,&regs.R10,0x1150);
		/* 8210D71Ch case   29:*/		return 0x8210D720;
		  /* 8210D720h */ case   30:  		/* cmplw CR6, R7, R10 */
		/* 8210D720h case   30:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 8210D720h case   30:*/		return 0x8210D724;
		  /* 8210D724h */ case   31:  		/* bc 12, CR6_EQ, 12 */
		/* 8210D724h case   31:*/		if ( regs.CR[6].eq ) { return 0x8210D730;  }
		/* 8210D724h case   31:*/		return 0x8210D728;
		  /* 8210D728h */ case   32:  		/* lwz R10, <#[R8 + 20]> */
		/* 8210D728h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000014) );
		/* 8210D728h case   32:*/		return 0x8210D72C;
		  /* 8210D72Ch */ case   33:  		/* b 24 */
		/* 8210D72Ch case   33:*/		return 0x8210D744;
		/* 8210D72Ch case   33:*/		return 0x8210D730;
	}
	return 0x8210D730;
} // Block from 8210D6A8h-8210D730h (34 instructions)

//////////////////////////////////////////////////////
// Block at 8210D730h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D730);
		  /* 8210D730h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 8210D730h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8210D730h case    0:*/		return 0x8210D734;
		  /* 8210D734h */ case    1:  		/* lwz R10, <#[R10]> */
		/* 8210D734h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 8210D734h case    1:*/		return 0x8210D738;
		  /* 8210D738h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210D738h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210D738h case    2:*/		return 0x8210D73C;
		  /* 8210D73Ch */ case    3:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210D73Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210D73Ch case    3:*/		return 0x8210D740;
		  /* 8210D740h */ case    4:  		/* lwz R10, <#[R10 + 20]> */
		/* 8210D740h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 8210D740h case    4:*/		return 0x8210D744;
	}
	return 0x8210D744;
} // Block from 8210D730h-8210D744h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210D744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D744);
		  /* 8210D744h */ case    0:  		/* stw R10, <#[R11 + 52]> */
		/* 8210D744h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000034) );
		/* 8210D744h case    0:*/		return 0x8210D748;
		  /* 8210D748h */ case    1:  		/* rlwinm R11, R10, 0, 0, 31 */
		/* 8210D748h case    1:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R10);
		/* 8210D748h case    1:*/		return 0x8210D74C;
		  /* 8210D74Ch */ case    2:  		/* cmpwi CR6, R11, -1 */
		/* 8210D74Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210D74Ch case    2:*/		return 0x8210D750;
		  /* 8210D750h */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 8210D750h case    3:*/		if ( regs.CR[6].eq ) { return 0x8210D758;  }
		/* 8210D750h case    3:*/		return 0x8210D754;
		  /* 8210D754h */ case    4:  		/* li R4, 1 */
		/* 8210D754h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8210D754h case    4:*/		return 0x8210D758;
	}
	return 0x8210D758;
} // Block from 8210D744h-8210D758h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210D758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D758);
		  /* 8210D758h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210D758h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210D758h case    0:*/		return 0x8210D75C;
		  /* 8210D75Ch */ case    1:  		/* addi R5, R5, 1 */
		/* 8210D75Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 8210D75Ch case    1:*/		return 0x8210D760;
		  /* 8210D760h */ case    2:  		/* addi R6, R6, 4 */
		/* 8210D760h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 8210D760h case    2:*/		return 0x8210D764;
		  /* 8210D764h */ case    3:  		/* cmplw CR6, R5, R11 */
		/* 8210D764h case    3:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 8210D764h case    3:*/		return 0x8210D768;
		  /* 8210D768h */ case    4:  		/* bc 12, CR6_LT, -168 */
		/* 8210D768h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210D6C0;  }
		/* 8210D768h case    4:*/		return 0x8210D76C;
	}
	return 0x8210D76C;
} // Block from 8210D758h-8210D76Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210D76Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D76C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D76C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D76C);
		  /* 8210D76Ch */ case    0:  		/* lwz R10, <#[R31 + 204]> */
		/* 8210D76Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000CC) );
		/* 8210D76Ch case    0:*/		return 0x8210D770;
		  /* 8210D770h */ case    1:  		/* rlwinm. R10, R10, 0, 29, 29 */
		/* 8210D770h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R10);
		/* 8210D770h case    1:*/		return 0x8210D774;
		  /* 8210D774h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 8210D774h case    2:*/		if ( regs.CR[0].eq ) { return 0x8210D780;  }
		/* 8210D774h case    2:*/		return 0x8210D778;
		  /* 8210D778h */ case    3:  		/* li R3, 1 */
		/* 8210D778h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8210D778h case    3:*/		return 0x8210D77C;
		  /* 8210D77Ch */ case    4:  		/* b 676 */
		/* 8210D77Ch case    4:*/		return 0x8210DA20;
		/* 8210D77Ch case    4:*/		return 0x8210D780;
	}
	return 0x8210D780;
} // Block from 8210D76Ch-8210D780h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210D780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D780);
		  /* 8210D780h */ case    0:  		/* cmpwi CR6, R4, 0 */
		/* 8210D780h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 8210D780h case    0:*/		return 0x8210D784;
		  /* 8210D784h */ case    1:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 8210D784h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 8210D784h case    1:*/		return 0x8210D788;
		  /* 8210D788h */ case    2:  		/* lis R4, 9345 */
		/* 8210D788h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210D788h case    2:*/		return 0x8210D78C;
		  /* 8210D78Ch */ case    3:  		/* bc 12, CR6_EQ, 300 */
		/* 8210D78Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8210D8B8;  }
		/* 8210D78Ch case    3:*/		return 0x8210D790;
		  /* 8210D790h */ case    4:  		/* bl -546192 */
		/* 8210D790h case    4:*/		regs.LR = 0x8210D794; return 0x82088200;
		/* 8210D790h case    4:*/		return 0x8210D794;
		  /* 8210D794h */ case    5:  		/* or. R25, R3, R3 */
		/* 8210D794h case    5:*/		cpu::op::or<1>(regs,&regs.R25,regs.R3,regs.R3);
		/* 8210D794h case    5:*/		return 0x8210D798;
		  /* 8210D798h */ case    6:  		/* bc 12, CR0_EQ, 600 */
		/* 8210D798h case    6:*/		if ( regs.CR[0].eq ) { return 0x8210D9F0;  }
		/* 8210D798h case    6:*/		return 0x8210D79C;
		  /* 8210D79Ch */ case    7:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210D79Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210D79Ch case    7:*/		return 0x8210D7A0;
		  /* 8210D7A0h */ case    8:  		/* lis R4, 9345 */
		/* 8210D7A0h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210D7A0h case    8:*/		return 0x8210D7A4;
		  /* 8210D7A4h */ case    9:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 8210D7A4h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 8210D7A4h case    9:*/		return 0x8210D7A8;
		  /* 8210D7A8h */ case   10:  		/* bl -546216 */
		/* 8210D7A8h case   10:*/		regs.LR = 0x8210D7AC; return 0x82088200;
		/* 8210D7A8h case   10:*/		return 0x8210D7AC;
		  /* 8210D7ACh */ case   11:  		/* or. R24, R3, R3 */
		/* 8210D7ACh case   11:*/		cpu::op::or<1>(regs,&regs.R24,regs.R3,regs.R3);
		/* 8210D7ACh case   11:*/		return 0x8210D7B0;
		  /* 8210D7B0h */ case   12:  		/* bc 12, CR0_EQ, 576 */
		/* 8210D7B0h case   12:*/		if ( regs.CR[0].eq ) { return 0x8210D9F0;  }
		/* 8210D7B0h case   12:*/		return 0x8210D7B4;
		  /* 8210D7B4h */ case   13:  		/* mr R3, R31 */
		/* 8210D7B4h case   13:*/		regs.R3 = regs.R31;
		/* 8210D7B4h case   13:*/		return 0x8210D7B8;
		  /* 8210D7B8h */ case   14:  		/* li R29, 1 */
		/* 8210D7B8h case   14:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 8210D7B8h case   14:*/		return 0x8210D7BC;
		  /* 8210D7BCh */ case   15:  		/* bl -31780 */
		/* 8210D7BCh case   15:*/		regs.LR = 0x8210D7C0; return 0x82105B98;
		/* 8210D7BCh case   15:*/		return 0x8210D7C0;
		  /* 8210D7C0h */ case   16:  		/* or. R30, R3, R3 */
		/* 8210D7C0h case   16:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 8210D7C0h case   16:*/		return 0x8210D7C4;
		  /* 8210D7C4h */ case   17:  		/* bc 12, CR0_LT, 564 */
		/* 8210D7C4h case   17:*/		if ( regs.CR[0].lt ) { return 0x8210D9F8;  }
		/* 8210D7C4h case   17:*/		return 0x8210D7C8;
		  /* 8210D7C8h */ case   18:  		/* lwz R5, <#[R31 + 12]> */
		/* 8210D7C8h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210D7C8h case   18:*/		return 0x8210D7CC;
		  /* 8210D7CCh */ case   19:  		/* mr R11, R26 */
		/* 8210D7CCh case   19:*/		regs.R11 = regs.R26;
		/* 8210D7CCh case   19:*/		return 0x8210D7D0;
		  /* 8210D7D0h */ case   20:  		/* cmplwi CR6, R5, 0 */
		/* 8210D7D0h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8210D7D0h case   20:*/		return 0x8210D7D4;
		  /* 8210D7D4h */ case   21:  		/* bc 12, CR6_EQ, 28 */
		/* 8210D7D4h case   21:*/		if ( regs.CR[6].eq ) { return 0x8210D7F0;  }
		/* 8210D7D4h case   21:*/		return 0x8210D7D8;
		  /* 8210D7D8h */ case   22:  		/* addi R10, R25, -4 */
		/* 8210D7D8h case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R25,0xFFFFFFFC);
		/* 8210D7D8h case   22:*/		return 0x8210D7DC;
		  /* 8210D7DCh */ case   23:  		/* stwu R11, <#[R10 + 4]> */
		/* 8210D7DCh case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8210D7DCh case   23:*/		return 0x8210D7E0;
		  /* 8210D7E0h */ case   24:  		/* addi R11, R11, 1 */
		/* 8210D7E0h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210D7E0h case   24:*/		return 0x8210D7E4;
		  /* 8210D7E4h */ case   25:  		/* lwz R5, <#[R31 + 12]> */
		/* 8210D7E4h case   25:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210D7E4h case   25:*/		return 0x8210D7E8;
		  /* 8210D7E8h */ case   26:  		/* cmplw CR6, R11, R5 */
		/* 8210D7E8h case   26:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 8210D7E8h case   26:*/		return 0x8210D7EC;
		  /* 8210D7ECh */ case   27:  		/* bc 12, CR6_LT, -16 */
		/* 8210D7ECh case   27:*/		if ( regs.CR[6].lt ) { return 0x8210D7DC;  }
		/* 8210D7ECh case   27:*/		return 0x8210D7F0;
	}
	return 0x8210D7F0;
} // Block from 8210D780h-8210D7F0h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8210D7F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D7F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D7F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D7F0);
		  /* 8210D7F0h */ case    0:  		/* lis R11, -32240 */
		/* 8210D7F0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8210);
		/* 8210D7F0h case    0:*/		return 0x8210D7F4;
		  /* 8210D7F4h */ case    1:  		/* mr R6, R31 */
		/* 8210D7F4h case    1:*/		regs.R6 = regs.R31;
		/* 8210D7F4h case    1:*/		return 0x8210D7F8;
		  /* 8210D7F8h */ case    2:  		/* mr R4, R25 */
		/* 8210D7F8h case    2:*/		regs.R4 = regs.R25;
		/* 8210D7F8h case    2:*/		return 0x8210D7FC;
		  /* 8210D7FCh */ case    3:  		/* addi R3, R11, -9600 */
		/* 8210D7FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFDA80);
		/* 8210D7FCh case    3:*/		return 0x8210D800;
		  /* 8210D800h */ case    4:  		/* bl -63840 */
		/* 8210D800h case    4:*/		regs.LR = 0x8210D804; return 0x820FDEA0;
		/* 8210D800h case    4:*/		return 0x8210D804;
		  /* 8210D804h */ case    5:  		/* lwz R10, <#[R31 + 12]> */
		/* 8210D804h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210D804h case    5:*/		return 0x8210D808;
		  /* 8210D808h */ case    6:  		/* mr R9, R26 */
		/* 8210D808h case    6:*/		regs.R9 = regs.R26;
		/* 8210D808h case    6:*/		return 0x8210D80C;
		  /* 8210D80Ch */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 8210D80Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8210D80Ch case    7:*/		return 0x8210D810;
		  /* 8210D810h */ case    8:  		/* bc 12, CR6_EQ, 68 */
		/* 8210D810h case    8:*/		if ( regs.CR[6].eq ) { return 0x8210D854;  }
		/* 8210D810h case    8:*/		return 0x8210D814;
		  /* 8210D814h */ case    9:  		/* mr R11, R25 */
		/* 8210D814h case    9:*/		regs.R11 = regs.R25;
		/* 8210D814h case    9:*/		return 0x8210D818;
		  /* 8210D818h */ case   10:  		/* subf R8, R25, R24 */
		/* 8210D818h case   10:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R25,regs.R24);
		/* 8210D818h case   10:*/		return 0x8210D81C;
		  /* 8210D81Ch */ case   11:  		/* lwz R10, <#[R11]> */
		/* 8210D81Ch case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210D81Ch case   11:*/		return 0x8210D820;
		  /* 8210D820h */ case   12:  		/* lwz R7, <#[R31 + 24]> */
		/* 8210D820h case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000018) );
		/* 8210D820h case   12:*/		return 0x8210D824;
		  /* 8210D824h */ case   13:  		/* rlwinm R6, R10, 2, 0, 29 */
		/* 8210D824h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R10);
		/* 8210D824h case   13:*/		return 0x8210D828;
		  /* 8210D828h */ case   14:  		/* subf R10, R10, R9 */
		/* 8210D828h case   14:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8210D828h case   14:*/		return 0x8210D82C;
		  /* 8210D82Ch */ case   15:  		/* addi R9, R9, 1 */
		/* 8210D82Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8210D82Ch case   15:*/		return 0x8210D830;
		  /* 8210D830h */ case   16:  		/* addic R10, R10, -1 */
		/* 8210D830h case   16:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8210D830h case   16:*/		return 0x8210D834;
		  /* 8210D834h */ case   17:  		/* lwzx R7, <#[R6 + R7]> */
		/* 8210D834h case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R6 + regs.R7 + 0x00000000) );
		/* 8210D834h case   17:*/		return 0x8210D838;
		  /* 8210D838h */ case   18:  		/* subfe R10, R10, R10 */
		/* 8210D838h case   18:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8210D838h case   18:*/		return 0x8210D83C;
		  /* 8210D83Ch */ case   19:  		/* and R29, R10, R29 */
		/* 8210D83Ch case   19:*/		cpu::op::and<0>(regs,&regs.R29,regs.R10,regs.R29);
		/* 8210D83Ch case   19:*/		return 0x8210D840;
		  /* 8210D840h */ case   20:  		/* stwx R7, <#[R8 + R11]> */
		/* 8210D840h case   20:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8210D840h case   20:*/		return 0x8210D844;
		  /* 8210D844h */ case   21:  		/* addi R11, R11, 4 */
		/* 8210D844h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210D844h case   21:*/		return 0x8210D848;
		  /* 8210D848h */ case   22:  		/* lwz R10, <#[R31 + 12]> */
		/* 8210D848h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210D848h case   22:*/		return 0x8210D84C;
		  /* 8210D84Ch */ case   23:  		/* cmplw CR6, R9, R10 */
		/* 8210D84Ch case   23:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 8210D84Ch case   23:*/		return 0x8210D850;
		  /* 8210D850h */ case   24:  		/* bc 12, CR6_LT, -52 */
		/* 8210D850h case   24:*/		if ( regs.CR[6].lt ) { return 0x8210D81C;  }
		/* 8210D850h case   24:*/		return 0x8210D854;
	}
	return 0x8210D854;
} // Block from 8210D7F0h-8210D854h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8210D854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D854);
		  /* 8210D854h */ case    0:  		/* rlwinm R5, R10, 2, 0, 29 */
		/* 8210D854h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R10);
		/* 8210D854h case    0:*/		return 0x8210D858;
		  /* 8210D858h */ case    1:  		/* lwz R3, <#[R31 + 24]> */
		/* 8210D858h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 8210D858h case    1:*/		return 0x8210D85C;
		  /* 8210D85Ch */ case    2:  		/* mr R4, R24 */
		/* 8210D85Ch case    2:*/		regs.R4 = regs.R24;
		/* 8210D85Ch case    2:*/		return 0x8210D860;
		  /* 8210D860h */ case    3:  		/* bl -507568 */
		/* 8210D860h case    3:*/		regs.LR = 0x8210D864; return 0x820919B0;
		/* 8210D860h case    3:*/		return 0x8210D864;
		  /* 8210D864h */ case    4:  		/* cmpwi CR6, R29, 0 */
		/* 8210D864h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 8210D864h case    4:*/		return 0x8210D868;
		  /* 8210D868h */ case    5:  		/* bc 12, CR6_EQ, -180 */
		/* 8210D868h case    5:*/		if ( regs.CR[6].eq ) { return 0x8210D7B4;  }
		/* 8210D868h case    5:*/		return 0x8210D86C;
		  /* 8210D86Ch */ case    6:  		/* mr R3, R31 */
		/* 8210D86Ch case    6:*/		regs.R3 = regs.R31;
		/* 8210D86Ch case    6:*/		return 0x8210D870;
		  /* 8210D870h */ case    7:  		/* bl -30736 */
		/* 8210D870h case    7:*/		regs.LR = 0x8210D874; return 0x82106060;
		/* 8210D870h case    7:*/		return 0x8210D874;
		  /* 8210D874h */ case    8:  		/* or. R30, R3, R3 */
		/* 8210D874h case    8:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 8210D874h case    8:*/		return 0x8210D878;
	}
	return 0x8210D878;
} // Block from 8210D854h-8210D878h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8210D878h
// Function '?VectorizeLiterals@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D878);
		  /* 8210D878h */ case    0:  		/* bc 12, CR0_LT, 384 */
		/* 8210D878h case    0:*/		if ( regs.CR[0].lt ) { return 0x8210D9F8;  }
		/* 8210D878h case    0:*/		return 0x8210D87C;
		  /* 8210D87Ch */ case    1:  		/* lis R11, -32254 */
		/* 8210D87Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 8210D87Ch case    1:*/		return 0x8210D880;
		  /* 8210D880h */ case    2:  		/* stw R31, <#[R1 + 100]> */
		/* 8210D880h case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000064) );
		/* 8210D880h case    2:*/		return 0x8210D884;
		  /* 8210D884h */ case    3:  		/* li R4, 1 */
		/* 8210D884h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8210D884h case    3:*/		return 0x8210D888;
		  /* 8210D888h */ case    4:  		/* addi R11, R11, -14332 */
		/* 8210D888h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFC804);
		/* 8210D888h case    4:*/		return 0x8210D88C;
		  /* 8210D88Ch */ case    5:  		/* addi R3, R1, 96 */
		/* 8210D88Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8210D88Ch case    5:*/		return 0x8210D890;
		  /* 8210D890h */ case    6:  		/* stw R11, <#[R1 + 96]> */
		/* 8210D890h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 8210D890h case    6:*/		return 0x8210D894;
		  /* 8210D894h */ case    7:  		/* lwz R11, <#[R11 + 8]> */
		/* 8210D894h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8210D894h case    7:*/		return 0x8210D898;
		  /* 8210D898h */ case    8:  		/* mtspr CTR, R11 */
		/* 8210D898h case    8:*/		regs.CTR = regs.R11;
		/* 8210D898h case    8:*/		return 0x8210D89C;
		  /* 8210D89Ch */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 8210D89Ch case    9:*/		if ( 1 ) { regs.LR = 0x8210D8A0; return (uint32)regs.CTR; }
		/* 8210D89Ch case    9:*/		return 0x8210D8A0;
		  /* 8210D8A0h */ case   10:  		/* lis R11, -32254 */
		/* 8210D8A0h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 8210D8A0h case   10:*/		return 0x8210D8A4;
		  /* 8210D8A4h */ case   11:  		/* or. R30, R3, R3 */
		/* 8210D8A4h case   11:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 8210D8A4h case   11:*/		return 0x8210D8A8;
		  /* 8210D8A8h */ case   12:  		/* addi R11, R11, -14340 */
		/* 8210D8A8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFC7FC);
		/* 8210D8A8h case   12:*/		return 0x8210D8AC;
		  /* 8210D8ACh */ case   13:  		/* stw R11, <#[R1 + 96]> */
		/* 8210D8ACh case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 8210D8ACh case   13:*/		return 0x8210D8B0;
		  /* 8210D8B0h */ case   14:  		/* bc 12, CR0_LT, 328 */
		/* 8210D8B0h case   14:*/		if ( regs.CR[0].lt ) { return 0x8210D9F8;  }
		/* 8210D8B0h case   14:*/		return 0x8210D8B4;
		  /* 8210D8B4h */ case   15:  		/* b 308 */
		/* 8210D8B4h case   15:*/		return 0x8210D9E8;
		/* 8210D8B4h case   15:*/		return 0x8210D8B8;
	}
	return 0x8210D8B8;
} // Block from 8210D878h-8210D8B8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8210D8B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D8B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D8B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D8B8);
		  /* 8210D8B8h */ case    0:  		/* mr R27, R26 */
		/* 8210D8B8h case    0:*/		regs.R27 = regs.R26;
		/* 8210D8B8h case    0:*/		return 0x8210D8BC;
		  /* 8210D8BCh */ case    1:  		/* bl -546492 */
		/* 8210D8BCh case    1:*/		regs.LR = 0x8210D8C0; return 0x82088200;
		/* 8210D8BCh case    1:*/		return 0x8210D8C0;
		  /* 8210D8C0h */ case    2:  		/* or. R23, R3, R3 */
		/* 8210D8C0h case    2:*/		cpu::op::or<1>(regs,&regs.R23,regs.R3,regs.R3);
		/* 8210D8C0h case    2:*/		return 0x8210D8C4;
		  /* 8210D8C4h */ case    3:  		/* bc 12, CR0_EQ, 300 */
		/* 8210D8C4h case    3:*/		if ( regs.CR[0].eq ) { return 0x8210D9F0;  }
		/* 8210D8C4h case    3:*/		return 0x8210D8C8;
		  /* 8210D8C8h */ case    4:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210D8C8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210D8C8h case    4:*/		return 0x8210D8CC;
		  /* 8210D8CCh */ case    5:  		/* lis R4, 9345 */
		/* 8210D8CCh case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210D8CCh case    5:*/		return 0x8210D8D0;
		  /* 8210D8D0h */ case    6:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 8210D8D0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 8210D8D0h case    6:*/		return 0x8210D8D4;
		  /* 8210D8D4h */ case    7:  		/* bl -546516 */
		/* 8210D8D4h case    7:*/		regs.LR = 0x8210D8D8; return 0x82088200;
		/* 8210D8D4h case    7:*/		return 0x8210D8D8;
		  /* 8210D8D8h */ case    8:  		/* or. R25, R3, R3 */
		/* 8210D8D8h case    8:*/		cpu::op::or<1>(regs,&regs.R25,regs.R3,regs.R3);
		/* 8210D8D8h case    8:*/		return 0x8210D8DC;
		  /* 8210D8DCh */ case    9:  		/* bc 12, CR0_EQ, 276 */
		/* 8210D8DCh case    9:*/		if ( regs.CR[0].eq ) { return 0x8210D9F0;  }
		/* 8210D8DCh case    9:*/		return 0x8210D8E0;
		  /* 8210D8E0h */ case   10:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210D8E0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210D8E0h case   10:*/		return 0x8210D8E4;
		  /* 8210D8E4h */ case   11:  		/* lis R4, 9345 */
		/* 8210D8E4h case   11:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210D8E4h case   11:*/		return 0x8210D8E8;
		  /* 8210D8E8h */ case   12:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 8210D8E8h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 8210D8E8h case   12:*/		return 0x8210D8EC;
		  /* 8210D8ECh */ case   13:  		/* bl -546540 */
		/* 8210D8ECh case   13:*/		regs.LR = 0x8210D8F0; return 0x82088200;
		/* 8210D8ECh case   13:*/		return 0x8210D8F0;
		  /* 8210D8F0h */ case   14:  		/* or. R24, R3, R3 */
		/* 8210D8F0h case   14:*/		cpu::op::or<1>(regs,&regs.R24,regs.R3,regs.R3);
		/* 8210D8F0h case   14:*/		return 0x8210D8F4;
		  /* 8210D8F4h */ case   15:  		/* bc 12, CR0_EQ, 252 */
		/* 8210D8F4h case   15:*/		if ( regs.CR[0].eq ) { return 0x8210D9F0;  }
		/* 8210D8F4h case   15:*/		return 0x8210D8F8;
		  /* 8210D8F8h */ case   16:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210D8F8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210D8F8h case   16:*/		return 0x8210D8FC;
		  /* 8210D8FCh */ case   17:  		/* mr R9, R26 */
		/* 8210D8FCh case   17:*/		regs.R9 = regs.R26;
		/* 8210D8FCh case   17:*/		return 0x8210D900;
		  /* 8210D900h */ case   18:  		/* cmplwi CR6, R11, 0 */
		/* 8210D900h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210D900h case   18:*/		return 0x8210D904;
		  /* 8210D904h */ case   19:  		/* bc 4, CR6_GT, 84 */
		/* 8210D904h case   19:*/		if ( !regs.CR[6].gt ) { return 0x8210D958;  }
		/* 8210D904h case   19:*/		return 0x8210D908;
		  /* 8210D908h */ case   20:  		/* mr R10, R26 */
		/* 8210D908h case   20:*/		regs.R10 = regs.R26;
		/* 8210D908h case   20:*/		return 0x8210D90C;
		  /* 8210D90Ch */ case   21:  		/* addi R8, R23, -4 */
		/* 8210D90Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R23,0xFFFFFFFC);
		/* 8210D90Ch case   21:*/		return 0x8210D910;
		  /* 8210D910h */ case   22:  		/* lwz R11, <#[R31 + 24]> */
		/* 8210D910h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8210D910h case   22:*/		return 0x8210D914;
		  /* 8210D914h */ case   23:  		/* li R7, -1 */
		/* 8210D914h case   23:*/		cpu::op::li<0>(regs,&regs.R7,0xFFFFFFFF);
		/* 8210D914h case   23:*/		return 0x8210D918;
		  /* 8210D918h */ case   24:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210D918h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210D918h case   24:*/		return 0x8210D91C;
		  /* 8210D91Ch */ case   25:  		/* lwz R6, <#[R11]> */
		/* 8210D91Ch case   25:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8210D91Ch case   25:*/		return 0x8210D920;
		  /* 8210D920h */ case   26:  		/* stw R26, <#[R11 + 36]> */
		/* 8210D920h case   26:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000024) );
		/* 8210D920h case   26:*/		return 0x8210D924;
		  /* 8210D924h */ case   27:  		/* rlwinm. R6, R6, 0, 0, 11 */
		/* 8210D924h case   27:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R6,regs.R6);
		/* 8210D924h case   27:*/		return 0x8210D928;
		  /* 8210D928h */ case   28:  		/* stw R7, <#[R11 + 56]> */
		/* 8210D928h case   28:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000038) );
		/* 8210D928h case   28:*/		return 0x8210D92C;
		  /* 8210D92Ch */ case   29:  		/* bc 12, CR0_EQ, 24 */
		/* 8210D92Ch case   29:*/		if ( regs.CR[0].eq ) { return 0x8210D944;  }
		/* 8210D92Ch case   29:*/		return 0x8210D930;
		  /* 8210D930h */ case   30:  		/* lwz R11, <#[R11 + 28]> */
		/* 8210D930h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8210D930h case   30:*/		return 0x8210D934;
		  /* 8210D934h */ case   31:  		/* cmplwi CR6, R11, 0 */
		/* 8210D934h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210D934h case   31:*/		return 0x8210D938;
		  /* 8210D938h */ case   32:  		/* bc 4, CR6_EQ, 12 */
		/* 8210D938h case   32:*/		if ( !regs.CR[6].eq ) { return 0x8210D944;  }
		/* 8210D938h case   32:*/		return 0x8210D93C;
		  /* 8210D93Ch */ case   33:  		/* stwu R9, <#[R8 + 4]> */
		/* 8210D93Ch case   33:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + 0x00000004) );
		regs.R8 = (uint32)(regs.R8 + 0x00000004);
		/* 8210D93Ch case   33:*/		return 0x8210D940;
		  /* 8210D940h */ case   34:  		/* addi R27, R27, 1 */
		/* 8210D940h case   34:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8210D940h case   34:*/		return 0x8210D944;
	}
	return 0x8210D944;
} // Block from 8210D8B8h-8210D944h (35 instructions)

//////////////////////////////////////////////////////
// Block at 8210D944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D944);
		  /* 8210D944h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210D944h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210D944h case    0:*/		return 0x8210D948;
		  /* 8210D948h */ case    1:  		/* addi R9, R9, 1 */
		/* 8210D948h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8210D948h case    1:*/		return 0x8210D94C;
		  /* 8210D94Ch */ case    2:  		/* addi R10, R10, 4 */
		/* 8210D94Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210D94Ch case    2:*/		return 0x8210D950;
		  /* 8210D950h */ case    3:  		/* cmplw CR6, R9, R11 */
		/* 8210D950h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8210D950h case    3:*/		return 0x8210D954;
		  /* 8210D954h */ case    4:  		/* bc 12, CR6_LT, -68 */
		/* 8210D954h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210D910;  }
		/* 8210D954h case    4:*/		return 0x8210D958;
	}
	return 0x8210D958;
} // Block from 8210D944h-8210D958h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210D958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D958);
		  /* 8210D958h */ case    0:  		/* mr R28, R26 */
		/* 8210D958h case    0:*/		regs.R28 = regs.R26;
		/* 8210D958h case    0:*/		return 0x8210D95C;
		  /* 8210D95Ch */ case    1:  		/* stw R26, <#[R1 + 80]> */
		/* 8210D95Ch case    1:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 8210D95Ch case    1:*/		return 0x8210D960;
		  /* 8210D960h */ case    2:  		/* cmplwi CR6, R27, 0 */
		/* 8210D960h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8210D960h case    2:*/		return 0x8210D964;
		  /* 8210D964h */ case    3:  		/* bc 12, CR6_EQ, 52 */
		/* 8210D964h case    3:*/		if ( regs.CR[6].eq ) { return 0x8210D998;  }
		/* 8210D964h case    3:*/		return 0x8210D968;
		  /* 8210D968h */ case    4:  		/* mr R29, R23 */
		/* 8210D968h case    4:*/		regs.R29 = regs.R23;
		/* 8210D968h case    4:*/		return 0x8210D96C;
		  /* 8210D96Ch */ case    5:  		/* addi R6, R1, 80 */
		/* 8210D96Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 8210D96Ch case    5:*/		return 0x8210D970;
		  /* 8210D970h */ case    6:  		/* lwz R4, <#[R29]> */
		/* 8210D970h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000000) );
		/* 8210D970h case    6:*/		return 0x8210D974;
		  /* 8210D974h */ case    7:  		/* mr R5, R25 */
		/* 8210D974h case    7:*/		regs.R5 = regs.R25;
		/* 8210D974h case    7:*/		return 0x8210D978;
		  /* 8210D978h */ case    8:  		/* mr R3, R31 */
		/* 8210D978h case    8:*/		regs.R3 = regs.R31;
		/* 8210D978h case    8:*/		return 0x8210D97C;
		  /* 8210D97Ch */ case    9:  		/* bl -55908 */
		/* 8210D97Ch case    9:*/		regs.LR = 0x8210D980; return 0x820FFF18;
		/* 8210D97Ch case    9:*/		return 0x8210D980;
		  /* 8210D980h */ case   10:  		/* or. R30, R3, R3 */
		/* 8210D980h case   10:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 8210D980h case   10:*/		return 0x8210D984;
		  /* 8210D984h */ case   11:  		/* bc 12, CR0_LT, 116 */
		/* 8210D984h case   11:*/		if ( regs.CR[0].lt ) { return 0x8210D9F8;  }
		/* 8210D984h case   11:*/		return 0x8210D988;
		  /* 8210D988h */ case   12:  		/* addi R28, R28, 1 */
		/* 8210D988h case   12:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8210D988h case   12:*/		return 0x8210D98C;
		  /* 8210D98Ch */ case   13:  		/* addi R29, R29, 4 */
		/* 8210D98Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8210D98Ch case   13:*/		return 0x8210D990;
		  /* 8210D990h */ case   14:  		/* cmplw CR6, R28, R27 */
		/* 8210D990h case   14:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R27);
		/* 8210D990h case   14:*/		return 0x8210D994;
		  /* 8210D994h */ case   15:  		/* bc 12, CR6_LT, -40 */
		/* 8210D994h case   15:*/		if ( regs.CR[6].lt ) { return 0x8210D96C;  }
		/* 8210D994h case   15:*/		return 0x8210D998;
	}
	return 0x8210D998;
} // Block from 8210D958h-8210D998h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8210D998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D998);
		  /* 8210D998h */ case    0:  		/* lwz R10, <#[R31 + 12]> */
		/* 8210D998h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210D998h case    0:*/		return 0x8210D99C;
		  /* 8210D99Ch */ case    1:  		/* mr R9, R26 */
		/* 8210D99Ch case    1:*/		regs.R9 = regs.R26;
		/* 8210D99Ch case    1:*/		return 0x8210D9A0;
		  /* 8210D9A0h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 8210D9A0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8210D9A0h case    2:*/		return 0x8210D9A4;
		  /* 8210D9A4h */ case    3:  		/* bc 12, CR6_EQ, 52 */
		/* 8210D9A4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8210D9D8;  }
		/* 8210D9A4h case    3:*/		return 0x8210D9A8;
		  /* 8210D9A8h */ case    4:  		/* mr R11, R24 */
		/* 8210D9A8h case    4:*/		regs.R11 = regs.R24;
		/* 8210D9A8h case    4:*/		return 0x8210D9AC;
		  /* 8210D9ACh */ case    5:  		/* subf R8, R24, R25 */
		/* 8210D9ACh case    5:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R24,regs.R25);
		/* 8210D9ACh case    5:*/		return 0x8210D9B0;
		  /* 8210D9B0h */ case    6:  		/* lwzx R10, <#[R8 + R11]> */
		/* 8210D9B0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8210D9B0h case    6:*/		return 0x8210D9B4;
		  /* 8210D9B4h */ case    7:  		/* addi R9, R9, 1 */
		/* 8210D9B4h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8210D9B4h case    7:*/		return 0x8210D9B8;
		  /* 8210D9B8h */ case    8:  		/* lwz R7, <#[R31 + 24]> */
		/* 8210D9B8h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000018) );
		/* 8210D9B8h case    8:*/		return 0x8210D9BC;
		  /* 8210D9BCh */ case    9:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210D9BCh case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210D9BCh case    9:*/		return 0x8210D9C0;
		  /* 8210D9C0h */ case   10:  		/* lwzx R10, <#[R10 + R7]> */
		/* 8210D9C0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 8210D9C0h case   10:*/		return 0x8210D9C4;
		  /* 8210D9C4h */ case   11:  		/* stw R10, <#[R11]> */
		/* 8210D9C4h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210D9C4h case   11:*/		return 0x8210D9C8;
		  /* 8210D9C8h */ case   12:  		/* addi R11, R11, 4 */
		/* 8210D9C8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210D9C8h case   12:*/		return 0x8210D9CC;
		  /* 8210D9CCh */ case   13:  		/* lwz R10, <#[R31 + 12]> */
		/* 8210D9CCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210D9CCh case   13:*/		return 0x8210D9D0;
		  /* 8210D9D0h */ case   14:  		/* cmplw CR6, R9, R10 */
		/* 8210D9D0h case   14:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 8210D9D0h case   14:*/		return 0x8210D9D4;
		  /* 8210D9D4h */ case   15:  		/* bc 12, CR6_LT, -36 */
		/* 8210D9D4h case   15:*/		if ( regs.CR[6].lt ) { return 0x8210D9B0;  }
		/* 8210D9D4h case   15:*/		return 0x8210D9D8;
	}
	return 0x8210D9D8;
} // Block from 8210D998h-8210D9D8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8210D9D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D9D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D9D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D9D8);
		  /* 8210D9D8h */ case    0:  		/* rlwinm R5, R10, 2, 0, 29 */
		/* 8210D9D8h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R10);
		/* 8210D9D8h case    0:*/		return 0x8210D9DC;
		  /* 8210D9DCh */ case    1:  		/* lwz R3, <#[R31 + 24]> */
		/* 8210D9DCh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 8210D9DCh case    1:*/		return 0x8210D9E0;
		  /* 8210D9E0h */ case    2:  		/* mr R4, R24 */
		/* 8210D9E0h case    2:*/		regs.R4 = regs.R24;
		/* 8210D9E0h case    2:*/		return 0x8210D9E4;
		  /* 8210D9E4h */ case    3:  		/* bl -507956 */
		/* 8210D9E4h case    3:*/		regs.LR = 0x8210D9E8; return 0x820919B0;
		/* 8210D9E4h case    3:*/		return 0x8210D9E8;
	}
	return 0x8210D9E8;
} // Block from 8210D9D8h-8210D9E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210D9E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D9E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D9E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D9E8);
		  /* 8210D9E8h */ case    0:  		/* mr R30, R26 */
		/* 8210D9E8h case    0:*/		regs.R30 = regs.R26;
		/* 8210D9E8h case    0:*/		return 0x8210D9EC;
		  /* 8210D9ECh */ case    1:  		/* b 12 */
		/* 8210D9ECh case    1:*/		return 0x8210D9F8;
		/* 8210D9ECh case    1:*/		return 0x8210D9F0;
	}
	return 0x8210D9F0;
} // Block from 8210D9E8h-8210D9F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210D9F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D9F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D9F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D9F0);
		  /* 8210D9F0h */ case    0:  		/* lis R30, -32761 */
		/* 8210D9F0h case    0:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8007);
		/* 8210D9F0h case    0:*/		return 0x8210D9F4;
		  /* 8210D9F4h */ case    1:  		/* ori R30, R30, 14 */
		/* 8210D9F4h case    1:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0xE);
		/* 8210D9F4h case    1:*/		return 0x8210D9F8;
	}
	return 0x8210D9F8;
} // Block from 8210D9F0h-8210D9F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210D9F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210D9F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210D9F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210D9F8);
		  /* 8210D9F8h */ case    0:  		/* lis R4, 9345 */
		/* 8210D9F8h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210D9F8h case    0:*/		return 0x8210D9FC;
		  /* 8210D9FCh */ case    1:  		/* mr R3, R23 */
		/* 8210D9FCh case    1:*/		regs.R3 = regs.R23;
		/* 8210D9FCh case    1:*/		return 0x8210DA00;
		  /* 8210DA00h */ case    2:  		/* bl -546504 */
		/* 8210DA00h case    2:*/		regs.LR = 0x8210DA04; return 0x82088338;
		/* 8210DA00h case    2:*/		return 0x8210DA04;
		  /* 8210DA04h */ case    3:  		/* lis R4, 9345 */
		/* 8210DA04h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210DA04h case    3:*/		return 0x8210DA08;
		  /* 8210DA08h */ case    4:  		/* mr R3, R25 */
		/* 8210DA08h case    4:*/		regs.R3 = regs.R25;
		/* 8210DA08h case    4:*/		return 0x8210DA0C;
		  /* 8210DA0Ch */ case    5:  		/* bl -546516 */
		/* 8210DA0Ch case    5:*/		regs.LR = 0x8210DA10; return 0x82088338;
		/* 8210DA0Ch case    5:*/		return 0x8210DA10;
		  /* 8210DA10h */ case    6:  		/* lis R4, 9345 */
		/* 8210DA10h case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210DA10h case    6:*/		return 0x8210DA14;
		  /* 8210DA14h */ case    7:  		/* mr R3, R24 */
		/* 8210DA14h case    7:*/		regs.R3 = regs.R24;
		/* 8210DA14h case    7:*/		return 0x8210DA18;
		  /* 8210DA18h */ case    8:  		/* bl -546528 */
		/* 8210DA18h case    8:*/		regs.LR = 0x8210DA1C; return 0x82088338;
		/* 8210DA18h case    8:*/		return 0x8210DA1C;
		  /* 8210DA1Ch */ case    9:  		/* mr R3, R30 */
		/* 8210DA1Ch case    9:*/		regs.R3 = regs.R30;
		/* 8210DA1Ch case    9:*/		return 0x8210DA20;
	}
	return 0x8210DA20;
} // Block from 8210D9F8h-8210DA20h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8210DA20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210DA20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210DA20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210DA20);
		  /* 8210DA20h */ case    0:  		/* addi R1, R1, 272 */
		/* 8210DA20h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x110);
		/* 8210DA20h case    0:*/		return 0x8210DA24;
		  /* 8210DA24h */ case    1:  		/* b -509840 */
		/* 8210DA24h case    1:*/		return 0x82091294;
		/* 8210DA24h case    1:*/		return 0x8210DA28;
	}
	return 0x8210DA28;
} // Block from 8210DA20h-8210DA28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210DA28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210DA28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210DA28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210DA28);
		  /* 8210DA28h */ case    0:  		/* mfspr R12, LR */
		/* 8210DA28h case    0:*/		regs.R12 = regs.LR;
		/* 8210DA28h case    0:*/		return 0x8210DA2C;
		  /* 8210DA2Ch */ case    1:  		/* bl -509924 */
		/* 8210DA2Ch case    1:*/		regs.LR = 0x8210DA30; return 0x82091248;
		/* 8210DA2Ch case    1:*/		return 0x8210DA30;
		  /* 8210DA30h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 8210DA30h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 8210DA30h case    2:*/		return 0x8210DA34;
		  /* 8210DA34h */ case    3:  		/* mr R27, R3 */
		/* 8210DA34h case    3:*/		regs.R27 = regs.R3;
		/* 8210DA34h case    3:*/		return 0x8210DA38;
		  /* 8210DA38h */ case    4:  		/* bl -32416 */
		/* 8210DA38h case    4:*/		regs.LR = 0x8210DA3C; return 0x82105B98;
		/* 8210DA38h case    4:*/		return 0x8210DA3C;
		  /* 8210DA3Ch */ case    5:  		/* lwz R11, <#[R27 + 12]> */
		/* 8210DA3Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 8210DA3Ch case    5:*/		return 0x8210DA40;
		  /* 8210DA40h */ case    6:  		/* li R24, 0 */
		/* 8210DA40h case    6:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 8210DA40h case    6:*/		return 0x8210DA44;
		  /* 8210DA44h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8210DA44h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210DA44h case    7:*/		return 0x8210DA48;
		  /* 8210DA48h */ case    8:  		/* bc 4, CR6_GT, 676 */
		/* 8210DA48h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8210DCEC;  }
		/* 8210DA48h case    8:*/		return 0x8210DA4C;
		  /* 8210DA4Ch */ case    9:  		/* li R25, 0 */
		/* 8210DA4Ch case    9:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 8210DA4Ch case    9:*/		return 0x8210DA50;
		  /* 8210DA50h */ case   10:  		/* li R26, -1 */
		/* 8210DA50h case   10:*/		cpu::op::li<0>(regs,&regs.R26,0xFFFFFFFF);
		/* 8210DA50h case   10:*/		return 0x8210DA54;
		  /* 8210DA54h */ case   11:  		/* lwz R11, <#[R27 + 24]> */
		/* 8210DA54h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000018) );
		/* 8210DA54h case   11:*/		return 0x8210DA58;
		  /* 8210DA58h */ case   12:  		/* lwzx R29, <#[R25 + R11]> */
		/* 8210DA58h case   12:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R25 + regs.R11 + 0x00000000) );
		/* 8210DA58h case   12:*/		return 0x8210DA5C;
		  /* 8210DA5Ch */ case   13:  		/* lwz R11, <#[R29]> */
		/* 8210DA5Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8210DA5Ch case   13:*/		return 0x8210DA60;
		  /* 8210DA60h */ case   14:  		/* rlwinm. R10, R11, 0, 0, 11 */
		/* 8210DA60h case   14:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R10,regs.R11);
		/* 8210DA60h case   14:*/		return 0x8210DA64;
		  /* 8210DA64h */ case   15:  		/* bc 12, CR0_EQ, 628 */
		/* 8210DA64h case   15:*/		if ( regs.CR[0].eq ) { return 0x8210DCD8;  }
		/* 8210DA64h case   15:*/		return 0x8210DA68;
		  /* 8210DA68h */ case   16:  		/* lwz R9, <#[R29 + 4]> */
		/* 8210DA68h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000004) );
		/* 8210DA68h case   16:*/		return 0x8210DA6C;
		  /* 8210DA6Ch */ case   17:  		/* rlwinm R31, R11, 0, 12, 31 */
		/* 8210DA6Ch case   17:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R31,regs.R11);
		/* 8210DA6Ch case   17:*/		return 0x8210DA70;
		  /* 8210DA70h */ case   18:  		/* lis R8, 20480 */
		/* 8210DA70h case   18:*/		cpu::op::lis<0>(regs,&regs.R8,0x5000);
		/* 8210DA70h case   18:*/		return 0x8210DA74;
		  /* 8210DA74h */ case   19:  		/* divwu R28, R9, R31 */
		/* 8210DA74h case   19:*/		cpu::op::divwu<0>(regs,&regs.R28,regs.R9,regs.R31);
		/* 8210DA74h case   19:*/		return 0x8210DA78;
		  /* 8210DA78h */ case   20:  		/* twi 6, R31, 0 */
		/* 8210DA78h case   20:*/		cpu::op::tw<6>(regs, 0x8210DA78, regs.R31, 0x00000000);
		/* 8210DA78h case   20:*/		return 0x8210DA7C;
		  /* 8210DA7Ch */ case   21:  		/* cmplw CR6, R10, R8 */
		/* 8210DA7Ch case   21:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8210DA7Ch case   21:*/		return 0x8210DA80;
		  /* 8210DA80h */ case   22:  		/* bc 4, CR6_EQ, 104 */
		/* 8210DA80h case   22:*/		if ( !regs.CR[6].eq ) { return 0x8210DAE8;  }
		/* 8210DA80h case   22:*/		return 0x8210DA84;
		  /* 8210DA84h */ case   23:  		/* lwz R11, <#[R29 + 8]> */
		/* 8210DA84h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8210DA84h case   23:*/		return 0x8210DA88;
		  /* 8210DA88h */ case   24:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 8210DA88h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 8210DA88h case   24:*/		return 0x8210DA8C;
		  /* 8210DA8Ch */ case   25:  		/* li R7, 1 */
		/* 8210DA8Ch case   25:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8210DA8Ch case   25:*/		return 0x8210DA90;
		  /* 8210DA90h */ case   26:  		/* mr R6, R31 */
		/* 8210DA90h case   26:*/		regs.R6 = regs.R31;
		/* 8210DA90h case   26:*/		return 0x8210DA94;
		  /* 8210DA94h */ case   27:  		/* addi R5, R1, 80 */
		/* 8210DA94h case   27:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8210DA94h case   27:*/		return 0x8210DA98;
		  /* 8210DA98h */ case   28:  		/* mr R3, R27 */
		/* 8210DA98h case   28:*/		regs.R3 = regs.R27;
		/* 8210DA98h case   28:*/		return 0x8210DA9C;
		  /* 8210DA9Ch */ case   29:  		/* add R4, R10, R11 */
		/* 8210DA9Ch case   29:*/		cpu::op::add<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 8210DA9Ch case   29:*/		return 0x8210DAA0;
		  /* 8210DAA0h */ case   30:  		/* bl -51624 */
		/* 8210DAA0h case   30:*/		regs.LR = 0x8210DAA4; return 0x821010F8;
		/* 8210DAA0h case   30:*/		return 0x8210DAA4;
		  /* 8210DAA4h */ case   31:  		/* lwz R3, <#[R29 + 8]> */
		/* 8210DAA4h case   31:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000008) );
		/* 8210DAA4h case   31:*/		return 0x8210DAA8;
		  /* 8210DAA8h */ case   32:  		/* cmplwi CR6, R31, 0 */
		/* 8210DAA8h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8210DAA8h case   32:*/		return 0x8210DAAC;
		  /* 8210DAACh */ case   33:  		/* bc 12, CR6_EQ, 216 */
		/* 8210DAACh case   33:*/		if ( regs.CR[6].eq ) { return 0x8210DB84;  }
		/* 8210DAACh case   33:*/		return 0x8210DAB0;
		  /* 8210DAB0h */ case   34:  		/* li R11, 0 */
		/* 8210DAB0h case   34:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210DAB0h case   34:*/		return 0x8210DAB4;
		  /* 8210DAB4h */ case   35:  		/* mtspr CTR, R31 */
		/* 8210DAB4h case   35:*/		regs.CTR = regs.R31;
		/* 8210DAB4h case   35:*/		return 0x8210DAB8;
		  /* 8210DAB8h */ case   36:  		/* addi R10, R1, 80 */
		/* 8210DAB8h case   36:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 8210DAB8h case   36:*/		return 0x8210DABC;
		  /* 8210DABCh */ case   37:  		/* addi R9, R1, 96 */
		/* 8210DABCh case   37:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 8210DABCh case   37:*/		return 0x8210DAC0;
		  /* 8210DAC0h */ case   38:  		/* lwzx R10, <#[R11 + R10]> */
		/* 8210DAC0h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210DAC0h case   38:*/		return 0x8210DAC4;
		  /* 8210DAC4h */ case   39:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210DAC4h case   39:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210DAC4h case   39:*/		return 0x8210DAC8;
		  /* 8210DAC8h */ case   40:  		/* lwzx R10, <#[R10 + R3]> */
		/* 8210DAC8h case   40:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 8210DAC8h case   40:*/		return 0x8210DACC;
		  /* 8210DACCh */ case   41:  		/* stwx R10, <#[R11 + R9]> */
		/* 8210DACCh case   41:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210DACCh case   41:*/		return 0x8210DAD0;
		  /* 8210DAD0h */ case   42:  		/* addi R11, R11, 4 */
		/* 8210DAD0h case   42:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210DAD0h case   42:*/		return 0x8210DAD4;
		  /* 8210DAD4h */ case   43:  		/* bc 16, CR0_LT, -28 */
		/* 8210DAD4h case   43:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210DAB8;  }
		/* 8210DAD4h case   43:*/		return 0x8210DAD8;
		  /* 8210DAD8h */ case   44:  		/* addi R4, R1, 96 */
		/* 8210DAD8h case   44:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 8210DAD8h case   44:*/		return 0x8210DADC;
		  /* 8210DADCh */ case   45:  		/* rlwinm R5, R31, 2, 0, 29 */
		/* 8210DADCh case   45:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R31);
		/* 8210DADCh case   45:*/		return 0x8210DAE0;
		  /* 8210DAE0h */ case   46:  		/* bl -507048 */
		/* 8210DAE0h case   46:*/		regs.LR = 0x8210DAE4; return 0x82091E38;
		/* 8210DAE0h case   46:*/		return 0x8210DAE4;
		  /* 8210DAE4h */ case   47:  		/* b 160 */
		/* 8210DAE4h case   47:*/		return 0x8210DB84;
		/* 8210DAE4h case   47:*/		return 0x8210DAE8;
	}
	return 0x8210DAE8;
} // Block from 8210DA28h-8210DAE8h (48 instructions)

//////////////////////////////////////////////////////
// Block at 8210DAE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210DAE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210DAE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210DAE8);
		  /* 8210DAE8h */ case    0:  		/* rlwinm R11, R11, 0, 0, 3 */
		/* 8210DAE8h case    0:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R11,regs.R11);
		/* 8210DAE8h case    0:*/		return 0x8210DAEC;
		  /* 8210DAECh */ case    1:  		/* lis R10, 4096 */
		/* 8210DAECh case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x1000);
		/* 8210DAECh case    1:*/		return 0x8210DAF0;
		  /* 8210DAF0h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 8210DAF0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210DAF0h case    2:*/		return 0x8210DAF4;
		  /* 8210DAF4h */ case    3:  		/* bc 12, CR6_LT, 144 */
		/* 8210DAF4h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210DB84;  }
		/* 8210DAF4h case    3:*/		return 0x8210DAF8;
		  /* 8210DAF8h */ case    4:  		/* lis R10, 16384 */
		/* 8210DAF8h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0x4000);
		/* 8210DAF8h case    4:*/		return 0x8210DAFC;
		  /* 8210DAFCh */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 8210DAFCh case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210DAFCh case    5:*/		return 0x8210DB00;
		  /* 8210DB00h */ case    6:  		/* bc 12, CR6_GT, 132 */
		/* 8210DB00h case    6:*/		if ( regs.CR[6].gt ) { return 0x8210DB84;  }
		/* 8210DB00h case    6:*/		return 0x8210DB04;
		  /* 8210DB04h */ case    7:  		/* li R7, 1 */
		/* 8210DB04h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8210DB04h case    7:*/		return 0x8210DB08;
		  /* 8210DB08h */ case    8:  		/* lwz R4, <#[R29 + 16]> */
		/* 8210DB08h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000010) );
		/* 8210DB08h case    8:*/		return 0x8210DB0C;
		  /* 8210DB0Ch */ case    9:  		/* mr R6, R31 */
		/* 8210DB0Ch case    9:*/		regs.R6 = regs.R31;
		/* 8210DB0Ch case    9:*/		return 0x8210DB10;
		  /* 8210DB10h */ case   10:  		/* addi R5, R1, 80 */
		/* 8210DB10h case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8210DB10h case   10:*/		return 0x8210DB14;
		  /* 8210DB14h */ case   11:  		/* mr R3, R27 */
		/* 8210DB14h case   11:*/		regs.R3 = regs.R27;
		/* 8210DB14h case   11:*/		return 0x8210DB18;
		  /* 8210DB18h */ case   12:  		/* bl -51744 */
		/* 8210DB18h case   12:*/		regs.LR = 0x8210DB1C; return 0x821010F8;
		/* 8210DB18h case   12:*/		return 0x8210DB1C;
		  /* 8210DB1Ch */ case   13:  		/* li R30, 0 */
		/* 8210DB1Ch case   13:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8210DB1Ch case   13:*/		return 0x8210DB20;
		  /* 8210DB20h */ case   14:  		/* cmplwi CR6, R28, 0 */
		/* 8210DB20h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8210DB20h case   14:*/		return 0x8210DB24;
		  /* 8210DB24h */ case   15:  		/* bc 12, CR6_EQ, 96 */
		/* 8210DB24h case   15:*/		if ( regs.CR[6].eq ) { return 0x8210DB84;  }
		/* 8210DB24h case   15:*/		return 0x8210DB28;
		  /* 8210DB28h */ case   16:  		/* lwz R10, <#[R29 + 12]> */
		/* 8210DB28h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000000C) );
		/* 8210DB28h case   16:*/		return 0x8210DB2C;
		  /* 8210DB2Ch */ case   17:  		/* cmplwi CR6, R31, 0 */
		/* 8210DB2Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8210DB2Ch case   17:*/		return 0x8210DB30;
		  /* 8210DB30h */ case   18:  		/* lwz R11, <#[R29 + 8]> */
		/* 8210DB30h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8210DB30h case   18:*/		return 0x8210DB34;
		  /* 8210DB34h */ case   19:  		/* mullw R10, R30, R10 */
		/* 8210DB34h case   19:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R30,regs.R10);
		/* 8210DB34h case   19:*/		return 0x8210DB38;
		  /* 8210DB38h */ case   20:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210DB38h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210DB38h case   20:*/		return 0x8210DB3C;
		  /* 8210DB3Ch */ case   21:  		/* add R3, R10, R11 */
		/* 8210DB3Ch case   21:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8210DB3Ch case   21:*/		return 0x8210DB40;
		  /* 8210DB40h */ case   22:  		/* bc 12, CR6_EQ, 56 */
		/* 8210DB40h case   22:*/		if ( regs.CR[6].eq ) { return 0x8210DB78;  }
		/* 8210DB40h case   22:*/		return 0x8210DB44;
		  /* 8210DB44h */ case   23:  		/* li R11, 0 */
		/* 8210DB44h case   23:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210DB44h case   23:*/		return 0x8210DB48;
		  /* 8210DB48h */ case   24:  		/* mtspr CTR, R31 */
		/* 8210DB48h case   24:*/		regs.CTR = regs.R31;
		/* 8210DB48h case   24:*/		return 0x8210DB4C;
		  /* 8210DB4Ch */ case   25:  		/* addi R10, R1, 80 */
		/* 8210DB4Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 8210DB4Ch case   25:*/		return 0x8210DB50;
		  /* 8210DB50h */ case   26:  		/* addi R9, R1, 112 */
		/* 8210DB50h case   26:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 8210DB50h case   26:*/		return 0x8210DB54;
		  /* 8210DB54h */ case   27:  		/* lwzx R10, <#[R11 + R10]> */
		/* 8210DB54h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210DB54h case   27:*/		return 0x8210DB58;
		  /* 8210DB58h */ case   28:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210DB58h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210DB58h case   28:*/		return 0x8210DB5C;
		  /* 8210DB5Ch */ case   29:  		/* lwzx R10, <#[R10 + R3]> */
		/* 8210DB5Ch case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 8210DB5Ch case   29:*/		return 0x8210DB60;
		  /* 8210DB60h */ case   30:  		/* stwx R10, <#[R11 + R9]> */
		/* 8210DB60h case   30:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210DB60h case   30:*/		return 0x8210DB64;
		  /* 8210DB64h */ case   31:  		/* addi R11, R11, 4 */
		/* 8210DB64h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210DB64h case   31:*/		return 0x8210DB68;
		  /* 8210DB68h */ case   32:  		/* bc 16, CR0_LT, -28 */
		/* 8210DB68h case   32:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210DB4C;  }
		/* 8210DB68h case   32:*/		return 0x8210DB6C;
		  /* 8210DB6Ch */ case   33:  		/* addi R4, R1, 112 */
		/* 8210DB6Ch case   33:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 8210DB6Ch case   33:*/		return 0x8210DB70;
		  /* 8210DB70h */ case   34:  		/* rlwinm R5, R31, 2, 0, 29 */
		/* 8210DB70h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R31);
		/* 8210DB70h case   34:*/		return 0x8210DB74;
		  /* 8210DB74h */ case   35:  		/* bl -507196 */
		/* 8210DB74h case   35:*/		regs.LR = 0x8210DB78; return 0x82091E38;
		/* 8210DB74h case   35:*/		return 0x8210DB78;
	}
	return 0x8210DB78;
} // Block from 8210DAE8h-8210DB78h (36 instructions)

//////////////////////////////////////////////////////
// Block at 8210DB78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210DB78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210DB78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210DB78);
		  /* 8210DB78h */ case    0:  		/* addi R30, R30, 1 */
		/* 8210DB78h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8210DB78h case    0:*/		return 0x8210DB7C;
		  /* 8210DB7Ch */ case    1:  		/* cmplw CR6, R30, R28 */
		/* 8210DB7Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R28);
		/* 8210DB7Ch case    1:*/		return 0x8210DB80;
		  /* 8210DB80h */ case    2:  		/* bc 12, CR6_LT, -88 */
		/* 8210DB80h case    2:*/		if ( regs.CR[6].lt ) { return 0x8210DB28;  }
		/* 8210DB80h case    2:*/		return 0x8210DB84;
	}
	return 0x8210DB84;
} // Block from 8210DB78h-8210DB84h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210DB84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210DB84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210DB84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210DB84);
		  /* 8210DB84h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8210DB84h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8210DB84h case    0:*/		return 0x8210DB88;
		  /* 8210DB88h */ case    1:  		/* lis R10, 8192 */
		/* 8210DB88h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x2000);
		/* 8210DB88h case    1:*/		return 0x8210DB8C;
		  /* 8210DB8Ch */ case    2:  		/* rlwinm R11, R11, 0, 0, 3 */
		/* 8210DB8Ch case    2:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R11,regs.R11);
		/* 8210DB8Ch case    2:*/		return 0x8210DB90;
		  /* 8210DB90h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 8210DB90h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210DB90h case    3:*/		return 0x8210DB94;
		  /* 8210DB94h */ case    4:  		/* bc 4, CR6_EQ, 324 */
		/* 8210DB94h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8210DCD8;  }
		/* 8210DB94h case    4:*/		return 0x8210DB98;
		  /* 8210DB98h */ case    5:  		/* mr R3, R29 */
		/* 8210DB98h case    5:*/		regs.R3 = regs.R29;
		/* 8210DB98h case    5:*/		return 0x8210DB9C;
		  /* 8210DB9Ch */ case    6:  		/* bl -72604 */
		/* 8210DB9Ch case    6:*/		regs.LR = 0x8210DBA0; return 0x820FC000;
		/* 8210DB9Ch case    6:*/		return 0x8210DBA0;
		  /* 8210DBA0h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 8210DBA0h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210DBA0h case    7:*/		return 0x8210DBA4;
		  /* 8210DBA4h */ case    8:  		/* bc 12, CR0_EQ, 308 */
		/* 8210DBA4h case    8:*/		if ( regs.CR[0].eq ) { return 0x8210DCD8;  }
		/* 8210DBA4h case    8:*/		return 0x8210DBA8;
		  /* 8210DBA8h */ case    9:  		/* lwz R11, <#[R29 + 8]> */
		/* 8210DBA8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8210DBA8h case    9:*/		return 0x8210DBAC;
		  /* 8210DBACh */ case   10:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 8210DBACh case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 8210DBACh case   10:*/		return 0x8210DBB0;
		  /* 8210DBB0h */ case   11:  		/* lwz R9, <#[R27 + 20]> */
		/* 8210DBB0h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000014) );
		/* 8210DBB0h case   11:*/		return 0x8210DBB4;
		  /* 8210DBB4h */ case   12:  		/* mr R4, R26 */
		/* 8210DBB4h case   12:*/		regs.R4 = regs.R26;
		/* 8210DBB4h case   12:*/		return 0x8210DBB8;
		  /* 8210DBB8h */ case   13:  		/* mr R5, R26 */
		/* 8210DBB8h case   13:*/		regs.R5 = regs.R26;
		/* 8210DBB8h case   13:*/		return 0x8210DBBC;
		  /* 8210DBBCh */ case   14:  		/* cmplwi CR6, R31, 0 */
		/* 8210DBBCh case   14:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8210DBBCh case   14:*/		return 0x8210DBC0;
		  /* 8210DBC0h */ case   15:  		/* lwz R8, <#[R11]> */
		/* 8210DBC0h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8210DBC0h case   15:*/		return 0x8210DBC4;
		  /* 8210DBC4h */ case   16:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210DBC4h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210DBC4h case   16:*/		return 0x8210DBC8;
		  /* 8210DBC8h */ case   17:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8210DBC8h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8210DBC8h case   17:*/		return 0x8210DBCC;
		  /* 8210DBCCh */ case   18:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210DBCCh case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210DBCCh case   18:*/		return 0x8210DBD0;
		  /* 8210DBD0h */ case   19:  		/* lwzx R3, <#[R8 + R9]> */
		/* 8210DBD0h case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 8210DBD0h case   19:*/		return 0x8210DBD4;
		  /* 8210DBD4h */ case   20:  		/* lwzx R30, <#[R11 + R9]> */
		/* 8210DBD4h case   20:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210DBD4h case   20:*/		return 0x8210DBD8;
		  /* 8210DBD8h */ case   21:  		/* bc 12, CR6_EQ, 104 */
		/* 8210DBD8h case   21:*/		if ( regs.CR[6].eq ) { return 0x8210DC40;  }
		/* 8210DBD8h case   21:*/		return 0x8210DBDC;
		  /* 8210DBDCh */ case   22:  		/* lwz R11, <#[R29 + 8]> */
		/* 8210DBDCh case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8210DBDCh case   22:*/		return 0x8210DBE0;
		  /* 8210DBE0h */ case   23:  		/* li R7, 0 */
		/* 8210DBE0h case   23:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8210DBE0h case   23:*/		return 0x8210DBE4;
		  /* 8210DBE4h */ case   24:  		/* rlwinm R9, R9, 0, 0, 31 */
		/* 8210DBE4h case   24:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R9,regs.R9);
		/* 8210DBE4h case   24:*/		return 0x8210DBE8;
		  /* 8210DBE8h */ case   25:  		/* mtspr CTR, R31 */
		/* 8210DBE8h case   25:*/		regs.CTR = regs.R31;
		/* 8210DBE8h case   25:*/		return 0x8210DBEC;
		  /* 8210DBECh */ case   26:  		/* mr R6, R10 */
		/* 8210DBECh case   26:*/		regs.R6 = regs.R10;
		/* 8210DBECh case   26:*/		return 0x8210DBF0;
		  /* 8210DBF0h */ case   27:  		/* lwzx R8, <#[R7 + R11]> */
		/* 8210DBF0h case   27:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 8210DBF0h case   27:*/		return 0x8210DBF4;
		  /* 8210DBF4h */ case   28:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8210DBF4h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8210DBF4h case   28:*/		return 0x8210DBF8;
		  /* 8210DBF8h */ case   29:  		/* lwzx R8, <#[R8 + R9]> */
		/* 8210DBF8h case   29:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 8210DBF8h case   29:*/		return 0x8210DBFC;
		  /* 8210DBFCh */ case   30:  		/* lwz R8, <#[R8 + 72]> */
		/* 8210DBFCh case   30:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000048) );
		/* 8210DBFCh case   30:*/		return 0x8210DC00;
		  /* 8210DC00h */ case   31:  		/* cmplw CR6, R8, R4 */
		/* 8210DC00h case   31:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R4);
		/* 8210DC00h case   31:*/		return 0x8210DC04;
		  /* 8210DC04h */ case   32:  		/* bc 4, CR6_LT, 8 */
		/* 8210DC04h case   32:*/		if ( !regs.CR[6].lt ) { return 0x8210DC0C;  }
		/* 8210DC04h case   32:*/		return 0x8210DC08;
		  /* 8210DC08h */ case   33:  		/* mr R4, R8 */
		/* 8210DC08h case   33:*/		regs.R4 = regs.R8;
		/* 8210DC08h case   33:*/		return 0x8210DC0C;
	}
	return 0x8210DC0C;
} // Block from 8210DB84h-8210DC0Ch (34 instructions)

//////////////////////////////////////////////////////
// Block at 8210DC0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210DC0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210DC0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210DC0C);
		  /* 8210DC0Ch */ case    0:  		/* lwzx R8, <#[R11 + R6]> */
		/* 8210DC0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 8210DC0Ch case    0:*/		return 0x8210DC10;
		  /* 8210DC10h */ case    1:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8210DC10h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8210DC10h case    1:*/		return 0x8210DC14;
		  /* 8210DC14h */ case    2:  		/* lwzx R8, <#[R8 + R9]> */
		/* 8210DC14h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 8210DC14h case    2:*/		return 0x8210DC18;
		  /* 8210DC18h */ case    3:  		/* lwz R8, <#[R8 + 72]> */
		/* 8210DC18h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000048) );
		/* 8210DC18h case    3:*/		return 0x8210DC1C;
		  /* 8210DC1Ch */ case    4:  		/* cmplw CR6, R8, R5 */
		/* 8210DC1Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R5);
		/* 8210DC1Ch case    4:*/		return 0x8210DC20;
		  /* 8210DC20h */ case    5:  		/* bc 4, CR6_LT, 8 */
		/* 8210DC20h case    5:*/		if ( !regs.CR[6].lt ) { return 0x8210DC28;  }
		/* 8210DC20h case    5:*/		return 0x8210DC24;
		  /* 8210DC24h */ case    6:  		/* mr R5, R8 */
		/* 8210DC24h case    6:*/		regs.R5 = regs.R8;
		/* 8210DC24h case    6:*/		return 0x8210DC28;
	}
	return 0x8210DC28;
} // Block from 8210DC0Ch-8210DC28h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210DC28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210DC28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210DC28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210DC28);
		  /* 8210DC28h */ case    0:  		/* addi R7, R7, 4 */
		/* 8210DC28h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 8210DC28h case    0:*/		return 0x8210DC2C;
		  /* 8210DC2Ch */ case    1:  		/* addi R6, R6, 4 */
		/* 8210DC2Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 8210DC2Ch case    1:*/		return 0x8210DC30;
		  /* 8210DC30h */ case    2:  		/* bc 16, CR0_LT, -64 */
		/* 8210DC30h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210DBF0;  }
		/* 8210DC30h case    2:*/		return 0x8210DC34;
		  /* 8210DC34h */ case    3:  		/* cmplw CR6, R4, R5 */
		/* 8210DC34h case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R5);
		/* 8210DC34h case    3:*/		return 0x8210DC38;
		  /* 8210DC38h */ case    4:  		/* bc 12, CR6_LT, 160 */
		/* 8210DC38h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210DCD8;  }
		/* 8210DC38h case    4:*/		return 0x8210DC3C;
		  /* 8210DC3Ch */ case    5:  		/* bc 4, CR6_EQ, 104 */
		/* 8210DC3Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x8210DCA4;  }
		/* 8210DC3Ch case    5:*/		return 0x8210DC40;
	}
	return 0x8210DC40;
} // Block from 8210DC28h-8210DC40h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210DC40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210DC40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210DC40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210DC40);
		  /* 8210DC40h */ case    0:  		/* lwz R8, <#[R30 + 4]> */
		/* 8210DC40h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000004) );
		/* 8210DC40h case    0:*/		return 0x8210DC44;
		  /* 8210DC44h */ case    1:  		/* lwz R7, <#[R3 + 4]> */
		/* 8210DC44h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000004) );
		/* 8210DC44h case    1:*/		return 0x8210DC48;
		  /* 8210DC48h */ case    2:  		/* lwz R6, <#[R27 + 16]> */
		/* 8210DC48h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R27 + 0x00000010) );
		/* 8210DC48h case    2:*/		return 0x8210DC4C;
		  /* 8210DC4Ch */ case    3:  		/* rlwinm R11, R8, 2, 0, 29 */
		/* 8210DC4Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R8);
		/* 8210DC4Ch case    3:*/		return 0x8210DC50;
		  /* 8210DC50h */ case    4:  		/* rlwinm R9, R7, 2, 0, 29 */
		/* 8210DC50h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R7);
		/* 8210DC50h case    4:*/		return 0x8210DC54;
		  /* 8210DC54h */ case    5:  		/* lwzx R5, <#[R6 + R11]> */
		/* 8210DC54h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 8210DC54h case    5:*/		return 0x8210DC58;
		  /* 8210DC58h */ case    6:  		/* lwzx R6, <#[R9 + R6]> */
		/* 8210DC58h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 8210DC58h case    6:*/		return 0x8210DC5C;
		  /* 8210DC5Ch */ case    7:  		/* lwz R5, <#[R5 + 4]> */
		/* 8210DC5Ch case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000004) );
		/* 8210DC5Ch case    7:*/		return 0x8210DC60;
		  /* 8210DC60h */ case    8:  		/* lwz R6, <#[R6 + 4]> */
		/* 8210DC60h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000004) );
		/* 8210DC60h case    8:*/		return 0x8210DC64;
		  /* 8210DC64h */ case    9:  		/* cmplw CR6, R6, R5 */
		/* 8210DC64h case    9:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R5);
		/* 8210DC64h case    9:*/		return 0x8210DC68;
		  /* 8210DC68h */ case   10:  		/* bc 12, CR6_LT, 112 */
		/* 8210DC68h case   10:*/		if ( regs.CR[6].lt ) { return 0x8210DCD8;  }
		/* 8210DC68h case   10:*/		return 0x8210DC6C;
		  /* 8210DC6Ch */ case   11:  		/* lwz R6, <#[R27 + 16]> */
		/* 8210DC6Ch case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R27 + 0x00000010) );
		/* 8210DC6Ch case   11:*/		return 0x8210DC70;
		  /* 8210DC70h */ case   12:  		/* lwzx R9, <#[R6 + R9]> */
		/* 8210DC70h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + regs.R9 + 0x00000000) );
		/* 8210DC70h case   12:*/		return 0x8210DC74;
		  /* 8210DC74h */ case   13:  		/* lwzx R11, <#[R6 + R11]> */
		/* 8210DC74h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 8210DC74h case   13:*/		return 0x8210DC78;
		  /* 8210DC78h */ case   14:  		/* lwz R9, <#[R9 + 4]> */
		/* 8210DC78h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 8210DC78h case   14:*/		return 0x8210DC7C;
		  /* 8210DC7Ch */ case   15:  		/* lwz R11, <#[R11 + 4]> */
		/* 8210DC7Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8210DC7Ch case   15:*/		return 0x8210DC80;
		  /* 8210DC80h */ case   16:  		/* cmplw CR6, R9, R11 */
		/* 8210DC80h case   16:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8210DC80h case   16:*/		return 0x8210DC84;
		  /* 8210DC84h */ case   17:  		/* bc 4, CR6_EQ, 32 */
		/* 8210DC84h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8210DCA4;  }
		/* 8210DC84h case   17:*/		return 0x8210DC88;
		  /* 8210DC88h */ case   18:  		/* cmplw CR6, R7, R8 */
		/* 8210DC88h case   18:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 8210DC88h case   18:*/		return 0x8210DC8C;
		  /* 8210DC8Ch */ case   19:  		/* bc 12, CR6_LT, 76 */
		/* 8210DC8Ch case   19:*/		if ( regs.CR[6].lt ) { return 0x8210DCD8;  }
		/* 8210DC8Ch case   19:*/		return 0x8210DC90;
		  /* 8210DC90h */ case   20:  		/* bc 4, CR6_EQ, 20 */
		/* 8210DC90h case   20:*/		if ( !regs.CR[6].eq ) { return 0x8210DCA4;  }
		/* 8210DC90h case   20:*/		return 0x8210DC94;
		  /* 8210DC94h */ case   21:  		/* lwz R11, <#[R3 + 12]> */
		/* 8210DC94h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8210DC94h case   21:*/		return 0x8210DC98;
		  /* 8210DC98h */ case   22:  		/* lwz R9, <#[R30 + 12]> */
		/* 8210DC98h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000000C) );
		/* 8210DC98h case   22:*/		return 0x8210DC9C;
		  /* 8210DC9Ch */ case   23:  		/* cmplw CR6, R11, R9 */
		/* 8210DC9Ch case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210DC9Ch case   23:*/		return 0x8210DCA0;
		  /* 8210DCA0h */ case   24:  		/* bc 12, CR6_LT, 56 */
		/* 8210DCA0h case   24:*/		if ( regs.CR[6].lt ) { return 0x8210DCD8;  }
		/* 8210DCA0h case   24:*/		return 0x8210DCA4;
	}
	return 0x8210DCA4;
} // Block from 8210DC40h-8210DCA4h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8210DCA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210DCA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210DCA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210DCA4);
		  /* 8210DCA4h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 8210DCA4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8210DCA4h case    0:*/		return 0x8210DCA8;
		  /* 8210DCA8h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 8210DCA8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8210DCD8;  }
		/* 8210DCA8h case    1:*/		return 0x8210DCAC;
		  /* 8210DCACh */ case    2:  		/* li R11, 0 */
		/* 8210DCACh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210DCACh case    2:*/		return 0x8210DCB0;
		  /* 8210DCB0h */ case    3:  		/* mtspr CTR, R31 */
		/* 8210DCB0h case    3:*/		regs.CTR = regs.R31;
		/* 8210DCB0h case    3:*/		return 0x8210DCB4;
		  /* 8210DCB4h */ case    4:  		/* lwz R9, <#[R29 + 8]> */
		/* 8210DCB4h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 8210DCB4h case    4:*/		return 0x8210DCB8;
		  /* 8210DCB8h */ case    5:  		/* lwzx R8, <#[R9 + R10]> */
		/* 8210DCB8h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210DCB8h case    5:*/		return 0x8210DCBC;
		  /* 8210DCBCh */ case    6:  		/* lwzx R7, <#[R9 + R11]> */
		/* 8210DCBCh case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8210DCBCh case    6:*/		return 0x8210DCC0;
		  /* 8210DCC0h */ case    7:  		/* stwx R8, <#[R9 + R11]> */
		/* 8210DCC0h case    7:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8210DCC0h case    7:*/		return 0x8210DCC4;
		  /* 8210DCC4h */ case    8:  		/* addi R11, R11, 4 */
		/* 8210DCC4h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210DCC4h case    8:*/		return 0x8210DCC8;
		  /* 8210DCC8h */ case    9:  		/* lwz R9, <#[R29 + 8]> */
		/* 8210DCC8h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 8210DCC8h case    9:*/		return 0x8210DCCC;
		  /* 8210DCCCh */ case   10:  		/* stwx R7, <#[R9 + R10]> */
		/* 8210DCCCh case   10:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210DCCCh case   10:*/		return 0x8210DCD0;
		  /* 8210DCD0h */ case   11:  		/* addi R10, R10, 4 */
		/* 8210DCD0h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210DCD0h case   11:*/		return 0x8210DCD4;
		  /* 8210DCD4h */ case   12:  		/* bc 16, CR0_LT, -32 */
		/* 8210DCD4h case   12:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210DCB4;  }
		/* 8210DCD4h case   12:*/		return 0x8210DCD8;
	}
	return 0x8210DCD8;
} // Block from 8210DCA4h-8210DCD8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8210DCD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210DCD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210DCD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210DCD8);
		  /* 8210DCD8h */ case    0:  		/* lwz R11, <#[R27 + 12]> */
		/* 8210DCD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 8210DCD8h case    0:*/		return 0x8210DCDC;
		  /* 8210DCDCh */ case    1:  		/* addi R24, R24, 1 */
		/* 8210DCDCh case    1:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 8210DCDCh case    1:*/		return 0x8210DCE0;
		  /* 8210DCE0h */ case    2:  		/* addi R25, R25, 4 */
		/* 8210DCE0h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 8210DCE0h case    2:*/		return 0x8210DCE4;
		  /* 8210DCE4h */ case    3:  		/* cmplw CR6, R24, R11 */
		/* 8210DCE4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R11);
		/* 8210DCE4h case    3:*/		return 0x8210DCE8;
		  /* 8210DCE8h */ case    4:  		/* bc 12, CR6_LT, -660 */
		/* 8210DCE8h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210DA54;  }
		/* 8210DCE8h case    4:*/		return 0x8210DCEC;
	}
	return 0x8210DCEC;
} // Block from 8210DCD8h-8210DCECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210DCECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210DCEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210DCEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210DCEC);
		  /* 8210DCECh */ case    0:  		/* li R3, 0 */
		/* 8210DCECh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8210DCECh case    0:*/		return 0x8210DCF0;
		  /* 8210DCF0h */ case    1:  		/* addi R1, R1, 208 */
		/* 8210DCF0h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 8210DCF0h case    1:*/		return 0x8210DCF4;
		  /* 8210DCF4h */ case    2:  		/* b -510556 */
		/* 8210DCF4h case    2:*/		return 0x82091298;
		/* 8210DCF4h case    2:*/		return 0x8210DCF8;
	}
	return 0x8210DCF8;
} // Block from 8210DCECh-8210DCF8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210DCF8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210DCF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210DCF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210DCF8);
		  /* 8210DCF8h */ case    0:  		/* mfspr R12, LR */
		/* 8210DCF8h case    0:*/		regs.R12 = regs.LR;
		/* 8210DCF8h case    0:*/		return 0x8210DCFC;
		  /* 8210DCFCh */ case    1:  		/* bl -510664 */
		/* 8210DCFCh case    1:*/		regs.LR = 0x8210DD00; return 0x82091234;
		/* 8210DCFCh case    1:*/		return 0x8210DD00;
		  /* 8210DD00h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 8210DD00h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 8210DD00h case    2:*/		return 0x8210DD04;
		  /* 8210DD04h */ case    3:  		/* mr R25, R3 */
		/* 8210DD04h case    3:*/		regs.R25 = regs.R3;
		/* 8210DD04h case    3:*/		return 0x8210DD08;
		  /* 8210DD08h */ case    4:  		/* mr R31, R4 */
		/* 8210DD08h case    4:*/		regs.R31 = regs.R4;
		/* 8210DD08h case    4:*/		return 0x8210DD0C;
		  /* 8210DD0Ch */ case    5:  		/* mr R22, R5 */
		/* 8210DD0Ch case    5:*/		regs.R22 = regs.R5;
		/* 8210DD0Ch case    5:*/		return 0x8210DD10;
		  /* 8210DD10h */ case    6:  		/* mr R30, R6 */
		/* 8210DD10h case    6:*/		regs.R30 = regs.R6;
		/* 8210DD10h case    6:*/		return 0x8210DD14;
		  /* 8210DD14h */ case    7:  		/* bl -33148 */
		/* 8210DD14h case    7:*/		regs.LR = 0x8210DD18; return 0x82105B98;
		/* 8210DD14h case    7:*/		return 0x8210DD18;
		  /* 8210DD18h */ case    8:  		/* cmplwi CR6, R31, 0 */
		/* 8210DD18h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8210DD18h case    8:*/		return 0x8210DD1C;
		  /* 8210DD1Ch */ case    9:  		/* bc 4, CR6_EQ, 16 */
		/* 8210DD1Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x8210DD2C;  }
		/* 8210DD1Ch case    9:*/		return 0x8210DD20;
		  /* 8210DD20h */ case   10:  		/* lis R3, -32768 */
		/* 8210DD20h case   10:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8210DD20h case   10:*/		return 0x8210DD24;
		  /* 8210DD24h */ case   11:  		/* ori R3, R3, 16389 */
		/* 8210DD24h case   11:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8210DD24h case   11:*/		return 0x8210DD28;
		  /* 8210DD28h */ case   12:  		/* b 2328 */
		/* 8210DD28h case   12:*/		return 0x8210E640;
		/* 8210DD28h case   12:*/		return 0x8210DD2C;
	}
	return 0x8210DD2C;
} // Block from 8210DCF8h-8210DD2Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8210DD2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210DD2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210DD2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210DD2C);
		  /* 8210DD2Ch */ case    0:  		/* li R5, 100 */
		/* 8210DD2Ch case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x64);
		/* 8210DD2Ch case    0:*/		return 0x8210DD30;
		  /* 8210DD30h */ case    1:  		/* li R4, 0 */
		/* 8210DD30h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8210DD30h case    1:*/		return 0x8210DD34;
		  /* 8210DD34h */ case    2:  		/* mr R3, R31 */
		/* 8210DD34h case    2:*/		regs.R3 = regs.R31;
		/* 8210DD34h case    2:*/		return 0x8210DD38;
		  /* 8210DD38h */ case    3:  		/* bl -510456 */
		/* 8210DD38h case    3:*/		regs.LR = 0x8210DD3C; return 0x82091340;
		/* 8210DD38h case    3:*/		return 0x8210DD3C;
		  /* 8210DD3Ch */ case    4:  		/* lwz R11, <#[R31 + 96]> */
		/* 8210DD3Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 8210DD3Ch case    4:*/		return 0x8210DD40;
		  /* 8210DD40h */ case    5:  		/* stw R22, <#[R31]> */
		/* 8210DD40h case    5:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000000) );
		/* 8210DD40h case    5:*/		return 0x8210DD44;
		  /* 8210DD44h */ case    6:  		/* li R8, 0 */
		/* 8210DD44h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8210DD44h case    6:*/		return 0x8210DD48;
		  /* 8210DD48h */ case    7:  		/* stw R30, <#[R31 + 44]> */
		/* 8210DD48h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000002C) );
		/* 8210DD48h case    7:*/		return 0x8210DD4C;
		  /* 8210DD4Ch */ case    8:  		/* lwz R10, <#[R25 + 108]> */
		/* 8210DD4Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x0000006C) );
		/* 8210DD4Ch case    8:*/		return 0x8210DD50;
		  /* 8210DD50h */ case    9:  		/* rlwimi R11, R10, 31, 0, 0 */
		/* 8210DD50h case    9:*/		cpu::op::rlwimi<0,31,0,0>(regs,&regs.R11,regs.R10);
		/* 8210DD50h case    9:*/		return 0x8210DD54;
		  /* 8210DD54h */ case   10:  		/* stw R11, <#[R31 + 96]> */
		/* 8210DD54h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 8210DD54h case   10:*/		return 0x8210DD58;
		  /* 8210DD58h */ case   11:  		/* lwz R11, <#[R25 + 8]> */
		/* 8210DD58h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 8210DD58h case   11:*/		return 0x8210DD5C;
		  /* 8210DD5Ch */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 8210DD5Ch case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210DD5Ch case   12:*/		return 0x8210DD60;
		  /* 8210DD60h */ case   13:  		/* bc 4, CR6_GT, 104 */
		/* 8210DD60h case   13:*/		if ( !regs.CR[6].gt ) { return 0x8210DDC8;  }
		/* 8210DD60h case   13:*/		return 0x8210DD64;
		  /* 8210DD64h */ case   14:  		/* li R9, 0 */
		/* 8210DD64h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8210DD64h case   14:*/		return 0x8210DD68;
		  /* 8210DD68h */ case   15:  		/* lwz R11, <#[R25 + 20]> */
		/* 8210DD68h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000014) );
		/* 8210DD68h case   15:*/		return 0x8210DD6C;
		  /* 8210DD6Ch */ case   16:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210DD6Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210DD6Ch case   16:*/		return 0x8210DD70;
		  /* 8210DD70h */ case   17:  		/* lwz R10, <#[R11 + 4]> */
		/* 8210DD70h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210DD70h case   17:*/		return 0x8210DD74;
		  /* 8210DD74h */ case   18:  		/* cmplw CR6, R22, R10 */
		/* 8210DD74h case   18:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R10);
		/* 8210DD74h case   18:*/		return 0x8210DD78;
		  /* 8210DD78h */ case   19:  		/* bc 4, CR6_EQ, 60 */
		/* 8210DD78h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8210DDB4;  }
		/* 8210DD78h case   19:*/		return 0x8210DD7C;
		  /* 8210DD7Ch */ case   20:  		/* lwz R10, <#[R11 + 56]> */
		/* 8210DD7Ch case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000038) );
		/* 8210DD7Ch case   20:*/		return 0x8210DD80;
		  /* 8210DD80h */ case   21:  		/* cmpwi CR6, R10, -1 */
		/* 8210DD80h case   21:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210DD80h case   21:*/		return 0x8210DD84;
		  /* 8210DD84h */ case   22:  		/* bc 4, CR6_EQ, 48 */
		/* 8210DD84h case   22:*/		if ( !regs.CR[6].eq ) { return 0x8210DDB4;  }
		/* 8210DD84h case   22:*/		return 0x8210DD88;
		  /* 8210DD88h */ case   23:  		/* lwz R10, <#[R11 + 12]> */
		/* 8210DD88h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210DD88h case   23:*/		return 0x8210DD8C;
		  /* 8210DD8Ch */ case   24:  		/* lwz R7, <#[R31 + 40]> */
		/* 8210DD8Ch case   24:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000028) );
		/* 8210DD8Ch case   24:*/		return 0x8210DD90;
		  /* 8210DD90h */ case   25:  		/* cmplw CR6, R10, R7 */
		/* 8210DD90h case   25:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 8210DD90h case   25:*/		return 0x8210DD94;
		  /* 8210DD94h */ case   26:  		/* bc 12, CR6_LT, 12 */
		/* 8210DD94h case   26:*/		if ( regs.CR[6].lt ) { return 0x8210DDA0;  }
		/* 8210DD94h case   26:*/		return 0x8210DD98;
		  /* 8210DD98h */ case   27:  		/* addi R10, R10, 1 */
		/* 8210DD98h case   27:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210DD98h case   27:*/		return 0x8210DD9C;
		  /* 8210DD9Ch */ case   28:  		/* stw R10, <#[R31 + 40]> */
		/* 8210DD9Ch case   28:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000028) );
		/* 8210DD9Ch case   28:*/		return 0x8210DDA0;
	}
	return 0x8210DDA0;
} // Block from 8210DD2Ch-8210DDA0h (29 instructions)

//////////////////////////////////////////////////////
// Block at 8210DDA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210DDA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210DDA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210DDA0);
		  /* 8210DDA0h */ case    0:  		/* lwz R10, <#[R31 + 72]> */
		/* 8210DDA0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000048) );
		/* 8210DDA0h case    0:*/		return 0x8210DDA4;
		  /* 8210DDA4h */ case    1:  		/* stw R10, <#[R11 + 116]> */
		/* 8210DDA4h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000074) );
		/* 8210DDA4h case    1:*/		return 0x8210DDA8;
		  /* 8210DDA8h */ case    2:  		/* lwz R11, <#[R31 + 72]> */
		/* 8210DDA8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 8210DDA8h case    2:*/		return 0x8210DDAC;
		  /* 8210DDACh */ case    3:  		/* addi R11, R11, 1 */
		/* 8210DDACh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210DDACh case    3:*/		return 0x8210DDB0;
		  /* 8210DDB0h */ case    4:  		/* stw R11, <#[R31 + 72]> */
		/* 8210DDB0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 8210DDB0h case    4:*/		return 0x8210DDB4;
	}
	return 0x8210DDB4;
} // Block from 8210DDA0h-8210DDB4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210DDB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210DDB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210DDB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210DDB4);
		  /* 8210DDB4h */ case    0:  		/* lwz R11, <#[R25 + 8]> */
		/* 8210DDB4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 8210DDB4h case    0:*/		return 0x8210DDB8;
		  /* 8210DDB8h */ case    1:  		/* addi R8, R8, 1 */
		/* 8210DDB8h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8210DDB8h case    1:*/		return 0x8210DDBC;
		  /* 8210DDBCh */ case    2:  		/* addi R9, R9, 4 */
		/* 8210DDBCh case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8210DDBCh case    2:*/		return 0x8210DDC0;
		  /* 8210DDC0h */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 8210DDC0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8210DDC0h case    3:*/		return 0x8210DDC4;
		  /* 8210DDC4h */ case    4:  		/* bc 12, CR6_LT, -92 */
		/* 8210DDC4h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210DD68;  }
		/* 8210DDC4h case    4:*/		return 0x8210DDC8;
	}
	return 0x8210DDC8;
} // Block from 8210DDB4h-8210DDC8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210DDC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210DDC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210DDC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210DDC8);
		  /* 8210DDC8h */ case    0:  		/* lwz R11, <#[R31 + 40]> */
		/* 8210DDC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8210DDC8h case    0:*/		return 0x8210DDCC;
		  /* 8210DDCCh */ case    1:  		/* lis R4, 9345 */
		/* 8210DDCCh case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210DDCCh case    1:*/		return 0x8210DDD0;
		  /* 8210DDD0h */ case    2:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 8210DDD0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 8210DDD0h case    2:*/		return 0x8210DDD4;
		  /* 8210DDD4h */ case    3:  		/* bl -547796 */
		/* 8210DDD4h case    3:*/		regs.LR = 0x8210DDD8; return 0x82088200;
		/* 8210DDD4h case    3:*/		return 0x8210DDD8;
		  /* 8210DDD8h */ case    4:  		/* stw R3, <#[R31 + 16]> */
		/* 8210DDD8h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8210DDD8h case    4:*/		return 0x8210DDDC;
		  /* 8210DDDCh */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 8210DDDCh case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210DDDCh case    5:*/		return 0x8210DDE0;
		  /* 8210DDE0h */ case    6:  		/* bc 12, CR0_EQ, 2136 */
		/* 8210DDE0h case    6:*/		if ( regs.CR[0].eq ) { return 0x8210E638;  }
		/* 8210DDE0h case    6:*/		return 0x8210DDE4;
		  /* 8210DDE4h */ case    7:  		/* lwz R11, <#[R31 + 40]> */
		/* 8210DDE4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8210DDE4h case    7:*/		return 0x8210DDE8;
		  /* 8210DDE8h */ case    8:  		/* lis R4, 9345 */
		/* 8210DDE8h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210DDE8h case    8:*/		return 0x8210DDEC;
		  /* 8210DDECh */ case    9:  		/* rlwinm R3, R11, 4, 0, 27 */
		/* 8210DDECh case    9:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R3,regs.R11);
		/* 8210DDECh case    9:*/		return 0x8210DDF0;
		  /* 8210DDF0h */ case   10:  		/* bl -547824 */
		/* 8210DDF0h case   10:*/		regs.LR = 0x8210DDF4; return 0x82088200;
		/* 8210DDF0h case   10:*/		return 0x8210DDF4;
		  /* 8210DDF4h */ case   11:  		/* stw R3, <#[R31 + 20]> */
		/* 8210DDF4h case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 8210DDF4h case   11:*/		return 0x8210DDF8;
		  /* 8210DDF8h */ case   12:  		/* cmplwi CR0, R3, 0 */
		/* 8210DDF8h case   12:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210DDF8h case   12:*/		return 0x8210DDFC;
		  /* 8210DDFCh */ case   13:  		/* bc 12, CR0_EQ, 2108 */
		/* 8210DDFCh case   13:*/		if ( regs.CR[0].eq ) { return 0x8210E638;  }
		/* 8210DDFCh case   13:*/		return 0x8210DE00;
		  /* 8210DE00h */ case   14:  		/* lwz R11, <#[R31 + 40]> */
		/* 8210DE00h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8210DE00h case   14:*/		return 0x8210DE04;
		  /* 8210DE04h */ case   15:  		/* lis R4, 9345 */
		/* 8210DE04h case   15:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210DE04h case   15:*/		return 0x8210DE08;
		  /* 8210DE08h */ case   16:  		/* rlwinm R3, R11, 4, 0, 27 */
		/* 8210DE08h case   16:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R3,regs.R11);
		/* 8210DE08h case   16:*/		return 0x8210DE0C;
		  /* 8210DE0Ch */ case   17:  		/* bl -547852 */
		/* 8210DE0Ch case   17:*/		regs.LR = 0x8210DE10; return 0x82088200;
		/* 8210DE0Ch case   17:*/		return 0x8210DE10;
		  /* 8210DE10h */ case   18:  		/* stw R3, <#[R31 + 24]> */
		/* 8210DE10h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 8210DE10h case   18:*/		return 0x8210DE14;
		  /* 8210DE14h */ case   19:  		/* cmplwi CR0, R3, 0 */
		/* 8210DE14h case   19:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210DE14h case   19:*/		return 0x8210DE18;
		  /* 8210DE18h */ case   20:  		/* bc 12, CR0_EQ, 2080 */
		/* 8210DE18h case   20:*/		if ( regs.CR[0].eq ) { return 0x8210E638;  }
		/* 8210DE18h case   20:*/		return 0x8210DE1C;
		  /* 8210DE1Ch */ case   21:  		/* lwz R11, <#[R31 + 40]> */
		/* 8210DE1Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8210DE1Ch case   21:*/		return 0x8210DE20;
		  /* 8210DE20h */ case   22:  		/* lis R4, 9345 */
		/* 8210DE20h case   22:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210DE20h case   22:*/		return 0x8210DE24;
		  /* 8210DE24h */ case   23:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 8210DE24h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 8210DE24h case   23:*/		return 0x8210DE28;
		  /* 8210DE28h */ case   24:  		/* bl -547880 */
		/* 8210DE28h case   24:*/		regs.LR = 0x8210DE2C; return 0x82088200;
		/* 8210DE28h case   24:*/		return 0x8210DE2C;
		  /* 8210DE2Ch */ case   25:  		/* stw R3, <#[R31 + 8]> */
		/* 8210DE2Ch case   25:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 8210DE2Ch case   25:*/		return 0x8210DE30;
		  /* 8210DE30h */ case   26:  		/* cmplwi CR0, R3, 0 */
		/* 8210DE30h case   26:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210DE30h case   26:*/		return 0x8210DE34;
		  /* 8210DE34h */ case   27:  		/* bc 12, CR0_EQ, 2052 */
		/* 8210DE34h case   27:*/		if ( regs.CR[0].eq ) { return 0x8210E638;  }
		/* 8210DE34h case   27:*/		return 0x8210DE38;
		  /* 8210DE38h */ case   28:  		/* lwz R11, <#[R31 + 40]> */
		/* 8210DE38h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8210DE38h case   28:*/		return 0x8210DE3C;
		  /* 8210DE3Ch */ case   29:  		/* lis R4, 9345 */
		/* 8210DE3Ch case   29:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210DE3Ch case   29:*/		return 0x8210DE40;
		  /* 8210DE40h */ case   30:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 8210DE40h case   30:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 8210DE40h case   30:*/		return 0x8210DE44;
		  /* 8210DE44h */ case   31:  		/* bl -547908 */
		/* 8210DE44h case   31:*/		regs.LR = 0x8210DE48; return 0x82088200;
		/* 8210DE44h case   31:*/		return 0x8210DE48;
		  /* 8210DE48h */ case   32:  		/* stw R3, <#[R31 + 12]> */
		/* 8210DE48h case   32:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210DE48h case   32:*/		return 0x8210DE4C;
		  /* 8210DE4Ch */ case   33:  		/* cmplwi CR0, R3, 0 */
		/* 8210DE4Ch case   33:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210DE4Ch case   33:*/		return 0x8210DE50;
		  /* 8210DE50h */ case   34:  		/* bc 12, CR0_EQ, 2024 */
		/* 8210DE50h case   34:*/		if ( regs.CR[0].eq ) { return 0x8210E638;  }
		/* 8210DE50h case   34:*/		return 0x8210DE54;
		  /* 8210DE54h */ case   35:  		/* lwz R11, <#[R31 + 44]> */
		/* 8210DE54h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 8210DE54h case   35:*/		return 0x8210DE58;
		  /* 8210DE58h */ case   36:  		/* lis R4, 9345 */
		/* 8210DE58h case   36:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210DE58h case   36:*/		return 0x8210DE5C;
		  /* 8210DE5Ch */ case   37:  		/* rlwinm R3, R11, 4, 0, 27 */
		/* 8210DE5Ch case   37:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R3,regs.R11);
		/* 8210DE5Ch case   37:*/		return 0x8210DE60;
		  /* 8210DE60h */ case   38:  		/* bl -547936 */
		/* 8210DE60h case   38:*/		regs.LR = 0x8210DE64; return 0x82088200;
		/* 8210DE60h case   38:*/		return 0x8210DE64;
		  /* 8210DE64h */ case   39:  		/* stw R3, <#[R31 + 28]> */
		/* 8210DE64h case   39:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000001C) );
		/* 8210DE64h case   39:*/		return 0x8210DE68;
		  /* 8210DE68h */ case   40:  		/* cmplwi CR0, R3, 0 */
		/* 8210DE68h case   40:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210DE68h case   40:*/		return 0x8210DE6C;
		  /* 8210DE6Ch */ case   41:  		/* bc 12, CR0_EQ, 1996 */
		/* 8210DE6Ch case   41:*/		if ( regs.CR[0].eq ) { return 0x8210E638;  }
		/* 8210DE6Ch case   41:*/		return 0x8210DE70;
		  /* 8210DE70h */ case   42:  		/* lwz R11, <#[R31 + 44]> */
		/* 8210DE70h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 8210DE70h case   42:*/		return 0x8210DE74;
		  /* 8210DE74h */ case   43:  		/* lis R4, 9345 */
		/* 8210DE74h case   43:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210DE74h case   43:*/		return 0x8210DE78;
		  /* 8210DE78h */ case   44:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 8210DE78h case   44:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 8210DE78h case   44:*/		return 0x8210DE7C;
		  /* 8210DE7Ch */ case   45:  		/* bl -547964 */
		/* 8210DE7Ch case   45:*/		regs.LR = 0x8210DE80; return 0x82088200;
		/* 8210DE7Ch case   45:*/		return 0x8210DE80;
		  /* 8210DE80h */ case   46:  		/* stw R3, <#[R31 + 32]> */
		/* 8210DE80h case   46:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000020) );
		/* 8210DE80h case   46:*/		return 0x8210DE84;
		  /* 8210DE84h */ case   47:  		/* cmplwi CR0, R3, 0 */
		/* 8210DE84h case   47:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210DE84h case   47:*/		return 0x8210DE88;
		  /* 8210DE88h */ case   48:  		/* bc 12, CR0_EQ, 1968 */
		/* 8210DE88h case   48:*/		if ( regs.CR[0].eq ) { return 0x8210E638;  }
		/* 8210DE88h case   48:*/		return 0x8210DE8C;
		  /* 8210DE8Ch */ case   49:  		/* lwz R11, <#[R31 + 40]> */
		/* 8210DE8Ch case   49:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8210DE8Ch case   49:*/		return 0x8210DE90;
		  /* 8210DE90h */ case   50:  		/* lis R4, 9345 */
		/* 8210DE90h case   50:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210DE90h case   50:*/		return 0x8210DE94;
		  /* 8210DE94h */ case   51:  		/* rlwinm R3, R11, 4, 0, 27 */
		/* 8210DE94h case   51:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R3,regs.R11);
		/* 8210DE94h case   51:*/		return 0x8210DE98;
		  /* 8210DE98h */ case   52:  		/* bl -547992 */
		/* 8210DE98h case   52:*/		regs.LR = 0x8210DE9C; return 0x82088200;
		/* 8210DE98h case   52:*/		return 0x8210DE9C;
		  /* 8210DE9Ch */ case   53:  		/* cmplwi CR0, R3, 0 */
		/* 8210DE9Ch case   53:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210DE9Ch case   53:*/		return 0x8210DEA0;
		  /* 8210DEA0h */ case   54:  		/* stw R3, <#[R31 + 48]> */
		/* 8210DEA0h case   54:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8210DEA0h case   54:*/		return 0x8210DEA4;
		  /* 8210DEA4h */ case   55:  		/* bc 12, CR0_EQ, 1940 */
		/* 8210DEA4h case   55:*/		if ( regs.CR[0].eq ) { return 0x8210E638;  }
		/* 8210DEA4h case   55:*/		return 0x8210DEA8;
		  /* 8210DEA8h */ case   56:  		/* lwz R11, <#[R31 + 40]> */
		/* 8210DEA8h case   56:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8210DEA8h case   56:*/		return 0x8210DEAC;
		  /* 8210DEACh */ case   57:  		/* lis R4, 9345 */
		/* 8210DEACh case   57:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210DEACh case   57:*/		return 0x8210DEB0;
		  /* 8210DEB0h */ case   58:  		/* rlwinm R3, R11, 4, 0, 27 */
		/* 8210DEB0h case   58:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R3,regs.R11);
		/* 8210DEB0h case   58:*/		return 0x8210DEB4;
		  /* 8210DEB4h */ case   59:  		/* bl -548020 */
		/* 8210DEB4h case   59:*/		regs.LR = 0x8210DEB8; return 0x82088200;
		/* 8210DEB4h case   59:*/		return 0x8210DEB8;
		  /* 8210DEB8h */ case   60:  		/* cmplwi CR0, R3, 0 */
		/* 8210DEB8h case   60:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210DEB8h case   60:*/		return 0x8210DEBC;
		  /* 8210DEBCh */ case   61:  		/* stw R3, <#[R31 + 52]> */
		/* 8210DEBCh case   61:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000034) );
		/* 8210DEBCh case   61:*/		return 0x8210DEC0;
		  /* 8210DEC0h */ case   62:  		/* bc 12, CR0_EQ, 1912 */
		/* 8210DEC0h case   62:*/		if ( regs.CR[0].eq ) { return 0x8210E638;  }
		/* 8210DEC0h case   62:*/		return 0x8210DEC4;
		  /* 8210DEC4h */ case   63:  		/* lwz R11, <#[R31 + 40]> */
		/* 8210DEC4h case   63:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8210DEC4h case   63:*/		return 0x8210DEC8;
		  /* 8210DEC8h */ case   64:  		/* lis R4, 9345 */
		/* 8210DEC8h case   64:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210DEC8h case   64:*/		return 0x8210DECC;
		  /* 8210DECCh */ case   65:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 8210DECCh case   65:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 8210DECCh case   65:*/		return 0x8210DED0;
		  /* 8210DED0h */ case   66:  		/* bl -548048 */
		/* 8210DED0h case   66:*/		regs.LR = 0x8210DED4; return 0x82088200;
		/* 8210DED0h case   66:*/		return 0x8210DED4;
		  /* 8210DED4h */ case   67:  		/* cmplwi CR0, R3, 0 */
		/* 8210DED4h case   67:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210DED4h case   67:*/		return 0x8210DED8;
		  /* 8210DED8h */ case   68:  		/* stw R3, <#[R31 + 60]> */
		/* 8210DED8h case   68:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000003C) );
		/* 8210DED8h case   68:*/		return 0x8210DEDC;
		  /* 8210DEDCh */ case   69:  		/* bc 12, CR0_EQ, 1884 */
		/* 8210DEDCh case   69:*/		if ( regs.CR[0].eq ) { return 0x8210E638;  }
		/* 8210DEDCh case   69:*/		return 0x8210DEE0;
		  /* 8210DEE0h */ case   70:  		/* lwz R11, <#[R31 + 40]> */
		/* 8210DEE0h case   70:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8210DEE0h case   70:*/		return 0x8210DEE4;
		  /* 8210DEE4h */ case   71:  		/* lis R4, 9345 */
		/* 8210DEE4h case   71:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210DEE4h case   71:*/		return 0x8210DEE8;
		  /* 8210DEE8h */ case   72:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 8210DEE8h case   72:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 8210DEE8h case   72:*/		return 0x8210DEEC;
		  /* 8210DEECh */ case   73:  		/* bl -548076 */
		/* 8210DEECh case   73:*/		regs.LR = 0x8210DEF0; return 0x82088200;
		/* 8210DEECh case   73:*/		return 0x8210DEF0;
		  /* 8210DEF0h */ case   74:  		/* cmplwi CR0, R3, 0 */
		/* 8210DEF0h case   74:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210DEF0h case   74:*/		return 0x8210DEF4;
		  /* 8210DEF4h */ case   75:  		/* stw R3, <#[R31 + 64]> */
		/* 8210DEF4h case   75:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000040) );
		/* 8210DEF4h case   75:*/		return 0x8210DEF8;
		  /* 8210DEF8h */ case   76:  		/* bc 12, CR0_EQ, 1856 */
		/* 8210DEF8h case   76:*/		if ( regs.CR[0].eq ) { return 0x8210E638;  }
		/* 8210DEF8h case   76:*/		return 0x8210DEFC;
		  /* 8210DEFCh */ case   77:  		/* lwz R11, <#[R31 + 72]> */
		/* 8210DEFCh case   77:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 8210DEFCh case   77:*/		return 0x8210DF00;
		  /* 8210DF00h */ case   78:  		/* lis R4, 9345 */
		/* 8210DF00h case   78:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210DF00h case   78:*/		return 0x8210DF04;
		  /* 8210DF04h */ case   79:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 8210DF04h case   79:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 8210DF04h case   79:*/		return 0x8210DF08;
		  /* 8210DF08h */ case   80:  		/* bl -548104 */
		/* 8210DF08h case   80:*/		regs.LR = 0x8210DF0C; return 0x82088200;
		/* 8210DF08h case   80:*/		return 0x8210DF0C;
		  /* 8210DF0Ch */ case   81:  		/* cmplwi CR0, R3, 0 */
		/* 8210DF0Ch case   81:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210DF0Ch case   81:*/		return 0x8210DF10;
		  /* 8210DF10h */ case   82:  		/* stw R3, <#[R31 + 76]> */
		/* 8210DF10h case   82:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000004C) );
		/* 8210DF10h case   82:*/		return 0x8210DF14;
		  /* 8210DF14h */ case   83:  		/* bc 12, CR0_EQ, 1828 */
		/* 8210DF14h case   83:*/		if ( regs.CR[0].eq ) { return 0x8210E638;  }
		/* 8210DF14h case   83:*/		return 0x8210DF18;
		  /* 8210DF18h */ case   84:  		/* lwz R11, <#[R31 + 72]> */
		/* 8210DF18h case   84:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 8210DF18h case   84:*/		return 0x8210DF1C;
		  /* 8210DF1Ch */ case   85:  		/* lis R4, 9345 */
		/* 8210DF1Ch case   85:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210DF1Ch case   85:*/		return 0x8210DF20;
		  /* 8210DF20h */ case   86:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 8210DF20h case   86:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 8210DF20h case   86:*/		return 0x8210DF24;
		  /* 8210DF24h */ case   87:  		/* bl -548132 */
		/* 8210DF24h case   87:*/		regs.LR = 0x8210DF28; return 0x82088200;
		/* 8210DF24h case   87:*/		return 0x8210DF28;
		  /* 8210DF28h */ case   88:  		/* cmplwi CR0, R3, 0 */
		/* 8210DF28h case   88:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210DF28h case   88:*/		return 0x8210DF2C;
		  /* 8210DF2Ch */ case   89:  		/* stw R3, <#[R31 + 80]> */
		/* 8210DF2Ch case   89:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 8210DF2Ch case   89:*/		return 0x8210DF30;
		  /* 8210DF30h */ case   90:  		/* bc 12, CR0_EQ, 1800 */
		/* 8210DF30h case   90:*/		if ( regs.CR[0].eq ) { return 0x8210E638;  }
		/* 8210DF30h case   90:*/		return 0x8210DF34;
		  /* 8210DF34h */ case   91:  		/* li R23, 0 */
		/* 8210DF34h case   91:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 8210DF34h case   91:*/		return 0x8210DF38;
		  /* 8210DF38h */ case   92:  		/* lwz R11, <#[R31 + 40]> */
		/* 8210DF38h case   92:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8210DF38h case   92:*/		return 0x8210DF3C;
		  /* 8210DF3Ch */ case   93:  		/* li R4, 0 */
		/* 8210DF3Ch case   93:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8210DF3Ch case   93:*/		return 0x8210DF40;
		  /* 8210DF40h */ case   94:  		/* lwz R3, <#[R31 + 48]> */
		/* 8210DF40h case   94:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8210DF40h case   94:*/		return 0x8210DF44;
		  /* 8210DF44h */ case   95:  		/* rlwinm R5, R11, 4, 0, 27 */
		/* 8210DF44h case   95:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R5,regs.R11);
		/* 8210DF44h case   95:*/		return 0x8210DF48;
		  /* 8210DF48h */ case   96:  		/* bl -510984 */
		/* 8210DF48h case   96:*/		regs.LR = 0x8210DF4C; return 0x82091340;
		/* 8210DF48h case   96:*/		return 0x8210DF4C;
		  /* 8210DF4Ch */ case   97:  		/* lwz R11, <#[R25 + 12]> */
		/* 8210DF4Ch case   97:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000000C) );
		/* 8210DF4Ch case   97:*/		return 0x8210DF50;
		  /* 8210DF50h */ case   98:  		/* li R27, 0 */
		/* 8210DF50h case   98:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8210DF50h case   98:*/		return 0x8210DF54;
		  /* 8210DF54h */ case   99:  		/* li R24, 0 */
		/* 8210DF54h case   99:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 8210DF54h case   99:*/		return 0x8210DF58;
		  /* 8210DF58h */ case  100:  		/* cmplwi CR6, R11, 0 */
		/* 8210DF58h case  100:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210DF58h case  100:*/		return 0x8210DF5C;
		  /* 8210DF5Ch */ case  101:  		/* bc 4, CR6_GT, 704 */
		/* 8210DF5Ch case  101:*/		if ( !regs.CR[6].gt ) { return 0x8210E21C;  }
		/* 8210DF5Ch case  101:*/		return 0x8210DF60;
		  /* 8210DF60h */ case  102:  		/* li R26, 0 */
		/* 8210DF60h case  102:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8210DF60h case  102:*/		return 0x8210DF64;
		  /* 8210DF64h */ case  103:  		/* lwz R11, <#[R25 + 24]> */
		/* 8210DF64h case  103:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000018) );
		/* 8210DF64h case  103:*/		return 0x8210DF68;
		  /* 8210DF68h */ case  104:  		/* lwzx R30, <#[R26 + R11]> */
		/* 8210DF68h case  104:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 8210DF68h case  104:*/		return 0x8210DF6C;
		  /* 8210DF6Ch */ case  105:  		/* mr R3, R30 */
		/* 8210DF6Ch case  105:*/		regs.R3 = regs.R30;
		/* 8210DF6Ch case  105:*/		return 0x8210DF70;
		  /* 8210DF70h */ case  106:  		/* bl -73504 */
		/* 8210DF70h case  106:*/		regs.LR = 0x8210DF74; return 0x820FC050;
		/* 8210DF70h case  106:*/		return 0x8210DF74;
		  /* 8210DF74h */ case  107:  		/* cmpwi CR0, R3, 0 */
		/* 8210DF74h case  107:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210DF74h case  107:*/		return 0x8210DF78;
		  /* 8210DF78h */ case  108:  		/* bc 12, CR0_EQ, 656 */
		/* 8210DF78h case  108:*/		if ( regs.CR[0].eq ) { return 0x8210E208;  }
		/* 8210DF78h case  108:*/		return 0x8210DF7C;
		  /* 8210DF7Ch */ case  109:  		/* lwz R11, <#[R30 + 16]> */
		/* 8210DF7Ch case  109:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8210DF7Ch case  109:*/		return 0x8210DF80;
		  /* 8210DF80h */ case  110:  		/* lwz R10, <#[R25 + 20]> */
		/* 8210DF80h case  110:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000014) );
		/* 8210DF80h case  110:*/		return 0x8210DF84;
		  /* 8210DF84h */ case  111:  		/* lwz R11, <#[R11]> */
		/* 8210DF84h case  111:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8210DF84h case  111:*/		return 0x8210DF88;
		  /* 8210DF88h */ case  112:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210DF88h case  112:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210DF88h case  112:*/		return 0x8210DF8C;
		  /* 8210DF8Ch */ case  113:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210DF8Ch case  113:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210DF8Ch case  113:*/		return 0x8210DF90;
		  /* 8210DF90h */ case  114:  		/* lwz R11, <#[R11 + 4]> */
		/* 8210DF90h case  114:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8210DF90h case  114:*/		return 0x8210DF94;
		  /* 8210DF94h */ case  115:  		/* cmplw CR6, R22, R11 */
		/* 8210DF94h case  115:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 8210DF94h case  115:*/		return 0x8210DF98;
		  /* 8210DF98h */ case  116:  		/* bc 4, CR6_EQ, 624 */
		/* 8210DF98h case  116:*/		if ( !regs.CR[6].eq ) { return 0x8210E208;  }
		/* 8210DF98h case  116:*/		return 0x8210DF9C;
		  /* 8210DF9Ch */ case  117:  		/* lwz R11, <#[R30]> */
		/* 8210DF9Ch case  117:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8210DF9Ch case  117:*/		return 0x8210DFA0;
		  /* 8210DFA0h */ case  118:  		/* lwz R10, <#[R30 + 4]> */
		/* 8210DFA0h case  118:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 8210DFA0h case  118:*/		return 0x8210DFA4;
		  /* 8210DFA4h */ case  119:  		/* rlwinm R4, R11, 0, 12, 31 */
		/* 8210DFA4h case  119:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R4,regs.R11);
		/* 8210DFA4h case  119:*/		return 0x8210DFA8;
		  /* 8210DFA8h */ case  120:  		/* divwu. R11, R10, R4 */
		/* 8210DFA8h case  120:*/		cpu::op::divwu<1>(regs,&regs.R11,regs.R10,regs.R4);
		/* 8210DFA8h case  120:*/		return 0x8210DFAC;
		  /* 8210DFACh */ case  121:  		/* twi 6, R4, 0 */
		/* 8210DFACh case  121:*/		cpu::op::tw<6>(regs, 0x8210DFAC, regs.R4, 0x00000000);
		/* 8210DFACh case  121:*/		return 0x8210DFB0;
		  /* 8210DFB0h */ case  122:  		/* bc 12, CR0_EQ, 600 */
		/* 8210DFB0h case  122:*/		if ( regs.CR[0].eq ) { return 0x8210E208;  }
		/* 8210DFB0h case  122:*/		return 0x8210DFB4;
		  /* 8210DFB4h */ case  123:  		/* li R3, 0 */
		/* 8210DFB4h case  123:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8210DFB4h case  123:*/		return 0x8210DFB8;
		  /* 8210DFB8h */ case  124:  		/* rlwinm R28, R4, 2, 0, 29 */
		/* 8210DFB8h case  124:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R4);
		/* 8210DFB8h case  124:*/		return 0x8210DFBC;
		  /* 8210DFBCh */ case  125:  		/* mr R29, R11 */
		/* 8210DFBCh case  125:*/		regs.R29 = regs.R11;
		/* 8210DFBCh case  125:*/		return 0x8210DFC0;
		  /* 8210DFC0h */ case  126:  		/* lwz R11, <#[R30 + 8]> */
		/* 8210DFC0h case  126:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8210DFC0h case  126:*/		return 0x8210DFC4;
		  /* 8210DFC4h */ case  127:  		/* add R5, R11, R3 */
		/* 8210DFC4h case  127:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R3);
		/* 8210DFC4h case  127:*/		return 0x8210DFC8;
		  /* 8210DFC8h */ case  128:  		/* lwzx R11, <#[R11 + R3]> */
		/* 8210DFC8h case  128:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8210DFC8h case  128:*/		return 0x8210DFCC;
		  /* 8210DFCCh */ case  129:  		/* cmpwi CR6, R11, -1 */
		/* 8210DFCCh case  129:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210DFCCh case  129:*/		return 0x8210DFD0;
		  /* 8210DFD0h */ case  130:  		/* bc 12, CR6_EQ, 28 */
		/* 8210DFD0h case  130:*/		if ( regs.CR[6].eq ) { return 0x8210DFEC;  }
		/* 8210DFD0h case  130:*/		return 0x8210DFD4;
		  /* 8210DFD4h */ case  131:  		/* lwz R10, <#[R25 + 20]> */
		/* 8210DFD4h case  131:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000014) );
		/* 8210DFD4h case  131:*/		return 0x8210DFD8;
		  /* 8210DFD8h */ case  132:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8210DFD8h case  132:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8210DFD8h case  132:*/		return 0x8210DFDC;
		  /* 8210DFDCh */ case  133:  		/* lwzx R10, <#[R9 + R10]> */
		/* 8210DFDCh case  133:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210DFDCh case  133:*/		return 0x8210DFE0;
		  /* 8210DFE0h */ case  134:  		/* lwz R10, <#[R10 + 56]> */
		/* 8210DFE0h case  134:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000038) );
		/* 8210DFE0h case  134:*/		return 0x8210DFE4;
		  /* 8210DFE4h */ case  135:  		/* cmpwi CR6, R10, -1 */
		/* 8210DFE4h case  135:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210DFE4h case  135:*/		return 0x8210DFE8;
		  /* 8210DFE8h */ case  136:  		/* bc 4, CR6_EQ, 8 */
		/* 8210DFE8h case  136:*/		if ( !regs.CR[6].eq ) { return 0x8210DFF0;  }
		/* 8210DFE8h case  136:*/		return 0x8210DFEC;
	}
	return 0x8210DFEC;
} // Block from 8210DDC8h-8210DFECh (137 instructions)

//////////////////////////////////////////////////////
// Block at 8210DFECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210DFEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210DFEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210DFEC);
		  /* 8210DFECh */ case    0:  		/* mr R10, R11 */
		/* 8210DFECh case    0:*/		regs.R10 = regs.R11;
		/* 8210DFECh case    0:*/		return 0x8210DFF0;
	}
	return 0x8210DFF0;
} // Block from 8210DFECh-8210DFF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210DFF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210DFF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210DFF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210DFF0);
		  /* 8210DFF0h */ case    0:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210DFF0h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210DFF0h case    0:*/		return 0x8210DFF4;
		  /* 8210DFF4h */ case    1:  		/* lwz R6, <#[R25 + 20]> */
		/* 8210DFF4h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R25 + 0x00000014) );
		/* 8210DFF4h case    1:*/		return 0x8210DFF8;
		  /* 8210DFF8h */ case    2:  		/* lwz R9, <#[R25 + 16]> */
		/* 8210DFF8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000010) );
		/* 8210DFF8h case    2:*/		return 0x8210DFFC;
		  /* 8210DFFCh */ case    3:  		/* lwzx R10, <#[R10 + R6]> */
		/* 8210DFFCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 8210DFFCh case    3:*/		return 0x8210E000;
		  /* 8210E000h */ case    4:  		/* lwz R10, <#[R10 + 4]> */
		/* 8210E000h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8210E000h case    4:*/		return 0x8210E004;
		  /* 8210E004h */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210E004h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210E004h case    5:*/		return 0x8210E008;
		  /* 8210E008h */ case    6:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210E008h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210E008h case    6:*/		return 0x8210E00C;
		  /* 8210E00Ch */ case    7:  		/* lwz R10, <#[R10 + 4]> */
		/* 8210E00Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8210E00Ch case    7:*/		return 0x8210E010;
		  /* 8210E010h */ case    8:  		/* rlwinm. R10, R10, 0, 14, 14 */
		/* 8210E010h case    8:*/		cpu::op::rlwinm<1,0,14,14>(regs,&regs.R10,regs.R10);
		/* 8210E010h case    8:*/		return 0x8210E014;
		  /* 8210E014h */ case    9:  		/* bc 12, CR0_EQ, 64 */
		/* 8210E014h case    9:*/		if ( regs.CR[0].eq ) { return 0x8210E054;  }
		/* 8210E014h case    9:*/		return 0x8210E018;
		  /* 8210E018h */ case   10:  		/* cmpwi CR6, R11, -1 */
		/* 8210E018h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210E018h case   10:*/		return 0x8210E01C;
		  /* 8210E01Ch */ case   11:  		/* bc 12, CR6_EQ, 28 */
		/* 8210E01Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x8210E038;  }
		/* 8210E01Ch case   11:*/		return 0x8210E020;
		  /* 8210E020h */ case   12:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 8210E020h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 8210E020h case   12:*/		return 0x8210E024;
		  /* 8210E024h */ case   13:  		/* lwzx R10, <#[R10 + R6]> */
		/* 8210E024h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 8210E024h case   13:*/		return 0x8210E028;
		  /* 8210E028h */ case   14:  		/* lwz R10, <#[R10 + 56]> */
		/* 8210E028h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000038) );
		/* 8210E028h case   14:*/		return 0x8210E02C;
		  /* 8210E02Ch */ case   15:  		/* cmpwi CR6, R10, -1 */
		/* 8210E02Ch case   15:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210E02Ch case   15:*/		return 0x8210E030;
		  /* 8210E030h */ case   16:  		/* bc 12, CR6_EQ, 8 */
		/* 8210E030h case   16:*/		if ( regs.CR[6].eq ) { return 0x8210E038;  }
		/* 8210E030h case   16:*/		return 0x8210E034;
		  /* 8210E034h */ case   17:  		/* mr R11, R10 */
		/* 8210E034h case   17:*/		regs.R11 = regs.R10;
		/* 8210E034h case   17:*/		return 0x8210E038;
	}
	return 0x8210E038;
} // Block from 8210DFF0h-8210E038h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8210E038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E038);
		  /* 8210E038h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210E038h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210E038h case    0:*/		return 0x8210E03C;
		  /* 8210E03Ch */ case    1:  		/* lwz R10, <#[R25 + 24]> */
		/* 8210E03Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000018) );
		/* 8210E03Ch case    1:*/		return 0x8210E040;
		  /* 8210E040h */ case    2:  		/* lwzx R11, <#[R11 + R6]> */
		/* 8210E040h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 8210E040h case    2:*/		return 0x8210E044;
		  /* 8210E044h */ case    3:  		/* lwz R11, <#[R11 + 72]> */
		/* 8210E044h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 8210E044h case    3:*/		return 0x8210E048;
		  /* 8210E048h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210E048h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210E048h case    4:*/		return 0x8210E04C;
		  /* 8210E04Ch */ case    5:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210E04Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210E04Ch case    5:*/		return 0x8210E050;
		  /* 8210E050h */ case    6:  		/* lwz R5, <#[R11 + 8]> */
		/* 8210E050h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000008) );
		/* 8210E050h case    6:*/		return 0x8210E054;
	}
	return 0x8210E054;
} // Block from 8210E038h-8210E054h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210E054h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E054( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E054) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E054);
		  /* 8210E054h */ case    0:  		/* lwz R11, <#[R5]> */
		/* 8210E054h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8210E054h case    0:*/		return 0x8210E058;
		  /* 8210E058h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 8210E058h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210E058h case    1:*/		return 0x8210E05C;
		  /* 8210E05Ch */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 8210E05Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8210E078;  }
		/* 8210E05Ch case    2:*/		return 0x8210E060;
		  /* 8210E060h */ case    3:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 8210E060h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 8210E060h case    3:*/		return 0x8210E064;
		  /* 8210E064h */ case    4:  		/* lwzx R10, <#[R10 + R6]> */
		/* 8210E064h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 8210E064h case    4:*/		return 0x8210E068;
		  /* 8210E068h */ case    5:  		/* lwz R10, <#[R10 + 56]> */
		/* 8210E068h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000038) );
		/* 8210E068h case    5:*/		return 0x8210E06C;
		  /* 8210E06Ch */ case    6:  		/* cmpwi CR6, R10, -1 */
		/* 8210E06Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210E06Ch case    6:*/		return 0x8210E070;
		  /* 8210E070h */ case    7:  		/* bc 12, CR6_EQ, 8 */
		/* 8210E070h case    7:*/		if ( regs.CR[6].eq ) { return 0x8210E078;  }
		/* 8210E070h case    7:*/		return 0x8210E074;
		  /* 8210E074h */ case    8:  		/* mr R11, R10 */
		/* 8210E074h case    8:*/		regs.R11 = regs.R10;
		/* 8210E074h case    8:*/		return 0x8210E078;
	}
	return 0x8210E078;
} // Block from 8210E054h-8210E078h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8210E078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E078);
		  /* 8210E078h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210E078h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210E078h case    0:*/		return 0x8210E07C;
		  /* 8210E07Ch */ case    1:  		/* lwzx R11, <#[R11 + R6]> */
		/* 8210E07Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 8210E07Ch case    1:*/		return 0x8210E080;
		  /* 8210E080h */ case    2:  		/* lwz R11, <#[R11 + 4]> */
		/* 8210E080h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8210E080h case    2:*/		return 0x8210E084;
		  /* 8210E084h */ case    3:  		/* cmplw CR6, R22, R11 */
		/* 8210E084h case    3:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 8210E084h case    3:*/		return 0x8210E088;
		  /* 8210E088h */ case    4:  		/* bc 4, CR6_EQ, 372 */
		/* 8210E088h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8210E1FC;  }
		/* 8210E088h case    4:*/		return 0x8210E08C;
		  /* 8210E08Ch */ case    5:  		/* li R9, 0 */
		/* 8210E08Ch case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8210E08Ch case    5:*/		return 0x8210E090;
		  /* 8210E090h */ case    6:  		/* li R8, 0 */
		/* 8210E090h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8210E090h case    6:*/		return 0x8210E094;
		  /* 8210E094h */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 8210E094h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8210E094h case    7:*/		return 0x8210E098;
		  /* 8210E098h */ case    8:  		/* bc 12, CR6_EQ, 356 */
		/* 8210E098h case    8:*/		if ( regs.CR[6].eq ) { return 0x8210E1FC;  }
		/* 8210E098h case    8:*/		return 0x8210E09C;
		  /* 8210E09Ch */ case    9:  		/* mr R7, R5 */
		/* 8210E09Ch case    9:*/		regs.R7 = regs.R5;
		/* 8210E09Ch case    9:*/		return 0x8210E0A0;
		  /* 8210E0A0h */ case   10:  		/* lwz R11, <#[R7]> */
		/* 8210E0A0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 8210E0A0h case   10:*/		return 0x8210E0A4;
		  /* 8210E0A4h */ case   11:  		/* cmpwi CR6, R11, -1 */
		/* 8210E0A4h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210E0A4h case   11:*/		return 0x8210E0A8;
		  /* 8210E0A8h */ case   12:  		/* bc 12, CR6_EQ, 28 */
		/* 8210E0A8h case   12:*/		if ( regs.CR[6].eq ) { return 0x8210E0C4;  }
		/* 8210E0A8h case   12:*/		return 0x8210E0AC;
		  /* 8210E0ACh */ case   13:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 8210E0ACh case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 8210E0ACh case   13:*/		return 0x8210E0B0;
		  /* 8210E0B0h */ case   14:  		/* lwzx R10, <#[R10 + R6]> */
		/* 8210E0B0h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 8210E0B0h case   14:*/		return 0x8210E0B4;
		  /* 8210E0B4h */ case   15:  		/* lwz R10, <#[R10 + 56]> */
		/* 8210E0B4h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000038) );
		/* 8210E0B4h case   15:*/		return 0x8210E0B8;
		  /* 8210E0B8h */ case   16:  		/* cmpwi CR6, R10, -1 */
		/* 8210E0B8h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210E0B8h case   16:*/		return 0x8210E0BC;
		  /* 8210E0BCh */ case   17:  		/* bc 12, CR6_EQ, 8 */
		/* 8210E0BCh case   17:*/		if ( regs.CR[6].eq ) { return 0x8210E0C4;  }
		/* 8210E0BCh case   17:*/		return 0x8210E0C0;
		  /* 8210E0C0h */ case   18:  		/* mr R11, R10 */
		/* 8210E0C0h case   18:*/		regs.R11 = regs.R10;
		/* 8210E0C0h case   18:*/		return 0x8210E0C4;
	}
	return 0x8210E0C4;
} // Block from 8210E078h-8210E0C4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8210E0C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E0C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E0C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E0C4);
		  /* 8210E0C4h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210E0C4h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210E0C4h case    0:*/		return 0x8210E0C8;
		  /* 8210E0C8h */ case    1:  		/* li R10, 1 */
		/* 8210E0C8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8210E0C8h case    1:*/		return 0x8210E0CC;
		  /* 8210E0CCh */ case    2:  		/* lwzx R11, <#[R11 + R6]> */
		/* 8210E0CCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 8210E0CCh case    2:*/		return 0x8210E0D0;
		  /* 8210E0D0h */ case    3:  		/* lwz R11, <#[R11 + 16]> */
		/* 8210E0D0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 8210E0D0h case    3:*/		return 0x8210E0D4;
		  /* 8210E0D4h */ case    4:  		/* slw R11, R10, R11 */
		/* 8210E0D4h case    4:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8210E0D4h case    4:*/		return 0x8210E0D8;
		  /* 8210E0D8h */ case    5:  		/* and. R10, R11, R9 */
		/* 8210E0D8h case    5:*/		cpu::op::and<1>(regs,&regs.R10,regs.R11,regs.R9);
		/* 8210E0D8h case    5:*/		return 0x8210E0DC;
		  /* 8210E0DCh */ case    6:  		/* bc 4, CR0_EQ, 24 */
		/* 8210E0DCh case    6:*/		if ( !regs.CR[0].eq ) { return 0x8210E0F4;  }
		/* 8210E0DCh case    6:*/		return 0x8210E0E0;
	}
	return 0x8210E0E0;
} // Block from 8210E0C4h-8210E0E0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210E0E0h
// Function '?ReorderInstructions@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E0E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E0E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E0E0);
		  /* 8210E0E0h */ case    0:  		/* addi R8, R8, 1 */
		/* 8210E0E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8210E0E0h case    0:*/		return 0x8210E0E4;
		  /* 8210E0E4h */ case    1:  		/* or R9, R11, R9 */
		/* 8210E0E4h case    1:*/		cpu::op::or<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 8210E0E4h case    1:*/		return 0x8210E0E8;
		  /* 8210E0E8h */ case    2:  		/* addi R7, R7, 4 */
		/* 8210E0E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 8210E0E8h case    2:*/		return 0x8210E0EC;
		  /* 8210E0ECh */ case    3:  		/* cmplw CR6, R8, R4 */
		/* 8210E0ECh case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R4);
		/* 8210E0ECh case    3:*/		return 0x8210E0F0;
		  /* 8210E0F0h */ case    4:  		/* bc 12, CR6_LT, -80 */
		/* 8210E0F0h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210E0A0;  }
		/* 8210E0F0h case    4:*/		return 0x8210E0F4;
	}
	return 0x8210E0F4;
} // Block from 8210E0E0h-8210E0F4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210E0F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E0F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E0F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E0F4);
		  /* 8210E0F4h */ case    0:  		/* cmplw CR6, R8, R4 */
		/* 8210E0F4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R4);
		/* 8210E0F4h case    0:*/		return 0x8210E0F8;
		  /* 8210E0F8h */ case    1:  		/* bc 12, CR6_LT, 260 */
		/* 8210E0F8h case    1:*/		if ( regs.CR[6].lt ) { return 0x8210E1FC;  }
		/* 8210E0F8h case    1:*/		return 0x8210E0FC;
		  /* 8210E0FCh */ case    2:  		/* li R7, 0 */
		/* 8210E0FCh case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8210E0FCh case    2:*/		return 0x8210E100;
		  /* 8210E100h */ case    3:  		/* mtspr CTR, R4 */
		/* 8210E100h case    3:*/		regs.CTR = regs.R4;
		/* 8210E100h case    3:*/		return 0x8210E104;
		  /* 8210E104h */ case    4:  		/* lwz R9, <#[R30 + 16]> */
		/* 8210E104h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000010) );
		/* 8210E104h case    4:*/		return 0x8210E108;
		  /* 8210E108h */ case    5:  		/* lwz R10, <#[R25 + 20]> */
		/* 8210E108h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000014) );
		/* 8210E108h case    5:*/		return 0x8210E10C;
		  /* 8210E10Ch */ case    6:  		/* lwzx R11, <#[R7 + R5]> */
		/* 8210E10Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R5 + 0x00000000) );
		/* 8210E10Ch case    6:*/		return 0x8210E110;
		  /* 8210E110h */ case    7:  		/* cmpwi CR6, R11, -1 */
		/* 8210E110h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210E110h case    7:*/		return 0x8210E114;
		  /* 8210E114h */ case    8:  		/* lwzx R9, <#[R9 + R7]> */
		/* 8210E114h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 8210E114h case    8:*/		return 0x8210E118;
		  /* 8210E118h */ case    9:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210E118h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210E118h case    9:*/		return 0x8210E11C;
		  /* 8210E11Ch */ case   10:  		/* lwzx R9, <#[R9 + R10]> */
		/* 8210E11Ch case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210E11Ch case   10:*/		return 0x8210E120;
		  /* 8210E120h */ case   11:  		/* bc 12, CR6_EQ, 28 */
		/* 8210E120h case   11:*/		if ( regs.CR[6].eq ) { return 0x8210E13C;  }
		/* 8210E120h case   11:*/		return 0x8210E124;
		  /* 8210E124h */ case   12:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 8210E124h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 8210E124h case   12:*/		return 0x8210E128;
		  /* 8210E128h */ case   13:  		/* lwzx R8, <#[R8 + R10]> */
		/* 8210E128h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 8210E128h case   13:*/		return 0x8210E12C;
		  /* 8210E12Ch */ case   14:  		/* lwz R8, <#[R8 + 56]> */
		/* 8210E12Ch case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000038) );
		/* 8210E12Ch case   14:*/		return 0x8210E130;
		  /* 8210E130h */ case   15:  		/* cmpwi CR6, R8, -1 */
		/* 8210E130h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 8210E130h case   15:*/		return 0x8210E134;
		  /* 8210E134h */ case   16:  		/* bc 12, CR6_EQ, 8 */
		/* 8210E134h case   16:*/		if ( regs.CR[6].eq ) { return 0x8210E13C;  }
		/* 8210E134h case   16:*/		return 0x8210E138;
		  /* 8210E138h */ case   17:  		/* mr R11, R8 */
		/* 8210E138h case   17:*/		regs.R11 = regs.R8;
		/* 8210E138h case   17:*/		return 0x8210E13C;
	}
	return 0x8210E13C;
} // Block from 8210E0F4h-8210E13Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 8210E13Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E13C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E13C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E13C);
		  /* 8210E13Ch */ case    0:  		/* rlwinm R6, R11, 2, 0, 29 */
		/* 8210E13Ch case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R11);
		/* 8210E13Ch case    0:*/		return 0x8210E140;
		  /* 8210E140h */ case    1:  		/* lwz R8, <#[R9 + 12]> */
		/* 8210E140h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x0000000C) );
		/* 8210E140h case    1:*/		return 0x8210E144;
		  /* 8210E144h */ case    2:  		/* lwz R11, <#[R9 + 16]> */
		/* 8210E144h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000010) );
		/* 8210E144h case    2:*/		return 0x8210E148;
		  /* 8210E148h */ case    3:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8210E148h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8210E148h case    3:*/		return 0x8210E14C;
		  /* 8210E14Ch */ case    4:  		/* add R11, R8, R11 */
		/* 8210E14Ch case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 8210E14Ch case    4:*/		return 0x8210E150;
		  /* 8210E150h */ case    5:  		/* lwzx R10, <#[R6 + R10]> */
		/* 8210E150h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + regs.R10 + 0x00000000) );
		/* 8210E150h case    5:*/		return 0x8210E154;
		  /* 8210E154h */ case    6:  		/* lwz R8, <#[R10 + 12]> */
		/* 8210E154h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x0000000C) );
		/* 8210E154h case    6:*/		return 0x8210E158;
		  /* 8210E158h */ case    7:  		/* lwz R10, <#[R10 + 16]> */
		/* 8210E158h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 8210E158h case    7:*/		return 0x8210E15C;
		  /* 8210E15Ch */ case    8:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8210E15Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8210E15Ch case    8:*/		return 0x8210E160;
		  /* 8210E160h */ case    9:  		/* add R10, R8, R10 */
		/* 8210E160h case    9:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8210E160h case    9:*/		return 0x8210E164;
		  /* 8210E164h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 8210E164h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210E164h case   10:*/		return 0x8210E168;
		  /* 8210E168h */ case   11:  		/* bc 12, CR6_EQ, 140 */
		/* 8210E168h case   11:*/		if ( regs.CR[6].eq ) { return 0x8210E1F4;  }
		/* 8210E168h case   11:*/		return 0x8210E16C;
		  /* 8210E16Ch */ case   12:  		/* lwz R9, <#[R9 + 60]> */
		/* 8210E16Ch case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000003C) );
		/* 8210E16Ch case   12:*/		return 0x8210E170;
		  /* 8210E170h */ case   13:  		/* cmplwi CR6, R9, 0 */
		/* 8210E170h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8210E170h case   13:*/		return 0x8210E174;
		  /* 8210E174h */ case   14:  		/* bc 4, CR6_EQ, 128 */
		/* 8210E174h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8210E1F4;  }
		/* 8210E174h case   14:*/		return 0x8210E178;
		  /* 8210E178h */ case   15:  		/* cmplwi CR6, R23, 1 */
		/* 8210E178h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000001);
		/* 8210E178h case   15:*/		return 0x8210E17C;
		  /* 8210E17Ch */ case   16:  		/* bc 4, CR6_EQ, 76 */
		/* 8210E17Ch case   16:*/		if ( !regs.CR[6].eq ) { return 0x8210E1C8;  }
		/* 8210E17Ch case   16:*/		return 0x8210E180;
		  /* 8210E180h */ case   17:  		/* lwz R9, <#[R31 + 48]> */
		/* 8210E180h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000030) );
		/* 8210E180h case   17:*/		return 0x8210E184;
		  /* 8210E184h */ case   18:  		/* rlwinm R6, R11, 2, 0, 29 */
		/* 8210E184h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R11);
		/* 8210E184h case   18:*/		return 0x8210E188;
		  /* 8210E188h */ case   19:  		/* lwz R21, <#[R31 + 52]> */
		/* 8210E188h case   19:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R31 + 0x00000034) );
		/* 8210E188h case   19:*/		return 0x8210E18C;
		  /* 8210E18Ch */ case   20:  		/* rlwinm R20, R10, 2, 0, 29 */
		/* 8210E18Ch case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R20,regs.R10);
		/* 8210E18Ch case   20:*/		return 0x8210E190;
		  /* 8210E190h */ case   21:  		/* lwz R19, <#[R31 + 56]> */
		/* 8210E190h case   21:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R31 + 0x00000038) );
		/* 8210E190h case   21:*/		return 0x8210E194;
		  /* 8210E194h */ case   22:  		/* lwzx R8, <#[R6 + R9]> */
		/* 8210E194h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + regs.R9 + 0x00000000) );
		/* 8210E194h case   22:*/		return 0x8210E198;
		  /* 8210E198h */ case   23:  		/* lwzx R9, <#[R6 + R21]> */
		/* 8210E198h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + regs.R21 + 0x00000000) );
		/* 8210E198h case   23:*/		return 0x8210E19C;
		  /* 8210E19Ch */ case   24:  		/* add R9, R8, R9 */
		/* 8210E19Ch case   24:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8210E19Ch case   24:*/		return 0x8210E1A0;
		  /* 8210E1A0h */ case   25:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210E1A0h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210E1A0h case   25:*/		return 0x8210E1A4;
		  /* 8210E1A4h */ case   26:  		/* stwx R10, <#[R9 + R19]> */
		/* 8210E1A4h case   26:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + regs.R19 + 0x00000000) );
		/* 8210E1A4h case   26:*/		return 0x8210E1A8;
		  /* 8210E1A8h */ case   27:  		/* lwz R9, <#[R31 + 52]> */
		/* 8210E1A8h case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000034) );
		/* 8210E1A8h case   27:*/		return 0x8210E1AC;
		  /* 8210E1ACh */ case   28:  		/* lwz R8, <#[R31 + 48]> */
		/* 8210E1ACh case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000030) );
		/* 8210E1ACh case   28:*/		return 0x8210E1B0;
		  /* 8210E1B0h */ case   29:  		/* lwz R6, <#[R31 + 56]> */
		/* 8210E1B0h case   29:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000038) );
		/* 8210E1B0h case   29:*/		return 0x8210E1B4;
		  /* 8210E1B4h */ case   30:  		/* lwzx R9, <#[R20 + R9]> */
		/* 8210E1B4h case   30:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R20 + regs.R9 + 0x00000000) );
		/* 8210E1B4h case   30:*/		return 0x8210E1B8;
		  /* 8210E1B8h */ case   31:  		/* lwzx R8, <#[R20 + R8]> */
		/* 8210E1B8h case   31:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R20 + regs.R8 + 0x00000000) );
		/* 8210E1B8h case   31:*/		return 0x8210E1BC;
		  /* 8210E1BCh */ case   32:  		/* add R9, R8, R9 */
		/* 8210E1BCh case   32:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8210E1BCh case   32:*/		return 0x8210E1C0;
		  /* 8210E1C0h */ case   33:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210E1C0h case   33:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210E1C0h case   33:*/		return 0x8210E1C4;
		  /* 8210E1C4h */ case   34:  		/* stwx R11, <#[R9 + R6]> */
		/* 8210E1C4h case   34:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 8210E1C4h case   34:*/		return 0x8210E1C8;
	}
	return 0x8210E1C8;
} // Block from 8210E13Ch-8210E1C8h (35 instructions)

//////////////////////////////////////////////////////
// Block at 8210E1C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E1C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E1C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E1C8);
		  /* 8210E1C8h */ case    0:  		/* lwz R9, <#[R31 + 48]> */
		/* 8210E1C8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000030) );
		/* 8210E1C8h case    0:*/		return 0x8210E1CC;
		  /* 8210E1CCh */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210E1CCh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210E1CCh case    1:*/		return 0x8210E1D0;
		  /* 8210E1D0h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210E1D0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210E1D0h case    2:*/		return 0x8210E1D4;
		  /* 8210E1D4h */ case    3:  		/* addi R27, R27, 2 */
		/* 8210E1D4h case    3:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x2);
		/* 8210E1D4h case    3:*/		return 0x8210E1D8;
		  /* 8210E1D8h */ case    4:  		/* lwzx R8, <#[R11 + R9]> */
		/* 8210E1D8h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210E1D8h case    4:*/		return 0x8210E1DC;
		  /* 8210E1DCh */ case    5:  		/* addi R8, R8, 1 */
		/* 8210E1DCh case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8210E1DCh case    5:*/		return 0x8210E1E0;
		  /* 8210E1E0h */ case    6:  		/* stwx R8, <#[R11 + R9]> */
		/* 8210E1E0h case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210E1E0h case    6:*/		return 0x8210E1E4;
		  /* 8210E1E4h */ case    7:  		/* lwz R11, <#[R31 + 48]> */
		/* 8210E1E4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8210E1E4h case    7:*/		return 0x8210E1E8;
		  /* 8210E1E8h */ case    8:  		/* lwzx R9, <#[R10 + R11]> */
		/* 8210E1E8h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210E1E8h case    8:*/		return 0x8210E1EC;
		  /* 8210E1ECh */ case    9:  		/* addi R9, R9, 1 */
		/* 8210E1ECh case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8210E1ECh case    9:*/		return 0x8210E1F0;
		  /* 8210E1F0h */ case   10:  		/* stwx R9, <#[R10 + R11]> */
		/* 8210E1F0h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210E1F0h case   10:*/		return 0x8210E1F4;
	}
	return 0x8210E1F4;
} // Block from 8210E1C8h-8210E1F4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8210E1F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E1F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E1F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E1F4);
		  /* 8210E1F4h */ case    0:  		/* addi R7, R7, 4 */
		/* 8210E1F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 8210E1F4h case    0:*/		return 0x8210E1F8;
		  /* 8210E1F8h */ case    1:  		/* bc 16, CR0_LT, -244 */
		/* 8210E1F8h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210E104;  }
		/* 8210E1F8h case    1:*/		return 0x8210E1FC;
	}
	return 0x8210E1FC;
} // Block from 8210E1F4h-8210E1FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210E1FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E1FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E1FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E1FC);
		  /* 8210E1FCh */ case    0:  		/* addic. R29, R29, -1 */
		/* 8210E1FCh case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 8210E1FCh case    0:*/		return 0x8210E200;
		  /* 8210E200h */ case    1:  		/* add R3, R28, R3 */
		/* 8210E200h case    1:*/		cpu::op::add<0>(regs,&regs.R3,regs.R28,regs.R3);
		/* 8210E200h case    1:*/		return 0x8210E204;
		  /* 8210E204h */ case    2:  		/* bc 4, CR0_EQ, -580 */
		/* 8210E204h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8210DFC0;  }
		/* 8210E204h case    2:*/		return 0x8210E208;
	}
	return 0x8210E208;
} // Block from 8210E1FCh-8210E208h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210E208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E208);
		  /* 8210E208h */ case    0:  		/* lwz R11, <#[R25 + 12]> */
		/* 8210E208h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000000C) );
		/* 8210E208h case    0:*/		return 0x8210E20C;
		  /* 8210E20Ch */ case    1:  		/* addi R24, R24, 1 */
		/* 8210E20Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 8210E20Ch case    1:*/		return 0x8210E210;
		  /* 8210E210h */ case    2:  		/* addi R26, R26, 4 */
		/* 8210E210h case    2:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 8210E210h case    2:*/		return 0x8210E214;
		  /* 8210E214h */ case    3:  		/* cmplw CR6, R24, R11 */
		/* 8210E214h case    3:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R11);
		/* 8210E214h case    3:*/		return 0x8210E218;
		  /* 8210E218h */ case    4:  		/* bc 12, CR6_LT, -692 */
		/* 8210E218h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210DF64;  }
		/* 8210E218h case    4:*/		return 0x8210E21C;
	}
	return 0x8210E21C;
} // Block from 8210E208h-8210E21Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210E21Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E21C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E21C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E21C);
		  /* 8210E21Ch */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 8210E21Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 8210E21Ch case    0:*/		return 0x8210E220;
		  /* 8210E220h */ case    1:  		/* bc 4, CR6_EQ, 96 */
		/* 8210E220h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210E280;  }
		/* 8210E220h case    1:*/		return 0x8210E224;
		  /* 8210E224h */ case    2:  		/* lwz R11, <#[R31 + 40]> */
		/* 8210E224h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8210E224h case    2:*/		return 0x8210E228;
		  /* 8210E228h */ case    3:  		/* li R9, 0 */
		/* 8210E228h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8210E228h case    3:*/		return 0x8210E22C;
		  /* 8210E22Ch */ case    4:  		/* li R10, 0 */
		/* 8210E22Ch case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210E22Ch case    4:*/		return 0x8210E230;
		  /* 8210E230h */ case    5:  		/* rlwinm. R11, R11, 2, 0, 29 */
		/* 8210E230h case    5:*/		cpu::op::rlwinm<1,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210E230h case    5:*/		return 0x8210E234;
		  /* 8210E234h */ case    6:  		/* bc 12, CR0_EQ, 52 */
		/* 8210E234h case    6:*/		if ( regs.CR[0].eq ) { return 0x8210E268;  }
		/* 8210E234h case    6:*/		return 0x8210E238;
		  /* 8210E238h */ case    7:  		/* li R11, 0 */
		/* 8210E238h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210E238h case    7:*/		return 0x8210E23C;
		  /* 8210E23Ch */ case    8:  		/* lwz R8, <#[R31 + 52]> */
		/* 8210E23Ch case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000034) );
		/* 8210E23Ch case    8:*/		return 0x8210E240;
		  /* 8210E240h */ case    9:  		/* addi R10, R10, 1 */
		/* 8210E240h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210E240h case    9:*/		return 0x8210E244;
		  /* 8210E244h */ case   10:  		/* stwx R9, <#[R8 + R11]> */
		/* 8210E244h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8210E244h case   10:*/		return 0x8210E248;
		  /* 8210E248h */ case   11:  		/* lwz R7, <#[R31 + 48]> */
		/* 8210E248h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000030) );
		/* 8210E248h case   11:*/		return 0x8210E24C;
		  /* 8210E24Ch */ case   12:  		/* lwz R8, <#[R31 + 40]> */
		/* 8210E24Ch case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000028) );
		/* 8210E24Ch case   12:*/		return 0x8210E250;
		  /* 8210E250h */ case   13:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8210E250h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8210E250h case   13:*/		return 0x8210E254;
		  /* 8210E254h */ case   14:  		/* cmplw CR6, R10, R8 */
		/* 8210E254h case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8210E254h case   14:*/		return 0x8210E258;
		  /* 8210E258h */ case   15:  		/* lwzx R8, <#[R7 + R11]> */
		/* 8210E258h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 8210E258h case   15:*/		return 0x8210E25C;
		  /* 8210E25Ch */ case   16:  		/* addi R11, R11, 4 */
		/* 8210E25Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210E25Ch case   16:*/		return 0x8210E260;
		  /* 8210E260h */ case   17:  		/* add R9, R8, R9 */
		/* 8210E260h case   17:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8210E260h case   17:*/		return 0x8210E264;
		  /* 8210E264h */ case   18:  		/* bc 12, CR6_LT, -40 */
		/* 8210E264h case   18:*/		if ( regs.CR[6].lt ) { return 0x8210E23C;  }
		/* 8210E264h case   18:*/		return 0x8210E268;
	}
	return 0x8210E268;
} // Block from 8210E21Ch-8210E268h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8210E268h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E268);
		  /* 8210E268h */ case    0:  		/* lis R4, 9345 */
		/* 8210E268h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210E268h case    0:*/		return 0x8210E26C;
		  /* 8210E26Ch */ case    1:  		/* rlwinm R3, R27, 2, 0, 29 */
		/* 8210E26Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R27);
		/* 8210E26Ch case    1:*/		return 0x8210E270;
		  /* 8210E270h */ case    2:  		/* bl -548976 */
		/* 8210E270h case    2:*/		regs.LR = 0x8210E274; return 0x82088200;
		/* 8210E270h case    2:*/		return 0x8210E274;
		  /* 8210E274h */ case    3:  		/* stw R3, <#[R31 + 56]> */
		/* 8210E274h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000038) );
		/* 8210E274h case    3:*/		return 0x8210E278;
		  /* 8210E278h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 8210E278h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210E278h case    4:*/		return 0x8210E27C;
		  /* 8210E27Ch */ case    5:  		/* bc 12, CR0_EQ, 956 */
		/* 8210E27Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x8210E638;  }
		/* 8210E27Ch case    5:*/		return 0x8210E280;
	}
	return 0x8210E280;
} // Block from 8210E268h-8210E280h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210E280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E280);
		  /* 8210E280h */ case    0:  		/* addi R23, R23, 1 */
		/* 8210E280h case    0:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 8210E280h case    0:*/		return 0x8210E284;
		  /* 8210E284h */ case    1:  		/* cmplwi CR6, R23, 2 */
		/* 8210E284h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000002);
		/* 8210E284h case    1:*/		return 0x8210E288;
		  /* 8210E288h */ case    2:  		/* bc 12, CR6_LT, -848 */
		/* 8210E288h case    2:*/		if ( regs.CR[6].lt ) { return 0x8210DF38;  }
		/* 8210E288h case    2:*/		return 0x8210E28C;
		  /* 8210E28Ch */ case    3:  		/* li R26, 0 */
		/* 8210E28Ch case    3:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8210E28Ch case    3:*/		return 0x8210E290;
		  /* 8210E290h */ case    4:  		/* lwz R11, <#[R31 + 40]> */
		/* 8210E290h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8210E290h case    4:*/		return 0x8210E294;
		  /* 8210E294h */ case    5:  		/* li R4, 0 */
		/* 8210E294h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8210E294h case    5:*/		return 0x8210E298;
		  /* 8210E298h */ case    6:  		/* lwz R3, <#[R31 + 60]> */
		/* 8210E298h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000003C) );
		/* 8210E298h case    6:*/		return 0x8210E29C;
		  /* 8210E29Ch */ case    7:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 8210E29Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 8210E29Ch case    7:*/		return 0x8210E2A0;
		  /* 8210E2A0h */ case    8:  		/* bl -511840 */
		/* 8210E2A0h case    8:*/		regs.LR = 0x8210E2A4; return 0x82091340;
		/* 8210E2A0h case    8:*/		return 0x8210E2A4;
		  /* 8210E2A4h */ case    9:  		/* lwz R11, <#[R25 + 12]> */
		/* 8210E2A4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000000C) );
		/* 8210E2A4h case    9:*/		return 0x8210E2A8;
		  /* 8210E2A8h */ case   10:  		/* li R29, 0 */
		/* 8210E2A8h case   10:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8210E2A8h case   10:*/		return 0x8210E2AC;
		  /* 8210E2ACh */ case   11:  		/* li R27, 0 */
		/* 8210E2ACh case   11:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8210E2ACh case   11:*/		return 0x8210E2B0;
		  /* 8210E2B0h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 8210E2B0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210E2B0h case   12:*/		return 0x8210E2B4;
		  /* 8210E2B4h */ case   13:  		/* bc 4, CR6_GT, 360 */
		/* 8210E2B4h case   13:*/		if ( !regs.CR[6].gt ) { return 0x8210E41C;  }
		/* 8210E2B4h case   13:*/		return 0x8210E2B8;
		  /* 8210E2B8h */ case   14:  		/* li R28, 0 */
		/* 8210E2B8h case   14:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8210E2B8h case   14:*/		return 0x8210E2BC;
		  /* 8210E2BCh */ case   15:  		/* lwz R11, <#[R25 + 24]> */
		/* 8210E2BCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000018) );
		/* 8210E2BCh case   15:*/		return 0x8210E2C0;
		  /* 8210E2C0h */ case   16:  		/* lwzx R30, <#[R28 + R11]> */
		/* 8210E2C0h case   16:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 8210E2C0h case   16:*/		return 0x8210E2C4;
		  /* 8210E2C4h */ case   17:  		/* mr R3, R30 */
		/* 8210E2C4h case   17:*/		regs.R3 = regs.R30;
		/* 8210E2C4h case   17:*/		return 0x8210E2C8;
		  /* 8210E2C8h */ case   18:  		/* bl -74264 */
		/* 8210E2C8h case   18:*/		regs.LR = 0x8210E2CC; return 0x820FC0B0;
		/* 8210E2C8h case   18:*/		return 0x8210E2CC;
		  /* 8210E2CCh */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 8210E2CCh case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210E2CCh case   19:*/		return 0x8210E2D0;
		  /* 8210E2D0h */ case   20:  		/* bc 4, CR0_EQ, 16 */
		/* 8210E2D0h case   20:*/		if ( !regs.CR[0].eq ) { return 0x8210E2E0;  }
		/* 8210E2D0h case   20:*/		return 0x8210E2D4;
		  /* 8210E2D4h */ case   21:  		/* lwz R11, <#[R25 + 112]> */
		/* 8210E2D4h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000070) );
		/* 8210E2D4h case   21:*/		return 0x8210E2D8;
		  /* 8210E2D8h */ case   22:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 8210E2D8h case   22:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 8210E2D8h case   22:*/		return 0x8210E2DC;
		  /* 8210E2DCh */ case   23:  		/* bc 12, CR0_EQ, 300 */
		/* 8210E2DCh case   23:*/		if ( regs.CR[0].eq ) { return 0x8210E408;  }
		/* 8210E2DCh case   23:*/		return 0x8210E2E0;
	}
	return 0x8210E2E0;
} // Block from 8210E280h-8210E2E0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8210E2E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E2E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E2E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E2E0);
		  /* 8210E2E0h */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 8210E2E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8210E2E0h case    0:*/		return 0x8210E2E4;
		  /* 8210E2E4h */ case    1:  		/* lwz R10, <#[R25 + 20]> */
		/* 8210E2E4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000014) );
		/* 8210E2E4h case    1:*/		return 0x8210E2E8;
		  /* 8210E2E8h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 8210E2E8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8210E2E8h case    2:*/		return 0x8210E2EC;
		  /* 8210E2ECh */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210E2ECh case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210E2ECh case    3:*/		return 0x8210E2F0;
		  /* 8210E2F0h */ case    4:  		/* lwzx R10, <#[R11 + R10]> */
		/* 8210E2F0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210E2F0h case    4:*/		return 0x8210E2F4;
		  /* 8210E2F4h */ case    5:  		/* lwz R11, <#[R10 + 4]> */
		/* 8210E2F4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8210E2F4h case    5:*/		return 0x8210E2F8;
		  /* 8210E2F8h */ case    6:  		/* cmplw CR6, R22, R11 */
		/* 8210E2F8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 8210E2F8h case    6:*/		return 0x8210E2FC;
		  /* 8210E2FCh */ case    7:  		/* bc 4, CR6_EQ, 268 */
		/* 8210E2FCh case    7:*/		if ( !regs.CR[6].eq ) { return 0x8210E408;  }
		/* 8210E2FCh case    7:*/		return 0x8210E300;
		  /* 8210E300h */ case    8:  		/* lwz R11, <#[R30]> */
		/* 8210E300h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8210E300h case    8:*/		return 0x8210E304;
		  /* 8210E304h */ case    9:  		/* lwz R9, <#[R30 + 4]> */
		/* 8210E304h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000004) );
		/* 8210E304h case    9:*/		return 0x8210E308;
		  /* 8210E308h */ case   10:  		/* rlwinm R11, R11, 0, 12, 31 */
		/* 8210E308h case   10:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R11);
		/* 8210E308h case   10:*/		return 0x8210E30C;
		  /* 8210E30Ch */ case   11:  		/* lwz R7, <#[R10 + 12]> */
		/* 8210E30Ch case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x0000000C) );
		/* 8210E30Ch case   11:*/		return 0x8210E310;
		  /* 8210E310h */ case   12:  		/* divwu. R10, R9, R11 */
		/* 8210E310h case   12:*/		cpu::op::divwu<1>(regs,&regs.R10,regs.R9,regs.R11);
		/* 8210E310h case   12:*/		return 0x8210E314;
		  /* 8210E314h */ case   13:  		/* twi 6, R11, 0 */
		/* 8210E314h case   13:*/		cpu::op::tw<6>(regs, 0x8210E314, regs.R11, 0x00000000);
		/* 8210E314h case   13:*/		return 0x8210E318;
		  /* 8210E318h */ case   14:  		/* bc 12, CR0_EQ, 240 */
		/* 8210E318h case   14:*/		if ( regs.CR[0].eq ) { return 0x8210E408;  }
		/* 8210E318h case   14:*/		return 0x8210E31C;
		  /* 8210E31Ch */ case   15:  		/* mtspr CTR, R10 */
		/* 8210E31Ch case   15:*/		regs.CTR = regs.R10;
		/* 8210E31Ch case   15:*/		return 0x8210E320;
		  /* 8210E320h */ case   16:  		/* li R6, 0 */
		/* 8210E320h case   16:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8210E320h case   16:*/		return 0x8210E324;
		  /* 8210E324h */ case   17:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 8210E324h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 8210E324h case   17:*/		return 0x8210E328;
		  /* 8210E328h */ case   18:  		/* lwz R11, <#[R30 + 8]> */
		/* 8210E328h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8210E328h case   18:*/		return 0x8210E32C;
		  /* 8210E32Ch */ case   19:  		/* lwzx R11, <#[R11 + R6]> */
		/* 8210E32Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 8210E32Ch case   19:*/		return 0x8210E330;
		  /* 8210E330h */ case   20:  		/* cmpwi CR6, R11, -1 */
		/* 8210E330h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210E330h case   20:*/		return 0x8210E334;
		  /* 8210E334h */ case   21:  		/* bc 12, CR6_EQ, 32 */
		/* 8210E334h case   21:*/		if ( regs.CR[6].eq ) { return 0x8210E354;  }
		/* 8210E334h case   21:*/		return 0x8210E338;
		  /* 8210E338h */ case   22:  		/* lwz R10, <#[R25 + 20]> */
		/* 8210E338h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000014) );
		/* 8210E338h case   22:*/		return 0x8210E33C;
		  /* 8210E33Ch */ case   23:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8210E33Ch case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8210E33Ch case   23:*/		return 0x8210E340;
		  /* 8210E340h */ case   24:  		/* lwzx R10, <#[R9 + R10]> */
		/* 8210E340h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210E340h case   24:*/		return 0x8210E344;
		  /* 8210E344h */ case   25:  		/* lwz R10, <#[R10 + 56]> */
		/* 8210E344h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000038) );
		/* 8210E344h case   25:*/		return 0x8210E348;
		  /* 8210E348h */ case   26:  		/* cmpwi CR6, R10, -1 */
		/* 8210E348h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210E348h case   26:*/		return 0x8210E34C;
		  /* 8210E34Ch */ case   27:  		/* bc 12, CR6_EQ, 8 */
		/* 8210E34Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x8210E354;  }
		/* 8210E34Ch case   27:*/		return 0x8210E350;
		  /* 8210E350h */ case   28:  		/* mr R11, R10 */
		/* 8210E350h case   28:*/		regs.R11 = regs.R10;
		/* 8210E350h case   28:*/		return 0x8210E354;
	}
	return 0x8210E354;
} // Block from 8210E2E0h-8210E354h (29 instructions)

//////////////////////////////////////////////////////
// Block at 8210E354h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E354( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E354) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E354);
		  /* 8210E354h */ case    0:  		/* lwz R10, <#[R25 + 20]> */
		/* 8210E354h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000014) );
		/* 8210E354h case    0:*/		return 0x8210E358;
		  /* 8210E358h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210E358h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210E358h case    1:*/		return 0x8210E35C;
		  /* 8210E35Ch */ case    2:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210E35Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210E35Ch case    2:*/		return 0x8210E360;
		  /* 8210E360h */ case    3:  		/* lwz R10, <#[R11 + 4]> */
		/* 8210E360h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210E360h case    3:*/		return 0x8210E364;
		  /* 8210E364h */ case    4:  		/* cmplw CR6, R22, R10 */
		/* 8210E364h case    4:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R10);
		/* 8210E364h case    4:*/		return 0x8210E368;
		  /* 8210E368h */ case    5:  		/* bc 4, CR6_EQ, 152 */
		/* 8210E368h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8210E400;  }
		/* 8210E368h case    5:*/		return 0x8210E36C;
		  /* 8210E36Ch */ case    6:  		/* lwz R10, <#[R11 + 12]> */
		/* 8210E36Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210E36Ch case    6:*/		return 0x8210E370;
		  /* 8210E370h */ case    7:  		/* cmplw CR6, R7, R10 */
		/* 8210E370h case    7:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 8210E370h case    7:*/		return 0x8210E374;
		  /* 8210E374h */ case    8:  		/* bc 12, CR6_EQ, 140 */
		/* 8210E374h case    8:*/		if ( regs.CR[6].eq ) { return 0x8210E400;  }
		/* 8210E374h case    8:*/		return 0x8210E378;
		  /* 8210E378h */ case    9:  		/* cmplwi CR6, R26, 1 */
		/* 8210E378h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000001);
		/* 8210E378h case    9:*/		return 0x8210E37C;
		  /* 8210E37Ch */ case   10:  		/* bc 4, CR6_EQ, 84 */
		/* 8210E37Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x8210E3D0;  }
		/* 8210E37Ch case   10:*/		return 0x8210E380;
		  /* 8210E380h */ case   11:  		/* lwz R10, <#[R31 + 60]> */
		/* 8210E380h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000003C) );
		/* 8210E380h case   11:*/		return 0x8210E384;
		  /* 8210E384h */ case   12:  		/* rlwinm R8, R7, 2, 0, 29 */
		/* 8210E384h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R7);
		/* 8210E384h case   12:*/		return 0x8210E388;
		  /* 8210E388h */ case   13:  		/* lwz R4, <#[R31 + 64]> */
		/* 8210E388h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000040) );
		/* 8210E388h case   13:*/		return 0x8210E38C;
		  /* 8210E38Ch */ case   14:  		/* lwz R3, <#[R31 + 68]> */
		/* 8210E38Ch case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000044) );
		/* 8210E38Ch case   14:*/		return 0x8210E390;
		  /* 8210E390h */ case   15:  		/* lwz R24, <#[R11 + 12]> */
		/* 8210E390h case   15:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210E390h case   15:*/		return 0x8210E394;
		  /* 8210E394h */ case   16:  		/* lwzx R9, <#[R8 + R10]> */
		/* 8210E394h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 8210E394h case   16:*/		return 0x8210E398;
		  /* 8210E398h */ case   17:  		/* lwzx R10, <#[R4 + R8]> */
		/* 8210E398h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + regs.R8 + 0x00000000) );
		/* 8210E398h case   17:*/		return 0x8210E39C;
		  /* 8210E39Ch */ case   18:  		/* add R10, R9, R10 */
		/* 8210E39Ch case   18:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8210E39Ch case   18:*/		return 0x8210E3A0;
		  /* 8210E3A0h */ case   19:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210E3A0h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210E3A0h case   19:*/		return 0x8210E3A4;
		  /* 8210E3A4h */ case   20:  		/* stwx R24, <#[R10 + R3]> */
		/* 8210E3A4h case   20:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 8210E3A4h case   20:*/		return 0x8210E3A8;
		  /* 8210E3A8h */ case   21:  		/* lwz R4, <#[R31 + 64]> */
		/* 8210E3A8h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000040) );
		/* 8210E3A8h case   21:*/		return 0x8210E3AC;
		  /* 8210E3ACh */ case   22:  		/* lwz R9, <#[R11 + 12]> */
		/* 8210E3ACh case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210E3ACh case   22:*/		return 0x8210E3B0;
		  /* 8210E3B0h */ case   23:  		/* lwz R10, <#[R31 + 60]> */
		/* 8210E3B0h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000003C) );
		/* 8210E3B0h case   23:*/		return 0x8210E3B4;
		  /* 8210E3B4h */ case   24:  		/* rlwinm R8, R9, 2, 0, 29 */
		/* 8210E3B4h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R9);
		/* 8210E3B4h case   24:*/		return 0x8210E3B8;
		  /* 8210E3B8h */ case   25:  		/* lwz R3, <#[R31 + 68]> */
		/* 8210E3B8h case   25:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000044) );
		/* 8210E3B8h case   25:*/		return 0x8210E3BC;
		  /* 8210E3BCh */ case   26:  		/* lwzx R9, <#[R8 + R10]> */
		/* 8210E3BCh case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 8210E3BCh case   26:*/		return 0x8210E3C0;
		  /* 8210E3C0h */ case   27:  		/* lwzx R10, <#[R4 + R8]> */
		/* 8210E3C0h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + regs.R8 + 0x00000000) );
		/* 8210E3C0h case   27:*/		return 0x8210E3C4;
		  /* 8210E3C4h */ case   28:  		/* add R10, R9, R10 */
		/* 8210E3C4h case   28:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8210E3C4h case   28:*/		return 0x8210E3C8;
		  /* 8210E3C8h */ case   29:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210E3C8h case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210E3C8h case   29:*/		return 0x8210E3CC;
		  /* 8210E3CCh */ case   30:  		/* stwx R7, <#[R10 + R3]> */
		/* 8210E3CCh case   30:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 8210E3CCh case   30:*/		return 0x8210E3D0;
	}
	return 0x8210E3D0;
} // Block from 8210E354h-8210E3D0h (31 instructions)

//////////////////////////////////////////////////////
// Block at 8210E3D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E3D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E3D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E3D0);
		  /* 8210E3D0h */ case    0:  		/* lwz R10, <#[R31 + 60]> */
		/* 8210E3D0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000003C) );
		/* 8210E3D0h case    0:*/		return 0x8210E3D4;
		  /* 8210E3D4h */ case    1:  		/* rlwinm R9, R7, 2, 0, 29 */
		/* 8210E3D4h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R7);
		/* 8210E3D4h case    1:*/		return 0x8210E3D8;
		  /* 8210E3D8h */ case    2:  		/* addi R29, R29, 2 */
		/* 8210E3D8h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x2);
		/* 8210E3D8h case    2:*/		return 0x8210E3DC;
		  /* 8210E3DCh */ case    3:  		/* lwzx R8, <#[R9 + R10]> */
		/* 8210E3DCh case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210E3DCh case    3:*/		return 0x8210E3E0;
		  /* 8210E3E0h */ case    4:  		/* addi R8, R8, 1 */
		/* 8210E3E0h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8210E3E0h case    4:*/		return 0x8210E3E4;
		  /* 8210E3E4h */ case    5:  		/* stwx R8, <#[R9 + R10]> */
		/* 8210E3E4h case    5:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210E3E4h case    5:*/		return 0x8210E3E8;
		  /* 8210E3E8h */ case    6:  		/* lwz R10, <#[R31 + 60]> */
		/* 8210E3E8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000003C) );
		/* 8210E3E8h case    6:*/		return 0x8210E3EC;
		  /* 8210E3ECh */ case    7:  		/* lwz R11, <#[R11 + 12]> */
		/* 8210E3ECh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210E3ECh case    7:*/		return 0x8210E3F0;
		  /* 8210E3F0h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210E3F0h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210E3F0h case    8:*/		return 0x8210E3F4;
		  /* 8210E3F4h */ case    9:  		/* lwzx R9, <#[R11 + R10]> */
		/* 8210E3F4h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210E3F4h case    9:*/		return 0x8210E3F8;
		  /* 8210E3F8h */ case   10:  		/* addi R9, R9, 1 */
		/* 8210E3F8h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8210E3F8h case   10:*/		return 0x8210E3FC;
		  /* 8210E3FCh */ case   11:  		/* stwx R9, <#[R11 + R10]> */
		/* 8210E3FCh case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210E3FCh case   11:*/		return 0x8210E400;
	}
	return 0x8210E400;
} // Block from 8210E3D0h-8210E400h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8210E400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E400);
		  /* 8210E400h */ case    0:  		/* add R6, R5, R6 */
		/* 8210E400h case    0:*/		cpu::op::add<0>(regs,&regs.R6,regs.R5,regs.R6);
		/* 8210E400h case    0:*/		return 0x8210E404;
		  /* 8210E404h */ case    1:  		/* bc 16, CR0_LT, -220 */
		/* 8210E404h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210E328;  }
		/* 8210E404h case    1:*/		return 0x8210E408;
	}
	return 0x8210E408;
} // Block from 8210E400h-8210E408h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210E408h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E408);
		  /* 8210E408h */ case    0:  		/* lwz R11, <#[R25 + 12]> */
		/* 8210E408h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000000C) );
		/* 8210E408h case    0:*/		return 0x8210E40C;
		  /* 8210E40Ch */ case    1:  		/* addi R27, R27, 1 */
		/* 8210E40Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8210E40Ch case    1:*/		return 0x8210E410;
		  /* 8210E410h */ case    2:  		/* addi R28, R28, 4 */
		/* 8210E410h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 8210E410h case    2:*/		return 0x8210E414;
		  /* 8210E414h */ case    3:  		/* cmplw CR6, R27, R11 */
		/* 8210E414h case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 8210E414h case    3:*/		return 0x8210E418;
		  /* 8210E418h */ case    4:  		/* bc 12, CR6_LT, -348 */
		/* 8210E418h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210E2BC;  }
		/* 8210E418h case    4:*/		return 0x8210E41C;
	}
	return 0x8210E41C;
} // Block from 8210E408h-8210E41Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210E41Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E41C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E41C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E41C);
		  /* 8210E41Ch */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 8210E41Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 8210E41Ch case    0:*/		return 0x8210E420;
		  /* 8210E420h */ case    1:  		/* bc 4, CR6_EQ, 92 */
		/* 8210E420h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210E47C;  }
		/* 8210E420h case    1:*/		return 0x8210E424;
		  /* 8210E424h */ case    2:  		/* lwz R11, <#[R31 + 40]> */
		/* 8210E424h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8210E424h case    2:*/		return 0x8210E428;
		  /* 8210E428h */ case    3:  		/* li R9, 0 */
		/* 8210E428h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8210E428h case    3:*/		return 0x8210E42C;
		  /* 8210E42Ch */ case    4:  		/* li R10, 0 */
		/* 8210E42Ch case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210E42Ch case    4:*/		return 0x8210E430;
		  /* 8210E430h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8210E430h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210E430h case    5:*/		return 0x8210E434;
		  /* 8210E434h */ case    6:  		/* bc 4, CR6_GT, 48 */
		/* 8210E434h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8210E464;  }
		/* 8210E434h case    6:*/		return 0x8210E438;
		  /* 8210E438h */ case    7:  		/* li R11, 0 */
		/* 8210E438h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210E438h case    7:*/		return 0x8210E43C;
		  /* 8210E43Ch */ case    8:  		/* lwz R8, <#[R31 + 64]> */
		/* 8210E43Ch case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000040) );
		/* 8210E43Ch case    8:*/		return 0x8210E440;
		  /* 8210E440h */ case    9:  		/* addi R10, R10, 1 */
		/* 8210E440h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210E440h case    9:*/		return 0x8210E444;
		  /* 8210E444h */ case   10:  		/* stwx R9, <#[R8 + R11]> */
		/* 8210E444h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8210E444h case   10:*/		return 0x8210E448;
		  /* 8210E448h */ case   11:  		/* lwz R7, <#[R31 + 40]> */
		/* 8210E448h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000028) );
		/* 8210E448h case   11:*/		return 0x8210E44C;
		  /* 8210E44Ch */ case   12:  		/* cmplw CR6, R10, R7 */
		/* 8210E44Ch case   12:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 8210E44Ch case   12:*/		return 0x8210E450;
		  /* 8210E450h */ case   13:  		/* lwz R8, <#[R31 + 60]> */
		/* 8210E450h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000003C) );
		/* 8210E450h case   13:*/		return 0x8210E454;
		  /* 8210E454h */ case   14:  		/* lwzx R8, <#[R11 + R8]> */
		/* 8210E454h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8210E454h case   14:*/		return 0x8210E458;
		  /* 8210E458h */ case   15:  		/* addi R11, R11, 4 */
		/* 8210E458h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210E458h case   15:*/		return 0x8210E45C;
		  /* 8210E45Ch */ case   16:  		/* add R9, R8, R9 */
		/* 8210E45Ch case   16:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8210E45Ch case   16:*/		return 0x8210E460;
		  /* 8210E460h */ case   17:  		/* bc 12, CR6_LT, -36 */
		/* 8210E460h case   17:*/		if ( regs.CR[6].lt ) { return 0x8210E43C;  }
		/* 8210E460h case   17:*/		return 0x8210E464;
	}
	return 0x8210E464;
} // Block from 8210E41Ch-8210E464h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8210E464h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E464);
		  /* 8210E464h */ case    0:  		/* lis R4, 9345 */
		/* 8210E464h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210E464h case    0:*/		return 0x8210E468;
		  /* 8210E468h */ case    1:  		/* rlwinm R3, R29, 2, 0, 29 */
		/* 8210E468h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R29);
		/* 8210E468h case    1:*/		return 0x8210E46C;
		  /* 8210E46Ch */ case    2:  		/* bl -549484 */
		/* 8210E46Ch case    2:*/		regs.LR = 0x8210E470; return 0x82088200;
		/* 8210E46Ch case    2:*/		return 0x8210E470;
		  /* 8210E470h */ case    3:  		/* stw R3, <#[R31 + 68]> */
		/* 8210E470h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000044) );
		/* 8210E470h case    3:*/		return 0x8210E474;
		  /* 8210E474h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 8210E474h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210E474h case    4:*/		return 0x8210E478;
		  /* 8210E478h */ case    5:  		/* bc 12, CR0_EQ, 448 */
		/* 8210E478h case    5:*/		if ( regs.CR[0].eq ) { return 0x8210E638;  }
		/* 8210E478h case    5:*/		return 0x8210E47C;
	}
	return 0x8210E47C;
} // Block from 8210E464h-8210E47Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210E47Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E47C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E47C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E47C);
		  /* 8210E47Ch */ case    0:  		/* addi R26, R26, 1 */
		/* 8210E47Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 8210E47Ch case    0:*/		return 0x8210E480;
		  /* 8210E480h */ case    1:  		/* cmplwi CR6, R26, 2 */
		/* 8210E480h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000002);
		/* 8210E480h case    1:*/		return 0x8210E484;
		  /* 8210E484h */ case    2:  		/* bc 12, CR6_LT, -500 */
		/* 8210E484h case    2:*/		if ( regs.CR[6].lt ) { return 0x8210E290;  }
		/* 8210E484h case    2:*/		return 0x8210E488;
		  /* 8210E488h */ case    3:  		/* lwz R11, <#[R31 + 72]> */
		/* 8210E488h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 8210E488h case    3:*/		return 0x8210E48C;
		  /* 8210E48Ch */ case    4:  		/* li R4, 0 */
		/* 8210E48Ch case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8210E48Ch case    4:*/		return 0x8210E490;
		  /* 8210E490h */ case    5:  		/* lwz R3, <#[R31 + 76]> */
		/* 8210E490h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000004C) );
		/* 8210E490h case    5:*/		return 0x8210E494;
		  /* 8210E494h */ case    6:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 8210E494h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 8210E494h case    6:*/		return 0x8210E498;
		  /* 8210E498h */ case    7:  		/* bl -512344 */
		/* 8210E498h case    7:*/		regs.LR = 0x8210E49C; return 0x82091340;
		/* 8210E498h case    7:*/		return 0x8210E49C;
		  /* 8210E49Ch */ case    8:  		/* lwz R11, <#[R25 + 12]> */
		/* 8210E49Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000000C) );
		/* 8210E49Ch case    8:*/		return 0x8210E4A0;
		  /* 8210E4A0h */ case    9:  		/* li R27, 0 */
		/* 8210E4A0h case    9:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8210E4A0h case    9:*/		return 0x8210E4A4;
		  /* 8210E4A4h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 8210E4A4h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210E4A4h case   10:*/		return 0x8210E4A8;
		  /* 8210E4A8h */ case   11:  		/* bc 4, CR6_GT, 280 */
		/* 8210E4A8h case   11:*/		if ( !regs.CR[6].gt ) { return 0x8210E5C0;  }
		/* 8210E4A8h case   11:*/		return 0x8210E4AC;
		  /* 8210E4ACh */ case   12:  		/* li R26, 0 */
		/* 8210E4ACh case   12:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8210E4ACh case   12:*/		return 0x8210E4B0;
		  /* 8210E4B0h */ case   13:  		/* lwz R11, <#[R25 + 24]> */
		/* 8210E4B0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000018) );
		/* 8210E4B0h case   13:*/		return 0x8210E4B4;
		  /* 8210E4B4h */ case   14:  		/* lwzx R30, <#[R26 + R11]> */
		/* 8210E4B4h case   14:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 8210E4B4h case   14:*/		return 0x8210E4B8;
		  /* 8210E4B8h */ case   15:  		/* lwz R11, <#[R30]> */
		/* 8210E4B8h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8210E4B8h case   15:*/		return 0x8210E4BC;
		  /* 8210E4BCh */ case   16:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 8210E4BCh case   16:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 8210E4BCh case   16:*/		return 0x8210E4C0;
		  /* 8210E4C0h */ case   17:  		/* bc 12, CR0_EQ, 236 */
		/* 8210E4C0h case   17:*/		if ( regs.CR[0].eq ) { return 0x8210E5AC;  }
		/* 8210E4C0h case   17:*/		return 0x8210E4C4;
		  /* 8210E4C4h */ case   18:  		/* lwz R11, <#[R30 + 12]> */
		/* 8210E4C4h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8210E4C4h case   18:*/		return 0x8210E4C8;
		  /* 8210E4C8h */ case   19:  		/* li R28, 0 */
		/* 8210E4C8h case   19:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8210E4C8h case   19:*/		return 0x8210E4CC;
		  /* 8210E4CCh */ case   20:  		/* cmplwi CR6, R11, 0 */
		/* 8210E4CCh case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210E4CCh case   20:*/		return 0x8210E4D0;
		  /* 8210E4D0h */ case   21:  		/* bc 4, CR6_GT, 76 */
		/* 8210E4D0h case   21:*/		if ( !regs.CR[6].gt ) { return 0x8210E51C;  }
		/* 8210E4D0h case   21:*/		return 0x8210E4D4;
		  /* 8210E4D4h */ case   22:  		/* li R29, 0 */
		/* 8210E4D4h case   22:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8210E4D4h case   22:*/		return 0x8210E4D8;
		  /* 8210E4D8h */ case   23:  		/* lwz R11, <#[R30 + 16]> */
		/* 8210E4D8h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8210E4D8h case   23:*/		return 0x8210E4DC;
		  /* 8210E4DCh */ case   24:  		/* lwz R10, <#[R25 + 20]> */
		/* 8210E4DCh case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000014) );
		/* 8210E4DCh case   24:*/		return 0x8210E4E0;
		  /* 8210E4E0h */ case   25:  		/* lwzx R11, <#[R11 + R29]> */
		/* 8210E4E0h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 8210E4E0h case   25:*/		return 0x8210E4E4;
		  /* 8210E4E4h */ case   26:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210E4E4h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210E4E4h case   26:*/		return 0x8210E4E8;
		  /* 8210E4E8h */ case   27:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210E4E8h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210E4E8h case   27:*/		return 0x8210E4EC;
		  /* 8210E4ECh */ case   28:  		/* lwz R5, <#[R11 + 20]> */
		/* 8210E4ECh case   28:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000014) );
		/* 8210E4ECh case   28:*/		return 0x8210E4F0;
		  /* 8210E4F0h */ case   29:  		/* cmpwi CR6, R5, -1 */
		/* 8210E4F0h case   29:*/		cpu::op::cmpwi<6>(regs,regs.R5,0xFFFFFFFF);
		/* 8210E4F0h case   29:*/		return 0x8210E4F4;
		  /* 8210E4F4h */ case   30:  		/* bc 12, CR6_EQ, 20 */
		/* 8210E4F4h case   30:*/		if ( regs.CR[6].eq ) { return 0x8210E508;  }
		/* 8210E4F4h case   30:*/		return 0x8210E4F8;
		  /* 8210E4F8h */ case   31:  		/* mr R6, R27 */
		/* 8210E4F8h case   31:*/		regs.R6 = regs.R27;
		/* 8210E4F8h case   31:*/		return 0x8210E4FC;
		  /* 8210E4FCh */ case   32:  		/* mr R4, R31 */
		/* 8210E4FCh case   32:*/		regs.R4 = regs.R31;
		/* 8210E4FCh case   32:*/		return 0x8210E500;
		  /* 8210E500h */ case   33:  		/* mr R3, R25 */
		/* 8210E500h case   33:*/		regs.R3 = regs.R25;
		/* 8210E500h case   33:*/		return 0x8210E504;
		  /* 8210E504h */ case   34:  		/* bl -35948 */
		/* 8210E504h case   34:*/		regs.LR = 0x8210E508; return 0x82105898;
		/* 8210E504h case   34:*/		return 0x8210E508;
	}
	return 0x8210E508;
} // Block from 8210E47Ch-8210E508h (35 instructions)

//////////////////////////////////////////////////////
// Block at 8210E508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E508);
		  /* 8210E508h */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 8210E508h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8210E508h case    0:*/		return 0x8210E50C;
		  /* 8210E50Ch */ case    1:  		/* addi R28, R28, 1 */
		/* 8210E50Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8210E50Ch case    1:*/		return 0x8210E510;
		  /* 8210E510h */ case    2:  		/* addi R29, R29, 4 */
		/* 8210E510h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8210E510h case    2:*/		return 0x8210E514;
		  /* 8210E514h */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 8210E514h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 8210E514h case    3:*/		return 0x8210E518;
		  /* 8210E518h */ case    4:  		/* bc 12, CR6_LT, -64 */
		/* 8210E518h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210E4D8;  }
		/* 8210E518h case    4:*/		return 0x8210E51C;
	}
	return 0x8210E51C;
} // Block from 8210E508h-8210E51Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210E51Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E51C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E51C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E51C);
		  /* 8210E51Ch */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 8210E51Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8210E51Ch case    0:*/		return 0x8210E520;
		  /* 8210E520h */ case    1:  		/* li R28, 0 */
		/* 8210E520h case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8210E520h case    1:*/		return 0x8210E524;
		  /* 8210E524h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8210E524h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210E524h case    2:*/		return 0x8210E528;
		  /* 8210E528h */ case    3:  		/* bc 4, CR6_GT, 52 */
		/* 8210E528h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210E55C;  }
		/* 8210E528h case    3:*/		return 0x8210E52C;
		  /* 8210E52Ch */ case    4:  		/* li R29, 0 */
		/* 8210E52Ch case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8210E52Ch case    4:*/		return 0x8210E530;
		  /* 8210E530h */ case    5:  		/* lwz R11, <#[R30 + 8]> */
		/* 8210E530h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8210E530h case    5:*/		return 0x8210E534;
		  /* 8210E534h */ case    6:  		/* mr R6, R27 */
		/* 8210E534h case    6:*/		regs.R6 = regs.R27;
		/* 8210E534h case    6:*/		return 0x8210E538;
		  /* 8210E538h */ case    7:  		/* mr R4, R31 */
		/* 8210E538h case    7:*/		regs.R4 = regs.R31;
		/* 8210E538h case    7:*/		return 0x8210E53C;
		  /* 8210E53Ch */ case    8:  		/* mr R3, R25 */
		/* 8210E53Ch case    8:*/		regs.R3 = regs.R25;
		/* 8210E53Ch case    8:*/		return 0x8210E540;
		  /* 8210E540h */ case    9:  		/* lwzx R5, <#[R29 + R11]> */
		/* 8210E540h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 8210E540h case    9:*/		return 0x8210E544;
		  /* 8210E544h */ case   10:  		/* bl -36012 */
		/* 8210E544h case   10:*/		regs.LR = 0x8210E548; return 0x82105898;
		/* 8210E544h case   10:*/		return 0x8210E548;
		  /* 8210E548h */ case   11:  		/* lwz R11, <#[R30 + 4]> */
		/* 8210E548h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8210E548h case   11:*/		return 0x8210E54C;
		  /* 8210E54Ch */ case   12:  		/* addi R28, R28, 1 */
		/* 8210E54Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8210E54Ch case   12:*/		return 0x8210E550;
		  /* 8210E550h */ case   13:  		/* addi R29, R29, 4 */
		/* 8210E550h case   13:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8210E550h case   13:*/		return 0x8210E554;
		  /* 8210E554h */ case   14:  		/* cmplw CR6, R28, R11 */
		/* 8210E554h case   14:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 8210E554h case   14:*/		return 0x8210E558;
		  /* 8210E558h */ case   15:  		/* bc 12, CR6_LT, -40 */
		/* 8210E558h case   15:*/		if ( regs.CR[6].lt ) { return 0x8210E530;  }
		/* 8210E558h case   15:*/		return 0x8210E55C;
	}
	return 0x8210E55C;
} // Block from 8210E51Ch-8210E55Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8210E55Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E55C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E55C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E55C);
		  /* 8210E55Ch */ case    0:  		/* mr R3, R30 */
		/* 8210E55Ch case    0:*/		regs.R3 = regs.R30;
		/* 8210E55Ch case    0:*/		return 0x8210E560;
		  /* 8210E560h */ case    1:  		/* bl -75248 */
		/* 8210E560h case    1:*/		regs.LR = 0x8210E564; return 0x820FBF70;
		/* 8210E560h case    1:*/		return 0x8210E564;
		  /* 8210E564h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 8210E564h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210E564h case    2:*/		return 0x8210E568;
		  /* 8210E568h */ case    3:  		/* bc 12, CR0_EQ, 68 */
		/* 8210E568h case    3:*/		if ( regs.CR[0].eq ) { return 0x8210E5AC;  }
		/* 8210E568h case    3:*/		return 0x8210E56C;
		  /* 8210E56Ch */ case    4:  		/* lwz R11, <#[R30 + 12]> */
		/* 8210E56Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8210E56Ch case    4:*/		return 0x8210E570;
		  /* 8210E570h */ case    5:  		/* li R28, 0 */
		/* 8210E570h case    5:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8210E570h case    5:*/		return 0x8210E574;
		  /* 8210E574h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 8210E574h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210E574h case    6:*/		return 0x8210E578;
		  /* 8210E578h */ case    7:  		/* bc 4, CR6_GT, 52 */
		/* 8210E578h case    7:*/		if ( !regs.CR[6].gt ) { return 0x8210E5AC;  }
		/* 8210E578h case    7:*/		return 0x8210E57C;
		  /* 8210E57Ch */ case    8:  		/* li R29, 0 */
		/* 8210E57Ch case    8:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8210E57Ch case    8:*/		return 0x8210E580;
		  /* 8210E580h */ case    9:  		/* lwz R11, <#[R30 + 16]> */
		/* 8210E580h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8210E580h case    9:*/		return 0x8210E584;
		  /* 8210E584h */ case   10:  		/* mr R6, R27 */
		/* 8210E584h case   10:*/		regs.R6 = regs.R27;
		/* 8210E584h case   10:*/		return 0x8210E588;
		  /* 8210E588h */ case   11:  		/* mr R4, R31 */
		/* 8210E588h case   11:*/		regs.R4 = regs.R31;
		/* 8210E588h case   11:*/		return 0x8210E58C;
		  /* 8210E58Ch */ case   12:  		/* mr R3, R25 */
		/* 8210E58Ch case   12:*/		regs.R3 = regs.R25;
		/* 8210E58Ch case   12:*/		return 0x8210E590;
	}
	return 0x8210E590;
} // Block from 8210E55Ch-8210E590h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8210E590h
// Function '?SwizzleRegisters@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E590( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E590) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E590);
		  /* 8210E590h */ case    0:  		/* lwzx R5, <#[R11 + R29]> */
		/* 8210E590h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 8210E590h case    0:*/		return 0x8210E594;
		  /* 8210E594h */ case    1:  		/* bl -36092 */
		/* 8210E594h case    1:*/		regs.LR = 0x8210E598; return 0x82105898;
		/* 8210E594h case    1:*/		return 0x8210E598;
		  /* 8210E598h */ case    2:  		/* lwz R11, <#[R30 + 12]> */
		/* 8210E598h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8210E598h case    2:*/		return 0x8210E59C;
		  /* 8210E59Ch */ case    3:  		/* addi R28, R28, 1 */
		/* 8210E59Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8210E59Ch case    3:*/		return 0x8210E5A0;
		  /* 8210E5A0h */ case    4:  		/* addi R29, R29, 4 */
		/* 8210E5A0h case    4:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8210E5A0h case    4:*/		return 0x8210E5A4;
		  /* 8210E5A4h */ case    5:  		/* cmplw CR6, R28, R11 */
		/* 8210E5A4h case    5:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 8210E5A4h case    5:*/		return 0x8210E5A8;
		  /* 8210E5A8h */ case    6:  		/* bc 12, CR6_LT, -40 */
		/* 8210E5A8h case    6:*/		if ( regs.CR[6].lt ) { return 0x8210E580;  }
		/* 8210E5A8h case    6:*/		return 0x8210E5AC;
	}
	return 0x8210E5AC;
} // Block from 8210E590h-8210E5ACh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210E5ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E5AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E5AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E5AC);
		  /* 8210E5ACh */ case    0:  		/* lwz R11, <#[R25 + 12]> */
		/* 8210E5ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000000C) );
		/* 8210E5ACh case    0:*/		return 0x8210E5B0;
		  /* 8210E5B0h */ case    1:  		/* addi R27, R27, 1 */
		/* 8210E5B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8210E5B0h case    1:*/		return 0x8210E5B4;
		  /* 8210E5B4h */ case    2:  		/* addi R26, R26, 4 */
		/* 8210E5B4h case    2:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 8210E5B4h case    2:*/		return 0x8210E5B8;
		  /* 8210E5B8h */ case    3:  		/* cmplw CR6, R27, R11 */
		/* 8210E5B8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 8210E5B8h case    3:*/		return 0x8210E5BC;
		  /* 8210E5BCh */ case    4:  		/* bc 12, CR6_LT, -268 */
		/* 8210E5BCh case    4:*/		if ( regs.CR[6].lt ) { return 0x8210E4B0;  }
		/* 8210E5BCh case    4:*/		return 0x8210E5C0;
	}
	return 0x8210E5C0;
} // Block from 8210E5ACh-8210E5C0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210E5C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E5C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E5C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E5C0);
		  /* 8210E5C0h */ case    0:  		/* lwz R11, <#[R31 + 72]> */
		/* 8210E5C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 8210E5C0h case    0:*/		return 0x8210E5C4;
		  /* 8210E5C4h */ case    1:  		/* li R30, 0 */
		/* 8210E5C4h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8210E5C4h case    1:*/		return 0x8210E5C8;
		  /* 8210E5C8h */ case    2:  		/* li R10, 0 */
		/* 8210E5C8h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210E5C8h case    2:*/		return 0x8210E5CC;
		  /* 8210E5CCh */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8210E5CCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210E5CCh case    3:*/		return 0x8210E5D0;
		  /* 8210E5D0h */ case    4:  		/* bc 4, CR6_GT, 48 */
		/* 8210E5D0h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8210E600;  }
		/* 8210E5D0h case    4:*/		return 0x8210E5D4;
		  /* 8210E5D4h */ case    5:  		/* li R11, 0 */
		/* 8210E5D4h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210E5D4h case    5:*/		return 0x8210E5D8;
		  /* 8210E5D8h */ case    6:  		/* lwz R9, <#[R31 + 80]> */
		/* 8210E5D8h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000050) );
		/* 8210E5D8h case    6:*/		return 0x8210E5DC;
		  /* 8210E5DCh */ case    7:  		/* addi R10, R10, 1 */
		/* 8210E5DCh case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210E5DCh case    7:*/		return 0x8210E5E0;
		  /* 8210E5E0h */ case    8:  		/* stwx R30, <#[R9 + R11]> */
		/* 8210E5E0h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8210E5E0h case    8:*/		return 0x8210E5E4;
		  /* 8210E5E4h */ case    9:  		/* lwz R9, <#[R31 + 76]> */
		/* 8210E5E4h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000004C) );
		/* 8210E5E4h case    9:*/		return 0x8210E5E8;
		  /* 8210E5E8h */ case   10:  		/* lwz R8, <#[R31 + 72]> */
		/* 8210E5E8h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000048) );
		/* 8210E5E8h case   10:*/		return 0x8210E5EC;
		  /* 8210E5ECh */ case   11:  		/* cmplw CR6, R10, R8 */
		/* 8210E5ECh case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8210E5ECh case   11:*/		return 0x8210E5F0;
		  /* 8210E5F0h */ case   12:  		/* lwzx R9, <#[R9 + R11]> */
		/* 8210E5F0h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8210E5F0h case   12:*/		return 0x8210E5F4;
		  /* 8210E5F4h */ case   13:  		/* addi R11, R11, 4 */
		/* 8210E5F4h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210E5F4h case   13:*/		return 0x8210E5F8;
		  /* 8210E5F8h */ case   14:  		/* add R30, R9, R30 */
		/* 8210E5F8h case   14:*/		cpu::op::add<0>(regs,&regs.R30,regs.R9,regs.R30);
		/* 8210E5F8h case   14:*/		return 0x8210E5FC;
		  /* 8210E5FCh */ case   15:  		/* bc 12, CR6_LT, -36 */
		/* 8210E5FCh case   15:*/		if ( regs.CR[6].lt ) { return 0x8210E5D8;  }
		/* 8210E5FCh case   15:*/		return 0x8210E600;
	}
	return 0x8210E600;
} // Block from 8210E5C0h-8210E600h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8210E600h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E600);
		  /* 8210E600h */ case    0:  		/* lis R4, 9345 */
		/* 8210E600h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210E600h case    0:*/		return 0x8210E604;
		  /* 8210E604h */ case    1:  		/* rlwinm R3, R30, 2, 0, 29 */
		/* 8210E604h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R30);
		/* 8210E604h case    1:*/		return 0x8210E608;
		  /* 8210E608h */ case    2:  		/* bl -549896 */
		/* 8210E608h case    2:*/		regs.LR = 0x8210E60C; return 0x82088200;
		/* 8210E608h case    2:*/		return 0x8210E60C;
		  /* 8210E60Ch */ case    3:  		/* stw R3, <#[R31 + 84]> */
		/* 8210E60Ch case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000054) );
		/* 8210E60Ch case    3:*/		return 0x8210E610;
		  /* 8210E610h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 8210E610h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210E610h case    4:*/		return 0x8210E614;
		  /* 8210E614h */ case    5:  		/* bc 12, CR0_EQ, 36 */
		/* 8210E614h case    5:*/		if ( regs.CR[0].eq ) { return 0x8210E638;  }
		/* 8210E614h case    5:*/		return 0x8210E618;
		  /* 8210E618h */ case    6:  		/* lis R4, 9345 */
		/* 8210E618h case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210E618h case    6:*/		return 0x8210E61C;
		  /* 8210E61Ch */ case    7:  		/* mulli R3, R30, 12 */
		/* 8210E61Ch case    7:*/		cpu::op::mulli<0>(regs,&regs.R3,regs.R30,0xC);
		/* 8210E61Ch case    7:*/		return 0x8210E620;
		  /* 8210E620h */ case    8:  		/* bl -549920 */
		/* 8210E620h case    8:*/		regs.LR = 0x8210E624; return 0x82088200;
		/* 8210E620h case    8:*/		return 0x8210E624;
		  /* 8210E624h */ case    9:  		/* stw R3, <#[R31 + 88]> */
		/* 8210E624h case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000058) );
		/* 8210E624h case    9:*/		return 0x8210E628;
		  /* 8210E628h */ case   10:  		/* cmplwi CR0, R3, 0 */
		/* 8210E628h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210E628h case   10:*/		return 0x8210E62C;
		  /* 8210E62Ch */ case   11:  		/* bc 12, CR0_EQ, 12 */
		/* 8210E62Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x8210E638;  }
		/* 8210E62Ch case   11:*/		return 0x8210E630;
		  /* 8210E630h */ case   12:  		/* li R3, 0 */
		/* 8210E630h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8210E630h case   12:*/		return 0x8210E634;
		  /* 8210E634h */ case   13:  		/* b 12 */
		/* 8210E634h case   13:*/		return 0x8210E640;
		/* 8210E634h case   13:*/		return 0x8210E638;
	}
	return 0x8210E638;
} // Block from 8210E600h-8210E638h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8210E638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E638);
		  /* 8210E638h */ case    0:  		/* lis R3, -32761 */
		/* 8210E638h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 8210E638h case    0:*/		return 0x8210E63C;
		  /* 8210E63Ch */ case    1:  		/* ori R3, R3, 14 */
		/* 8210E63Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 8210E63Ch case    1:*/		return 0x8210E640;
	}
	return 0x8210E640;
} // Block from 8210E638h-8210E640h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210E640h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E640);
		  /* 8210E640h */ case    0:  		/* addi R1, R1, 192 */
		/* 8210E640h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 8210E640h case    0:*/		return 0x8210E644;
		  /* 8210E644h */ case    1:  		/* b -512960 */
		/* 8210E644h case    1:*/		return 0x82091284;
		/* 8210E644h case    1:*/		return 0x8210E648;
	}
	return 0x8210E648;
} // Block from 8210E640h-8210E648h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210E648h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E648);
		  /* 8210E648h */ case    0:  		/* mfspr R12, LR */
		/* 8210E648h case    0:*/		regs.R12 = regs.LR;
		/* 8210E648h case    0:*/		return 0x8210E64C;
		  /* 8210E64Ch */ case    1:  		/* bl -513008 */
		/* 8210E64Ch case    1:*/		regs.LR = 0x8210E650; return 0x8209125C;
		/* 8210E64Ch case    1:*/		return 0x8210E650;
		  /* 8210E650h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8210E650h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8210E650h case    2:*/		return 0x8210E654;
		  /* 8210E654h */ case    3:  		/* lwz R11, <#[R4 + 4]> */
		/* 8210E654h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 8210E654h case    3:*/		return 0x8210E658;
		  /* 8210E658h */ case    4:  		/* mr R31, R5 */
		/* 8210E658h case    4:*/		regs.R31 = regs.R5;
		/* 8210E658h case    4:*/		return 0x8210E65C;
		  /* 8210E65Ch */ case    5:  		/* lwz R10, <#[R3 + 16]> */
		/* 8210E65Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 8210E65Ch case    5:*/		return 0x8210E660;
		  /* 8210E660h */ case    6:  		/* mr R30, R6 */
		/* 8210E660h case    6:*/		regs.R30 = regs.R6;
		/* 8210E660h case    6:*/		return 0x8210E664;
		  /* 8210E664h */ case    7:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8210E664h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8210E664h case    7:*/		return 0x8210E668;
		  /* 8210E668h */ case    8:  		/* lwz R11, <#[R4 + 56]> */
		/* 8210E668h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000038) );
		/* 8210E668h case    8:*/		return 0x8210E66C;
		  /* 8210E66Ch */ case    9:  		/* cmpwi CR6, R11, -1 */
		/* 8210E66Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210E66Ch case    9:*/		return 0x8210E670;
		  /* 8210E670h */ case   10:  		/* lwzx R10, <#[R9 + R10]> */
		/* 8210E670h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210E670h case   10:*/		return 0x8210E674;
		  /* 8210E674h */ case   11:  		/* bc 4, CR6_EQ, 12 */
		/* 8210E674h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8210E680;  }
		/* 8210E674h case   11:*/		return 0x8210E678;
		  /* 8210E678h */ case   12:  		/* mr R29, R4 */
		/* 8210E678h case   12:*/		regs.R29 = regs.R4;
		/* 8210E678h case   12:*/		return 0x8210E67C;
		  /* 8210E67Ch */ case   13:  		/* b 16 */
		/* 8210E67Ch case   13:*/		return 0x8210E68C;
		/* 8210E67Ch case   13:*/		return 0x8210E680;
	}
	return 0x8210E680;
} // Block from 8210E648h-8210E680h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8210E680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E680);
		  /* 8210E680h */ case    0:  		/* lwz R9, <#[R3 + 20]> */
		/* 8210E680h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 8210E680h case    0:*/		return 0x8210E684;
		  /* 8210E684h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210E684h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210E684h case    1:*/		return 0x8210E688;
		  /* 8210E688h */ case    2:  		/* lwzx R29, <#[R11 + R9]> */
		/* 8210E688h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210E688h case    2:*/		return 0x8210E68C;
	}
	return 0x8210E68C;
} // Block from 8210E680h-8210E68Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210E68Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E68C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E68C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E68C);
		  /* 8210E68Ch */ case    0:  		/* lwz R6, <#[R10]> */
		/* 8210E68Ch case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 8210E68Ch case    0:*/		return 0x8210E690;
		  /* 8210E690h */ case    1:  		/* lbz R11, <#[R6]> */
		/* 8210E690h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 8210E690h case    1:*/		return 0x8210E694;
		  /* 8210E694h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 8210E694h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8210E694h case    2:*/		return 0x8210E698;
		  /* 8210E698h */ case    3:  		/* bc 12, CR0_EQ, 28 */
		/* 8210E698h case    3:*/		if ( regs.CR[0].eq ) { return 0x8210E6B4;  }
		/* 8210E698h case    3:*/		return 0x8210E69C;
		  /* 8210E69Ch */ case    4:  		/* lbz R11, <#[R6 + 1]> */
		/* 8210E69Ch case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000001) );
		/* 8210E69Ch case    4:*/		return 0x8210E6A0;
		  /* 8210E6A0h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 8210E6A0h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8210E6A0h case    5:*/		return 0x8210E6A4;
		  /* 8210E6A4h */ case    6:  		/* bc 4, CR0_EQ, 16 */
		/* 8210E6A4h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8210E6B4;  }
		/* 8210E6A4h case    6:*/		return 0x8210E6A8;
		  /* 8210E6A8h */ case    7:  		/* lis R11, -32255 */
		/* 8210E6A8h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8210E6A8h case    7:*/		return 0x8210E6AC;
		  /* 8210E6ACh */ case    8:  		/* addi R5, R11, -10432 */
		/* 8210E6ACh case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFD740);
		/* 8210E6ACh case    8:*/		return 0x8210E6B0;
		  /* 8210E6B0h */ case    9:  		/* b 12 */
		/* 8210E6B0h case    9:*/		return 0x8210E6BC;
		/* 8210E6B0h case    9:*/		return 0x8210E6B4;
	}
	return 0x8210E6B4;
} // Block from 8210E68Ch-8210E6B4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8210E6B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E6B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E6B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E6B4);
		  /* 8210E6B4h */ case    0:  		/* lis R11, -32254 */
		/* 8210E6B4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 8210E6B4h case    0:*/		return 0x8210E6B8;
		  /* 8210E6B8h */ case    1:  		/* addi R5, R11, -14300 */
		/* 8210E6B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFC824);
		/* 8210E6B8h case    1:*/		return 0x8210E6BC;
	}
	return 0x8210E6BC;
} // Block from 8210E6B4h-8210E6BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210E6BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E6BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E6BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E6BC);
		  /* 8210E6BCh */ case    0:  		/* mr R4, R30 */
		/* 8210E6BCh case    0:*/		regs.R4 = regs.R30;
		/* 8210E6BCh case    0:*/		return 0x8210E6C0;
		  /* 8210E6C0h */ case    1:  		/* mr R3, R31 */
		/* 8210E6C0h case    1:*/		regs.R3 = regs.R31;
		/* 8210E6C0h case    1:*/		return 0x8210E6C4;
		  /* 8210E6C4h */ case    2:  		/* bl -442500 */
		/* 8210E6C4h case    2:*/		regs.LR = 0x8210E6C8; return 0x820A2640;
		/* 8210E6C4h case    2:*/		return 0x8210E6C8;
		  /* 8210E6C8h */ case    3:  		/* mr R11, R31 */
		/* 8210E6C8h case    3:*/		regs.R11 = regs.R31;
		/* 8210E6C8h case    3:*/		return 0x8210E6CC;
		  /* 8210E6CCh */ case    4:  		/* lbz R10, <#[R11]> */
		/* 8210E6CCh case    4:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210E6CCh case    4:*/		return 0x8210E6D0;
		  /* 8210E6D0h */ case    5:  		/* addi R11, R11, 1 */
		/* 8210E6D0h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210E6D0h case    5:*/		return 0x8210E6D4;
		  /* 8210E6D4h */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 8210E6D4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8210E6D4h case    6:*/		return 0x8210E6D8;
		  /* 8210E6D8h */ case    7:  		/* bc 4, CR6_EQ, -12 */
		/* 8210E6D8h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8210E6CC;  }
		/* 8210E6D8h case    7:*/		return 0x8210E6DC;
		  /* 8210E6DCh */ case    8:  		/* subf R11, R31, R11 */
		/* 8210E6DCh case    8:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 8210E6DCh case    8:*/		return 0x8210E6E0;
		  /* 8210E6E0h */ case    9:  		/* lwz R6, <#[R29 + 12]> */
		/* 8210E6E0h case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R29 + 0x0000000C) );
		/* 8210E6E0h case    9:*/		return 0x8210E6E4;
		  /* 8210E6E4h */ case   10:  		/* addi R11, R11, -1 */
		/* 8210E6E4h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8210E6E4h case   10:*/		return 0x8210E6E8;
		  /* 8210E6E8h */ case   11:  		/* cmpwi CR6, R6, -1 */
		/* 8210E6E8h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R6,0xFFFFFFFF);
		/* 8210E6E8h case   11:*/		return 0x8210E6EC;
		  /* 8210E6ECh */ case   12:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 8210E6ECh case   12:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 8210E6ECh case   12:*/		return 0x8210E6F0;
		  /* 8210E6F0h */ case   13:  		/* subf R4, R11, R30 */
		/* 8210E6F0h case   13:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R11,regs.R30);
		/* 8210E6F0h case   13:*/		return 0x8210E6F4;
		  /* 8210E6F4h */ case   14:  		/* add R3, R11, R31 */
		/* 8210E6F4h case   14:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R31);
		/* 8210E6F4h case   14:*/		return 0x8210E6F8;
		  /* 8210E6F8h */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 8210E6F8h case   15:*/		if ( regs.CR[6].eq ) { return 0x8210E70C;  }
		/* 8210E6F8h case   15:*/		return 0x8210E6FC;
		  /* 8210E6FCh */ case   16:  		/* lis R10, -32255 */
		/* 8210E6FCh case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8210E6FCh case   16:*/		return 0x8210E700;
		  /* 8210E700h */ case   17:  		/* addi R5, R10, -10436 */
		/* 8210E700h case   17:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFD73C);
		/* 8210E700h case   17:*/		return 0x8210E704;
		  /* 8210E704h */ case   18:  		/* bl -442564 */
		/* 8210E704h case   18:*/		regs.LR = 0x8210E708; return 0x820A2640;
		/* 8210E704h case   18:*/		return 0x8210E708;
		  /* 8210E708h */ case   19:  		/* b 16 */
		/* 8210E708h case   19:*/		return 0x8210E718;
		/* 8210E708h case   19:*/		return 0x8210E70C;
	}
	return 0x8210E70C;
} // Block from 8210E6BCh-8210E70Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 8210E70Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E70C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E70C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E70C);
		  /* 8210E70Ch */ case    0:  		/* lis R10, -32254 */
		/* 8210E70Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 8210E70Ch case    0:*/		return 0x8210E710;
		  /* 8210E710h */ case    1:  		/* addi R5, R10, -14304 */
		/* 8210E710h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFC820);
		/* 8210E710h case    1:*/		return 0x8210E714;
		  /* 8210E714h */ case    2:  		/* bl -442580 */
		/* 8210E714h case    2:*/		regs.LR = 0x8210E718; return 0x820A2640;
		/* 8210E714h case    2:*/		return 0x8210E718;
	}
	return 0x8210E718;
} // Block from 8210E70Ch-8210E718h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210E718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E718);
		  /* 8210E718h */ case    0:  		/* add R11, R31, R30 */
		/* 8210E718h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R30);
		/* 8210E718h case    0:*/		return 0x8210E71C;
		  /* 8210E71Ch */ case    1:  		/* li R10, 0 */
		/* 8210E71Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210E71Ch case    1:*/		return 0x8210E720;
		  /* 8210E720h */ case    2:  		/* stb R10, <#[R11 - 1]> */
		/* 8210E720h case    2:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0xFFFFFFFF) );
		/* 8210E720h case    2:*/		return 0x8210E724;
		  /* 8210E724h */ case    3:  		/* addi R1, R1, 112 */
		/* 8210E724h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8210E724h case    3:*/		return 0x8210E728;
		  /* 8210E728h */ case    4:  		/* b -513148 */
		/* 8210E728h case    4:*/		return 0x820912AC;
		/* 8210E728h case    4:*/		return 0x8210E72C;
		  /* 8210E72Ch */ case    5:  		/* nop */
		/* 8210E72Ch case    5:*/		cpu::op::nop();
		/* 8210E72Ch case    5:*/		return 0x8210E730;
	}
	return 0x8210E730;
} // Block from 8210E718h-8210E730h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210E730h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E730);
		  /* 8210E730h */ case    0:  		/* mfspr R12, LR */
		/* 8210E730h case    0:*/		regs.R12 = regs.LR;
		/* 8210E730h case    0:*/		return 0x8210E734;
		  /* 8210E734h */ case    1:  		/* bl -513240 */
		/* 8210E734h case    1:*/		regs.LR = 0x8210E738; return 0x8209125C;
		/* 8210E734h case    1:*/		return 0x8210E738;
		  /* 8210E738h */ case    2:  		/* std R7, <#[R1 + 48]> */
		/* 8210E738h case    2:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 8210E738h case    2:*/		return 0x8210E73C;
		  /* 8210E73Ch */ case    3:  		/* std R8, <#[R1 + 56]> */
		/* 8210E73Ch case    3:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 8210E73Ch case    3:*/		return 0x8210E740;
		  /* 8210E740h */ case    4:  		/* std R9, <#[R1 + 64]> */
		/* 8210E740h case    4:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 8210E740h case    4:*/		return 0x8210E744;
		  /* 8210E744h */ case    5:  		/* std R10, <#[R1 + 72]> */
		/* 8210E744h case    5:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 8210E744h case    5:*/		return 0x8210E748;
		  /* 8210E748h */ case    6:  		/* stwu R1, <#[R1 - 384]> */
		/* 8210E748h case    6:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE80);
		/* 8210E748h case    6:*/		return 0x8210E74C;
		  /* 8210E74Ch */ case    7:  		/* stw R6, <#[R1 + 428]> */
		/* 8210E74Ch case    7:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x000001AC) );
		/* 8210E74Ch case    7:*/		return 0x8210E750;
		  /* 8210E750h */ case    8:  		/* addi R11, R1, 80 */
		/* 8210E750h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8210E750h case    8:*/		return 0x8210E754;
		  /* 8210E754h */ case    9:  		/* addi R10, R1, 432 */
		/* 8210E754h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x1B0);
		/* 8210E754h case    9:*/		return 0x8210E758;
		  /* 8210E758h */ case   10:  		/* mr R30, R3 */
		/* 8210E758h case   10:*/		regs.R30 = regs.R3;
		/* 8210E758h case   10:*/		return 0x8210E75C;
		  /* 8210E75Ch */ case   11:  		/* mr R31, R4 */
		/* 8210E75Ch case   11:*/		regs.R31 = regs.R4;
		/* 8210E75Ch case   11:*/		return 0x8210E760;
		  /* 8210E760h */ case   12:  		/* mr R29, R5 */
		/* 8210E760h case   12:*/		regs.R29 = regs.R5;
		/* 8210E760h case   12:*/		return 0x8210E764;
		  /* 8210E764h */ case   13:  		/* mr R5, R6 */
		/* 8210E764h case   13:*/		regs.R5 = regs.R6;
		/* 8210E764h case   13:*/		return 0x8210E768;
		  /* 8210E768h */ case   14:  		/* stw R10, <#[R11]> */
		/* 8210E768h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210E768h case   14:*/		return 0x8210E76C;
		  /* 8210E76Ch */ case   15:  		/* li R4, 256 */
		/* 8210E76Ch case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x100);
		/* 8210E76Ch case   15:*/		return 0x8210E770;
		  /* 8210E770h */ case   16:  		/* lwz R6, <#[R1 + 80]> */
		/* 8210E770h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 8210E770h case   16:*/		return 0x8210E774;
		  /* 8210E774h */ case   17:  		/* addi R3, R1, 96 */
		/* 8210E774h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8210E774h case   17:*/		return 0x8210E778;
		  /* 8210E778h */ case   18:  		/* bl -456848 */
		/* 8210E778h case   18:*/		regs.LR = 0x8210E77C; return 0x8209EEE8;
		/* 8210E778h case   18:*/		return 0x8210E77C;
		  /* 8210E77Ch */ case   19:  		/* li R4, 0 */
		/* 8210E77Ch case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8210E77Ch case   19:*/		return 0x8210E780;
		  /* 8210E780h */ case   20:  		/* cmplwi CR6, R31, 0 */
		/* 8210E780h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8210E780h case   20:*/		return 0x8210E784;
		  /* 8210E784h */ case   21:  		/* stb R4, <#[R1 + 351]> */
		/* 8210E784h case   21:*/		cpu::mem::store8( regs, regs.R4, (uint32)(regs.R1 + 0x0000015F) );
		/* 8210E784h case   21:*/		return 0x8210E788;
		  /* 8210E788h */ case   22:  		/* bc 12, CR6_EQ, 56 */
		/* 8210E788h case   22:*/		if ( regs.CR[6].eq ) { return 0x8210E7C0;  }
		/* 8210E788h case   22:*/		return 0x8210E78C;
		  /* 8210E78Ch */ case   23:  		/* lwz R11, <#[R31 + 4]> */
		/* 8210E78Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8210E78Ch case   23:*/		return 0x8210E790;
		  /* 8210E790h */ case   24:  		/* cmpwi CR6, R11, 3 */
		/* 8210E790h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8210E790h case   24:*/		return 0x8210E794;
		  /* 8210E794h */ case   25:  		/* bc 12, CR6_EQ, 40 */
		/* 8210E794h case   25:*/		if ( regs.CR[6].eq ) { return 0x8210E7BC;  }
		/* 8210E794h case   25:*/		return 0x8210E798;
		  /* 8210E798h */ case   26:  		/* cmpwi CR6, R11, 6 */
		/* 8210E798h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 8210E798h case   26:*/		return 0x8210E79C;
		  /* 8210E79Ch */ case   27:  		/* bc 12, CR6_EQ, 20 */
		/* 8210E79Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x8210E7B0;  }
		/* 8210E79Ch case   27:*/		return 0x8210E7A0;
		  /* 8210E7A0h */ case   28:  		/* cmpwi CR6, R11, 14 */
		/* 8210E7A0h case   28:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000E);
		/* 8210E7A0h case   28:*/		return 0x8210E7A4;
		  /* 8210E7A4h */ case   29:  		/* bc 4, CR6_EQ, 28 */
		/* 8210E7A4h case   29:*/		if ( !regs.CR[6].eq ) { return 0x8210E7C0;  }
		/* 8210E7A4h case   29:*/		return 0x8210E7A8;
		  /* 8210E7A8h */ case   30:  		/* addi R4, R31, 48 */
		/* 8210E7A8h case   30:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x30);
		/* 8210E7A8h case   30:*/		return 0x8210E7AC;
		  /* 8210E7ACh */ case   31:  		/* b 20 */
		/* 8210E7ACh case   31:*/		return 0x8210E7C0;
		/* 8210E7ACh case   31:*/		return 0x8210E7B0;
	}
	return 0x8210E7B0;
} // Block from 8210E730h-8210E7B0h (32 instructions)

//////////////////////////////////////////////////////
// Block at 8210E7B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E7B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E7B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E7B0);
		  /* 8210E7B0h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 8210E7B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8210E7B0h case    0:*/		return 0x8210E7B4;
		  /* 8210E7B4h */ case    1:  		/* addi R4, R11, 16 */
		/* 8210E7B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x10);
		/* 8210E7B4h case    1:*/		return 0x8210E7B8;
		  /* 8210E7B8h */ case    2:  		/* b 8 */
		/* 8210E7B8h case    2:*/		return 0x8210E7C0;
		/* 8210E7B8h case    2:*/		return 0x8210E7BC;
	}
	return 0x8210E7BC;
} // Block from 8210E7B0h-8210E7BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210E7BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E7BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E7BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E7BC);
		  /* 8210E7BCh */ case    0:  		/* addi R4, R31, 16 */
		/* 8210E7BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x10);
		/* 8210E7BCh case    0:*/		return 0x8210E7C0;
	}
	return 0x8210E7C0;
} // Block from 8210E7BCh-8210E7C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210E7C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E7C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E7C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E7C0);
		  /* 8210E7C0h */ case    0:  		/* lis R11, -32255 */
		/* 8210E7C0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8210E7C0h case    0:*/		return 0x8210E7C4;
		  /* 8210E7C4h */ case    1:  		/* lwz R3, <#[R30 + 196]> */
		/* 8210E7C4h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000000C4) );
		/* 8210E7C4h case    1:*/		return 0x8210E7C8;
		  /* 8210E7C8h */ case    2:  		/* addi R7, R1, 96 */
		/* 8210E7C8h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 8210E7C8h case    2:*/		return 0x8210E7CC;
		  /* 8210E7CCh */ case    3:  		/* addi R6, R11, -10432 */
		/* 8210E7CCh case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD740);
		/* 8210E7CCh case    3:*/		return 0x8210E7D0;
		  /* 8210E7D0h */ case    4:  		/* mr R5, R29 */
		/* 8210E7D0h case    4:*/		regs.R5 = regs.R29;
		/* 8210E7D0h case    4:*/		return 0x8210E7D4;
		  /* 8210E7D4h */ case    5:  		/* bl -423492 */
		/* 8210E7D4h case    5:*/		regs.LR = 0x8210E7D8; return 0x820A7190;
		/* 8210E7D4h case    5:*/		return 0x8210E7D8;
		  /* 8210E7D8h */ case    6:  		/* li R11, 1 */
		/* 8210E7D8h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8210E7D8h case    6:*/		return 0x8210E7DC;
		  /* 8210E7DCh */ case    7:  		/* li R3, 0 */
		/* 8210E7DCh case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8210E7DCh case    7:*/		return 0x8210E7E0;
		  /* 8210E7E0h */ case    8:  		/* stw R11, <#[R30 + 212]> */
		/* 8210E7E0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x000000D4) );
		/* 8210E7E0h case    8:*/		return 0x8210E7E4;
		  /* 8210E7E4h */ case    9:  		/* addi R1, R1, 384 */
		/* 8210E7E4h case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x180);
		/* 8210E7E4h case    9:*/		return 0x8210E7E8;
		  /* 8210E7E8h */ case   10:  		/* b -513340 */
		/* 8210E7E8h case   10:*/		return 0x820912AC;
		/* 8210E7E8h case   10:*/		return 0x8210E7EC;
		  /* 8210E7ECh */ case   11:  		/* nop */
		/* 8210E7ECh case   11:*/		cpu::op::nop();
		/* 8210E7ECh case   11:*/		return 0x8210E7F0;
	}
	return 0x8210E7F0;
} // Block from 8210E7C0h-8210E7F0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8210E7F0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E7F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E7F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E7F0);
		  /* 8210E7F0h */ case    0:  		/* mfspr R12, LR */
		/* 8210E7F0h case    0:*/		regs.R12 = regs.LR;
		/* 8210E7F0h case    0:*/		return 0x8210E7F4;
		  /* 8210E7F4h */ case    1:  		/* bl -513432 */
		/* 8210E7F4h case    1:*/		regs.LR = 0x8210E7F8; return 0x8209125C;
		/* 8210E7F4h case    1:*/		return 0x8210E7F8;
		  /* 8210E7F8h */ case    2:  		/* std R7, <#[R1 + 48]> */
		/* 8210E7F8h case    2:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 8210E7F8h case    2:*/		return 0x8210E7FC;
		  /* 8210E7FCh */ case    3:  		/* std R8, <#[R1 + 56]> */
		/* 8210E7FCh case    3:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 8210E7FCh case    3:*/		return 0x8210E800;
		  /* 8210E800h */ case    4:  		/* std R9, <#[R1 + 64]> */
		/* 8210E800h case    4:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 8210E800h case    4:*/		return 0x8210E804;
		  /* 8210E804h */ case    5:  		/* std R10, <#[R1 + 72]> */
		/* 8210E804h case    5:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 8210E804h case    5:*/		return 0x8210E808;
		  /* 8210E808h */ case    6:  		/* stwu R1, <#[R1 - 384]> */
		/* 8210E808h case    6:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE80);
		/* 8210E808h case    6:*/		return 0x8210E80C;
		  /* 8210E80Ch */ case    7:  		/* stw R6, <#[R1 + 428]> */
		/* 8210E80Ch case    7:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x000001AC) );
		/* 8210E80Ch case    7:*/		return 0x8210E810;
		  /* 8210E810h */ case    8:  		/* addi R11, R1, 80 */
		/* 8210E810h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8210E810h case    8:*/		return 0x8210E814;
		  /* 8210E814h */ case    9:  		/* addi R10, R1, 432 */
		/* 8210E814h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x1B0);
		/* 8210E814h case    9:*/		return 0x8210E818;
		  /* 8210E818h */ case   10:  		/* mr R30, R3 */
		/* 8210E818h case   10:*/		regs.R30 = regs.R3;
		/* 8210E818h case   10:*/		return 0x8210E81C;
		  /* 8210E81Ch */ case   11:  		/* mr R31, R4 */
		/* 8210E81Ch case   11:*/		regs.R31 = regs.R4;
		/* 8210E81Ch case   11:*/		return 0x8210E820;
		  /* 8210E820h */ case   12:  		/* mr R29, R5 */
		/* 8210E820h case   12:*/		regs.R29 = regs.R5;
		/* 8210E820h case   12:*/		return 0x8210E824;
		  /* 8210E824h */ case   13:  		/* mr R5, R6 */
		/* 8210E824h case   13:*/		regs.R5 = regs.R6;
		/* 8210E824h case   13:*/		return 0x8210E828;
		  /* 8210E828h */ case   14:  		/* stw R10, <#[R11]> */
		/* 8210E828h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210E828h case   14:*/		return 0x8210E82C;
		  /* 8210E82Ch */ case   15:  		/* li R4, 256 */
		/* 8210E82Ch case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x100);
		/* 8210E82Ch case   15:*/		return 0x8210E830;
		  /* 8210E830h */ case   16:  		/* lwz R6, <#[R1 + 80]> */
		/* 8210E830h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 8210E830h case   16:*/		return 0x8210E834;
		  /* 8210E834h */ case   17:  		/* addi R3, R1, 96 */
		/* 8210E834h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8210E834h case   17:*/		return 0x8210E838;
		  /* 8210E838h */ case   18:  		/* bl -457040 */
		/* 8210E838h case   18:*/		regs.LR = 0x8210E83C; return 0x8209EEE8;
		/* 8210E838h case   18:*/		return 0x8210E83C;
		  /* 8210E83Ch */ case   19:  		/* li R4, 0 */
		/* 8210E83Ch case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8210E83Ch case   19:*/		return 0x8210E840;
		  /* 8210E840h */ case   20:  		/* cmplwi CR6, R31, 0 */
		/* 8210E840h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8210E840h case   20:*/		return 0x8210E844;
		  /* 8210E844h */ case   21:  		/* stb R4, <#[R1 + 351]> */
		/* 8210E844h case   21:*/		cpu::mem::store8( regs, regs.R4, (uint32)(regs.R1 + 0x0000015F) );
		/* 8210E844h case   21:*/		return 0x8210E848;
		  /* 8210E848h */ case   22:  		/* bc 12, CR6_EQ, 56 */
		/* 8210E848h case   22:*/		if ( regs.CR[6].eq ) { return 0x8210E880;  }
		/* 8210E848h case   22:*/		return 0x8210E84C;
		  /* 8210E84Ch */ case   23:  		/* lwz R11, <#[R31 + 4]> */
		/* 8210E84Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8210E84Ch case   23:*/		return 0x8210E850;
		  /* 8210E850h */ case   24:  		/* cmpwi CR6, R11, 3 */
		/* 8210E850h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8210E850h case   24:*/		return 0x8210E854;
		  /* 8210E854h */ case   25:  		/* bc 12, CR6_EQ, 40 */
		/* 8210E854h case   25:*/		if ( regs.CR[6].eq ) { return 0x8210E87C;  }
		/* 8210E854h case   25:*/		return 0x8210E858;
		  /* 8210E858h */ case   26:  		/* cmpwi CR6, R11, 6 */
		/* 8210E858h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 8210E858h case   26:*/		return 0x8210E85C;
		  /* 8210E85Ch */ case   27:  		/* bc 12, CR6_EQ, 20 */
		/* 8210E85Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x8210E870;  }
		/* 8210E85Ch case   27:*/		return 0x8210E860;
	}
	return 0x8210E860;
} // Block from 8210E7F0h-8210E860h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8210E860h
// Function '?CompactPool_Begin@CProgram@D3DXShader@@IAAJPAU_D3DXCP_DATA@2@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E860);
		  /* 8210E860h */ case    0:  		/* cmpwi CR6, R11, 14 */
		/* 8210E860h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000E);
		/* 8210E860h case    0:*/		return 0x8210E864;
		  /* 8210E864h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 8210E864h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210E880;  }
		/* 8210E864h case    1:*/		return 0x8210E868;
		  /* 8210E868h */ case    2:  		/* addi R4, R31, 48 */
		/* 8210E868h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x30);
		/* 8210E868h case    2:*/		return 0x8210E86C;
		  /* 8210E86Ch */ case    3:  		/* b 20 */
		/* 8210E86Ch case    3:*/		return 0x8210E880;
		/* 8210E86Ch case    3:*/		return 0x8210E870;
	}
	return 0x8210E870;
} // Block from 8210E860h-8210E870h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210E870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E870);
		  /* 8210E870h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 8210E870h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8210E870h case    0:*/		return 0x8210E874;
		  /* 8210E874h */ case    1:  		/* addi R4, R11, 16 */
		/* 8210E874h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x10);
		/* 8210E874h case    1:*/		return 0x8210E878;
		  /* 8210E878h */ case    2:  		/* b 8 */
		/* 8210E878h case    2:*/		return 0x8210E880;
		/* 8210E878h case    2:*/		return 0x8210E87C;
	}
	return 0x8210E87C;
} // Block from 8210E870h-8210E87Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210E87Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E87C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E87C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E87C);
		  /* 8210E87Ch */ case    0:  		/* addi R4, R31, 16 */
		/* 8210E87Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x10);
		/* 8210E87Ch case    0:*/		return 0x8210E880;
	}
	return 0x8210E880;
} // Block from 8210E87Ch-8210E880h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210E880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E880);
		  /* 8210E880h */ case    0:  		/* lis R11, -32255 */
		/* 8210E880h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8210E880h case    0:*/		return 0x8210E884;
		  /* 8210E884h */ case    1:  		/* lwz R3, <#[R30 + 196]> */
		/* 8210E884h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000000C4) );
		/* 8210E884h case    1:*/		return 0x8210E888;
		  /* 8210E888h */ case    2:  		/* addi R7, R1, 96 */
		/* 8210E888h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 8210E888h case    2:*/		return 0x8210E88C;
		  /* 8210E88Ch */ case    3:  		/* addi R6, R11, -10432 */
		/* 8210E88Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD740);
		/* 8210E88Ch case    3:*/		return 0x8210E890;
		  /* 8210E890h */ case    4:  		/* mr R5, R29 */
		/* 8210E890h case    4:*/		regs.R5 = regs.R29;
		/* 8210E890h case    4:*/		return 0x8210E894;
		  /* 8210E894h */ case    5:  		/* bl -423228 */
		/* 8210E894h case    5:*/		regs.LR = 0x8210E898; return 0x820A7358;
		/* 8210E894h case    5:*/		return 0x8210E898;
		  /* 8210E898h */ case    6:  		/* li R3, 0 */
		/* 8210E898h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8210E898h case    6:*/		return 0x8210E89C;
		  /* 8210E89Ch */ case    7:  		/* addi R1, R1, 384 */
		/* 8210E89Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x180);
		/* 8210E89Ch case    7:*/		return 0x8210E8A0;
		  /* 8210E8A0h */ case    8:  		/* b -513524 */
		/* 8210E8A0h case    8:*/		return 0x820912AC;
		/* 8210E8A0h case    8:*/		return 0x8210E8A4;
		  /* 8210E8A4h */ case    9:  		/* nop */
		/* 8210E8A4h case    9:*/		cpu::op::nop();
		/* 8210E8A4h case    9:*/		return 0x8210E8A8;
	}
	return 0x8210E8A8;
} // Block from 8210E880h-8210E8A8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8210E8A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E8A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E8A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E8A8);
		  /* 8210E8A8h */ case    0:  		/* mfspr R12, LR */
		/* 8210E8A8h case    0:*/		regs.R12 = regs.LR;
		/* 8210E8A8h case    0:*/		return 0x8210E8AC;
		  /* 8210E8ACh */ case    1:  		/* bl -513652 */
		/* 8210E8ACh case    1:*/		regs.LR = 0x8210E8B0; return 0x82091238;
		/* 8210E8ACh case    1:*/		return 0x8210E8B0;
		  /* 8210E8B0h */ case    2:  		/* stwu R1, <#[R1 - 240]> */
		/* 8210E8B0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 8210E8B0h case    2:*/		return 0x8210E8B4;
		  /* 8210E8B4h */ case    3:  		/* lwz R9, <#[R3 + 4]> */
		/* 8210E8B4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 8210E8B4h case    3:*/		return 0x8210E8B8;
		  /* 8210E8B8h */ case    4:  		/* mr R30, R3 */
		/* 8210E8B8h case    4:*/		regs.R30 = regs.R3;
		/* 8210E8B8h case    4:*/		return 0x8210E8BC;
		  /* 8210E8BCh */ case    5:  		/* li R11, -1 */
		/* 8210E8BCh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 8210E8BCh case    5:*/		return 0x8210E8C0;
		  /* 8210E8C0h */ case    6:  		/* li R20, 0 */
		/* 8210E8C0h case    6:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 8210E8C0h case    6:*/		return 0x8210E8C4;
		  /* 8210E8C4h */ case    7:  		/* li R10, 0 */
		/* 8210E8C4h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210E8C4h case    7:*/		return 0x8210E8C8;
		  /* 8210E8C8h */ case    8:  		/* cmplwi CR6, R9, 0 */
		/* 8210E8C8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8210E8C8h case    8:*/		return 0x8210E8CC;
		  /* 8210E8CCh */ case    9:  		/* bc 4, CR6_GT, 44 */
		/* 8210E8CCh case    9:*/		if ( !regs.CR[6].gt ) { return 0x8210E8F8;  }
		/* 8210E8CCh case    9:*/		return 0x8210E8D0;
		  /* 8210E8D0h */ case   10:  		/* li R9, 0 */
		/* 8210E8D0h case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8210E8D0h case   10:*/		return 0x8210E8D4;
		  /* 8210E8D4h */ case   11:  		/* lwz R8, <#[R30 + 16]> */
		/* 8210E8D4h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000010) );
		/* 8210E8D4h case   11:*/		return 0x8210E8D8;
		  /* 8210E8D8h */ case   12:  		/* addi R10, R10, 1 */
		/* 8210E8D8h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210E8D8h case   12:*/		return 0x8210E8DC;
		  /* 8210E8DCh */ case   13:  		/* lwzx R8, <#[R9 + R8]> */
		/* 8210E8DCh case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 8210E8DCh case   13:*/		return 0x8210E8E0;
		  /* 8210E8E0h */ case   14:  		/* addi R9, R9, 4 */
		/* 8210E8E0h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8210E8E0h case   14:*/		return 0x8210E8E4;
		  /* 8210E8E4h */ case   15:  		/* stw R11, <#[R8 + 40]> */
		/* 8210E8E4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000028) );
		/* 8210E8E4h case   15:*/		return 0x8210E8E8;
		  /* 8210E8E8h */ case   16:  		/* stw R11, <#[R8 + 36]> */
		/* 8210E8E8h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000024) );
		/* 8210E8E8h case   16:*/		return 0x8210E8EC;
		  /* 8210E8ECh */ case   17:  		/* lwz R8, <#[R30 + 4]> */
		/* 8210E8ECh case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000004) );
		/* 8210E8ECh case   17:*/		return 0x8210E8F0;
		  /* 8210E8F0h */ case   18:  		/* cmplw CR6, R10, R8 */
		/* 8210E8F0h case   18:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8210E8F0h case   18:*/		return 0x8210E8F4;
		  /* 8210E8F4h */ case   19:  		/* bc 12, CR6_LT, -32 */
		/* 8210E8F4h case   19:*/		if ( regs.CR[6].lt ) { return 0x8210E8D4;  }
		/* 8210E8F4h case   19:*/		return 0x8210E8F8;
	}
	return 0x8210E8F8;
} // Block from 8210E8A8h-8210E8F8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8210E8F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E8F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E8F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E8F8);
		  /* 8210E8F8h */ case    0:  		/* lwz R10, <#[R30 + 8]> */
		/* 8210E8F8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 8210E8F8h case    0:*/		return 0x8210E8FC;
		  /* 8210E8FCh */ case    1:  		/* li R9, 0 */
		/* 8210E8FCh case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8210E8FCh case    1:*/		return 0x8210E900;
		  /* 8210E900h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 8210E900h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8210E900h case    2:*/		return 0x8210E904;
		  /* 8210E904h */ case    3:  		/* bc 4, CR6_GT, 44 */
		/* 8210E904h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210E930;  }
		/* 8210E904h case    3:*/		return 0x8210E908;
		  /* 8210E908h */ case    4:  		/* li R10, 0 */
		/* 8210E908h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210E908h case    4:*/		return 0x8210E90C;
		  /* 8210E90Ch */ case    5:  		/* lwz R8, <#[R30 + 20]> */
		/* 8210E90Ch case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000014) );
		/* 8210E90Ch case    5:*/		return 0x8210E910;
		  /* 8210E910h */ case    6:  		/* addi R9, R9, 1 */
		/* 8210E910h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8210E910h case    6:*/		return 0x8210E914;
		  /* 8210E914h */ case    7:  		/* lwzx R8, <#[R10 + R8]> */
		/* 8210E914h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 8210E914h case    7:*/		return 0x8210E918;
		  /* 8210E918h */ case    8:  		/* addi R10, R10, 4 */
		/* 8210E918h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210E918h case    8:*/		return 0x8210E91C;
		  /* 8210E91Ch */ case    9:  		/* stw R11, <#[R8 + 84]> */
		/* 8210E91Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000054) );
		/* 8210E91Ch case    9:*/		return 0x8210E920;
		  /* 8210E920h */ case   10:  		/* stw R11, <#[R8 + 72]> */
		/* 8210E920h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000048) );
		/* 8210E920h case   10:*/		return 0x8210E924;
		  /* 8210E924h */ case   11:  		/* lwz R8, <#[R30 + 8]> */
		/* 8210E924h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000008) );
		/* 8210E924h case   11:*/		return 0x8210E928;
		  /* 8210E928h */ case   12:  		/* cmplw CR6, R9, R8 */
		/* 8210E928h case   12:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 8210E928h case   12:*/		return 0x8210E92C;
		  /* 8210E92Ch */ case   13:  		/* bc 12, CR6_LT, -32 */
		/* 8210E92Ch case   13:*/		if ( regs.CR[6].lt ) { return 0x8210E90C;  }
		/* 8210E92Ch case   13:*/		return 0x8210E930;
	}
	return 0x8210E930;
} // Block from 8210E8F8h-8210E930h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8210E930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E930);
		  /* 8210E930h */ case    0:  		/* lwz R10, <#[R30 + 12]> */
		/* 8210E930h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000000C) );
		/* 8210E930h case    0:*/		return 0x8210E934;
		  /* 8210E934h */ case    1:  		/* li R11, 0 */
		/* 8210E934h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210E934h case    1:*/		return 0x8210E938;
		  /* 8210E938h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 8210E938h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8210E938h case    2:*/		return 0x8210E93C;
		  /* 8210E93Ch */ case    3:  		/* bc 4, CR6_GT, 548 */
		/* 8210E93Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210EB60;  }
		/* 8210E93Ch case    3:*/		return 0x8210E940;
		  /* 8210E940h */ case    4:  		/* li R4, 0 */
		/* 8210E940h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8210E940h case    4:*/		return 0x8210E944;
		  /* 8210E944h */ case    5:  		/* lwz R10, <#[R30 + 24]> */
		/* 8210E944h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000018) );
		/* 8210E944h case    5:*/		return 0x8210E948;
		  /* 8210E948h */ case    6:  		/* lwzx R5, <#[R4 + R10]> */
		/* 8210E948h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R4 + regs.R10 + 0x00000000) );
		/* 8210E948h case    6:*/		return 0x8210E94C;
		  /* 8210E94Ch */ case    7:  		/* lwz R10, <#[R5]> */
		/* 8210E94Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 8210E94Ch case    7:*/		return 0x8210E950;
		  /* 8210E950h */ case    8:  		/* rlwinm. R10, R10, 0, 0, 11 */
		/* 8210E950h case    8:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R10,regs.R10);
		/* 8210E950h case    8:*/		return 0x8210E954;
		  /* 8210E954h */ case    9:  		/* bc 12, CR0_EQ, 504 */
		/* 8210E954h case    9:*/		if ( regs.CR[0].eq ) { return 0x8210EB4C;  }
		/* 8210E954h case    9:*/		return 0x8210E958;
		  /* 8210E958h */ case   10:  		/* lwz R10, <#[R5 + 4]> */
		/* 8210E958h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000004) );
		/* 8210E958h case   10:*/		return 0x8210E95C;
		  /* 8210E95Ch */ case   11:  		/* li R6, 0 */
		/* 8210E95Ch case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8210E95Ch case   11:*/		return 0x8210E960;
		  /* 8210E960h */ case   12:  		/* cmplwi CR6, R10, 0 */
		/* 8210E960h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8210E960h case   12:*/		return 0x8210E964;
		  /* 8210E964h */ case   13:  		/* bc 4, CR6_GT, 220 */
		/* 8210E964h case   13:*/		if ( !regs.CR[6].gt ) { return 0x8210EA40;  }
		/* 8210E964h case   13:*/		return 0x8210E968;
		  /* 8210E968h */ case   14:  		/* li R7, 0 */
		/* 8210E968h case   14:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8210E968h case   14:*/		return 0x8210E96C;
		  /* 8210E96Ch */ case   15:  		/* lwz R10, <#[R5 + 8]> */
		/* 8210E96Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000008) );
		/* 8210E96Ch case   15:*/		return 0x8210E970;
		  /* 8210E970h */ case   16:  		/* lwz R9, <#[R30 + 20]> */
		/* 8210E970h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 8210E970h case   16:*/		return 0x8210E974;
		  /* 8210E974h */ case   17:  		/* lwzx R10, <#[R7 + R10]> */
		/* 8210E974h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 8210E974h case   17:*/		return 0x8210E978;
		  /* 8210E978h */ case   18:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210E978h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210E978h case   18:*/		return 0x8210E97C;
		  /* 8210E97Ch */ case   19:  		/* lwzx R8, <#[R10 + R9]> */
		/* 8210E97Ch case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210E97Ch case   19:*/		return 0x8210E980;
		  /* 8210E980h */ case   20:  		/* lwz R10, <#[R8 + 84]> */
		/* 8210E980h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000054) );
		/* 8210E980h case   20:*/		return 0x8210E984;
		  /* 8210E984h */ case   21:  		/* cmplw CR6, R11, R10 */
		/* 8210E984h case   21:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210E984h case   21:*/		return 0x8210E988;
		  /* 8210E988h */ case   22:  		/* bc 4, CR6_LT, 8 */
		/* 8210E988h case   22:*/		if ( !regs.CR[6].lt ) { return 0x8210E990;  }
		/* 8210E988h case   22:*/		return 0x8210E98C;
		  /* 8210E98Ch */ case   23:  		/* stw R11, <#[R8 + 84]> */
		/* 8210E98Ch case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000054) );
		/* 8210E98Ch case   23:*/		return 0x8210E990;
	}
	return 0x8210E990;
} // Block from 8210E930h-8210E990h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8210E990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E990);
		  /* 8210E990h */ case    0:  		/* addi R9, R8, 8 */
		/* 8210E990h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R8,0x8);
		/* 8210E990h case    0:*/		return 0x8210E994;
		  /* 8210E994h */ case    1:  		/* mr R10, R8 */
		/* 8210E994h case    1:*/		regs.R10 = regs.R8;
		/* 8210E994h case    1:*/		return 0x8210E998;
		  /* 8210E998h */ case    2:  		/* lwz R3, <#[R9]> */
		/* 8210E998h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R9 + 0x00000000) );
		/* 8210E998h case    2:*/		return 0x8210E99C;
		  /* 8210E99Ch */ case    3:  		/* b 76 */
		/* 8210E99Ch case    3:*/		return 0x8210E9E8;
		/* 8210E99Ch case    3:*/		return 0x8210E9A0;
		  /* 8210E9A0h */ case    4:  		/* lwz R10, <#[R10 + 4]> */
		/* 8210E9A0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8210E9A0h case    4:*/		return 0x8210E9A4;
		  /* 8210E9A4h */ case    5:  		/* lwz R3, <#[R30 + 16]> */
		/* 8210E9A4h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000010) );
		/* 8210E9A4h case    5:*/		return 0x8210E9A8;
		  /* 8210E9A8h */ case    6:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210E9A8h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210E9A8h case    6:*/		return 0x8210E9AC;
		  /* 8210E9ACh */ case    7:  		/* lwzx R10, <#[R10 + R3]> */
		/* 8210E9ACh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 8210E9ACh case    7:*/		return 0x8210E9B0;
		  /* 8210E9B0h */ case    8:  		/* lwz R3, <#[R10 + 40]> */
		/* 8210E9B0h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x00000028) );
		/* 8210E9B0h case    8:*/		return 0x8210E9B4;
		  /* 8210E9B4h */ case    9:  		/* cmplw CR6, R11, R3 */
		/* 8210E9B4h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R3);
		/* 8210E9B4h case    9:*/		return 0x8210E9B8;
		  /* 8210E9B8h */ case   10:  		/* bc 4, CR6_LT, 8 */
		/* 8210E9B8h case   10:*/		if ( !regs.CR[6].lt ) { return 0x8210E9C0;  }
		/* 8210E9B8h case   10:*/		return 0x8210E9BC;
		  /* 8210E9BCh */ case   11:  		/* stw R11, <#[R10 + 40]> */
		/* 8210E9BCh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000028) );
		/* 8210E9BCh case   11:*/		return 0x8210E9C0;
	}
	return 0x8210E9C0;
} // Block from 8210E990h-8210E9C0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8210E9C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E9C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E9C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E9C0);
		  /* 8210E9C0h */ case    0:  		/* lwz R10, <#[R9]> */
		/* 8210E9C0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8210E9C0h case    0:*/		return 0x8210E9C4;
		  /* 8210E9C4h */ case    1:  		/* lwz R9, <#[R30 + 20]> */
		/* 8210E9C4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 8210E9C4h case    1:*/		return 0x8210E9C8;
		  /* 8210E9C8h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210E9C8h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210E9C8h case    2:*/		return 0x8210E9CC;
		  /* 8210E9CCh */ case    3:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210E9CCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210E9CCh case    3:*/		return 0x8210E9D0;
		  /* 8210E9D0h */ case    4:  		/* lwz R9, <#[R10 + 84]> */
		/* 8210E9D0h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000054) );
		/* 8210E9D0h case    4:*/		return 0x8210E9D4;
		  /* 8210E9D4h */ case    5:  		/* cmplw CR6, R11, R9 */
		/* 8210E9D4h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210E9D4h case    5:*/		return 0x8210E9D8;
		  /* 8210E9D8h */ case    6:  		/* bc 4, CR6_LT, 8 */
		/* 8210E9D8h case    6:*/		if ( !regs.CR[6].lt ) { return 0x8210E9E0;  }
		/* 8210E9D8h case    6:*/		return 0x8210E9DC;
		  /* 8210E9DCh */ case    7:  		/* stw R11, <#[R10 + 84]> */
		/* 8210E9DCh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000054) );
		/* 8210E9DCh case    7:*/		return 0x8210E9E0;
	}
	return 0x8210E9E0;
} // Block from 8210E9C0h-8210E9E0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8210E9E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E9E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E9E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E9E0);
		  /* 8210E9E0h */ case    0:  		/* lwz R3, <#[R10 + 8]> */
		/* 8210E9E0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x00000008) );
		/* 8210E9E0h case    0:*/		return 0x8210E9E4;
		  /* 8210E9E4h */ case    1:  		/* addi R9, R10, 8 */
		/* 8210E9E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x8);
		/* 8210E9E4h case    1:*/		return 0x8210E9E8;
	}
	return 0x8210E9E8;
} // Block from 8210E9E0h-8210E9E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210E9E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210E9E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210E9E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210E9E8);
		  /* 8210E9E8h */ case    0:  		/* cmpwi CR6, R3, -1 */
		/* 8210E9E8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8210E9E8h case    0:*/		return 0x8210E9EC;
		  /* 8210E9ECh */ case    1:  		/* bc 4, CR6_EQ, -76 */
		/* 8210E9ECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210E9A0;  }
		/* 8210E9ECh case    1:*/		return 0x8210E9F0;
		  /* 8210E9F0h */ case    2:  		/* lwz R9, <#[R8 + 20]> */
		/* 8210E9F0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000014) );
		/* 8210E9F0h case    2:*/		return 0x8210E9F4;
		  /* 8210E9F4h */ case    3:  		/* addi R10, R8, 20 */
		/* 8210E9F4h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R8,0x14);
		/* 8210E9F4h case    3:*/		return 0x8210E9F8;
		  /* 8210E9F8h */ case    4:  		/* b 44 */
		/* 8210E9F8h case    4:*/		return 0x8210EA24;
		/* 8210E9F8h case    4:*/		return 0x8210E9FC;
		  /* 8210E9FCh */ case    5:  		/* lwz R10, <#[R10]> */
		/* 8210E9FCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 8210E9FCh case    5:*/		return 0x8210EA00;
		  /* 8210EA00h */ case    6:  		/* lwz R9, <#[R30 + 20]> */
		/* 8210EA00h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 8210EA00h case    6:*/		return 0x8210EA04;
		  /* 8210EA04h */ case    7:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210EA04h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210EA04h case    7:*/		return 0x8210EA08;
		  /* 8210EA08h */ case    8:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210EA08h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210EA08h case    8:*/		return 0x8210EA0C;
		  /* 8210EA0Ch */ case    9:  		/* lwz R9, <#[R10 + 84]> */
		/* 8210EA0Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000054) );
		/* 8210EA0Ch case    9:*/		return 0x8210EA10;
		  /* 8210EA10h */ case   10:  		/* cmplw CR6, R11, R9 */
		/* 8210EA10h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210EA10h case   10:*/		return 0x8210EA14;
		  /* 8210EA14h */ case   11:  		/* bc 4, CR6_LT, 8 */
		/* 8210EA14h case   11:*/		if ( !regs.CR[6].lt ) { return 0x8210EA1C;  }
		/* 8210EA14h case   11:*/		return 0x8210EA18;
		  /* 8210EA18h */ case   12:  		/* stw R11, <#[R10 + 84]> */
		/* 8210EA18h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000054) );
		/* 8210EA18h case   12:*/		return 0x8210EA1C;
	}
	return 0x8210EA1C;
} // Block from 8210E9E8h-8210EA1Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8210EA1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EA1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EA1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EA1C);
		  /* 8210EA1Ch */ case    0:  		/* addi R10, R10, 20 */
		/* 8210EA1Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x14);
		/* 8210EA1Ch case    0:*/		return 0x8210EA20;
		  /* 8210EA20h */ case    1:  		/* lwz R9, <#[R10]> */
		/* 8210EA20h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8210EA20h case    1:*/		return 0x8210EA24;
	}
	return 0x8210EA24;
} // Block from 8210EA1Ch-8210EA24h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210EA24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EA24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EA24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EA24);
		  /* 8210EA24h */ case    0:  		/* cmpwi CR6, R9, -1 */
		/* 8210EA24h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 8210EA24h case    0:*/		return 0x8210EA28;
		  /* 8210EA28h */ case    1:  		/* bc 4, CR6_EQ, -44 */
		/* 8210EA28h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210E9FC;  }
		/* 8210EA28h case    1:*/		return 0x8210EA2C;
		  /* 8210EA2Ch */ case    2:  		/* lwz R10, <#[R5 + 4]> */
		/* 8210EA2Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000004) );
		/* 8210EA2Ch case    2:*/		return 0x8210EA30;
		  /* 8210EA30h */ case    3:  		/* addi R6, R6, 1 */
		/* 8210EA30h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8210EA30h case    3:*/		return 0x8210EA34;
		  /* 8210EA34h */ case    4:  		/* addi R7, R7, 4 */
		/* 8210EA34h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 8210EA34h case    4:*/		return 0x8210EA38;
		  /* 8210EA38h */ case    5:  		/* cmplw CR6, R6, R10 */
		/* 8210EA38h case    5:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 8210EA38h case    5:*/		return 0x8210EA3C;
		  /* 8210EA3Ch */ case    6:  		/* bc 12, CR6_LT, -208 */
		/* 8210EA3Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x8210E96C;  }
		/* 8210EA3Ch case    6:*/		return 0x8210EA40;
	}
	return 0x8210EA40;
} // Block from 8210EA24h-8210EA40h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210EA40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EA40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EA40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EA40);
		  /* 8210EA40h */ case    0:  		/* lwz R10, <#[R5 + 12]> */
		/* 8210EA40h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x0000000C) );
		/* 8210EA40h case    0:*/		return 0x8210EA44;
		  /* 8210EA44h */ case    1:  		/* li R6, 0 */
		/* 8210EA44h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8210EA44h case    1:*/		return 0x8210EA48;
		  /* 8210EA48h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 8210EA48h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8210EA48h case    2:*/		return 0x8210EA4C;
		  /* 8210EA4Ch */ case    3:  		/* bc 4, CR6_GT, 256 */
		/* 8210EA4Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210EB4C;  }
		/* 8210EA4Ch case    3:*/		return 0x8210EA50;
		  /* 8210EA50h */ case    4:  		/* li R7, 0 */
		/* 8210EA50h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8210EA50h case    4:*/		return 0x8210EA54;
		  /* 8210EA54h */ case    5:  		/* lwz R10, <#[R5 + 16]> */
		/* 8210EA54h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000010) );
		/* 8210EA54h case    5:*/		return 0x8210EA58;
		  /* 8210EA58h */ case    6:  		/* lwz R9, <#[R30 + 20]> */
		/* 8210EA58h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 8210EA58h case    6:*/		return 0x8210EA5C;
		  /* 8210EA5Ch */ case    7:  		/* lwzx R10, <#[R7 + R10]> */
		/* 8210EA5Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 8210EA5Ch case    7:*/		return 0x8210EA60;
		  /* 8210EA60h */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210EA60h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210EA60h case    8:*/		return 0x8210EA64;
		  /* 8210EA64h */ case    9:  		/* lwzx R8, <#[R10 + R9]> */
		/* 8210EA64h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210EA64h case    9:*/		return 0x8210EA68;
		  /* 8210EA68h */ case   10:  		/* lwz R10, <#[R8 + 72]> */
		/* 8210EA68h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000048) );
		/* 8210EA68h case   10:*/		return 0x8210EA6C;
		  /* 8210EA6Ch */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 8210EA6Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210EA6Ch case   11:*/		return 0x8210EA70;
		  /* 8210EA70h */ case   12:  		/* bc 4, CR6_LT, 8 */
		/* 8210EA70h case   12:*/		if ( !regs.CR[6].lt ) { return 0x8210EA78;  }
		/* 8210EA70h case   12:*/		return 0x8210EA74;
		  /* 8210EA74h */ case   13:  		/* stw R11, <#[R8 + 72]> */
		/* 8210EA74h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000048) );
		/* 8210EA74h case   13:*/		return 0x8210EA78;
	}
	return 0x8210EA78;
} // Block from 8210EA40h-8210EA78h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8210EA78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EA78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EA78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EA78);
		  /* 8210EA78h */ case    0:  		/* lwz R9, <#[R8 + 8]> */
		/* 8210EA78h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000008) );
		/* 8210EA78h case    0:*/		return 0x8210EA7C;
		  /* 8210EA7Ch */ case    1:  		/* mr R10, R8 */
		/* 8210EA7Ch case    1:*/		regs.R10 = regs.R8;
		/* 8210EA7Ch case    1:*/		return 0x8210EA80;
		  /* 8210EA80h */ case    2:  		/* cmpwi CR6, R9, -1 */
		/* 8210EA80h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 8210EA80h case    2:*/		return 0x8210EA84;
		  /* 8210EA84h */ case    3:  		/* bc 12, CR6_EQ, 108 */
		/* 8210EA84h case    3:*/		if ( regs.CR[6].eq ) { return 0x8210EAF0;  }
		/* 8210EA84h case    3:*/		return 0x8210EA88;
		  /* 8210EA88h */ case    4:  		/* lwz R10, <#[R8 + 4]> */
		/* 8210EA88h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000004) );
		/* 8210EA88h case    4:*/		return 0x8210EA8C;
		  /* 8210EA8Ch */ case    5:  		/* lwz R9, <#[R30 + 16]> */
		/* 8210EA8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000010) );
		/* 8210EA8Ch case    5:*/		return 0x8210EA90;
		  /* 8210EA90h */ case    6:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210EA90h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210EA90h case    6:*/		return 0x8210EA94;
		  /* 8210EA94h */ case    7:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210EA94h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210EA94h case    7:*/		return 0x8210EA98;
		  /* 8210EA98h */ case    8:  		/* lwz R9, <#[R10 + 36]> */
		/* 8210EA98h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000024) );
		/* 8210EA98h case    8:*/		return 0x8210EA9C;
		  /* 8210EA9Ch */ case    9:  		/* cmplw CR6, R11, R9 */
		/* 8210EA9Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210EA9Ch case    9:*/		return 0x8210EAA0;
		  /* 8210EAA0h */ case   10:  		/* bc 4, CR6_LT, 8 */
		/* 8210EAA0h case   10:*/		if ( !regs.CR[6].lt ) { return 0x8210EAA8;  }
		/* 8210EAA0h case   10:*/		return 0x8210EAA4;
		  /* 8210EAA4h */ case   11:  		/* stw R11, <#[R10 + 36]> */
		/* 8210EAA4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000024) );
		/* 8210EAA4h case   11:*/		return 0x8210EAA8;
	}
	return 0x8210EAA8;
} // Block from 8210EA78h-8210EAA8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8210EAA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EAA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EAA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EAA8);
		  /* 8210EAA8h */ case    0:  		/* lwz R10, <#[R8 + 8]> */
		/* 8210EAA8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000008) );
		/* 8210EAA8h case    0:*/		return 0x8210EAAC;
		  /* 8210EAACh */ case    1:  		/* b 40 */
		/* 8210EAACh case    1:*/		return 0x8210EAD4;
		/* 8210EAACh case    1:*/		return 0x8210EAB0;
		  /* 8210EAB0h */ case    2:  		/* lwz R9, <#[R10 + 4]> */
		/* 8210EAB0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 8210EAB0h case    2:*/		return 0x8210EAB4;
		  /* 8210EAB4h */ case    3:  		/* lwz R3, <#[R30 + 16]> */
		/* 8210EAB4h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000010) );
		/* 8210EAB4h case    3:*/		return 0x8210EAB8;
		  /* 8210EAB8h */ case    4:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210EAB8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210EAB8h case    4:*/		return 0x8210EABC;
		  /* 8210EABCh */ case    5:  		/* lwzx R9, <#[R9 + R3]> */
		/* 8210EABCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8210EABCh case    5:*/		return 0x8210EAC0;
		  /* 8210EAC0h */ case    6:  		/* lwz R3, <#[R9 + 40]> */
		/* 8210EAC0h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R9 + 0x00000028) );
		/* 8210EAC0h case    6:*/		return 0x8210EAC4;
		  /* 8210EAC4h */ case    7:  		/* cmplw CR6, R11, R3 */
		/* 8210EAC4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R3);
		/* 8210EAC4h case    7:*/		return 0x8210EAC8;
		  /* 8210EAC8h */ case    8:  		/* bc 4, CR6_LT, 8 */
		/* 8210EAC8h case    8:*/		if ( !regs.CR[6].lt ) { return 0x8210EAD0;  }
		/* 8210EAC8h case    8:*/		return 0x8210EACC;
		  /* 8210EACCh */ case    9:  		/* stw R11, <#[R9 + 40]> */
		/* 8210EACCh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000028) );
		/* 8210EACCh case    9:*/		return 0x8210EAD0;
	}
	return 0x8210EAD0;
} // Block from 8210EAA8h-8210EAD0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8210EAD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EAD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EAD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EAD0);
		  /* 8210EAD0h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 8210EAD0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8210EAD0h case    0:*/		return 0x8210EAD4;
	}
	return 0x8210EAD4;
} // Block from 8210EAD0h-8210EAD4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210EAD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EAD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EAD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EAD4);
		  /* 8210EAD4h */ case    0:  		/* lwz R9, <#[R30 + 20]> */
		/* 8210EAD4h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 8210EAD4h case    0:*/		return 0x8210EAD8;
		  /* 8210EAD8h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210EAD8h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210EAD8h case    1:*/		return 0x8210EADC;
		  /* 8210EADCh */ case    2:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210EADCh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210EADCh case    2:*/		return 0x8210EAE0;
		  /* 8210EAE0h */ case    3:  		/* lwz R9, <#[R10 + 84]> */
		/* 8210EAE0h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000054) );
		/* 8210EAE0h case    3:*/		return 0x8210EAE4;
		  /* 8210EAE4h */ case    4:  		/* cmplw CR6, R11, R9 */
		/* 8210EAE4h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210EAE4h case    4:*/		return 0x8210EAE8;
		  /* 8210EAE8h */ case    5:  		/* bc 4, CR6_LT, 8 */
		/* 8210EAE8h case    5:*/		if ( !regs.CR[6].lt ) { return 0x8210EAF0;  }
		/* 8210EAE8h case    5:*/		return 0x8210EAEC;
		  /* 8210EAECh */ case    6:  		/* stw R11, <#[R10 + 84]> */
		/* 8210EAECh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000054) );
		/* 8210EAECh case    6:*/		return 0x8210EAF0;
	}
	return 0x8210EAF0;
} // Block from 8210EAD4h-8210EAF0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210EAF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EAF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EAF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EAF0);
		  /* 8210EAF0h */ case    0:  		/* lwz R9, <#[R10 + 8]> */
		/* 8210EAF0h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 8210EAF0h case    0:*/		return 0x8210EAF4;
		  /* 8210EAF4h */ case    1:  		/* cmpwi CR6, R9, -1 */
		/* 8210EAF4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 8210EAF4h case    1:*/		return 0x8210EAF8;
		  /* 8210EAF8h */ case    2:  		/* bc 4, CR6_EQ, -72 */
		/* 8210EAF8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8210EAB0;  }
		/* 8210EAF8h case    2:*/		return 0x8210EAFC;
		  /* 8210EAFCh */ case    3:  		/* lwz R9, <#[R8 + 20]> */
		/* 8210EAFCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000014) );
		/* 8210EAFCh case    3:*/		return 0x8210EB00;
		  /* 8210EB00h */ case    4:  		/* addi R10, R8, 20 */
		/* 8210EB00h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R8,0x14);
		/* 8210EB00h case    4:*/		return 0x8210EB04;
		  /* 8210EB04h */ case    5:  		/* b 44 */
		/* 8210EB04h case    5:*/		return 0x8210EB30;
		/* 8210EB04h case    5:*/		return 0x8210EB08;
		  /* 8210EB08h */ case    6:  		/* lwz R10, <#[R10]> */
		/* 8210EB08h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 8210EB08h case    6:*/		return 0x8210EB0C;
		  /* 8210EB0Ch */ case    7:  		/* lwz R9, <#[R30 + 20]> */
		/* 8210EB0Ch case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 8210EB0Ch case    7:*/		return 0x8210EB10;
		  /* 8210EB10h */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210EB10h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210EB10h case    8:*/		return 0x8210EB14;
		  /* 8210EB14h */ case    9:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210EB14h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210EB14h case    9:*/		return 0x8210EB18;
		  /* 8210EB18h */ case   10:  		/* lwz R9, <#[R10 + 84]> */
		/* 8210EB18h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000054) );
		/* 8210EB18h case   10:*/		return 0x8210EB1C;
		  /* 8210EB1Ch */ case   11:  		/* cmplw CR6, R11, R9 */
		/* 8210EB1Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210EB1Ch case   11:*/		return 0x8210EB20;
		  /* 8210EB20h */ case   12:  		/* bc 4, CR6_LT, 8 */
		/* 8210EB20h case   12:*/		if ( !regs.CR[6].lt ) { return 0x8210EB28;  }
		/* 8210EB20h case   12:*/		return 0x8210EB24;
		  /* 8210EB24h */ case   13:  		/* stw R11, <#[R10 + 84]> */
		/* 8210EB24h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000054) );
		/* 8210EB24h case   13:*/		return 0x8210EB28;
	}
	return 0x8210EB28;
} // Block from 8210EAF0h-8210EB28h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8210EB28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EB28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EB28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EB28);
		  /* 8210EB28h */ case    0:  		/* addi R10, R10, 20 */
		/* 8210EB28h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x14);
		/* 8210EB28h case    0:*/		return 0x8210EB2C;
		  /* 8210EB2Ch */ case    1:  		/* lwz R9, <#[R10]> */
		/* 8210EB2Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8210EB2Ch case    1:*/		return 0x8210EB30;
	}
	return 0x8210EB30;
} // Block from 8210EB28h-8210EB30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210EB30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EB30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EB30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EB30);
		  /* 8210EB30h */ case    0:  		/* cmpwi CR6, R9, -1 */
		/* 8210EB30h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 8210EB30h case    0:*/		return 0x8210EB34;
		  /* 8210EB34h */ case    1:  		/* bc 4, CR6_EQ, -44 */
		/* 8210EB34h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210EB08;  }
		/* 8210EB34h case    1:*/		return 0x8210EB38;
		  /* 8210EB38h */ case    2:  		/* lwz R10, <#[R5 + 12]> */
		/* 8210EB38h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x0000000C) );
		/* 8210EB38h case    2:*/		return 0x8210EB3C;
		  /* 8210EB3Ch */ case    3:  		/* addi R6, R6, 1 */
		/* 8210EB3Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8210EB3Ch case    3:*/		return 0x8210EB40;
		  /* 8210EB40h */ case    4:  		/* addi R7, R7, 4 */
		/* 8210EB40h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 8210EB40h case    4:*/		return 0x8210EB44;
		  /* 8210EB44h */ case    5:  		/* cmplw CR6, R6, R10 */
		/* 8210EB44h case    5:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 8210EB44h case    5:*/		return 0x8210EB48;
		  /* 8210EB48h */ case    6:  		/* bc 12, CR6_LT, -244 */
		/* 8210EB48h case    6:*/		if ( regs.CR[6].lt ) { return 0x8210EA54;  }
		/* 8210EB48h case    6:*/		return 0x8210EB4C;
	}
	return 0x8210EB4C;
} // Block from 8210EB30h-8210EB4Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210EB4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EB4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EB4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EB4C);
		  /* 8210EB4Ch */ case    0:  		/* lwz R10, <#[R30 + 12]> */
		/* 8210EB4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000000C) );
		/* 8210EB4Ch case    0:*/		return 0x8210EB50;
		  /* 8210EB50h */ case    1:  		/* addi R11, R11, 1 */
		/* 8210EB50h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210EB50h case    1:*/		return 0x8210EB54;
		  /* 8210EB54h */ case    2:  		/* addi R4, R4, 4 */
		/* 8210EB54h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 8210EB54h case    2:*/		return 0x8210EB58;
		  /* 8210EB58h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 8210EB58h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210EB58h case    3:*/		return 0x8210EB5C;
		  /* 8210EB5Ch */ case    4:  		/* bc 12, CR6_LT, -536 */
		/* 8210EB5Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x8210E944;  }
		/* 8210EB5Ch case    4:*/		return 0x8210EB60;
	}
	return 0x8210EB60;
} // Block from 8210EB4Ch-8210EB60h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210EB60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EB60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EB60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EB60);
		  /* 8210EB60h */ case    0:  		/* mr R3, R30 */
		/* 8210EB60h case    0:*/		regs.R3 = regs.R30;
		/* 8210EB60h case    0:*/		return 0x8210EB64;
		  /* 8210EB64h */ case    1:  		/* bl -55316 */
		/* 8210EB64h case    1:*/		regs.LR = 0x8210EB68; return 0x82101350;
		/* 8210EB64h case    1:*/		return 0x8210EB68;
		  /* 8210EB68h */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 8210EB68h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8210EB68h case    2:*/		return 0x8210EB6C;
		  /* 8210EB6Ch */ case    3:  		/* li R29, 0 */
		/* 8210EB6Ch case    3:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8210EB6Ch case    3:*/		return 0x8210EB70;
		  /* 8210EB70h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8210EB70h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210EB70h case    4:*/		return 0x8210EB74;
		  /* 8210EB74h */ case    5:  		/* bc 4, CR6_GT, 596 */
		/* 8210EB74h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8210EDC8;  }
		/* 8210EB74h case    5:*/		return 0x8210EB78;
		  /* 8210EB78h */ case    6:  		/* lis R6, -32254 */
		/* 8210EB78h case    6:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8202);
		/* 8210EB78h case    6:*/		return 0x8210EB7C;
		  /* 8210EB7Ch */ case    7:  		/* lis R5, -32254 */
		/* 8210EB7Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8202);
		/* 8210EB7Ch case    7:*/		return 0x8210EB80;
		  /* 8210EB80h */ case    8:  		/* lis R7, -32254 */
		/* 8210EB80h case    8:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8202);
		/* 8210EB80h case    8:*/		return 0x8210EB84;
		  /* 8210EB84h */ case    9:  		/* lis R8, -32254 */
		/* 8210EB84h case    9:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8202);
		/* 8210EB84h case    9:*/		return 0x8210EB88;
		  /* 8210EB88h */ case   10:  		/* lis R9, -32254 */
		/* 8210EB88h case   10:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8202);
		/* 8210EB88h case   10:*/		return 0x8210EB8C;
		  /* 8210EB8Ch */ case   11:  		/* lis R10, -32254 */
		/* 8210EB8Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 8210EB8Ch case   11:*/		return 0x8210EB90;
		  /* 8210EB90h */ case   12:  		/* lis R11, -32254 */
		/* 8210EB90h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 8210EB90h case   12:*/		return 0x8210EB94;
		  /* 8210EB94h */ case   13:  		/* li R21, 0 */
		/* 8210EB94h case   13:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 8210EB94h case   13:*/		return 0x8210EB98;
		  /* 8210EB98h */ case   14:  		/* addi R22, R6, -13928 */
		/* 8210EB98h case   14:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R6,0xFFFFC998);
		/* 8210EB98h case   14:*/		return 0x8210EB9C;
		  /* 8210EB9Ch */ case   15:  		/* addi R24, R5, -13980 */
		/* 8210EB9Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R5,0xFFFFC964);
		/* 8210EB9Ch case   15:*/		return 0x8210EBA0;
		  /* 8210EBA0h */ case   16:  		/* addi R26, R7, -14036 */
		/* 8210EBA0h case   16:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R7,0xFFFFC92C);
		/* 8210EBA0h case   16:*/		return 0x8210EBA4;
		  /* 8210EBA4h */ case   17:  		/* addi R28, R8, -14096 */
		/* 8210EBA4h case   17:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R8,0xFFFFC8F0);
		/* 8210EBA4h case   17:*/		return 0x8210EBA8;
		  /* 8210EBA8h */ case   18:  		/* addi R25, R9, -14156 */
		/* 8210EBA8h case   18:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R9,0xFFFFC8B4);
		/* 8210EBA8h case   18:*/		return 0x8210EBAC;
		  /* 8210EBACh */ case   19:  		/* addi R23, R10, -14232 */
		/* 8210EBACh case   19:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R10,0xFFFFC868);
		/* 8210EBACh case   19:*/		return 0x8210EBB0;
		  /* 8210EBB0h */ case   20:  		/* addi R27, R11, -14296 */
		/* 8210EBB0h case   20:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFFC828);
		/* 8210EBB0h case   20:*/		return 0x8210EBB4;
		  /* 8210EBB4h */ case   21:  		/* lwz R11, <#[R30 + 20]> */
		/* 8210EBB4h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 8210EBB4h case   21:*/		return 0x8210EBB8;
		  /* 8210EBB8h */ case   22:  		/* lwz R10, <#[R30 + 16]> */
		/* 8210EBB8h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 8210EBB8h case   22:*/		return 0x8210EBBC;
		  /* 8210EBBCh */ case   23:  		/* lwzx R31, <#[R11 + R21]> */
		/* 8210EBBCh case   23:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R21 + 0x00000000) );
		/* 8210EBBCh case   23:*/		return 0x8210EBC0;
		  /* 8210EBC0h */ case   24:  		/* lwz R11, <#[R31 + 4]> */
		/* 8210EBC0h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8210EBC0h case   24:*/		return 0x8210EBC4;
		  /* 8210EBC4h */ case   25:  		/* lwz R9, <#[R31 + 84]> */
		/* 8210EBC4h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000054) );
		/* 8210EBC4h case   25:*/		return 0x8210EBC8;
		  /* 8210EBC8h */ case   26:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210EBC8h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210EBC8h case   26:*/		return 0x8210EBCC;
		  /* 8210EBCCh */ case   27:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210EBCCh case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210EBCCh case   27:*/		return 0x8210EBD0;
		  /* 8210EBD0h */ case   28:  		/* lwz R10, <#[R11 + 40]> */
		/* 8210EBD0h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000028) );
		/* 8210EBD0h case   28:*/		return 0x8210EBD4;
		  /* 8210EBD4h */ case   29:  		/* cmplw CR6, R10, R9 */
		/* 8210EBD4h case   29:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8210EBD4h case   29:*/		return 0x8210EBD8;
		  /* 8210EBD8h */ case   30:  		/* bc 4, CR6_LT, 8 */
		/* 8210EBD8h case   30:*/		if ( !regs.CR[6].lt ) { return 0x8210EBE0;  }
		/* 8210EBD8h case   30:*/		return 0x8210EBDC;
		  /* 8210EBDCh */ case   31:  		/* stw R10, <#[R31 + 84]> */
		/* 8210EBDCh case   31:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000054) );
		/* 8210EBDCh case   31:*/		return 0x8210EBE0;
	}
	return 0x8210EBE0;
} // Block from 8210EB60h-8210EBE0h (32 instructions)

//////////////////////////////////////////////////////
// Block at 8210EBE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EBE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EBE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EBE0);
		  /* 8210EBE0h */ case    0:  		/* lwz R10, <#[R11 + 36]> */
		/* 8210EBE0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000024) );
		/* 8210EBE0h case    0:*/		return 0x8210EBE4;
		  /* 8210EBE4h */ case    1:  		/* lwz R9, <#[R31 + 72]> */
		/* 8210EBE4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000048) );
		/* 8210EBE4h case    1:*/		return 0x8210EBE8;
		  /* 8210EBE8h */ case    2:  		/* cmplw CR6, R10, R9 */
		/* 8210EBE8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8210EBE8h case    2:*/		return 0x8210EBEC;
		  /* 8210EBECh */ case    3:  		/* bc 4, CR6_LT, 8 */
		/* 8210EBECh case    3:*/		if ( !regs.CR[6].lt ) { return 0x8210EBF4;  }
		/* 8210EBECh case    3:*/		return 0x8210EBF0;
		  /* 8210EBF0h */ case    4:  		/* stw R10, <#[R31 + 72]> */
		/* 8210EBF0h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000048) );
		/* 8210EBF0h case    4:*/		return 0x8210EBF4;
	}
	return 0x8210EBF4;
} // Block from 8210EBE0h-8210EBF4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210EBF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EBF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EBF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EBF4);
		  /* 8210EBF4h */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 8210EBF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8210EBF4h case    0:*/		return 0x8210EBF8;
		  /* 8210EBF8h */ case    1:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 8210EBF8h case    1:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 8210EBF8h case    1:*/		return 0x8210EBFC;
		  /* 8210EBFCh */ case    2:  		/* bc 4, CR0_EQ, 144 */
		/* 8210EBFCh case    2:*/		if ( !regs.CR[0].eq ) { return 0x8210EC8C;  }
		/* 8210EBFCh case    2:*/		return 0x8210EC00;
		  /* 8210EC00h */ case    3:  		/* lwz R8, <#[R31 + 84]> */
		/* 8210EC00h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000054) );
		/* 8210EC00h case    3:*/		return 0x8210EC04;
		  /* 8210EC04h */ case    4:  		/* cmpwi CR6, R8, -1 */
		/* 8210EC04h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 8210EC04h case    4:*/		return 0x8210EC08;
		  /* 8210EC08h */ case    5:  		/* bc 12, CR6_EQ, 132 */
		/* 8210EC08h case    5:*/		if ( regs.CR[6].eq ) { return 0x8210EC8C;  }
		/* 8210EC08h case    5:*/		return 0x8210EC0C;
		  /* 8210EC0Ch */ case    6:  		/* lwz R9, <#[R31 + 72]> */
		/* 8210EC0Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000048) );
		/* 8210EC0Ch case    6:*/		return 0x8210EC10;
		  /* 8210EC10h */ case    7:  		/* cmplw CR6, R8, R9 */
		/* 8210EC10h case    7:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8210EC10h case    7:*/		return 0x8210EC14;
		  /* 8210EC14h */ case    8:  		/* bc 12, CR6_GT, 120 */
		/* 8210EC14h case    8:*/		if ( regs.CR[6].gt ) { return 0x8210EC8C;  }
		/* 8210EC14h case    8:*/		return 0x8210EC18;
		  /* 8210EC18h */ case    9:  		/* lwz R31, <#[R31 + 96]> */
		/* 8210EC18h case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000060) );
		/* 8210EC18h case    9:*/		return 0x8210EC1C;
		  /* 8210EC1Ch */ case   10:  		/* cmplwi CR6, R31, 0 */
		/* 8210EC1Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8210EC1Ch case   10:*/		return 0x8210EC20;
		  /* 8210EC20h */ case   11:  		/* bc 12, CR6_EQ, 100 */
		/* 8210EC20h case   11:*/		if ( regs.CR[6].eq ) { return 0x8210EC84;  }
		/* 8210EC20h case   11:*/		return 0x8210EC24;
		  /* 8210EC24h */ case   12:  		/* lwz R11, <#[R31 + 4]> */
		/* 8210EC24h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8210EC24h case   12:*/		return 0x8210EC28;
		  /* 8210EC28h */ case   13:  		/* cmpwi CR6, R11, 6 */
		/* 8210EC28h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 8210EC28h case   13:*/		return 0x8210EC2C;
		  /* 8210EC2Ch */ case   14:  		/* bc 4, CR6_EQ, 88 */
		/* 8210EC2Ch case   14:*/		if ( !regs.CR[6].eq ) { return 0x8210EC84;  }
		/* 8210EC2Ch case   14:*/		return 0x8210EC30;
		  /* 8210EC30h */ case   15:  		/* lwz R11, <#[R31 + 20]> */
		/* 8210EC30h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8210EC30h case   15:*/		return 0x8210EC34;
		  /* 8210EC34h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 8210EC34h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210EC34h case   16:*/		return 0x8210EC38;
		  /* 8210EC38h */ case   17:  		/* bc 12, CR6_EQ, 76 */
		/* 8210EC38h case   17:*/		if ( regs.CR[6].eq ) { return 0x8210EC84;  }
		/* 8210EC38h case   17:*/		return 0x8210EC3C;
		  /* 8210EC3Ch */ case   18:  		/* lwz R10, <#[R11 + 4]> */
		/* 8210EC3Ch case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210EC3Ch case   18:*/		return 0x8210EC40;
		  /* 8210EC40h */ case   19:  		/* cmpwi CR6, R10, 3 */
		/* 8210EC40h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000003);
		/* 8210EC40h case   19:*/		return 0x8210EC44;
		  /* 8210EC44h */ case   20:  		/* bc 4, CR6_EQ, 64 */
		/* 8210EC44h case   20:*/		if ( !regs.CR[6].eq ) { return 0x8210EC84;  }
		/* 8210EC44h case   20:*/		return 0x8210EC48;
		  /* 8210EC48h */ case   21:  		/* lwz R10, <#[R31 + 44]> */
		/* 8210EC48h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 8210EC48h case   21:*/		return 0x8210EC4C;
		  /* 8210EC4Ch */ case   22:  		/* cmpwi CR6, R10, 0 */
		/* 8210EC4Ch case   22:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8210EC4Ch case   22:*/		return 0x8210EC50;
		  /* 8210EC50h */ case   23:  		/* bc 4, CR6_EQ, 332 */
		/* 8210EC50h case   23:*/		if ( !regs.CR[6].eq ) { return 0x8210ED9C;  }
		/* 8210EC50h case   23:*/		return 0x8210EC54;
		  /* 8210EC54h */ case   24:  		/* lwz R10, <#[R30 + 24]> */
		/* 8210EC54h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000018) );
		/* 8210EC54h case   24:*/		return 0x8210EC58;
		  /* 8210EC58h */ case   25:  		/* rlwinm R9, R8, 2, 0, 29 */
		/* 8210EC58h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 8210EC58h case   25:*/		return 0x8210EC5C;
		  /* 8210EC5Ch */ case   26:  		/* lwz R7, <#[R11 + 24]> */
		/* 8210EC5Ch case   26:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000018) );
		/* 8210EC5Ch case   26:*/		return 0x8210EC60;
		  /* 8210EC60h */ case   27:  		/* mr R6, R27 */
		/* 8210EC60h case   27:*/		regs.R6 = regs.R27;
		/* 8210EC60h case   27:*/		return 0x8210EC64;
		  /* 8210EC64h */ case   28:  		/* li R5, 4000 */
		/* 8210EC64h case   28:*/		cpu::op::li<0>(regs,&regs.R5,0xFA0);
		/* 8210EC64h case   28:*/		return 0x8210EC68;
		  /* 8210EC68h */ case   29:  		/* mr R3, R30 */
		/* 8210EC68h case   29:*/		regs.R3 = regs.R30;
		/* 8210EC68h case   29:*/		return 0x8210EC6C;
		  /* 8210EC6Ch */ case   30:  		/* lwzx R11, <#[R9 + R10]> */
		/* 8210EC6Ch case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210EC6Ch case   30:*/		return 0x8210EC70;
		  /* 8210EC70h */ case   31:  		/* lwz R4, <#[R11 + 60]> */
		/* 8210EC70h case   31:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000003C) );
		/* 8210EC70h case   31:*/		return 0x8210EC74;
		  /* 8210EC74h */ case   32:  		/* bl -1348 */
		/* 8210EC74h case   32:*/		regs.LR = 0x8210EC78; return 0x8210E730;
		/* 8210EC74h case   32:*/		return 0x8210EC78;
		  /* 8210EC78h */ case   33:  		/* li R11, 1 */
		/* 8210EC78h case   33:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8210EC78h case   33:*/		return 0x8210EC7C;
		  /* 8210EC7Ch */ case   34:  		/* stw R11, <#[R31 + 44]> */
		/* 8210EC7Ch case   34:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 8210EC7Ch case   34:*/		return 0x8210EC80;
		  /* 8210EC80h */ case   35:  		/* b 284 */
		/* 8210EC80h case   35:*/		return 0x8210ED9C;
		/* 8210EC80h case   35:*/		return 0x8210EC84;
	}
	return 0x8210EC84;
} // Block from 8210EBF4h-8210EC84h (36 instructions)

//////////////////////////////////////////////////////
// Block at 8210EC84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EC84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EC84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EC84);
		  /* 8210EC84h */ case    0:  		/* mr R6, R23 */
		/* 8210EC84h case    0:*/		regs.R6 = regs.R23;
		/* 8210EC84h case    0:*/		return 0x8210EC88;
		  /* 8210EC88h */ case    1:  		/* b 228 */
		/* 8210EC88h case    1:*/		return 0x8210ED6C;
		/* 8210EC88h case    1:*/		return 0x8210EC8C;
	}
	return 0x8210EC8C;
} // Block from 8210EC84h-8210EC8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210EC8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EC8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EC8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EC8C);
		  /* 8210EC8Ch */ case    0:  		/* rlwinm. R9, R11, 0, 26, 26 */
		/* 8210EC8Ch case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R9,regs.R11);
		/* 8210EC8Ch case    0:*/		return 0x8210EC90;
		  /* 8210EC90h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 8210EC90h case    1:*/		if ( regs.CR[0].eq ) { return 0x8210ECA8;  }
		/* 8210EC90h case    1:*/		return 0x8210EC94;
		  /* 8210EC94h */ case    2:  		/* lwz R9, <#[R31 + 72]> */
		/* 8210EC94h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000048) );
		/* 8210EC94h case    2:*/		return 0x8210EC98;
		  /* 8210EC98h */ case    3:  		/* cmpwi CR6, R9, -1 */
		/* 8210EC98h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 8210EC98h case    3:*/		return 0x8210EC9C;
		  /* 8210EC9Ch */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 8210EC9Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x8210ECA8;  }
		/* 8210EC9Ch case    4:*/		return 0x8210ECA0;
		  /* 8210ECA0h */ case    5:  		/* mr R6, R25 */
		/* 8210ECA0h case    5:*/		regs.R6 = regs.R25;
		/* 8210ECA0h case    5:*/		return 0x8210ECA4;
		  /* 8210ECA4h */ case    6:  		/* b 228 */
		/* 8210ECA4h case    6:*/		return 0x8210ED88;
		/* 8210ECA4h case    6:*/		return 0x8210ECA8;
	}
	return 0x8210ECA8;
} // Block from 8210EC8Ch-8210ECA8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210ECA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210ECA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210ECA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210ECA8);
		  /* 8210ECA8h */ case    0:  		/* rlwinm. R9, R11, 0, 30, 30 */
		/* 8210ECA8h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R11);
		/* 8210ECA8h case    0:*/		return 0x8210ECAC;
		  /* 8210ECACh */ case    1:  		/* bc 4, CR0_EQ, 24 */
		/* 8210ECACh case    1:*/		if ( !regs.CR[0].eq ) { return 0x8210ECC4;  }
		/* 8210ECACh case    1:*/		return 0x8210ECB0;
		  /* 8210ECB0h */ case    2:  		/* lwz R8, <#[R31 + 72]> */
		/* 8210ECB0h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000048) );
		/* 8210ECB0h case    2:*/		return 0x8210ECB4;
		  /* 8210ECB4h */ case    3:  		/* cmpwi CR6, R8, -1 */
		/* 8210ECB4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 8210ECB4h case    3:*/		return 0x8210ECB8;
		  /* 8210ECB8h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 8210ECB8h case    4:*/		if ( regs.CR[6].eq ) { return 0x8210ECC4;  }
		/* 8210ECB8h case    4:*/		return 0x8210ECBC;
		  /* 8210ECBCh */ case    5:  		/* mr R6, R28 */
		/* 8210ECBCh case    5:*/		regs.R6 = regs.R28;
		/* 8210ECBCh case    5:*/		return 0x8210ECC0;
		  /* 8210ECC0h */ case    6:  		/* b 172 */
		/* 8210ECC0h case    6:*/		return 0x8210ED6C;
		/* 8210ECC0h case    6:*/		return 0x8210ECC4;
	}
	return 0x8210ECC4;
} // Block from 8210ECA8h-8210ECC4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210ECC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210ECC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210ECC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210ECC4);
		  /* 8210ECC4h */ case    0:  		/* andi. R9, R11, 13 */
		/* 8210ECC4h case    0:*/		cpu::op::andi<1>(regs,&regs.R9,regs.R11,0xD);
		/* 8210ECC4h case    0:*/		return 0x8210ECC8;
		  /* 8210ECC8h */ case    1:  		/* cmplwi CR0, R9, 0 */
		/* 8210ECC8h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 8210ECC8h case    1:*/		return 0x8210ECCC;
		  /* 8210ECCCh */ case    2:  		/* bc 4, CR0_EQ, 24 */
		/* 8210ECCCh case    2:*/		if ( !regs.CR[0].eq ) { return 0x8210ECE4;  }
		/* 8210ECCCh case    2:*/		return 0x8210ECD0;
		  /* 8210ECD0h */ case    3:  		/* lwz R9, <#[R31 + 84]> */
		/* 8210ECD0h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000054) );
		/* 8210ECD0h case    3:*/		return 0x8210ECD4;
		  /* 8210ECD4h */ case    4:  		/* cmpwi CR6, R9, -1 */
		/* 8210ECD4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 8210ECD4h case    4:*/		return 0x8210ECD8;
		  /* 8210ECD8h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 8210ECD8h case    5:*/		if ( regs.CR[6].eq ) { return 0x8210ECE4;  }
		/* 8210ECD8h case    5:*/		return 0x8210ECDC;
		  /* 8210ECDCh */ case    6:  		/* mr R6, R26 */
		/* 8210ECDCh case    6:*/		regs.R6 = regs.R26;
		/* 8210ECDCh case    6:*/		return 0x8210ECE0;
		  /* 8210ECE0h */ case    7:  		/* b 168 */
		/* 8210ECE0h case    7:*/		return 0x8210ED88;
		/* 8210ECE0h case    7:*/		return 0x8210ECE4;
	}
	return 0x8210ECE4;
} // Block from 8210ECC4h-8210ECE4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8210ECE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210ECE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210ECE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210ECE4);
		  /* 8210ECE4h */ case    0:  		/* lwz R9, <#[R30 + 216]> */
		/* 8210ECE4h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x000000D8) );
		/* 8210ECE4h case    0:*/		return 0x8210ECE8;
		  /* 8210ECE8h */ case    1:  		/* cmpwi CR6, R9, 0 */
		/* 8210ECE8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 8210ECE8h case    1:*/		return 0x8210ECEC;
		  /* 8210ECECh */ case    2:  		/* bc 12, CR6_EQ, 180 */
		/* 8210ECECh case    2:*/		if ( regs.CR[6].eq ) { return 0x8210EDA0;  }
		/* 8210ECECh case    2:*/		return 0x8210ECF0;
		  /* 8210ECF0h */ case    3:  		/* lis R12, 1 */
		/* 8210ECF0h case    3:*/		cpu::op::lis<0>(regs,&regs.R12,0x1);
		/* 8210ECF0h case    3:*/		return 0x8210ECF4;
		  /* 8210ECF4h */ case    4:  		/* ori R12, R12, 800 */
		/* 8210ECF4h case    4:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0x320);
		/* 8210ECF4h case    4:*/		return 0x8210ECF8;
		  /* 8210ECF8h */ case    5:  		/* and. R11, R11, R12 */
		/* 8210ECF8h case    5:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8210ECF8h case    5:*/		return 0x8210ECFC;
		  /* 8210ECFCh */ case    6:  		/* bc 4, CR0_EQ, 164 */
		/* 8210ECFCh case    6:*/		if ( !regs.CR[0].eq ) { return 0x8210EDA0;  }
		/* 8210ECFCh case    6:*/		return 0x8210ED00;
		  /* 8210ED00h */ case    7:  		/* lwz R11, <#[R31 + 84]> */
		/* 8210ED00h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 8210ED00h case    7:*/		return 0x8210ED04;
		  /* 8210ED04h */ case    8:  		/* cmpwi CR6, R11, -1 */
		/* 8210ED04h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210ED04h case    8:*/		return 0x8210ED08;
		  /* 8210ED08h */ case    9:  		/* bc 4, CR6_EQ, 152 */
		/* 8210ED08h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8210EDA0;  }
		/* 8210ED08h case    9:*/		return 0x8210ED0C;
		  /* 8210ED0Ch */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 8210ED0Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8210ED0Ch case   10:*/		return 0x8210ED10;
		  /* 8210ED10h */ case   11:  		/* bc 4, CR6_EQ, 76 */
		/* 8210ED10h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8210ED5C;  }
		/* 8210ED10h case   11:*/		return 0x8210ED14;
		  /* 8210ED14h */ case   12:  		/* lwz R11, <#[R31 + 72]> */
		/* 8210ED14h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 8210ED14h case   12:*/		return 0x8210ED18;
		  /* 8210ED18h */ case   13:  		/* cmpwi CR6, R11, -1 */
		/* 8210ED18h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210ED18h case   13:*/		return 0x8210ED1C;
		  /* 8210ED1Ch */ case   14:  		/* bc 12, CR6_EQ, 132 */
		/* 8210ED1Ch case   14:*/		if ( regs.CR[6].eq ) { return 0x8210EDA0;  }
		/* 8210ED1Ch case   14:*/		return 0x8210ED20;
		  /* 8210ED20h */ case   15:  		/* lwz R10, <#[R30 + 24]> */
		/* 8210ED20h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000018) );
		/* 8210ED20h case   15:*/		return 0x8210ED24;
		  /* 8210ED24h */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210ED24h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210ED24h case   16:*/		return 0x8210ED28;
		  /* 8210ED28h */ case   17:  		/* lwzx R3, <#[R11 + R10]> */
		/* 8210ED28h case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210ED28h case   17:*/		return 0x8210ED2C;
		  /* 8210ED2Ch */ case   18:  		/* bl -77244 */
		/* 8210ED2Ch case   18:*/		regs.LR = 0x8210ED30; return 0x820FBF70;
		/* 8210ED2Ch case   18:*/		return 0x8210ED30;
		  /* 8210ED30h */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 8210ED30h case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210ED30h case   19:*/		return 0x8210ED34;
		  /* 8210ED34h */ case   20:  		/* bc 4, CR0_EQ, 108 */
		/* 8210ED34h case   20:*/		if ( !regs.CR[0].eq ) { return 0x8210EDA0;  }
		/* 8210ED34h case   20:*/		return 0x8210ED38;
		  /* 8210ED38h */ case   21:  		/* lwz R11, <#[R31 + 72]> */
		/* 8210ED38h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 8210ED38h case   21:*/		return 0x8210ED3C;
		  /* 8210ED3Ch */ case   22:  		/* lis R10, 8336 */
		/* 8210ED3Ch case   22:*/		cpu::op::lis<0>(regs,&regs.R10,0x2090);
		/* 8210ED3Ch case   22:*/		return 0x8210ED40;
		  /* 8210ED40h */ case   23:  		/* lwz R9, <#[R30 + 24]> */
		/* 8210ED40h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000018) );
		/* 8210ED40h case   23:*/		return 0x8210ED44;
		  /* 8210ED44h */ case   24:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210ED44h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210ED44h case   24:*/		return 0x8210ED48;
		  /* 8210ED48h */ case   25:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210ED48h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210ED48h case   25:*/		return 0x8210ED4C;
		  /* 8210ED4Ch */ case   26:  		/* lwz R11, <#[R11]> */
		/* 8210ED4Ch case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8210ED4Ch case   26:*/		return 0x8210ED50;
		  /* 8210ED50h */ case   27:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 8210ED50h case   27:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 8210ED50h case   27:*/		return 0x8210ED54;
		  /* 8210ED54h */ case   28:  		/* cmplw CR6, R11, R10 */
		/* 8210ED54h case   28:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210ED54h case   28:*/		return 0x8210ED58;
		  /* 8210ED58h */ case   29:  		/* bc 12, CR6_EQ, 72 */
		/* 8210ED58h case   29:*/		if ( regs.CR[6].eq ) { return 0x8210EDA0;  }
		/* 8210ED58h case   29:*/		return 0x8210ED5C;
	}
	return 0x8210ED5C;
} // Block from 8210ECE4h-8210ED5Ch (30 instructions)

//////////////////////////////////////////////////////
// Block at 8210ED5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210ED5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210ED5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210ED5C);
		  /* 8210ED5Ch */ case    0:  		/* lwz R8, <#[R31 + 72]> */
		/* 8210ED5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000048) );
		/* 8210ED5Ch case    0:*/		return 0x8210ED60;
		  /* 8210ED60h */ case    1:  		/* cmpwi CR6, R8, -1 */
		/* 8210ED60h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 8210ED60h case    1:*/		return 0x8210ED64;
		  /* 8210ED64h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 8210ED64h case    2:*/		if ( regs.CR[6].eq ) { return 0x8210ED84;  }
		/* 8210ED64h case    2:*/		return 0x8210ED68;
		  /* 8210ED68h */ case    3:  		/* mr R6, R24 */
		/* 8210ED68h case    3:*/		regs.R6 = regs.R24;
		/* 8210ED68h case    3:*/		return 0x8210ED6C;
	}
	return 0x8210ED6C;
} // Block from 8210ED5Ch-8210ED6Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210ED6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210ED6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210ED6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210ED6C);
		  /* 8210ED6Ch */ case    0:  		/* mr R7, R29 */
		/* 8210ED6Ch case    0:*/		regs.R7 = regs.R29;
		/* 8210ED6Ch case    0:*/		return 0x8210ED70;
		  /* 8210ED70h */ case    1:  		/* li R5, 0 */
		/* 8210ED70h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8210ED70h case    1:*/		return 0x8210ED74;
		  /* 8210ED74h */ case    2:  		/* li R4, 0 */
		/* 8210ED74h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8210ED74h case    2:*/		return 0x8210ED78;
		  /* 8210ED78h */ case    3:  		/* mr R3, R30 */
		/* 8210ED78h case    3:*/		regs.R3 = regs.R30;
		/* 8210ED78h case    3:*/		return 0x8210ED7C;
		  /* 8210ED7Ch */ case    4:  		/* bl -1612 */
		/* 8210ED7Ch case    4:*/		regs.LR = 0x8210ED80; return 0x8210E730;
		/* 8210ED7Ch case    4:*/		return 0x8210ED80;
		  /* 8210ED80h */ case    5:  		/* b 28 */
		/* 8210ED80h case    5:*/		return 0x8210ED9C;
		/* 8210ED80h case    5:*/		return 0x8210ED84;
	}
	return 0x8210ED84;
} // Block from 8210ED6Ch-8210ED84h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210ED84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210ED84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210ED84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210ED84);
		  /* 8210ED84h */ case    0:  		/* mr R6, R22 */
		/* 8210ED84h case    0:*/		regs.R6 = regs.R22;
		/* 8210ED84h case    0:*/		return 0x8210ED88;
	}
	return 0x8210ED88;
} // Block from 8210ED84h-8210ED88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210ED88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210ED88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210ED88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210ED88);
		  /* 8210ED88h */ case    0:  		/* mr R7, R29 */
		/* 8210ED88h case    0:*/		regs.R7 = regs.R29;
		/* 8210ED88h case    0:*/		return 0x8210ED8C;
		  /* 8210ED8Ch */ case    1:  		/* li R5, 0 */
		/* 8210ED8Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8210ED8Ch case    1:*/		return 0x8210ED90;
		  /* 8210ED90h */ case    2:  		/* li R4, 0 */
		/* 8210ED90h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8210ED90h case    2:*/		return 0x8210ED94;
		  /* 8210ED94h */ case    3:  		/* mr R3, R30 */
		/* 8210ED94h case    3:*/		regs.R3 = regs.R30;
		/* 8210ED94h case    3:*/		return 0x8210ED98;
		  /* 8210ED98h */ case    4:  		/* bl -1640 */
		/* 8210ED98h case    4:*/		regs.LR = 0x8210ED9C; return 0x8210E730;
		/* 8210ED98h case    4:*/		return 0x8210ED9C;
	}
	return 0x8210ED9C;
} // Block from 8210ED88h-8210ED9Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210ED9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210ED9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210ED9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210ED9C);
		  /* 8210ED9Ch */ case    0:  		/* li R20, 1 */
		/* 8210ED9Ch case    0:*/		cpu::op::li<0>(regs,&regs.R20,0x1);
		/* 8210ED9Ch case    0:*/		return 0x8210EDA0;
	}
	return 0x8210EDA0;
} // Block from 8210ED9Ch-8210EDA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210EDA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EDA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EDA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EDA0);
		  /* 8210EDA0h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 8210EDA0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8210EDA0h case    0:*/		return 0x8210EDA4;
		  /* 8210EDA4h */ case    1:  		/* addi R29, R29, 1 */
		/* 8210EDA4h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8210EDA4h case    1:*/		return 0x8210EDA8;
		  /* 8210EDA8h */ case    2:  		/* addi R21, R21, 4 */
		/* 8210EDA8h case    2:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x4);
		/* 8210EDA8h case    2:*/		return 0x8210EDAC;
		  /* 8210EDACh */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 8210EDACh case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8210EDACh case    3:*/		return 0x8210EDB0;
		  /* 8210EDB0h */ case    4:  		/* bc 12, CR6_LT, -508 */
		/* 8210EDB0h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210EBB4;  }
		/* 8210EDB0h case    4:*/		return 0x8210EDB4;
		  /* 8210EDB4h */ case    5:  		/* cmpwi CR6, R20, 0 */
		/* 8210EDB4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 8210EDB4h case    5:*/		return 0x8210EDB8;
		  /* 8210EDB8h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 8210EDB8h case    6:*/		if ( regs.CR[6].eq ) { return 0x8210EDC8;  }
		/* 8210EDB8h case    6:*/		return 0x8210EDBC;
		  /* 8210EDBCh */ case    7:  		/* lis R3, -32768 */
		/* 8210EDBCh case    7:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8210EDBCh case    7:*/		return 0x8210EDC0;
		  /* 8210EDC0h */ case    8:  		/* ori R3, R3, 16389 */
		/* 8210EDC0h case    8:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8210EDC0h case    8:*/		return 0x8210EDC4;
		  /* 8210EDC4h */ case    9:  		/* b 8 */
		/* 8210EDC4h case    9:*/		return 0x8210EDCC;
		/* 8210EDC4h case    9:*/		return 0x8210EDC8;
	}
	return 0x8210EDC8;
} // Block from 8210EDA0h-8210EDC8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8210EDC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EDC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EDC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EDC8);
		  /* 8210EDC8h */ case    0:  		/* li R3, 0 */
		/* 8210EDC8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8210EDC8h case    0:*/		return 0x8210EDCC;
	}
	return 0x8210EDCC;
} // Block from 8210EDC8h-8210EDCCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210EDCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EDCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EDCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EDCC);
		  /* 8210EDCCh */ case    0:  		/* addi R1, R1, 240 */
		/* 8210EDCCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 8210EDCCh case    0:*/		return 0x8210EDD0;
		  /* 8210EDD0h */ case    1:  		/* b -514888 */
		/* 8210EDD0h case    1:*/		return 0x82091288;
		/* 8210EDD0h case    1:*/		return 0x8210EDD4;
		  /* 8210EDD4h */ case    2:  		/* nop */
		/* 8210EDD4h case    2:*/		cpu::op::nop();
		/* 8210EDD4h case    2:*/		return 0x8210EDD8;
	}
	return 0x8210EDD8;
} // Block from 8210EDCCh-8210EDD8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210EDD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EDD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EDD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EDD8);
		  /* 8210EDD8h */ case    0:  		/* mfspr R12, LR */
		/* 8210EDD8h case    0:*/		regs.R12 = regs.LR;
		/* 8210EDD8h case    0:*/		return 0x8210EDDC;
		  /* 8210EDDCh */ case    1:  		/* bl -515004 */
		/* 8210EDDCh case    1:*/		regs.LR = 0x8210EDE0; return 0x82091220;
		/* 8210EDDCh case    1:*/		return 0x8210EDE0;
		  /* 8210EDE0h */ case    2:  		/* stfd FR31, <#[R1 - 160]> */
		/* 8210EDE0h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8210EDE0h case    2:*/		return 0x8210EDE4;
		  /* 8210EDE4h */ case    3:  		/* stwu R1, <#[R1 - 256]> */
		/* 8210EDE4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 8210EDE4h case    3:*/		return 0x8210EDE8;
		  /* 8210EDE8h */ case    4:  		/* lwz R11, <#[R3 + 204]> */
		/* 8210EDE8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000CC) );
		/* 8210EDE8h case    4:*/		return 0x8210EDEC;
		  /* 8210EDECh */ case    5:  		/* mr R31, R3 */
		/* 8210EDECh case    5:*/		regs.R31 = regs.R3;
		/* 8210EDECh case    5:*/		return 0x8210EDF0;
		  /* 8210EDF0h */ case    6:  		/* rlwinm. R10, R11, 0, 23, 23 */
		/* 8210EDF0h case    6:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R11);
		/* 8210EDF0h case    6:*/		return 0x8210EDF4;
		  /* 8210EDF4h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 8210EDF4h case    7:*/		if ( regs.CR[0].eq ) { return 0x8210EE00;  }
		/* 8210EDF4h case    7:*/		return 0x8210EDF8;
		  /* 8210EDF8h */ case    8:  		/* li R3, 1 */
		/* 8210EDF8h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8210EDF8h case    8:*/		return 0x8210EDFC;
		  /* 8210EDFCh */ case    9:  		/* b 1672 */
		/* 8210EDFCh case    9:*/		return 0x8210F484;
		/* 8210EDFCh case    9:*/		return 0x8210EE00;
	}
	return 0x8210EE00;
} // Block from 8210EDD8h-8210EE00h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8210EE00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EE00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EE00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EE00);
		  /* 8210EE00h */ case    0:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 8210EE00h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 8210EE00h case    0:*/		return 0x8210EE04;
		  /* 8210EE04h */ case    1:  		/* bc 4, CR0_EQ, -12 */
		/* 8210EE04h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8210EDF8;  }
		/* 8210EE04h case    1:*/		return 0x8210EE08;
		  /* 8210EE08h */ case    2:  		/* mr R3, R31 */
		/* 8210EE08h case    2:*/		regs.R3 = regs.R31;
		/* 8210EE08h case    2:*/		return 0x8210EE0C;
		  /* 8210EE0Ch */ case    3:  		/* bl -19060 */
		/* 8210EE0Ch case    3:*/		regs.LR = 0x8210EE10; return 0x8210A398;
		/* 8210EE0Ch case    3:*/		return 0x8210EE10;
		  /* 8210EE10h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 8210EE10h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210EE10h case    4:*/		return 0x8210EE14;
		  /* 8210EE14h */ case    5:  		/* bc 12, CR0_LT, 1648 */
		/* 8210EE14h case    5:*/		if ( regs.CR[0].lt ) { return 0x8210F484;  }
		/* 8210EE14h case    5:*/		return 0x8210EE18;
		  /* 8210EE18h */ case    6:  		/* lis R4, 9345 */
		/* 8210EE18h case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8210EE18h case    6:*/		return 0x8210EE1C;
		  /* 8210EE1Ch */ case    7:  		/* li R3, 512 */
		/* 8210EE1Ch case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x200);
		/* 8210EE1Ch case    7:*/		return 0x8210EE20;
		  /* 8210EE20h */ case    8:  		/* bl -551968 */
		/* 8210EE20h case    8:*/		regs.LR = 0x8210EE24; return 0x82088200;
		/* 8210EE20h case    8:*/		return 0x8210EE24;
		  /* 8210EE24h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 8210EE24h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8210EE24h case    9:*/		return 0x8210EE28;
		  /* 8210EE28h */ case   10:  		/* bc 12, CR0_EQ, 16 */
		/* 8210EE28h case   10:*/		if ( regs.CR[0].eq ) { return 0x8210EE38;  }
		/* 8210EE28h case   10:*/		return 0x8210EE2C;
		  /* 8210EE2Ch */ case   11:  		/* lwz R4, <#[R31 + 224]> */
		/* 8210EE2Ch case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x000000E0) );
		/* 8210EE2Ch case   11:*/		return 0x8210EE30;
		  /* 8210EE30h */ case   12:  		/* bl 211760 */
		/* 8210EE30h case   12:*/		regs.LR = 0x8210EE34; return 0x82142960;
		/* 8210EE30h case   12:*/		return 0x8210EE34;
		  /* 8210EE34h */ case   13:  		/* b 8 */
		/* 8210EE34h case   13:*/		return 0x8210EE3C;
		/* 8210EE34h case   13:*/		return 0x8210EE38;
	}
	return 0x8210EE38;
} // Block from 8210EE00h-8210EE38h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8210EE38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EE38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EE38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EE38);
		  /* 8210EE38h */ case    0:  		/* li R3, 0 */
		/* 8210EE38h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8210EE38h case    0:*/		return 0x8210EE3C;
	}
	return 0x8210EE3C;
} // Block from 8210EE38h-8210EE3Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210EE3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EE3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EE3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EE3C);
		  /* 8210EE3Ch */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 8210EE3Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8210EE3Ch case    0:*/		return 0x8210EE40;
		  /* 8210EE40h */ case    1:  		/* stw R3, <#[R31 + 228]> */
		/* 8210EE40h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000000E4) );
		/* 8210EE40h case    1:*/		return 0x8210EE44;
		  /* 8210EE44h */ case    2:  		/* bc 12, CR6_EQ, 1612 */
		/* 8210EE44h case    2:*/		if ( regs.CR[6].eq ) { return 0x8210F490;  }
		/* 8210EE44h case    2:*/		return 0x8210EE48;
		  /* 8210EE48h */ case    3:  		/* lwz R11, <#[R31 + 204]> */
		/* 8210EE48h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000CC) );
		/* 8210EE48h case    3:*/		return 0x8210EE4C;
		  /* 8210EE4Ch */ case    4:  		/* lis R5, 18008 */
		/* 8210EE4Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R5,0x4658);
		/* 8210EE4Ch case    4:*/		return 0x8210EE50;
		  /* 8210EE50h */ case    5:  		/* mr R4, R31 */
		/* 8210EE50h case    5:*/		regs.R4 = regs.R31;
		/* 8210EE50h case    5:*/		return 0x8210EE54;
		  /* 8210EE54h */ case    6:  		/* ori R5, R5, 513 */
		/* 8210EE54h case    6:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x201);
		/* 8210EE54h case    6:*/		return 0x8210EE58;
		  /* 8210EE58h */ case    7:  		/* ori R6, R11, 256 */
		/* 8210EE58h case    7:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R11,0x100);
		/* 8210EE58h case    7:*/		return 0x8210EE5C;
		  /* 8210EE5Ch */ case    8:  		/* bl -34052 */
		/* 8210EE5Ch case    8:*/		regs.LR = 0x8210EE60; return 0x82106958;
		/* 8210EE5Ch case    8:*/		return 0x8210EE60;
		  /* 8210EE60h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 8210EE60h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210EE60h case    9:*/		return 0x8210EE64;
		  /* 8210EE64h */ case   10:  		/* bc 12, CR0_LT, 1568 */
		/* 8210EE64h case   10:*/		if ( regs.CR[0].lt ) { return 0x8210F484;  }
		/* 8210EE64h case   10:*/		return 0x8210EE68;
		  /* 8210EE68h */ case   11:  		/* lwz R3, <#[R31 + 228]> */
		/* 8210EE68h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000E4) );
		/* 8210EE68h case   11:*/		return 0x8210EE6C;
		  /* 8210EE6Ch */ case   12:  		/* bl -53588 */
		/* 8210EE6Ch case   12:*/		regs.LR = 0x8210EE70; return 0x82101D18;
		/* 8210EE6Ch case   12:*/		return 0x8210EE70;
		  /* 8210EE70h */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 8210EE70h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210EE70h case   13:*/		return 0x8210EE74;
		  /* 8210EE74h */ case   14:  		/* bc 12, CR0_LT, 1552 */
		/* 8210EE74h case   14:*/		if ( regs.CR[0].lt ) { return 0x8210F484;  }
		/* 8210EE74h case   14:*/		return 0x8210EE78;
		  /* 8210EE78h */ case   15:  		/* mr R3, R31 */
		/* 8210EE78h case   15:*/		regs.R3 = regs.R31;
		/* 8210EE78h case   15:*/		return 0x8210EE7C;
		  /* 8210EE7Ch */ case   16:  		/* bl -52876 */
		/* 8210EE7Ch case   16:*/		regs.LR = 0x8210EE80; return 0x82101FF0;
		/* 8210EE7Ch case   16:*/		return 0x8210EE80;
		  /* 8210EE80h */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 8210EE80h case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210EE80h case   17:*/		return 0x8210EE84;
		  /* 8210EE84h */ case   18:  		/* bc 12, CR0_LT, 1536 */
		/* 8210EE84h case   18:*/		if ( regs.CR[0].lt ) { return 0x8210F484;  }
		/* 8210EE84h case   18:*/		return 0x8210EE88;
		  /* 8210EE88h */ case   19:  		/* lwz R11, <#[R31 + 8]> */
		/* 8210EE88h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8210EE88h case   19:*/		return 0x8210EE8C;
		  /* 8210EE8Ch */ case   20:  		/* li R28, -1 */
		/* 8210EE8Ch case   20:*/		cpu::op::li<0>(regs,&regs.R28,0xFFFFFFFF);
		/* 8210EE8Ch case   20:*/		return 0x8210EE90;
		  /* 8210EE90h */ case   21:  		/* li R10, 0 */
		/* 8210EE90h case   21:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210EE90h case   21:*/		return 0x8210EE94;
		  /* 8210EE94h */ case   22:  		/* cmplwi CR6, R11, 0 */
		/* 8210EE94h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210EE94h case   22:*/		return 0x8210EE98;
		  /* 8210EE98h */ case   23:  		/* bc 4, CR6_GT, 52 */
		/* 8210EE98h case   23:*/		if ( !regs.CR[6].gt ) { return 0x8210EECC;  }
		/* 8210EE98h case   23:*/		return 0x8210EE9C;
		  /* 8210EE9Ch */ case   24:  		/* li R11, 0 */
		/* 8210EE9Ch case   24:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210EE9Ch case   24:*/		return 0x8210EEA0;
		  /* 8210EEA0h */ case   25:  		/* lwz R9, <#[R31 + 20]> */
		/* 8210EEA0h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 8210EEA0h case   25:*/		return 0x8210EEA4;
		  /* 8210EEA4h */ case   26:  		/* addi R10, R10, 1 */
		/* 8210EEA4h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210EEA4h case   26:*/		return 0x8210EEA8;
		  /* 8210EEA8h */ case   27:  		/* lwzx R9, <#[R9 + R11]> */
		/* 8210EEA8h case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8210EEA8h case   27:*/		return 0x8210EEAC;
		  /* 8210EEACh */ case   28:  		/* stw R28, <#[R9 + 48]> */
		/* 8210EEACh case   28:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R9 + 0x00000030) );
		/* 8210EEACh case   28:*/		return 0x8210EEB0;
		  /* 8210EEB0h */ case   29:  		/* lwz R9, <#[R31 + 20]> */
		/* 8210EEB0h case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 8210EEB0h case   29:*/		return 0x8210EEB4;
		  /* 8210EEB4h */ case   30:  		/* lwzx R9, <#[R9 + R11]> */
		/* 8210EEB4h case   30:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8210EEB4h case   30:*/		return 0x8210EEB8;
		  /* 8210EEB8h */ case   31:  		/* addi R11, R11, 4 */
		/* 8210EEB8h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210EEB8h case   31:*/		return 0x8210EEBC;
		  /* 8210EEBCh */ case   32:  		/* stw R28, <#[R9 + 68]> */
		/* 8210EEBCh case   32:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R9 + 0x00000044) );
		/* 8210EEBCh case   32:*/		return 0x8210EEC0;
		  /* 8210EEC0h */ case   33:  		/* lwz R9, <#[R31 + 8]> */
		/* 8210EEC0h case   33:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 8210EEC0h case   33:*/		return 0x8210EEC4;
		  /* 8210EEC4h */ case   34:  		/* cmplw CR6, R10, R9 */
		/* 8210EEC4h case   34:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8210EEC4h case   34:*/		return 0x8210EEC8;
		  /* 8210EEC8h */ case   35:  		/* bc 12, CR6_LT, -40 */
		/* 8210EEC8h case   35:*/		if ( regs.CR[6].lt ) { return 0x8210EEA0;  }
		/* 8210EEC8h case   35:*/		return 0x8210EECC;
	}
	return 0x8210EECC;
} // Block from 8210EE3Ch-8210EECCh (36 instructions)

//////////////////////////////////////////////////////
// Block at 8210EECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EECC);
		  /* 8210EECCh */ case    0:  		/* lis R10, -32256 */
		/* 8210EECCh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8210EECCh case    0:*/		return 0x8210EED0;
		  /* 8210EED0h */ case    1:  		/* lwz R9, <#[R31 + 12]> */
		/* 8210EED0h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210EED0h case    1:*/		return 0x8210EED4;
		  /* 8210EED4h */ case    2:  		/* lis R11, -32255 */
		/* 8210EED4h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8210EED4h case    2:*/		return 0x8210EED8;
		  /* 8210EED8h */ case    3:  		/* mr R14, R28 */
		/* 8210EED8h case    3:*/		regs.R14 = regs.R28;
		/* 8210EED8h case    3:*/		return 0x8210EEDC;
		  /* 8210EEDCh */ case    4:  		/* addi R11, R11, -8736 */
		/* 8210EEDCh case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFDDE0);
		/* 8210EEDCh case    4:*/		return 0x8210EEE0;
		  /* 8210EEE0h */ case    5:  		/* li R17, 0 */
		/* 8210EEE0h case    5:*/		cpu::op::li<0>(regs,&regs.R17,0x0);
		/* 8210EEE0h case    5:*/		return 0x8210EEE4;
		  /* 8210EEE4h */ case    6:  		/* lfd FR31, <#[R10 + 1808]> */
		/* 8210EEE4h case    6:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R10 + 0x00000710) );
		/* 8210EEE4h case    6:*/		return 0x8210EEE8;
		  /* 8210EEE8h */ case    7:  		/* li R16, 0 */
		/* 8210EEE8h case    7:*/		cpu::op::li<0>(regs,&regs.R16,0x0);
		/* 8210EEE8h case    7:*/		return 0x8210EEEC;
		  /* 8210EEECh */ case    8:  		/* stw R11, <#[R1 + 80]> */
		/* 8210EEECh case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8210EEECh case    8:*/		return 0x8210EEF0;
		  /* 8210EEF0h */ case    9:  		/* cmplwi CR6, R9, 0 */
		/* 8210EEF0h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8210EEF0h case    9:*/		return 0x8210EEF4;
		  /* 8210EEF4h */ case   10:  		/* bc 4, CR6_GT, 716 */
		/* 8210EEF4h case   10:*/		if ( !regs.CR[6].gt ) { return 0x8210F1C0;  }
		/* 8210EEF4h case   10:*/		return 0x8210EEF8;
		  /* 8210EEF8h */ case   11:  		/* li R15, 0 */
		/* 8210EEF8h case   11:*/		cpu::op::li<0>(regs,&regs.R15,0x0);
		/* 8210EEF8h case   11:*/		return 0x8210EEFC;
		  /* 8210EEFCh */ case   12:  		/* lwz R11, <#[R31 + 24]> */
		/* 8210EEFCh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8210EEFCh case   12:*/		return 0x8210EF00;
		  /* 8210EF00h */ case   13:  		/* lwzx R25, <#[R15 + R11]> */
		/* 8210EF00h case   13:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R15 + regs.R11 + 0x00000000) );
		/* 8210EF00h case   13:*/		return 0x8210EF04;
		  /* 8210EF04h */ case   14:  		/* lwz R11, <#[R25]> */
		/* 8210EF04h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 8210EF04h case   14:*/		return 0x8210EF08;
		  /* 8210EF08h */ case   15:  		/* rlwinm. R10, R11, 0, 0, 11 */
		/* 8210EF08h case   15:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R10,regs.R11);
		/* 8210EF08h case   15:*/		return 0x8210EF0C;
		  /* 8210EF0Ch */ case   16:  		/* bc 12, CR0_EQ, 672 */
		/* 8210EF0Ch case   16:*/		if ( regs.CR[0].eq ) { return 0x8210F1AC;  }
		/* 8210EF0Ch case   16:*/		return 0x8210EF10;
		  /* 8210EF10h */ case   17:  		/* lwz R10, <#[R25 + 4]> */
		/* 8210EF10h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 8210EF10h case   17:*/		return 0x8210EF14;
		  /* 8210EF14h */ case   18:  		/* rlwinm R20, R11, 0, 12, 31 */
		/* 8210EF14h case   18:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R20,regs.R11);
		/* 8210EF14h case   18:*/		return 0x8210EF18;
		  /* 8210EF18h */ case   19:  		/* li R19, 0 */
		/* 8210EF18h case   19:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 8210EF18h case   19:*/		return 0x8210EF1C;
		  /* 8210EF1Ch */ case   20:  		/* divwu. R18, R10, R20 */
		/* 8210EF1Ch case   20:*/		cpu::op::divwu<1>(regs,&regs.R18,regs.R10,regs.R20);
		/* 8210EF1Ch case   20:*/		return 0x8210EF20;
		  /* 8210EF20h */ case   21:  		/* twi 6, R20, 0 */
		/* 8210EF20h case   21:*/		cpu::op::tw<6>(regs, 0x8210EF20, regs.R20, 0x00000000);
		/* 8210EF20h case   21:*/		return 0x8210EF24;
		  /* 8210EF24h */ case   22:  		/* bc 12, CR0_EQ, 648 */
		/* 8210EF24h case   22:*/		if ( regs.CR[0].eq ) { return 0x8210F1AC;  }
		/* 8210EF24h case   22:*/		return 0x8210EF28;
		  /* 8210EF28h */ case   23:  		/* li R21, 0 */
		/* 8210EF28h case   23:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 8210EF28h case   23:*/		return 0x8210EF2C;
		  /* 8210EF2Ch */ case   24:  		/* li R30, 0 */
		/* 8210EF2Ch case   24:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8210EF2Ch case   24:*/		return 0x8210EF30;
		  /* 8210EF30h */ case   25:  		/* li R8, 0 */
		/* 8210EF30h case   25:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8210EF30h case   25:*/		return 0x8210EF34;
		  /* 8210EF34h */ case   26:  		/* cmplwi CR6, R20, 0 */
		/* 8210EF34h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 8210EF34h case   26:*/		return 0x8210EF38;
		  /* 8210EF38h */ case   27:  		/* bc 12, CR6_EQ, 612 */
		/* 8210EF38h case   27:*/		if ( regs.CR[6].eq ) { return 0x8210F19C;  }
		/* 8210EF38h case   27:*/		return 0x8210EF3C;
		  /* 8210EF3Ch */ case   28:  		/* lwz R7, <#[R25 + 8]> */
		/* 8210EF3Ch case   28:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R25 + 0x00000008) );
		/* 8210EF3Ch case   28:*/		return 0x8210EF40;
		  /* 8210EF40h */ case   29:  		/* lwz R6, <#[R31 + 20]> */
		/* 8210EF40h case   29:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000014) );
		/* 8210EF40h case   29:*/		return 0x8210EF44;
		  /* 8210EF44h */ case   30:  		/* lwz R5, <#[R31 + 16]> */
		/* 8210EF44h case   30:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000010) );
		/* 8210EF44h case   30:*/		return 0x8210EF48;
		  /* 8210EF48h */ case   31:  		/* add R11, R21, R8 */
		/* 8210EF48h case   31:*/		cpu::op::add<0>(regs,&regs.R11,regs.R21,regs.R8);
		/* 8210EF48h case   31:*/		return 0x8210EF4C;
		  /* 8210EF4Ch */ case   32:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210EF4Ch case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210EF4Ch case   32:*/		return 0x8210EF50;
		  /* 8210EF50h */ case   33:  		/* lwzx R4, <#[R11 + R7]> */
		/* 8210EF50h case   33:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 8210EF50h case   33:*/		return 0x8210EF54;
		  /* 8210EF54h */ case   34:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 8210EF54h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 8210EF54h case   34:*/		return 0x8210EF58;
		  /* 8210EF58h */ case   35:  		/* lwzx R11, <#[R11 + R6]> */
		/* 8210EF58h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 8210EF58h case   35:*/		return 0x8210EF5C;
		  /* 8210EF5Ch */ case   36:  		/* lwz R11, <#[R11 + 4]> */
		/* 8210EF5Ch case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8210EF5Ch case   36:*/		return 0x8210EF60;
		  /* 8210EF60h */ case   37:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210EF60h case   37:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210EF60h case   37:*/		return 0x8210EF64;
		  /* 8210EF64h */ case   38:  		/* lwzx R11, <#[R11 + R5]> */
		/* 8210EF64h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 8210EF64h case   38:*/		return 0x8210EF68;
		  /* 8210EF68h */ case   39:  		/* lwz R11, <#[R11 + 4]> */
		/* 8210EF68h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8210EF68h case   39:*/		return 0x8210EF6C;
		  /* 8210EF6Ch */ case   40:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 8210EF6Ch case   40:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 8210EF6Ch case   40:*/		return 0x8210EF70;
		  /* 8210EF70h */ case   41:  		/* bc 12, CR0_EQ, 24 */
		/* 8210EF70h case   41:*/		if ( regs.CR[0].eq ) { return 0x8210EF88;  }
		/* 8210EF70h case   41:*/		return 0x8210EF74;
		  /* 8210EF74h */ case   42:  		/* mr R3, R31 */
		/* 8210EF74h case   42:*/		regs.R3 = regs.R31;
		/* 8210EF74h case   42:*/		return 0x8210EF78;
		  /* 8210EF78h */ case   43:  		/* bl -69024 */
		/* 8210EF78h case   43:*/		regs.LR = 0x8210EF7C; return 0x820FE1D8;
		/* 8210EF78h case   43:*/		return 0x8210EF7C;
		  /* 8210EF7Ch */ case   44:  		/* cmpwi CR0, R3, 0 */
		/* 8210EF7Ch case   44:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210EF7Ch case   44:*/		return 0x8210EF80;
		  /* 8210EF80h */ case   45:  		/* bc 4, CR0_EQ, 8 */
		/* 8210EF80h case   45:*/		if ( !regs.CR[0].eq ) { return 0x8210EF88;  }
		/* 8210EF80h case   45:*/		return 0x8210EF84;
		  /* 8210EF84h */ case   46:  		/* addi R30, R30, 1 */
		/* 8210EF84h case   46:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8210EF84h case   46:*/		return 0x8210EF88;
	}
	return 0x8210EF88;
} // Block from 8210EECCh-8210EF88h (47 instructions)

//////////////////////////////////////////////////////
// Block at 8210EF88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EF88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EF88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EF88);
		  /* 8210EF88h */ case    0:  		/* addi R8, R8, 1 */
		/* 8210EF88h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8210EF88h case    0:*/		return 0x8210EF8C;
		  /* 8210EF8Ch */ case    1:  		/* cmplw CR6, R8, R20 */
		/* 8210EF8Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R20);
		/* 8210EF8Ch case    1:*/		return 0x8210EF90;
		  /* 8210EF90h */ case    2:  		/* bc 12, CR6_LT, -72 */
		/* 8210EF90h case    2:*/		if ( regs.CR[6].lt ) { return 0x8210EF48;  }
		/* 8210EF90h case    2:*/		return 0x8210EF94;
		  /* 8210EF94h */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 8210EF94h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8210EF94h case    3:*/		return 0x8210EF98;
		  /* 8210EF98h */ case    4:  		/* bc 12, CR6_EQ, 516 */
		/* 8210EF98h case    4:*/		if ( regs.CR[6].eq ) { return 0x8210F19C;  }
		/* 8210EF98h case    4:*/		return 0x8210EF9C;
		  /* 8210EF9Ch */ case    5:  		/* cmpwi CR6, R14, -1 */
		/* 8210EF9Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R14,0xFFFFFFFF);
		/* 8210EF9Ch case    5:*/		return 0x8210EFA0;
		  /* 8210EFA0h */ case    6:  		/* bc 4, CR6_EQ, 44 */
		/* 8210EFA0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8210EFCC;  }
		/* 8210EFA0h case    6:*/		return 0x8210EFA4;
		  /* 8210EFA4h */ case    7:  		/* lis R5, 8 */
		/* 8210EFA4h case    7:*/		cpu::op::lis<0>(regs,&regs.R5,0x8);
		/* 8210EFA4h case    7:*/		return 0x8210EFA8;
		  /* 8210EFA8h */ case    8:  		/* lwz R4, <#[R1 + 80]> */
		/* 8210EFA8h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 8210EFA8h case    8:*/		return 0x8210EFAC;
		  /* 8210EFACh */ case    9:  		/* li R7, 4 */
		/* 8210EFACh case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 8210EFACh case    9:*/		return 0x8210EFB0;
		  /* 8210EFB0h */ case   10:  		/* mr R6, R28 */
		/* 8210EFB0h case   10:*/		regs.R6 = regs.R28;
		/* 8210EFB0h case   10:*/		return 0x8210EFB4;
		  /* 8210EFB4h */ case   11:  		/* ori R5, R5, 593 */
		/* 8210EFB4h case   11:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x251);
		/* 8210EFB4h case   11:*/		return 0x8210EFB8;
		  /* 8210EFB8h */ case   12:  		/* mr R3, R31 */
		/* 8210EFB8h case   12:*/		regs.R3 = regs.R31;
		/* 8210EFB8h case   12:*/		return 0x8210EFBC;
		  /* 8210EFBCh */ case   13:  		/* bl -73268 */
		/* 8210EFBCh case   13:*/		regs.LR = 0x8210EFC0; return 0x820FD188;
		/* 8210EFBCh case   13:*/		return 0x8210EFC0;
		  /* 8210EFC0h */ case   14:  		/* mr R14, R3 */
		/* 8210EFC0h case   14:*/		regs.R14 = regs.R3;
		/* 8210EFC0h case   14:*/		return 0x8210EFC4;
		  /* 8210EFC4h */ case   15:  		/* cmpwi CR6, R3, -1 */
		/* 8210EFC4h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8210EFC4h case   15:*/		return 0x8210EFC8;
		  /* 8210EFC8h */ case   16:  		/* bc 12, CR6_EQ, 1224 */
		/* 8210EFC8h case   16:*/		if ( regs.CR[6].eq ) { return 0x8210F490;  }
		/* 8210EFC8h case   16:*/		return 0x8210EFCC;
	}
	return 0x8210EFCC;
} // Block from 8210EF88h-8210EFCCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 8210EFCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210EFCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210EFCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210EFCC);
		  /* 8210EFCCh */ case    0:  		/* li R11, 1 */
		/* 8210EFCCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8210EFCCh case    0:*/		return 0x8210EFD0;
		  /* 8210EFD0h */ case    1:  		/* lwz R3, <#[R31 + 228]> */
		/* 8210EFD0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000E4) );
		/* 8210EFD0h case    1:*/		return 0x8210EFD4;
		  /* 8210EFD4h */ case    2:  		/* mr R4, R30 */
		/* 8210EFD4h case    2:*/		regs.R4 = regs.R30;
		/* 8210EFD4h case    2:*/		return 0x8210EFD8;
		  /* 8210EFD8h */ case    3:  		/* mr R6, R30 */
		/* 8210EFD8h case    3:*/		regs.R6 = regs.R30;
		/* 8210EFD8h case    3:*/		return 0x8210EFDC;
		  /* 8210EFDCh */ case    4:  		/* rlwimi R4, R11, 28, 0, 11 */
		/* 8210EFDCh case    4:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R4,regs.R11);
		/* 8210EFDCh case    4:*/		return 0x8210EFE0;
		  /* 8210EFE0h */ case    5:  		/* mr R5, R30 */
		/* 8210EFE0h case    5:*/		regs.R5 = regs.R30;
		/* 8210EFE0h case    5:*/		return 0x8210EFE4;
		  /* 8210EFE4h */ case    6:  		/* bl -72988 */
		/* 8210EFE4h case    6:*/		regs.LR = 0x8210EFE8; return 0x820FD2C8;
		/* 8210EFE4h case    6:*/		return 0x8210EFE8;
		  /* 8210EFE8h */ case    7:  		/* cmpwi CR6, R3, -1 */
		/* 8210EFE8h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8210EFE8h case    7:*/		return 0x8210EFEC;
		  /* 8210EFECh */ case    8:  		/* bc 12, CR6_EQ, 1188 */
		/* 8210EFECh case    8:*/		if ( regs.CR[6].eq ) { return 0x8210F490;  }
		/* 8210EFECh case    8:*/		return 0x8210EFF0;
		  /* 8210EFF0h */ case    9:  		/* lwz R11, <#[R31 + 228]> */
		/* 8210EFF0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8210EFF0h case    9:*/		return 0x8210EFF4;
		  /* 8210EFF4h */ case   10:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 8210EFF4h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 8210EFF4h case   10:*/		return 0x8210EFF8;
		  /* 8210EFF8h */ case   11:  		/* mr R4, R25 */
		/* 8210EFF8h case   11:*/		regs.R4 = regs.R25;
		/* 8210EFF8h case   11:*/		return 0x8210EFFC;
		  /* 8210EFFCh */ case   12:  		/* lwz R11, <#[R11 + 24]> */
		/* 8210EFFCh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8210EFFCh case   12:*/		return 0x8210F000;
		  /* 8210F000h */ case   13:  		/* lwzx R23, <#[R10 + R11]> */
		/* 8210F000h case   13:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210F000h case   13:*/		return 0x8210F004;
		  /* 8210F004h */ case   14:  		/* mr R3, R23 */
		/* 8210F004h case   14:*/		regs.R3 = regs.R23;
		/* 8210F004h case   14:*/		return 0x8210F008;
		  /* 8210F008h */ case   15:  		/* bl -78104 */
		/* 8210F008h case   15:*/		regs.LR = 0x8210F00C; return 0x820FBEF0;
		/* 8210F008h case   15:*/		return 0x8210F00C;
		  /* 8210F00Ch */ case   16:  		/* li R29, 0 */
		/* 8210F00Ch case   16:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8210F00Ch case   16:*/		return 0x8210F010;
		  /* 8210F010h */ case   17:  		/* li R6, 0 */
		/* 8210F010h case   17:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8210F010h case   17:*/		return 0x8210F014;
		  /* 8210F014h */ case   18:  		/* li R22, 0 */
		/* 8210F014h case   18:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 8210F014h case   18:*/		return 0x8210F018;
		  /* 8210F018h */ case   19:  		/* li R27, 0 */
		/* 8210F018h case   19:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8210F018h case   19:*/		return 0x8210F01C;
		  /* 8210F01Ch */ case   20:  		/* add R11, R21, R22 */
		/* 8210F01Ch case   20:*/		cpu::op::add<0>(regs,&regs.R11,regs.R21,regs.R22);
		/* 8210F01Ch case   20:*/		return 0x8210F020;
		  /* 8210F020h */ case   21:  		/* lwz R7, <#[R25 + 8]> */
		/* 8210F020h case   21:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R25 + 0x00000008) );
		/* 8210F020h case   21:*/		return 0x8210F024;
		  /* 8210F024h */ case   22:  		/* lwz R10, <#[R31 + 20]> */
		/* 8210F024h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 8210F024h case   22:*/		return 0x8210F028;
		  /* 8210F028h */ case   23:  		/* rlwinm R30, R11, 2, 0, 29 */
		/* 8210F028h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R11);
		/* 8210F028h case   23:*/		return 0x8210F02C;
		  /* 8210F02Ch */ case   24:  		/* lwz R11, <#[R31 + 16]> */
		/* 8210F02Ch case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8210F02Ch case   24:*/		return 0x8210F030;
		  /* 8210F030h */ case   25:  		/* lwzx R26, <#[R30 + R7]> */
		/* 8210F030h case   25:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R30 + regs.R7 + 0x00000000) );
		/* 8210F030h case   25:*/		return 0x8210F034;
		  /* 8210F034h */ case   26:  		/* rlwinm R24, R26, 2, 0, 29 */
		/* 8210F034h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R24,regs.R26);
		/* 8210F034h case   26:*/		return 0x8210F038;
		  /* 8210F038h */ case   27:  		/* lwzx R8, <#[R24 + R10]> */
		/* 8210F038h case   27:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R24 + regs.R10 + 0x00000000) );
		/* 8210F038h case   27:*/		return 0x8210F03C;
		  /* 8210F03Ch */ case   28:  		/* lwz R10, <#[R8 + 4]> */
		/* 8210F03Ch case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000004) );
		/* 8210F03Ch case   28:*/		return 0x8210F040;
		  /* 8210F040h */ case   29:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210F040h case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210F040h case   29:*/		return 0x8210F044;
		  /* 8210F044h */ case   30:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8210F044h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210F044h case   30:*/		return 0x8210F048;
		  /* 8210F048h */ case   31:  		/* lwz R11, <#[R11 + 4]> */
		/* 8210F048h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8210F048h case   31:*/		return 0x8210F04C;
		  /* 8210F04Ch */ case   32:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 8210F04Ch case   32:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 8210F04Ch case   32:*/		return 0x8210F050;
		  /* 8210F050h */ case   33:  		/* bc 12, CR0_EQ, 272 */
		/* 8210F050h case   33:*/		if ( regs.CR[0].eq ) { return 0x8210F160;  }
		/* 8210F050h case   33:*/		return 0x8210F054;
		  /* 8210F054h */ case   34:  		/* mr R4, R26 */
		/* 8210F054h case   34:*/		regs.R4 = regs.R26;
		/* 8210F054h case   34:*/		return 0x8210F058;
		  /* 8210F058h */ case   35:  		/* mr R3, R31 */
		/* 8210F058h case   35:*/		regs.R3 = regs.R31;
		/* 8210F058h case   35:*/		return 0x8210F05C;
		  /* 8210F05Ch */ case   36:  		/* bl -69252 */
		/* 8210F05Ch case   36:*/		regs.LR = 0x8210F060; return 0x820FE1D8;
		/* 8210F05Ch case   36:*/		return 0x8210F060;
		  /* 8210F060h */ case   37:  		/* cmpwi CR0, R3, 0 */
		/* 8210F060h case   37:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210F060h case   37:*/		return 0x8210F064;
		  /* 8210F064h */ case   38:  		/* bc 4, CR0_EQ, 252 */
		/* 8210F064h case   38:*/		if ( !regs.CR[0].eq ) { return 0x8210F160;  }
		/* 8210F064h case   38:*/		return 0x8210F068;
		  /* 8210F068h */ case   39:  		/* lwz R11, <#[R8 + 72]> */
		/* 8210F068h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000048) );
		/* 8210F068h case   39:*/		return 0x8210F06C;
		  /* 8210F06Ch */ case   40:  		/* cmpwi CR6, R11, -1 */
		/* 8210F06Ch case   40:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210F06Ch case   40:*/		return 0x8210F070;
		  /* 8210F070h */ case   41:  		/* bc 12, CR6_EQ, 36 */
		/* 8210F070h case   41:*/		if ( regs.CR[6].eq ) { return 0x8210F094;  }
		/* 8210F070h case   41:*/		return 0x8210F074;
		  /* 8210F074h */ case   42:  		/* lwz R10, <#[R31 + 24]> */
		/* 8210F074h case   42:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 8210F074h case   42:*/		return 0x8210F078;
		  /* 8210F078h */ case   43:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210F078h case   43:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210F078h case   43:*/		return 0x8210F07C;
		  /* 8210F07Ch */ case   44:  		/* lis R9, 4112 */
		/* 8210F07Ch case   44:*/		cpu::op::lis<0>(regs,&regs.R9,0x1010);
		/* 8210F07Ch case   44:*/		return 0x8210F080;
		  /* 8210F080h */ case   45:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210F080h case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210F080h case   45:*/		return 0x8210F084;
		  /* 8210F084h */ case   46:  		/* lwz R11, <#[R11]> */
		/* 8210F084h case   46:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8210F084h case   46:*/		return 0x8210F088;
		  /* 8210F088h */ case   47:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 8210F088h case   47:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 8210F088h case   47:*/		return 0x8210F08C;
		  /* 8210F08Ch */ case   48:  		/* cmplw CR6, R11, R9 */
		/* 8210F08Ch case   48:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210F08Ch case   48:*/		return 0x8210F090;
		  /* 8210F090h */ case   49:  		/* bc 12, CR6_EQ, 208 */
		/* 8210F090h case   49:*/		if ( regs.CR[6].eq ) { return 0x8210F160;  }
		/* 8210F090h case   49:*/		return 0x8210F094;
	}
	return 0x8210F094;
} // Block from 8210EFCCh-8210F094h (50 instructions)

//////////////////////////////////////////////////////
// Block at 8210F094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F094);
		  /* 8210F094h */ case    0:  		/* lwz R11, <#[R8 + 48]> */
		/* 8210F094h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000030) );
		/* 8210F094h case    0:*/		return 0x8210F098;
		  /* 8210F098h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 8210F098h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210F098h case    1:*/		return 0x8210F09C;
		  /* 8210F09Ch */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8210F09Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8210F0A8;  }
		/* 8210F09Ch case    2:*/		return 0x8210F0A0;
		  /* 8210F0A0h */ case    3:  		/* stwx R11, <#[R30 + R7]> */
		/* 8210F0A0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + regs.R7 + 0x00000000) );
		/* 8210F0A0h case    3:*/		return 0x8210F0A4;
		  /* 8210F0A4h */ case    4:  		/* b 188 */
		/* 8210F0A4h case    4:*/		return 0x8210F160;
		/* 8210F0A4h case    4:*/		return 0x8210F0A8;
	}
	return 0x8210F0A8;
} // Block from 8210F094h-8210F0A8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210F0A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F0A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F0A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F0A8);
		  /* 8210F0A8h */ case    0:  		/* lwz R3, <#[R31 + 228]> */
		/* 8210F0A8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000E4) );
		/* 8210F0A8h case    0:*/		return 0x8210F0AC;
		  /* 8210F0ACh */ case    1:  		/* mr R6, R29 */
		/* 8210F0ACh case    1:*/		regs.R6 = regs.R29;
		/* 8210F0ACh case    1:*/		return 0x8210F0B0;
		  /* 8210F0B0h */ case    2:  		/* mr R5, R17 */
		/* 8210F0B0h case    2:*/		regs.R5 = regs.R17;
		/* 8210F0B0h case    2:*/		return 0x8210F0B4;
		  /* 8210F0B4h */ case    3:  		/* fmr FR1, FR31 */
		/* 8210F0B4h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8210F0B4h case    3:*/		return 0x8210F0B8;
		  /* 8210F0B8h */ case    4:  		/* lwz R4, <#[R3 + 132]> */
		/* 8210F0B8h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000084) );
		/* 8210F0B8h case    4:*/		return 0x8210F0BC;
		  /* 8210F0BCh */ case    5:  		/* bl -73364 */
		/* 8210F0BCh case    5:*/		regs.LR = 0x8210F0C0; return 0x820FD228;
		/* 8210F0BCh case    5:*/		return 0x8210F0C0;
		  /* 8210F0C0h */ case    6:  		/* mr R28, R3 */
		/* 8210F0C0h case    6:*/		regs.R28 = regs.R3;
		/* 8210F0C0h case    6:*/		return 0x8210F0C4;
		  /* 8210F0C4h */ case    7:  		/* cmpwi CR6, R3, -1 */
		/* 8210F0C4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8210F0C4h case    7:*/		return 0x8210F0C8;
		  /* 8210F0C8h */ case    8:  		/* bc 12, CR6_EQ, 968 */
		/* 8210F0C8h case    8:*/		if ( regs.CR[6].eq ) { return 0x8210F490;  }
		/* 8210F0C8h case    8:*/		return 0x8210F0CC;
		  /* 8210F0CCh */ case    9:  		/* lwz R11, <#[R23 + 16]> */
		/* 8210F0CCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000010) );
		/* 8210F0CCh case    9:*/		return 0x8210F0D0;
		  /* 8210F0D0h */ case   10:  		/* mr R6, R29 */
		/* 8210F0D0h case   10:*/		regs.R6 = regs.R29;
		/* 8210F0D0h case   10:*/		return 0x8210F0D4;
		  /* 8210F0D4h */ case   11:  		/* mr R5, R17 */
		/* 8210F0D4h case   11:*/		regs.R5 = regs.R17;
		/* 8210F0D4h case   11:*/		return 0x8210F0D8;
		  /* 8210F0D8h */ case   12:  		/* fmr FR1, FR31 */
		/* 8210F0D8h case   12:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8210F0D8h case   12:*/		return 0x8210F0DC;
		  /* 8210F0DCh */ case   13:  		/* mr R4, R14 */
		/* 8210F0DCh case   13:*/		regs.R4 = regs.R14;
		/* 8210F0DCh case   13:*/		return 0x8210F0E0;
		  /* 8210F0E0h */ case   14:  		/* mr R3, R31 */
		/* 8210F0E0h case   14:*/		regs.R3 = regs.R31;
		/* 8210F0E0h case   14:*/		return 0x8210F0E4;
		  /* 8210F0E4h */ case   15:  		/* stwx R28, <#[R11 + R27]> */
		/* 8210F0E4h case   15:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8210F0E4h case   15:*/		return 0x8210F0E8;
		  /* 8210F0E8h */ case   16:  		/* lwz R11, <#[R23 + 8]> */
		/* 8210F0E8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 8210F0E8h case   16:*/		return 0x8210F0EC;
		  /* 8210F0ECh */ case   17:  		/* stwx R26, <#[R11 + R27]> */
		/* 8210F0ECh case   17:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8210F0ECh case   17:*/		return 0x8210F0F0;
		  /* 8210F0F0h */ case   18:  		/* bl -73416 */
		/* 8210F0F0h case   18:*/		regs.LR = 0x8210F0F4; return 0x820FD228;
		/* 8210F0F0h case   18:*/		return 0x8210F0F4;
		  /* 8210F0F4h */ case   19:  		/* lwz R11, <#[R25 + 8]> */
		/* 8210F0F4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 8210F0F4h case   19:*/		return 0x8210F0F8;
		  /* 8210F0F8h */ case   20:  		/* stwx R3, <#[R30 + R11]> */
		/* 8210F0F8h case   20:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8210F0F8h case   20:*/		return 0x8210F0FC;
		  /* 8210F0FCh */ case   21:  		/* lwz R11, <#[R25 + 8]> */
		/* 8210F0FCh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 8210F0FCh case   21:*/		return 0x8210F100;
		  /* 8210F100h */ case   22:  		/* lwzx R11, <#[R30 + R11]> */
		/* 8210F100h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8210F100h case   22:*/		return 0x8210F104;
		  /* 8210F104h */ case   23:  		/* cmpwi CR6, R11, -1 */
		/* 8210F104h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210F104h case   23:*/		return 0x8210F108;
		  /* 8210F108h */ case   24:  		/* bc 12, CR6_EQ, 904 */
		/* 8210F108h case   24:*/		if ( regs.CR[6].eq ) { return 0x8210F490;  }
		/* 8210F108h case   24:*/		return 0x8210F10C;
		  /* 8210F10Ch */ case   25:  		/* lwz R11, <#[R25 + 8]> */
		/* 8210F10Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 8210F10Ch case   25:*/		return 0x8210F110;
		  /* 8210F110h */ case   26:  		/* lwz R10, <#[R31 + 20]> */
		/* 8210F110h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 8210F110h case   26:*/		return 0x8210F114;
		  /* 8210F114h */ case   27:  		/* lwzx R11, <#[R30 + R11]> */
		/* 8210F114h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8210F114h case   27:*/		return 0x8210F118;
		  /* 8210F118h */ case   28:  		/* lwzx R4, <#[R24 + R10]> */
		/* 8210F118h case   28:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R24 + regs.R10 + 0x00000000) );
		/* 8210F118h case   28:*/		return 0x8210F11C;
		  /* 8210F11Ch */ case   29:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210F11Ch case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210F11Ch case   29:*/		return 0x8210F120;
		  /* 8210F120h */ case   30:  		/* lwzx R26, <#[R11 + R10]> */
		/* 8210F120h case   30:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210F120h case   30:*/		return 0x8210F124;
		  /* 8210F124h */ case   31:  		/* mr R3, R26 */
		/* 8210F124h case   31:*/		regs.R3 = regs.R26;
		/* 8210F124h case   31:*/		return 0x8210F128;
		  /* 8210F128h */ case   32:  		/* bl -74888 */
		/* 8210F128h case   32:*/		regs.LR = 0x8210F12C; return 0x820FCCA0;
		/* 8210F128h case   32:*/		return 0x8210F12C;
		  /* 8210F12Ch */ case   33:  		/* li R11, 0 */
		/* 8210F12Ch case   33:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210F12Ch case   33:*/		return 0x8210F130;
		  /* 8210F130h */ case   34:  		/* stw R28, <#[R26 + 68]> */
		/* 8210F130h case   34:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R26 + 0x00000044) );
		/* 8210F130h case   34:*/		return 0x8210F134;
		  /* 8210F134h */ case   35:  		/* addi R29, R29, 1 */
		/* 8210F134h case   35:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8210F134h case   35:*/		return 0x8210F138;
		  /* 8210F138h */ case   36:  		/* stw R11, <#[R26 + 100]> */
		/* 8210F138h case   36:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000064) );
		/* 8210F138h case   36:*/		return 0x8210F13C;
		  /* 8210F13Ch */ case   37:  		/* addi R27, R27, 4 */
		/* 8210F13Ch case   37:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 8210F13Ch case   37:*/		return 0x8210F140;
		  /* 8210F140h */ case   38:  		/* stw R11, <#[R26 + 96]> */
		/* 8210F140h case   38:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000060) );
		/* 8210F140h case   38:*/		return 0x8210F144;
		  /* 8210F144h */ case   39:  		/* li R6, 1 */
		/* 8210F144h case   39:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8210F144h case   39:*/		return 0x8210F148;
		  /* 8210F148h */ case   40:  		/* lwz R10, <#[R31 + 20]> */
		/* 8210F148h case   40:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 8210F148h case   40:*/		return 0x8210F14C;
		  /* 8210F14Ch */ case   41:  		/* li R28, -1 */
		/* 8210F14Ch case   41:*/		cpu::op::li<0>(regs,&regs.R28,0xFFFFFFFF);
		/* 8210F14Ch case   41:*/		return 0x8210F150;
		  /* 8210F150h */ case   42:  		/* lwzx R10, <#[R24 + R10]> */
		/* 8210F150h case   42:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + regs.R10 + 0x00000000) );
		/* 8210F150h case   42:*/		return 0x8210F154;
		  /* 8210F154h */ case   43:  		/* lwz R11, <#[R25 + 8]> */
		/* 8210F154h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 8210F154h case   43:*/		return 0x8210F158;
		  /* 8210F158h */ case   44:  		/* lwzx R11, <#[R30 + R11]> */
		/* 8210F158h case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8210F158h case   44:*/		return 0x8210F15C;
		  /* 8210F15Ch */ case   45:  		/* stw R11, <#[R10 + 48]> */
		/* 8210F15Ch case   45:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000030) );
		/* 8210F15Ch case   45:*/		return 0x8210F160;
	}
	return 0x8210F160;
} // Block from 8210F0A8h-8210F160h (46 instructions)

//////////////////////////////////////////////////////
// Block at 8210F160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F160);
		  /* 8210F160h */ case    0:  		/* addi R22, R22, 1 */
		/* 8210F160h case    0:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 8210F160h case    0:*/		return 0x8210F164;
		  /* 8210F164h */ case    1:  		/* cmplw CR6, R22, R20 */
		/* 8210F164h case    1:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R20);
		/* 8210F164h case    1:*/		return 0x8210F168;
		  /* 8210F168h */ case    2:  		/* bc 12, CR6_LT, -332 */
		/* 8210F168h case    2:*/		if ( regs.CR[6].lt ) { return 0x8210F01C;  }
		/* 8210F168h case    2:*/		return 0x8210F16C;
		  /* 8210F16Ch */ case    3:  		/* cmplwi CR6, R29, 0 */
		/* 8210F16Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8210F16Ch case    3:*/		return 0x8210F170;
		  /* 8210F170h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 8210F170h case    4:*/		if ( regs.CR[6].eq ) { return 0x8210F180;  }
		/* 8210F170h case    4:*/		return 0x8210F174;
		  /* 8210F174h */ case    5:  		/* rlwinm R11, R29, 0, 12, 31 */
		/* 8210F174h case    5:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R29);
		/* 8210F174h case    5:*/		return 0x8210F178;
		  /* 8210F178h */ case    6:  		/* oris R11, R11, 4096 */
		/* 8210F178h case    6:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 8210F178h case    6:*/		return 0x8210F17C;
		  /* 8210F17Ch */ case    7:  		/* b 8 */
		/* 8210F17Ch case    7:*/		return 0x8210F184;
		/* 8210F17Ch case    7:*/		return 0x8210F180;
	}
	return 0x8210F180;
} // Block from 8210F160h-8210F180h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8210F180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F180);
		  /* 8210F180h */ case    0:  		/* li R11, 0 */
		/* 8210F180h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210F180h case    0:*/		return 0x8210F184;
	}
	return 0x8210F184;
} // Block from 8210F180h-8210F184h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210F184h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F184( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F184) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F184);
		  /* 8210F184h */ case    0:  		/* stw R11, <#[R23]> */
		/* 8210F184h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8210F184h case    0:*/		return 0x8210F188;
		  /* 8210F188h */ case    1:  		/* cmpwi CR6, R6, 0 */
		/* 8210F188h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 8210F188h case    1:*/		return 0x8210F18C;
		  /* 8210F18Ch */ case    2:  		/* stw R29, <#[R23 + 12]> */
		/* 8210F18Ch case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210F18Ch case    2:*/		return 0x8210F190;
		  /* 8210F190h */ case    3:  		/* stw R29, <#[R23 + 4]> */
		/* 8210F190h case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R23 + 0x00000004) );
		/* 8210F190h case    3:*/		return 0x8210F194;
		  /* 8210F194h */ case    4:  		/* bc 12, CR6_EQ, 8 */
		/* 8210F194h case    4:*/		if ( regs.CR[6].eq ) { return 0x8210F19C;  }
		/* 8210F194h case    4:*/		return 0x8210F198;
		  /* 8210F198h */ case    5:  		/* addi R17, R17, 1 */
		/* 8210F198h case    5:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 8210F198h case    5:*/		return 0x8210F19C;
	}
	return 0x8210F19C;
} // Block from 8210F184h-8210F19Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210F19Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F19C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F19C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F19C);
		  /* 8210F19Ch */ case    0:  		/* addi R19, R19, 1 */
		/* 8210F19Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x1);
		/* 8210F19Ch case    0:*/		return 0x8210F1A0;
		  /* 8210F1A0h */ case    1:  		/* add R21, R21, R20 */
		/* 8210F1A0h case    1:*/		cpu::op::add<0>(regs,&regs.R21,regs.R21,regs.R20);
		/* 8210F1A0h case    1:*/		return 0x8210F1A4;
		  /* 8210F1A4h */ case    2:  		/* cmplw CR6, R19, R18 */
		/* 8210F1A4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R19,regs.R18);
		/* 8210F1A4h case    2:*/		return 0x8210F1A8;
		  /* 8210F1A8h */ case    3:  		/* bc 12, CR6_LT, -636 */
		/* 8210F1A8h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210EF2C;  }
		/* 8210F1A8h case    3:*/		return 0x8210F1AC;
	}
	return 0x8210F1AC;
} // Block from 8210F19Ch-8210F1ACh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210F1ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F1AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F1AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F1AC);
		  /* 8210F1ACh */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210F1ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210F1ACh case    0:*/		return 0x8210F1B0;
	}
	return 0x8210F1B0;
} // Block from 8210F1ACh-8210F1B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210F1B0h
// Function '?GetArgumentName@CProgram@D3DXShader@@MAAXPAVCArgument@2@PADI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F1B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F1B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F1B0);
		  /* 8210F1B0h */ case    0:  		/* addi R16, R16, 1 */
		/* 8210F1B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R16,0x1);
		/* 8210F1B0h case    0:*/		return 0x8210F1B4;
		  /* 8210F1B4h */ case    1:  		/* addi R15, R15, 4 */
		/* 8210F1B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R15,regs.R15,0x4);
		/* 8210F1B4h case    1:*/		return 0x8210F1B8;
		  /* 8210F1B8h */ case    2:  		/* cmplw CR6, R16, R11 */
		/* 8210F1B8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R16,regs.R11);
		/* 8210F1B8h case    2:*/		return 0x8210F1BC;
		  /* 8210F1BCh */ case    3:  		/* bc 12, CR6_LT, -704 */
		/* 8210F1BCh case    3:*/		if ( regs.CR[6].lt ) { return 0x8210EEFC;  }
		/* 8210F1BCh case    3:*/		return 0x8210F1C0;
	}
	return 0x8210F1C0;
} // Block from 8210F1B0h-8210F1C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210F1C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F1C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F1C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F1C0);
		  /* 8210F1C0h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8210F1C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8210F1C0h case    0:*/		return 0x8210F1C4;
		  /* 8210F1C4h */ case    1:  		/* li R26, 0 */
		/* 8210F1C4h case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8210F1C4h case    1:*/		return 0x8210F1C8;
		  /* 8210F1C8h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8210F1C8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210F1C8h case    2:*/		return 0x8210F1CC;
		  /* 8210F1CCh */ case    3:  		/* bc 4, CR6_GT, 392 */
		/* 8210F1CCh case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210F354;  }
		/* 8210F1CCh case    3:*/		return 0x8210F1D0;
		  /* 8210F1D0h */ case    4:  		/* li R27, 0 */
		/* 8210F1D0h case    4:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8210F1D0h case    4:*/		return 0x8210F1D4;
		  /* 8210F1D4h */ case    5:  		/* li R25, 0 */
		/* 8210F1D4h case    5:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 8210F1D4h case    5:*/		return 0x8210F1D8;
		  /* 8210F1D8h */ case    6:  		/* lwz R11, <#[R31 + 20]> */
		/* 8210F1D8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8210F1D8h case    6:*/		return 0x8210F1DC;
		  /* 8210F1DCh */ case    7:  		/* lwzx R28, <#[R11 + R27]> */
		/* 8210F1DCh case    7:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8210F1DCh case    7:*/		return 0x8210F1E0;
		  /* 8210F1E0h */ case    8:  		/* lwz R4, <#[R28 + 8]> */
		/* 8210F1E0h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000008) );
		/* 8210F1E0h case    8:*/		return 0x8210F1E4;
		  /* 8210F1E4h */ case    9:  		/* cmpwi CR6, R4, -1 */
		/* 8210F1E4h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 8210F1E4h case    9:*/		return 0x8210F1E8;
		  /* 8210F1E8h */ case   10:  		/* bc 12, CR6_EQ, 340 */
		/* 8210F1E8h case   10:*/		if ( regs.CR[6].eq ) { return 0x8210F33C;  }
		/* 8210F1E8h case   10:*/		return 0x8210F1EC;
		  /* 8210F1ECh */ case   11:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 8210F1ECh case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 8210F1ECh case   11:*/		return 0x8210F1F0;
		  /* 8210F1F0h */ case   12:  		/* lwz R9, <#[R31 + 16]> */
		/* 8210F1F0h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 8210F1F0h case   12:*/		return 0x8210F1F4;
		  /* 8210F1F4h */ case   13:  		/* lwzx R29, <#[R10 + R11]> */
		/* 8210F1F4h case   13:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210F1F4h case   13:*/		return 0x8210F1F8;
		  /* 8210F1F8h */ case   14:  		/* lwz R11, <#[R29 + 4]> */
		/* 8210F1F8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8210F1F8h case   14:*/		return 0x8210F1FC;
		  /* 8210F1FCh */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210F1FCh case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210F1FCh case   15:*/		return 0x8210F200;
		  /* 8210F200h */ case   16:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210F200h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210F200h case   16:*/		return 0x8210F204;
		  /* 8210F204h */ case   17:  		/* lwz R11, <#[R11 + 4]> */
		/* 8210F204h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8210F204h case   17:*/		return 0x8210F208;
		  /* 8210F208h */ case   18:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 8210F208h case   18:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 8210F208h case   18:*/		return 0x8210F20C;
		  /* 8210F20Ch */ case   19:  		/* bc 12, CR0_EQ, 304 */
		/* 8210F20Ch case   19:*/		if ( regs.CR[0].eq ) { return 0x8210F33C;  }
		/* 8210F20Ch case   19:*/		return 0x8210F210;
		  /* 8210F210h */ case   20:  		/* mr R3, R31 */
		/* 8210F210h case   20:*/		regs.R3 = regs.R31;
		/* 8210F210h case   20:*/		return 0x8210F214;
		  /* 8210F214h */ case   21:  		/* bl -69692 */
		/* 8210F214h case   21:*/		regs.LR = 0x8210F218; return 0x820FE1D8;
		/* 8210F214h case   21:*/		return 0x8210F218;
		  /* 8210F218h */ case   22:  		/* cmpwi CR0, R3, 0 */
		/* 8210F218h case   22:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210F218h case   22:*/		return 0x8210F21C;
		  /* 8210F21Ch */ case   23:  		/* bc 4, CR0_EQ, 288 */
		/* 8210F21Ch case   23:*/		if ( !regs.CR[0].eq ) { return 0x8210F33C;  }
		/* 8210F21Ch case   23:*/		return 0x8210F220;
		  /* 8210F220h */ case   24:  		/* lwz R11, <#[R29 + 48]> */
		/* 8210F220h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 8210F220h case   24:*/		return 0x8210F224;
		  /* 8210F224h */ case   25:  		/* cmpwi CR6, R11, -1 */
		/* 8210F224h case   25:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210F224h case   25:*/		return 0x8210F228;
		  /* 8210F228h */ case   26:  		/* bc 4, CR6_EQ, 268 */
		/* 8210F228h case   26:*/		if ( !regs.CR[6].eq ) { return 0x8210F334;  }
		/* 8210F228h case   26:*/		return 0x8210F22C;
		  /* 8210F22Ch */ case   27:  		/* cmpwi CR6, R14, -1 */
		/* 8210F22Ch case   27:*/		cpu::op::cmpwi<6>(regs,regs.R14,0xFFFFFFFF);
		/* 8210F22Ch case   27:*/		return 0x8210F230;
		  /* 8210F230h */ case   28:  		/* bc 4, CR6_EQ, 44 */
		/* 8210F230h case   28:*/		if ( !regs.CR[6].eq ) { return 0x8210F25C;  }
		/* 8210F230h case   28:*/		return 0x8210F234;
		  /* 8210F234h */ case   29:  		/* lis R5, 8 */
		/* 8210F234h case   29:*/		cpu::op::lis<0>(regs,&regs.R5,0x8);
		/* 8210F234h case   29:*/		return 0x8210F238;
		  /* 8210F238h */ case   30:  		/* lwz R4, <#[R1 + 80]> */
		/* 8210F238h case   30:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 8210F238h case   30:*/		return 0x8210F23C;
		  /* 8210F23Ch */ case   31:  		/* li R7, 4 */
		/* 8210F23Ch case   31:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 8210F23Ch case   31:*/		return 0x8210F240;
		  /* 8210F240h */ case   32:  		/* li R6, -1 */
		/* 8210F240h case   32:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFF);
		/* 8210F240h case   32:*/		return 0x8210F244;
		  /* 8210F244h */ case   33:  		/* ori R5, R5, 593 */
		/* 8210F244h case   33:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x251);
		/* 8210F244h case   33:*/		return 0x8210F248;
		  /* 8210F248h */ case   34:  		/* mr R3, R31 */
		/* 8210F248h case   34:*/		regs.R3 = regs.R31;
		/* 8210F248h case   34:*/		return 0x8210F24C;
		  /* 8210F24Ch */ case   35:  		/* bl -73924 */
		/* 8210F24Ch case   35:*/		regs.LR = 0x8210F250; return 0x820FD188;
		/* 8210F24Ch case   35:*/		return 0x8210F250;
		  /* 8210F250h */ case   36:  		/* mr R14, R3 */
		/* 8210F250h case   36:*/		regs.R14 = regs.R3;
		/* 8210F250h case   36:*/		return 0x8210F254;
		  /* 8210F254h */ case   37:  		/* cmpwi CR6, R3, -1 */
		/* 8210F254h case   37:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8210F254h case   37:*/		return 0x8210F258;
		  /* 8210F258h */ case   38:  		/* bc 12, CR6_EQ, 568 */
		/* 8210F258h case   38:*/		if ( regs.CR[6].eq ) { return 0x8210F490;  }
		/* 8210F258h case   38:*/		return 0x8210F25C;
	}
	return 0x8210F25C;
} // Block from 8210F1C0h-8210F25Ch (39 instructions)

//////////////////////////////////////////////////////
// Block at 8210F25Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F25C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F25C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F25C);
		  /* 8210F25Ch */ case    0:  		/* lis R4, 4096 */
		/* 8210F25Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x1000);
		/* 8210F25Ch case    0:*/		return 0x8210F260;
		  /* 8210F260h */ case    1:  		/* lwz R3, <#[R31 + 228]> */
		/* 8210F260h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000E4) );
		/* 8210F260h case    1:*/		return 0x8210F264;
		  /* 8210F264h */ case    2:  		/* li R6, 1 */
		/* 8210F264h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8210F264h case    2:*/		return 0x8210F268;
		  /* 8210F268h */ case    3:  		/* li R5, 1 */
		/* 8210F268h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8210F268h case    3:*/		return 0x8210F26C;
		  /* 8210F26Ch */ case    4:  		/* ori R4, R4, 1 */
		/* 8210F26Ch case    4:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x1);
		/* 8210F26Ch case    4:*/		return 0x8210F270;
		  /* 8210F270h */ case    5:  		/* bl -73640 */
		/* 8210F270h case    5:*/		regs.LR = 0x8210F274; return 0x820FD2C8;
		/* 8210F270h case    5:*/		return 0x8210F274;
		  /* 8210F274h */ case    6:  		/* cmpwi CR6, R3, -1 */
		/* 8210F274h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8210F274h case    6:*/		return 0x8210F278;
		  /* 8210F278h */ case    7:  		/* bc 12, CR6_EQ, 536 */
		/* 8210F278h case    7:*/		if ( regs.CR[6].eq ) { return 0x8210F490;  }
		/* 8210F278h case    7:*/		return 0x8210F27C;
		  /* 8210F27Ch */ case    8:  		/* lwz R11, <#[R31 + 228]> */
		/* 8210F27Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8210F27Ch case    8:*/		return 0x8210F280;
		  /* 8210F280h */ case    9:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 8210F280h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 8210F280h case    9:*/		return 0x8210F284;
		  /* 8210F284h */ case   10:  		/* lwz R9, <#[R29 + 72]> */
		/* 8210F284h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000048) );
		/* 8210F284h case   10:*/		return 0x8210F288;
		  /* 8210F288h */ case   11:  		/* lwz R8, <#[R31 + 24]> */
		/* 8210F288h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000018) );
		/* 8210F288h case   11:*/		return 0x8210F28C;
		  /* 8210F28Ch */ case   12:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210F28Ch case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210F28Ch case   12:*/		return 0x8210F290;
		  /* 8210F290h */ case   13:  		/* lwz R11, <#[R11 + 24]> */
		/* 8210F290h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8210F290h case   13:*/		return 0x8210F294;
		  /* 8210F294h */ case   14:  		/* lwzx R4, <#[R9 + R8]> */
		/* 8210F294h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 8210F294h case   14:*/		return 0x8210F298;
	}
	return 0x8210F298;
} // Block from 8210F25Ch-8210F298h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8210F298h
// Function '?Error@CProgram@D3DXShader@@IAAJPAVCNode@2@IPBDZZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F298);
		  /* 8210F298h */ case    0:  		/* lwzx R30, <#[R10 + R11]> */
		/* 8210F298h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210F298h case    0:*/		return 0x8210F29C;
		  /* 8210F29Ch */ case    1:  		/* mr R3, R30 */
		/* 8210F29Ch case    1:*/		regs.R3 = regs.R30;
		/* 8210F29Ch case    1:*/		return 0x8210F2A0;
		  /* 8210F2A0h */ case    2:  		/* bl -78768 */
		/* 8210F2A0h case    2:*/		regs.LR = 0x8210F2A4; return 0x820FBEF0;
		/* 8210F2A0h case    2:*/		return 0x8210F2A4;
		  /* 8210F2A4h */ case    3:  		/* lwz R11, <#[R30 + 8]> */
		/* 8210F2A4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8210F2A4h case    3:*/		return 0x8210F2A8;
		  /* 8210F2A8h */ case    4:  		/* lwz R10, <#[R28 + 8]> */
		/* 8210F2A8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 8210F2A8h case    4:*/		return 0x8210F2AC;
		  /* 8210F2ACh */ case    5:  		/* li R6, 0 */
		/* 8210F2ACh case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8210F2ACh case    5:*/		return 0x8210F2B0;
		  /* 8210F2B0h */ case    6:  		/* mr R5, R17 */
		/* 8210F2B0h case    6:*/		regs.R5 = regs.R17;
		/* 8210F2B0h case    6:*/		return 0x8210F2B4;
		  /* 8210F2B4h */ case    7:  		/* fmr FR1, FR31 */
		/* 8210F2B4h case    7:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8210F2B4h case    7:*/		return 0x8210F2B8;
		  /* 8210F2B8h */ case    8:  		/* stw R10, <#[R11]> */
		/* 8210F2B8h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210F2B8h case    8:*/		return 0x8210F2BC;
		  /* 8210F2BCh */ case    9:  		/* lwz R3, <#[R31 + 228]> */
		/* 8210F2BCh case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000E4) );
		/* 8210F2BCh case    9:*/		return 0x8210F2C0;
		  /* 8210F2C0h */ case   10:  		/* lwz R4, <#[R3 + 132]> */
		/* 8210F2C0h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000084) );
		/* 8210F2C0h case   10:*/		return 0x8210F2C4;
		  /* 8210F2C4h */ case   11:  		/* bl -73884 */
		/* 8210F2C4h case   11:*/		regs.LR = 0x8210F2C8; return 0x820FD228;
		/* 8210F2C4h case   11:*/		return 0x8210F2C8;
		  /* 8210F2C8h */ case   12:  		/* lwz R11, <#[R30 + 16]> */
		/* 8210F2C8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8210F2C8h case   12:*/		return 0x8210F2CC;
		  /* 8210F2CCh */ case   13:  		/* stw R3, <#[R11]> */
		/* 8210F2CCh case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 8210F2CCh case   13:*/		return 0x8210F2D0;
		  /* 8210F2D0h */ case   14:  		/* lwz R11, <#[R30 + 16]> */
		/* 8210F2D0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8210F2D0h case   14:*/		return 0x8210F2D4;
		  /* 8210F2D4h */ case   15:  		/* lwz R11, <#[R11]> */
		/* 8210F2D4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8210F2D4h case   15:*/		return 0x8210F2D8;
		  /* 8210F2D8h */ case   16:  		/* cmpwi CR6, R11, -1 */
		/* 8210F2D8h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210F2D8h case   16:*/		return 0x8210F2DC;
		  /* 8210F2DCh */ case   17:  		/* bc 12, CR6_EQ, 436 */
		/* 8210F2DCh case   17:*/		if ( regs.CR[6].eq ) { return 0x8210F490;  }
		/* 8210F2DCh case   17:*/		return 0x8210F2E0;
		  /* 8210F2E0h */ case   18:  		/* li R6, 0 */
		/* 8210F2E0h case   18:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8210F2E0h case   18:*/		return 0x8210F2E4;
		  /* 8210F2E4h */ case   19:  		/* fmr FR1, FR31 */
		/* 8210F2E4h case   19:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8210F2E4h case   19:*/		return 0x8210F2E8;
		  /* 8210F2E8h */ case   20:  		/* mr R5, R17 */
		/* 8210F2E8h case   20:*/		regs.R5 = regs.R17;
		/* 8210F2E8h case   20:*/		return 0x8210F2EC;
		  /* 8210F2ECh */ case   21:  		/* mr R4, R14 */
		/* 8210F2ECh case   21:*/		regs.R4 = regs.R14;
		/* 8210F2ECh case   21:*/		return 0x8210F2F0;
		  /* 8210F2F0h */ case   22:  		/* mr R3, R31 */
		/* 8210F2F0h case   22:*/		regs.R3 = regs.R31;
		/* 8210F2F0h case   22:*/		return 0x8210F2F4;
		  /* 8210F2F4h */ case   23:  		/* bl -73932 */
		/* 8210F2F4h case   23:*/		regs.LR = 0x8210F2F8; return 0x820FD228;
		/* 8210F2F4h case   23:*/		return 0x8210F2F8;
		  /* 8210F2F8h */ case   24:  		/* stw R3, <#[R29 + 48]> */
		/* 8210F2F8h case   24:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000030) );
		/* 8210F2F8h case   24:*/		return 0x8210F2FC;
		  /* 8210F2FCh */ case   25:  		/* cmpwi CR6, R3, -1 */
		/* 8210F2FCh case   25:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8210F2FCh case   25:*/		return 0x8210F300;
		  /* 8210F300h */ case   26:  		/* bc 12, CR6_EQ, 400 */
		/* 8210F300h case   26:*/		if ( regs.CR[6].eq ) { return 0x8210F490;  }
		/* 8210F300h case   26:*/		return 0x8210F304;
		  /* 8210F304h */ case   27:  		/* lwz R11, <#[R31 + 20]> */
		/* 8210F304h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8210F304h case   27:*/		return 0x8210F308;
		  /* 8210F308h */ case   28:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 8210F308h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 8210F308h case   28:*/		return 0x8210F30C;
		  /* 8210F30Ch */ case   29:  		/* mr R4, R29 */
		/* 8210F30Ch case   29:*/		regs.R4 = regs.R29;
		/* 8210F30Ch case   29:*/		return 0x8210F310;
		  /* 8210F310h */ case   30:  		/* lwzx R24, <#[R10 + R11]> */
		/* 8210F310h case   30:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210F310h case   30:*/		return 0x8210F314;
		  /* 8210F314h */ case   31:  		/* mr R3, R24 */
		/* 8210F314h case   31:*/		regs.R3 = regs.R24;
		/* 8210F314h case   31:*/		return 0x8210F318;
		  /* 8210F318h */ case   32:  		/* bl -75384 */
		/* 8210F318h case   32:*/		regs.LR = 0x8210F31C; return 0x820FCCA0;
		/* 8210F318h case   32:*/		return 0x8210F31C;
		  /* 8210F31Ch */ case   33:  		/* lwz R11, <#[R30 + 16]> */
		/* 8210F31Ch case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8210F31Ch case   33:*/		return 0x8210F320;
		  /* 8210F320h */ case   34:  		/* addi R17, R17, 1 */
		/* 8210F320h case   34:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 8210F320h case   34:*/		return 0x8210F324;
		  /* 8210F324h */ case   35:  		/* lwz R11, <#[R11]> */
		/* 8210F324h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8210F324h case   35:*/		return 0x8210F328;
		  /* 8210F328h */ case   36:  		/* stw R25, <#[R24 + 96]> */
		/* 8210F328h case   36:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R24 + 0x00000060) );
		/* 8210F328h case   36:*/		return 0x8210F32C;
		  /* 8210F32Ch */ case   37:  		/* stw R25, <#[R24 + 100]> */
		/* 8210F32Ch case   37:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R24 + 0x00000064) );
		/* 8210F32Ch case   37:*/		return 0x8210F330;
		  /* 8210F330h */ case   38:  		/* stw R11, <#[R24 + 68]> */
		/* 8210F330h case   38:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x00000044) );
		/* 8210F330h case   38:*/		return 0x8210F334;
	}
	return 0x8210F334;
} // Block from 8210F298h-8210F334h (39 instructions)

//////////////////////////////////////////////////////
// Block at 8210F334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F334);
		  /* 8210F334h */ case    0:  		/* lwz R11, <#[R29 + 48]> */
		/* 8210F334h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 8210F334h case    0:*/		return 0x8210F338;
		  /* 8210F338h */ case    1:  		/* stw R11, <#[R28 + 8]> */
		/* 8210F338h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8210F338h case    1:*/		return 0x8210F33C;
	}
	return 0x8210F33C;
} // Block from 8210F334h-8210F33Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210F33Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F33C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F33C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F33C);
		  /* 8210F33Ch */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8210F33Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8210F33Ch case    0:*/		return 0x8210F340;
		  /* 8210F340h */ case    1:  		/* addi R26, R26, 1 */
		/* 8210F340h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 8210F340h case    1:*/		return 0x8210F344;
		  /* 8210F344h */ case    2:  		/* addi R27, R27, 4 */
		/* 8210F344h case    2:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 8210F344h case    2:*/		return 0x8210F348;
		  /* 8210F348h */ case    3:  		/* cmplw CR6, R26, R11 */
		/* 8210F348h case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 8210F348h case    3:*/		return 0x8210F34C;
		  /* 8210F34Ch */ case    4:  		/* bc 12, CR6_LT, -372 */
		/* 8210F34Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x8210F1D8;  }
		/* 8210F34Ch case    4:*/		return 0x8210F350;
		  /* 8210F350h */ case    5:  		/* li R28, -1 */
		/* 8210F350h case    5:*/		cpu::op::li<0>(regs,&regs.R28,0xFFFFFFFF);
		/* 8210F350h case    5:*/		return 0x8210F354;
	}
	return 0x8210F354;
} // Block from 8210F33Ch-8210F354h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210F354h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F354( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F354) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F354);
		  /* 8210F354h */ case    0:  		/* lwz R3, <#[R31 + 228]> */
		/* 8210F354h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000E4) );
		/* 8210F354h case    0:*/		return 0x8210F358;
	}
	return 0x8210F358;
} // Block from 8210F354h-8210F358h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210F358h
// Function '?Warning@CProgram@D3DXShader@@IAAJPAVCNode@2@IPBDZZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F358);
		  /* 8210F358h */ case    0:  		/* bl -33520 */
		/* 8210F358h case    0:*/		regs.LR = 0x8210F35C; return 0x82107068;
		/* 8210F358h case    0:*/		return 0x8210F35C;
		  /* 8210F35Ch */ case    1:  		/* cmpwi CR0, R3, 0 */
		/* 8210F35Ch case    1:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210F35Ch case    1:*/		return 0x8210F360;
		  /* 8210F360h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 8210F360h case    2:*/		if ( regs.CR[0].eq ) { return 0x8210F36C;  }
		/* 8210F360h case    2:*/		return 0x8210F364;
		  /* 8210F364h */ case    3:  		/* cmpwi CR6, R3, 0 */
		/* 8210F364h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8210F364h case    3:*/		return 0x8210F368;
		  /* 8210F368h */ case    4:  		/* bc 12, CR6_LT, 284 */
		/* 8210F368h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210F484;  }
		/* 8210F368h case    4:*/		return 0x8210F36C;
	}
	return 0x8210F36C;
} // Block from 8210F358h-8210F36Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210F36Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F36C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F36C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F36C);
		  /* 8210F36Ch */ case    0:  		/* lwz R3, <#[R31 + 228]> */
		/* 8210F36Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000E4) );
		/* 8210F36Ch case    0:*/		return 0x8210F370;
		  /* 8210F370h */ case    1:  		/* bl -55056 */
		/* 8210F370h case    1:*/		regs.LR = 0x8210F374; return 0x82101C60;
		/* 8210F370h case    1:*/		return 0x8210F374;
		  /* 8210F374h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 8210F374h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210F374h case    2:*/		return 0x8210F378;
		  /* 8210F378h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 8210F378h case    3:*/		if ( regs.CR[0].eq ) { return 0x8210F384;  }
		/* 8210F378h case    3:*/		return 0x8210F37C;
		  /* 8210F37Ch */ case    4:  		/* cmpwi CR6, R3, 0 */
		/* 8210F37Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8210F37Ch case    4:*/		return 0x8210F380;
		  /* 8210F380h */ case    5:  		/* bc 12, CR6_LT, 260 */
		/* 8210F380h case    5:*/		if ( regs.CR[6].lt ) { return 0x8210F484;  }
		/* 8210F380h case    5:*/		return 0x8210F384;
	}
	return 0x8210F384;
} // Block from 8210F36Ch-8210F384h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210F384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F384);
		  /* 8210F384h */ case    0:  		/* lwz R3, <#[R31 + 228]> */
		/* 8210F384h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000E4) );
		/* 8210F384h case    0:*/		return 0x8210F388;
		  /* 8210F388h */ case    1:  		/* bl -38896 */
		/* 8210F388h case    1:*/		regs.LR = 0x8210F38C; return 0x82105B98;
		/* 8210F388h case    1:*/		return 0x8210F38C;
		  /* 8210F38Ch */ case    2:  		/* mr R3, R31 */
		/* 8210F38Ch case    2:*/		regs.R3 = regs.R31;
		/* 8210F38Ch case    2:*/		return 0x8210F390;
		  /* 8210F390h */ case    3:  		/* bl -33576 */
		/* 8210F390h case    3:*/		regs.LR = 0x8210F394; return 0x82107068;
		/* 8210F390h case    3:*/		return 0x8210F394;
		  /* 8210F394h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 8210F394h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210F394h case    4:*/		return 0x8210F398;
		  /* 8210F398h */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 8210F398h case    5:*/		if ( regs.CR[0].eq ) { return 0x8210F3A4;  }
		/* 8210F398h case    5:*/		return 0x8210F39C;
		  /* 8210F39Ch */ case    6:  		/* cmpwi CR6, R3, 0 */
		/* 8210F39Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8210F39Ch case    6:*/		return 0x8210F3A0;
		  /* 8210F3A0h */ case    7:  		/* bc 12, CR6_LT, 228 */
		/* 8210F3A0h case    7:*/		if ( regs.CR[6].lt ) { return 0x8210F484;  }
		/* 8210F3A0h case    7:*/		return 0x8210F3A4;
	}
	return 0x8210F3A4;
} // Block from 8210F384h-8210F3A4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8210F3A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F3A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F3A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F3A4);
		  /* 8210F3A4h */ case    0:  		/* mr R3, R31 */
		/* 8210F3A4h case    0:*/		regs.R3 = regs.R31;
		/* 8210F3A4h case    0:*/		return 0x8210F3A8;
		  /* 8210F3A8h */ case    1:  		/* bl -55112 */
		/* 8210F3A8h case    1:*/		regs.LR = 0x8210F3AC; return 0x82101C60;
		/* 8210F3A8h case    1:*/		return 0x8210F3AC;
		  /* 8210F3ACh */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 8210F3ACh case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210F3ACh case    2:*/		return 0x8210F3B0;
		  /* 8210F3B0h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 8210F3B0h case    3:*/		if ( regs.CR[0].eq ) { return 0x8210F3BC;  }
		/* 8210F3B0h case    3:*/		return 0x8210F3B4;
		  /* 8210F3B4h */ case    4:  		/* cmpwi CR6, R3, 0 */
		/* 8210F3B4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8210F3B4h case    4:*/		return 0x8210F3B8;
		  /* 8210F3B8h */ case    5:  		/* bc 12, CR6_LT, 204 */
		/* 8210F3B8h case    5:*/		if ( regs.CR[6].lt ) { return 0x8210F484;  }
		/* 8210F3B8h case    5:*/		return 0x8210F3BC;
	}
	return 0x8210F3BC;
} // Block from 8210F3A4h-8210F3BCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210F3BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F3BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F3BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F3BC);
		  /* 8210F3BCh */ case    0:  		/* mr R3, R31 */
		/* 8210F3BCh case    0:*/		regs.R3 = regs.R31;
		/* 8210F3BCh case    0:*/		return 0x8210F3C0;
		  /* 8210F3C0h */ case    1:  		/* bl -21008 */
		/* 8210F3C0h case    1:*/		regs.LR = 0x8210F3C4; return 0x8210A1B0;
		/* 8210F3C0h case    1:*/		return 0x8210F3C4;
		  /* 8210F3C4h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 8210F3C4h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210F3C4h case    2:*/		return 0x8210F3C8;
		  /* 8210F3C8h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 8210F3C8h case    3:*/		if ( regs.CR[0].eq ) { return 0x8210F3D4;  }
		/* 8210F3C8h case    3:*/		return 0x8210F3CC;
		  /* 8210F3CCh */ case    4:  		/* cmpwi CR6, R3, 0 */
		/* 8210F3CCh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8210F3CCh case    4:*/		return 0x8210F3D0;
		  /* 8210F3D0h */ case    5:  		/* bc 12, CR6_LT, 180 */
		/* 8210F3D0h case    5:*/		if ( regs.CR[6].lt ) { return 0x8210F484;  }
		/* 8210F3D0h case    5:*/		return 0x8210F3D4;
	}
	return 0x8210F3D4;
} // Block from 8210F3BCh-8210F3D4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210F3D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F3D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F3D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F3D4);
		  /* 8210F3D4h */ case    0:  		/* cmpwi CR6, R14, -1 */
		/* 8210F3D4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0xFFFFFFFF);
		/* 8210F3D4h case    0:*/		return 0x8210F3D8;
		  /* 8210F3D8h */ case    1:  		/* bc 12, CR6_EQ, 168 */
		/* 8210F3D8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8210F480;  }
		/* 8210F3D8h case    1:*/		return 0x8210F3DC;
		  /* 8210F3DCh */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 8210F3DCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8210F3DCh case    2:*/		return 0x8210F3E0;
		  /* 8210F3E0h */ case    3:  		/* mr R6, R28 */
		/* 8210F3E0h case    3:*/		regs.R6 = regs.R28;
		/* 8210F3E0h case    3:*/		return 0x8210F3E4;
		  /* 8210F3E4h */ case    4:  		/* li R8, 0 */
		/* 8210F3E4h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8210F3E4h case    4:*/		return 0x8210F3E8;
		  /* 8210F3E8h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8210F3E8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210F3E8h case    5:*/		return 0x8210F3EC;
		  /* 8210F3ECh */ case    6:  		/* bc 4, CR6_GT, 148 */
		/* 8210F3ECh case    6:*/		if ( !regs.CR[6].gt ) { return 0x8210F480;  }
		/* 8210F3ECh case    6:*/		return 0x8210F3F0;
		  /* 8210F3F0h */ case    7:  		/* lwz R9, <#[R31 + 20]> */
		/* 8210F3F0h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 8210F3F0h case    7:*/		return 0x8210F3F4;
		  /* 8210F3F4h */ case    8:  		/* rlwinm R7, R11, 0, 0, 31 */
		/* 8210F3F4h case    8:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R7,regs.R11);
		/* 8210F3F4h case    8:*/		return 0x8210F3F8;
		  /* 8210F3F8h */ case    9:  		/* li R10, 0 */
		/* 8210F3F8h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210F3F8h case    9:*/		return 0x8210F3FC;
		  /* 8210F3FCh */ case   10:  		/* lwzx R11, <#[R9 + R10]> */
		/* 8210F3FCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210F3FCh case   10:*/		return 0x8210F400;
		  /* 8210F400h */ case   11:  		/* lwz R5, <#[R11 + 4]> */
		/* 8210F400h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000004) );
		/* 8210F400h case   11:*/		return 0x8210F404;
		  /* 8210F404h */ case   12:  		/* cmplw CR6, R5, R14 */
		/* 8210F404h case   12:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R14);
		/* 8210F404h case   12:*/		return 0x8210F408;
		  /* 8210F408h */ case   13:  		/* bc 4, CR6_EQ, 20 */
		/* 8210F408h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8210F41C;  }
		/* 8210F408h case   13:*/		return 0x8210F40C;
		  /* 8210F40Ch */ case   14:  		/* lwz R11, <#[R11 + 12]> */
		/* 8210F40Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210F40Ch case   14:*/		return 0x8210F410;
	}
	return 0x8210F410;
} // Block from 8210F3D4h-8210F410h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8210F410h
// Function '?Validate@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F410);
		  /* 8210F410h */ case    0:  		/* cmplw CR6, R6, R11 */
		/* 8210F410h case    0:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 8210F410h case    0:*/		return 0x8210F414;
		  /* 8210F414h */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 8210F414h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8210F41C;  }
		/* 8210F414h case    1:*/		return 0x8210F418;
		  /* 8210F418h */ case    2:  		/* mr R6, R11 */
		/* 8210F418h case    2:*/		regs.R6 = regs.R11;
		/* 8210F418h case    2:*/		return 0x8210F41C;
	}
	return 0x8210F41C;
} // Block from 8210F410h-8210F41Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210F41Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F41C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F41C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F41C);
		  /* 8210F41Ch */ case    0:  		/* addi R8, R8, 1 */
		/* 8210F41Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8210F41Ch case    0:*/		return 0x8210F420;
		  /* 8210F420h */ case    1:  		/* addi R10, R10, 4 */
		/* 8210F420h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210F420h case    1:*/		return 0x8210F424;
		  /* 8210F424h */ case    2:  		/* cmplw CR6, R8, R7 */
		/* 8210F424h case    2:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 8210F424h case    2:*/		return 0x8210F428;
		  /* 8210F428h */ case    3:  		/* bc 12, CR6_LT, -44 */
		/* 8210F428h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210F3FC;  }
		/* 8210F428h case    3:*/		return 0x8210F42C;
		  /* 8210F42Ch */ case    4:  		/* cmpwi CR6, R6, -1 */
		/* 8210F42Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R6,0xFFFFFFFF);
		/* 8210F42Ch case    4:*/		return 0x8210F430;
		  /* 8210F430h */ case    5:  		/* bc 12, CR6_EQ, 80 */
		/* 8210F430h case    5:*/		if ( regs.CR[6].eq ) { return 0x8210F480;  }
		/* 8210F430h case    5:*/		return 0x8210F434;
		  /* 8210F434h */ case    6:  		/* li R8, 0 */
		/* 8210F434h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8210F434h case    6:*/		return 0x8210F438;
		  /* 8210F438h */ case    7:  		/* li R11, 0 */
		/* 8210F438h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210F438h case    7:*/		return 0x8210F43C;
		  /* 8210F43Ch */ case    8:  		/* lwz R10, <#[R31 + 20]> */
		/* 8210F43Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 8210F43Ch case    8:*/		return 0x8210F440;
		  /* 8210F440h */ case    9:  		/* lwzx R9, <#[R10 + R11]> */
		/* 8210F440h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210F440h case    9:*/		return 0x8210F444;
		  /* 8210F444h */ case   10:  		/* lwz R7, <#[R9 + 4]> */
		/* 8210F444h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000004) );
		/* 8210F444h case   10:*/		return 0x8210F448;
		  /* 8210F448h */ case   11:  		/* cmplw CR6, R7, R14 */
		/* 8210F448h case   11:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R14);
		/* 8210F448h case   11:*/		return 0x8210F44C;
		  /* 8210F44Ch */ case   12:  		/* bc 4, CR6_EQ, 32 */
		/* 8210F44Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x8210F46C;  }
		/* 8210F44Ch case   12:*/		return 0x8210F450;
		  /* 8210F450h */ case   13:  		/* lwz R9, <#[R9 + 12]> */
		/* 8210F450h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000000C) );
		/* 8210F450h case   13:*/		return 0x8210F454;
		  /* 8210F454h */ case   14:  		/* cmpwi CR6, R9, -1 */
		/* 8210F454h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 8210F454h case   14:*/		return 0x8210F458;
		  /* 8210F458h */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 8210F458h case   15:*/		if ( regs.CR[6].eq ) { return 0x8210F46C;  }
		/* 8210F458h case   15:*/		return 0x8210F45C;
		  /* 8210F45Ch */ case   16:  		/* lwzx R10, <#[R10 + R11]> */
		/* 8210F45Ch case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210F45Ch case   16:*/		return 0x8210F460;
		  /* 8210F460h */ case   17:  		/* lwz R9, <#[R10 + 12]> */
		/* 8210F460h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 8210F460h case   17:*/		return 0x8210F464;
		  /* 8210F464h */ case   18:  		/* subf R9, R6, R9 */
		/* 8210F464h case   18:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R6,regs.R9);
		/* 8210F464h case   18:*/		return 0x8210F468;
		  /* 8210F468h */ case   19:  		/* stw R9, <#[R10 + 12]> */
		/* 8210F468h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 8210F468h case   19:*/		return 0x8210F46C;
	}
	return 0x8210F46C;
} // Block from 8210F41Ch-8210F46Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 8210F46Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F46C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F46C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F46C);
		  /* 8210F46Ch */ case    0:  		/* lwz R10, <#[R31 + 8]> */
		/* 8210F46Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8210F46Ch case    0:*/		return 0x8210F470;
		  /* 8210F470h */ case    1:  		/* addi R8, R8, 1 */
		/* 8210F470h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8210F470h case    1:*/		return 0x8210F474;
		  /* 8210F474h */ case    2:  		/* addi R11, R11, 4 */
		/* 8210F474h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210F474h case    2:*/		return 0x8210F478;
		  /* 8210F478h */ case    3:  		/* cmplw CR6, R8, R10 */
		/* 8210F478h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 8210F478h case    3:*/		return 0x8210F47C;
		  /* 8210F47Ch */ case    4:  		/* bc 12, CR6_LT, -64 */
		/* 8210F47Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x8210F43C;  }
		/* 8210F47Ch case    4:*/		return 0x8210F480;
	}
	return 0x8210F480;
} // Block from 8210F46Ch-8210F480h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210F480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F480);
		  /* 8210F480h */ case    0:  		/* li R3, 0 */
		/* 8210F480h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8210F480h case    0:*/		return 0x8210F484;
	}
	return 0x8210F484;
} // Block from 8210F480h-8210F484h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210F484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F484);
		  /* 8210F484h */ case    0:  		/* addi R1, R1, 256 */
		/* 8210F484h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 8210F484h case    0:*/		return 0x8210F488;
		  /* 8210F488h */ case    1:  		/* lfd FR31, <#[R1 - 160]> */
		/* 8210F488h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8210F488h case    1:*/		return 0x8210F48C;
		  /* 8210F48Ch */ case    2:  		/* b -516636 */
		/* 8210F48Ch case    2:*/		return 0x82091270;
		/* 8210F48Ch case    2:*/		return 0x8210F490;
	}
	return 0x8210F490;
} // Block from 8210F484h-8210F490h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210F490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F490);
		  /* 8210F490h */ case    0:  		/* lis R3, -32761 */
		/* 8210F490h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 8210F490h case    0:*/		return 0x8210F494;
		  /* 8210F494h */ case    1:  		/* ori R3, R3, 14 */
		/* 8210F494h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 8210F494h case    1:*/		return 0x8210F498;
		  /* 8210F498h */ case    2:  		/* b -20 */
		/* 8210F498h case    2:*/		return 0x8210F484;
		/* 8210F498h case    2:*/		return 0x8210F49C;
		  /* 8210F49Ch */ case    3:  		/* nop */
		/* 8210F49Ch case    3:*/		cpu::op::nop();
		/* 8210F49Ch case    3:*/		return 0x8210F4A0;
	}
	return 0x8210F4A0;
} // Block from 8210F490h-8210F4A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210F4A0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F4A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F4A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F4A0);
		  /* 8210F4A0h */ case    0:  		/* lwz R11, <#[R3 + 228]> */
		/* 8210F4A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 8210F4A0h case    0:*/		return 0x8210F4A4;
		  /* 8210F4A4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8210F4A4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210F4A4h case    1:*/		return 0x8210F4A8;
		  /* 8210F4A8h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 8210F4A8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8210F4B4;  }
		/* 8210F4A8h case    2:*/		return 0x8210F4AC;
		  /* 8210F4ACh */ case    3:  		/* li R3, 1 */
		/* 8210F4ACh case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8210F4ACh case    3:*/		return 0x8210F4B0;
		  /* 8210F4B0h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8210F4B0h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8210F4B0h case    4:*/		return 0x8210F4B4;
	}
	return 0x8210F4B4;
} // Block from 8210F4A0h-8210F4B4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210F4B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F4B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F4B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F4B4);
		  /* 8210F4B4h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 8210F4B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8210F4B4h case    0:*/		return 0x8210F4B8;
		  /* 8210F4B8h */ case    1:  		/* li R10, 0 */
		/* 8210F4B8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210F4B8h case    1:*/		return 0x8210F4BC;
		  /* 8210F4BCh */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8210F4BCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210F4BCh case    2:*/		return 0x8210F4C0;
		  /* 8210F4C0h */ case    3:  		/* bc 4, CR6_GT, 100 */
		/* 8210F4C0h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210F524;  }
		/* 8210F4C0h case    3:*/		return 0x8210F4C4;
		  /* 8210F4C4h */ case    4:  		/* li R9, 0 */
		/* 8210F4C4h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8210F4C4h case    4:*/		return 0x8210F4C8;
		  /* 8210F4C8h */ case    5:  		/* lwz R11, <#[R3 + 20]> */
		/* 8210F4C8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 8210F4C8h case    5:*/		return 0x8210F4CC;
		  /* 8210F4CCh */ case    6:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210F4CCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210F4CCh case    6:*/		return 0x8210F4D0;
		  /* 8210F4D0h */ case    7:  		/* lwz R8, <#[R11 + 68]> */
		/* 8210F4D0h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000044) );
		/* 8210F4D0h case    7:*/		return 0x8210F4D4;
		  /* 8210F4D4h */ case    8:  		/* cmpwi CR6, R8, -1 */
		/* 8210F4D4h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 8210F4D4h case    8:*/		return 0x8210F4D8;
		  /* 8210F4D8h */ case    9:  		/* bc 12, CR6_EQ, 56 */
		/* 8210F4D8h case    9:*/		if ( regs.CR[6].eq ) { return 0x8210F510;  }
		/* 8210F4D8h case    9:*/		return 0x8210F4DC;
		  /* 8210F4DCh */ case   10:  		/* lwz R8, <#[R3 + 228]> */
		/* 8210F4DCh case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x000000E4) );
		/* 8210F4DCh case   10:*/		return 0x8210F4E0;
		  /* 8210F4E0h */ case   11:  		/* lwz R7, <#[R11 + 68]> */
		/* 8210F4E0h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000044) );
		/* 8210F4E0h case   11:*/		return 0x8210F4E4;
		  /* 8210F4E4h */ case   12:  		/* lwz R6, <#[R11 + 12]> */
		/* 8210F4E4h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210F4E4h case   12:*/		return 0x8210F4E8;
		  /* 8210F4E8h */ case   13:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 8210F4E8h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 8210F4E8h case   13:*/		return 0x8210F4EC;
		  /* 8210F4ECh */ case   14:  		/* lwz R8, <#[R8 + 20]> */
		/* 8210F4ECh case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000014) );
		/* 8210F4ECh case   14:*/		return 0x8210F4F0;
		  /* 8210F4F0h */ case   15:  		/* lwzx R8, <#[R7 + R8]> */
		/* 8210F4F0h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 8210F4F0h case   15:*/		return 0x8210F4F4;
		  /* 8210F4F4h */ case   16:  		/* stw R6, <#[R8 + 12]> */
		/* 8210F4F4h case   16:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R8 + 0x0000000C) );
		/* 8210F4F4h case   16:*/		return 0x8210F4F8;
		  /* 8210F4F8h */ case   17:  		/* lwz R8, <#[R3 + 228]> */
		/* 8210F4F8h case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x000000E4) );
		/* 8210F4F8h case   17:*/		return 0x8210F4FC;
		  /* 8210F4FCh */ case   18:  		/* lwz R11, <#[R11 + 68]> */
		/* 8210F4FCh case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000044) );
		/* 8210F4FCh case   18:*/		return 0x8210F500;
		  /* 8210F500h */ case   19:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210F500h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210F500h case   19:*/		return 0x8210F504;
		  /* 8210F504h */ case   20:  		/* lwz R8, <#[R8 + 20]> */
		/* 8210F504h case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000014) );
		/* 8210F504h case   20:*/		return 0x8210F508;
		  /* 8210F508h */ case   21:  		/* lwzx R11, <#[R11 + R8]> */
		/* 8210F508h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8210F508h case   21:*/		return 0x8210F50C;
		  /* 8210F50Ch */ case   22:  		/* stw R10, <#[R11 + 68]> */
		/* 8210F50Ch case   22:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000044) );
		/* 8210F50Ch case   22:*/		return 0x8210F510;
	}
	return 0x8210F510;
} // Block from 8210F4B4h-8210F510h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8210F510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F510);
		  /* 8210F510h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 8210F510h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8210F510h case    0:*/		return 0x8210F514;
		  /* 8210F514h */ case    1:  		/* addi R10, R10, 1 */
		/* 8210F514h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210F514h case    1:*/		return 0x8210F518;
		  /* 8210F518h */ case    2:  		/* addi R9, R9, 4 */
		/* 8210F518h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8210F518h case    2:*/		return 0x8210F51C;
		  /* 8210F51Ch */ case    3:  		/* cmplw CR6, R10, R11 */
		/* 8210F51Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8210F51Ch case    3:*/		return 0x8210F520;
		  /* 8210F520h */ case    4:  		/* bc 12, CR6_LT, -88 */
		/* 8210F520h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210F4C8;  }
		/* 8210F520h case    4:*/		return 0x8210F524;
	}
	return 0x8210F524;
} // Block from 8210F510h-8210F524h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210F524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F524);
		  /* 8210F524h */ case    0:  		/* lwz R3, <#[R3 + 228]> */
		/* 8210F524h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x000000E4) );
		/* 8210F524h case    0:*/		return 0x8210F528;
		  /* 8210F528h */ case    1:  		/* b -35496 */
		/* 8210F528h case    1:*/		return 0x82106A80;
		/* 8210F528h case    1:*/		return 0x8210F52C;
		  /* 8210F52Ch */ case    2:  		/* nop */
		/* 8210F52Ch case    2:*/		cpu::op::nop();
		/* 8210F52Ch case    2:*/		return 0x8210F530;
	}
	return 0x8210F530;
} // Block from 8210F524h-8210F530h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210F530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F530);
		  /* 8210F530h */ case    0:  		/* mfspr R12, LR */
		/* 8210F530h case    0:*/		regs.R12 = regs.LR;
		/* 8210F530h case    0:*/		return 0x8210F534;
		  /* 8210F534h */ case    1:  		/* bl -516884 */
		/* 8210F534h case    1:*/		regs.LR = 0x8210F538; return 0x82091220;
		/* 8210F534h case    1:*/		return 0x8210F538;
		  /* 8210F538h */ case    2:  		/* addi R12, R1, -152 */
		/* 8210F538h case    2:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFF68);
		/* 8210F538h case    2:*/		return 0x8210F53C;
		  /* 8210F53Ch */ case    3:  		/* bl -516388 */
		/* 8210F53Ch case    3:*/		regs.LR = 0x8210F540; return 0x82091418;
		/* 8210F53Ch case    3:*/		return 0x8210F540;
		  /* 8210F540h */ case    4:  		/* stwu R1, <#[R1 - 352]> */
		/* 8210F540h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEA0);
		/* 8210F540h case    4:*/		return 0x8210F544;
		  /* 8210F544h */ case    5:  		/* li R26, 0 */
		/* 8210F544h case    5:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8210F544h case    5:*/		return 0x8210F548;
		  /* 8210F548h */ case    6:  		/* stw R3, <#[R1 + 372]> */
		/* 8210F548h case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000174) );
		/* 8210F548h case    6:*/		return 0x8210F54C;
		  /* 8210F54Ch */ case    7:  		/* li R25, -1 */
		/* 8210F54Ch case    7:*/		cpu::op::li<0>(regs,&regs.R25,0xFFFFFFFF);
		/* 8210F54Ch case    7:*/		return 0x8210F550;
		  /* 8210F550h */ case    8:  		/* mr R29, R3 */
		/* 8210F550h case    8:*/		regs.R29 = regs.R3;
		/* 8210F550h case    8:*/		return 0x8210F554;
		  /* 8210F554h */ case    9:  		/* stw R26, <#[R1 + 92]> */
		/* 8210F554h case    9:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x0000005C) );
		/* 8210F554h case    9:*/		return 0x8210F558;
		  /* 8210F558h */ case   10:  		/* stw R26, <#[R1 + 88]> */
		/* 8210F558h case   10:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000058) );
		/* 8210F558h case   10:*/		return 0x8210F55C;
		  /* 8210F55Ch */ case   11:  		/* stw R26, <#[R1 + 96]> */
		/* 8210F55Ch case   11:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000060) );
		/* 8210F55Ch case   11:*/		return 0x8210F560;
		  /* 8210F560h */ case   12:  		/* stw R25, <#[R1 + 104]> */
		/* 8210F560h case   12:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000068) );
		/* 8210F560h case   12:*/		return 0x8210F564;
		  /* 8210F564h */ case   13:  		/* stw R25, <#[R1 + 108]> */
		/* 8210F564h case   13:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x0000006C) );
		/* 8210F564h case   13:*/		return 0x8210F568;
		  /* 8210F568h */ case   14:  		/* bl -39376 */
		/* 8210F568h case   14:*/		regs.LR = 0x8210F56C; return 0x82105B98;
		/* 8210F568h case   14:*/		return 0x8210F56C;
		  /* 8210F56Ch */ case   15:  		/* lwz R10, <#[R29 + 8]> */
		/* 8210F56Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 8210F56Ch case   15:*/		return 0x8210F570;
		  /* 8210F570h */ case   16:  		/* mr R11, R26 */
		/* 8210F570h case   16:*/		regs.R11 = regs.R26;
		/* 8210F570h case   16:*/		return 0x8210F574;
		  /* 8210F574h */ case   17:  		/* stw R26, <#[R1 + 80]> */
		/* 8210F574h case   17:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 8210F574h case   17:*/		return 0x8210F578;
		  /* 8210F578h */ case   18:  		/* cmplwi CR6, R10, 0 */
		/* 8210F578h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8210F578h case   18:*/		return 0x8210F57C;
		  /* 8210F57Ch */ case   19:  		/* bc 4, CR6_GT, 40 */
		/* 8210F57Ch case   19:*/		if ( !regs.CR[6].gt ) { return 0x8210F5A4;  }
		/* 8210F57Ch case   19:*/		return 0x8210F580;
		  /* 8210F580h */ case   20:  		/* mr R10, R26 */
		/* 8210F580h case   20:*/		regs.R10 = regs.R26;
		/* 8210F580h case   20:*/		return 0x8210F584;
		  /* 8210F584h */ case   21:  		/* lwz R9, <#[R29 + 20]> */
		/* 8210F584h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000014) );
		/* 8210F584h case   21:*/		return 0x8210F588;
		  /* 8210F588h */ case   22:  		/* addi R11, R11, 1 */
		/* 8210F588h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210F588h case   22:*/		return 0x8210F58C;
		  /* 8210F58Ch */ case   23:  		/* lwzx R9, <#[R10 + R9]> */
		/* 8210F58Ch case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210F58Ch case   23:*/		return 0x8210F590;
		  /* 8210F590h */ case   24:  		/* addi R10, R10, 4 */
		/* 8210F590h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210F590h case   24:*/		return 0x8210F594;
		  /* 8210F594h */ case   25:  		/* stw R25, <#[R9 + 64]> */
		/* 8210F594h case   25:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R9 + 0x00000040) );
		/* 8210F594h case   25:*/		return 0x8210F598;
		  /* 8210F598h */ case   26:  		/* lwz R9, <#[R29 + 8]> */
		/* 8210F598h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 8210F598h case   26:*/		return 0x8210F59C;
		  /* 8210F59Ch */ case   27:  		/* cmplw CR6, R11, R9 */
		/* 8210F59Ch case   27:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210F59Ch case   27:*/		return 0x8210F5A0;
		  /* 8210F5A0h */ case   28:  		/* bc 12, CR6_LT, -28 */
		/* 8210F5A0h case   28:*/		if ( regs.CR[6].lt ) { return 0x8210F584;  }
		/* 8210F5A0h case   28:*/		return 0x8210F5A4;
	}
	return 0x8210F5A4;
} // Block from 8210F530h-8210F5A4h (29 instructions)

//////////////////////////////////////////////////////
// Block at 8210F5A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F5A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F5A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F5A4);
		  /* 8210F5A4h */ case    0:  		/* lis R11, -32256 */
		/* 8210F5A4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8210F5A4h case    0:*/		return 0x8210F5A8;
		  /* 8210F5A8h */ case    1:  		/* lwz R10, <#[R29 + 12]> */
		/* 8210F5A8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000000C) );
		/* 8210F5A8h case    1:*/		return 0x8210F5AC;
		  /* 8210F5ACh */ case    2:  		/* mr R14, R26 */
		/* 8210F5ACh case    2:*/		regs.R14 = regs.R26;
		/* 8210F5ACh case    2:*/		return 0x8210F5B0;
		  /* 8210F5B0h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 8210F5B0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8210F5B0h case    3:*/		return 0x8210F5B4;
		  /* 8210F5B4h */ case    4:  		/* lfd FR30, <#[R11 + 1808]> */
		/* 8210F5B4h case    4:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R11 + 0x00000710) );
		/* 8210F5B4h case    4:*/		return 0x8210F5B8;
		  /* 8210F5B8h */ case    5:  		/* bc 4, CR6_GT, 1340 */
		/* 8210F5B8h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8210FAF4;  }
		/* 8210F5B8h case    5:*/		return 0x8210F5BC;
		  /* 8210F5BCh */ case    6:  		/* mr R15, R26 */
		/* 8210F5BCh case    6:*/		regs.R15 = regs.R26;
		/* 8210F5BCh case    6:*/		return 0x8210F5C0;
		  /* 8210F5C0h */ case    7:  		/* lwz R11, <#[R29 + 24]> */
		/* 8210F5C0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 8210F5C0h case    7:*/		return 0x8210F5C4;
		  /* 8210F5C4h */ case    8:  		/* lwzx R22, <#[R11 + R15]> */
		/* 8210F5C4h case    8:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R11 + regs.R15 + 0x00000000) );
		/* 8210F5C4h case    8:*/		return 0x8210F5C8;
		  /* 8210F5C8h */ case    9:  		/* lwz R11, <#[R22]> */
		/* 8210F5C8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 8210F5C8h case    9:*/		return 0x8210F5CC;
		  /* 8210F5CCh */ case   10:  		/* rlwinm. R10, R11, 0, 0, 11 */
		/* 8210F5CCh case   10:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R10,regs.R11);
		/* 8210F5CCh case   10:*/		return 0x8210F5D0;
		  /* 8210F5D0h */ case   11:  		/* bc 12, CR0_EQ, 1264 */
		/* 8210F5D0h case   11:*/		if ( regs.CR[0].eq ) { return 0x8210FAC0;  }
		/* 8210F5D0h case   11:*/		return 0x8210F5D4;
		  /* 8210F5D4h */ case   12:  		/* lwz R11, <#[R22 + 12]> */
		/* 8210F5D4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x0000000C) );
		/* 8210F5D4h case   12:*/		return 0x8210F5D8;
		  /* 8210F5D8h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 8210F5D8h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210F5D8h case   13:*/		return 0x8210F5DC;
		  /* 8210F5DCh */ case   14:  		/* bc 12, CR6_EQ, 36 */
		/* 8210F5DCh case   14:*/		if ( regs.CR[6].eq ) { return 0x8210F600;  }
		/* 8210F5DCh case   14:*/		return 0x8210F5E0;
		  /* 8210F5E0h */ case   15:  		/* lwz R9, <#[R22 + 16]> */
		/* 8210F5E0h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R22 + 0x00000010) );
		/* 8210F5E0h case   15:*/		return 0x8210F5E4;
		  /* 8210F5E4h */ case   16:  		/* lwz R8, <#[R29 + 20]> */
		/* 8210F5E4h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000014) );
		/* 8210F5E4h case   16:*/		return 0x8210F5E8;
		  /* 8210F5E8h */ case   17:  		/* lwz R9, <#[R9]> */
		/* 8210F5E8h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 8210F5E8h case   17:*/		return 0x8210F5EC;
		  /* 8210F5ECh */ case   18:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210F5ECh case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210F5ECh case   18:*/		return 0x8210F5F0;
		  /* 8210F5F0h */ case   19:  		/* lwzx R9, <#[R9 + R8]> */
		/* 8210F5F0h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 8210F5F0h case   19:*/		return 0x8210F5F4;
		  /* 8210F5F4h */ case   20:  		/* lwz R9, <#[R9]> */
		/* 8210F5F4h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 8210F5F4h case   20:*/		return 0x8210F5F8;
		  /* 8210F5F8h */ case   21:  		/* rlwinm. R9, R9, 0, 25, 25 */
		/* 8210F5F8h case   21:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R9,regs.R9);
		/* 8210F5F8h case   21:*/		return 0x8210F5FC;
		  /* 8210F5FCh */ case   22:  		/* bc 4, CR0_EQ, 1220 */
		/* 8210F5FCh case   22:*/		if ( !regs.CR[0].eq ) { return 0x8210FAC0;  }
		/* 8210F5FCh case   22:*/		return 0x8210F600;
	}
	return 0x8210F600;
} // Block from 8210F5A4h-8210F600h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8210F600h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F600);
		  /* 8210F600h */ case    0:  		/* lis R9, 8256 */
		/* 8210F600h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0x2040);
		/* 8210F600h case    0:*/		return 0x8210F604;
		  /* 8210F604h */ case    1:  		/* cmplw CR6, R10, R9 */
		/* 8210F604h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8210F604h case    1:*/		return 0x8210F608;
		  /* 8210F608h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8210F608h case    2:*/		if ( regs.CR[6].eq ) { return 0x8210F618;  }
		/* 8210F608h case    2:*/		return 0x8210F60C;
		  /* 8210F60Ch */ case    3:  		/* lis R9, 8272 */
		/* 8210F60Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0x2050);
		/* 8210F60Ch case    3:*/		return 0x8210F610;
		  /* 8210F610h */ case    4:  		/* cmplw CR6, R10, R9 */
		/* 8210F610h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8210F610h case    4:*/		return 0x8210F614;
		  /* 8210F614h */ case    5:  		/* bc 4, CR6_EQ, 1196 */
		/* 8210F614h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8210FAC0;  }
		/* 8210F614h case    5:*/		return 0x8210F618;
	}
	return 0x8210F618;
} // Block from 8210F600h-8210F618h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210F618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F618);
		  /* 8210F618h */ case    0:  		/* mr R16, R26 */
		/* 8210F618h case    0:*/		regs.R16 = regs.R26;
		/* 8210F618h case    0:*/		return 0x8210F61C;
		  /* 8210F61Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8210F61Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210F61Ch case    1:*/		return 0x8210F620;
		  /* 8210F620h */ case    2:  		/* bc 12, CR6_EQ, 1184 */
		/* 8210F620h case    2:*/		if ( regs.CR[6].eq ) { return 0x8210FAC0;  }
		/* 8210F620h case    2:*/		return 0x8210F624;
		  /* 8210F624h */ case    3:  		/* mr R20, R26 */
		/* 8210F624h case    3:*/		regs.R20 = regs.R26;
		/* 8210F624h case    3:*/		return 0x8210F628;
		  /* 8210F628h */ case    4:  		/* add R10, R11, R16 */
		/* 8210F628h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R16);
		/* 8210F628h case    4:*/		return 0x8210F62C;
		  /* 8210F62Ch */ case    5:  		/* lwz R11, <#[R22 + 8]> */
		/* 8210F62Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000008) );
		/* 8210F62Ch case    5:*/		return 0x8210F630;
		  /* 8210F630h */ case    6:  		/* mr R19, R26 */
		/* 8210F630h case    6:*/		regs.R19 = regs.R26;
		/* 8210F630h case    6:*/		return 0x8210F634;
		  /* 8210F634h */ case    7:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210F634h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210F634h case    7:*/		return 0x8210F638;
		  /* 8210F638h */ case    8:  		/* add R18, R11, R20 */
		/* 8210F638h case    8:*/		cpu::op::add<0>(regs,&regs.R18,regs.R11,regs.R20);
		/* 8210F638h case    8:*/		return 0x8210F63C;
		  /* 8210F63Ch */ case    9:  		/* add R17, R10, R11 */
		/* 8210F63Ch case    9:*/		cpu::op::add<0>(regs,&regs.R17,regs.R10,regs.R11);
		/* 8210F63Ch case    9:*/		return 0x8210F640;
		  /* 8210F640h */ case   10:  		/* stw R18, <#[R1 + 128]> */
		/* 8210F640h case   10:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000080) );
		/* 8210F640h case   10:*/		return 0x8210F644;
		  /* 8210F644h */ case   11:  		/* mr R23, R26 */
		/* 8210F644h case   11:*/		regs.R23 = regs.R26;
		/* 8210F644h case   11:*/		return 0x8210F648;
		  /* 8210F648h */ case   12:  		/* stw R17, <#[R1 + 132]> */
		/* 8210F648h case   12:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R1 + 0x00000084) );
		/* 8210F648h case   12:*/		return 0x8210F64C;
		  /* 8210F64Ch */ case   13:  		/* lwz R11, <#[R18]> */
		/* 8210F64Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 8210F64Ch case   13:*/		return 0x8210F650;
		  /* 8210F650h */ case   14:  		/* addi R6, R1, 144 */
		/* 8210F650h case   14:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x90);
		/* 8210F650h case   14:*/		return 0x8210F654;
		  /* 8210F654h */ case   15:  		/* lwz R9, <#[R17]> */
		/* 8210F654h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000000) );
		/* 8210F654h case   15:*/		return 0x8210F658;
		  /* 8210F658h */ case   16:  		/* subfic R21, R19, 1 */
		/* 8210F658h case   16:*/		cpu::op::subfic<0>(regs,&regs.R21,regs.R19,0x1);
		/* 8210F658h case   16:*/		return 0x8210F65C;
		  /* 8210F65Ch */ case   17:  		/* lwz R10, <#[R29 + 20]> */
		/* 8210F65Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000014) );
		/* 8210F65Ch case   17:*/		return 0x8210F660;
		  /* 8210F660h */ case   18:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210F660h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210F660h case   18:*/		return 0x8210F664;
		  /* 8210F664h */ case   19:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210F664h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210F664h case   19:*/		return 0x8210F668;
		  /* 8210F668h */ case   20:  		/* lwz R8, <#[R29 + 16]> */
		/* 8210F668h case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000010) );
		/* 8210F668h case   20:*/		return 0x8210F66C;
		  /* 8210F66Ch */ case   21:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210F66Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210F66Ch case   21:*/		return 0x8210F670;
		  /* 8210F670h */ case   22:  		/* lwzx R9, <#[R9 + R10]> */
		/* 8210F670h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210F670h case   22:*/		return 0x8210F674;
		  /* 8210F674h */ case   23:  		/* stw R11, <#[R1 + 144]> */
		/* 8210F674h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 8210F674h case   23:*/		return 0x8210F678;
		  /* 8210F678h */ case   24:  		/* stw R9, <#[R1 + 148]> */
		/* 8210F678h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000094) );
		/* 8210F678h case   24:*/		return 0x8210F67C;
		  /* 8210F67Ch */ case   25:  		/* lwzx R11, <#[R23 + R6]> */
		/* 8210F67Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + regs.R6 + 0x00000000) );
		/* 8210F67Ch case   25:*/		return 0x8210F680;
		  /* 8210F680h */ case   26:  		/* lwz R9, <#[R11 + 4]> */
		/* 8210F680h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8210F680h case   26:*/		return 0x8210F684;
		  /* 8210F684h */ case   27:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210F684h case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210F684h case   27:*/		return 0x8210F688;
		  /* 8210F688h */ case   28:  		/* lwzx R9, <#[R9 + R8]> */
		/* 8210F688h case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 8210F688h case   28:*/		return 0x8210F68C;
		  /* 8210F68Ch */ case   29:  		/* lwz R9, <#[R9 + 4]> */
		/* 8210F68Ch case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 8210F68Ch case   29:*/		return 0x8210F690;
		  /* 8210F690h */ case   30:  		/* rlwinm. R9, R9, 0, 30, 30 */
		/* 8210F690h case   30:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R9);
		/* 8210F690h case   30:*/		return 0x8210F694;
		  /* 8210F694h */ case   31:  		/* bc 12, CR0_EQ, 1032 */
		/* 8210F694h case   31:*/		if ( regs.CR[0].eq ) { return 0x8210FA9C;  }
		/* 8210F694h case   31:*/		return 0x8210F698;
		  /* 8210F698h */ case   32:  		/* lwz R9, <#[R11 + 8]> */
		/* 8210F698h case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8210F698h case   32:*/		return 0x8210F69C;
		  /* 8210F69Ch */ case   33:  		/* cmpwi CR6, R9, -1 */
		/* 8210F69Ch case   33:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 8210F69Ch case   33:*/		return 0x8210F6A0;
		  /* 8210F6A0h */ case   34:  		/* bc 4, CR6_EQ, 1020 */
		/* 8210F6A0h case   34:*/		if ( !regs.CR[6].eq ) { return 0x8210FA9C;  }
		/* 8210F6A0h case   34:*/		return 0x8210F6A4;
		  /* 8210F6A4h */ case   35:  		/* lwz R11, <#[R11 + 72]> */
		/* 8210F6A4h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 8210F6A4h case   35:*/		return 0x8210F6A8;
		  /* 8210F6A8h */ case   36:  		/* lwz R9, <#[R29 + 24]> */
		/* 8210F6A8h case   36:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000018) );
		/* 8210F6A8h case   36:*/		return 0x8210F6AC;
		  /* 8210F6ACh */ case   37:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210F6ACh case   37:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210F6ACh case   37:*/		return 0x8210F6B0;
		  /* 8210F6B0h */ case   38:  		/* lwz R8, <#[R22]> */
		/* 8210F6B0h case   38:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R22 + 0x00000000) );
		/* 8210F6B0h case   38:*/		return 0x8210F6B4;
		  /* 8210F6B4h */ case   39:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210F6B4h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210F6B4h case   39:*/		return 0x8210F6B8;
		  /* 8210F6B8h */ case   40:  		/* lwz R9, <#[R11]> */
		/* 8210F6B8h case   40:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8210F6B8h case   40:*/		return 0x8210F6BC;
		  /* 8210F6BCh */ case   41:  		/* xor R9, R9, R8 */
		/* 8210F6BCh case   41:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8210F6BCh case   41:*/		return 0x8210F6C0;
		  /* 8210F6C0h */ case   42:  		/* rlwinm. R9, R9, 0, 0, 11 */
		/* 8210F6C0h case   42:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R9,regs.R9);
		/* 8210F6C0h case   42:*/		return 0x8210F6C4;
		  /* 8210F6C4h */ case   43:  		/* bc 4, CR0_EQ, 984 */
		/* 8210F6C4h case   43:*/		if ( !regs.CR[0].eq ) { return 0x8210FA9C;  }
		/* 8210F6C4h case   43:*/		return 0x8210F6C8;
		  /* 8210F6C8h */ case   44:  		/* lwz R8, <#[R11 + 12]> */
		/* 8210F6C8h case   44:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210F6C8h case   44:*/		return 0x8210F6CC;
		  /* 8210F6CCh */ case   45:  		/* mr R9, R26 */
		/* 8210F6CCh case   45:*/		regs.R9 = regs.R26;
		/* 8210F6CCh case   45:*/		return 0x8210F6D0;
		  /* 8210F6D0h */ case   46:  		/* cmplwi CR6, R8, 0 */
		/* 8210F6D0h case   46:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8210F6D0h case   46:*/		return 0x8210F6D4;
		  /* 8210F6D4h */ case   47:  		/* bc 12, CR6_EQ, 52 */
		/* 8210F6D4h case   47:*/		if ( regs.CR[6].eq ) { return 0x8210F708;  }
		/* 8210F6D4h case   47:*/		return 0x8210F6D8;
		  /* 8210F6D8h */ case   48:  		/* addi R4, R1, 128 */
		/* 8210F6D8h case   48:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x80);
		/* 8210F6D8h case   48:*/		return 0x8210F6DC;
		  /* 8210F6DCh */ case   49:  		/* lwz R5, <#[R11 + 16]> */
		/* 8210F6DCh case   49:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000010) );
		/* 8210F6DCh case   49:*/		return 0x8210F6E0;
		  /* 8210F6E0h */ case   50:  		/* mr R7, R26 */
		/* 8210F6E0h case   50:*/		regs.R7 = regs.R26;
		/* 8210F6E0h case   50:*/		return 0x8210F6E4;
		  /* 8210F6E4h */ case   51:  		/* lwzx R4, <#[R23 + R4]> */
		/* 8210F6E4h case   51:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R23 + regs.R4 + 0x00000000) );
		/* 8210F6E4h case   51:*/		return 0x8210F6E8;
		  /* 8210F6E8h */ case   52:  		/* lwz R4, <#[R4]> */
		/* 8210F6E8h case   52:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000000) );
		/* 8210F6E8h case   52:*/		return 0x8210F6EC;
		  /* 8210F6ECh */ case   53:  		/* lwzx R3, <#[R7 + R5]> */
		/* 8210F6ECh case   53:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R7 + regs.R5 + 0x00000000) );
		/* 8210F6ECh case   53:*/		return 0x8210F6F0;
		  /* 8210F6F0h */ case   54:  		/* cmplw CR6, R3, R4 */
		/* 8210F6F0h case   54:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R4);
		/* 8210F6F0h case   54:*/		return 0x8210F6F4;
		  /* 8210F6F4h */ case   55:  		/* bc 12, CR6_EQ, 20 */
		/* 8210F6F4h case   55:*/		if ( regs.CR[6].eq ) { return 0x8210F708;  }
		/* 8210F6F4h case   55:*/		return 0x8210F6F8;
		  /* 8210F6F8h */ case   56:  		/* addi R9, R9, 1 */
		/* 8210F6F8h case   56:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8210F6F8h case   56:*/		return 0x8210F6FC;
		  /* 8210F6FCh */ case   57:  		/* addi R7, R7, 4 */
		/* 8210F6FCh case   57:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 8210F6FCh case   57:*/		return 0x8210F700;
		  /* 8210F700h */ case   58:  		/* cmplw CR6, R9, R8 */
		/* 8210F700h case   58:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 8210F700h case   58:*/		return 0x8210F704;
		  /* 8210F704h */ case   59:  		/* bc 12, CR6_LT, -24 */
		/* 8210F704h case   59:*/		if ( regs.CR[6].lt ) { return 0x8210F6EC;  }
		/* 8210F704h case   59:*/		return 0x8210F708;
	}
	return 0x8210F708;
} // Block from 8210F618h-8210F708h (60 instructions)

//////////////////////////////////////////////////////
// Block at 8210F708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F708);
		  /* 8210F708h */ case    0:  		/* add R8, R8, R9 */
		/* 8210F708h case    0:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R9);
		/* 8210F708h case    0:*/		return 0x8210F70C;
		  /* 8210F70Ch */ case    1:  		/* lwz R11, <#[R11 + 8]> */
		/* 8210F70Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8210F70Ch case    1:*/		return 0x8210F710;
		  /* 8210F710h */ case    2:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210F710h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210F710h case    2:*/		return 0x8210F714;
		  /* 8210F714h */ case    3:  		/* stw R25, <#[R1 + 84]> */
		/* 8210F714h case    3:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000054) );
		/* 8210F714h case    3:*/		return 0x8210F718;
		  /* 8210F718h */ case    4:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8210F718h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8210F718h case    4:*/		return 0x8210F71C;
		  /* 8210F71Ch */ case    5:  		/* add R9, R9, R11 */
		/* 8210F71Ch case    5:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 8210F71Ch case    5:*/		return 0x8210F720;
		  /* 8210F720h */ case    6:  		/* add R8, R8, R11 */
		/* 8210F720h case    6:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 8210F720h case    6:*/		return 0x8210F724;
		  /* 8210F724h */ case    7:  		/* stw R9, <#[R1 + 136]> */
		/* 8210F724h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000088) );
		/* 8210F724h case    7:*/		return 0x8210F728;
		  /* 8210F728h */ case    8:  		/* mr R24, R26 */
		/* 8210F728h case    8:*/		regs.R24 = regs.R26;
		/* 8210F728h case    8:*/		return 0x8210F72C;
		  /* 8210F72Ch */ case    9:  		/* stw R8, <#[R1 + 140]> */
		/* 8210F72Ch case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x0000008C) );
		/* 8210F72Ch case    9:*/		return 0x8210F730;
		  /* 8210F730h */ case   10:  		/* lwz R11, <#[R9]> */
		/* 8210F730h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8210F730h case   10:*/		return 0x8210F734;
		  /* 8210F734h */ case   11:  		/* lwz R9, <#[R8]> */
		/* 8210F734h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 8210F734h case   11:*/		return 0x8210F738;
		  /* 8210F738h */ case   12:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 8210F738h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 8210F738h case   12:*/		return 0x8210F73C;
		  /* 8210F73Ch */ case   13:  		/* rlwinm R7, R9, 2, 0, 29 */
		/* 8210F73Ch case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R9);
		/* 8210F73Ch case   13:*/		return 0x8210F740;
		  /* 8210F740h */ case   14:  		/* lwzx R8, <#[R8 + R10]> */
		/* 8210F740h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 8210F740h case   14:*/		return 0x8210F744;
		  /* 8210F744h */ case   15:  		/* lwzx R10, <#[R7 + R10]> */
		/* 8210F744h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 8210F744h case   15:*/		return 0x8210F748;
		  /* 8210F748h */ case   16:  		/* stw R8, <#[R1 + 152]> */
		/* 8210F748h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000098) );
		/* 8210F748h case   16:*/		return 0x8210F74C;
		  /* 8210F74Ch */ case   17:  		/* stw R10, <#[R1 + 156]> */
		/* 8210F74Ch case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000009C) );
		/* 8210F74Ch case   17:*/		return 0x8210F750;
		  /* 8210F750h */ case   18:  		/* lwzx R31, <#[R23 + R6]> */
		/* 8210F750h case   18:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R23 + regs.R6 + 0x00000000) );
		/* 8210F750h case   18:*/		return 0x8210F754;
		  /* 8210F754h */ case   19:  		/* lwz R10, <#[R31 + 92]> */
		/* 8210F754h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000005C) );
		/* 8210F754h case   19:*/		return 0x8210F758;
		  /* 8210F758h */ case   20:  		/* cmplwi CR6, R10, 1 */
		/* 8210F758h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 8210F758h case   20:*/		return 0x8210F75C;
		  /* 8210F75Ch */ case   21:  		/* bc 4, CR6_EQ, 88 */
		/* 8210F75Ch case   21:*/		if ( !regs.CR[6].eq ) { return 0x8210F7B4;  }
		/* 8210F75Ch case   21:*/		return 0x8210F760;
		  /* 8210F760h */ case   22:  		/* cmplw CR6, R11, R9 */
		/* 8210F760h case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210F760h case   22:*/		return 0x8210F764;
		  /* 8210F764h */ case   23:  		/* bc 12, CR6_EQ, 80 */
		/* 8210F764h case   23:*/		if ( regs.CR[6].eq ) { return 0x8210F7B4;  }
		/* 8210F764h case   23:*/		return 0x8210F768;
		  /* 8210F768h */ case   24:  		/* addi R10, R1, 128 */
		/* 8210F768h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 8210F768h case   24:*/		return 0x8210F76C;
		  /* 8210F76Ch */ case   25:  		/* rlwinm R11, R21, 2, 0, 29 */
		/* 8210F76Ch case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R21);
		/* 8210F76Ch case   25:*/		return 0x8210F770;
		  /* 8210F770h */ case   26:  		/* addi R6, R1, 112 */
		/* 8210F770h case   26:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x70);
		/* 8210F770h case   26:*/		return 0x8210F774;
		  /* 8210F774h */ case   27:  		/* addi R5, R1, 84 */
		/* 8210F774h case   27:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 8210F774h case   27:*/		return 0x8210F778;
		  /* 8210F778h */ case   28:  		/* mr R3, R29 */
		/* 8210F778h case   28:*/		regs.R3 = regs.R29;
		/* 8210F778h case   28:*/		return 0x8210F77C;
		  /* 8210F77Ch */ case   29:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210F77Ch case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210F77Ch case   29:*/		return 0x8210F780;
		  /* 8210F780h */ case   30:  		/* lwz R4, <#[R11]> */
		/* 8210F780h case   30:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 8210F780h case   30:*/		return 0x8210F784;
		  /* 8210F784h */ case   31:  		/* bl -70252 */
		/* 8210F784h case   31:*/		regs.LR = 0x8210F788; return 0x820FE518;
		/* 8210F784h case   31:*/		return 0x8210F788;
		  /* 8210F788h */ case   32:  		/* addi R11, R1, 128 */
		/* 8210F788h case   32:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 8210F788h case   32:*/		return 0x8210F78C;
		  /* 8210F78Ch */ case   33:  		/* addi R6, R1, 112 */
		/* 8210F78Ch case   33:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x70);
		/* 8210F78Ch case   33:*/		return 0x8210F790;
		  /* 8210F790h */ case   34:  		/* addi R5, R1, 100 */
		/* 8210F790h case   34:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x64);
		/* 8210F790h case   34:*/		return 0x8210F794;
		  /* 8210F794h */ case   35:  		/* mr R3, R29 */
		/* 8210F794h case   35:*/		regs.R3 = regs.R29;
		/* 8210F794h case   35:*/		return 0x8210F798;
		  /* 8210F798h */ case   36:  		/* lwzx R11, <#[R23 + R11]> */
		/* 8210F798h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + regs.R11 + 0x00000000) );
		/* 8210F798h case   36:*/		return 0x8210F79C;
		  /* 8210F79Ch */ case   37:  		/* lwz R4, <#[R11]> */
		/* 8210F79Ch case   37:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 8210F79Ch case   37:*/		return 0x8210F7A0;
		  /* 8210F7A0h */ case   38:  		/* lwz R25, <#[R1 + 84]> */
		/* 8210F7A0h case   38:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000054) );
		/* 8210F7A0h case   38:*/		return 0x8210F7A4;
		  /* 8210F7A4h */ case   39:  		/* stw R25, <#[R1 + 100]> */
		/* 8210F7A4h case   39:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000064) );
		/* 8210F7A4h case   39:*/		return 0x8210F7A8;
		  /* 8210F7A8h */ case   40:  		/* bl -70288 */
		/* 8210F7A8h case   40:*/		regs.LR = 0x8210F7AC; return 0x820FE518;
		/* 8210F7A8h case   40:*/		return 0x8210F7AC;
		  /* 8210F7ACh */ case   41:  		/* rlwinm R11, R3, 1, 31, 31 */
		/* 8210F7ACh case   41:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R3);
		/* 8210F7ACh case   41:*/		return 0x8210F7B0;
		  /* 8210F7B0h */ case   42:  		/* xori R24, R11, 1 */
		/* 8210F7B0h case   42:*/		cpu::op::xori<0>(regs,&regs.R24,regs.R11,0x1);
		/* 8210F7B0h case   42:*/		return 0x8210F7B4;
	}
	return 0x8210F7B4;
} // Block from 8210F708h-8210F7B4h (43 instructions)

//////////////////////////////////////////////////////
// Block at 8210F7B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F7B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F7B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F7B4);
		  /* 8210F7B4h */ case    0:  		/* li R27, 2 */
		/* 8210F7B4h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x2);
		/* 8210F7B4h case    0:*/		return 0x8210F7B8;
		  /* 8210F7B8h */ case    1:  		/* addi R11, R1, 152 */
		/* 8210F7B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x98);
		/* 8210F7B8h case    1:*/		return 0x8210F7BC;
		  /* 8210F7BCh */ case    2:  		/* lwz R29, <#[R1 + 372]> */
		/* 8210F7BCh case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000174) );
		/* 8210F7BCh case    2:*/		return 0x8210F7C0;
		  /* 8210F7C0h */ case    3:  		/* subfic R6, R27, 5 */
		/* 8210F7C0h case    3:*/		cpu::op::subfic<0>(regs,&regs.R6,regs.R27,0x5);
		/* 8210F7C0h case    3:*/		return 0x8210F7C4;
		  /* 8210F7C4h */ case    4:  		/* lwzx R8, <#[R26 + R11]> */
		/* 8210F7C4h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 8210F7C4h case    4:*/		return 0x8210F7C8;
		  /* 8210F7C8h */ case    5:  		/* lwz R9, <#[R29 + 16]> */
		/* 8210F7C8h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000010) );
		/* 8210F7C8h case    5:*/		return 0x8210F7CC;
		  /* 8210F7CCh */ case    6:  		/* lwz R11, <#[R8 + 4]> */
		/* 8210F7CCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 8210F7CCh case    6:*/		return 0x8210F7D0;
		  /* 8210F7D0h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210F7D0h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210F7D0h case    7:*/		return 0x8210F7D4;
		  /* 8210F7D4h */ case    8:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210F7D4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210F7D4h case    8:*/		return 0x8210F7D8;
		  /* 8210F7D8h */ case    9:  		/* lwz R11, <#[R11 + 4]> */
		/* 8210F7D8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8210F7D8h case    9:*/		return 0x8210F7DC;
		  /* 8210F7DCh */ case   10:  		/* rlwinm. R7, R11, 0, 23, 23 */
		/* 8210F7DCh case   10:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R7,regs.R11);
		/* 8210F7DCh case   10:*/		return 0x8210F7E0;
		  /* 8210F7E0h */ case   11:  		/* bc 12, CR0_EQ, 64 */
		/* 8210F7E0h case   11:*/		if ( regs.CR[0].eq ) { return 0x8210F820;  }
		/* 8210F7E0h case   11:*/		return 0x8210F7E4;
		  /* 8210F7E4h */ case   12:  		/* lwz R11, <#[R8 + 8]> */
		/* 8210F7E4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000008) );
		/* 8210F7E4h case   12:*/		return 0x8210F7E8;
		  /* 8210F7E8h */ case   13:  		/* cmpwi CR6, R11, -1 */
		/* 8210F7E8h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210F7E8h case   13:*/		return 0x8210F7EC;
		  /* 8210F7ECh */ case   14:  		/* bc 4, CR6_EQ, 52 */
		/* 8210F7ECh case   14:*/		if ( !regs.CR[6].eq ) { return 0x8210F820;  }
		/* 8210F7ECh case   14:*/		return 0x8210F7F0;
		  /* 8210F7F0h */ case   15:  		/* addi R11, R1, 144 */
		/* 8210F7F0h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x90);
		/* 8210F7F0h case   15:*/		return 0x8210F7F4;
		  /* 8210F7F4h */ case   16:  		/* rlwinm R30, R21, 2, 0, 29 */
		/* 8210F7F4h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R21);
		/* 8210F7F4h case   16:*/		return 0x8210F7F8;
		  /* 8210F7F8h */ case   17:  		/* lwzx R10, <#[R30 + R11]> */
		/* 8210F7F8h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8210F7F8h case   17:*/		return 0x8210F7FC;
		  /* 8210F7FCh */ case   18:  		/* lwz R11, <#[R10 + 4]> */
		/* 8210F7FCh case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8210F7FCh case   18:*/		return 0x8210F800;
		  /* 8210F800h */ case   19:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210F800h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210F800h case   19:*/		return 0x8210F804;
		  /* 8210F804h */ case   20:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210F804h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210F804h case   20:*/		return 0x8210F808;
		  /* 8210F808h */ case   21:  		/* lwz R11, <#[R11 + 4]> */
		/* 8210F808h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8210F808h case   21:*/		return 0x8210F80C;
		  /* 8210F80Ch */ case   22:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 8210F80Ch case   22:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 8210F80Ch case   22:*/		return 0x8210F810;
		  /* 8210F810h */ case   23:  		/* bc 12, CR0_EQ, 16 */
		/* 8210F810h case   23:*/		if ( regs.CR[0].eq ) { return 0x8210F820;  }
		/* 8210F810h case   23:*/		return 0x8210F814;
		  /* 8210F814h */ case   24:  		/* lwz R11, <#[R10 + 8]> */
		/* 8210F814h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8210F814h case   24:*/		return 0x8210F818;
		  /* 8210F818h */ case   25:  		/* cmpwi CR6, R11, -1 */
		/* 8210F818h case   25:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210F818h case   25:*/		return 0x8210F81C;
		  /* 8210F81Ch */ case   26:  		/* bc 12, CR6_EQ, 232 */
		/* 8210F81Ch case   26:*/		if ( regs.CR[6].eq ) { return 0x8210F904;  }
		/* 8210F81Ch case   26:*/		return 0x8210F820;
	}
	return 0x8210F820;
} // Block from 8210F7B4h-8210F820h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8210F820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F820);
		  /* 8210F820h */ case    0:  		/* lwz R11, <#[R31 + 92]> */
		/* 8210F820h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8210F820h case    0:*/		return 0x8210F824;
		  /* 8210F824h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 8210F824h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8210F824h case    1:*/		return 0x8210F828;
		  /* 8210F828h */ case    2:  		/* bc 4, CR6_EQ, 200 */
		/* 8210F828h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8210F8F0;  }
		/* 8210F828h case    2:*/		return 0x8210F82C;
		  /* 8210F82Ch */ case    3:  		/* addi R11, R1, 144 */
		/* 8210F82Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x90);
		/* 8210F82Ch case    3:*/		return 0x8210F830;
		  /* 8210F830h */ case    4:  		/* rlwinm R29, R21, 2, 0, 29 */
		/* 8210F830h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R21);
		/* 8210F830h case    4:*/		return 0x8210F834;
		  /* 8210F834h */ case    5:  		/* lwzx R10, <#[R29 + R11]> */
		/* 8210F834h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 8210F834h case    5:*/		return 0x8210F838;
		  /* 8210F838h */ case    6:  		/* lwz R11, <#[R10 + 72]> */
		/* 8210F838h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000048) );
		/* 8210F838h case    6:*/		return 0x8210F83C;
		  /* 8210F83Ch */ case    7:  		/* cmpwi CR6, R11, -1 */
		/* 8210F83Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210F83Ch case    7:*/		return 0x8210F840;
		  /* 8210F840h */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 8210F840h case    8:*/		if ( regs.CR[6].eq ) { return 0x8210F850;  }
		/* 8210F840h case    8:*/		return 0x8210F844;
		  /* 8210F844h */ case    9:  		/* lwz R5, <#[R31 + 72]> */
		/* 8210F844h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000048) );
		/* 8210F844h case    9:*/		return 0x8210F848;
		  /* 8210F848h */ case   10:  		/* cmplw CR6, R11, R5 */
		/* 8210F848h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 8210F848h case   10:*/		return 0x8210F84C;
		  /* 8210F84Ch */ case   11:  		/* bc 4, CR6_LT, 164 */
		/* 8210F84Ch case   11:*/		if ( !regs.CR[6].lt ) { return 0x8210F8F0;  }
		/* 8210F84Ch case   11:*/		return 0x8210F850;
	}
	return 0x8210F850;
} // Block from 8210F820h-8210F850h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8210F850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F850);
		  /* 8210F850h */ case    0:  		/* lwz R11, <#[R10 + 8]> */
		/* 8210F850h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8210F850h case    0:*/		return 0x8210F854;
		  /* 8210F854h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 8210F854h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210F854h case    1:*/		return 0x8210F858;
		  /* 8210F858h */ case    2:  		/* bc 4, CR6_EQ, 152 */
		/* 8210F858h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8210F8F0;  }
		/* 8210F858h case    2:*/		return 0x8210F85C;
		  /* 8210F85Ch */ case    3:  		/* cmplwi CR6, R7, 0 */
		/* 8210F85Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8210F85Ch case    3:*/		return 0x8210F860;
		  /* 8210F860h */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 8210F860h case    4:*/		if ( regs.CR[6].eq ) { return 0x8210F888;  }
		/* 8210F860h case    4:*/		return 0x8210F864;
		  /* 8210F864h */ case    5:  		/* lwz R11, <#[R8 + 8]> */
		/* 8210F864h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000008) );
		/* 8210F864h case    5:*/		return 0x8210F868;
		  /* 8210F868h */ case    6:  		/* cmpwi CR6, R11, -1 */
		/* 8210F868h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210F868h case    6:*/		return 0x8210F86C;
		  /* 8210F86Ch */ case    7:  		/* bc 4, CR6_EQ, 28 */
		/* 8210F86Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x8210F888;  }
		/* 8210F86Ch case    7:*/		return 0x8210F870;
		  /* 8210F870h */ case    8:  		/* lwz R11, <#[R10 + 4]> */
		/* 8210F870h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8210F870h case    8:*/		return 0x8210F874;
		  /* 8210F874h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210F874h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210F874h case    9:*/		return 0x8210F878;
		  /* 8210F878h */ case   10:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210F878h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210F878h case   10:*/		return 0x8210F87C;
		  /* 8210F87Ch */ case   11:  		/* lwz R11, <#[R11 + 4]> */
		/* 8210F87Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8210F87Ch case   11:*/		return 0x8210F880;
		  /* 8210F880h */ case   12:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 8210F880h case   12:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 8210F880h case   12:*/		return 0x8210F884;
		  /* 8210F884h */ case   13:  		/* bc 12, CR0_EQ, 316 */
		/* 8210F884h case   13:*/		if ( regs.CR[0].eq ) { return 0x8210F9C0;  }
		/* 8210F884h case   13:*/		return 0x8210F888;
	}
	return 0x8210F888;
} // Block from 8210F850h-8210F888h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8210F888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F888);
		  /* 8210F888h */ case    0:  		/* rlwinm R11, R6, 2, 0, 29 */
		/* 8210F888h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R6);
		/* 8210F888h case    0:*/		return 0x8210F88C;
		  /* 8210F88Ch */ case    1:  		/* addi R10, R1, 128 */
		/* 8210F88Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 8210F88Ch case    1:*/		return 0x8210F890;
		  /* 8210F890h */ case    2:  		/* addi R9, R1, 136 */
		/* 8210F890h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x88);
		/* 8210F890h case    2:*/		return 0x8210F894;
		  /* 8210F894h */ case    3:  		/* lwzx R30, <#[R11 + R10]> */
		/* 8210F894h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210F894h case    3:*/		return 0x8210F898;
		  /* 8210F898h */ case    4:  		/* lwzx R28, <#[R26 + R9]> */
		/* 8210F898h case    4:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R26 + regs.R9 + 0x00000000) );
		/* 8210F898h case    4:*/		return 0x8210F89C;
		  /* 8210F89Ch */ case    5:  		/* lwz R11, <#[R30]> */
		/* 8210F89Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8210F89Ch case    5:*/		return 0x8210F8A0;
		  /* 8210F8A0h */ case    6:  		/* lwz R4, <#[R28]> */
		/* 8210F8A0h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000000) );
		/* 8210F8A0h case    6:*/		return 0x8210F8A4;
		  /* 8210F8A4h */ case    7:  		/* cmplw CR6, R11, R4 */
		/* 8210F8A4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 8210F8A4h case    7:*/		return 0x8210F8A8;
		  /* 8210F8A8h */ case    8:  		/* bc 12, CR6_EQ, 72 */
		/* 8210F8A8h case    8:*/		if ( regs.CR[6].eq ) { return 0x8210F8F0;  }
		/* 8210F8A8h case    8:*/		return 0x8210F8AC;
		  /* 8210F8ACh */ case    9:  		/* cmpwi CR6, R24, 0 */
		/* 8210F8ACh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 8210F8ACh case    9:*/		return 0x8210F8B0;
		  /* 8210F8B0h */ case   10:  		/* bc 4, CR6_EQ, 40 */
		/* 8210F8B0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8210F8D8;  }
		/* 8210F8B0h case   10:*/		return 0x8210F8B4;
		  /* 8210F8B4h */ case   11:  		/* stw R25, <#[R1 + 100]> */
		/* 8210F8B4h case   11:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000064) );
		/* 8210F8B4h case   11:*/		return 0x8210F8B8;
		  /* 8210F8B8h */ case   12:  		/* addi R6, R1, 112 */
		/* 8210F8B8h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x70);
		/* 8210F8B8h case   12:*/		return 0x8210F8BC;
		  /* 8210F8BCh */ case   13:  		/* addi R5, R1, 100 */
		/* 8210F8BCh case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x64);
		/* 8210F8BCh case   13:*/		return 0x8210F8C0;
		  /* 8210F8C0h */ case   14:  		/* lwz R3, <#[R1 + 372]> */
		/* 8210F8C0h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000174) );
		/* 8210F8C0h case   14:*/		return 0x8210F8C4;
		  /* 8210F8C4h */ case   15:  		/* bl -70572 */
		/* 8210F8C4h case   15:*/		regs.LR = 0x8210F8C8; return 0x820FE518;
		/* 8210F8C4h case   15:*/		return 0x8210F8C8;
		  /* 8210F8C8h */ case   16:  		/* rlwinm R11, R3, 1, 31, 31 */
		/* 8210F8C8h case   16:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R3);
		/* 8210F8C8h case   16:*/		return 0x8210F8CC;
		  /* 8210F8CCh */ case   17:  		/* xori R11, R11, 1 */
		/* 8210F8CCh case   17:*/		cpu::op::xori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210F8CCh case   17:*/		return 0x8210F8D0;
		  /* 8210F8D0h */ case   18:  		/* cmpwi CR6, R11, 0 */
		/* 8210F8D0h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8210F8D0h case   18:*/		return 0x8210F8D4;
		  /* 8210F8D4h */ case   19:  		/* bc 4, CR6_EQ, 344 */
		/* 8210F8D4h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8210FA2C;  }
		/* 8210F8D4h case   19:*/		return 0x8210F8D8;
	}
	return 0x8210F8D8;
} // Block from 8210F888h-8210F8D8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8210F8D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F8D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F8D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F8D8);
		  /* 8210F8D8h */ case    0:  		/* addi R11, R1, 128 */
		/* 8210F8D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 8210F8D8h case    0:*/		return 0x8210F8DC;
		  /* 8210F8DCh */ case    1:  		/* lwz R10, <#[R28]> */
		/* 8210F8DCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 8210F8DCh case    1:*/		return 0x8210F8E0;
		  /* 8210F8E0h */ case    2:  		/* lwzx R11, <#[R29 + R11]> */
		/* 8210F8E0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 8210F8E0h case    2:*/		return 0x8210F8E4;
		  /* 8210F8E4h */ case    3:  		/* lwz R11, <#[R11]> */
		/* 8210F8E4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8210F8E4h case    3:*/		return 0x8210F8E8;
		  /* 8210F8E8h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 8210F8E8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210F8E8h case    4:*/		return 0x8210F8EC;
		  /* 8210F8ECh */ case    5:  		/* bc 12, CR6_EQ, 320 */
		/* 8210F8ECh case    5:*/		if ( regs.CR[6].eq ) { return 0x8210FA2C;  }
		/* 8210F8ECh case    5:*/		return 0x8210F8F0;
	}
	return 0x8210F8F0;
} // Block from 8210F8D8h-8210F8F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210F8F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F8F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F8F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F8F0);
		  /* 8210F8F0h */ case    0:  		/* addi R27, R27, 1 */
		/* 8210F8F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8210F8F0h case    0:*/		return 0x8210F8F4;
		  /* 8210F8F4h */ case    1:  		/* addi R26, R26, 4 */
		/* 8210F8F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 8210F8F4h case    1:*/		return 0x8210F8F8;
		  /* 8210F8F8h */ case    2:  		/* cmplwi CR6, R27, 4 */
		/* 8210F8F8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000004);
		/* 8210F8F8h case    2:*/		return 0x8210F8FC;
		  /* 8210F8FCh */ case    3:  		/* bc 12, CR6_LT, -324 */
		/* 8210F8FCh case    3:*/		if ( regs.CR[6].lt ) { return 0x8210F7B8;  }
		/* 8210F8FCh case    3:*/		return 0x8210F900;
		  /* 8210F900h */ case    4:  		/* b 400 */
		/* 8210F900h case    4:*/		return 0x8210FA90;
		/* 8210F900h case    4:*/		return 0x8210F904;
	}
	return 0x8210F904;
} // Block from 8210F8F0h-8210F904h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210F904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F904);
		  /* 8210F904h */ case    0:  		/* lwz R11, <#[R22]> */
		/* 8210F904h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 8210F904h case    0:*/		return 0x8210F908;
		  /* 8210F908h */ case    1:  		/* lis R9, 8256 */
		/* 8210F908h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0x2040);
		/* 8210F908h case    1:*/		return 0x8210F90C;
		  /* 8210F90Ch */ case    2:  		/* fmr FR1, FR30 */
		/* 8210F90Ch case    2:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 8210F90Ch case    2:*/		return 0x8210F910;
		  /* 8210F910h */ case    3:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 8210F910h case    3:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 8210F910h case    3:*/		return 0x8210F914;
		  /* 8210F914h */ case    4:  		/* cmplw CR6, R11, R9 */
		/* 8210F914h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210F914h case    4:*/		return 0x8210F918;
		  /* 8210F918h */ case    5:  		/* bc 12, CR6_EQ, 44 */
		/* 8210F918h case    5:*/		if ( regs.CR[6].eq ) { return 0x8210F944;  }
		/* 8210F918h case    5:*/		return 0x8210F91C;
		  /* 8210F91Ch */ case    6:  		/* lis R9, 8272 */
		/* 8210F91Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R9,0x2050);
		/* 8210F91Ch case    6:*/		return 0x8210F920;
		  /* 8210F920h */ case    7:  		/* cmplw CR6, R11, R9 */
		/* 8210F920h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210F920h case    7:*/		return 0x8210F924;
		  /* 8210F924h */ case    8:  		/* bc 4, CR6_EQ, 56 */
		/* 8210F924h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8210F95C;  }
		/* 8210F924h case    8:*/		return 0x8210F928;
		  /* 8210F928h */ case    9:  		/* lfd FR0, <#[R10 + 32]> */
		/* 8210F928h case    9:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 8210F928h case    9:*/		return 0x8210F92C;
		  /* 8210F92Ch */ case   10:  		/* rlwinm R11, R27, 2, 0, 29 */
		/* 8210F92Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R27);
		/* 8210F92Ch case   10:*/		return 0x8210F930;
		  /* 8210F930h */ case   11:  		/* addi R10, R1, 144 */
		/* 8210F930h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 8210F930h case   11:*/		return 0x8210F934;
		  /* 8210F934h */ case   12:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210F934h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210F934h case   12:*/		return 0x8210F938;
		  /* 8210F938h */ case   13:  		/* lfd FR13, <#[R11 + 32]> */
		/* 8210F938h case   13:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 8210F938h case   13:*/		return 0x8210F93C;
		  /* 8210F93Ch */ case   14:  		/* fmul FR1, FR13, FR0 */
		/* 8210F93Ch case   14:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR13,regs.FR0);
		/* 8210F93Ch case   14:*/		return 0x8210F940;
	}
	return 0x8210F940;
} // Block from 8210F904h-8210F940h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8210F940h
// Function '?Split@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F940);
		  /* 8210F940h */ case    0:  		/* b 28 */
		/* 8210F940h case    0:*/		return 0x8210F95C;
		/* 8210F940h case    0:*/		return 0x8210F944;
	}
	return 0x8210F944;
} // Block from 8210F940h-8210F944h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210F944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F944);
		  /* 8210F944h */ case    0:  		/* lfd FR0, <#[R10 + 32]> */
		/* 8210F944h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 8210F944h case    0:*/		return 0x8210F948;
		  /* 8210F948h */ case    1:  		/* rlwinm R11, R27, 2, 0, 29 */
		/* 8210F948h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R27);
		/* 8210F948h case    1:*/		return 0x8210F94C;
		  /* 8210F94Ch */ case    2:  		/* addi R10, R1, 144 */
		/* 8210F94Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 8210F94Ch case    2:*/		return 0x8210F950;
		  /* 8210F950h */ case    3:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210F950h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210F950h case    3:*/		return 0x8210F954;
		  /* 8210F954h */ case    4:  		/* lfd FR13, <#[R11 + 32]> */
		/* 8210F954h case    4:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 8210F954h case    4:*/		return 0x8210F958;
		  /* 8210F958h */ case    5:  		/* fadd FR1, FR13, FR0 */
		/* 8210F958h case    5:*/		cpu::op::fadd<0>(regs,&regs.FR1,regs.FR13,regs.FR0);
		/* 8210F958h case    5:*/		return 0x8210F95C;
	}
	return 0x8210F95C;
} // Block from 8210F944h-8210F95Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210F95Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F95C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F95C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F95C);
		  /* 8210F95Ch */ case    0:  		/* rlwinm R11, R6, 2, 0, 29 */
		/* 8210F95Ch case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R6);
		/* 8210F95Ch case    0:*/		return 0x8210F960;
		  /* 8210F960h */ case    1:  		/* addi R10, R1, 128 */
		/* 8210F960h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 8210F960h case    1:*/		return 0x8210F964;
		  /* 8210F964h */ case    2:  		/* addi R9, R1, 128 */
		/* 8210F964h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x80);
		/* 8210F964h case    2:*/		return 0x8210F968;
		  /* 8210F968h */ case    3:  		/* li R6, 0 */
		/* 8210F968h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8210F968h case    3:*/		return 0x8210F96C;
		  /* 8210F96Ch */ case    4:  		/* li R5, 0 */
		/* 8210F96Ch case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8210F96Ch case    4:*/		return 0x8210F970;
		  /* 8210F970h */ case    5:  		/* mr R3, R29 */
		/* 8210F970h case    5:*/		regs.R3 = regs.R29;
		/* 8210F970h case    5:*/		return 0x8210F974;
		  /* 8210F974h */ case    6:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210F974h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210F974h case    6:*/		return 0x8210F978;
		  /* 8210F978h */ case    7:  		/* lwzx R10, <#[R23 + R9]> */
		/* 8210F978h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + regs.R9 + 0x00000000) );
		/* 8210F978h case    7:*/		return 0x8210F97C;
		  /* 8210F97Ch */ case    8:  		/* lwz R11, <#[R11]> */
		/* 8210F97Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8210F97Ch case    8:*/		return 0x8210F980;
		  /* 8210F980h */ case    9:  		/* stw R11, <#[R10]> */
		/* 8210F980h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8210F980h case    9:*/		return 0x8210F984;
		  /* 8210F984h */ case   10:  		/* lwz R4, <#[R29 + 120]> */
		/* 8210F984h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000078) );
		/* 8210F984h case   10:*/		return 0x8210F988;
		  /* 8210F988h */ case   11:  		/* bl -75616 */
		/* 8210F988h case   11:*/		regs.LR = 0x8210F98C; return 0x820FD228;
		/* 8210F988h case   11:*/		return 0x8210F98C;
		  /* 8210F98Ch */ case   12:  		/* addi R11, R1, 128 */
		/* 8210F98Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 8210F98Ch case   12:*/		return 0x8210F990;
		  /* 8210F990h */ case   13:  		/* lwzx R11, <#[R30 + R11]> */
		/* 8210F990h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8210F990h case   13:*/		return 0x8210F994;
		  /* 8210F994h */ case   14:  		/* li R10, 1 */
		/* 8210F994h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8210F994h case   14:*/		return 0x8210F998;
		  /* 8210F998h */ case   15:  		/* li R25, -1 */
		/* 8210F998h case   15:*/		cpu::op::li<0>(regs,&regs.R25,0xFFFFFFFF);
		/* 8210F998h case   15:*/		return 0x8210F99C;
		  /* 8210F99Ch */ case   16:  		/* stw R10, <#[R1 + 80]> */
		/* 8210F99Ch case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8210F99Ch case   16:*/		return 0x8210F9A0;
		  /* 8210F9A0h */ case   17:  		/* stw R3, <#[R11]> */
		/* 8210F9A0h case   17:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 8210F9A0h case   17:*/		return 0x8210F9A4;
		  /* 8210F9A4h */ case   18:  		/* lwz R10, <#[R22 + 16]> */
		/* 8210F9A4h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000010) );
		/* 8210F9A4h case   18:*/		return 0x8210F9A8;
		  /* 8210F9A8h */ case   19:  		/* lwz R11, <#[R29 + 20]> */
		/* 8210F9A8h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000014) );
		/* 8210F9A8h case   19:*/		return 0x8210F9AC;
		  /* 8210F9ACh */ case   20:  		/* lwzx R10, <#[R10 + R20]> */
		/* 8210F9ACh case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R20 + 0x00000000) );
		/* 8210F9ACh case   20:*/		return 0x8210F9B0;
		  /* 8210F9B0h */ case   21:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210F9B0h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210F9B0h case   21:*/		return 0x8210F9B4;
		  /* 8210F9B4h */ case   22:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8210F9B4h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210F9B4h case   22:*/		return 0x8210F9B8;
		  /* 8210F9B8h */ case   23:  		/* stw R25, <#[R11 + 64]> */
		/* 8210F9B8h case   23:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x00000040) );
		/* 8210F9B8h case   23:*/		return 0x8210F9BC;
		  /* 8210F9BCh */ case   24:  		/* b 220 */
		/* 8210F9BCh case   24:*/		return 0x8210FA98;
		/* 8210F9BCh case   24:*/		return 0x8210F9C0;
	}
	return 0x8210F9C0;
} // Block from 8210F95Ch-8210F9C0h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8210F9C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210F9C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210F9C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210F9C0);
		  /* 8210F9C0h */ case    0:  		/* addi R10, R1, 128 */
		/* 8210F9C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 8210F9C0h case    0:*/		return 0x8210F9C4;
		  /* 8210F9C4h */ case    1:  		/* rlwinm R11, R27, 2, 0, 29 */
		/* 8210F9C4h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R27);
		/* 8210F9C4h case    1:*/		return 0x8210F9C8;
		  /* 8210F9C8h */ case    2:  		/* addi R9, R1, 128 */
		/* 8210F9C8h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x80);
		/* 8210F9C8h case    2:*/		return 0x8210F9CC;
		  /* 8210F9CCh */ case    3:  		/* li R8, 1 */
		/* 8210F9CCh case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8210F9CCh case    3:*/		return 0x8210F9D0;
		  /* 8210F9D0h */ case    4:  		/* li R26, 0 */
		/* 8210F9D0h case    4:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8210F9D0h case    4:*/		return 0x8210F9D4;
		  /* 8210F9D4h */ case    5:  		/* stw R8, <#[R1 + 80]> */
		/* 8210F9D4h case    5:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 8210F9D4h case    5:*/		return 0x8210F9D8;
		  /* 8210F9D8h */ case    6:  		/* li R25, -1 */
		/* 8210F9D8h case    6:*/		cpu::op::li<0>(regs,&regs.R25,0xFFFFFFFF);
		/* 8210F9D8h case    6:*/		return 0x8210F9DC;
		  /* 8210F9DCh */ case    7:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210F9DCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210F9DCh case    7:*/		return 0x8210F9E0;
		  /* 8210F9E0h */ case    8:  		/* lwzx R10, <#[R29 + R9]> */
		/* 8210F9E0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + regs.R9 + 0x00000000) );
		/* 8210F9E0h case    8:*/		return 0x8210F9E4;
		  /* 8210F9E4h */ case    9:  		/* lwz R29, <#[R1 + 372]> */
		/* 8210F9E4h case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000174) );
		/* 8210F9E4h case    9:*/		return 0x8210F9E8;
		  /* 8210F9E8h */ case   10:  		/* lwz R9, <#[R11]> */
		/* 8210F9E8h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8210F9E8h case   10:*/		return 0x8210F9EC;
		  /* 8210F9ECh */ case   11:  		/* lwz R8, <#[R10]> */
		/* 8210F9ECh case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8210F9ECh case   11:*/		return 0x8210F9F0;
		  /* 8210F9F0h */ case   12:  		/* stw R9, <#[R10]> */
		/* 8210F9F0h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8210F9F0h case   12:*/		return 0x8210F9F4;
		  /* 8210F9F4h */ case   13:  		/* stw R8, <#[R11]> */
		/* 8210F9F4h case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8210F9F4h case   13:*/		return 0x8210F9F8;
		  /* 8210F9F8h */ case   14:  		/* stw R26, <#[R31 + 96]> */
		/* 8210F9F8h case   14:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000060) );
		/* 8210F9F8h case   14:*/		return 0x8210F9FC;
		  /* 8210F9FCh */ case   15:  		/* stw R26, <#[R31 + 100]> */
		/* 8210F9FCh case   15:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000064) );
		/* 8210F9FCh case   15:*/		return 0x8210FA00;
		  /* 8210FA00h */ case   16:  		/* lwz R11, <#[R31]> */
		/* 8210FA00h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8210FA00h case   16:*/		return 0x8210FA04;
		  /* 8210FA04h */ case   17:  		/* rlwinm R11, R11, 0, 0, 27 */
		/* 8210FA04h case   17:*/		cpu::op::rlwinm<0,0,0,27>(regs,&regs.R11,regs.R11);
		/* 8210FA04h case   17:*/		return 0x8210FA08;
		  /* 8210FA08h */ case   18:  		/* stw R11, <#[R31]> */
		/* 8210FA08h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8210FA08h case   18:*/		return 0x8210FA0C;
		  /* 8210FA0Ch */ case   19:  		/* stw R25, <#[R31 + 64]> */
		/* 8210FA0Ch case   19:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x00000040) );
		/* 8210FA0Ch case   19:*/		return 0x8210FA10;
		  /* 8210FA10h */ case   20:  		/* lwz R11, <#[R22 + 16]> */
		/* 8210FA10h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000010) );
		/* 8210FA10h case   20:*/		return 0x8210FA14;
		  /* 8210FA14h */ case   21:  		/* lwz R10, <#[R29 + 20]> */
		/* 8210FA14h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000014) );
		/* 8210FA14h case   21:*/		return 0x8210FA18;
		  /* 8210FA18h */ case   22:  		/* lwzx R11, <#[R11 + R20]> */
		/* 8210FA18h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R20 + 0x00000000) );
		/* 8210FA18h case   22:*/		return 0x8210FA1C;
		  /* 8210FA1Ch */ case   23:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210FA1Ch case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210FA1Ch case   23:*/		return 0x8210FA20;
		  /* 8210FA20h */ case   24:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210FA20h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210FA20h case   24:*/		return 0x8210FA24;
		  /* 8210FA24h */ case   25:  		/* stw R25, <#[R11 + 64]> */
		/* 8210FA24h case   25:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x00000040) );
		/* 8210FA24h case   25:*/		return 0x8210FA28;
		  /* 8210FA28h */ case   26:  		/* b 116 */
		/* 8210FA28h case   26:*/		return 0x8210FA9C;
		/* 8210FA28h case   26:*/		return 0x8210FA2C;
	}
	return 0x8210FA2C;
} // Block from 8210F9C0h-8210FA2Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 8210FA2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FA2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FA2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FA2C);
		  /* 8210FA2Ch */ case    0:  		/* addi R10, R1, 128 */
		/* 8210FA2Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 8210FA2Ch case    0:*/		return 0x8210FA30;
		  /* 8210FA30h */ case    1:  		/* lwz R9, <#[R30]> */
		/* 8210FA30h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 8210FA30h case    1:*/		return 0x8210FA34;
		  /* 8210FA34h */ case    2:  		/* li R7, 1 */
		/* 8210FA34h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8210FA34h case    2:*/		return 0x8210FA38;
		  /* 8210FA38h */ case    3:  		/* lwz R8, <#[R1 + 372]> */
		/* 8210FA38h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000174) );
		/* 8210FA38h case    3:*/		return 0x8210FA3C;
		  /* 8210FA3Ch */ case    4:  		/* li R11, -1 */
		/* 8210FA3Ch case    4:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 8210FA3Ch case    4:*/		return 0x8210FA40;
		  /* 8210FA40h */ case    5:  		/* stw R7, <#[R1 + 80]> */
		/* 8210FA40h case    5:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 8210FA40h case    5:*/		return 0x8210FA44;
		  /* 8210FA44h */ case    6:  		/* mr R5, R11 */
		/* 8210FA44h case    6:*/		regs.R5 = regs.R11;
		/* 8210FA44h case    6:*/		return 0x8210FA48;
		  /* 8210FA48h */ case    7:  		/* lwzx R10, <#[R29 + R10]> */
		/* 8210FA48h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + regs.R10 + 0x00000000) );
		/* 8210FA48h case    7:*/		return 0x8210FA4C;
		  /* 8210FA4Ch */ case    8:  		/* mr R6, R11 */
		/* 8210FA4Ch case    8:*/		regs.R6 = regs.R11;
		/* 8210FA4Ch case    8:*/		return 0x8210FA50;
		  /* 8210FA50h */ case    9:  		/* li R11, 0 */
		/* 8210FA50h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210FA50h case    9:*/		return 0x8210FA54;
		  /* 8210FA54h */ case   10:  		/* lwz R7, <#[R10]> */
		/* 8210FA54h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 8210FA54h case   10:*/		return 0x8210FA58;
		  /* 8210FA58h */ case   11:  		/* stw R9, <#[R10]> */
		/* 8210FA58h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8210FA58h case   11:*/		return 0x8210FA5C;
		  /* 8210FA5Ch */ case   12:  		/* stw R7, <#[R30]> */
		/* 8210FA5Ch case   12:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R30 + 0x00000000) );
		/* 8210FA5Ch case   12:*/		return 0x8210FA60;
		  /* 8210FA60h */ case   13:  		/* stw R11, <#[R31 + 96]> */
		/* 8210FA60h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 8210FA60h case   13:*/		return 0x8210FA64;
		  /* 8210FA64h */ case   14:  		/* stw R11, <#[R31 + 100]> */
		/* 8210FA64h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000064) );
		/* 8210FA64h case   14:*/		return 0x8210FA68;
		  /* 8210FA68h */ case   15:  		/* lwz R11, <#[R31]> */
		/* 8210FA68h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8210FA68h case   15:*/		return 0x8210FA6C;
		  /* 8210FA6Ch */ case   16:  		/* rlwinm R11, R11, 0, 0, 27 */
		/* 8210FA6Ch case   16:*/		cpu::op::rlwinm<0,0,0,27>(regs,&regs.R11,regs.R11);
		/* 8210FA6Ch case   16:*/		return 0x8210FA70;
		  /* 8210FA70h */ case   17:  		/* stw R11, <#[R31]> */
		/* 8210FA70h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8210FA70h case   17:*/		return 0x8210FA74;
		  /* 8210FA74h */ case   18:  		/* stw R5, <#[R31 + 64]> */
		/* 8210FA74h case   18:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R31 + 0x00000040) );
		/* 8210FA74h case   18:*/		return 0x8210FA78;
		  /* 8210FA78h */ case   19:  		/* lwz R11, <#[R8 + 20]> */
		/* 8210FA78h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000014) );
		/* 8210FA78h case   19:*/		return 0x8210FA7C;
		  /* 8210FA7Ch */ case   20:  		/* lwz R10, <#[R22 + 16]> */
		/* 8210FA7Ch case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000010) );
		/* 8210FA7Ch case   20:*/		return 0x8210FA80;
		  /* 8210FA80h */ case   21:  		/* lwzx R10, <#[R10 + R20]> */
		/* 8210FA80h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R20 + 0x00000000) );
		/* 8210FA80h case   21:*/		return 0x8210FA84;
		  /* 8210FA84h */ case   22:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210FA84h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210FA84h case   22:*/		return 0x8210FA88;
		  /* 8210FA88h */ case   23:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8210FA88h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210FA88h case   23:*/		return 0x8210FA8C;
		  /* 8210FA8Ch */ case   24:  		/* stw R5, <#[R11 + 64]> */
		/* 8210FA8Ch case   24:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x00000040) );
		/* 8210FA8Ch case   24:*/		return 0x8210FA90;
	}
	return 0x8210FA90;
} // Block from 8210FA2Ch-8210FA90h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8210FA90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FA90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FA90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FA90);
		  /* 8210FA90h */ case    0:  		/* lwz R29, <#[R1 + 372]> */
		/* 8210FA90h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000174) );
		/* 8210FA90h case    0:*/		return 0x8210FA94;
		  /* 8210FA94h */ case    1:  		/* li R25, -1 */
		/* 8210FA94h case    1:*/		cpu::op::li<0>(regs,&regs.R25,0xFFFFFFFF);
		/* 8210FA94h case    1:*/		return 0x8210FA98;
	}
	return 0x8210FA98;
} // Block from 8210FA90h-8210FA98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210FA98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FA98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FA98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FA98);
		  /* 8210FA98h */ case    0:  		/* li R26, 0 */
		/* 8210FA98h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8210FA98h case    0:*/		return 0x8210FA9C;
	}
	return 0x8210FA9C;
} // Block from 8210FA98h-8210FA9Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210FA9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FA9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FA9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FA9C);
		  /* 8210FA9Ch */ case    0:  		/* addi R23, R23, 4 */
		/* 8210FA9Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x4);
		/* 8210FA9Ch case    0:*/		return 0x8210FAA0;
		  /* 8210FAA0h */ case    1:  		/* addi R19, R19, 1 */
		/* 8210FAA0h case    1:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x1);
		/* 8210FAA0h case    1:*/		return 0x8210FAA4;
		  /* 8210FAA4h */ case    2:  		/* cmplwi CR6, R23, 8 */
		/* 8210FAA4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000008);
		/* 8210FAA4h case    2:*/		return 0x8210FAA8;
		  /* 8210FAA8h */ case    3:  		/* bc 12, CR6_LT, -1116 */
		/* 8210FAA8h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210F64C;  }
		/* 8210FAA8h case    3:*/		return 0x8210FAAC;
		  /* 8210FAACh */ case    4:  		/* lwz R11, <#[R22 + 12]> */
		/* 8210FAACh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x0000000C) );
		/* 8210FAACh case    4:*/		return 0x8210FAB0;
		  /* 8210FAB0h */ case    5:  		/* addi R16, R16, 1 */
		/* 8210FAB0h case    5:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R16,0x1);
		/* 8210FAB0h case    5:*/		return 0x8210FAB4;
		  /* 8210FAB4h */ case    6:  		/* addi R20, R20, 4 */
		/* 8210FAB4h case    6:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0x4);
		/* 8210FAB4h case    6:*/		return 0x8210FAB8;
		  /* 8210FAB8h */ case    7:  		/* cmplw CR6, R16, R11 */
		/* 8210FAB8h case    7:*/		cpu::op::cmplw<6>(regs,regs.R16,regs.R11);
		/* 8210FAB8h case    7:*/		return 0x8210FABC;
		  /* 8210FABCh */ case    8:  		/* bc 12, CR6_LT, -1172 */
		/* 8210FABCh case    8:*/		if ( regs.CR[6].lt ) { return 0x8210F628;  }
		/* 8210FABCh case    8:*/		return 0x8210FAC0;
	}
	return 0x8210FAC0;
} // Block from 8210FA9Ch-8210FAC0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8210FAC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FAC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FAC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FAC0);
		  /* 8210FAC0h */ case    0:  		/* lwz R11, <#[R29 + 12]> */
		/* 8210FAC0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 8210FAC0h case    0:*/		return 0x8210FAC4;
		  /* 8210FAC4h */ case    1:  		/* addi R14, R14, 1 */
		/* 8210FAC4h case    1:*/		cpu::op::addi<0>(regs,&regs.R14,regs.R14,0x1);
		/* 8210FAC4h case    1:*/		return 0x8210FAC8;
		  /* 8210FAC8h */ case    2:  		/* addi R15, R15, 4 */
		/* 8210FAC8h case    2:*/		cpu::op::addi<0>(regs,&regs.R15,regs.R15,0x4);
		/* 8210FAC8h case    2:*/		return 0x8210FACC;
		  /* 8210FACCh */ case    3:  		/* cmplw CR6, R14, R11 */
		/* 8210FACCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R14,regs.R11);
		/* 8210FACCh case    3:*/		return 0x8210FAD0;
		  /* 8210FAD0h */ case    4:  		/* bc 12, CR6_LT, -1296 */
		/* 8210FAD0h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210F5C0;  }
		/* 8210FAD0h case    4:*/		return 0x8210FAD4;
		  /* 8210FAD4h */ case    5:  		/* lwz R11, <#[R1 + 80]> */
		/* 8210FAD4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8210FAD4h case    5:*/		return 0x8210FAD8;
		  /* 8210FAD8h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 8210FAD8h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8210FAD8h case    6:*/		return 0x8210FADC;
		  /* 8210FADCh */ case    7:  		/* bc 12, CR6_EQ, 24 */
		/* 8210FADCh case    7:*/		if ( regs.CR[6].eq ) { return 0x8210FAF4;  }
		/* 8210FADCh case    7:*/		return 0x8210FAE0;
		  /* 8210FAE0h */ case    8:  		/* li R11, 1 */
		/* 8210FAE0h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8210FAE0h case    8:*/		return 0x8210FAE4;
		  /* 8210FAE4h */ case    9:  		/* stw R26, <#[R1 + 80]> */
		/* 8210FAE4h case    9:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 8210FAE4h case    9:*/		return 0x8210FAE8;
		  /* 8210FAE8h */ case   10:  		/* mr R3, R29 */
		/* 8210FAE8h case   10:*/		regs.R3 = regs.R29;
		/* 8210FAE8h case   10:*/		return 0x8210FAEC;
		  /* 8210FAECh */ case   11:  		/* stw R11, <#[R1 + 96]> */
		/* 8210FAECh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 8210FAECh case   11:*/		return 0x8210FAF0;
		  /* 8210FAF0h */ case   12:  		/* bl -40792 */
		/* 8210FAF0h case   12:*/		regs.LR = 0x8210FAF4; return 0x82105B98;
		/* 8210FAF0h case   12:*/		return 0x8210FAF4;
	}
	return 0x8210FAF4;
} // Block from 8210FAC0h-8210FAF4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8210FAF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FAF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FAF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FAF4);
		  /* 8210FAF4h */ case    0:  		/* lwz R11, <#[R29 + 12]> */
		/* 8210FAF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 8210FAF4h case    0:*/		return 0x8210FAF8;
		  /* 8210FAF8h */ case    1:  		/* mr R25, R26 */
		/* 8210FAF8h case    1:*/		regs.R25 = regs.R26;
		/* 8210FAF8h case    1:*/		return 0x8210FAFC;
		  /* 8210FAFCh */ case    2:  		/* lis R16, 12288 */
		/* 8210FAFCh case    2:*/		cpu::op::lis<0>(regs,&regs.R16,0x3000);
		/* 8210FAFCh case    2:*/		return 0x8210FB00;
		  /* 8210FB00h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8210FB00h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210FB00h case    3:*/		return 0x8210FB04;
		  /* 8210FB04h */ case    4:  		/* bc 4, CR6_GT, 592 */
		/* 8210FB04h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8210FD54;  }
		/* 8210FB04h case    4:*/		return 0x8210FB08;
		  /* 8210FB08h */ case    5:  		/* li R26, 0 */
		/* 8210FB08h case    5:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8210FB08h case    5:*/		return 0x8210FB0C;
		  /* 8210FB0Ch */ case    6:  		/* lwz R11, <#[R1 + 372]> */
		/* 8210FB0Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000174) );
		/* 8210FB0Ch case    6:*/		return 0x8210FB10;
		  /* 8210FB10h */ case    7:  		/* lwz R24, <#[R1 + 372]> */
		/* 8210FB10h case    7:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000174) );
		/* 8210FB10h case    7:*/		return 0x8210FB14;
		  /* 8210FB14h */ case    8:  		/* lwz R11, <#[R11 + 24]> */
		/* 8210FB14h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8210FB14h case    8:*/		return 0x8210FB18;
		  /* 8210FB18h */ case    9:  		/* lwzx R29, <#[R11 + R26]> */
		/* 8210FB18h case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 8210FB18h case    9:*/		return 0x8210FB1C;
		  /* 8210FB1Ch */ case   10:  		/* lwz R11, <#[R29]> */
		/* 8210FB1Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8210FB1Ch case   10:*/		return 0x8210FB20;
		  /* 8210FB20h */ case   11:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 8210FB20h case   11:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 8210FB20h case   11:*/		return 0x8210FB24;
		  /* 8210FB24h */ case   12:  		/* bc 12, CR0_EQ, 540 */
		/* 8210FB24h case   12:*/		if ( regs.CR[0].eq ) { return 0x8210FD40;  }
		/* 8210FB24h case   12:*/		return 0x8210FB28;
		  /* 8210FB28h */ case   13:  		/* lwz R28, <#[R29 + 12]> */
		/* 8210FB28h case   13:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x0000000C) );
		/* 8210FB28h case   13:*/		return 0x8210FB2C;
		  /* 8210FB2Ch */ case   14:  		/* cmplwi CR6, R28, 0 */
		/* 8210FB2Ch case   14:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8210FB2Ch case   14:*/		return 0x8210FB30;
		  /* 8210FB30h */ case   15:  		/* bc 12, CR6_EQ, 36 */
		/* 8210FB30h case   15:*/		if ( regs.CR[6].eq ) { return 0x8210FB54;  }
		/* 8210FB30h case   15:*/		return 0x8210FB34;
		  /* 8210FB34h */ case   16:  		/* lwz R10, <#[R29 + 16]> */
		/* 8210FB34h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000010) );
		/* 8210FB34h case   16:*/		return 0x8210FB38;
		  /* 8210FB38h */ case   17:  		/* lwz R9, <#[R24 + 20]> */
		/* 8210FB38h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000014) );
		/* 8210FB38h case   17:*/		return 0x8210FB3C;
		  /* 8210FB3Ch */ case   18:  		/* lwz R10, <#[R10]> */
		/* 8210FB3Ch case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 8210FB3Ch case   18:*/		return 0x8210FB40;
		  /* 8210FB40h */ case   19:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210FB40h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210FB40h case   19:*/		return 0x8210FB44;
		  /* 8210FB44h */ case   20:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210FB44h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210FB44h case   20:*/		return 0x8210FB48;
		  /* 8210FB48h */ case   21:  		/* lwz R10, <#[R10]> */
		/* 8210FB48h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 8210FB48h case   21:*/		return 0x8210FB4C;
		  /* 8210FB4Ch */ case   22:  		/* rlwinm. R10, R10, 0, 25, 25 */
		/* 8210FB4Ch case   22:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R10);
		/* 8210FB4Ch case   22:*/		return 0x8210FB50;
		  /* 8210FB50h */ case   23:  		/* bc 4, CR0_EQ, 496 */
		/* 8210FB50h case   23:*/		if ( !regs.CR[0].eq ) { return 0x8210FD40;  }
		/* 8210FB50h case   23:*/		return 0x8210FB54;
	}
	return 0x8210FB54;
} // Block from 8210FAF4h-8210FB54h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8210FB54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FB54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FB54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FB54);
		  /* 8210FB54h */ case    0:  		/* cmplw CR6, R11, R16 */
		/* 8210FB54h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R16);
		/* 8210FB54h case    0:*/		return 0x8210FB58;
		  /* 8210FB58h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8210FB58h case    1:*/		if ( regs.CR[6].eq ) { return 0x8210FB68;  }
		/* 8210FB58h case    1:*/		return 0x8210FB5C;
		  /* 8210FB5Ch */ case    2:  		/* lis R10, 4352 */
		/* 8210FB5Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0x1100);
		/* 8210FB5Ch case    2:*/		return 0x8210FB60;
		  /* 8210FB60h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 8210FB60h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210FB60h case    3:*/		return 0x8210FB64;
		  /* 8210FB64h */ case    4:  		/* bc 4, CR6_EQ, 476 */
		/* 8210FB64h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8210FD40;  }
		/* 8210FB64h case    4:*/		return 0x8210FB68;
	}
	return 0x8210FB68;
} // Block from 8210FB54h-8210FB68h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210FB68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FB68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FB68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FB68);
		  /* 8210FB68h */ case    0:  		/* li R27, 0 */
		/* 8210FB68h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8210FB68h case    0:*/		return 0x8210FB6C;
		  /* 8210FB6Ch */ case    1:  		/* cmplwi CR6, R28, 0 */
		/* 8210FB6Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8210FB6Ch case    1:*/		return 0x8210FB70;
		  /* 8210FB70h */ case    2:  		/* bc 12, CR6_EQ, 464 */
		/* 8210FB70h case    2:*/		if ( regs.CR[6].eq ) { return 0x8210FD40;  }
		/* 8210FB70h case    2:*/		return 0x8210FB74;
		  /* 8210FB74h */ case    3:  		/* li R30, 0 */
		/* 8210FB74h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8210FB74h case    3:*/		return 0x8210FB78;
		  /* 8210FB78h */ case    4:  		/* lwz R31, <#[R29 + 8]> */
		/* 8210FB78h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000008) );
		/* 8210FB78h case    4:*/		return 0x8210FB7C;
		  /* 8210FB7Ch */ case    5:  		/* lwz R5, <#[R24 + 20]> */
		/* 8210FB7Ch case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R24 + 0x00000014) );
		/* 8210FB7Ch case    5:*/		return 0x8210FB80;
		  /* 8210FB80h */ case    6:  		/* lwz R4, <#[R24 + 16]> */
		/* 8210FB80h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R24 + 0x00000010) );
		/* 8210FB80h case    6:*/		return 0x8210FB84;
		  /* 8210FB84h */ case    7:  		/* lwzx R3, <#[R31 + R30]> */
		/* 8210FB84h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + regs.R30 + 0x00000000) );
		/* 8210FB84h case    7:*/		return 0x8210FB88;
		  /* 8210FB88h */ case    8:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 8210FB88h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 8210FB88h case    8:*/		return 0x8210FB8C;
		  /* 8210FB8Ch */ case    9:  		/* mr R6, R3 */
		/* 8210FB8Ch case    9:*/		regs.R6 = regs.R3;
		/* 8210FB8Ch case    9:*/		return 0x8210FB90;
		  /* 8210FB90h */ case   10:  		/* lwzx R11, <#[R11 + R5]> */
		/* 8210FB90h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 8210FB90h case   10:*/		return 0x8210FB94;
		  /* 8210FB94h */ case   11:  		/* lwz R10, <#[R11 + 4]> */
		/* 8210FB94h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210FB94h case   11:*/		return 0x8210FB98;
		  /* 8210FB98h */ case   12:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210FB98h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210FB98h case   12:*/		return 0x8210FB9C;
		  /* 8210FB9Ch */ case   13:  		/* lwzx R10, <#[R10 + R4]> */
		/* 8210FB9Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 8210FB9Ch case   13:*/		return 0x8210FBA0;
		  /* 8210FBA0h */ case   14:  		/* b 364 */
		/* 8210FBA0h case   14:*/		return 0x8210FD0C;
		/* 8210FBA0h case   14:*/		return 0x8210FBA4;
		  /* 8210FBA4h */ case   15:  		/* lwz R10, <#[R11 + 8]> */
		/* 8210FBA4h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8210FBA4h case   15:*/		return 0x8210FBA8;
		  /* 8210FBA8h */ case   16:  		/* cmpwi CR6, R10, -1 */
		/* 8210FBA8h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210FBA8h case   16:*/		return 0x8210FBAC;
		  /* 8210FBACh */ case   17:  		/* bc 4, CR6_EQ, 364 */
		/* 8210FBACh case   17:*/		if ( !regs.CR[6].eq ) { return 0x8210FD18;  }
		/* 8210FBACh case   17:*/		return 0x8210FBB0;
		  /* 8210FBB0h */ case   18:  		/* lwz R8, <#[R29 + 4]> */
		/* 8210FBB0h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000004) );
		/* 8210FBB0h case   18:*/		return 0x8210FBB4;
		  /* 8210FBB4h */ case   19:  		/* mr R10, R28 */
		/* 8210FBB4h case   19:*/		regs.R10 = regs.R28;
		/* 8210FBB4h case   19:*/		return 0x8210FBB8;
		  /* 8210FBB8h */ case   20:  		/* cmplw CR6, R28, R8 */
		/* 8210FBB8h case   20:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R8);
		/* 8210FBB8h case   20:*/		return 0x8210FBBC;
		  /* 8210FBBCh */ case   21:  		/* bc 4, CR6_LT, 36 */
		/* 8210FBBCh case   21:*/		if ( !regs.CR[6].lt ) { return 0x8210FBE0;  }
		/* 8210FBBCh case   21:*/		return 0x8210FBC0;
		  /* 8210FBC0h */ case   22:  		/* rlwinm R9, R28, 2, 0, 29 */
		/* 8210FBC0h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R28);
		/* 8210FBC0h case   22:*/		return 0x8210FBC4;
		  /* 8210FBC4h */ case   23:  		/* lwzx R7, <#[R31 + R9]> */
		/* 8210FBC4h case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + regs.R9 + 0x00000000) );
		/* 8210FBC4h case   23:*/		return 0x8210FBC8;
		  /* 8210FBC8h */ case   24:  		/* cmplw CR6, R6, R7 */
		/* 8210FBC8h case   24:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R7);
		/* 8210FBC8h case   24:*/		return 0x8210FBCC;
		  /* 8210FBCCh */ case   25:  		/* bc 12, CR6_EQ, 20 */
		/* 8210FBCCh case   25:*/		if ( regs.CR[6].eq ) { return 0x8210FBE0;  }
		/* 8210FBCCh case   25:*/		return 0x8210FBD0;
		  /* 8210FBD0h */ case   26:  		/* addi R10, R10, 1 */
		/* 8210FBD0h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210FBD0h case   26:*/		return 0x8210FBD4;
		  /* 8210FBD4h */ case   27:  		/* addi R9, R9, 4 */
		/* 8210FBD4h case   27:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8210FBD4h case   27:*/		return 0x8210FBD8;
		  /* 8210FBD8h */ case   28:  		/* cmplw CR6, R10, R8 */
		/* 8210FBD8h case   28:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8210FBD8h case   28:*/		return 0x8210FBDC;
		  /* 8210FBDCh */ case   29:  		/* bc 12, CR6_LT, -24 */
		/* 8210FBDCh case   29:*/		if ( regs.CR[6].lt ) { return 0x8210FBC4;  }
		/* 8210FBDCh case   29:*/		return 0x8210FBE0;
	}
	return 0x8210FBE0;
} // Block from 8210FB68h-8210FBE0h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8210FBE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FBE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FBE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FBE0);
		  /* 8210FBE0h */ case    0:  		/* cmplw CR6, R10, R8 */
		/* 8210FBE0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8210FBE0h case    0:*/		return 0x8210FBE4;
		  /* 8210FBE4h */ case    1:  		/* bc 12, CR6_LT, 308 */
		/* 8210FBE4h case    1:*/		if ( regs.CR[6].lt ) { return 0x8210FD18;  }
		/* 8210FBE4h case    1:*/		return 0x8210FBE8;
		  /* 8210FBE8h */ case    2:  		/* lwz R10, <#[R11 + 72]> */
		/* 8210FBE8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000048) );
		/* 8210FBE8h case    2:*/		return 0x8210FBEC;
		  /* 8210FBECh */ case    3:  		/* li R11, 0 */
		/* 8210FBECh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210FBECh case    3:*/		return 0x8210FBF0;
		  /* 8210FBF0h */ case    4:  		/* lwz R9, <#[R24 + 24]> */
		/* 8210FBF0h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000018) );
		/* 8210FBF0h case    4:*/		return 0x8210FBF4;
		  /* 8210FBF4h */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210FBF4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210FBF4h case    5:*/		return 0x8210FBF8;
		  /* 8210FBF8h */ case    6:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210FBF8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210FBF8h case    6:*/		return 0x8210FBFC;
		  /* 8210FBFCh */ case    7:  		/* lwz R9, <#[R10 + 12]> */
		/* 8210FBFCh case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 8210FBFCh case    7:*/		return 0x8210FC00;
		  /* 8210FC00h */ case    8:  		/* cmplwi CR6, R9, 0 */
		/* 8210FC00h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8210FC00h case    8:*/		return 0x8210FC04;
		  /* 8210FC04h */ case    9:  		/* bc 12, CR6_EQ, 40 */
		/* 8210FC04h case    9:*/		if ( regs.CR[6].eq ) { return 0x8210FC2C;  }
		/* 8210FC04h case    9:*/		return 0x8210FC08;
		  /* 8210FC08h */ case   10:  		/* lwz R7, <#[R10 + 16]> */
		/* 8210FC08h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000010) );
		/* 8210FC08h case   10:*/		return 0x8210FC0C;
		  /* 8210FC0Ch */ case   11:  		/* li R8, 0 */
		/* 8210FC0Ch case   11:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8210FC0Ch case   11:*/		return 0x8210FC10;
		  /* 8210FC10h */ case   12:  		/* lwzx R23, <#[R7 + R8]> */
		/* 8210FC10h case   12:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 8210FC10h case   12:*/		return 0x8210FC14;
		  /* 8210FC14h */ case   13:  		/* cmplw CR6, R23, R6 */
		/* 8210FC14h case   13:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R6);
		/* 8210FC14h case   13:*/		return 0x8210FC18;
		  /* 8210FC18h */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 8210FC18h case   14:*/		if ( regs.CR[6].eq ) { return 0x8210FC2C;  }
		/* 8210FC18h case   14:*/		return 0x8210FC1C;
		  /* 8210FC1Ch */ case   15:  		/* addi R11, R11, 1 */
		/* 8210FC1Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210FC1Ch case   15:*/		return 0x8210FC20;
		  /* 8210FC20h */ case   16:  		/* addi R8, R8, 4 */
		/* 8210FC20h case   16:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 8210FC20h case   16:*/		return 0x8210FC24;
		  /* 8210FC24h */ case   17:  		/* cmplw CR6, R11, R9 */
		/* 8210FC24h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210FC24h case   17:*/		return 0x8210FC28;
		  /* 8210FC28h */ case   18:  		/* bc 12, CR6_LT, -24 */
		/* 8210FC28h case   18:*/		if ( regs.CR[6].lt ) { return 0x8210FC10;  }
		/* 8210FC28h case   18:*/		return 0x8210FC2C;
	}
	return 0x8210FC2C;
} // Block from 8210FBE0h-8210FC2Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8210FC2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FC2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FC2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FC2C);
		  /* 8210FC2Ch */ case    0:  		/* lwz R8, <#[R10]> */
		/* 8210FC2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8210FC2Ch case    0:*/		return 0x8210FC30;
		  /* 8210FC30h */ case    1:  		/* lis R7, 8256 */
		/* 8210FC30h case    1:*/		cpu::op::lis<0>(regs,&regs.R7,0x2040);
		/* 8210FC30h case    1:*/		return 0x8210FC34;
		  /* 8210FC34h */ case    2:  		/* rlwinm R8, R8, 0, 0, 11 */
		/* 8210FC34h case    2:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R8,regs.R8);
		/* 8210FC34h case    2:*/		return 0x8210FC38;
		  /* 8210FC38h */ case    3:  		/* cmplw CR6, R8, R7 */
		/* 8210FC38h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 8210FC38h case    3:*/		return 0x8210FC3C;
		  /* 8210FC3Ch */ case    4:  		/* bc 4, CR6_EQ, 44 */
		/* 8210FC3Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x8210FC68;  }
		/* 8210FC3Ch case    4:*/		return 0x8210FC40;
		  /* 8210FC40h */ case    5:  		/* add R9, R9, R11 */
		/* 8210FC40h case    5:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 8210FC40h case    5:*/		return 0x8210FC44;
		  /* 8210FC44h */ case    6:  		/* lwz R10, <#[R10 + 8]> */
		/* 8210FC44h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8210FC44h case    6:*/		return 0x8210FC48;
		  /* 8210FC48h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210FC48h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210FC48h case    7:*/		return 0x8210FC4C;
		  /* 8210FC4Ch */ case    8:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210FC4Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210FC4Ch case    8:*/		return 0x8210FC50;
		  /* 8210FC50h */ case    9:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210FC50h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210FC50h case    9:*/		return 0x8210FC54;
		  /* 8210FC54h */ case   10:  		/* lwzx R10, <#[R9 + R10]> */
		/* 8210FC54h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210FC54h case   10:*/		return 0x8210FC58;
		  /* 8210FC58h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 8210FC58h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210FC58h case   11:*/		return 0x8210FC5C;
		  /* 8210FC5Ch */ case   12:  		/* bc 4, CR6_EQ, 188 */
		/* 8210FC5Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x8210FD18;  }
		/* 8210FC5Ch case   12:*/		return 0x8210FC60;
		  /* 8210FC60h */ case   13:  		/* mr R6, R11 */
		/* 8210FC60h case   13:*/		regs.R6 = regs.R11;
		/* 8210FC60h case   13:*/		return 0x8210FC64;
		  /* 8210FC64h */ case   14:  		/* b 140 */
		/* 8210FC64h case   14:*/		return 0x8210FCF0;
		/* 8210FC64h case   14:*/		return 0x8210FC68;
	}
	return 0x8210FC68;
} // Block from 8210FC2Ch-8210FC68h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8210FC68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FC68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FC68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FC68);
		  /* 8210FC68h */ case    0:  		/* lis R7, 8272 */
		/* 8210FC68h case    0:*/		cpu::op::lis<0>(regs,&regs.R7,0x2050);
		/* 8210FC68h case    0:*/		return 0x8210FC6C;
		  /* 8210FC6Ch */ case    1:  		/* cmplw CR6, R8, R7 */
		/* 8210FC6Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 8210FC6Ch case    1:*/		return 0x8210FC70;
		  /* 8210FC70h */ case    2:  		/* bc 4, CR6_EQ, 168 */
		/* 8210FC70h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8210FD18;  }
		/* 8210FC70h case    2:*/		return 0x8210FC74;
		  /* 8210FC74h */ case    3:  		/* lwz R10, <#[R10 + 8]> */
		/* 8210FC74h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8210FC74h case    3:*/		return 0x8210FC78;
		  /* 8210FC78h */ case    4:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 8210FC78h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 8210FC78h case    4:*/		return 0x8210FC7C;
		  /* 8210FC7Ch */ case    5:  		/* add R11, R9, R11 */
		/* 8210FC7Ch case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8210FC7Ch case    5:*/		return 0x8210FC80;
		  /* 8210FC80h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210FC80h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210FC80h case    6:*/		return 0x8210FC84;
		  /* 8210FC84h */ case    7:  		/* lwzx R9, <#[R8 + R10]> */
		/* 8210FC84h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 8210FC84h case    7:*/		return 0x8210FC88;
		  /* 8210FC88h */ case    8:  		/* rlwinm R8, R9, 2, 0, 29 */
		/* 8210FC88h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R9);
		/* 8210FC88h case    8:*/		return 0x8210FC8C;
		  /* 8210FC8Ch */ case    9:  		/* lwzx R10, <#[R11 + R10]> */
		/* 8210FC8Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210FC8Ch case    9:*/		return 0x8210FC90;
		  /* 8210FC90h */ case   10:  		/* lwzx R11, <#[R8 + R5]> */
		/* 8210FC90h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R5 + 0x00000000) );
		/* 8210FC90h case   10:*/		return 0x8210FC94;
		  /* 8210FC94h */ case   11:  		/* lwz R8, <#[R11 + 4]> */
		/* 8210FC94h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8210FC94h case   11:*/		return 0x8210FC98;
		  /* 8210FC98h */ case   12:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8210FC98h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8210FC98h case   12:*/		return 0x8210FC9C;
		  /* 8210FC9Ch */ case   13:  		/* lwzx R8, <#[R8 + R4]> */
		/* 8210FC9Ch case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R4 + 0x00000000) );
		/* 8210FC9Ch case   13:*/		return 0x8210FCA0;
		  /* 8210FCA0h */ case   14:  		/* lwz R8, <#[R8 + 4]> */
		/* 8210FCA0h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 8210FCA0h case   14:*/		return 0x8210FCA4;
		  /* 8210FCA4h */ case   15:  		/* rlwinm. R8, R8, 0, 23, 23 */
		/* 8210FCA4h case   15:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R8,regs.R8);
		/* 8210FCA4h case   15:*/		return 0x8210FCA8;
		  /* 8210FCA8h */ case   16:  		/* bc 12, CR0_EQ, 24 */
		/* 8210FCA8h case   16:*/		if ( regs.CR[0].eq ) { return 0x8210FCC0;  }
		/* 8210FCA8h case   16:*/		return 0x8210FCAC;
		  /* 8210FCACh */ case   17:  		/* lfd FR0, <#[R11 + 32]> */
		/* 8210FCACh case   17:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 8210FCACh case   17:*/		return 0x8210FCB0;
		  /* 8210FCB0h */ case   18:  		/* fcmpu CR6, FR0, FR30 */
		/* 8210FCB0h case   18:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 8210FCB0h case   18:*/		return 0x8210FCB4;
		  /* 8210FCB4h */ case   19:  		/* bc 4, CR6_GT, 12 */
		/* 8210FCB4h case   19:*/		if ( !regs.CR[6].gt ) { return 0x8210FCC0;  }
		/* 8210FCB4h case   19:*/		return 0x8210FCB8;
		  /* 8210FCB8h */ case   20:  		/* mr R6, R10 */
		/* 8210FCB8h case   20:*/		regs.R6 = regs.R10;
		/* 8210FCB8h case   20:*/		return 0x8210FCBC;
		  /* 8210FCBCh */ case   21:  		/* b 52 */
		/* 8210FCBCh case   21:*/		return 0x8210FCF0;
		/* 8210FCBCh case   21:*/		return 0x8210FCC0;
	}
	return 0x8210FCC0;
} // Block from 8210FC68h-8210FCC0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8210FCC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FCC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FCC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FCC0);
		  /* 8210FCC0h */ case    0:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 8210FCC0h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 8210FCC0h case    0:*/		return 0x8210FCC4;
		  /* 8210FCC4h */ case    1:  		/* lwzx R11, <#[R11 + R5]> */
		/* 8210FCC4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 8210FCC4h case    1:*/		return 0x8210FCC8;
		  /* 8210FCC8h */ case    2:  		/* lwz R10, <#[R11 + 4]> */
		/* 8210FCC8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210FCC8h case    2:*/		return 0x8210FCCC;
		  /* 8210FCCCh */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210FCCCh case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210FCCCh case    3:*/		return 0x8210FCD0;
		  /* 8210FCD0h */ case    4:  		/* lwzx R10, <#[R10 + R4]> */
		/* 8210FCD0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 8210FCD0h case    4:*/		return 0x8210FCD4;
		  /* 8210FCD4h */ case    5:  		/* lwz R10, <#[R10 + 4]> */
		/* 8210FCD4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8210FCD4h case    5:*/		return 0x8210FCD8;
		  /* 8210FCD8h */ case    6:  		/* rlwinm. R10, R10, 0, 23, 23 */
		/* 8210FCD8h case    6:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R10);
		/* 8210FCD8h case    6:*/		return 0x8210FCDC;
		  /* 8210FCDCh */ case    7:  		/* bc 12, CR0_EQ, 60 */
		/* 8210FCDCh case    7:*/		if ( regs.CR[0].eq ) { return 0x8210FD18;  }
		/* 8210FCDCh case    7:*/		return 0x8210FCE0;
		  /* 8210FCE0h */ case    8:  		/* lfd FR0, <#[R11 + 32]> */
		/* 8210FCE0h case    8:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 8210FCE0h case    8:*/		return 0x8210FCE4;
		  /* 8210FCE4h */ case    9:  		/* fcmpu CR6, FR0, FR30 */
		/* 8210FCE4h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 8210FCE4h case    9:*/		return 0x8210FCE8;
		  /* 8210FCE8h */ case   10:  		/* bc 4, CR6_GT, 48 */
		/* 8210FCE8h case   10:*/		if ( !regs.CR[6].gt ) { return 0x8210FD18;  }
		/* 8210FCE8h case   10:*/		return 0x8210FCEC;
		  /* 8210FCECh */ case   11:  		/* mr R6, R9 */
		/* 8210FCECh case   11:*/		regs.R6 = regs.R9;
		/* 8210FCECh case   11:*/		return 0x8210FCF0;
	}
	return 0x8210FCF0;
} // Block from 8210FCC0h-8210FCF0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8210FCF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FCF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FCF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FCF0);
		  /* 8210FCF0h */ case    0:  		/* lwz R11, <#[R24 + 20]> */
		/* 8210FCF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000014) );
		/* 8210FCF0h case    0:*/		return 0x8210FCF4;
		  /* 8210FCF4h */ case    1:  		/* rlwinm R10, R6, 2, 0, 29 */
		/* 8210FCF4h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R6);
		/* 8210FCF4h case    1:*/		return 0x8210FCF8;
		  /* 8210FCF8h */ case    2:  		/* lwz R9, <#[R24 + 16]> */
		/* 8210FCF8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000010) );
		/* 8210FCF8h case    2:*/		return 0x8210FCFC;
		  /* 8210FCFCh */ case    3:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8210FCFCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210FCFCh case    3:*/		return 0x8210FD00;
		  /* 8210FD00h */ case    4:  		/* lwz R10, <#[R11 + 4]> */
		/* 8210FD00h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210FD00h case    4:*/		return 0x8210FD04;
		  /* 8210FD04h */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210FD04h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210FD04h case    5:*/		return 0x8210FD08;
		  /* 8210FD08h */ case    6:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210FD08h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210FD08h case    6:*/		return 0x8210FD0C;
	}
	return 0x8210FD0C;
} // Block from 8210FCF0h-8210FD0Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210FD0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FD0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FD0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FD0C);
		  /* 8210FD0Ch */ case    0:  		/* lwz R10, <#[R10 + 4]> */
		/* 8210FD0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8210FD0Ch case    0:*/		return 0x8210FD10;
		  /* 8210FD10h */ case    1:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 8210FD10h case    1:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 8210FD10h case    1:*/		return 0x8210FD14;
		  /* 8210FD14h */ case    2:  		/* bc 4, CR0_EQ, -368 */
		/* 8210FD14h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8210FBA4;  }
		/* 8210FD14h case    2:*/		return 0x8210FD18;
	}
	return 0x8210FD18;
} // Block from 8210FD0Ch-8210FD18h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210FD18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FD18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FD18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FD18);
		  /* 8210FD18h */ case    0:  		/* cmplw CR6, R3, R6 */
		/* 8210FD18h case    0:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R6);
		/* 8210FD18h case    0:*/		return 0x8210FD1C;
		  /* 8210FD1Ch */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8210FD1Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8210FD2C;  }
		/* 8210FD1Ch case    1:*/		return 0x8210FD20;
		  /* 8210FD20h */ case    2:  		/* li R11, 1 */
		/* 8210FD20h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8210FD20h case    2:*/		return 0x8210FD24;
		  /* 8210FD24h */ case    3:  		/* stwx R6, <#[R31 + R30]> */
		/* 8210FD24h case    3:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R31 + regs.R30 + 0x00000000) );
		/* 8210FD24h case    3:*/		return 0x8210FD28;
		  /* 8210FD28h */ case    4:  		/* stw R11, <#[R1 + 80]> */
		/* 8210FD28h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8210FD28h case    4:*/		return 0x8210FD2C;
	}
	return 0x8210FD2C;
} // Block from 8210FD18h-8210FD2Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210FD2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FD2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FD2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FD2C);
		  /* 8210FD2Ch */ case    0:  		/* lwz R28, <#[R29 + 12]> */
		/* 8210FD2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x0000000C) );
		/* 8210FD2Ch case    0:*/		return 0x8210FD30;
		  /* 8210FD30h */ case    1:  		/* addi R27, R27, 1 */
		/* 8210FD30h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8210FD30h case    1:*/		return 0x8210FD34;
		  /* 8210FD34h */ case    2:  		/* addi R30, R30, 4 */
		/* 8210FD34h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8210FD34h case    2:*/		return 0x8210FD38;
		  /* 8210FD38h */ case    3:  		/* cmplw CR6, R27, R28 */
		/* 8210FD38h case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R28);
		/* 8210FD38h case    3:*/		return 0x8210FD3C;
		  /* 8210FD3Ch */ case    4:  		/* bc 12, CR6_LT, -452 */
		/* 8210FD3Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x8210FB78;  }
		/* 8210FD3Ch case    4:*/		return 0x8210FD40;
	}
	return 0x8210FD40;
} // Block from 8210FD2Ch-8210FD40h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210FD40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FD40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FD40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FD40);
		  /* 8210FD40h */ case    0:  		/* lwz R11, <#[R24 + 12]> */
		/* 8210FD40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000C) );
		/* 8210FD40h case    0:*/		return 0x8210FD44;
		  /* 8210FD44h */ case    1:  		/* addi R25, R25, 1 */
		/* 8210FD44h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 8210FD44h case    1:*/		return 0x8210FD48;
		  /* 8210FD48h */ case    2:  		/* addi R26, R26, 4 */
		/* 8210FD48h case    2:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 8210FD48h case    2:*/		return 0x8210FD4C;
		  /* 8210FD4Ch */ case    3:  		/* cmplw CR6, R25, R11 */
		/* 8210FD4Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 8210FD4Ch case    3:*/		return 0x8210FD50;
		  /* 8210FD50h */ case    4:  		/* bc 12, CR6_LT, -580 */
		/* 8210FD50h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210FB0C;  }
		/* 8210FD50h case    4:*/		return 0x8210FD54;
	}
	return 0x8210FD54;
} // Block from 8210FD40h-8210FD54h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210FD54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FD54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FD54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FD54);
		  /* 8210FD54h */ case    0:  		/* lwz R14, <#[R1 + 80]> */
		/* 8210FD54h case    0:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R1 + 0x00000050) );
		/* 8210FD54h case    0:*/		return 0x8210FD58;
		  /* 8210FD58h */ case    1:  		/* lwz R17, <#[R1 + 372]> */
		/* 8210FD58h case    1:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R1 + 0x00000174) );
		/* 8210FD58h case    1:*/		return 0x8210FD5C;
		  /* 8210FD5Ch */ case    2:  		/* cmpwi CR6, R14, 0 */
		/* 8210FD5Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 8210FD5Ch case    2:*/		return 0x8210FD60;
		  /* 8210FD60h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 8210FD60h case    3:*/		if ( regs.CR[6].eq ) { return 0x8210FD7C;  }
		/* 8210FD60h case    3:*/		return 0x8210FD64;
		  /* 8210FD64h */ case    4:  		/* li R14, 0 */
		/* 8210FD64h case    4:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 8210FD64h case    4:*/		return 0x8210FD68;
		  /* 8210FD68h */ case    5:  		/* mr R3, R17 */
		/* 8210FD68h case    5:*/		regs.R3 = regs.R17;
		/* 8210FD68h case    5:*/		return 0x8210FD6C;
		  /* 8210FD6Ch */ case    6:  		/* li R15, 1 */
		/* 8210FD6Ch case    6:*/		cpu::op::li<0>(regs,&regs.R15,0x1);
		/* 8210FD6Ch case    6:*/		return 0x8210FD70;
		  /* 8210FD70h */ case    7:  		/* stw R14, <#[R1 + 80]> */
		/* 8210FD70h case    7:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000050) );
		/* 8210FD70h case    7:*/		return 0x8210FD74;
		  /* 8210FD74h */ case    8:  		/* bl -41436 */
		/* 8210FD74h case    8:*/		regs.LR = 0x8210FD78; return 0x82105B98;
		/* 8210FD74h case    8:*/		return 0x8210FD78;
		  /* 8210FD78h */ case    9:  		/* b 8 */
		/* 8210FD78h case    9:*/		return 0x8210FD80;
		/* 8210FD78h case    9:*/		return 0x8210FD7C;
	}
	return 0x8210FD7C;
} // Block from 8210FD54h-8210FD7Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8210FD7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FD7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FD7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FD7C);
		  /* 8210FD7Ch */ case    0:  		/* lwz R15, <#[R1 + 96]> */
		/* 8210FD7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R1 + 0x00000060) );
		/* 8210FD7Ch case    0:*/		return 0x8210FD80;
	}
	return 0x8210FD80;
} // Block from 8210FD7Ch-8210FD80h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210FD80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FD80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FD80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FD80);
		  /* 8210FD80h */ case    0:  		/* lwz R11, <#[R17 + 12]> */
		/* 8210FD80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000000C) );
		/* 8210FD80h case    0:*/		return 0x8210FD84;
		  /* 8210FD84h */ case    1:  		/* li R18, 0 */
		/* 8210FD84h case    1:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 8210FD84h case    1:*/		return 0x8210FD88;
		  /* 8210FD88h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8210FD88h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210FD88h case    2:*/		return 0x8210FD8C;
		  /* 8210FD8Ch */ case    3:  		/* bc 4, CR6_GT, 1064 */
		/* 8210FD8Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x821101B4;  }
		/* 8210FD8Ch case    3:*/		return 0x8210FD90;
		  /* 8210FD90h */ case    4:  		/* li R19, 0 */
		/* 8210FD90h case    4:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 8210FD90h case    4:*/		return 0x8210FD94;
		  /* 8210FD94h */ case    5:  		/* lwz R11, <#[R17 + 24]> */
		/* 8210FD94h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000018) );
		/* 8210FD94h case    5:*/		return 0x8210FD98;
		  /* 8210FD98h */ case    6:  		/* lwzx R5, <#[R11 + R19]> */
		/* 8210FD98h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R19 + 0x00000000) );
		/* 8210FD98h case    6:*/		return 0x8210FD9C;
		  /* 8210FD9Ch */ case    7:  		/* lwz R11, <#[R5]> */
		/* 8210FD9Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8210FD9Ch case    7:*/		return 0x8210FDA0;
		  /* 8210FDA0h */ case    8:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 8210FDA0h case    8:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 8210FDA0h case    8:*/		return 0x8210FDA4;
		  /* 8210FDA4h */ case    9:  		/* bc 12, CR0_EQ, 1020 */
		/* 8210FDA4h case    9:*/		if ( regs.CR[0].eq ) { return 0x821101A0;  }
		/* 8210FDA4h case    9:*/		return 0x8210FDA8;
		  /* 8210FDA8h */ case   10:  		/* lwz R21, <#[R5 + 12]> */
		/* 8210FDA8h case   10:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R5 + 0x0000000C) );
		/* 8210FDA8h case   10:*/		return 0x8210FDAC;
		  /* 8210FDACh */ case   11:  		/* cmplwi CR6, R21, 0 */
		/* 8210FDACh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 8210FDACh case   11:*/		return 0x8210FDB0;
		  /* 8210FDB0h */ case   12:  		/* bc 12, CR6_EQ, 36 */
		/* 8210FDB0h case   12:*/		if ( regs.CR[6].eq ) { return 0x8210FDD4;  }
		/* 8210FDB0h case   12:*/		return 0x8210FDB4;
		  /* 8210FDB4h */ case   13:  		/* lwz R10, <#[R5 + 16]> */
		/* 8210FDB4h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000010) );
		/* 8210FDB4h case   13:*/		return 0x8210FDB8;
		  /* 8210FDB8h */ case   14:  		/* lwz R9, <#[R17 + 20]> */
		/* 8210FDB8h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000014) );
		/* 8210FDB8h case   14:*/		return 0x8210FDBC;
		  /* 8210FDBCh */ case   15:  		/* lwz R10, <#[R10]> */
		/* 8210FDBCh case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 8210FDBCh case   15:*/		return 0x8210FDC0;
		  /* 8210FDC0h */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210FDC0h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210FDC0h case   16:*/		return 0x8210FDC4;
		  /* 8210FDC4h */ case   17:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210FDC4h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210FDC4h case   17:*/		return 0x8210FDC8;
		  /* 8210FDC8h */ case   18:  		/* lwz R10, <#[R10]> */
		/* 8210FDC8h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 8210FDC8h case   18:*/		return 0x8210FDCC;
		  /* 8210FDCCh */ case   19:  		/* rlwinm. R10, R10, 0, 25, 25 */
		/* 8210FDCCh case   19:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R10);
		/* 8210FDCCh case   19:*/		return 0x8210FDD0;
		  /* 8210FDD0h */ case   20:  		/* bc 4, CR0_EQ, 976 */
		/* 8210FDD0h case   20:*/		if ( !regs.CR[0].eq ) { return 0x821101A0;  }
		/* 8210FDD0h case   20:*/		return 0x8210FDD4;
	}
	return 0x8210FDD4;
} // Block from 8210FD80h-8210FDD4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8210FDD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FDD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FDD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FDD4);
		  /* 8210FDD4h */ case    0:  		/* cmplw CR6, R11, R16 */
		/* 8210FDD4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R16);
		/* 8210FDD4h case    0:*/		return 0x8210FDD8;
		  /* 8210FDD8h */ case    1:  		/* bc 4, CR6_EQ, 968 */
		/* 8210FDD8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821101A0;  }
		/* 8210FDD8h case    1:*/		return 0x8210FDDC;
		  /* 8210FDDCh */ case    2:  		/* li R30, 0 */
		/* 8210FDDCh case    2:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8210FDDCh case    2:*/		return 0x8210FDE0;
		  /* 8210FDE0h */ case    3:  		/* cmplwi CR6, R21, 0 */
		/* 8210FDE0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 8210FDE0h case    3:*/		return 0x8210FDE4;
		  /* 8210FDE4h */ case    4:  		/* bc 12, CR6_EQ, 956 */
		/* 8210FDE4h case    4:*/		if ( regs.CR[6].eq ) { return 0x821101A0;  }
		/* 8210FDE4h case    4:*/		return 0x8210FDE8;
		  /* 8210FDE8h */ case    5:  		/* li R20, 0 */
		/* 8210FDE8h case    5:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 8210FDE8h case    5:*/		return 0x8210FDEC;
		  /* 8210FDECh */ case    6:  		/* lwz R23, <#[R5 + 8]> */
		/* 8210FDECh case    6:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R5 + 0x00000008) );
		/* 8210FDECh case    6:*/		return 0x8210FDF0;
		  /* 8210FDF0h */ case    7:  		/* lwz R31, <#[R17 + 20]> */
		/* 8210FDF0h case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R17 + 0x00000014) );
		/* 8210FDF0h case    7:*/		return 0x8210FDF4;
		  /* 8210FDF4h */ case    8:  		/* lwz R26, <#[R17 + 16]> */
		/* 8210FDF4h case    8:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R17 + 0x00000010) );
		/* 8210FDF4h case    8:*/		return 0x8210FDF8;
		  /* 8210FDF8h */ case    9:  		/* lwzx R6, <#[R23 + R20]> */
		/* 8210FDF8h case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R23 + regs.R20 + 0x00000000) );
		/* 8210FDF8h case    9:*/		return 0x8210FDFC;
		  /* 8210FDFCh */ case   10:  		/* rlwinm R11, R6, 2, 0, 29 */
		/* 8210FDFCh case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R6);
		/* 8210FDFCh case   10:*/		return 0x8210FE00;
		  /* 8210FE00h */ case   11:  		/* lwzx R11, <#[R11 + R31]> */
		/* 8210FE00h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 8210FE00h case   11:*/		return 0x8210FE04;
		  /* 8210FE04h */ case   12:  		/* lwz R10, <#[R11 + 4]> */
		/* 8210FE04h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210FE04h case   12:*/		return 0x8210FE08;
		  /* 8210FE08h */ case   13:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210FE08h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210FE08h case   13:*/		return 0x8210FE0C;
		  /* 8210FE0Ch */ case   14:  		/* lwzx R10, <#[R10 + R26]> */
		/* 8210FE0Ch case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R26 + 0x00000000) );
		/* 8210FE0Ch case   14:*/		return 0x8210FE10;
		  /* 8210FE10h */ case   15:  		/* lwz R10, <#[R10 + 4]> */
		/* 8210FE10h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8210FE10h case   15:*/		return 0x8210FE14;
		  /* 8210FE14h */ case   16:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 8210FE14h case   16:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 8210FE14h case   16:*/		return 0x8210FE18;
		  /* 8210FE18h */ case   17:  		/* bc 12, CR0_EQ, 884 */
		/* 8210FE18h case   17:*/		if ( regs.CR[0].eq ) { return 0x8211018C;  }
		/* 8210FE18h case   17:*/		return 0x8210FE1C;
		  /* 8210FE1Ch */ case   18:  		/* lwz R10, <#[R11 + 8]> */
		/* 8210FE1Ch case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8210FE1Ch case   18:*/		return 0x8210FE20;
		  /* 8210FE20h */ case   19:  		/* cmpwi CR6, R10, -1 */
		/* 8210FE20h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210FE20h case   19:*/		return 0x8210FE24;
		  /* 8210FE24h */ case   20:  		/* bc 4, CR6_EQ, 872 */
		/* 8210FE24h case   20:*/		if ( !regs.CR[6].eq ) { return 0x8211018C;  }
		/* 8210FE24h case   20:*/		return 0x8210FE28;
		  /* 8210FE28h */ case   21:  		/* lwz R11, <#[R11 + 72]> */
		/* 8210FE28h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 8210FE28h case   21:*/		return 0x8210FE2C;
		  /* 8210FE2Ch */ case   22:  		/* li R9, 0 */
		/* 8210FE2Ch case   22:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8210FE2Ch case   22:*/		return 0x8210FE30;
		  /* 8210FE30h */ case   23:  		/* lwz R22, <#[R17 + 24]> */
		/* 8210FE30h case   23:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R17 + 0x00000018) );
		/* 8210FE30h case   23:*/		return 0x8210FE34;
		  /* 8210FE34h */ case   24:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210FE34h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210FE34h case   24:*/		return 0x8210FE38;
		  /* 8210FE38h */ case   25:  		/* lwzx R11, <#[R11 + R22]> */
		/* 8210FE38h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R22 + 0x00000000) );
		/* 8210FE38h case   25:*/		return 0x8210FE3C;
		  /* 8210FE3Ch */ case   26:  		/* lwz R10, <#[R11 + 12]> */
		/* 8210FE3Ch case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210FE3Ch case   26:*/		return 0x8210FE40;
		  /* 8210FE40h */ case   27:  		/* cmplwi CR6, R10, 0 */
		/* 8210FE40h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8210FE40h case   27:*/		return 0x8210FE44;
		  /* 8210FE44h */ case   28:  		/* bc 12, CR6_EQ, 40 */
		/* 8210FE44h case   28:*/		if ( regs.CR[6].eq ) { return 0x8210FE6C;  }
		/* 8210FE44h case   28:*/		return 0x8210FE48;
		  /* 8210FE48h */ case   29:  		/* lwz R7, <#[R11 + 16]> */
		/* 8210FE48h case   29:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000010) );
		/* 8210FE48h case   29:*/		return 0x8210FE4C;
		  /* 8210FE4Ch */ case   30:  		/* li R8, 0 */
		/* 8210FE4Ch case   30:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8210FE4Ch case   30:*/		return 0x8210FE50;
		  /* 8210FE50h */ case   31:  		/* lwzx R4, <#[R7 + R8]> */
		/* 8210FE50h case   31:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 8210FE50h case   31:*/		return 0x8210FE54;
		  /* 8210FE54h */ case   32:  		/* cmplw CR6, R4, R6 */
		/* 8210FE54h case   32:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R6);
		/* 8210FE54h case   32:*/		return 0x8210FE58;
		  /* 8210FE58h */ case   33:  		/* bc 12, CR6_EQ, 20 */
		/* 8210FE58h case   33:*/		if ( regs.CR[6].eq ) { return 0x8210FE6C;  }
		/* 8210FE58h case   33:*/		return 0x8210FE5C;
		  /* 8210FE5Ch */ case   34:  		/* addi R9, R9, 1 */
		/* 8210FE5Ch case   34:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8210FE5Ch case   34:*/		return 0x8210FE60;
		  /* 8210FE60h */ case   35:  		/* addi R8, R8, 4 */
		/* 8210FE60h case   35:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 8210FE60h case   35:*/		return 0x8210FE64;
		  /* 8210FE64h */ case   36:  		/* cmplw CR6, R9, R10 */
		/* 8210FE64h case   36:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 8210FE64h case   36:*/		return 0x8210FE68;
		  /* 8210FE68h */ case   37:  		/* bc 12, CR6_LT, -24 */
		/* 8210FE68h case   37:*/		if ( regs.CR[6].lt ) { return 0x8210FE50;  }
		/* 8210FE68h case   37:*/		return 0x8210FE6C;
	}
	return 0x8210FE6C;
} // Block from 8210FDD4h-8210FE6Ch (38 instructions)

//////////////////////////////////////////////////////
// Block at 8210FE6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FE6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FE6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FE6C);
		  /* 8210FE6Ch */ case    0:  		/* lwz R8, <#[R11]> */
		/* 8210FE6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8210FE6Ch case    0:*/		return 0x8210FE70;
		  /* 8210FE70h */ case    1:  		/* lis R7, 4112 */
		/* 8210FE70h case    1:*/		cpu::op::lis<0>(regs,&regs.R7,0x1010);
		/* 8210FE70h case    1:*/		return 0x8210FE74;
		  /* 8210FE74h */ case    2:  		/* rlwinm R24, R8, 0, 0, 11 */
		/* 8210FE74h case    2:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R24,regs.R8);
		/* 8210FE74h case    2:*/		return 0x8210FE78;
		  /* 8210FE78h */ case    3:  		/* cmplw CR6, R24, R7 */
		/* 8210FE78h case    3:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R7);
		/* 8210FE78h case    3:*/		return 0x8210FE7C;
		  /* 8210FE7Ch */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 8210FE7Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x8210FE88;  }
		/* 8210FE7Ch case    4:*/		return 0x8210FE80;
		  /* 8210FE80h */ case    5:  		/* li R25, 1 */
		/* 8210FE80h case    5:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 8210FE80h case    5:*/		return 0x8210FE84;
		  /* 8210FE84h */ case    6:  		/* b 20 */
		/* 8210FE84h case    6:*/		return 0x8210FE98;
		/* 8210FE84h case    6:*/		return 0x8210FE88;
	}
	return 0x8210FE88;
} // Block from 8210FE6Ch-8210FE88h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210FE88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FE88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FE88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FE88);
		  /* 8210FE88h */ case    0:  		/* lis R8, 8272 */
		/* 8210FE88h case    0:*/		cpu::op::lis<0>(regs,&regs.R8,0x2050);
		/* 8210FE88h case    0:*/		return 0x8210FE8C;
		  /* 8210FE8Ch */ case    1:  		/* cmplw CR6, R24, R8 */
		/* 8210FE8Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R8);
		/* 8210FE8Ch case    1:*/		return 0x8210FE90;
		  /* 8210FE90h */ case    2:  		/* bc 4, CR6_EQ, 764 */
		/* 8210FE90h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8211018C;  }
		/* 8210FE90h case    2:*/		return 0x8210FE94;
		  /* 8210FE94h */ case    3:  		/* li R25, 2 */
		/* 8210FE94h case    3:*/		cpu::op::li<0>(regs,&regs.R25,0x2);
		/* 8210FE94h case    3:*/		return 0x8210FE98;
	}
	return 0x8210FE98;
} // Block from 8210FE88h-8210FE98h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210FE98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FE98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FE98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FE98);
		  /* 8210FE98h */ case    0:  		/* li R27, 0 */
		/* 8210FE98h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8210FE98h case    0:*/		return 0x8210FE9C;
		  /* 8210FE9Ch */ case    1:  		/* cmplwi CR6, R25, 0 */
		/* 8210FE9Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 8210FE9Ch case    1:*/		return 0x8210FEA0;
		  /* 8210FEA0h */ case    2:  		/* bc 12, CR6_EQ, 748 */
		/* 8210FEA0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8211018C;  }
		/* 8210FEA0h case    2:*/		return 0x8210FEA4;
		  /* 8210FEA4h */ case    3:  		/* add R8, R10, R9 */
		/* 8210FEA4h case    3:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R9);
		/* 8210FEA4h case    3:*/		return 0x8210FEA8;
		  /* 8210FEA8h */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 8210FEA8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8210FEA8h case    4:*/		return 0x8210FEAC;
		  /* 8210FEACh */ case    5:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210FEACh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210FEACh case    5:*/		return 0x8210FEB0;
		  /* 8210FEB0h */ case    6:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8210FEB0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8210FEB0h case    6:*/		return 0x8210FEB4;
		  /* 8210FEB4h */ case    7:  		/* rlwinm R29, R10, 2, 0, 29 */
		/* 8210FEB4h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R10);
		/* 8210FEB4h case    7:*/		return 0x8210FEB8;
		  /* 8210FEB8h */ case    8:  		/* mulli R28, R10, -4 */
		/* 8210FEB8h case    8:*/		cpu::op::mulli<0>(regs,&regs.R28,regs.R10,0xFFFFFFFC);
		/* 8210FEB8h case    8:*/		return 0x8210FEBC;
		  /* 8210FEBCh */ case    9:  		/* add R4, R9, R11 */
		/* 8210FEBCh case    9:*/		cpu::op::add<0>(regs,&regs.R4,regs.R9,regs.R11);
		/* 8210FEBCh case    9:*/		return 0x8210FEC0;
		  /* 8210FEC0h */ case   10:  		/* add R3, R8, R11 */
		/* 8210FEC0h case   10:*/		cpu::op::add<0>(regs,&regs.R3,regs.R8,regs.R11);
		/* 8210FEC0h case   10:*/		return 0x8210FEC4;
		  /* 8210FEC4h */ case   11:  		/* lwz R8, <#[R4]> */
		/* 8210FEC4h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000000) );
		/* 8210FEC4h case   11:*/		return 0x8210FEC8;
		  /* 8210FEC8h */ case   12:  		/* lis R11, 8272 */
		/* 8210FEC8h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0x2050);
		/* 8210FEC8h case   12:*/		return 0x8210FECC;
		  /* 8210FECCh */ case   13:  		/* rlwinm R10, R8, 2, 0, 29 */
		/* 8210FECCh case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R8);
		/* 8210FECCh case   13:*/		return 0x8210FED0;
		  /* 8210FED0h */ case   14:  		/* cmplw CR6, R24, R11 */
		/* 8210FED0h case   14:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R11);
		/* 8210FED0h case   14:*/		return 0x8210FED4;
		  /* 8210FED4h */ case   15:  		/* lwzx R9, <#[R10 + R31]> */
		/* 8210FED4h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 8210FED4h case   15:*/		return 0x8210FED8;
		  /* 8210FED8h */ case   16:  		/* bc 4, CR6_EQ, 64 */
		/* 8210FED8h case   16:*/		if ( !regs.CR[6].eq ) { return 0x8210FF18;  }
		/* 8210FED8h case   16:*/		return 0x8210FEDC;
		  /* 8210FEDCh */ case   17:  		/* lwz R11, <#[R3]> */
		/* 8210FEDCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8210FEDCh case   17:*/		return 0x8210FEE0;
		  /* 8210FEE0h */ case   18:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210FEE0h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210FEE0h case   18:*/		return 0x8210FEE4;
		  /* 8210FEE4h */ case   19:  		/* lwzx R11, <#[R11 + R31]> */
		/* 8210FEE4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 8210FEE4h case   19:*/		return 0x8210FEE8;
		  /* 8210FEE8h */ case   20:  		/* lwz R10, <#[R11 + 4]> */
		/* 8210FEE8h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210FEE8h case   20:*/		return 0x8210FEEC;
		  /* 8210FEECh */ case   21:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210FEECh case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210FEECh case   21:*/		return 0x8210FEF0;
		  /* 8210FEF0h */ case   22:  		/* lwzx R10, <#[R10 + R26]> */
		/* 8210FEF0h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R26 + 0x00000000) );
		/* 8210FEF0h case   22:*/		return 0x8210FEF4;
		  /* 8210FEF4h */ case   23:  		/* lwz R10, <#[R10 + 4]> */
		/* 8210FEF4h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8210FEF4h case   23:*/		return 0x8210FEF8;
		  /* 8210FEF8h */ case   24:  		/* rlwinm. R10, R10, 0, 23, 23 */
		/* 8210FEF8h case   24:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R10);
		/* 8210FEF8h case   24:*/		return 0x8210FEFC;
		  /* 8210FEFCh */ case   25:  		/* bc 12, CR0_EQ, 420 */
		/* 8210FEFCh case   25:*/		if ( regs.CR[0].eq ) { return 0x821100A0;  }
		/* 8210FEFCh case   25:*/		return 0x8210FF00;
		  /* 8210FF00h */ case   26:  		/* lwz R10, <#[R11 + 8]> */
		/* 8210FF00h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8210FF00h case   26:*/		return 0x8210FF04;
		  /* 8210FF04h */ case   27:  		/* cmpwi CR6, R10, -1 */
		/* 8210FF04h case   27:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210FF04h case   27:*/		return 0x8210FF08;
		  /* 8210FF08h */ case   28:  		/* bc 4, CR6_EQ, 408 */
		/* 8210FF08h case   28:*/		if ( !regs.CR[6].eq ) { return 0x821100A0;  }
		/* 8210FF08h case   28:*/		return 0x8210FF0C;
		  /* 8210FF0Ch */ case   29:  		/* lfd FR0, <#[R11 + 32]> */
		/* 8210FF0Ch case   29:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 8210FF0Ch case   29:*/		return 0x8210FF10;
		  /* 8210FF10h */ case   30:  		/* fcmpu CR6, FR0, FR30 */
		/* 8210FF10h case   30:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 8210FF10h case   30:*/		return 0x8210FF14;
		  /* 8210FF14h */ case   31:  		/* bc 4, CR6_LT, 396 */
		/* 8210FF14h case   31:*/		if ( !regs.CR[6].lt ) { return 0x821100A0;  }
		/* 8210FF14h case   31:*/		return 0x8210FF18;
	}
	return 0x8210FF18;
} // Block from 8210FE98h-8210FF18h (32 instructions)

//////////////////////////////////////////////////////
// Block at 8210FF18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FF18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FF18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FF18);
		  /* 8210FF18h */ case    0:  		/* rlwinm R11, R21, 1, 0, 30 */
		/* 8210FF18h case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R21);
		/* 8210FF18h case    0:*/		return 0x8210FF1C;
		  /* 8210FF1Ch */ case    1:  		/* add R11, R11, R30 */
		/* 8210FF1Ch case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8210FF1Ch case    1:*/		return 0x8210FF20;
		  /* 8210FF20h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210FF20h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210FF20h case    2:*/		return 0x8210FF24;
		  /* 8210FF24h */ case    3:  		/* lwzx R11, <#[R11 + R23]> */
		/* 8210FF24h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R23 + 0x00000000) );
		/* 8210FF24h case    3:*/		return 0x8210FF28;
		  /* 8210FF28h */ case    4:  		/* cmplw CR6, R8, R11 */
		/* 8210FF28h case    4:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8210FF28h case    4:*/		return 0x8210FF2C;
		  /* 8210FF2Ch */ case    5:  		/* bc 4, CR6_EQ, 72 */
		/* 8210FF2Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x8210FF74;  }
		/* 8210FF2Ch case    5:*/		return 0x8210FF30;
		  /* 8210FF30h */ case    6:  		/* add R11, R21, R30 */
		/* 8210FF30h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R21,regs.R30);
		/* 8210FF30h case    6:*/		return 0x8210FF34;
		  /* 8210FF34h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210FF34h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210FF34h case    7:*/		return 0x8210FF38;
		  /* 8210FF38h */ case    8:  		/* lwzx R11, <#[R11 + R23]> */
		/* 8210FF38h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R23 + 0x00000000) );
		/* 8210FF38h case    8:*/		return 0x8210FF3C;
		  /* 8210FF3Ch */ case    9:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 8210FF3Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 8210FF3Ch case    9:*/		return 0x8210FF40;
		  /* 8210FF40h */ case   10:  		/* lwzx R10, <#[R10 + R31]> */
		/* 8210FF40h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 8210FF40h case   10:*/		return 0x8210FF44;
		  /* 8210FF44h */ case   11:  		/* lwz R7, <#[R10 + 4]> */
		/* 8210FF44h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 8210FF44h case   11:*/		return 0x8210FF48;
		  /* 8210FF48h */ case   12:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 8210FF48h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 8210FF48h case   12:*/		return 0x8210FF4C;
		  /* 8210FF4Ch */ case   13:  		/* lwzx R7, <#[R7 + R26]> */
		/* 8210FF4Ch case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R26 + 0x00000000) );
		/* 8210FF4Ch case   13:*/		return 0x8210FF50;
		  /* 8210FF50h */ case   14:  		/* lwz R7, <#[R7 + 4]> */
		/* 8210FF50h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000004) );
		/* 8210FF50h case   14:*/		return 0x8210FF54;
		  /* 8210FF54h */ case   15:  		/* rlwinm. R7, R7, 0, 23, 23 */
		/* 8210FF54h case   15:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R7,regs.R7);
		/* 8210FF54h case   15:*/		return 0x8210FF58;
		  /* 8210FF58h */ case   16:  		/* bc 12, CR0_EQ, 28 */
		/* 8210FF58h case   16:*/		if ( regs.CR[0].eq ) { return 0x8210FF74;  }
		/* 8210FF58h case   16:*/		return 0x8210FF5C;
		  /* 8210FF5Ch */ case   17:  		/* lwz R7, <#[R10 + 8]> */
		/* 8210FF5Ch case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000008) );
		/* 8210FF5Ch case   17:*/		return 0x8210FF60;
		  /* 8210FF60h */ case   18:  		/* cmpwi CR6, R7, -1 */
		/* 8210FF60h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R7,0xFFFFFFFF);
		/* 8210FF60h case   18:*/		return 0x8210FF64;
		  /* 8210FF64h */ case   19:  		/* bc 4, CR6_EQ, 16 */
		/* 8210FF64h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8210FF74;  }
		/* 8210FF64h case   19:*/		return 0x8210FF68;
		  /* 8210FF68h */ case   20:  		/* lfd FR0, <#[R10 + 32]> */
		/* 8210FF68h case   20:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 8210FF68h case   20:*/		return 0x8210FF6C;
		  /* 8210FF6Ch */ case   21:  		/* fcmpu CR6, FR0, FR30 */
		/* 8210FF6Ch case   21:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 8210FF6Ch case   21:*/		return 0x8210FF70;
		  /* 8210FF70h */ case   22:  		/* bc 12, CR6_EQ, 328 */
		/* 8210FF70h case   22:*/		if ( regs.CR[6].eq ) { return 0x821100B8;  }
		/* 8210FF70h case   22:*/		return 0x8210FF74;
	}
	return 0x8210FF74;
} // Block from 8210FF18h-8210FF74h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8210FF74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FF74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FF74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FF74);
		  /* 8210FF74h */ case    0:  		/* lwz R11, <#[R9 + 4]> */
		/* 8210FF74h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 8210FF74h case    0:*/		return 0x8210FF78;
		  /* 8210FF78h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210FF78h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210FF78h case    1:*/		return 0x8210FF7C;
		  /* 8210FF7Ch */ case    2:  		/* lwzx R11, <#[R11 + R26]> */
		/* 8210FF7Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 8210FF7Ch case    2:*/		return 0x8210FF80;
		  /* 8210FF80h */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 8210FF80h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8210FF80h case    3:*/		return 0x8210FF84;
		  /* 8210FF84h */ case    4:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 8210FF84h case    4:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 8210FF84h case    4:*/		return 0x8210FF88;
		  /* 8210FF88h */ case    5:  		/* bc 12, CR0_EQ, 280 */
		/* 8210FF88h case    5:*/		if ( regs.CR[0].eq ) { return 0x821100A0;  }
		/* 8210FF88h case    5:*/		return 0x8210FF8C;
		  /* 8210FF8Ch */ case    6:  		/* lwz R11, <#[R9 + 8]> */
		/* 8210FF8Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 8210FF8Ch case    6:*/		return 0x8210FF90;
		  /* 8210FF90h */ case    7:  		/* cmpwi CR6, R11, -1 */
		/* 8210FF90h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210FF90h case    7:*/		return 0x8210FF94;
		  /* 8210FF94h */ case    8:  		/* bc 4, CR6_EQ, 268 */
		/* 8210FF94h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821100A0;  }
		/* 8210FF94h case    8:*/		return 0x8210FF98;
		  /* 8210FF98h */ case    9:  		/* lwz R11, <#[R9 + 72]> */
		/* 8210FF98h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000048) );
		/* 8210FF98h case    9:*/		return 0x8210FF9C;
		  /* 8210FF9Ch */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210FF9Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210FF9Ch case   10:*/		return 0x8210FFA0;
		  /* 8210FFA0h */ case   11:  		/* lwzx R10, <#[R11 + R22]> */
		/* 8210FFA0h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R22 + 0x00000000) );
		/* 8210FFA0h case   11:*/		return 0x8210FFA4;
		  /* 8210FFA4h */ case   12:  		/* lwz R11, <#[R10]> */
		/* 8210FFA4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8210FFA4h case   12:*/		return 0x8210FFA8;
		  /* 8210FFA8h */ case   13:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 8210FFA8h case   13:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 8210FFA8h case   13:*/		return 0x8210FFAC;
		  /* 8210FFACh */ case   14:  		/* cmplw CR6, R11, R16 */
		/* 8210FFACh case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R16);
		/* 8210FFACh case   14:*/		return 0x8210FFB0;
		  /* 8210FFB0h */ case   15:  		/* bc 4, CR6_EQ, 240 */
		/* 8210FFB0h case   15:*/		if ( !regs.CR[6].eq ) { return 0x821100A0;  }
		/* 8210FFB0h case   15:*/		return 0x8210FFB4;
		  /* 8210FFB4h */ case   16:  		/* lwz R6, <#[R10 + 12]> */
		/* 8210FFB4h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x0000000C) );
		/* 8210FFB4h case   16:*/		return 0x8210FFB8;
		  /* 8210FFB8h */ case   17:  		/* li R9, 0 */
		/* 8210FFB8h case   17:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8210FFB8h case   17:*/		return 0x8210FFBC;
		  /* 8210FFBCh */ case   18:  		/* cmplwi CR6, R6, 0 */
		/* 8210FFBCh case   18:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8210FFBCh case   18:*/		return 0x8210FFC0;
		  /* 8210FFC0h */ case   19:  		/* bc 12, CR6_EQ, 40 */
		/* 8210FFC0h case   19:*/		if ( regs.CR[6].eq ) { return 0x8210FFE8;  }
		/* 8210FFC0h case   19:*/		return 0x8210FFC4;
		  /* 8210FFC4h */ case   20:  		/* lwz R7, <#[R10 + 16]> */
		/* 8210FFC4h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000010) );
		/* 8210FFC4h case   20:*/		return 0x8210FFC8;
		  /* 8210FFC8h */ case   21:  		/* li R11, 0 */
		/* 8210FFC8h case   21:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210FFC8h case   21:*/		return 0x8210FFCC;
		  /* 8210FFCCh */ case   22:  		/* lwzx R14, <#[R11 + R7]> */
		/* 8210FFCCh case   22:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 8210FFCCh case   22:*/		return 0x8210FFD0;
		  /* 8210FFD0h */ case   23:  		/* cmplw CR6, R14, R8 */
		/* 8210FFD0h case   23:*/		cpu::op::cmplw<6>(regs,regs.R14,regs.R8);
		/* 8210FFD0h case   23:*/		return 0x8210FFD4;
		  /* 8210FFD4h */ case   24:  		/* bc 12, CR6_EQ, 20 */
		/* 8210FFD4h case   24:*/		if ( regs.CR[6].eq ) { return 0x8210FFE8;  }
		/* 8210FFD4h case   24:*/		return 0x8210FFD8;
		  /* 8210FFD8h */ case   25:  		/* addi R9, R9, 1 */
		/* 8210FFD8h case   25:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8210FFD8h case   25:*/		return 0x8210FFDC;
		  /* 8210FFDCh */ case   26:  		/* addi R11, R11, 4 */
		/* 8210FFDCh case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210FFDCh case   26:*/		return 0x8210FFE0;
		  /* 8210FFE0h */ case   27:  		/* cmplw CR6, R9, R6 */
		/* 8210FFE0h case   27:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 8210FFE0h case   27:*/		return 0x8210FFE4;
		  /* 8210FFE4h */ case   28:  		/* bc 12, CR6_LT, -24 */
		/* 8210FFE4h case   28:*/		if ( regs.CR[6].lt ) { return 0x8210FFCC;  }
		/* 8210FFE4h case   28:*/		return 0x8210FFE8;
	}
	return 0x8210FFE8;
} // Block from 8210FF74h-8210FFE8h (29 instructions)

//////////////////////////////////////////////////////
// Block at 8210FFE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210FFE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210FFE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210FFE8);
		  /* 8210FFE8h */ case    0:  		/* lwz R11, <#[R10 + 12]> */
		/* 8210FFE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 8210FFE8h case    0:*/		return 0x8210FFEC;
		  /* 8210FFECh */ case    1:  		/* lwz R8, <#[R10 + 8]> */
		/* 8210FFECh case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 8210FFECh case    1:*/		return 0x8210FFF0;
		  /* 8210FFF0h */ case    2:  		/* add R7, R9, R11 */
		/* 8210FFF0h case    2:*/		cpu::op::add<0>(regs,&regs.R7,regs.R9,regs.R11);
		/* 8210FFF0h case    2:*/		return 0x8210FFF4;
		  /* 8210FFF4h */ case    3:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 8210FFF4h case    3:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 8210FFF4h case    3:*/		return 0x8210FFF8;
		  /* 8210FFF8h */ case    4:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 8210FFF8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 8210FFF8h case    4:*/		return 0x8210FFFC;
		  /* 8210FFFCh */ case    5:  		/* add R11, R11, R9 */
		/* 8210FFFCh case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8210FFFCh case    5:*/		return 0x82110000;
		  /* 82110000h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82110000h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82110000h case    6:*/		return 0x82110004;
		  /* 82110004h */ case    7:  		/* lwzx R7, <#[R7 + R8]> */
		/* 82110004h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 82110004h case    7:*/		return 0x82110008;
	}
	return 0x82110008;
} // Block from 8210FFE8h-82110008h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82110008h
// Function '?Link@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110008);
		  /* 82110008h */ case    0:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82110008h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82110008h case    0:*/		return 0x8211000C;
		  /* 8211000Ch */ case    1:  		/* lwzx R11, <#[R11 + R8]> */
		/* 8211000Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8211000Ch case    1:*/		return 0x82110010;
		  /* 82110010h */ case    2:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 82110010h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 82110010h case    2:*/		return 0x82110014;
		  /* 82110014h */ case    3:  		/* lwzx R11, <#[R7 + R31]> */
		/* 82110014h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R31 + 0x00000000) );
		/* 82110014h case    3:*/		return 0x82110018;
		  /* 82110018h */ case    4:  		/* lwzx R7, <#[R8 + R31]> */
		/* 82110018h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + regs.R31 + 0x00000000) );
		/* 82110018h case    4:*/		return 0x8211001C;
		  /* 8211001Ch */ case    5:  		/* lwz R8, <#[R11]> */
		/* 8211001Ch case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8211001Ch case    5:*/		return 0x82110020;
		  /* 82110020h */ case    6:  		/* rlwinm. R8, R8, 0, 28, 28 */
		/* 82110020h case    6:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R8,regs.R8);
		/* 82110020h case    6:*/		return 0x82110024;
		  /* 82110024h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 82110024h case    7:*/		if ( regs.CR[0].eq ) { return 0x82110030;  }
		/* 82110024h case    7:*/		return 0x82110028;
		  /* 82110028h */ case    8:  		/* li R8, 0 */
		/* 82110028h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82110028h case    8:*/		return 0x8211002C;
		  /* 8211002Ch */ case    9:  		/* b 56 */
		/* 8211002Ch case    9:*/		return 0x82110064;
		/* 8211002Ch case    9:*/		return 0x82110030;
	}
	return 0x82110030;
} // Block from 82110008h-82110030h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82110030h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110030);
		  /* 82110030h */ case    0:  		/* lwz R8, <#[R11 + 4]> */
		/* 82110030h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82110030h case    0:*/		return 0x82110034;
		  /* 82110034h */ case    1:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82110034h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82110034h case    1:*/		return 0x82110038;
		  /* 82110038h */ case    2:  		/* lwzx R8, <#[R8 + R26]> */
		/* 82110038h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R26 + 0x00000000) );
		/* 82110038h case    2:*/		return 0x8211003C;
		  /* 8211003Ch */ case    3:  		/* lwz R8, <#[R8 + 4]> */
		/* 8211003Ch case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 8211003Ch case    3:*/		return 0x82110040;
		  /* 82110040h */ case    4:  		/* rlwinm. R8, R8, 0, 23, 23 */
		/* 82110040h case    4:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R8,regs.R8);
		/* 82110040h case    4:*/		return 0x82110044;
		  /* 82110044h */ case    5:  		/* bc 12, CR0_EQ, 92 */
		/* 82110044h case    5:*/		if ( regs.CR[0].eq ) { return 0x821100A0;  }
		/* 82110044h case    5:*/		return 0x82110048;
		  /* 82110048h */ case    6:  		/* lwz R8, <#[R11 + 8]> */
		/* 82110048h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 82110048h case    6:*/		return 0x8211004C;
		  /* 8211004Ch */ case    7:  		/* cmpwi CR6, R8, -1 */
		/* 8211004Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 8211004Ch case    7:*/		return 0x82110050;
		  /* 82110050h */ case    8:  		/* bc 4, CR6_EQ, 80 */
		/* 82110050h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821100A0;  }
		/* 82110050h case    8:*/		return 0x82110054;
		  /* 82110054h */ case    9:  		/* lfd FR0, <#[R11 + 32]> */
		/* 82110054h case    9:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 82110054h case    9:*/		return 0x82110058;
		  /* 82110058h */ case   10:  		/* fcmpu CR6, FR0, FR30 */
		/* 82110058h case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 82110058h case   10:*/		return 0x8211005C;
		  /* 8211005Ch */ case   11:  		/* bc 4, CR6_GT, 68 */
		/* 8211005Ch case   11:*/		if ( !regs.CR[6].gt ) { return 0x821100A0;  }
		/* 8211005Ch case   11:*/		return 0x82110060;
		  /* 82110060h */ case   12:  		/* li R8, 1 */
		/* 82110060h case   12:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82110060h case   12:*/		return 0x82110064;
	}
	return 0x82110064;
} // Block from 82110030h-82110064h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82110064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110064);
		  /* 82110064h */ case    0:  		/* lwz R11, <#[R7]> */
		/* 82110064h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 82110064h case    0:*/		return 0x82110068;
		  /* 82110068h */ case    1:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 82110068h case    1:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 82110068h case    1:*/		return 0x8211006C;
		  /* 8211006Ch */ case    2:  		/* bc 4, CR0_EQ, 140 */
		/* 8211006Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x821100F8;  }
		/* 8211006Ch case    2:*/		return 0x82110070;
		  /* 82110070h */ case    3:  		/* lwz R11, <#[R7 + 4]> */
		/* 82110070h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000004) );
		/* 82110070h case    3:*/		return 0x82110074;
		  /* 82110074h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82110074h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82110074h case    4:*/		return 0x82110078;
		  /* 82110078h */ case    5:  		/* lwzx R11, <#[R11 + R26]> */
		/* 82110078h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 82110078h case    5:*/		return 0x8211007C;
		  /* 8211007Ch */ case    6:  		/* lwz R11, <#[R11 + 4]> */
		/* 8211007Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8211007Ch case    6:*/		return 0x82110080;
		  /* 82110080h */ case    7:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 82110080h case    7:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 82110080h case    7:*/		return 0x82110084;
		  /* 82110084h */ case    8:  		/* bc 12, CR0_EQ, 28 */
		/* 82110084h case    8:*/		if ( regs.CR[0].eq ) { return 0x821100A0;  }
		/* 82110084h case    8:*/		return 0x82110088;
		  /* 82110088h */ case    9:  		/* lwz R11, <#[R7 + 8]> */
		/* 82110088h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 82110088h case    9:*/		return 0x8211008C;
		  /* 8211008Ch */ case   10:  		/* cmpwi CR6, R11, -1 */
		/* 8211008Ch case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8211008Ch case   10:*/		return 0x82110090;
		  /* 82110090h */ case   11:  		/* bc 4, CR6_EQ, 16 */
		/* 82110090h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821100A0;  }
		/* 82110090h case   11:*/		return 0x82110094;
		  /* 82110094h */ case   12:  		/* lfd FR0, <#[R7 + 32]> */
		/* 82110094h case   12:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R7 + 0x00000020) );
		/* 82110094h case   12:*/		return 0x82110098;
	}
	return 0x82110098;
} // Block from 82110064h-82110098h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82110098h
// Function '?ReorderBinary@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110098);
		  /* 82110098h */ case    0:  		/* fcmpu CR6, FR0, FR30 */
		/* 82110098h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 82110098h case    0:*/		return 0x8211009C;
		  /* 8211009Ch */ case    1:  		/* bc 12, CR6_GT, 100 */
		/* 8211009Ch case    1:*/		if ( regs.CR[6].gt ) { return 0x82110100;  }
		/* 8211009Ch case    1:*/		return 0x821100A0;
	}
	return 0x821100A0;
} // Block from 82110098h-821100A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821100A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821100A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821100A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821100A0);
		  /* 821100A0h */ case    0:  		/* addi R27, R27, 1 */
		/* 821100A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 821100A0h case    0:*/		return 0x821100A4;
		  /* 821100A4h */ case    1:  		/* add R4, R29, R4 */
		/* 821100A4h case    1:*/		cpu::op::add<0>(regs,&regs.R4,regs.R29,regs.R4);
		/* 821100A4h case    1:*/		return 0x821100A8;
		  /* 821100A8h */ case    2:  		/* add R3, R28, R3 */
		/* 821100A8h case    2:*/		cpu::op::add<0>(regs,&regs.R3,regs.R28,regs.R3);
		/* 821100A8h case    2:*/		return 0x821100AC;
		  /* 821100ACh */ case    3:  		/* cmplw CR6, R27, R25 */
		/* 821100ACh case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R25);
		/* 821100ACh case    3:*/		return 0x821100B0;
		  /* 821100B0h */ case    4:  		/* bc 12, CR6_LT, -492 */
		/* 821100B0h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210FEC4;  }
		/* 821100B0h case    4:*/		return 0x821100B4;
		  /* 821100B4h */ case    5:  		/* b 212 */
		/* 821100B4h case    5:*/		return 0x82110188;
		/* 821100B4h case    5:*/		return 0x821100B8;
	}
	return 0x821100B8;
} // Block from 821100A0h-821100B8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821100B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821100B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821100B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821100B8);
		  /* 821100B8h */ case    0:  		/* lwz R10, <#[R5 + 8]> */
		/* 821100B8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000008) );
		/* 821100B8h case    0:*/		return 0x821100BC;
		  /* 821100BCh */ case    1:  		/* li R14, 1 */
		/* 821100BCh case    1:*/		cpu::op::li<0>(regs,&regs.R14,0x1);
		/* 821100BCh case    1:*/		return 0x821100C0;
		  /* 821100C0h */ case    2:  		/* stw R14, <#[R1 + 80]> */
		/* 821100C0h case    2:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000050) );
		/* 821100C0h case    2:*/		return 0x821100C4;
		  /* 821100C4h */ case    3:  		/* stwx R8, <#[R20 + R10]> */
		/* 821100C4h case    3:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R20 + regs.R10 + 0x00000000) );
		/* 821100C4h case    3:*/		return 0x821100C8;
		  /* 821100C8h */ case    4:  		/* lwz R10, <#[R5 + 12]> */
		/* 821100C8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x0000000C) );
		/* 821100C8h case    4:*/		return 0x821100CC;
		  /* 821100CCh */ case    5:  		/* lwz R9, <#[R5 + 8]> */
		/* 821100CCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000008) );
		/* 821100CCh case    5:*/		return 0x821100D0;
		  /* 821100D0h */ case    6:  		/* add R10, R10, R30 */
		/* 821100D0h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R30);
		/* 821100D0h case    6:*/		return 0x821100D4;
		  /* 821100D4h */ case    7:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821100D4h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821100D4h case    7:*/		return 0x821100D8;
		  /* 821100D8h */ case    8:  		/* stwx R8, <#[R10 + R9]> */
		/* 821100D8h case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821100D8h case    8:*/		return 0x821100DC;
		  /* 821100DCh */ case    9:  		/* lwz R10, <#[R5 + 12]> */
		/* 821100DCh case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x0000000C) );
		/* 821100DCh case    9:*/		return 0x821100E0;
		  /* 821100E0h */ case   10:  		/* rlwinm R10, R10, 1, 0, 30 */
		/* 821100E0h case   10:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R10);
		/* 821100E0h case   10:*/		return 0x821100E4;
		  /* 821100E4h */ case   11:  		/* add R10, R10, R30 */
		/* 821100E4h case   11:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R30);
		/* 821100E4h case   11:*/		return 0x821100E8;
		  /* 821100E8h */ case   12:  		/* lwz R9, <#[R5 + 8]> */
		/* 821100E8h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000008) );
		/* 821100E8h case   12:*/		return 0x821100EC;
		  /* 821100ECh */ case   13:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821100ECh case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821100ECh case   13:*/		return 0x821100F0;
		  /* 821100F0h */ case   14:  		/* stwx R11, <#[R10 + R9]> */
		/* 821100F0h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821100F0h case   14:*/		return 0x821100F4;
		  /* 821100F4h */ case   15:  		/* b 152 */
		/* 821100F4h case   15:*/		return 0x8211018C;
		/* 821100F4h case   15:*/		return 0x821100F8;
	}
	return 0x821100F8;
} // Block from 821100B8h-821100F8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821100F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821100F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821100F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821100F8);
		  /* 821100F8h */ case    0:  		/* li R7, 0 */
		/* 821100F8h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821100F8h case    0:*/		return 0x821100FC;
		  /* 821100FCh */ case    1:  		/* b 8 */
		/* 821100FCh case    1:*/		return 0x82110104;
		/* 821100FCh case    1:*/		return 0x82110100;
	}
	return 0x82110100;
} // Block from 821100F8h-82110100h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82110100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110100);
		  /* 82110100h */ case    0:  		/* li R7, 1 */
		/* 82110100h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82110100h case    0:*/		return 0x82110104;
	}
	return 0x82110104;
} // Block from 82110100h-82110104h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82110104h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110104( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110104) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110104);
		  /* 82110104h */ case    0:  		/* lwz R11, <#[R5 + 12]> */
		/* 82110104h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x0000000C) );
		/* 82110104h case    0:*/		return 0x82110108;
		  /* 82110108h */ case    1:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82110108h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82110108h case    1:*/		return 0x8211010C;
		  /* 8211010Ch */ case    2:  		/* lwz R6, <#[R10 + 8]> */
		/* 8211010Ch case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000008) );
		/* 8211010Ch case    2:*/		return 0x82110110;
		  /* 82110110h */ case    3:  		/* cmplwi CR6, R8, 0 */
		/* 82110110h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82110110h case    3:*/		return 0x82110114;
		  /* 82110114h */ case    4:  		/* rlwinm R10, R11, 1, 0, 30 */
		/* 82110114h case    4:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R11);
		/* 82110114h case    4:*/		return 0x82110118;
		  /* 82110118h */ case    5:  		/* lwz R4, <#[R5 + 8]> */
		/* 82110118h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x00000008) );
		/* 82110118h case    5:*/		return 0x8211011C;
		  /* 8211011Ch */ case    6:  		/* add R11, R30, R11 */
		/* 8211011Ch case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 8211011Ch case    6:*/		return 0x82110120;
		  /* 82110120h */ case    7:  		/* add R10, R10, R30 */
		/* 82110120h case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R30);
		/* 82110120h case    7:*/		return 0x82110124;
		  /* 82110124h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82110124h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82110124h case    8:*/		return 0x82110128;
		  /* 82110128h */ case    9:  		/* rlwinm R8, R10, 2, 0, 29 */
		/* 82110128h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R10);
		/* 82110128h case    9:*/		return 0x8211012C;
		  /* 8211012Ch */ case   10:  		/* lwzx R9, <#[R9 + R6]> */
		/* 8211012Ch case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 8211012Ch case   10:*/		return 0x82110130;
		  /* 82110130h */ case   11:  		/* lwzx R10, <#[R11 + R4]> */
		/* 82110130h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R4 + 0x00000000) );
		/* 82110130h case   11:*/		return 0x82110134;
		  /* 82110134h */ case   12:  		/* lwzx R8, <#[R8 + R4]> */
		/* 82110134h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R4 + 0x00000000) );
		/* 82110134h case   12:*/		return 0x82110138;
		  /* 82110138h */ case   13:  		/* stwx R9, <#[R20 + R4]> */
		/* 82110138h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R20 + regs.R4 + 0x00000000) );
		/* 82110138h case   13:*/		return 0x8211013C;
		  /* 8211013Ch */ case   14:  		/* mr R9, R8 */
		/* 8211013Ch case   14:*/		regs.R9 = regs.R8;
		/* 8211013Ch case   14:*/		return 0x82110140;
		  /* 82110140h */ case   15:  		/* bc 4, CR6_EQ, 8 */
		/* 82110140h case   15:*/		if ( !regs.CR[6].eq ) { return 0x82110148;  }
		/* 82110140h case   15:*/		return 0x82110144;
		  /* 82110144h */ case   16:  		/* mr R9, R10 */
		/* 82110144h case   16:*/		regs.R9 = regs.R10;
		/* 82110144h case   16:*/		return 0x82110148;
	}
	return 0x82110148;
} // Block from 82110104h-82110148h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82110148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110148);
		  /* 82110148h */ case    0:  		/* lwz R11, <#[R5 + 12]> */
		/* 82110148h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x0000000C) );
		/* 82110148h case    0:*/		return 0x8211014C;
		  /* 8211014Ch */ case    1:  		/* cmplwi CR6, R7, 0 */
		/* 8211014Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8211014Ch case    1:*/		return 0x82110150;
		  /* 82110150h */ case    2:  		/* lwz R7, <#[R5 + 8]> */
		/* 82110150h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R5 + 0x00000008) );
		/* 82110150h case    2:*/		return 0x82110154;
		  /* 82110154h */ case    3:  		/* add R11, R11, R30 */
		/* 82110154h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82110154h case    3:*/		return 0x82110158;
		  /* 82110158h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82110158h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82110158h case    4:*/		return 0x8211015C;
		  /* 8211015Ch */ case    5:  		/* stwx R9, <#[R11 + R7]> */
		/* 8211015Ch case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 8211015Ch case    5:*/		return 0x82110160;
		  /* 82110160h */ case    6:  		/* bc 12, CR6_EQ, 8 */
		/* 82110160h case    6:*/		if ( regs.CR[6].eq ) { return 0x82110168;  }
		/* 82110160h case    6:*/		return 0x82110164;
		  /* 82110164h */ case    7:  		/* mr R10, R8 */
		/* 82110164h case    7:*/		regs.R10 = regs.R8;
		/* 82110164h case    7:*/		return 0x82110168;
	}
	return 0x82110168;
} // Block from 82110148h-82110168h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82110168h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110168);
		  /* 82110168h */ case    0:  		/* lwz R11, <#[R5 + 12]> */
		/* 82110168h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x0000000C) );
		/* 82110168h case    0:*/		return 0x8211016C;
		  /* 8211016Ch */ case    1:  		/* li R9, 1 */
		/* 8211016Ch case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8211016Ch case    1:*/		return 0x82110170;
		  /* 82110170h */ case    2:  		/* lwz R8, <#[R5 + 8]> */
		/* 82110170h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000008) );
		/* 82110170h case    2:*/		return 0x82110174;
		  /* 82110174h */ case    3:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 82110174h case    3:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 82110174h case    3:*/		return 0x82110178;
		  /* 82110178h */ case    4:  		/* stw R9, <#[R1 + 80]> */
		/* 82110178h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 82110178h case    4:*/		return 0x8211017C;
		  /* 8211017Ch */ case    5:  		/* add R11, R11, R30 */
		/* 8211017Ch case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8211017Ch case    5:*/		return 0x82110180;
		  /* 82110180h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82110180h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82110180h case    6:*/		return 0x82110184;
		  /* 82110184h */ case    7:  		/* stwx R10, <#[R11 + R8]> */
		/* 82110184h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82110184h case    7:*/		return 0x82110188;
	}
	return 0x82110188;
} // Block from 82110168h-82110188h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82110188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110188);
		  /* 82110188h */ case    0:  		/* lwz R14, <#[R1 + 80]> */
		/* 82110188h case    0:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R1 + 0x00000050) );
		/* 82110188h case    0:*/		return 0x8211018C;
	}
	return 0x8211018C;
} // Block from 82110188h-8211018Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8211018Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211018C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211018C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211018C);
		  /* 8211018Ch */ case    0:  		/* lwz R21, <#[R5 + 12]> */
		/* 8211018Ch case    0:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R5 + 0x0000000C) );
		/* 8211018Ch case    0:*/		return 0x82110190;
		  /* 82110190h */ case    1:  		/* addi R30, R30, 1 */
		/* 82110190h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82110190h case    1:*/		return 0x82110194;
		  /* 82110194h */ case    2:  		/* addi R20, R20, 4 */
		/* 82110194h case    2:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0x4);
		/* 82110194h case    2:*/		return 0x82110198;
		  /* 82110198h */ case    3:  		/* cmplw CR6, R30, R21 */
		/* 82110198h case    3:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R21);
		/* 82110198h case    3:*/		return 0x8211019C;
		  /* 8211019Ch */ case    4:  		/* bc 12, CR6_LT, -944 */
		/* 8211019Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x8210FDEC;  }
		/* 8211019Ch case    4:*/		return 0x821101A0;
	}
	return 0x821101A0;
} // Block from 8211018Ch-821101A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821101A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821101A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821101A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821101A0);
		  /* 821101A0h */ case    0:  		/* lwz R11, <#[R17 + 12]> */
		/* 821101A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000000C) );
		/* 821101A0h case    0:*/		return 0x821101A4;
		  /* 821101A4h */ case    1:  		/* addi R18, R18, 1 */
		/* 821101A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R18,0x1);
		/* 821101A4h case    1:*/		return 0x821101A8;
		  /* 821101A8h */ case    2:  		/* addi R19, R19, 4 */
		/* 821101A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x4);
		/* 821101A8h case    2:*/		return 0x821101AC;
		  /* 821101ACh */ case    3:  		/* cmplw CR6, R18, R11 */
		/* 821101ACh case    3:*/		cpu::op::cmplw<6>(regs,regs.R18,regs.R11);
		/* 821101ACh case    3:*/		return 0x821101B0;
		  /* 821101B0h */ case    4:  		/* bc 12, CR6_LT, -1052 */
		/* 821101B0h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210FD94;  }
		/* 821101B0h case    4:*/		return 0x821101B4;
	}
	return 0x821101B4;
} // Block from 821101A0h-821101B4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821101B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821101B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821101B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821101B4);
		  /* 821101B4h */ case    0:  		/* cmpwi CR6, R14, 0 */
		/* 821101B4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 821101B4h case    0:*/		return 0x821101B8;
		  /* 821101B8h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 821101B8h case    1:*/		if ( regs.CR[6].eq ) { return 0x821101D0;  }
		/* 821101B8h case    1:*/		return 0x821101BC;
		  /* 821101BCh */ case    2:  		/* li R14, 0 */
		/* 821101BCh case    2:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 821101BCh case    2:*/		return 0x821101C0;
		  /* 821101C0h */ case    3:  		/* mr R3, R17 */
		/* 821101C0h case    3:*/		regs.R3 = regs.R17;
		/* 821101C0h case    3:*/		return 0x821101C4;
		  /* 821101C4h */ case    4:  		/* li R15, 1 */
		/* 821101C4h case    4:*/		cpu::op::li<0>(regs,&regs.R15,0x1);
		/* 821101C4h case    4:*/		return 0x821101C8;
		  /* 821101C8h */ case    5:  		/* stw R14, <#[R1 + 80]> */
		/* 821101C8h case    5:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000050) );
		/* 821101C8h case    5:*/		return 0x821101CC;
		  /* 821101CCh */ case    6:  		/* bl -42548 */
		/* 821101CCh case    6:*/		regs.LR = 0x821101D0; return 0x82105B98;
		/* 821101CCh case    6:*/		return 0x821101D0;
	}
	return 0x821101D0;
} // Block from 821101B4h-821101D0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821101D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821101D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821101D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821101D0);
		  /* 821101D0h */ case    0:  		/* lwz R11, <#[R17 + 12]> */
		/* 821101D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000000C) );
		/* 821101D0h case    0:*/		return 0x821101D4;
		  /* 821101D4h */ case    1:  		/* li R24, 0 */
		/* 821101D4h case    1:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 821101D4h case    1:*/		return 0x821101D8;
		  /* 821101D8h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821101D8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821101D8h case    2:*/		return 0x821101DC;
		  /* 821101DCh */ case    3:  		/* bc 4, CR6_GT, 1200 */
		/* 821101DCh case    3:*/		if ( !regs.CR[6].gt ) { return 0x8211068C;  }
		/* 821101DCh case    3:*/		return 0x821101E0;
		  /* 821101E0h */ case    4:  		/* li R25, 0 */
		/* 821101E0h case    4:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 821101E0h case    4:*/		return 0x821101E4;
		  /* 821101E4h */ case    5:  		/* li R23, -1 */
		/* 821101E4h case    5:*/		cpu::op::li<0>(regs,&regs.R23,0xFFFFFFFF);
		/* 821101E4h case    5:*/		return 0x821101E8;
		  /* 821101E8h */ case    6:  		/* lwz R11, <#[R17 + 24]> */
		/* 821101E8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000018) );
		/* 821101E8h case    6:*/		return 0x821101EC;
		  /* 821101ECh */ case    7:  		/* lwzx R28, <#[R11 + R25]> */
		/* 821101ECh case    7:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 821101ECh case    7:*/		return 0x821101F0;
		  /* 821101F0h */ case    8:  		/* lwz R11, <#[R28]> */
		/* 821101F0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821101F0h case    8:*/		return 0x821101F4;
		  /* 821101F4h */ case    9:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 821101F4h case    9:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 821101F4h case    9:*/		return 0x821101F8;
		  /* 821101F8h */ case   10:  		/* bc 12, CR0_EQ, 1152 */
		/* 821101F8h case   10:*/		if ( regs.CR[0].eq ) { return 0x82110678;  }
		/* 821101F8h case   10:*/		return 0x821101FC;
		  /* 821101FCh */ case   11:  		/* lwz R10, <#[R28 + 12]> */
		/* 821101FCh case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000000C) );
		/* 821101FCh case   11:*/		return 0x82110200;
		  /* 82110200h */ case   12:  		/* cmplwi CR6, R10, 0 */
		/* 82110200h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82110200h case   12:*/		return 0x82110204;
		  /* 82110204h */ case   13:  		/* bc 12, CR6_EQ, 36 */
		/* 82110204h case   13:*/		if ( regs.CR[6].eq ) { return 0x82110228;  }
		/* 82110204h case   13:*/		return 0x82110208;
		  /* 82110208h */ case   14:  		/* lwz R10, <#[R28 + 16]> */
		/* 82110208h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000010) );
		/* 82110208h case   14:*/		return 0x8211020C;
		  /* 8211020Ch */ case   15:  		/* lwz R9, <#[R17 + 20]> */
		/* 8211020Ch case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000014) );
		/* 8211020Ch case   15:*/		return 0x82110210;
		  /* 82110210h */ case   16:  		/* lwz R10, <#[R10]> */
		/* 82110210h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 82110210h case   16:*/		return 0x82110214;
		  /* 82110214h */ case   17:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82110214h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82110214h case   17:*/		return 0x82110218;
		  /* 82110218h */ case   18:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82110218h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82110218h case   18:*/		return 0x8211021C;
		  /* 8211021Ch */ case   19:  		/* lwz R10, <#[R10]> */
		/* 8211021Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 8211021Ch case   19:*/		return 0x82110220;
		  /* 82110220h */ case   20:  		/* rlwinm. R10, R10, 0, 25, 25 */
		/* 82110220h case   20:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R10);
		/* 82110220h case   20:*/		return 0x82110224;
		  /* 82110224h */ case   21:  		/* bc 4, CR0_EQ, 1108 */
		/* 82110224h case   21:*/		if ( !regs.CR[0].eq ) { return 0x82110678;  }
		/* 82110224h case   21:*/		return 0x82110228;
	}
	return 0x82110228;
} // Block from 821101D0h-82110228h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82110228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110228);
		  /* 82110228h */ case    0:  		/* lis R10, 4176 */
		/* 82110228h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x1050);
		/* 82110228h case    0:*/		return 0x8211022C;
		  /* 8211022Ch */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 8211022Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8211022Ch case    1:*/		return 0x82110230;
		  /* 82110230h */ case    2:  		/* bc 4, CR6_EQ, 1096 */
		/* 82110230h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82110678;  }
		/* 82110230h case    2:*/		return 0x82110234;
		  /* 82110234h */ case    3:  		/* lwz R11, <#[R28 + 4]> */
		/* 82110234h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82110234h case    3:*/		return 0x82110238;
		  /* 82110238h */ case    4:  		/* mr R27, R23 */
		/* 82110238h case    4:*/		regs.R27 = regs.R23;
		/* 82110238h case    4:*/		return 0x8211023C;
		  /* 8211023Ch */ case    5:  		/* mr R26, R23 */
		/* 8211023Ch case    5:*/		regs.R26 = regs.R23;
		/* 8211023Ch case    5:*/		return 0x82110240;
		  /* 82110240h */ case    6:  		/* li R29, 0 */
		/* 82110240h case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82110240h case    6:*/		return 0x82110244;
		  /* 82110244h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82110244h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82110244h case    7:*/		return 0x82110248;
		  /* 82110248h */ case    8:  		/* bc 4, CR6_GT, 1072 */
		/* 82110248h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82110678;  }
		/* 82110248h case    8:*/		return 0x8211024C;
		  /* 8211024Ch */ case    9:  		/* li R30, 0 */
		/* 8211024Ch case    9:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8211024Ch case    9:*/		return 0x82110250;
		  /* 82110250h */ case   10:  		/* lwz R11, <#[R28 + 8]> */
		/* 82110250h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 82110250h case   10:*/		return 0x82110254;
		  /* 82110254h */ case   11:  		/* lwz R10, <#[R17 + 20]> */
		/* 82110254h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000014) );
		/* 82110254h case   11:*/		return 0x82110258;
		  /* 82110258h */ case   12:  		/* lwz R9, <#[R17 + 16]> */
		/* 82110258h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000010) );
		/* 82110258h case   12:*/		return 0x8211025C;
		  /* 8211025Ch */ case   13:  		/* lwzx R8, <#[R30 + R11]> */
		/* 8211025Ch case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8211025Ch case   13:*/		return 0x82110260;
		  /* 82110260h */ case   14:  		/* rlwinm R11, R8, 2, 0, 29 */
		/* 82110260h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R8);
		/* 82110260h case   14:*/		return 0x82110264;
		  /* 82110264h */ case   15:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82110264h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82110264h case   15:*/		return 0x82110268;
		  /* 82110268h */ case   16:  		/* lwz R10, <#[R11 + 4]> */
		/* 82110268h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82110268h case   16:*/		return 0x8211026C;
		  /* 8211026Ch */ case   17:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8211026Ch case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8211026Ch case   17:*/		return 0x82110270;
		  /* 82110270h */ case   18:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82110270h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82110270h case   18:*/		return 0x82110274;
		  /* 82110274h */ case   19:  		/* lwz R10, <#[R10 + 4]> */
		/* 82110274h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82110274h case   19:*/		return 0x82110278;
		  /* 82110278h */ case   20:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 82110278h case   20:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 82110278h case   20:*/		return 0x8211027C;
		  /* 8211027Ch */ case   21:  		/* bc 12, CR0_EQ, 500 */
		/* 8211027Ch case   21:*/		if ( regs.CR[0].eq ) { return 0x82110470;  }
		/* 8211027Ch case   21:*/		return 0x82110280;
		  /* 82110280h */ case   22:  		/* lwz R10, <#[R11 + 8]> */
		/* 82110280h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82110280h case   22:*/		return 0x82110284;
		  /* 82110284h */ case   23:  		/* cmpwi CR6, R10, -1 */
		/* 82110284h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82110284h case   23:*/		return 0x82110288;
		  /* 82110288h */ case   24:  		/* bc 4, CR6_EQ, 488 */
		/* 82110288h case   24:*/		if ( !regs.CR[6].eq ) { return 0x82110470;  }
		/* 82110288h case   24:*/		return 0x8211028C;
		  /* 8211028Ch */ case   25:  		/* lwz R11, <#[R11 + 72]> */
		/* 8211028Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 8211028Ch case   25:*/		return 0x82110290;
		  /* 82110290h */ case   26:  		/* lis R10, 8272 */
		/* 82110290h case   26:*/		cpu::op::lis<0>(regs,&regs.R10,0x2050);
		/* 82110290h case   26:*/		return 0x82110294;
		  /* 82110294h */ case   27:  		/* lwz R9, <#[R17 + 24]> */
		/* 82110294h case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000018) );
		/* 82110294h case   27:*/		return 0x82110298;
		  /* 82110298h */ case   28:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82110298h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82110298h case   28:*/		return 0x8211029C;
		  /* 8211029Ch */ case   29:  		/* lwzx R7, <#[R11 + R9]> */
		/* 8211029Ch case   29:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8211029Ch case   29:*/		return 0x821102A0;
		  /* 821102A0h */ case   30:  		/* lwz R11, <#[R7]> */
		/* 821102A0h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 821102A0h case   30:*/		return 0x821102A4;
		  /* 821102A4h */ case   31:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 821102A4h case   31:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 821102A4h case   31:*/		return 0x821102A8;
		  /* 821102A8h */ case   32:  		/* cmplw CR6, R11, R10 */
		/* 821102A8h case   32:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821102A8h case   32:*/		return 0x821102AC;
		  /* 821102ACh */ case   33:  		/* bc 4, CR6_EQ, 452 */
		/* 821102ACh case   33:*/		if ( !regs.CR[6].eq ) { return 0x82110470;  }
		/* 821102ACh case   33:*/		return 0x821102B0;
		  /* 821102B0h */ case   34:  		/* lwz R9, <#[R7 + 12]> */
		/* 821102B0h case   34:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x0000000C) );
		/* 821102B0h case   34:*/		return 0x821102B4;
		  /* 821102B4h */ case   35:  		/* li R4, 0 */
		/* 821102B4h case   35:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821102B4h case   35:*/		return 0x821102B8;
		  /* 821102B8h */ case   36:  		/* cmplwi CR6, R9, 0 */
		/* 821102B8h case   36:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821102B8h case   36:*/		return 0x821102BC;
		  /* 821102BCh */ case   37:  		/* bc 12, CR6_EQ, 40 */
		/* 821102BCh case   37:*/		if ( regs.CR[6].eq ) { return 0x821102E4;  }
		/* 821102BCh case   37:*/		return 0x821102C0;
		  /* 821102C0h */ case   38:  		/* lwz R10, <#[R7 + 16]> */
		/* 821102C0h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000010) );
		/* 821102C0h case   38:*/		return 0x821102C4;
		  /* 821102C4h */ case   39:  		/* li R11, 0 */
		/* 821102C4h case   39:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821102C4h case   39:*/		return 0x821102C8;
		  /* 821102C8h */ case   40:  		/* lwzx R6, <#[R11 + R10]> */
		/* 821102C8h case   40:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821102C8h case   40:*/		return 0x821102CC;
		  /* 821102CCh */ case   41:  		/* cmplw CR6, R6, R8 */
		/* 821102CCh case   41:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R8);
		/* 821102CCh case   41:*/		return 0x821102D0;
		  /* 821102D0h */ case   42:  		/* bc 12, CR6_EQ, 20 */
		/* 821102D0h case   42:*/		if ( regs.CR[6].eq ) { return 0x821102E4;  }
		/* 821102D0h case   42:*/		return 0x821102D4;
		  /* 821102D4h */ case   43:  		/* addi R4, R4, 1 */
		/* 821102D4h case   43:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 821102D4h case   43:*/		return 0x821102D8;
		  /* 821102D8h */ case   44:  		/* addi R11, R11, 4 */
		/* 821102D8h case   44:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821102D8h case   44:*/		return 0x821102DC;
		  /* 821102DCh */ case   45:  		/* cmplw CR6, R4, R9 */
		/* 821102DCh case   45:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R9);
		/* 821102DCh case   45:*/		return 0x821102E0;
		  /* 821102E0h */ case   46:  		/* bc 12, CR6_LT, -24 */
		/* 821102E0h case   46:*/		if ( regs.CR[6].lt ) { return 0x821102C8;  }
		/* 821102E0h case   46:*/		return 0x821102E4;
	}
	return 0x821102E4;
} // Block from 82110228h-821102E4h (47 instructions)

//////////////////////////////////////////////////////
// Block at 821102E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821102E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821102E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821102E4);
		  /* 821102E4h */ case    0:  		/* li R3, 0 */
		/* 821102E4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821102E4h case    0:*/		return 0x821102E8;
		  /* 821102E8h */ case    1:  		/* li R31, 1 */
		/* 821102E8h case    1:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 821102E8h case    1:*/		return 0x821102EC;
		  /* 821102ECh */ case    2:  		/* lwz R11, <#[R7 + 12]> */
		/* 821102ECh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x0000000C) );
		/* 821102ECh case    2:*/		return 0x821102F0;
		  /* 821102F0h */ case    3:  		/* lwz R9, <#[R7 + 8]> */
		/* 821102F0h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000008) );
		/* 821102F0h case    3:*/		return 0x821102F4;
		  /* 821102F4h */ case    4:  		/* mullw R11, R3, R11 */
		/* 821102F4h case    4:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 821102F4h case    4:*/		return 0x821102F8;
		  /* 821102F8h */ case    5:  		/* lwz R10, <#[R17 + 20]> */
		/* 821102F8h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000014) );
		/* 821102F8h case    5:*/		return 0x821102FC;
		  /* 821102FCh */ case    6:  		/* lwz R8, <#[R17 + 16]> */
		/* 821102FCh case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R17 + 0x00000010) );
		/* 821102FCh case    6:*/		return 0x82110300;
		  /* 82110300h */ case    7:  		/* add R11, R11, R4 */
		/* 82110300h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 82110300h case    7:*/		return 0x82110304;
		  /* 82110304h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82110304h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82110304h case    8:*/		return 0x82110308;
		  /* 82110308h */ case    9:  		/* lwzx R5, <#[R11 + R9]> */
		/* 82110308h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82110308h case    9:*/		return 0x8211030C;
		  /* 8211030Ch */ case   10:  		/* rlwinm R11, R5, 2, 0, 29 */
		/* 8211030Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R5);
		/* 8211030Ch case   10:*/		return 0x82110310;
		  /* 82110310h */ case   11:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82110310h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82110310h case   11:*/		return 0x82110314;
		  /* 82110314h */ case   12:  		/* lwz R9, <#[R11 + 4]> */
		/* 82110314h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82110314h case   12:*/		return 0x82110318;
		  /* 82110318h */ case   13:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82110318h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82110318h case   13:*/		return 0x8211031C;
		  /* 8211031Ch */ case   14:  		/* lwzx R9, <#[R9 + R8]> */
		/* 8211031Ch case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 8211031Ch case   14:*/		return 0x82110320;
		  /* 82110320h */ case   15:  		/* lwz R9, <#[R9 + 4]> */
		/* 82110320h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 82110320h case   15:*/		return 0x82110324;
		  /* 82110324h */ case   16:  		/* rlwinm. R9, R9, 0, 30, 30 */
		/* 82110324h case   16:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R9);
		/* 82110324h case   16:*/		return 0x82110328;
		  /* 82110328h */ case   17:  		/* bc 12, CR0_EQ, 312 */
		/* 82110328h case   17:*/		if ( regs.CR[0].eq ) { return 0x82110460;  }
		/* 82110328h case   17:*/		return 0x8211032C;
		  /* 8211032Ch */ case   18:  		/* lwz R9, <#[R11 + 8]> */
		/* 8211032Ch case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8211032Ch case   18:*/		return 0x82110330;
		  /* 82110330h */ case   19:  		/* cmpwi CR6, R9, -1 */
		/* 82110330h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 82110330h case   19:*/		return 0x82110334;
		  /* 82110334h */ case   20:  		/* bc 4, CR6_EQ, 300 */
		/* 82110334h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82110460;  }
		/* 82110334h case   20:*/		return 0x82110338;
		  /* 82110338h */ case   21:  		/* lwz R9, <#[R11 + 72]> */
		/* 82110338h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000048) );
		/* 82110338h case   21:*/		return 0x8211033C;
		  /* 8211033Ch */ case   22:  		/* lis R8, 4192 */
		/* 8211033Ch case   22:*/		cpu::op::lis<0>(regs,&regs.R8,0x1060);
		/* 8211033Ch case   22:*/		return 0x82110340;
		  /* 82110340h */ case   23:  		/* lwz R6, <#[R17 + 24]> */
		/* 82110340h case   23:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R17 + 0x00000018) );
		/* 82110340h case   23:*/		return 0x82110344;
		  /* 82110344h */ case   24:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82110344h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82110344h case   24:*/		return 0x82110348;
		  /* 82110348h */ case   25:  		/* lwzx R6, <#[R9 + R6]> */
		/* 82110348h case   25:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 82110348h case   25:*/		return 0x8211034C;
		  /* 8211034Ch */ case   26:  		/* lwz R9, <#[R6]> */
		/* 8211034Ch case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000000) );
		/* 8211034Ch case   26:*/		return 0x82110350;
		  /* 82110350h */ case   27:  		/* rlwinm R9, R9, 0, 0, 11 */
		/* 82110350h case   27:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R9,regs.R9);
		/* 82110350h case   27:*/		return 0x82110354;
		  /* 82110354h */ case   28:  		/* cmplw CR6, R9, R8 */
		/* 82110354h case   28:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 82110354h case   28:*/		return 0x82110358;
		  /* 82110358h */ case   29:  		/* bc 4, CR6_EQ, 264 */
		/* 82110358h case   29:*/		if ( !regs.CR[6].eq ) { return 0x82110460;  }
		/* 82110358h case   29:*/		return 0x8211035C;
		  /* 8211035Ch */ case   30:  		/* lwz R9, <#[R11 + 92]> */
		/* 8211035Ch case   30:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000005C) );
		/* 8211035Ch case   30:*/		return 0x82110360;
		  /* 82110360h */ case   31:  		/* cmplwi CR6, R9, 1 */
		/* 82110360h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 82110360h case   31:*/		return 0x82110364;
		  /* 82110364h */ case   32:  		/* bc 4, CR6_EQ, 108 */
		/* 82110364h case   32:*/		if ( !regs.CR[6].eq ) { return 0x821103D0;  }
		/* 82110364h case   32:*/		return 0x82110368;
		  /* 82110368h */ case   33:  		/* lwz R8, <#[R28 + 16]> */
		/* 82110368h case   33:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R28 + 0x00000010) );
		/* 82110368h case   33:*/		return 0x8211036C;
		  /* 8211036Ch */ case   34:  		/* lwz R9, <#[R11]> */
		/* 8211036Ch case   34:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8211036Ch case   34:*/		return 0x82110370;
		  /* 82110370h */ case   35:  		/* lwzx R8, <#[R8 + R30]> */
		/* 82110370h case   35:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R30 + 0x00000000) );
		/* 82110370h case   35:*/		return 0x82110374;
		  /* 82110374h */ case   36:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82110374h case   36:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82110374h case   36:*/		return 0x82110378;
		  /* 82110378h */ case   37:  		/* lwzx R10, <#[R8 + R10]> */
		/* 82110378h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 82110378h case   37:*/		return 0x8211037C;
		  /* 8211037Ch */ case   38:  		/* lwz R10, <#[R10]> */
		/* 8211037Ch case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 8211037Ch case   38:*/		return 0x82110380;
		  /* 82110380h */ case   39:  		/* or R10, R10, R9 */
		/* 82110380h case   39:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82110380h case   39:*/		return 0x82110384;
		  /* 82110384h */ case   40:  		/* rlwinm R10, R10, 0, 4, 6 */
		/* 82110384h case   40:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R10,regs.R10);
		/* 82110384h case   40:*/		return 0x82110388;
		  /* 82110388h */ case   41:  		/* rlwinm. R8, R10, 0, 4, 4 */
		/* 82110388h case   41:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R8,regs.R10);
		/* 82110388h case   41:*/		return 0x8211038C;
		  /* 8211038Ch */ case   42:  		/* bc 12, CR0_EQ, 12 */
		/* 8211038Ch case   42:*/		if ( regs.CR[0].eq ) { return 0x82110398;  }
		/* 8211038Ch case   42:*/		return 0x82110390;
		  /* 82110390h */ case   43:  		/* lis R10, 2048 */
		/* 82110390h case   43:*/		cpu::op::lis<0>(regs,&regs.R10,0x800);
		/* 82110390h case   43:*/		return 0x82110394;
		  /* 82110394h */ case   44:  		/* b 32 */
		/* 82110394h case   44:*/		return 0x821103B4;
		/* 82110394h case   44:*/		return 0x82110398;
	}
	return 0x82110398;
} // Block from 821102E4h-82110398h (45 instructions)

//////////////////////////////////////////////////////
// Block at 82110398h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110398);
		  /* 82110398h */ case    0:  		/* rlwinm. R8, R10, 0, 5, 5 */
		/* 82110398h case    0:*/		cpu::op::rlwinm<1,0,5,5>(regs,&regs.R8,regs.R10);
		/* 82110398h case    0:*/		return 0x8211039C;
		  /* 8211039Ch */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8211039Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821103A8;  }
		/* 8211039Ch case    1:*/		return 0x821103A0;
		  /* 821103A0h */ case    2:  		/* lis R10, 1024 */
		/* 821103A0h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0x400);
		/* 821103A0h case    2:*/		return 0x821103A4;
		  /* 821103A4h */ case    3:  		/* b 16 */
		/* 821103A4h case    3:*/		return 0x821103B4;
		/* 821103A4h case    3:*/		return 0x821103A8;
	}
	return 0x821103A8;
} // Block from 82110398h-821103A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821103A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821103A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821103A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821103A8);
		  /* 821103A8h */ case    0:  		/* rlwinm. R8, R10, 0, 6, 6 */
		/* 821103A8h case    0:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R8,regs.R10);
		/* 821103A8h case    0:*/		return 0x821103AC;
		  /* 821103ACh */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 821103ACh case    1:*/		if ( regs.CR[0].eq ) { return 0x821103B4;  }
		/* 821103ACh case    1:*/		return 0x821103B0;
		  /* 821103B0h */ case    2:  		/* lis R10, 512 */
		/* 821103B0h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0x200);
		/* 821103B0h case    2:*/		return 0x821103B4;
	}
	return 0x821103B4;
} // Block from 821103A8h-821103B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821103B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821103B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821103B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821103B4);
		  /* 821103B4h */ case    0:  		/* rlwinm R8, R9, 0, 4, 6 */
		/* 821103B4h case    0:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R8,regs.R9);
		/* 821103B4h case    0:*/		return 0x821103B8;
		  /* 821103B8h */ case    1:  		/* cmplw CR6, R8, R10 */
		/* 821103B8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 821103B8h case    1:*/		return 0x821103BC;
		  /* 821103BCh */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 821103BCh case    2:*/		if ( regs.CR[6].eq ) { return 0x821103D0;  }
		/* 821103BCh case    2:*/		return 0x821103C0;
		  /* 821103C0h */ case    3:  		/* rlwinm R9, R9, 0, 7, 3 */
		/* 821103C0h case    3:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R9,regs.R9);
		/* 821103C0h case    3:*/		return 0x821103C4;
		  /* 821103C4h */ case    4:  		/* li R14, 1 */
		/* 821103C4h case    4:*/		cpu::op::li<0>(regs,&regs.R14,0x1);
		/* 821103C4h case    4:*/		return 0x821103C8;
		  /* 821103C8h */ case    5:  		/* or R10, R9, R10 */
		/* 821103C8h case    5:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821103C8h case    5:*/		return 0x821103CC;
		  /* 821103CCh */ case    6:  		/* stw R10, <#[R11]> */
		/* 821103CCh case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821103CCh case    6:*/		return 0x821103D0;
	}
	return 0x821103D0;
} // Block from 821103B4h-821103D0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821103D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821103D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821103D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821103D0);
		  /* 821103D0h */ case    0:  		/* lwz R11, <#[R17 + 108]> */
		/* 821103D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000006C) );
		/* 821103D0h case    0:*/		return 0x821103D4;
		  /* 821103D4h */ case    1:  		/* rlwinm. R11, R11, 0, 7, 7 */
		/* 821103D4h case    1:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R11,regs.R11);
		/* 821103D4h case    1:*/		return 0x821103D8;
		  /* 821103D8h */ case    2:  		/* bc 12, CR0_EQ, 136 */
		/* 821103D8h case    2:*/		if ( regs.CR[0].eq ) { return 0x82110460;  }
		/* 821103D8h case    2:*/		return 0x821103DC;
		  /* 821103DCh */ case    3:  		/* lwz R11, <#[R28 + 12]> */
		/* 821103DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000000C) );
		/* 821103DCh case    3:*/		return 0x821103E0;
		  /* 821103E0h */ case    4:  		/* cmplwi CR6, R11, 1 */
		/* 821103E0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821103E0h case    4:*/		return 0x821103E4;
		  /* 821103E4h */ case    5:  		/* bc 4, CR6_EQ, 124 */
		/* 821103E4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82110460;  }
		/* 821103E4h case    5:*/		return 0x821103E8;
		  /* 821103E8h */ case    6:  		/* lwz R11, <#[R28 + 16]> */
		/* 821103E8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 821103E8h case    6:*/		return 0x821103EC;
		  /* 821103ECh */ case    7:  		/* lwz R10, <#[R17 + 20]> */
		/* 821103ECh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000014) );
		/* 821103ECh case    7:*/		return 0x821103F0;
		  /* 821103F0h */ case    8:  		/* lwzx R11, <#[R11 + R30]> */
		/* 821103F0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 821103F0h case    8:*/		return 0x821103F4;
		  /* 821103F4h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821103F4h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821103F4h case    9:*/		return 0x821103F8;
		  /* 821103F8h */ case   10:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821103F8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821103F8h case   10:*/		return 0x821103FC;
		  /* 821103FCh */ case   11:  		/* lwz R11, <#[R11]> */
		/* 821103FCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821103FCh case   11:*/		return 0x82110400;
		  /* 82110400h */ case   12:  		/* rlwinm. R11, R11, 0, 6, 6 */
		/* 82110400h case   12:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R11,regs.R11);
		/* 82110400h case   12:*/		return 0x82110404;
		  /* 82110404h */ case   13:  		/* bc 12, CR0_EQ, 92 */
		/* 82110404h case   13:*/		if ( regs.CR[0].eq ) { return 0x82110460;  }
		/* 82110404h case   13:*/		return 0x82110408;
		  /* 82110408h */ case   14:  		/* lwz R8, <#[R6 + 12]> */
		/* 82110408h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + 0x0000000C) );
		/* 82110408h case   14:*/		return 0x8211040C;
		  /* 8211040Ch */ case   15:  		/* li R11, 0 */
		/* 8211040Ch case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8211040Ch case   15:*/		return 0x82110410;
		  /* 82110410h */ case   16:  		/* cmplwi CR6, R8, 0 */
		/* 82110410h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82110410h case   16:*/		return 0x82110414;
		  /* 82110414h */ case   17:  		/* bc 12, CR6_EQ, 40 */
		/* 82110414h case   17:*/		if ( regs.CR[6].eq ) { return 0x8211043C;  }
		/* 82110414h case   17:*/		return 0x82110418;
		  /* 82110418h */ case   18:  		/* lwz R9, <#[R6 + 16]> */
		/* 82110418h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000010) );
		/* 82110418h case   18:*/		return 0x8211041C;
		  /* 8211041Ch */ case   19:  		/* li R10, 0 */
		/* 8211041Ch case   19:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8211041Ch case   19:*/		return 0x82110420;
		  /* 82110420h */ case   20:  		/* lwzx R27, <#[R9 + R10]> */
		/* 82110420h case   20:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82110420h case   20:*/		return 0x82110424;
		  /* 82110424h */ case   21:  		/* cmplw CR6, R27, R5 */
		/* 82110424h case   21:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R5);
		/* 82110424h case   21:*/		return 0x82110428;
		  /* 82110428h */ case   22:  		/* bc 12, CR6_EQ, 20 */
		/* 82110428h case   22:*/		if ( regs.CR[6].eq ) { return 0x8211043C;  }
		/* 82110428h case   22:*/		return 0x8211042C;
		  /* 8211042Ch */ case   23:  		/* addi R11, R11, 1 */
		/* 8211042Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8211042Ch case   23:*/		return 0x82110430;
		  /* 82110430h */ case   24:  		/* addi R10, R10, 4 */
		/* 82110430h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82110430h case   24:*/		return 0x82110434;
		  /* 82110434h */ case   25:  		/* cmplw CR6, R11, R8 */
		/* 82110434h case   25:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 82110434h case   25:*/		return 0x82110438;
		  /* 82110438h */ case   26:  		/* bc 12, CR6_LT, -24 */
		/* 82110438h case   26:*/		if ( regs.CR[6].lt ) { return 0x82110420;  }
		/* 82110438h case   26:*/		return 0x8211043C;
	}
	return 0x8211043C;
} // Block from 821103D0h-8211043Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 8211043Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211043C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211043C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211043C);
		  /* 8211043Ch */ case    0:  		/* lwz R10, <#[R7 + 12]> */
		/* 8211043Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x0000000C) );
		/* 8211043Ch case    0:*/		return 0x82110440;
		  /* 82110440h */ case    1:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 82110440h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 82110440h case    1:*/		return 0x82110444;
		  /* 82110444h */ case    2:  		/* lwz R8, <#[R6 + 8]> */
		/* 82110444h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + 0x00000008) );
		/* 82110444h case    2:*/		return 0x82110448;
		  /* 82110448h */ case    3:  		/* mullw R11, R31, R10 */
		/* 82110448h case    3:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R31,regs.R10);
		/* 82110448h case    3:*/		return 0x8211044C;
		  /* 8211044Ch */ case    4:  		/* lwz R10, <#[R7 + 8]> */
		/* 8211044Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000008) );
		/* 8211044Ch case    4:*/		return 0x82110450;
		  /* 82110450h */ case    5:  		/* lwzx R27, <#[R9 + R8]> */
		/* 82110450h case    5:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82110450h case    5:*/		return 0x82110454;
		  /* 82110454h */ case    6:  		/* add R11, R11, R4 */
		/* 82110454h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 82110454h case    6:*/		return 0x82110458;
		  /* 82110458h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82110458h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82110458h case    7:*/		return 0x8211045C;
		  /* 8211045Ch */ case    8:  		/* lwzx R26, <#[R11 + R10]> */
		/* 8211045Ch case    8:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8211045Ch case    8:*/		return 0x82110460;
	}
	return 0x82110460;
} // Block from 8211043Ch-82110460h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82110460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110460);
		  /* 82110460h */ case    0:  		/* addi R3, R3, 1 */
		/* 82110460h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 82110460h case    0:*/		return 0x82110464;
		  /* 82110464h */ case    1:  		/* addi R31, R31, -1 */
		/* 82110464h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82110464h case    1:*/		return 0x82110468;
		  /* 82110468h */ case    2:  		/* cmplwi CR6, R3, 2 */
		/* 82110468h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000002);
		/* 82110468h case    2:*/		return 0x8211046C;
		  /* 8211046Ch */ case    3:  		/* bc 12, CR6_LT, -384 */
		/* 8211046Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x821102EC;  }
		/* 8211046Ch case    3:*/		return 0x82110470;
	}
	return 0x82110470;
} // Block from 82110460h-82110470h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82110470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110470);
		  /* 82110470h */ case    0:  		/* lwz R11, <#[R28 + 4]> */
		/* 82110470h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82110470h case    0:*/		return 0x82110474;
		  /* 82110474h */ case    1:  		/* addi R29, R29, 1 */
		/* 82110474h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82110474h case    1:*/		return 0x82110478;
		  /* 82110478h */ case    2:  		/* addi R30, R30, 4 */
		/* 82110478h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82110478h case    2:*/		return 0x8211047C;
		  /* 8211047Ch */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 8211047Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8211047Ch case    3:*/		return 0x82110480;
		  /* 82110480h */ case    4:  		/* bc 12, CR6_LT, -560 */
		/* 82110480h case    4:*/		if ( regs.CR[6].lt ) { return 0x82110250;  }
		/* 82110480h case    4:*/		return 0x82110484;
		  /* 82110484h */ case    5:  		/* stw R14, <#[R1 + 80]> */
		/* 82110484h case    5:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000050) );
		/* 82110484h case    5:*/		return 0x82110488;
		  /* 82110488h */ case    6:  		/* cmpwi CR6, R27, -1 */
		/* 82110488h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R27,0xFFFFFFFF);
		/* 82110488h case    6:*/		return 0x8211048C;
		  /* 8211048Ch */ case    7:  		/* bc 12, CR6_EQ, 492 */
		/* 8211048Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x82110678;  }
		/* 8211048Ch case    7:*/		return 0x82110490;
		  /* 82110490h */ case    8:  		/* lis R4, 20496 */
		/* 82110490h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x5010);
		/* 82110490h case    8:*/		return 0x82110494;
		  /* 82110494h */ case    9:  		/* mr R6, R23 */
		/* 82110494h case    9:*/		regs.R6 = regs.R23;
		/* 82110494h case    9:*/		return 0x82110498;
		  /* 82110498h */ case   10:  		/* mr R5, R23 */
		/* 82110498h case   10:*/		regs.R5 = regs.R23;
		/* 82110498h case   10:*/		return 0x8211049C;
		  /* 8211049Ch */ case   11:  		/* ori R4, R4, 4 */
		/* 8211049Ch case   11:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x4);
		/* 8211049Ch case   11:*/		return 0x821104A0;
		  /* 821104A0h */ case   12:  		/* mr R3, R17 */
		/* 821104A0h case   12:*/		regs.R3 = regs.R17;
		/* 821104A0h case   12:*/		return 0x821104A4;
		  /* 821104A4h */ case   13:  		/* bl -78300 */
		/* 821104A4h case   13:*/		regs.LR = 0x821104A8; return 0x820FD2C8;
		/* 821104A4h case   13:*/		return 0x821104A8;
		  /* 821104A8h */ case   14:  		/* mr R31, R3 */
		/* 821104A8h case   14:*/		regs.R31 = regs.R3;
		/* 821104A8h case   14:*/		return 0x821104AC;
		  /* 821104ACh */ case   15:  		/* cmpwi CR6, R3, -1 */
		/* 821104ACh case   15:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 821104ACh case   15:*/		return 0x821104B0;
		  /* 821104B0h */ case   16:  		/* bc 12, CR6_EQ, 864 */
		/* 821104B0h case   16:*/		if ( regs.CR[6].eq ) { return 0x82110810;  }
		/* 821104B0h case   16:*/		return 0x821104B4;
		  /* 821104B4h */ case   17:  		/* lis R4, 4096 */
		/* 821104B4h case   17:*/		cpu::op::lis<0>(regs,&regs.R4,0x1000);
		/* 821104B4h case   17:*/		return 0x821104B8;
		  /* 821104B8h */ case   18:  		/* mr R6, R23 */
		/* 821104B8h case   18:*/		regs.R6 = regs.R23;
		/* 821104B8h case   18:*/		return 0x821104BC;
		  /* 821104BCh */ case   19:  		/* mr R5, R23 */
		/* 821104BCh case   19:*/		regs.R5 = regs.R23;
		/* 821104BCh case   19:*/		return 0x821104C0;
		  /* 821104C0h */ case   20:  		/* ori R4, R4, 1 */
		/* 821104C0h case   20:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x1);
		/* 821104C0h case   20:*/		return 0x821104C4;
		  /* 821104C4h */ case   21:  		/* mr R3, R17 */
		/* 821104C4h case   21:*/		regs.R3 = regs.R17;
		/* 821104C4h case   21:*/		return 0x821104C8;
		  /* 821104C8h */ case   22:  		/* bl -78336 */
		/* 821104C8h case   22:*/		regs.LR = 0x821104CC; return 0x820FD2C8;
		/* 821104C8h case   22:*/		return 0x821104CC;
		  /* 821104CCh */ case   23:  		/* cmpwi CR6, R3, -1 */
		/* 821104CCh case   23:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 821104CCh case   23:*/		return 0x821104D0;
		  /* 821104D0h */ case   24:  		/* bc 12, CR6_EQ, 832 */
		/* 821104D0h case   24:*/		if ( regs.CR[6].eq ) { return 0x82110810;  }
		/* 821104D0h case   24:*/		return 0x821104D4;
		  /* 821104D4h */ case   25:  		/* lwz R11, <#[R17 + 24]> */
		/* 821104D4h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000018) );
		/* 821104D4h case   25:*/		return 0x821104D8;
		  /* 821104D8h */ case   26:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 821104D8h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 821104D8h case   26:*/		return 0x821104DC;
		  /* 821104DCh */ case   27:  		/* rlwinm R9, R3, 2, 0, 29 */
		/* 821104DCh case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R3);
		/* 821104DCh case   27:*/		return 0x821104E0;
		  /* 821104E0h */ case   28:  		/* mr R4, R28 */
		/* 821104E0h case   28:*/		regs.R4 = regs.R28;
		/* 821104E0h case   28:*/		return 0x821104E4;
		  /* 821104E4h */ case   29:  		/* lwzx R31, <#[R10 + R11]> */
		/* 821104E4h case   29:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821104E4h case   29:*/		return 0x821104E8;
		  /* 821104E8h */ case   30:  		/* lwzx R29, <#[R9 + R11]> */
		/* 821104E8h case   30:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821104E8h case   30:*/		return 0x821104EC;
		  /* 821104ECh */ case   31:  		/* mr R3, R31 */
		/* 821104ECh case   31:*/		regs.R3 = regs.R31;
		/* 821104ECh case   31:*/		return 0x821104F0;
		  /* 821104F0h */ case   32:  		/* bl -83456 */
		/* 821104F0h case   32:*/		regs.LR = 0x821104F4; return 0x820FBEF0;
		/* 821104F0h case   32:*/		return 0x821104F4;
		  /* 821104F4h */ case   33:  		/* mr R4, R28 */
		/* 821104F4h case   33:*/		regs.R4 = regs.R28;
		/* 821104F4h case   33:*/		return 0x821104F8;
		  /* 821104F8h */ case   34:  		/* mr R3, R29 */
		/* 821104F8h case   34:*/		regs.R3 = regs.R29;
		/* 821104F8h case   34:*/		return 0x821104FC;
		  /* 821104FCh */ case   35:  		/* bl -83468 */
		/* 821104FCh case   35:*/		regs.LR = 0x82110500; return 0x820FBEF0;
		/* 821104FCh case   35:*/		return 0x82110500;
		  /* 82110500h */ case   36:  		/* lwz R11, <#[R31 + 8]> */
		/* 82110500h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82110500h case   36:*/		return 0x82110504;
		  /* 82110504h */ case   37:  		/* li R30, 0 */
		/* 82110504h case   37:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82110504h case   37:*/		return 0x82110508;
		  /* 82110508h */ case   38:  		/* stw R27, <#[R11 + 4]> */
		/* 82110508h case   38:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000004) );
		/* 82110508h case   38:*/		return 0x8211050C;
		  /* 8211050Ch */ case   39:  		/* lwz R11, <#[R31 + 8]> */
		/* 8211050Ch case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8211050Ch case   39:*/		return 0x82110510;
		  /* 82110510h */ case   40:  		/* stw R27, <#[R11]> */
		/* 82110510h case   40:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000000) );
		/* 82110510h case   40:*/		return 0x82110514;
		  /* 82110514h */ case   41:  		/* lwz R11, <#[R31 + 8]> */
		/* 82110514h case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82110514h case   41:*/		return 0x82110518;
		  /* 82110518h */ case   42:  		/* stw R26, <#[R11 + 12]> */
		/* 82110518h case   42:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x0000000C) );
		/* 82110518h case   42:*/		return 0x8211051C;
		  /* 8211051Ch */ case   43:  		/* lwz R11, <#[R31 + 8]> */
		/* 8211051Ch case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8211051Ch case   43:*/		return 0x82110520;
		  /* 82110520h */ case   44:  		/* stw R26, <#[R11 + 8]> */
		/* 82110520h case   44:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000008) );
		/* 82110520h case   44:*/		return 0x82110524;
		  /* 82110524h */ case   45:  		/* li R6, 0 */
		/* 82110524h case   45:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82110524h case   45:*/		return 0x82110528;
		  /* 82110528h */ case   46:  		/* lwz R4, <#[R17 + 136]> */
		/* 82110528h case   46:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R17 + 0x00000088) );
		/* 82110528h case   46:*/		return 0x8211052C;
		  /* 8211052Ch */ case   47:  		/* li R5, 0 */
		/* 8211052Ch case   47:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8211052Ch case   47:*/		return 0x82110530;
		  /* 82110530h */ case   48:  		/* fmr FR1, FR30 */
		/* 82110530h case   48:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 82110530h case   48:*/		return 0x82110534;
		  /* 82110534h */ case   49:  		/* mr R3, R17 */
		/* 82110534h case   49:*/		regs.R3 = regs.R17;
		/* 82110534h case   49:*/		return 0x82110538;
		  /* 82110538h */ case   50:  		/* bl -78608 */
		/* 82110538h case   50:*/		regs.LR = 0x8211053C; return 0x820FD228;
		/* 82110538h case   50:*/		return 0x8211053C;
		  /* 8211053Ch */ case   51:  		/* lwz R11, <#[R31 + 16]> */
		/* 8211053Ch case   51:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8211053Ch case   51:*/		return 0x82110540;
		  /* 82110540h */ case   52:  		/* cmpwi CR6, R3, -1 */
		/* 82110540h case   52:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82110540h case   52:*/		return 0x82110544;
		  /* 82110544h */ case   53:  		/* stwx R3, <#[R30 + R11]> */
		/* 82110544h case   53:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 82110544h case   53:*/		return 0x82110548;
		  /* 82110548h */ case   54:  		/* bc 12, CR6_EQ, 712 */
		/* 82110548h case   54:*/		if ( regs.CR[6].eq ) { return 0x82110810;  }
		/* 82110548h case   54:*/		return 0x8211054C;
		  /* 8211054Ch */ case   55:  		/* lwz R11, <#[R28 + 16]> */
		/* 8211054Ch case   55:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 8211054Ch case   55:*/		return 0x82110550;
		  /* 82110550h */ case   56:  		/* lwz R10, <#[R31 + 16]> */
		/* 82110550h case   56:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82110550h case   56:*/		return 0x82110554;
		  /* 82110554h */ case   57:  		/* lwz R9, <#[R17 + 20]> */
		/* 82110554h case   57:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000014) );
		/* 82110554h case   57:*/		return 0x82110558;
		  /* 82110558h */ case   58:  		/* lwz R11, <#[R11]> */
		/* 82110558h case   58:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82110558h case   58:*/		return 0x8211055C;
		  /* 8211055Ch */ case   59:  		/* lwzx R10, <#[R30 + R10]> */
		/* 8211055Ch case   59:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + regs.R10 + 0x00000000) );
		/* 8211055Ch case   59:*/		return 0x82110560;
		  /* 82110560h */ case   60:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82110560h case   60:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82110560h case   60:*/		return 0x82110564;
		  /* 82110564h */ case   61:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82110564h case   61:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82110564h case   61:*/		return 0x82110568;
		  /* 82110568h */ case   62:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82110568h case   62:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82110568h case   62:*/		return 0x8211056C;
		  /* 8211056Ch */ case   63:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8211056Ch case   63:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8211056Ch case   63:*/		return 0x82110570;
		  /* 82110570h */ case   64:  		/* lwz R11, <#[R11 + 20]> */
		/* 82110570h case   64:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82110570h case   64:*/		return 0x82110574;
		  /* 82110574h */ case   65:  		/* stw R11, <#[R10 + 20]> */
		/* 82110574h case   65:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 82110574h case   65:*/		return 0x82110578;
		  /* 82110578h */ case   66:  		/* lwz R9, <#[R31 + 16]> */
		/* 82110578h case   66:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 82110578h case   66:*/		return 0x8211057C;
		  /* 8211057Ch */ case   67:  		/* lwz R11, <#[R28 + 16]> */
		/* 8211057Ch case   67:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 8211057Ch case   67:*/		return 0x82110580;
		  /* 82110580h */ case   68:  		/* lwz R10, <#[R17 + 20]> */
		/* 82110580h case   68:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000014) );
		/* 82110580h case   68:*/		return 0x82110584;
		  /* 82110584h */ case   69:  		/* lwzx R9, <#[R30 + R9]> */
		/* 82110584h case   69:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + regs.R9 + 0x00000000) );
		/* 82110584h case   69:*/		return 0x82110588;
		  /* 82110588h */ case   70:  		/* lwz R11, <#[R11]> */
		/* 82110588h case   70:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82110588h case   70:*/		return 0x8211058C;
		  /* 8211058Ch */ case   71:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8211058Ch case   71:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8211058Ch case   71:*/		return 0x82110590;
		  /* 82110590h */ case   72:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82110590h case   72:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82110590h case   72:*/		return 0x82110594;
		  /* 82110594h */ case   73:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82110594h case   73:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82110594h case   73:*/		return 0x82110598;
		  /* 82110598h */ case   74:  		/* lwz R11, <#[R11 + 24]> */
		/* 82110598h case   74:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82110598h case   74:*/		return 0x8211059C;
		  /* 8211059Ch */ case   75:  		/* lwzx R10, <#[R9 + R10]> */
		/* 8211059Ch case   75:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8211059Ch case   75:*/		return 0x821105A0;
		  /* 821105A0h */ case   76:  		/* stw R11, <#[R10 + 24]> */
		/* 821105A0h case   76:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000018) );
		/* 821105A0h case   76:*/		return 0x821105A4;
		  /* 821105A4h */ case   77:  		/* lwz R9, <#[R28 + 16]> */
		/* 821105A4h case   77:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000010) );
		/* 821105A4h case   77:*/		return 0x821105A8;
		  /* 821105A8h */ case   78:  		/* lwz R10, <#[R17 + 20]> */
		/* 821105A8h case   78:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000014) );
		/* 821105A8h case   78:*/		return 0x821105AC;
		  /* 821105ACh */ case   79:  		/* lwz R11, <#[R31 + 16]> */
		/* 821105ACh case   79:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821105ACh case   79:*/		return 0x821105B0;
		  /* 821105B0h */ case   80:  		/* lwz R9, <#[R9]> */
		/* 821105B0h case   80:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 821105B0h case   80:*/		return 0x821105B4;
		  /* 821105B4h */ case   81:  		/* lwzx R11, <#[R30 + R11]> */
		/* 821105B4h case   81:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 821105B4h case   81:*/		return 0x821105B8;
		  /* 821105B8h */ case   82:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821105B8h case   82:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821105B8h case   82:*/		return 0x821105BC;
		  /* 821105BCh */ case   83:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821105BCh case   83:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821105BCh case   83:*/		return 0x821105C0;
		  /* 821105C0h */ case   84:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821105C0h case   84:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821105C0h case   84:*/		return 0x821105C4;
		  /* 821105C4h */ case   85:  		/* addi R30, R30, 4 */
		/* 821105C4h case   85:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 821105C4h case   85:*/		return 0x821105C8;
		  /* 821105C8h */ case   86:  		/* cmplwi CR6, R30, 16 */
		/* 821105C8h case   86:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000010);
		/* 821105C8h case   86:*/		return 0x821105CC;
		  /* 821105CCh */ case   87:  		/* lwzx R10, <#[R9 + R10]> */
		/* 821105CCh case   87:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821105CCh case   87:*/		return 0x821105D0;
		  /* 821105D0h */ case   88:  		/* lwz R9, <#[R11]> */
		/* 821105D0h case   88:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821105D0h case   88:*/		return 0x821105D4;
		  /* 821105D4h */ case   89:  		/* lwz R10, <#[R10]> */
		/* 821105D4h case   89:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821105D4h case   89:*/		return 0x821105D8;
		  /* 821105D8h */ case   90:  		/* rlwinm R10, R10, 0, 4, 6 */
		/* 821105D8h case   90:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R10,regs.R10);
		/* 821105D8h case   90:*/		return 0x821105DC;
		  /* 821105DCh */ case   91:  		/* or R10, R10, R9 */
		/* 821105DCh case   91:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 821105DCh case   91:*/		return 0x821105E0;
		  /* 821105E0h */ case   92:  		/* stw R10, <#[R11]> */
		/* 821105E0h case   92:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821105E0h case   92:*/		return 0x821105E4;
		  /* 821105E4h */ case   93:  		/* bc 12, CR6_LT, -192 */
		/* 821105E4h case   93:*/		if ( regs.CR[6].lt ) { return 0x82110524;  }
		/* 821105E4h case   93:*/		return 0x821105E8;
		  /* 821105E8h */ case   94:  		/* lwz R11, <#[R31 + 16]> */
		/* 821105E8h case   94:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821105E8h case   94:*/		return 0x821105EC;
		  /* 821105ECh */ case   95:  		/* mr R3, R28 */
		/* 821105ECh case   95:*/		regs.R3 = regs.R28;
		/* 821105ECh case   95:*/		return 0x821105F0;
		  /* 821105F0h */ case   96:  		/* lwz R10, <#[R29 + 8]> */
		/* 821105F0h case   96:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 821105F0h case   96:*/		return 0x821105F4;
		  /* 821105F4h */ case   97:  		/* lwz R11, <#[R11 + 8]> */
		/* 821105F4h case   97:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821105F4h case   97:*/		return 0x821105F8;
		  /* 821105F8h */ case   98:  		/* stw R11, <#[R10]> */
		/* 821105F8h case   98:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821105F8h case   98:*/		return 0x821105FC;
		  /* 821105FCh */ case   99:  		/* lwz R10, <#[R29 + 16]> */
		/* 821105FCh case   99:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000010) );
		/* 821105FCh case   99:*/		return 0x82110600;
		  /* 82110600h */ case  100:  		/* lwz R11, <#[R28 + 16]> */
		/* 82110600h case  100:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 82110600h case  100:*/		return 0x82110604;
		  /* 82110604h */ case  101:  		/* lwz R11, <#[R11]> */
		/* 82110604h case  101:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82110604h case  101:*/		return 0x82110608;
		  /* 82110608h */ case  102:  		/* stw R11, <#[R10]> */
		/* 82110608h case  102:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82110608h case  102:*/		return 0x8211060C;
		  /* 8211060Ch */ case  103:  		/* bl 1101236 */
		/* 8211060Ch case  103:*/		regs.LR = 0x82110610; return 0x8221D3C0;
		/* 8211060Ch case  103:*/		return 0x82110610;
		  /* 82110610h */ case  104:  		/* mr R3, R28 */
		/* 82110610h case  104:*/		regs.R3 = regs.R28;
		/* 82110610h case  104:*/		return 0x82110614;
		  /* 82110614h */ case  105:  		/* bl -81956 */
		/* 82110614h case  105:*/		regs.LR = 0x82110618; return 0x820FC5F0;
		/* 82110614h case  105:*/		return 0x82110618;
		  /* 82110618h */ case  106:  		/* lwz R11, <#[R17 + 12]> */
		/* 82110618h case  106:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000000C) );
		/* 82110618h case  106:*/		return 0x8211061C;
		  /* 8211061Ch */ case  107:  		/* addi R11, R11, -1 */
		/* 8211061Ch case  107:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8211061Ch case  107:*/		return 0x82110620;
		  /* 82110620h */ case  108:  		/* addi R10, R11, -1 */
		/* 82110620h case  108:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 82110620h case  108:*/		return 0x82110624;
		  /* 82110624h */ case  109:  		/* stw R11, <#[R17 + 12]> */
		/* 82110624h case  109:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R17 + 0x0000000C) );
		/* 82110624h case  109:*/		return 0x82110628;
		  /* 82110628h */ case  110:  		/* cmplw CR6, R10, R24 */
		/* 82110628h case  110:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R24);
		/* 82110628h case  110:*/		return 0x8211062C;
		  /* 8211062Ch */ case  111:  		/* bc 4, CR6_GT, 40 */
		/* 8211062Ch case  111:*/		if ( !regs.CR[6].gt ) { return 0x82110654;  }
		/* 8211062Ch case  111:*/		return 0x82110630;
		  /* 82110630h */ case  112:  		/* subf R9, R24, R10 */
		/* 82110630h case  112:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R24,regs.R10);
		/* 82110630h case  112:*/		return 0x82110634;
		  /* 82110634h */ case  113:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 82110634h case  113:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 82110634h case  113:*/		return 0x82110638;
		  /* 82110638h */ case  114:  		/* mtspr CTR, R9 */
		/* 82110638h case  114:*/		regs.CTR = regs.R9;
		/* 82110638h case  114:*/		return 0x8211063C;
		  /* 8211063Ch */ case  115:  		/* lwz R10, <#[R17 + 24]> */
		/* 8211063Ch case  115:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000018) );
		/* 8211063Ch case  115:*/		return 0x82110640;
		  /* 82110640h */ case  116:  		/* add R10, R10, R11 */
		/* 82110640h case  116:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82110640h case  116:*/		return 0x82110644;
		  /* 82110644h */ case  117:  		/* addi R11, R11, -4 */
		/* 82110644h case  117:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 82110644h case  117:*/		return 0x82110648;
		  /* 82110648h */ case  118:  		/* lwz R9, <#[R10 - 4]> */
		/* 82110648h case  118:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 82110648h case  118:*/		return 0x8211064C;
		  /* 8211064Ch */ case  119:  		/* stw R9, <#[R10]> */
		/* 8211064Ch case  119:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8211064Ch case  119:*/		return 0x82110650;
		  /* 82110650h */ case  120:  		/* bc 16, CR0_LT, -20 */
		/* 82110650h case  120:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8211063C;  }
		/* 82110650h case  120:*/		return 0x82110654;
	}
	return 0x82110654;
} // Block from 82110470h-82110654h (121 instructions)

//////////////////////////////////////////////////////
// Block at 82110654h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110654( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110654) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110654);
		  /* 82110654h */ case    0:  		/* lwz R11, <#[R17 + 24]> */
		/* 82110654h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000018) );
		/* 82110654h case    0:*/		return 0x82110658;
		  /* 82110658h */ case    1:  		/* mr R3, R17 */
		/* 82110658h case    1:*/		regs.R3 = regs.R17;
		/* 82110658h case    1:*/		return 0x8211065C;
		  /* 8211065Ch */ case    2:  		/* stwx R31, <#[R11 + R25]> */
		/* 8211065Ch case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 8211065Ch case    2:*/		return 0x82110660;
		  /* 82110660h */ case    3:  		/* lwz R11, <#[R17 + 24]> */
		/* 82110660h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000018) );
		/* 82110660h case    3:*/		return 0x82110664;
		  /* 82110664h */ case    4:  		/* add R11, R11, R25 */
		/* 82110664h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R25);
		/* 82110664h case    4:*/		return 0x82110668;
		  /* 82110668h */ case    5:  		/* stw R29, <#[R11 + 4]> */
		/* 82110668h case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000004) );
		/* 82110668h case    5:*/		return 0x8211066C;
		  /* 8211066Ch */ case    6:  		/* bl -43732 */
		/* 8211066Ch case    6:*/		regs.LR = 0x82110670; return 0x82105B98;
		/* 8211066Ch case    6:*/		return 0x82110670;
		  /* 82110670h */ case    7:  		/* li R14, 1 */
		/* 82110670h case    7:*/		cpu::op::li<0>(regs,&regs.R14,0x1);
		/* 82110670h case    7:*/		return 0x82110674;
		  /* 82110674h */ case    8:  		/* stw R14, <#[R1 + 80]> */
		/* 82110674h case    8:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000050) );
		/* 82110674h case    8:*/		return 0x82110678;
	}
	return 0x82110678;
} // Block from 82110654h-82110678h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82110678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110678);
		  /* 82110678h */ case    0:  		/* lwz R11, <#[R17 + 12]> */
		/* 82110678h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000000C) );
		/* 82110678h case    0:*/		return 0x8211067C;
		  /* 8211067Ch */ case    1:  		/* addi R24, R24, 1 */
		/* 8211067Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 8211067Ch case    1:*/		return 0x82110680;
		  /* 82110680h */ case    2:  		/* addi R25, R25, 4 */
		/* 82110680h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 82110680h case    2:*/		return 0x82110684;
		  /* 82110684h */ case    3:  		/* cmplw CR6, R24, R11 */
		/* 82110684h case    3:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R11);
		/* 82110684h case    3:*/		return 0x82110688;
		  /* 82110688h */ case    4:  		/* bc 12, CR6_LT, -1184 */
		/* 82110688h case    4:*/		if ( regs.CR[6].lt ) { return 0x821101E8;  }
		/* 82110688h case    4:*/		return 0x8211068C;
	}
	return 0x8211068C;
} // Block from 82110678h-8211068Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8211068Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211068C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211068C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211068C);
		  /* 8211068Ch */ case    0:  		/* cmpwi CR6, R14, 0 */
		/* 8211068Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 8211068Ch case    0:*/		return 0x82110690;
		  /* 82110690h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 82110690h case    1:*/		if ( regs.CR[6].eq ) { return 0x821106A8;  }
		/* 82110690h case    1:*/		return 0x82110694;
		  /* 82110694h */ case    2:  		/* li R14, 0 */
		/* 82110694h case    2:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 82110694h case    2:*/		return 0x82110698;
		  /* 82110698h */ case    3:  		/* mr R3, R17 */
		/* 82110698h case    3:*/		regs.R3 = regs.R17;
		/* 82110698h case    3:*/		return 0x8211069C;
		  /* 8211069Ch */ case    4:  		/* li R15, 1 */
		/* 8211069Ch case    4:*/		cpu::op::li<0>(regs,&regs.R15,0x1);
		/* 8211069Ch case    4:*/		return 0x821106A0;
		  /* 821106A0h */ case    5:  		/* stw R14, <#[R1 + 80]> */
		/* 821106A0h case    5:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000050) );
		/* 821106A0h case    5:*/		return 0x821106A4;
		  /* 821106A4h */ case    6:  		/* bl -43788 */
		/* 821106A4h case    6:*/		regs.LR = 0x821106A8; return 0x82105B98;
		/* 821106A4h case    6:*/		return 0x821106A8;
	}
	return 0x821106A8;
} // Block from 8211068Ch-821106A8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821106A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821106A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821106A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821106A8);
		  /* 821106A8h */ case    0:  		/* lwz R11, <#[R17 + 12]> */
		/* 821106A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000000C) );
		/* 821106A8h case    0:*/		return 0x821106AC;
		  /* 821106ACh */ case    1:  		/* li R27, 0 */
		/* 821106ACh case    1:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 821106ACh case    1:*/		return 0x821106B0;
		  /* 821106B0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821106B0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821106B0h case    2:*/		return 0x821106B4;
		  /* 821106B4h */ case    3:  		/* bc 4, CR6_GT, 432 */
		/* 821106B4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82110864;  }
		/* 821106B4h case    3:*/		return 0x821106B8;
		  /* 821106B8h */ case    4:  		/* li R28, 0 */
		/* 821106B8h case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 821106B8h case    4:*/		return 0x821106BC;
		  /* 821106BCh */ case    5:  		/* lwz R11, <#[R17 + 24]> */
		/* 821106BCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000018) );
		/* 821106BCh case    5:*/		return 0x821106C0;
		  /* 821106C0h */ case    6:  		/* lwzx R30, <#[R28 + R11]> */
		/* 821106C0h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 821106C0h case    6:*/		return 0x821106C4;
		  /* 821106C4h */ case    7:  		/* lwz R11, <#[R30]> */
		/* 821106C4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821106C4h case    7:*/		return 0x821106C8;
		  /* 821106C8h */ case    8:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 821106C8h case    8:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 821106C8h case    8:*/		return 0x821106CC;
		  /* 821106CCh */ case    9:  		/* bc 12, CR0_EQ, 384 */
		/* 821106CCh case    9:*/		if ( regs.CR[0].eq ) { return 0x8211084C;  }
		/* 821106CCh case    9:*/		return 0x821106D0;
		  /* 821106D0h */ case   10:  		/* lwz R10, <#[R30 + 12]> */
		/* 821106D0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000000C) );
		/* 821106D0h case   10:*/		return 0x821106D4;
		  /* 821106D4h */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 821106D4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821106D4h case   11:*/		return 0x821106D8;
		  /* 821106D8h */ case   12:  		/* bc 12, CR6_EQ, 36 */
		/* 821106D8h case   12:*/		if ( regs.CR[6].eq ) { return 0x821106FC;  }
		/* 821106D8h case   12:*/		return 0x821106DC;
		  /* 821106DCh */ case   13:  		/* lwz R10, <#[R30 + 16]> */
		/* 821106DCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 821106DCh case   13:*/		return 0x821106E0;
		  /* 821106E0h */ case   14:  		/* lwz R9, <#[R17 + 20]> */
		/* 821106E0h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000014) );
		/* 821106E0h case   14:*/		return 0x821106E4;
		  /* 821106E4h */ case   15:  		/* lwz R10, <#[R10]> */
		/* 821106E4h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821106E4h case   15:*/		return 0x821106E8;
		  /* 821106E8h */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821106E8h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821106E8h case   16:*/		return 0x821106EC;
		  /* 821106ECh */ case   17:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821106ECh case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821106ECh case   17:*/		return 0x821106F0;
		  /* 821106F0h */ case   18:  		/* lwz R10, <#[R10]> */
		/* 821106F0h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821106F0h case   18:*/		return 0x821106F4;
		  /* 821106F4h */ case   19:  		/* rlwinm. R10, R10, 0, 25, 25 */
		/* 821106F4h case   19:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R10);
		/* 821106F4h case   19:*/		return 0x821106F8;
		  /* 821106F8h */ case   20:  		/* bc 4, CR0_EQ, 340 */
		/* 821106F8h case   20:*/		if ( !regs.CR[0].eq ) { return 0x8211084C;  }
		/* 821106F8h case   20:*/		return 0x821106FC;
	}
	return 0x821106FC;
} // Block from 821106A8h-821106FCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 821106FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821106FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821106FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821106FC);
		  /* 821106FCh */ case    0:  		/* lis R10, 4160 */
		/* 821106FCh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x1040);
		/* 821106FCh case    0:*/		return 0x82110700;
		  /* 82110700h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 82110700h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82110700h case    1:*/		return 0x82110704;
		  /* 82110704h */ case    2:  		/* bc 4, CR6_EQ, 328 */
		/* 82110704h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8211084C;  }
		/* 82110704h case    2:*/		return 0x82110708;
		  /* 82110708h */ case    3:  		/* lwz R11, <#[R30 + 4]> */
		/* 82110708h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82110708h case    3:*/		return 0x8211070C;
		  /* 8211070Ch */ case    4:  		/* li R29, 0 */
		/* 8211070Ch case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8211070Ch case    4:*/		return 0x82110710;
		  /* 82110710h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82110710h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82110710h case    5:*/		return 0x82110714;
		  /* 82110714h */ case    6:  		/* bc 4, CR6_GT, 312 */
		/* 82110714h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8211084C;  }
		/* 82110714h case    6:*/		return 0x82110718;
		  /* 82110718h */ case    7:  		/* li R3, 0 */
		/* 82110718h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82110718h case    7:*/		return 0x8211071C;
		  /* 8211071Ch */ case    8:  		/* lwz R31, <#[R30 + 8]> */
		/* 8211071Ch case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000008) );
		/* 8211071Ch case    8:*/		return 0x82110720;
		  /* 82110720h */ case    9:  		/* lwz R5, <#[R17 + 20]> */
		/* 82110720h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R17 + 0x00000014) );
		/* 82110720h case    9:*/		return 0x82110724;
		  /* 82110724h */ case   10:  		/* lwz R4, <#[R17 + 16]> */
		/* 82110724h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R17 + 0x00000010) );
		/* 82110724h case   10:*/		return 0x82110728;
		  /* 82110728h */ case   11:  		/* lwzx R6, <#[R3 + R31]> */
		/* 82110728h case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + regs.R31 + 0x00000000) );
		/* 82110728h case   11:*/		return 0x8211072C;
		  /* 8211072Ch */ case   12:  		/* rlwinm R11, R6, 2, 0, 29 */
		/* 8211072Ch case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R6);
		/* 8211072Ch case   12:*/		return 0x82110730;
		  /* 82110730h */ case   13:  		/* lwzx R11, <#[R11 + R5]> */
		/* 82110730h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 82110730h case   13:*/		return 0x82110734;
		  /* 82110734h */ case   14:  		/* lwz R10, <#[R11 + 4]> */
		/* 82110734h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82110734h case   14:*/		return 0x82110738;
		  /* 82110738h */ case   15:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82110738h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82110738h case   15:*/		return 0x8211073C;
		  /* 8211073Ch */ case   16:  		/* lwzx R10, <#[R10 + R4]> */
		/* 8211073Ch case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 8211073Ch case   16:*/		return 0x82110740;
		  /* 82110740h */ case   17:  		/* lwz R10, <#[R10 + 4]> */
		/* 82110740h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82110740h case   17:*/		return 0x82110744;
		  /* 82110744h */ case   18:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 82110744h case   18:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 82110744h case   18:*/		return 0x82110748;
		  /* 82110748h */ case   19:  		/* bc 12, CR0_EQ, 240 */
		/* 82110748h case   19:*/		if ( regs.CR[0].eq ) { return 0x82110838;  }
		/* 82110748h case   19:*/		return 0x8211074C;
		  /* 8211074Ch */ case   20:  		/* lwz R10, <#[R11 + 8]> */
		/* 8211074Ch case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8211074Ch case   20:*/		return 0x82110750;
		  /* 82110750h */ case   21:  		/* cmpwi CR6, R10, -1 */
		/* 82110750h case   21:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82110750h case   21:*/		return 0x82110754;
		  /* 82110754h */ case   22:  		/* bc 4, CR6_EQ, 228 */
		/* 82110754h case   22:*/		if ( !regs.CR[6].eq ) { return 0x82110838;  }
		/* 82110754h case   22:*/		return 0x82110758;
		  /* 82110758h */ case   23:  		/* lwz R11, <#[R11 + 72]> */
		/* 82110758h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 82110758h case   23:*/		return 0x8211075C;
		  /* 8211075Ch */ case   24:  		/* lis R10, 8256 */
		/* 8211075Ch case   24:*/		cpu::op::lis<0>(regs,&regs.R10,0x2040);
		/* 8211075Ch case   24:*/		return 0x82110760;
		  /* 82110760h */ case   25:  		/* lwz R9, <#[R17 + 24]> */
		/* 82110760h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000018) );
		/* 82110760h case   25:*/		return 0x82110764;
		  /* 82110764h */ case   26:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82110764h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82110764h case   26:*/		return 0x82110768;
		  /* 82110768h */ case   27:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82110768h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82110768h case   27:*/		return 0x8211076C;
		  /* 8211076Ch */ case   28:  		/* lwz R9, <#[R11]> */
		/* 8211076Ch case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8211076Ch case   28:*/		return 0x82110770;
		  /* 82110770h */ case   29:  		/* rlwinm R9, R9, 0, 0, 11 */
		/* 82110770h case   29:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R9,regs.R9);
		/* 82110770h case   29:*/		return 0x82110774;
		  /* 82110774h */ case   30:  		/* cmplw CR6, R9, R10 */
		/* 82110774h case   30:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82110774h case   30:*/		return 0x82110778;
		  /* 82110778h */ case   31:  		/* bc 4, CR6_EQ, 192 */
		/* 82110778h case   31:*/		if ( !regs.CR[6].eq ) { return 0x82110838;  }
		/* 82110778h case   31:*/		return 0x8211077C;
		  /* 8211077Ch */ case   32:  		/* lwz R7, <#[R11 + 12]> */
		/* 8211077Ch case   32:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 8211077Ch case   32:*/		return 0x82110780;
		  /* 82110780h */ case   33:  		/* li R8, 0 */
		/* 82110780h case   33:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82110780h case   33:*/		return 0x82110784;
		  /* 82110784h */ case   34:  		/* cmplwi CR6, R7, 0 */
		/* 82110784h case   34:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82110784h case   34:*/		return 0x82110788;
		  /* 82110788h */ case   35:  		/* bc 12, CR6_EQ, 40 */
		/* 82110788h case   35:*/		if ( regs.CR[6].eq ) { return 0x821107B0;  }
		/* 82110788h case   35:*/		return 0x8211078C;
		  /* 8211078Ch */ case   36:  		/* lwz R9, <#[R11 + 16]> */
		/* 8211078Ch case   36:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 8211078Ch case   36:*/		return 0x82110790;
		  /* 82110790h */ case   37:  		/* li R10, 0 */
		/* 82110790h case   37:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82110790h case   37:*/		return 0x82110794;
		  /* 82110794h */ case   38:  		/* lwzx R26, <#[R9 + R10]> */
		/* 82110794h case   38:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82110794h case   38:*/		return 0x82110798;
		  /* 82110798h */ case   39:  		/* cmplw CR6, R26, R6 */
		/* 82110798h case   39:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R6);
		/* 82110798h case   39:*/		return 0x8211079C;
		  /* 8211079Ch */ case   40:  		/* bc 12, CR6_EQ, 20 */
		/* 8211079Ch case   40:*/		if ( regs.CR[6].eq ) { return 0x821107B0;  }
		/* 8211079Ch case   40:*/		return 0x821107A0;
		  /* 821107A0h */ case   41:  		/* addi R8, R8, 1 */
		/* 821107A0h case   41:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821107A0h case   41:*/		return 0x821107A4;
		  /* 821107A4h */ case   42:  		/* addi R10, R10, 4 */
		/* 821107A4h case   42:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821107A4h case   42:*/		return 0x821107A8;
		  /* 821107A8h */ case   43:  		/* cmplw CR6, R8, R7 */
		/* 821107A8h case   43:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 821107A8h case   43:*/		return 0x821107AC;
		  /* 821107ACh */ case   44:  		/* bc 12, CR6_LT, -24 */
		/* 821107ACh case   44:*/		if ( regs.CR[6].lt ) { return 0x82110794;  }
		/* 821107ACh case   44:*/		return 0x821107B0;
	}
	return 0x821107B0;
} // Block from 821106FCh-821107B0h (45 instructions)

//////////////////////////////////////////////////////
// Block at 821107B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821107B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821107B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821107B0);
		  /* 821107B0h */ case    0:  		/* lwz R9, <#[R11 + 8]> */
		/* 821107B0h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821107B0h case    0:*/		return 0x821107B4;
		  /* 821107B4h */ case    1:  		/* li R11, 0 */
		/* 821107B4h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821107B4h case    1:*/		return 0x821107B8;
		  /* 821107B8h */ case    2:  		/* mullw R10, R11, R7 */
		/* 821107B8h case    2:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R11,regs.R7);
		/* 821107B8h case    2:*/		return 0x821107BC;
		  /* 821107BCh */ case    3:  		/* add R10, R10, R8 */
		/* 821107BCh case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 821107BCh case    3:*/		return 0x821107C0;
		  /* 821107C0h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821107C0h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821107C0h case    4:*/		return 0x821107C4;
		  /* 821107C4h */ case    5:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821107C4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821107C4h case    5:*/		return 0x821107C8;
		  /* 821107C8h */ case    6:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821107C8h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821107C8h case    6:*/		return 0x821107CC;
		  /* 821107CCh */ case    7:  		/* lwzx R10, <#[R10 + R5]> */
		/* 821107CCh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 821107CCh case    7:*/		return 0x821107D0;
		  /* 821107D0h */ case    8:  		/* lwz R6, <#[R10 + 4]> */
		/* 821107D0h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 821107D0h case    8:*/		return 0x821107D4;
		  /* 821107D4h */ case    9:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 821107D4h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 821107D4h case    9:*/		return 0x821107D8;
		  /* 821107D8h */ case   10:  		/* lwzx R6, <#[R6 + R4]> */
		/* 821107D8h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R4 + 0x00000000) );
		/* 821107D8h case   10:*/		return 0x821107DC;
		  /* 821107DCh */ case   11:  		/* lwz R6, <#[R6 + 4]> */
		/* 821107DCh case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000004) );
		/* 821107DCh case   11:*/		return 0x821107E0;
		  /* 821107E0h */ case   12:  		/* rlwinm. R6, R6, 0, 23, 23 */
		/* 821107E0h case   12:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R6,regs.R6);
		/* 821107E0h case   12:*/		return 0x821107E4;
		  /* 821107E4h */ case   13:  		/* bc 12, CR0_EQ, 28 */
		/* 821107E4h case   13:*/		if ( regs.CR[0].eq ) { return 0x82110800;  }
		/* 821107E4h case   13:*/		return 0x821107E8;
		  /* 821107E8h */ case   14:  		/* lwz R6, <#[R10]> */
		/* 821107E8h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 821107E8h case   14:*/		return 0x821107EC;
		  /* 821107ECh */ case   15:  		/* rlwinm. R6, R6, 0, 30, 30 */
		/* 821107ECh case   15:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R6,regs.R6);
		/* 821107ECh case   15:*/		return 0x821107F0;
		  /* 821107F0h */ case   16:  		/* bc 12, CR0_EQ, 16 */
		/* 821107F0h case   16:*/		if ( regs.CR[0].eq ) { return 0x82110800;  }
		/* 821107F0h case   16:*/		return 0x821107F4;
		  /* 821107F4h */ case   17:  		/* lwz R10, <#[R10 + 8]> */
		/* 821107F4h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821107F4h case   17:*/		return 0x821107F8;
		  /* 821107F8h */ case   18:  		/* cmpwi CR6, R10, -1 */
		/* 821107F8h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 821107F8h case   18:*/		return 0x821107FC;
		  /* 821107FCh */ case   19:  		/* bc 12, CR6_EQ, 32 */
		/* 821107FCh case   19:*/		if ( regs.CR[6].eq ) { return 0x8211081C;  }
		/* 821107FCh case   19:*/		return 0x82110800;
	}
	return 0x82110800;
} // Block from 821107B0h-82110800h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82110800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110800);
		  /* 82110800h */ case    0:  		/* addi R11, R11, 1 */
		/* 82110800h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82110800h case    0:*/		return 0x82110804;
		  /* 82110804h */ case    1:  		/* cmplwi CR6, R11, 2 */
		/* 82110804h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 82110804h case    1:*/		return 0x82110808;
		  /* 82110808h */ case    2:  		/* bc 12, CR6_LT, -80 */
		/* 82110808h case    2:*/		if ( regs.CR[6].lt ) { return 0x821107B8;  }
		/* 82110808h case    2:*/		return 0x8211080C;
		  /* 8211080Ch */ case    3:  		/* b 44 */
		/* 8211080Ch case    3:*/		return 0x82110838;
		/* 8211080Ch case    3:*/		return 0x82110810;
	}
	return 0x82110810;
} // Block from 82110800h-82110810h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82110810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110810);
		  /* 82110810h */ case    0:  		/* lis R3, -32761 */
		/* 82110810h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 82110810h case    0:*/		return 0x82110814;
		  /* 82110814h */ case    1:  		/* ori R3, R3, 14 */
		/* 82110814h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 82110814h case    1:*/		return 0x82110818;
		  /* 82110818h */ case    2:  		/* b 3000 */
		/* 82110818h case    2:*/		return 0x821113D0;
		/* 82110818h case    2:*/		return 0x8211081C;
	}
	return 0x8211081C;
} // Block from 82110810h-8211081Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8211081Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211081C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211081C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211081C);
		  /* 8211081Ch */ case    0:  		/* subfic R11, R11, 1 */
		/* 8211081Ch case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8211081Ch case    0:*/		return 0x82110820;
		  /* 82110820h */ case    1:  		/* li R14, 1 */
		/* 82110820h case    1:*/		cpu::op::li<0>(regs,&regs.R14,0x1);
		/* 82110820h case    1:*/		return 0x82110824;
		  /* 82110824h */ case    2:  		/* mullw R11, R11, R7 */
		/* 82110824h case    2:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 82110824h case    2:*/		return 0x82110828;
		  /* 82110828h */ case    3:  		/* add R11, R11, R8 */
		/* 82110828h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 82110828h case    3:*/		return 0x8211082C;
		  /* 8211082Ch */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8211082Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8211082Ch case    4:*/		return 0x82110830;
		  /* 82110830h */ case    5:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82110830h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82110830h case    5:*/		return 0x82110834;
		  /* 82110834h */ case    6:  		/* stwx R11, <#[R3 + R31]> */
		/* 82110834h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + regs.R31 + 0x00000000) );
		/* 82110834h case    6:*/		return 0x82110838;
	}
	return 0x82110838;
} // Block from 8211081Ch-82110838h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82110838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110838);
		  /* 82110838h */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 82110838h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82110838h case    0:*/		return 0x8211083C;
		  /* 8211083Ch */ case    1:  		/* addi R29, R29, 1 */
		/* 8211083Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8211083Ch case    1:*/		return 0x82110840;
		  /* 82110840h */ case    2:  		/* addi R3, R3, 4 */
		/* 82110840h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 82110840h case    2:*/		return 0x82110844;
		  /* 82110844h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 82110844h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82110844h case    3:*/		return 0x82110848;
		  /* 82110848h */ case    4:  		/* bc 12, CR6_LT, -300 */
		/* 82110848h case    4:*/		if ( regs.CR[6].lt ) { return 0x8211071C;  }
		/* 82110848h case    4:*/		return 0x8211084C;
	}
	return 0x8211084C;
} // Block from 82110838h-8211084Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8211084Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211084C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211084C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211084C);
		  /* 8211084Ch */ case    0:  		/* lwz R11, <#[R17 + 12]> */
		/* 8211084Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000000C) );
		/* 8211084Ch case    0:*/		return 0x82110850;
		  /* 82110850h */ case    1:  		/* addi R27, R27, 1 */
		/* 82110850h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82110850h case    1:*/		return 0x82110854;
		  /* 82110854h */ case    2:  		/* addi R28, R28, 4 */
		/* 82110854h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82110854h case    2:*/		return 0x82110858;
		  /* 82110858h */ case    3:  		/* cmplw CR6, R27, R11 */
		/* 82110858h case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 82110858h case    3:*/		return 0x8211085C;
		  /* 8211085Ch */ case    4:  		/* bc 12, CR6_LT, -416 */
		/* 8211085Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x821106BC;  }
		/* 8211085Ch case    4:*/		return 0x82110860;
		  /* 82110860h */ case    5:  		/* stw R14, <#[R1 + 80]> */
		/* 82110860h case    5:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000050) );
		/* 82110860h case    5:*/		return 0x82110864;
	}
	return 0x82110864;
} // Block from 8211084Ch-82110864h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82110864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110864);
		  /* 82110864h */ case    0:  		/* cmpwi CR6, R14, 0 */
		/* 82110864h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 82110864h case    0:*/		return 0x82110868;
		  /* 82110868h */ case    1:  		/* bc 4, CR6_EQ, 2880 */
		/* 82110868h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821113A8;  }
		/* 82110868h case    1:*/		return 0x8211086C;
		  /* 8211086Ch */ case    2:  		/* cmpwi CR6, R15, 0 */
		/* 8211086Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R15,0x00000000);
		/* 8211086Ch case    2:*/		return 0x82110870;
		  /* 82110870h */ case    3:  		/* bc 4, CR6_EQ, 2872 */
		/* 82110870h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821113A8;  }
		/* 82110870h case    3:*/		return 0x82110874;
		  /* 82110874h */ case    4:  		/* lwz R19, <#[R17 + 12]> */
		/* 82110874h case    4:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R17 + 0x0000000C) );
		/* 82110874h case    4:*/		return 0x82110878;
		  /* 82110878h */ case    5:  		/* lwz R20, <#[R1 + 92]> */
		/* 82110878h case    5:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x0000005C) );
		/* 82110878h case    5:*/		return 0x8211087C;
		  /* 8211087Ch */ case    6:  		/* lwz R21, <#[R1 + 88]> */
		/* 8211087Ch case    6:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000058) );
		/* 8211087Ch case    6:*/		return 0x82110880;
		  /* 82110880h */ case    7:  		/* cmplwi CR6, R19, 0 */
		/* 82110880h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 82110880h case    7:*/		return 0x82110884;
		  /* 82110884h */ case    8:  		/* lwz R26, <#[R1 + 80]> */
		/* 82110884h case    8:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 82110884h case    8:*/		return 0x82110888;
		  /* 82110888h */ case    9:  		/* bc 12, CR6_EQ, 2776 */
		/* 82110888h case    9:*/		if ( regs.CR[6].eq ) { return 0x82111360;  }
		/* 82110888h case    9:*/		return 0x8211088C;
		  /* 8211088Ch */ case   10:  		/* lis R11, -32255 */
		/* 8211088Ch case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8211088Ch case   10:*/		return 0x82110890;
		  /* 82110890h */ case   11:  		/* lwz R15, <#[R1 + 104]> */
		/* 82110890h case   11:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R1 + 0x00000068) );
		/* 82110890h case   11:*/		return 0x82110894;
		  /* 82110894h */ case   12:  		/* lis R10, -32255 */
		/* 82110894h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 82110894h case   12:*/		return 0x82110898;
		  /* 82110898h */ case   13:  		/* lwz R16, <#[R1 + 108]> */
		/* 82110898h case   13:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R1 + 0x0000006C) );
		/* 82110898h case   13:*/		return 0x8211089C;
		  /* 8211089Ch */ case   14:  		/* lis R9, -32256 */
		/* 8211089Ch case   14:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 8211089Ch case   14:*/		return 0x821108A0;
		  /* 821108A0h */ case   15:  		/* li R24, -1 */
		/* 821108A0h case   15:*/		cpu::op::li<0>(regs,&regs.R24,0xFFFFFFFF);
		/* 821108A0h case   15:*/		return 0x821108A4;
		  /* 821108A4h */ case   16:  		/* lfd FR28, <#[R11 - 24504]> */
		/* 821108A4h case   16:*/		cpu::mem::load64f( regs, &regs.FR28, (uint32)(regs.R11 + 0xFFFFA048) );
		/* 821108A4h case   16:*/		return 0x821108A8;
		  /* 821108A8h */ case   17:  		/* lfd FR29, <#[R10 - 24488]> */
		/* 821108A8h case   17:*/		cpu::mem::load64f( regs, &regs.FR29, (uint32)(regs.R10 + 0xFFFFA058) );
		/* 821108A8h case   17:*/		return 0x821108AC;
		  /* 821108ACh */ case   18:  		/* lfd FR31, <#[R9 + 1848]> */
		/* 821108ACh case   18:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R9 + 0x00000738) );
		/* 821108ACh case   18:*/		return 0x821108B0;
		  /* 821108B0h */ case   19:  		/* addi R19, R19, -1 */
		/* 821108B0h case   19:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0xFFFFFFFF);
		/* 821108B0h case   19:*/		return 0x821108B4;
		  /* 821108B4h */ case   20:  		/* lwz R11, <#[R17 + 24]> */
		/* 821108B4h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000018) );
		/* 821108B4h case   20:*/		return 0x821108B8;
		  /* 821108B8h */ case   21:  		/* rlwinm R18, R19, 2, 0, 29 */
		/* 821108B8h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R18,regs.R19);
		/* 821108B8h case   21:*/		return 0x821108BC;
		  /* 821108BCh */ case   22:  		/* lwzx R23, <#[R18 + R11]> */
		/* 821108BCh case   22:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R18 + regs.R11 + 0x00000000) );
		/* 821108BCh case   22:*/		return 0x821108C0;
		  /* 821108C0h */ case   23:  		/* lwz R30, <#[R23 + 12]> */
		/* 821108C0h case   23:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R23 + 0x0000000C) );
		/* 821108C0h case   23:*/		return 0x821108C4;
		  /* 821108C4h */ case   24:  		/* cmplwi CR6, R30, 0 */
		/* 821108C4h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821108C4h case   24:*/		return 0x821108C8;
		  /* 821108C8h */ case   25:  		/* bc 12, CR6_EQ, 36 */
		/* 821108C8h case   25:*/		if ( regs.CR[6].eq ) { return 0x821108EC;  }
		/* 821108C8h case   25:*/		return 0x821108CC;
		  /* 821108CCh */ case   26:  		/* lwz R11, <#[R23 + 16]> */
		/* 821108CCh case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000010) );
		/* 821108CCh case   26:*/		return 0x821108D0;
		  /* 821108D0h */ case   27:  		/* lwz R10, <#[R17 + 20]> */
		/* 821108D0h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000014) );
		/* 821108D0h case   27:*/		return 0x821108D4;
		  /* 821108D4h */ case   28:  		/* lwz R11, <#[R11]> */
		/* 821108D4h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821108D4h case   28:*/		return 0x821108D8;
		  /* 821108D8h */ case   29:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821108D8h case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821108D8h case   29:*/		return 0x821108DC;
		  /* 821108DCh */ case   30:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821108DCh case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821108DCh case   30:*/		return 0x821108E0;
		  /* 821108E0h */ case   31:  		/* lwz R11, <#[R11]> */
		/* 821108E0h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821108E0h case   31:*/		return 0x821108E4;
		  /* 821108E4h */ case   32:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 821108E4h case   32:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 821108E4h case   32:*/		return 0x821108E8;
		  /* 821108E8h */ case   33:  		/* bc 4, CR0_EQ, 2664 */
		/* 821108E8h case   33:*/		if ( !regs.CR[0].eq ) { return 0x82111350;  }
		/* 821108E8h case   33:*/		return 0x821108EC;
	}
	return 0x821108EC;
} // Block from 82110864h-821108ECh (34 instructions)

//////////////////////////////////////////////////////
// Block at 821108ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821108EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821108EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821108EC);
		  /* 821108ECh */ case    0:  		/* lwz R11, <#[R23]> */
		/* 821108ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 821108ECh case    0:*/		return 0x821108F0;
		  /* 821108F0h */ case    1:  		/* lis R10, 8256 */
		/* 821108F0h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x2040);
		/* 821108F0h case    1:*/		return 0x821108F4;
		  /* 821108F4h */ case    2:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 821108F4h case    2:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 821108F4h case    2:*/		return 0x821108F8;
		  /* 821108F8h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 821108F8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821108F8h case    3:*/		return 0x821108FC;
		  /* 821108FCh */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 821108FCh case    4:*/		if ( regs.CR[6].eq ) { return 0x8211090C;  }
		/* 821108FCh case    4:*/		return 0x82110900;
		  /* 82110900h */ case    5:  		/* lis R10, 8272 */
		/* 82110900h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x2050);
		/* 82110900h case    5:*/		return 0x82110904;
		  /* 82110904h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 82110904h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82110904h case    6:*/		return 0x82110908;
		  /* 82110908h */ case    7:  		/* bc 4, CR6_EQ, 1092 */
		/* 82110908h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82110D4C;  }
		/* 82110908h case    7:*/		return 0x8211090C;
	}
	return 0x8211090C;
} // Block from 821108ECh-8211090Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8211090Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211090C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211090C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211090C);
		  /* 8211090Ch */ case    0:  		/* cmplw CR6, R30, R14 */
		/* 8211090Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R14);
		/* 8211090Ch case    0:*/		return 0x82110910;
		  /* 82110910h */ case    1:  		/* bc 4, CR6_GT, 84 */
		/* 82110910h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82110964;  }
		/* 82110910h case    1:*/		return 0x82110914;
		  /* 82110914h */ case    2:  		/* cmplwi CR6, R30, 16 */
		/* 82110914h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000010);
		/* 82110914h case    2:*/		return 0x82110918;
		  /* 82110918h */ case    3:  		/* mr R14, R30 */
		/* 82110918h case    3:*/		regs.R14 = regs.R30;
		/* 82110918h case    3:*/		return 0x8211091C;
		  /* 8211091Ch */ case    4:  		/* bc 12, CR6_GT, 8 */
		/* 8211091Ch case    4:*/		if ( regs.CR[6].gt ) { return 0x82110924;  }
		/* 8211091Ch case    4:*/		return 0x82110920;
		  /* 82110920h */ case    5:  		/* li R14, 16 */
		/* 82110920h case    5:*/		cpu::op::li<0>(regs,&regs.R14,0x10);
		/* 82110920h case    5:*/		return 0x82110924;
	}
	return 0x82110924;
} // Block from 8211090Ch-82110924h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82110924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110924);
		  /* 82110924h */ case    0:  		/* lis R4, 9345 */
		/* 82110924h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82110924h case    0:*/		return 0x82110928;
		  /* 82110928h */ case    1:  		/* mr R3, R20 */
		/* 82110928h case    1:*/		regs.R3 = regs.R20;
		/* 82110928h case    1:*/		return 0x8211092C;
		  /* 8211092Ch */ case    2:  		/* bl -558580 */
		/* 8211092Ch case    2:*/		regs.LR = 0x82110930; return 0x82088338;
		/* 8211092Ch case    2:*/		return 0x82110930;
		  /* 82110930h */ case    3:  		/* lis R4, 9345 */
		/* 82110930h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82110930h case    3:*/		return 0x82110934;
		  /* 82110934h */ case    4:  		/* rlwinm R3, R14, 2, 0, 29 */
		/* 82110934h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R14);
		/* 82110934h case    4:*/		return 0x82110938;
		  /* 82110938h */ case    5:  		/* bl -558904 */
		/* 82110938h case    5:*/		regs.LR = 0x8211093C; return 0x82088200;
		/* 82110938h case    5:*/		return 0x8211093C;
		  /* 8211093Ch */ case    6:  		/* or. R20, R3, R3 */
		/* 8211093Ch case    6:*/		cpu::op::or<1>(regs,&regs.R20,regs.R3,regs.R3);
		/* 8211093Ch case    6:*/		return 0x82110940;
		  /* 82110940h */ case    7:  		/* bc 12, CR0_EQ, 2652 */
		/* 82110940h case    7:*/		if ( regs.CR[0].eq ) { return 0x8211139C;  }
		/* 82110940h case    7:*/		return 0x82110944;
		  /* 82110944h */ case    8:  		/* lis R4, 9345 */
		/* 82110944h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82110944h case    8:*/		return 0x82110948;
		  /* 82110948h */ case    9:  		/* mr R3, R21 */
		/* 82110948h case    9:*/		regs.R3 = regs.R21;
		/* 82110948h case    9:*/		return 0x8211094C;
		  /* 8211094Ch */ case   10:  		/* bl -558612 */
		/* 8211094Ch case   10:*/		regs.LR = 0x82110950; return 0x82088338;
		/* 8211094Ch case   10:*/		return 0x82110950;
		  /* 82110950h */ case   11:  		/* lis R4, 9345 */
		/* 82110950h case   11:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82110950h case   11:*/		return 0x82110954;
		  /* 82110954h */ case   12:  		/* rlwinm R3, R14, 3, 0, 28 */
		/* 82110954h case   12:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R3,regs.R14);
		/* 82110954h case   12:*/		return 0x82110958;
		  /* 82110958h */ case   13:  		/* bl -558936 */
		/* 82110958h case   13:*/		regs.LR = 0x8211095C; return 0x82088200;
		/* 82110958h case   13:*/		return 0x8211095C;
		  /* 8211095Ch */ case   14:  		/* or. R21, R3, R3 */
		/* 8211095Ch case   14:*/		cpu::op::or<1>(regs,&regs.R21,regs.R3,regs.R3);
		/* 8211095Ch case   14:*/		return 0x82110960;
		  /* 82110960h */ case   15:  		/* bc 12, CR0_EQ, 2620 */
		/* 82110960h case   15:*/		if ( regs.CR[0].eq ) { return 0x8211139C;  }
		/* 82110960h case   15:*/		return 0x82110964;
	}
	return 0x82110964;
} // Block from 82110924h-82110964h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82110964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110964);
		  /* 82110964h */ case    0:  		/* li R27, 0 */
		/* 82110964h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82110964h case    0:*/		return 0x82110968;
		  /* 82110968h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 82110968h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82110968h case    1:*/		return 0x8211096C;
		  /* 8211096Ch */ case    2:  		/* bc 12, CR6_EQ, 100 */
		/* 8211096Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x821109D0;  }
		/* 8211096Ch case    2:*/		return 0x82110970;
		  /* 82110970h */ case    3:  		/* li R28, 0 */
		/* 82110970h case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82110970h case    3:*/		return 0x82110974;
		  /* 82110974h */ case    4:  		/* mr R31, R20 */
		/* 82110974h case    4:*/		regs.R31 = regs.R20;
		/* 82110974h case    4:*/		return 0x82110978;
		  /* 82110978h */ case    5:  		/* mr R29, R21 */
		/* 82110978h case    5:*/		regs.R29 = regs.R21;
		/* 82110978h case    5:*/		return 0x8211097C;
		  /* 8211097Ch */ case    6:  		/* stw R24, <#[R31]> */
		/* 8211097Ch case    6:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000000) );
		/* 8211097Ch case    6:*/		return 0x82110980;
		  /* 82110980h */ case    7:  		/* stfd FR31, <#[R29]> */
		/* 82110980h case    7:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R29 + 0x00000000) );
		/* 82110980h case    7:*/		return 0x82110984;
		  /* 82110984h */ case    8:  		/* mr R6, R29 */
		/* 82110984h case    8:*/		regs.R6 = regs.R29;
		/* 82110984h case    8:*/		return 0x82110988;
		  /* 82110988h */ case    9:  		/* lwz R11, <#[R23 + 16]> */
		/* 82110988h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000010) );
		/* 82110988h case    9:*/		return 0x8211098C;
		  /* 8211098Ch */ case   10:  		/* mr R5, R31 */
		/* 8211098Ch case   10:*/		regs.R5 = regs.R31;
		/* 8211098Ch case   10:*/		return 0x82110990;
		  /* 82110990h */ case   11:  		/* mr R3, R17 */
		/* 82110990h case   11:*/		regs.R3 = regs.R17;
		/* 82110990h case   11:*/		return 0x82110994;
		  /* 82110994h */ case   12:  		/* lwzx R4, <#[R28 + R11]> */
		/* 82110994h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 82110994h case   12:*/		return 0x82110998;
		  /* 82110998h */ case   13:  		/* bl -74880 */
		/* 82110998h case   13:*/		regs.LR = 0x8211099C; return 0x820FE518;
		/* 82110998h case   13:*/		return 0x8211099C;
		  /* 8211099Ch */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 8211099Ch case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8211099Ch case   14:*/		return 0x821109A0;
		  /* 821109A0h */ case   15:  		/* bc 12, CR0_LT, 48 */
		/* 821109A0h case   15:*/		if ( regs.CR[0].lt ) { return 0x821109D0;  }
		/* 821109A0h case   15:*/		return 0x821109A4;
		  /* 821109A4h */ case   16:  		/* lwz R11, <#[R23 + 16]> */
		/* 821109A4h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000010) );
		/* 821109A4h case   16:*/		return 0x821109A8;
		  /* 821109A8h */ case   17:  		/* lwz R10, <#[R31]> */
		/* 821109A8h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821109A8h case   17:*/		return 0x821109AC;
		  /* 821109ACh */ case   18:  		/* lwzx R11, <#[R28 + R11]> */
		/* 821109ACh case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 821109ACh case   18:*/		return 0x821109B0;
		  /* 821109B0h */ case   19:  		/* cmplw CR6, R10, R11 */
		/* 821109B0h case   19:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821109B0h case   19:*/		return 0x821109B4;
		  /* 821109B4h */ case   20:  		/* bc 12, CR6_EQ, 28 */
		/* 821109B4h case   20:*/		if ( regs.CR[6].eq ) { return 0x821109D0;  }
		/* 821109B4h case   20:*/		return 0x821109B8;
		  /* 821109B8h */ case   21:  		/* addi R27, R27, 1 */
		/* 821109B8h case   21:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 821109B8h case   21:*/		return 0x821109BC;
		  /* 821109BCh */ case   22:  		/* addi R29, R29, 8 */
		/* 821109BCh case   22:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x8);
		/* 821109BCh case   22:*/		return 0x821109C0;
		  /* 821109C0h */ case   23:  		/* addi R28, R28, 4 */
		/* 821109C0h case   23:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 821109C0h case   23:*/		return 0x821109C4;
		  /* 821109C4h */ case   24:  		/* addi R31, R31, 4 */
		/* 821109C4h case   24:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 821109C4h case   24:*/		return 0x821109C8;
		  /* 821109C8h */ case   25:  		/* cmplw CR6, R27, R30 */
		/* 821109C8h case   25:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R30);
		/* 821109C8h case   25:*/		return 0x821109CC;
		  /* 821109CCh */ case   26:  		/* bc 12, CR6_LT, -80 */
		/* 821109CCh case   26:*/		if ( regs.CR[6].lt ) { return 0x8211097C;  }
		/* 821109CCh case   26:*/		return 0x821109D0;
	}
	return 0x821109D0;
} // Block from 82110964h-821109D0h (27 instructions)

//////////////////////////////////////////////////////
// Block at 821109D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821109D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821109D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821109D0);
		  /* 821109D0h */ case    0:  		/* cmplw CR6, R27, R30 */
		/* 821109D0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R30);
		/* 821109D0h case    0:*/		return 0x821109D4;
		  /* 821109D4h */ case    1:  		/* bc 4, CR6_EQ, 888 */
		/* 821109D4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82110D4C;  }
		/* 821109D4h case    1:*/		return 0x821109D8;
		  /* 821109D8h */ case    2:  		/* li R25, 1 */
		/* 821109D8h case    2:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 821109D8h case    2:*/		return 0x821109DC;
		  /* 821109DCh */ case    3:  		/* li R10, 0 */
		/* 821109DCh case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821109DCh case    3:*/		return 0x821109E0;
		  /* 821109E0h */ case    4:  		/* mr R8, R25 */
		/* 821109E0h case    4:*/		regs.R8 = regs.R25;
		/* 821109E0h case    4:*/		return 0x821109E4;
		  /* 821109E4h */ case    5:  		/* mr R9, R25 */
		/* 821109E4h case    5:*/		regs.R9 = regs.R25;
		/* 821109E4h case    5:*/		return 0x821109E8;
		  /* 821109E8h */ case    6:  		/* cmplwi CR6, R30, 0 */
		/* 821109E8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821109E8h case    6:*/		return 0x821109EC;
		  /* 821109ECh */ case    7:  		/* bc 12, CR6_EQ, 84 */
		/* 821109ECh case    7:*/		if ( regs.CR[6].eq ) { return 0x82110A40;  }
		/* 821109ECh case    7:*/		return 0x821109F0;
		  /* 821109F0h */ case    8:  		/* mr R11, R21 */
		/* 821109F0h case    8:*/		regs.R11 = regs.R21;
		/* 821109F0h case    8:*/		return 0x821109F4;
		  /* 821109F4h */ case    9:  		/* mtspr CTR, R30 */
		/* 821109F4h case    9:*/		regs.CTR = regs.R30;
		/* 821109F4h case    9:*/		return 0x821109F8;
		  /* 821109F8h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 821109F8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821109F8h case   10:*/		return 0x821109FC;
		  /* 821109FCh */ case   11:  		/* bc 12, CR6_EQ, 24 */
		/* 821109FCh case   11:*/		if ( regs.CR[6].eq ) { return 0x82110A14;  }
		/* 821109FCh case   11:*/		return 0x82110A00;
		  /* 82110A00h */ case   12:  		/* lfd FR0, <#[R11]> */
		/* 82110A00h case   12:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000000) );
		/* 82110A00h case   12:*/		return 0x82110A04;
		  /* 82110A04h */ case   13:  		/* lfd FR13, <#[R11 - 8]> */
		/* 82110A04h case   13:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 82110A04h case   13:*/		return 0x82110A08;
		  /* 82110A08h */ case   14:  		/* fcmpu CR6, FR0, FR13 */
		/* 82110A08h case   14:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82110A08h case   14:*/		return 0x82110A0C;
		  /* 82110A0Ch */ case   15:  		/* bc 12, CR6_EQ, 8 */
		/* 82110A0Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x82110A14;  }
		/* 82110A0Ch case   15:*/		return 0x82110A10;
		  /* 82110A10h */ case   16:  		/* li R9, 0 */
		/* 82110A10h case   16:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82110A10h case   16:*/		return 0x82110A14;
	}
	return 0x82110A14;
} // Block from 821109D0h-82110A14h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82110A14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110A14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110A14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110A14);
		  /* 82110A14h */ case    0:  		/* lfd FR0, <#[R11]> */
		/* 82110A14h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000000) );
		/* 82110A14h case    0:*/		return 0x82110A18;
		  /* 82110A18h */ case    1:  		/* fcmpu CR6, FR0, FR29 */
		/* 82110A18h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR29);
		/* 82110A18h case    1:*/		return 0x82110A1C;
		  /* 82110A1Ch */ case    2:  		/* bc 12, CR6_LT, 12 */
		/* 82110A1Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x82110A28;  }
		/* 82110A1Ch case    2:*/		return 0x82110A20;
		  /* 82110A20h */ case    3:  		/* fcmpu CR6, FR0, FR31 */
		/* 82110A20h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82110A20h case    3:*/		return 0x82110A24;
		  /* 82110A24h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 82110A24h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82110A2C;  }
		/* 82110A24h case    4:*/		return 0x82110A28;
	}
	return 0x82110A28;
} // Block from 82110A14h-82110A28h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82110A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110A28);
		  /* 82110A28h */ case    0:  		/* li R8, 0 */
		/* 82110A28h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82110A28h case    0:*/		return 0x82110A2C;
	}
	return 0x82110A2C;
} // Block from 82110A28h-82110A2Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82110A2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110A2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110A2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110A2C);
		  /* 82110A2Ch */ case    0:  		/* addi R10, R10, 1 */
		/* 82110A2Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82110A2Ch case    0:*/		return 0x82110A30;
		  /* 82110A30h */ case    1:  		/* addi R11, R11, 8 */
		/* 82110A30h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 82110A30h case    1:*/		return 0x82110A34;
		  /* 82110A34h */ case    2:  		/* bc 16, CR0_LT, -60 */
		/* 82110A34h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821109F8;  }
		/* 82110A34h case    2:*/		return 0x82110A38;
		  /* 82110A38h */ case    3:  		/* cmpwi CR6, R9, 0 */
		/* 82110A38h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 82110A38h case    3:*/		return 0x82110A3C;
		  /* 82110A3Ch */ case    4:  		/* bc 12, CR6_EQ, 456 */
		/* 82110A3Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82110C04;  }
		/* 82110A3Ch case    4:*/		return 0x82110A40;
	}
	return 0x82110A40;
} // Block from 82110A2Ch-82110A40h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82110A40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110A40);
		  /* 82110A40h */ case    0:  		/* lfd FR0, <#[R21]> */
		/* 82110A40h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R21 + 0x00000000) );
		/* 82110A40h case    0:*/		return 0x82110A44;
		  /* 82110A44h */ case    1:  		/* fcmpu CR6, FR0, FR28 */
		/* 82110A44h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR28);
		/* 82110A44h case    1:*/		return 0x82110A48;
		  /* 82110A48h */ case    2:  		/* bc 4, CR6_EQ, 176 */
		/* 82110A48h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82110AF8;  }
		/* 82110A48h case    2:*/		return 0x82110A4C;
		  /* 82110A4Ch */ case    3:  		/* rlwinm R11, R30, 0, 12, 31 */
		/* 82110A4Ch case    3:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R30);
		/* 82110A4Ch case    3:*/		return 0x82110A50;
		  /* 82110A50h */ case    4:  		/* lwz R10, <#[R23]> */
		/* 82110A50h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000000) );
		/* 82110A50h case    4:*/		return 0x82110A54;
		  /* 82110A54h */ case    5:  		/* oris R11, R11, 8256 */
		/* 82110A54h case    5:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2040);
		/* 82110A54h case    5:*/		return 0x82110A58;
		  /* 82110A58h */ case    6:  		/* cmplw CR6, R10, R11 */
		/* 82110A58h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82110A58h case    6:*/		return 0x82110A5C;
		  /* 82110A5Ch */ case    7:  		/* bc 12, CR6_EQ, 64 */
		/* 82110A5Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x82110A9C;  }
		/* 82110A5Ch case    7:*/		return 0x82110A60;
		  /* 82110A60h */ case    8:  		/* lwz R10, <#[R23 + 4]> */
		/* 82110A60h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000004) );
		/* 82110A60h case    8:*/		return 0x82110A64;
		  /* 82110A64h */ case    9:  		/* rlwinm R31, R30, 1, 0, 30 */
		/* 82110A64h case    9:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R31,regs.R30);
		/* 82110A64h case    9:*/		return 0x82110A68;
		  /* 82110A68h */ case   10:  		/* stw R11, <#[R23]> */
		/* 82110A68h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 82110A68h case   10:*/		return 0x82110A6C;
		  /* 82110A6Ch */ case   11:  		/* mr R26, R25 */
		/* 82110A6Ch case   11:*/		regs.R26 = regs.R25;
		/* 82110A6Ch case   11:*/		return 0x82110A70;
		  /* 82110A70h */ case   12:  		/* cmplw CR6, R10, R31 */
		/* 82110A70h case   12:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 82110A70h case   12:*/		return 0x82110A74;
		  /* 82110A74h */ case   13:  		/* bc 4, CR6_LT, 40 */
		/* 82110A74h case   13:*/		if ( !regs.CR[6].lt ) { return 0x82110A9C;  }
		/* 82110A74h case   13:*/		return 0x82110A78;
		  /* 82110A78h */ case   14:  		/* mr R3, R31 */
		/* 82110A78h case   14:*/		regs.R3 = regs.R31;
		/* 82110A78h case   14:*/		return 0x82110A7C;
		  /* 82110A7Ch */ case   15:  		/* bl -83236 */
		/* 82110A7Ch case   15:*/		regs.LR = 0x82110A80; return 0x820FC558;
		/* 82110A7Ch case   15:*/		return 0x82110A80;
		  /* 82110A80h */ case   16:  		/* stw R3, <#[R23 + 8]> */
		/* 82110A80h case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R23 + 0x00000008) );
		/* 82110A80h case   16:*/		return 0x82110A84;
		  /* 82110A84h */ case   17:  		/* cmplwi CR0, R3, 0 */
		/* 82110A84h case   17:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82110A84h case   17:*/		return 0x82110A88;
		  /* 82110A88h */ case   18:  		/* bc 12, CR0_EQ, 2324 */
		/* 82110A88h case   18:*/		if ( regs.CR[0].eq ) { return 0x8211139C;  }
		/* 82110A88h case   18:*/		return 0x82110A8C;
		  /* 82110A8Ch */ case   19:  		/* rlwinm R5, R31, 2, 0, 29 */
		/* 82110A8Ch case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R31);
		/* 82110A8Ch case   19:*/		return 0x82110A90;
		  /* 82110A90h */ case   20:  		/* stw R31, <#[R23 + 4]> */
		/* 82110A90h case   20:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R23 + 0x00000004) );
		/* 82110A90h case   20:*/		return 0x82110A94;
		  /* 82110A94h */ case   21:  		/* li R4, 255 */
		/* 82110A94h case   21:*/		cpu::op::li<0>(regs,&regs.R4,0xFF);
		/* 82110A94h case   21:*/		return 0x82110A98;
		  /* 82110A98h */ case   22:  		/* bl -522072 */
		/* 82110A98h case   22:*/		regs.LR = 0x82110A9C; return 0x82091340;
		/* 82110A98h case   22:*/		return 0x82110A9C;
	}
	return 0x82110A9C;
} // Block from 82110A40h-82110A9Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 82110A9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110A9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110A9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110A9C);
		  /* 82110A9Ch */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 82110A9Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82110A9Ch case    0:*/		return 0x82110AA0;
		  /* 82110AA0h */ case    1:  		/* bc 12, CR6_EQ, 684 */
		/* 82110AA0h case    1:*/		if ( regs.CR[6].eq ) { return 0x82110D4C;  }
		/* 82110AA0h case    1:*/		return 0x82110AA4;
		  /* 82110AA4h */ case    2:  		/* mtspr CTR, R30 */
		/* 82110AA4h case    2:*/		regs.CTR = regs.R30;
		/* 82110AA4h case    2:*/		return 0x82110AA8;
		  /* 82110AA8h */ case    3:  		/* li R11, 0 */
		/* 82110AA8h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82110AA8h case    3:*/		return 0x82110AAC;
		  /* 82110AACh */ case    4:  		/* rlwinm R8, R30, 2, 0, 29 */
		/* 82110AACh case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R30);
		/* 82110AACh case    4:*/		return 0x82110AB0;
		  /* 82110AB0h */ case    5:  		/* lwz R9, <#[R23 + 8]> */
		/* 82110AB0h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000008) );
		/* 82110AB0h case    5:*/		return 0x82110AB4;
		  /* 82110AB4h */ case    6:  		/* lwzx R10, <#[R11 + R20]> */
		/* 82110AB4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R20 + 0x00000000) );
		/* 82110AB4h case    6:*/		return 0x82110AB8;
		  /* 82110AB8h */ case    7:  		/* lwzx R7, <#[R11 + R9]> */
		/* 82110AB8h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82110AB8h case    7:*/		return 0x82110ABC;
		  /* 82110ABCh */ case    8:  		/* cmplw CR6, R7, R10 */
		/* 82110ABCh case    8:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 82110ABCh case    8:*/		return 0x82110AC0;
		  /* 82110AC0h */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 82110AC0h case    9:*/		if ( regs.CR[6].eq ) { return 0x82110ACC;  }
		/* 82110AC0h case    9:*/		return 0x82110AC4;
		  /* 82110AC4h */ case   10:  		/* stwx R10, <#[R11 + R9]> */
		/* 82110AC4h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82110AC4h case   10:*/		return 0x82110AC8;
		  /* 82110AC8h */ case   11:  		/* mr R26, R25 */
		/* 82110AC8h case   11:*/		regs.R26 = regs.R25;
		/* 82110AC8h case   11:*/		return 0x82110ACC;
	}
	return 0x82110ACC;
} // Block from 82110A9Ch-82110ACCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 82110ACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110ACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110ACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110ACC);
		  /* 82110ACCh */ case    0:  		/* lwz R9, <#[R23 + 8]> */
		/* 82110ACCh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000008) );
		/* 82110ACCh case    0:*/		return 0x82110AD0;
		  /* 82110AD0h */ case    1:  		/* lwzx R10, <#[R11 + R20]> */
		/* 82110AD0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R20 + 0x00000000) );
		/* 82110AD0h case    1:*/		return 0x82110AD4;
		  /* 82110AD4h */ case    2:  		/* lwzx R7, <#[R8 + R9]> */
		/* 82110AD4h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 82110AD4h case    2:*/		return 0x82110AD8;
		  /* 82110AD8h */ case    3:  		/* cmplw CR6, R7, R10 */
		/* 82110AD8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 82110AD8h case    3:*/		return 0x82110ADC;
		  /* 82110ADCh */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 82110ADCh case    4:*/		if ( regs.CR[6].eq ) { return 0x82110AE8;  }
		/* 82110ADCh case    4:*/		return 0x82110AE0;
		  /* 82110AE0h */ case    5:  		/* stwx R10, <#[R8 + R9]> */
		/* 82110AE0h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 82110AE0h case    5:*/		return 0x82110AE4;
		  /* 82110AE4h */ case    6:  		/* mr R26, R25 */
		/* 82110AE4h case    6:*/		regs.R26 = regs.R25;
		/* 82110AE4h case    6:*/		return 0x82110AE8;
	}
	return 0x82110AE8;
} // Block from 82110ACCh-82110AE8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82110AE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110AE8);
		  /* 82110AE8h */ case    0:  		/* addi R11, R11, 4 */
		/* 82110AE8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82110AE8h case    0:*/		return 0x82110AEC;
		  /* 82110AECh */ case    1:  		/* addi R8, R8, 4 */
		/* 82110AECh case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82110AECh case    1:*/		return 0x82110AF0;
		  /* 82110AF0h */ case    2:  		/* bc 16, CR0_LT, -64 */
		/* 82110AF0h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82110AB0;  }
		/* 82110AF0h case    2:*/		return 0x82110AF4;
		  /* 82110AF4h */ case    3:  		/* b 600 */
		/* 82110AF4h case    3:*/		return 0x82110D4C;
		/* 82110AF4h case    3:*/		return 0x82110AF8;
	}
	return 0x82110AF8;
} // Block from 82110AE8h-82110AF8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82110AF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110AF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110AF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110AF8);
		  /* 82110AF8h */ case    0:  		/* fcmpu CR6, FR0, FR31 */
		/* 82110AF8h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82110AF8h case    0:*/		return 0x82110AFC;
		  /* 82110AFCh */ case    1:  		/* bc 4, CR6_EQ, 60 */
		/* 82110AFCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82110B38;  }
		/* 82110AFCh case    1:*/		return 0x82110B00;
		  /* 82110B00h */ case    2:  		/* mr R11, R30 */
		/* 82110B00h case    2:*/		regs.R11 = regs.R30;
		/* 82110B00h case    2:*/		return 0x82110B04;
		  /* 82110B04h */ case    3:  		/* stw R30, <#[R23 + 4]> */
		/* 82110B04h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R23 + 0x00000004) );
		/* 82110B04h case    3:*/		return 0x82110B08;
		  /* 82110B08h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 82110B08h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82110B08h case    4:*/		return 0x82110B0C;
		  /* 82110B0Ch */ case    5:  		/* rlwimi R11, R25, 28, 0, 11 */
		/* 82110B0Ch case    5:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R11,regs.R25);
		/* 82110B0Ch case    5:*/		return 0x82110B10;
		  /* 82110B10h */ case    6:  		/* stw R11, <#[R23]> */
		/* 82110B10h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 82110B10h case    6:*/		return 0x82110B14;
		  /* 82110B14h */ case    7:  		/* bc 12, CR6_EQ, 136 */
		/* 82110B14h case    7:*/		if ( regs.CR[6].eq ) { return 0x82110B9C;  }
		/* 82110B14h case    7:*/		return 0x82110B18;
		  /* 82110B18h */ case    8:  		/* mtspr CTR, R30 */
		/* 82110B18h case    8:*/		regs.CTR = regs.R30;
		/* 82110B18h case    8:*/		return 0x82110B1C;
		  /* 82110B1Ch */ case    9:  		/* li R11, 0 */
		/* 82110B1Ch case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82110B1Ch case    9:*/		return 0x82110B20;
		  /* 82110B20h */ case   10:  		/* lwzx R10, <#[R11 + R20]> */
		/* 82110B20h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R20 + 0x00000000) );
		/* 82110B20h case   10:*/		return 0x82110B24;
		  /* 82110B24h */ case   11:  		/* lwz R9, <#[R23 + 8]> */
		/* 82110B24h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000008) );
		/* 82110B24h case   11:*/		return 0x82110B28;
		  /* 82110B28h */ case   12:  		/* stwx R10, <#[R11 + R9]> */
		/* 82110B28h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82110B28h case   12:*/		return 0x82110B2C;
		  /* 82110B2Ch */ case   13:  		/* addi R11, R11, 4 */
		/* 82110B2Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82110B2Ch case   13:*/		return 0x82110B30;
		  /* 82110B30h */ case   14:  		/* bc 16, CR0_LT, -16 */
		/* 82110B30h case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82110B20;  }
		/* 82110B30h case   14:*/		return 0x82110B34;
		  /* 82110B34h */ case   15:  		/* b 104 */
		/* 82110B34h case   15:*/		return 0x82110B9C;
		/* 82110B34h case   15:*/		return 0x82110B38;
	}
	return 0x82110B38;
} // Block from 82110AF8h-82110B38h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82110B38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110B38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110B38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110B38);
		  /* 82110B38h */ case    0:  		/* fcmpu CR6, FR0, FR30 */
		/* 82110B38h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 82110B38h case    0:*/		return 0x82110B3C;
		  /* 82110B3Ch */ case    1:  		/* bc 4, CR6_EQ, 104 */
		/* 82110B3Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82110BA4;  }
		/* 82110B3Ch case    1:*/		return 0x82110B40;
		  /* 82110B40h */ case    2:  		/* mr R11, R30 */
		/* 82110B40h case    2:*/		regs.R11 = regs.R30;
		/* 82110B40h case    2:*/		return 0x82110B44;
		  /* 82110B44h */ case    3:  		/* stw R30, <#[R23 + 4]> */
		/* 82110B44h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R23 + 0x00000004) );
		/* 82110B44h case    3:*/		return 0x82110B48;
		  /* 82110B48h */ case    4:  		/* cmpwi CR6, R16, -1 */
		/* 82110B48h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R16,0xFFFFFFFF);
		/* 82110B48h case    4:*/		return 0x82110B4C;
		  /* 82110B4Ch */ case    5:  		/* rlwimi R11, R25, 28, 0, 11 */
		/* 82110B4Ch case    5:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R11,regs.R25);
		/* 82110B4Ch case    5:*/		return 0x82110B50;
		  /* 82110B50h */ case    6:  		/* stw R11, <#[R23]> */
		/* 82110B50h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 82110B50h case    6:*/		return 0x82110B54;
		  /* 82110B54h */ case    7:  		/* bc 4, CR6_EQ, 40 */
		/* 82110B54h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82110B7C;  }
		/* 82110B54h case    7:*/		return 0x82110B58;
		  /* 82110B58h */ case    8:  		/* li R6, 0 */
		/* 82110B58h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82110B58h case    8:*/		return 0x82110B5C;
		  /* 82110B5Ch */ case    9:  		/* lwz R4, <#[R17 + 120]> */
		/* 82110B5Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R17 + 0x00000078) );
		/* 82110B5Ch case    9:*/		return 0x82110B60;
		  /* 82110B60h */ case   10:  		/* li R5, 0 */
		/* 82110B60h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82110B60h case   10:*/		return 0x82110B64;
		  /* 82110B64h */ case   11:  		/* fmr FR1, FR30 */
		/* 82110B64h case   11:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 82110B64h case   11:*/		return 0x82110B68;
		  /* 82110B68h */ case   12:  		/* mr R3, R17 */
		/* 82110B68h case   12:*/		regs.R3 = regs.R17;
		/* 82110B68h case   12:*/		return 0x82110B6C;
		  /* 82110B6Ch */ case   13:  		/* bl -80196 */
		/* 82110B6Ch case   13:*/		regs.LR = 0x82110B70; return 0x820FD228;
		/* 82110B6Ch case   13:*/		return 0x82110B70;
		  /* 82110B70h */ case   14:  		/* mr R16, R3 */
		/* 82110B70h case   14:*/		regs.R16 = regs.R3;
		/* 82110B70h case   14:*/		return 0x82110B74;
		  /* 82110B74h */ case   15:  		/* cmpwi CR6, R3, -1 */
		/* 82110B74h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82110B74h case   15:*/		return 0x82110B78;
		  /* 82110B78h */ case   16:  		/* bc 12, CR6_EQ, 2084 */
		/* 82110B78h case   16:*/		if ( regs.CR[6].eq ) { return 0x8211139C;  }
		/* 82110B78h case   16:*/		return 0x82110B7C;
	}
	return 0x82110B7C;
} // Block from 82110B38h-82110B7Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 82110B7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110B7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110B7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110B7C);
		  /* 82110B7Ch */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 82110B7Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82110B7Ch case    0:*/		return 0x82110B80;
		  /* 82110B80h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 82110B80h case    1:*/		if ( regs.CR[6].eq ) { return 0x82110B9C;  }
		/* 82110B80h case    1:*/		return 0x82110B84;
		  /* 82110B84h */ case    2:  		/* mtspr CTR, R30 */
		/* 82110B84h case    2:*/		regs.CTR = regs.R30;
		/* 82110B84h case    2:*/		return 0x82110B88;
		  /* 82110B88h */ case    3:  		/* li R11, 0 */
		/* 82110B88h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82110B88h case    3:*/		return 0x82110B8C;
		  /* 82110B8Ch */ case    4:  		/* lwz R10, <#[R23 + 8]> */
		/* 82110B8Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000008) );
		/* 82110B8Ch case    4:*/		return 0x82110B90;
		  /* 82110B90h */ case    5:  		/* stwx R16, <#[R11 + R10]> */
		/* 82110B90h case    5:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82110B90h case    5:*/		return 0x82110B94;
		  /* 82110B94h */ case    6:  		/* addi R11, R11, 4 */
		/* 82110B94h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82110B94h case    6:*/		return 0x82110B98;
		  /* 82110B98h */ case    7:  		/* bc 16, CR0_LT, -12 */
		/* 82110B98h case    7:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82110B8C;  }
		/* 82110B98h case    7:*/		return 0x82110B9C;
	}
	return 0x82110B9C;
} // Block from 82110B7Ch-82110B9Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 82110B9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110B9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110B9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110B9C);
		  /* 82110B9Ch */ case    0:  		/* mr R26, R25 */
		/* 82110B9Ch case    0:*/		regs.R26 = regs.R25;
		/* 82110B9Ch case    0:*/		return 0x82110BA0;
		  /* 82110BA0h */ case    1:  		/* b 428 */
		/* 82110BA0h case    1:*/		return 0x82110D4C;
		/* 82110BA0h case    1:*/		return 0x82110BA4;
	}
	return 0x82110BA4;
} // Block from 82110B9Ch-82110BA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82110BA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110BA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110BA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110BA4);
		  /* 82110BA4h */ case    0:  		/* fcmpu CR6, FR0, FR29 */
		/* 82110BA4h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR29);
		/* 82110BA4h case    0:*/		return 0x82110BA8;
		  /* 82110BA8h */ case    1:  		/* bc 4, CR6_EQ, 92 */
		/* 82110BA8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82110C04;  }
		/* 82110BA8h case    1:*/		return 0x82110BAC;
		  /* 82110BACh */ case    2:  		/* rlwinm R11, R30, 0, 12, 31 */
		/* 82110BACh case    2:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R30);
		/* 82110BACh case    2:*/		return 0x82110BB0;
		  /* 82110BB0h */ case    3:  		/* lwz R10, <#[R23]> */
		/* 82110BB0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000000) );
		/* 82110BB0h case    3:*/		return 0x82110BB4;
		  /* 82110BB4h */ case    4:  		/* oris R11, R11, 4112 */
		/* 82110BB4h case    4:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1010);
		/* 82110BB4h case    4:*/		return 0x82110BB8;
		  /* 82110BB8h */ case    5:  		/* cmplw CR6, R10, R11 */
		/* 82110BB8h case    5:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82110BB8h case    5:*/		return 0x82110BBC;
		  /* 82110BBCh */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 82110BBCh case    6:*/		if ( regs.CR[6].eq ) { return 0x82110BCC;  }
		/* 82110BBCh case    6:*/		return 0x82110BC0;
		  /* 82110BC0h */ case    7:  		/* stw R11, <#[R23]> */
		/* 82110BC0h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 82110BC0h case    7:*/		return 0x82110BC4;
		  /* 82110BC4h */ case    8:  		/* mr R26, R25 */
		/* 82110BC4h case    8:*/		regs.R26 = regs.R25;
		/* 82110BC4h case    8:*/		return 0x82110BC8;
		  /* 82110BC8h */ case    9:  		/* stw R30, <#[R23 + 4]> */
		/* 82110BC8h case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R23 + 0x00000004) );
		/* 82110BC8h case    9:*/		return 0x82110BCC;
	}
	return 0x82110BCC;
} // Block from 82110BA4h-82110BCCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 82110BCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110BCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110BCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110BCC);
		  /* 82110BCCh */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 82110BCCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82110BCCh case    0:*/		return 0x82110BD0;
		  /* 82110BD0h */ case    1:  		/* bc 12, CR6_EQ, 380 */
		/* 82110BD0h case    1:*/		if ( regs.CR[6].eq ) { return 0x82110D4C;  }
		/* 82110BD0h case    1:*/		return 0x82110BD4;
		  /* 82110BD4h */ case    2:  		/* mtspr CTR, R30 */
		/* 82110BD4h case    2:*/		regs.CTR = regs.R30;
		/* 82110BD4h case    2:*/		return 0x82110BD8;
		  /* 82110BD8h */ case    3:  		/* li R11, 0 */
		/* 82110BD8h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82110BD8h case    3:*/		return 0x82110BDC;
		  /* 82110BDCh */ case    4:  		/* lwz R9, <#[R23 + 8]> */
		/* 82110BDCh case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000008) );
		/* 82110BDCh case    4:*/		return 0x82110BE0;
		  /* 82110BE0h */ case    5:  		/* lwzx R10, <#[R11 + R20]> */
		/* 82110BE0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R20 + 0x00000000) );
		/* 82110BE0h case    5:*/		return 0x82110BE4;
		  /* 82110BE4h */ case    6:  		/* lwzx R8, <#[R11 + R9]> */
		/* 82110BE4h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82110BE4h case    6:*/		return 0x82110BE8;
		  /* 82110BE8h */ case    7:  		/* cmplw CR6, R8, R10 */
		/* 82110BE8h case    7:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 82110BE8h case    7:*/		return 0x82110BEC;
		  /* 82110BECh */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 82110BECh case    8:*/		if ( regs.CR[6].eq ) { return 0x82110BF8;  }
		/* 82110BECh case    8:*/		return 0x82110BF0;
		  /* 82110BF0h */ case    9:  		/* stwx R10, <#[R11 + R9]> */
		/* 82110BF0h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82110BF0h case    9:*/		return 0x82110BF4;
		  /* 82110BF4h */ case   10:  		/* mr R26, R25 */
		/* 82110BF4h case   10:*/		regs.R26 = regs.R25;
		/* 82110BF4h case   10:*/		return 0x82110BF8;
	}
	return 0x82110BF8;
} // Block from 82110BCCh-82110BF8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82110BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110BF8);
		  /* 82110BF8h */ case    0:  		/* addi R11, R11, 4 */
		/* 82110BF8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82110BF8h case    0:*/		return 0x82110BFC;
		  /* 82110BFCh */ case    1:  		/* bc 16, CR0_LT, -32 */
		/* 82110BFCh case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82110BDC;  }
		/* 82110BFCh case    1:*/		return 0x82110C00;
		  /* 82110C00h */ case    2:  		/* b 332 */
		/* 82110C00h case    2:*/		return 0x82110D4C;
		/* 82110C00h case    2:*/		return 0x82110C04;
	}
	return 0x82110C04;
} // Block from 82110BF8h-82110C04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82110C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110C04);
		  /* 82110C04h */ case    0:  		/* lwz R11, <#[R17 + 108]> */
		/* 82110C04h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000006C) );
		/* 82110C04h case    0:*/		return 0x82110C08;
		  /* 82110C08h */ case    1:  		/* rlwinm. R11, R11, 0, 21, 21 */
		/* 82110C08h case    1:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R11,regs.R11);
		/* 82110C08h case    1:*/		return 0x82110C0C;
		  /* 82110C0Ch */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 82110C0Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x82110C18;  }
		/* 82110C0Ch case    2:*/		return 0x82110C10;
		  /* 82110C10h */ case    3:  		/* cmpwi CR6, R8, 0 */
		/* 82110C10h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 82110C10h case    3:*/		return 0x82110C14;
		  /* 82110C14h */ case    4:  		/* bc 12, CR6_EQ, 312 */
		/* 82110C14h case    4:*/		if ( regs.CR[6].eq ) { return 0x82110D4C;  }
		/* 82110C14h case    4:*/		return 0x82110C18;
	}
	return 0x82110C18;
} // Block from 82110C04h-82110C18h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82110C18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110C18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110C18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110C18);
		  /* 82110C18h */ case    0:  		/* rlwinm R11, R30, 0, 12, 31 */
		/* 82110C18h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R30);
		/* 82110C18h case    0:*/		return 0x82110C1C;
		  /* 82110C1Ch */ case    1:  		/* lwz R10, <#[R23]> */
		/* 82110C1Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000000) );
		/* 82110C1Ch case    1:*/		return 0x82110C20;
		  /* 82110C20h */ case    2:  		/* oris R11, R11, 8272 */
		/* 82110C20h case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2050);
		/* 82110C20h case    2:*/		return 0x82110C24;
		  /* 82110C24h */ case    3:  		/* cmplw CR6, R10, R11 */
		/* 82110C24h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82110C24h case    3:*/		return 0x82110C28;
		  /* 82110C28h */ case    4:  		/* bc 12, CR6_EQ, 64 */
		/* 82110C28h case    4:*/		if ( regs.CR[6].eq ) { return 0x82110C68;  }
		/* 82110C28h case    4:*/		return 0x82110C2C;
		  /* 82110C2Ch */ case    5:  		/* lwz R10, <#[R23 + 4]> */
		/* 82110C2Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000004) );
		/* 82110C2Ch case    5:*/		return 0x82110C30;
		  /* 82110C30h */ case    6:  		/* rlwinm R31, R30, 1, 0, 30 */
		/* 82110C30h case    6:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R31,regs.R30);
		/* 82110C30h case    6:*/		return 0x82110C34;
		  /* 82110C34h */ case    7:  		/* stw R11, <#[R23]> */
		/* 82110C34h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 82110C34h case    7:*/		return 0x82110C38;
		  /* 82110C38h */ case    8:  		/* mr R26, R25 */
		/* 82110C38h case    8:*/		regs.R26 = regs.R25;
		/* 82110C38h case    8:*/		return 0x82110C3C;
		  /* 82110C3Ch */ case    9:  		/* cmplw CR6, R10, R31 */
		/* 82110C3Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 82110C3Ch case    9:*/		return 0x82110C40;
		  /* 82110C40h */ case   10:  		/* bc 4, CR6_LT, 40 */
		/* 82110C40h case   10:*/		if ( !regs.CR[6].lt ) { return 0x82110C68;  }
		/* 82110C40h case   10:*/		return 0x82110C44;
		  /* 82110C44h */ case   11:  		/* mr R3, R31 */
		/* 82110C44h case   11:*/		regs.R3 = regs.R31;
		/* 82110C44h case   11:*/		return 0x82110C48;
		  /* 82110C48h */ case   12:  		/* bl -83696 */
		/* 82110C48h case   12:*/		regs.LR = 0x82110C4C; return 0x820FC558;
		/* 82110C48h case   12:*/		return 0x82110C4C;
		  /* 82110C4Ch */ case   13:  		/* stw R3, <#[R23 + 8]> */
		/* 82110C4Ch case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R23 + 0x00000008) );
		/* 82110C4Ch case   13:*/		return 0x82110C50;
		  /* 82110C50h */ case   14:  		/* cmplwi CR0, R3, 0 */
		/* 82110C50h case   14:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82110C50h case   14:*/		return 0x82110C54;
		  /* 82110C54h */ case   15:  		/* bc 12, CR0_EQ, 1864 */
		/* 82110C54h case   15:*/		if ( regs.CR[0].eq ) { return 0x8211139C;  }
		/* 82110C54h case   15:*/		return 0x82110C58;
		  /* 82110C58h */ case   16:  		/* rlwinm R5, R31, 2, 0, 29 */
		/* 82110C58h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R31);
		/* 82110C58h case   16:*/		return 0x82110C5C;
		  /* 82110C5Ch */ case   17:  		/* stw R31, <#[R23 + 4]> */
		/* 82110C5Ch case   17:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R23 + 0x00000004) );
		/* 82110C5Ch case   17:*/		return 0x82110C60;
		  /* 82110C60h */ case   18:  		/* li R4, 255 */
		/* 82110C60h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0xFF);
		/* 82110C60h case   18:*/		return 0x82110C64;
		  /* 82110C64h */ case   19:  		/* bl -522532 */
		/* 82110C64h case   19:*/		regs.LR = 0x82110C68; return 0x82091340;
		/* 82110C64h case   19:*/		return 0x82110C68;
	}
	return 0x82110C68;
} // Block from 82110C18h-82110C68h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82110C68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110C68);
		  /* 82110C68h */ case    0:  		/* li R27, 0 */
		/* 82110C68h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82110C68h case    0:*/		return 0x82110C6C;
		  /* 82110C6Ch */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 82110C6Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82110C6Ch case    1:*/		return 0x82110C70;
		  /* 82110C70h */ case    2:  		/* bc 12, CR6_EQ, 220 */
		/* 82110C70h case    2:*/		if ( regs.CR[6].eq ) { return 0x82110D4C;  }
		/* 82110C70h case    2:*/		return 0x82110C74;
		  /* 82110C74h */ case    3:  		/* li R31, 0 */
		/* 82110C74h case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82110C74h case    3:*/		return 0x82110C78;
		  /* 82110C78h */ case    4:  		/* rlwinm R29, R30, 2, 0, 29 */
		/* 82110C78h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R30);
		/* 82110C78h case    4:*/		return 0x82110C7C;
		  /* 82110C7Ch */ case    5:  		/* mr R28, R21 */
		/* 82110C7Ch case    5:*/		regs.R28 = regs.R21;
		/* 82110C7Ch case    5:*/		return 0x82110C80;
		  /* 82110C80h */ case    6:  		/* lwz R10, <#[R23 + 8]> */
		/* 82110C80h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000008) );
		/* 82110C80h case    6:*/		return 0x82110C84;
		  /* 82110C84h */ case    7:  		/* lwzx R11, <#[R31 + R20]> */
		/* 82110C84h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R20 + 0x00000000) );
		/* 82110C84h case    7:*/		return 0x82110C88;
		  /* 82110C88h */ case    8:  		/* lwzx R9, <#[R31 + R10]> */
		/* 82110C88h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 82110C88h case    8:*/		return 0x82110C8C;
		  /* 82110C8Ch */ case    9:  		/* cmplw CR6, R9, R11 */
		/* 82110C8Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82110C8Ch case    9:*/		return 0x82110C90;
		  /* 82110C90h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 82110C90h case   10:*/		if ( regs.CR[6].eq ) { return 0x82110C9C;  }
		/* 82110C90h case   10:*/		return 0x82110C94;
		  /* 82110C94h */ case   11:  		/* stwx R11, <#[R31 + R10]> */
		/* 82110C94h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 82110C94h case   11:*/		return 0x82110C98;
		  /* 82110C98h */ case   12:  		/* mr R26, R25 */
		/* 82110C98h case   12:*/		regs.R26 = regs.R25;
		/* 82110C98h case   12:*/		return 0x82110C9C;
	}
	return 0x82110C9C;
} // Block from 82110C68h-82110C9Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 82110C9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110C9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110C9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110C9C);
		  /* 82110C9Ch */ case    0:  		/* lwz R11, <#[R23 + 8]> */
		/* 82110C9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82110C9Ch case    0:*/		return 0x82110CA0;
		  /* 82110CA0h */ case    1:  		/* lwzx R11, <#[R29 + R11]> */
		/* 82110CA0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 82110CA0h case    1:*/		return 0x82110CA4;
		  /* 82110CA4h */ case    2:  		/* cmpwi CR6, R11, -1 */
		/* 82110CA4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82110CA4h case    2:*/		return 0x82110CA8;
		  /* 82110CA8h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 82110CA8h case    3:*/		if ( regs.CR[6].eq ) { return 0x82110CBC;  }
		/* 82110CA8h case    3:*/		return 0x82110CAC;
		  /* 82110CACh */ case    4:  		/* lwz R10, <#[R17 + 20]> */
		/* 82110CACh case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000014) );
		/* 82110CACh case    4:*/		return 0x82110CB0;
		  /* 82110CB0h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82110CB0h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82110CB0h case    5:*/		return 0x82110CB4;
		  /* 82110CB4h */ case    6:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82110CB4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82110CB4h case    6:*/		return 0x82110CB8;
		  /* 82110CB8h */ case    7:  		/* b 8 */
		/* 82110CB8h case    7:*/		return 0x82110CC0;
		/* 82110CB8h case    7:*/		return 0x82110CBC;
	}
	return 0x82110CBC;
} // Block from 82110C9Ch-82110CBCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 82110CBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110CBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110CBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110CBC);
		  /* 82110CBCh */ case    0:  		/* li R11, 0 */
		/* 82110CBCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82110CBCh case    0:*/		return 0x82110CC0;
	}
	return 0x82110CC0;
} // Block from 82110CBCh-82110CC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82110CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110CC0);
		  /* 82110CC0h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 82110CC0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82110CC0h case    0:*/		return 0x82110CC4;
		  /* 82110CC4h */ case    1:  		/* bc 12, CR6_EQ, 60 */
		/* 82110CC4h case    1:*/		if ( regs.CR[6].eq ) { return 0x82110D00;  }
		/* 82110CC4h case    1:*/		return 0x82110CC8;
		  /* 82110CC8h */ case    2:  		/* lwz R10, <#[R11 + 4]> */
		/* 82110CC8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82110CC8h case    2:*/		return 0x82110CCC;
		  /* 82110CCCh */ case    3:  		/* lwz R9, <#[R17 + 16]> */
		/* 82110CCCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000010) );
		/* 82110CCCh case    3:*/		return 0x82110CD0;
		  /* 82110CD0h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82110CD0h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82110CD0h case    4:*/		return 0x82110CD4;
		  /* 82110CD4h */ case    5:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82110CD4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82110CD4h case    5:*/		return 0x82110CD8;
		  /* 82110CD8h */ case    6:  		/* lwz R10, <#[R10 + 4]> */
		/* 82110CD8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82110CD8h case    6:*/		return 0x82110CDC;
		  /* 82110CDCh */ case    7:  		/* rlwinm. R10, R10, 0, 23, 23 */
		/* 82110CDCh case    7:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R10);
		/* 82110CDCh case    7:*/		return 0x82110CE0;
		  /* 82110CE0h */ case    8:  		/* bc 12, CR0_EQ, 32 */
		/* 82110CE0h case    8:*/		if ( regs.CR[0].eq ) { return 0x82110D00;  }
		/* 82110CE0h case    8:*/		return 0x82110CE4;
		  /* 82110CE4h */ case    9:  		/* lwz R10, <#[R11 + 8]> */
		/* 82110CE4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82110CE4h case    9:*/		return 0x82110CE8;
		  /* 82110CE8h */ case   10:  		/* cmpwi CR6, R10, -1 */
		/* 82110CE8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82110CE8h case   10:*/		return 0x82110CEC;
		  /* 82110CECh */ case   11:  		/* bc 4, CR6_EQ, 20 */
		/* 82110CECh case   11:*/		if ( !regs.CR[6].eq ) { return 0x82110D00;  }
		/* 82110CECh case   11:*/		return 0x82110CF0;
		  /* 82110CF0h */ case   12:  		/* lfd FR0, <#[R28]> */
		/* 82110CF0h case   12:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R28 + 0x00000000) );
		/* 82110CF0h case   12:*/		return 0x82110CF4;
		  /* 82110CF4h */ case   13:  		/* lfd FR13, <#[R11 + 32]> */
		/* 82110CF4h case   13:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 82110CF4h case   13:*/		return 0x82110CF8;
		  /* 82110CF8h */ case   14:  		/* fcmpu CR6, FR13, FR0 */
		/* 82110CF8h case   14:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 82110CF8h case   14:*/		return 0x82110CFC;
		  /* 82110CFCh */ case   15:  		/* bc 12, CR6_EQ, 56 */
		/* 82110CFCh case   15:*/		if ( regs.CR[6].eq ) { return 0x82110D34;  }
		/* 82110CFCh case   15:*/		return 0x82110D00;
	}
	return 0x82110D00;
} // Block from 82110CC0h-82110D00h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82110D00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110D00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110D00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110D00);
		  /* 82110D00h */ case    0:  		/* li R6, 0 */
		/* 82110D00h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82110D00h case    0:*/		return 0x82110D04;
		  /* 82110D04h */ case    1:  		/* lfd FR1, <#[R28]> */
		/* 82110D04h case    1:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R28 + 0x00000000) );
		/* 82110D04h case    1:*/		return 0x82110D08;
		  /* 82110D08h */ case    2:  		/* li R5, 0 */
		/* 82110D08h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82110D08h case    2:*/		return 0x82110D0C;
		  /* 82110D0Ch */ case    3:  		/* lwz R4, <#[R17 + 120]> */
		/* 82110D0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R17 + 0x00000078) );
		/* 82110D0Ch case    3:*/		return 0x82110D10;
		  /* 82110D10h */ case    4:  		/* mr R3, R17 */
		/* 82110D10h case    4:*/		regs.R3 = regs.R17;
		/* 82110D10h case    4:*/		return 0x82110D14;
		  /* 82110D14h */ case    5:  		/* bl -80620 */
		/* 82110D14h case    5:*/		regs.LR = 0x82110D18; return 0x820FD228;
		/* 82110D14h case    5:*/		return 0x82110D18;
		  /* 82110D18h */ case    6:  		/* lwz R11, <#[R23 + 8]> */
		/* 82110D18h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82110D18h case    6:*/		return 0x82110D1C;
		  /* 82110D1Ch */ case    7:  		/* stwx R3, <#[R29 + R11]> */
		/* 82110D1Ch case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 82110D1Ch case    7:*/		return 0x82110D20;
		  /* 82110D20h */ case    8:  		/* lwz R11, <#[R23 + 8]> */
		/* 82110D20h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82110D20h case    8:*/		return 0x82110D24;
		  /* 82110D24h */ case    9:  		/* lwzx R11, <#[R29 + R11]> */
		/* 82110D24h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 82110D24h case    9:*/		return 0x82110D28;
		  /* 82110D28h */ case   10:  		/* cmpwi CR6, R11, -1 */
		/* 82110D28h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82110D28h case   10:*/		return 0x82110D2C;
		  /* 82110D2Ch */ case   11:  		/* bc 12, CR6_EQ, 1648 */
		/* 82110D2Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x8211139C;  }
		/* 82110D2Ch case   11:*/		return 0x82110D30;
		  /* 82110D30h */ case   12:  		/* mr R26, R25 */
		/* 82110D30h case   12:*/		regs.R26 = regs.R25;
		/* 82110D30h case   12:*/		return 0x82110D34;
	}
	return 0x82110D34;
} // Block from 82110D00h-82110D34h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82110D34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110D34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110D34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110D34);
		  /* 82110D34h */ case    0:  		/* addi R27, R27, 1 */
		/* 82110D34h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82110D34h case    0:*/		return 0x82110D38;
		  /* 82110D38h */ case    1:  		/* addi R31, R31, 4 */
		/* 82110D38h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82110D38h case    1:*/		return 0x82110D3C;
		  /* 82110D3Ch */ case    2:  		/* addi R29, R29, 4 */
		/* 82110D3Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82110D3Ch case    2:*/		return 0x82110D40;
		  /* 82110D40h */ case    3:  		/* addi R28, R28, 8 */
		/* 82110D40h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x8);
		/* 82110D40h case    3:*/		return 0x82110D44;
		  /* 82110D44h */ case    4:  		/* cmplw CR6, R27, R30 */
		/* 82110D44h case    4:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R30);
		/* 82110D44h case    4:*/		return 0x82110D48;
		  /* 82110D48h */ case    5:  		/* bc 12, CR6_LT, -200 */
		/* 82110D48h case    5:*/		if ( regs.CR[6].lt ) { return 0x82110C80;  }
		/* 82110D48h case    5:*/		return 0x82110D4C;
	}
	return 0x82110D4C;
} // Block from 82110D34h-82110D4Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82110D4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110D4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110D4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110D4C);
		  /* 82110D4Ch */ case    0:  		/* lwz R11, <#[R23]> */
		/* 82110D4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 82110D4Ch case    0:*/		return 0x82110D50;
		  /* 82110D50h */ case    1:  		/* lis R10, 8272 */
		/* 82110D50h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x2050);
		/* 82110D50h case    1:*/		return 0x82110D54;
		  /* 82110D54h */ case    2:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82110D54h case    2:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82110D54h case    2:*/		return 0x82110D58;
		  /* 82110D58h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 82110D58h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82110D58h case    3:*/		return 0x82110D5C;
		  /* 82110D5Ch */ case    4:  		/* bc 4, CR6_EQ, 1524 */
		/* 82110D5Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x82111350;  }
		/* 82110D5Ch case    4:*/		return 0x82110D60;
		  /* 82110D60h */ case    5:  		/* lwz R25, <#[R23 + 12]> */
		/* 82110D60h case    5:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R23 + 0x0000000C) );
		/* 82110D60h case    5:*/		return 0x82110D64;
		  /* 82110D64h */ case    6:  		/* li R22, 0 */
		/* 82110D64h case    6:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 82110D64h case    6:*/		return 0x82110D68;
		  /* 82110D68h */ case    7:  		/* li R29, 0 */
		/* 82110D68h case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82110D68h case    7:*/		return 0x82110D6C;
		  /* 82110D6Ch */ case    8:  		/* li R31, 0 */
		/* 82110D6Ch case    8:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82110D6Ch case    8:*/		return 0x82110D70;
		  /* 82110D70h */ case    9:  		/* cmplwi CR6, R25, 0 */
		/* 82110D70h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82110D70h case    9:*/		return 0x82110D74;
		  /* 82110D74h */ case   10:  		/* bc 12, CR6_EQ, 444 */
		/* 82110D74h case   10:*/		if ( regs.CR[6].eq ) { return 0x82110F30;  }
		/* 82110D74h case   10:*/		return 0x82110D78;
		  /* 82110D78h */ case   11:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 82110D78h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 82110D78h case   11:*/		return 0x82110D7C;
		  /* 82110D7Ch */ case   12:  		/* stw R24, <#[R1 + 80]> */
		/* 82110D7Ch case   12:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000050) );
		/* 82110D7Ch case   12:*/		return 0x82110D80;
		  /* 82110D80h */ case   13:  		/* stw R24, <#[R1 + 92]> */
		/* 82110D80h case   13:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x0000005C) );
		/* 82110D80h case   13:*/		return 0x82110D84;
		  /* 82110D84h */ case   14:  		/* addi R9, R1, 92 */
		/* 82110D84h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x5C);
		/* 82110D84h case   14:*/		return 0x82110D88;
		  /* 82110D88h */ case   15:  		/* stw R24, <#[R1 + 88]> */
		/* 82110D88h case   15:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000058) );
		/* 82110D88h case   15:*/		return 0x82110D8C;
		  /* 82110D8Ch */ case   16:  		/* add R5, R11, R20 */
		/* 82110D8Ch case   16:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R20);
		/* 82110D8Ch case   16:*/		return 0x82110D90;
		  /* 82110D90h */ case   17:  		/* stw R24, <#[R1 + 84]> */
		/* 82110D90h case   17:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000054) );
		/* 82110D90h case   17:*/		return 0x82110D94;
		  /* 82110D94h */ case   18:  		/* addi R8, R1, 84 */
		/* 82110D94h case   18:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x54);
		/* 82110D94h case   18:*/		return 0x82110D98;
		  /* 82110D98h */ case   19:  		/* addi R7, R1, 80 */
		/* 82110D98h case   19:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 82110D98h case   19:*/		return 0x82110D9C;
		  /* 82110D9Ch */ case   20:  		/* stwx R24, <#[R11 + R20]> */
		/* 82110D9Ch case   20:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + regs.R20 + 0x00000000) );
		/* 82110D9Ch case   20:*/		return 0x82110DA0;
		  /* 82110DA0h */ case   21:  		/* addi R6, R1, 88 */
		/* 82110DA0h case   21:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x58);
		/* 82110DA0h case   21:*/		return 0x82110DA4;
		  /* 82110DA4h */ case   22:  		/* mr R3, R17 */
		/* 82110DA4h case   22:*/		regs.R3 = regs.R17;
		/* 82110DA4h case   22:*/		return 0x82110DA8;
		  /* 82110DA8h */ case   23:  		/* lwz R10, <#[R23 + 16]> */
		/* 82110DA8h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000010) );
		/* 82110DA8h case   23:*/		return 0x82110DAC;
		  /* 82110DACh */ case   24:  		/* lwzx R4, <#[R11 + R10]> */
		/* 82110DACh case   24:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82110DACh case   24:*/		return 0x82110DB0;
		  /* 82110DB0h */ case   25:  		/* bl -75040 */
		/* 82110DB0h case   25:*/		regs.LR = 0x82110DB4; return 0x820FE890;
		/* 82110DB0h case   25:*/		return 0x82110DB4;
		  /* 82110DB4h */ case   26:  		/* cmpwi CR0, R3, 0 */
		/* 82110DB4h case   26:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82110DB4h case   26:*/		return 0x82110DB8;
		  /* 82110DB8h */ case   27:  		/* bc 12, CR0_LT, 376 */
		/* 82110DB8h case   27:*/		if ( regs.CR[0].lt ) { return 0x82110F30;  }
		/* 82110DB8h case   27:*/		return 0x82110DBC;
		  /* 82110DBCh */ case   28:  		/* lwz R8, <#[R1 + 88]> */
		/* 82110DBCh case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000058) );
		/* 82110DBCh case   28:*/		return 0x82110DC0;
		  /* 82110DC0h */ case   29:  		/* lwz R9, <#[R1 + 80]> */
		/* 82110DC0h case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 82110DC0h case   29:*/		return 0x82110DC4;
		  /* 82110DC4h */ case   30:  		/* cmpwi CR6, R8, -1 */
		/* 82110DC4h case   30:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 82110DC4h case   30:*/		return 0x82110DC8;
		  /* 82110DC8h */ case   31:  		/* bc 12, CR6_EQ, 68 */
		/* 82110DC8h case   31:*/		if ( regs.CR[6].eq ) { return 0x82110E0C;  }
		/* 82110DC8h case   31:*/		return 0x82110DCC;
		  /* 82110DCCh */ case   32:  		/* cmpwi CR6, R9, -1 */
		/* 82110DCCh case   32:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 82110DCCh case   32:*/		return 0x82110DD0;
		  /* 82110DD0h */ case   33:  		/* bc 12, CR6_EQ, 60 */
		/* 82110DD0h case   33:*/		if ( regs.CR[6].eq ) { return 0x82110E0C;  }
		/* 82110DD0h case   33:*/		return 0x82110DD4;
		  /* 82110DD4h */ case   34:  		/* lwz R11, <#[R17 + 20]> */
		/* 82110DD4h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000014) );
		/* 82110DD4h case   34:*/		return 0x82110DD8;
		  /* 82110DD8h */ case   35:  		/* rlwinm R10, R8, 2, 0, 29 */
		/* 82110DD8h case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R8);
		/* 82110DD8h case   35:*/		return 0x82110DDC;
		  /* 82110DDCh */ case   36:  		/* rlwinm R7, R9, 2, 0, 29 */
		/* 82110DDCh case   36:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R9);
		/* 82110DDCh case   36:*/		return 0x82110DE0;
		  /* 82110DE0h */ case   37:  		/* lwzx R10, <#[R10 + R11]> */
		/* 82110DE0h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82110DE0h case   37:*/		return 0x82110DE4;
		  /* 82110DE4h */ case   38:  		/* lwzx R11, <#[R7 + R11]> */
		/* 82110DE4h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 82110DE4h case   38:*/		return 0x82110DE8;
		  /* 82110DE8h */ case   39:  		/* lfd FR0, <#[R10 + 32]> */
		/* 82110DE8h case   39:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 82110DE8h case   39:*/		return 0x82110DEC;
		  /* 82110DECh */ case   40:  		/* lfd FR13, <#[R11 + 32]> */
		/* 82110DECh case   40:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 82110DECh case   40:*/		return 0x82110DF0;
		  /* 82110DF0h */ case   41:  		/* fcmpu CR6, FR0, FR13 */
		/* 82110DF0h case   41:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82110DF0h case   41:*/		return 0x82110DF4;
		  /* 82110DF4h */ case   42:  		/* bc 12, CR6_LT, 16 */
		/* 82110DF4h case   42:*/		if ( regs.CR[6].lt ) { return 0x82110E04;  }
		/* 82110DF4h case   42:*/		return 0x82110DF8;
		  /* 82110DF8h */ case   43:  		/* mr R9, R24 */
		/* 82110DF8h case   43:*/		regs.R9 = regs.R24;
		/* 82110DF8h case   43:*/		return 0x82110DFC;
		  /* 82110DFCh */ case   44:  		/* stw R24, <#[R1 + 80]> */
		/* 82110DFCh case   44:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000050) );
		/* 82110DFCh case   44:*/		return 0x82110E00;
		  /* 82110E00h */ case   45:  		/* b 12 */
		/* 82110E00h case   45:*/		return 0x82110E0C;
		/* 82110E00h case   45:*/		return 0x82110E04;
	}
	return 0x82110E04;
} // Block from 82110D4Ch-82110E04h (46 instructions)

//////////////////////////////////////////////////////
// Block at 82110E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110E04);
		  /* 82110E04h */ case    0:  		/* mr R8, R24 */
		/* 82110E04h case    0:*/		regs.R8 = regs.R24;
		/* 82110E04h case    0:*/		return 0x82110E08;
		  /* 82110E08h */ case    1:  		/* stw R24, <#[R1 + 88]> */
		/* 82110E08h case    1:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000058) );
		/* 82110E08h case    1:*/		return 0x82110E0C;
	}
	return 0x82110E0C;
} // Block from 82110E04h-82110E0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82110E0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110E0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110E0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110E0C);
		  /* 82110E0Ch */ case    0:  		/* lwz R10, <#[R1 + 92]> */
		/* 82110E0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 82110E0Ch case    0:*/		return 0x82110E10;
		  /* 82110E10h */ case    1:  		/* lwz R11, <#[R1 + 84]> */
		/* 82110E10h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82110E10h case    1:*/		return 0x82110E14;
		  /* 82110E14h */ case    2:  		/* cmpwi CR6, R10, -1 */
		/* 82110E14h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82110E14h case    2:*/		return 0x82110E18;
		  /* 82110E18h */ case    3:  		/* bc 12, CR6_EQ, 76 */
		/* 82110E18h case    3:*/		if ( regs.CR[6].eq ) { return 0x82110E64;  }
		/* 82110E18h case    3:*/		return 0x82110E1C;
		  /* 82110E1Ch */ case    4:  		/* cmpwi CR6, R11, -1 */
		/* 82110E1Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82110E1Ch case    4:*/		return 0x82110E20;
		  /* 82110E20h */ case    5:  		/* bc 12, CR6_EQ, 60 */
		/* 82110E20h case    5:*/		if ( regs.CR[6].eq ) { return 0x82110E5C;  }
		/* 82110E20h case    5:*/		return 0x82110E24;
		  /* 82110E24h */ case    6:  		/* lwz R7, <#[R17 + 20]> */
		/* 82110E24h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R17 + 0x00000014) );
		/* 82110E24h case    6:*/		return 0x82110E28;
		  /* 82110E28h */ case    7:  		/* rlwinm R6, R10, 2, 0, 29 */
		/* 82110E28h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R10);
		/* 82110E28h case    7:*/		return 0x82110E2C;
		  /* 82110E2Ch */ case    8:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82110E2Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82110E2Ch case    8:*/		return 0x82110E30;
		  /* 82110E30h */ case    9:  		/* lwzx R6, <#[R6 + R7]> */
		/* 82110E30h case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R7 + 0x00000000) );
		/* 82110E30h case    9:*/		return 0x82110E34;
		  /* 82110E34h */ case   10:  		/* lwzx R7, <#[R5 + R7]> */
		/* 82110E34h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R5 + regs.R7 + 0x00000000) );
		/* 82110E34h case   10:*/		return 0x82110E38;
		  /* 82110E38h */ case   11:  		/* lfd FR0, <#[R6 + 32]> */
		/* 82110E38h case   11:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R6 + 0x00000020) );
		/* 82110E38h case   11:*/		return 0x82110E3C;
		  /* 82110E3Ch */ case   12:  		/* lfd FR13, <#[R7 + 32]> */
		/* 82110E3Ch case   12:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R7 + 0x00000020) );
		/* 82110E3Ch case   12:*/		return 0x82110E40;
		  /* 82110E40h */ case   13:  		/* fcmpu CR6, FR0, FR13 */
		/* 82110E40h case   13:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82110E40h case   13:*/		return 0x82110E44;
		  /* 82110E44h */ case   14:  		/* bc 12, CR6_GT, 16 */
		/* 82110E44h case   14:*/		if ( regs.CR[6].gt ) { return 0x82110E54;  }
		/* 82110E44h case   14:*/		return 0x82110E48;
		  /* 82110E48h */ case   15:  		/* mr R11, R24 */
		/* 82110E48h case   15:*/		regs.R11 = regs.R24;
		/* 82110E48h case   15:*/		return 0x82110E4C;
		  /* 82110E4Ch */ case   16:  		/* stw R24, <#[R1 + 84]> */
		/* 82110E4Ch case   16:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000054) );
		/* 82110E4Ch case   16:*/		return 0x82110E50;
		  /* 82110E50h */ case   17:  		/* b 12 */
		/* 82110E50h case   17:*/		return 0x82110E5C;
		/* 82110E50h case   17:*/		return 0x82110E54;
	}
	return 0x82110E54;
} // Block from 82110E0Ch-82110E54h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82110E54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110E54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110E54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110E54);
		  /* 82110E54h */ case    0:  		/* mr R10, R24 */
		/* 82110E54h case    0:*/		regs.R10 = regs.R24;
		/* 82110E54h case    0:*/		return 0x82110E58;
		  /* 82110E58h */ case    1:  		/* stw R24, <#[R1 + 92]> */
		/* 82110E58h case    1:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x0000005C) );
		/* 82110E58h case    1:*/		return 0x82110E5C;
	}
	return 0x82110E5C;
} // Block from 82110E54h-82110E5Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82110E5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110E5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110E5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110E5C);
		  /* 82110E5Ch */ case    0:  		/* cmpwi CR6, R10, -1 */
		/* 82110E5Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82110E5Ch case    0:*/		return 0x82110E60;
		  /* 82110E60h */ case    1:  		/* bc 4, CR6_EQ, 80 */
		/* 82110E60h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82110EB0;  }
		/* 82110E60h case    1:*/		return 0x82110E64;
	}
	return 0x82110E64;
} // Block from 82110E5Ch-82110E64h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82110E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110E64);
		  /* 82110E64h */ case    0:  		/* cmpwi CR6, R11, -1 */
		/* 82110E64h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82110E64h case    0:*/		return 0x82110E68;
		  /* 82110E68h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 82110E68h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82110E80;  }
		/* 82110E68h case    1:*/		return 0x82110E6C;
		  /* 82110E6Ch */ case    2:  		/* cmpwi CR6, R8, -1 */
		/* 82110E6Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 82110E6Ch case    2:*/		return 0x82110E70;
		  /* 82110E70h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 82110E70h case    3:*/		if ( regs.CR[6].eq ) { return 0x82110E80;  }
		/* 82110E70h case    3:*/		return 0x82110E74;
		  /* 82110E74h */ case    4:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82110E74h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82110E74h case    4:*/		return 0x82110E78;
		  /* 82110E78h */ case    5:  		/* li R10, 1 */
		/* 82110E78h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82110E78h case    5:*/		return 0x82110E7C;
		  /* 82110E7Ch */ case    6:  		/* b 108 */
		/* 82110E7Ch case    6:*/		return 0x82110EE8;
		/* 82110E7Ch case    6:*/		return 0x82110E80;
	}
	return 0x82110E80;
} // Block from 82110E64h-82110E80h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82110E80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110E80);
		  /* 82110E80h */ case    0:  		/* cmpwi CR6, R10, -1 */
		/* 82110E80h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82110E80h case    0:*/		return 0x82110E84;
		  /* 82110E84h */ case    1:  		/* bc 4, CR6_EQ, 44 */
		/* 82110E84h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82110EB0;  }
		/* 82110E84h case    1:*/		return 0x82110E88;
		  /* 82110E88h */ case    2:  		/* cmpwi CR6, R11, -1 */
		/* 82110E88h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82110E88h case    2:*/		return 0x82110E8C;
		  /* 82110E8Ch */ case    3:  		/* bc 4, CR6_EQ, 36 */
		/* 82110E8Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82110EB0;  }
		/* 82110E8Ch case    3:*/		return 0x82110E90;
		  /* 82110E90h */ case    4:  		/* cmpwi CR6, R9, -1 */
		/* 82110E90h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 82110E90h case    4:*/		return 0x82110E94;
		  /* 82110E94h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 82110E94h case    5:*/		if ( regs.CR[6].eq ) { return 0x82110EB0;  }
		/* 82110E94h case    5:*/		return 0x82110E98;
		  /* 82110E98h */ case    6:  		/* lwz R8, <#[R17 + 20]> */
		/* 82110E98h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R17 + 0x00000014) );
		/* 82110E98h case    6:*/		return 0x82110E9C;
		  /* 82110E9Ch */ case    7:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82110E9Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82110E9Ch case    7:*/		return 0x82110EA0;
		  /* 82110EA0h */ case    8:  		/* lis R11, 8240 */
		/* 82110EA0h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0x2030);
		/* 82110EA0h case    8:*/		return 0x82110EA4;
		  /* 82110EA4h */ case    9:  		/* li R10, 0 */
		/* 82110EA4h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82110EA4h case    9:*/		return 0x82110EA8;
		  /* 82110EA8h */ case   10:  		/* lwzx R9, <#[R9 + R8]> */
		/* 82110EA8h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82110EA8h case   10:*/		return 0x82110EAC;
		  /* 82110EACh */ case   11:  		/* b 72 */
		/* 82110EACh case   11:*/		return 0x82110EF4;
		/* 82110EACh case   11:*/		return 0x82110EB0;
	}
	return 0x82110EB0;
} // Block from 82110E80h-82110EB0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82110EB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110EB0);
		  /* 82110EB0h */ case    0:  		/* cmpwi CR6, R8, -1 */
		/* 82110EB0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 82110EB0h case    0:*/		return 0x82110EB4;
		  /* 82110EB4h */ case    1:  		/* bc 4, CR6_EQ, 124 */
		/* 82110EB4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82110F30;  }
		/* 82110EB4h case    1:*/		return 0x82110EB8;
		  /* 82110EB8h */ case    2:  		/* cmpwi CR6, R9, -1 */
		/* 82110EB8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 82110EB8h case    2:*/		return 0x82110EBC;
		  /* 82110EBCh */ case    3:  		/* bc 4, CR6_EQ, 116 */
		/* 82110EBCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x82110F30;  }
		/* 82110EBCh case    3:*/		return 0x82110EC0;
		  /* 82110EC0h */ case    4:  		/* cmpwi CR6, R11, -1 */
		/* 82110EC0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82110EC0h case    4:*/		return 0x82110EC4;
		  /* 82110EC4h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 82110EC4h case    5:*/		if ( regs.CR[6].eq ) { return 0x82110ED8;  }
		/* 82110EC4h case    5:*/		return 0x82110EC8;
		  /* 82110EC8h */ case    6:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 82110EC8h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 82110EC8h case    6:*/		return 0x82110ECC;
		  /* 82110ECCh */ case    7:  		/* lis R11, 8240 */
		/* 82110ECCh case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0x2030);
		/* 82110ECCh case    7:*/		return 0x82110ED0;
		  /* 82110ED0h */ case    8:  		/* li R10, 1 */
		/* 82110ED0h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82110ED0h case    8:*/		return 0x82110ED4;
		  /* 82110ED4h */ case    9:  		/* b 24 */
		/* 82110ED4h case    9:*/		return 0x82110EEC;
		/* 82110ED4h case    9:*/		return 0x82110ED8;
	}
	return 0x82110ED8;
} // Block from 82110EB0h-82110ED8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82110ED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110ED8);
		  /* 82110ED8h */ case    0:  		/* cmpwi CR6, R10, -1 */
		/* 82110ED8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82110ED8h case    0:*/		return 0x82110EDC;
		  /* 82110EDCh */ case    1:  		/* bc 12, CR6_EQ, 84 */
		/* 82110EDCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82110F30;  }
		/* 82110EDCh case    1:*/		return 0x82110EE0;
		  /* 82110EE0h */ case    2:  		/* rlwinm R8, R10, 2, 0, 29 */
		/* 82110EE0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R10);
		/* 82110EE0h case    2:*/		return 0x82110EE4;
		  /* 82110EE4h */ case    3:  		/* li R10, 0 */
		/* 82110EE4h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82110EE4h case    3:*/		return 0x82110EE8;
	}
	return 0x82110EE8;
} // Block from 82110ED8h-82110EE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82110EE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110EE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110EE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110EE8);
		  /* 82110EE8h */ case    0:  		/* lis R11, 8224 */
		/* 82110EE8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x2020);
		/* 82110EE8h case    0:*/		return 0x82110EEC;
	}
	return 0x82110EEC;
} // Block from 82110EE8h-82110EECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82110EECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110EEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110EEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110EEC);
		  /* 82110EECh */ case    0:  		/* lwz R9, <#[R17 + 20]> */
		/* 82110EECh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000014) );
		/* 82110EECh case    0:*/		return 0x82110EF0;
		  /* 82110EF0h */ case    1:  		/* lwzx R9, <#[R8 + R9]> */
		/* 82110EF0h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 82110EF0h case    1:*/		return 0x82110EF4;
	}
	return 0x82110EF4;
} // Block from 82110EECh-82110EF4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82110EF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110EF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110EF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110EF4);
		  /* 82110EF4h */ case    0:  		/* rlwinm R7, R31, 3, 0, 28 */
		/* 82110EF4h case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R7,regs.R31);
		/* 82110EF4h case    0:*/		return 0x82110EF8;
		  /* 82110EF8h */ case    1:  		/* lfd FR0, <#[R9 + 32]> */
		/* 82110EF8h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000020) );
		/* 82110EF8h case    1:*/		return 0x82110EFC;
		  /* 82110EFCh */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 82110EFCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82110EFCh case    2:*/		return 0x82110F00;
		  /* 82110F00h */ case    3:  		/* stfdx FR0, <#[R7 + R21]> */
		/* 82110F00h case    3:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R7 + regs.R21 + 0x00000000) );
		/* 82110F00h case    3:*/		return 0x82110F04;
		  /* 82110F04h */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 82110F04h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82110F14;  }
		/* 82110F04h case    4:*/		return 0x82110F08;
		  /* 82110F08h */ case    5:  		/* mr R22, R11 */
		/* 82110F08h case    5:*/		regs.R22 = regs.R11;
		/* 82110F08h case    5:*/		return 0x82110F0C;
		  /* 82110F0Ch */ case    6:  		/* mr R29, R10 */
		/* 82110F0Ch case    6:*/		regs.R29 = regs.R10;
		/* 82110F0Ch case    6:*/		return 0x82110F10;
		  /* 82110F10h */ case    7:  		/* b 20 */
		/* 82110F10h case    7:*/		return 0x82110F24;
		/* 82110F10h case    7:*/		return 0x82110F14;
	}
	return 0x82110F14;
} // Block from 82110EF4h-82110F14h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82110F14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110F14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110F14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110F14);
		  /* 82110F14h */ case    0:  		/* cmplw CR6, R11, R22 */
		/* 82110F14h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R22);
		/* 82110F14h case    0:*/		return 0x82110F18;
		  /* 82110F18h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 82110F18h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82110F30;  }
		/* 82110F18h case    1:*/		return 0x82110F1C;
		  /* 82110F1Ch */ case    2:  		/* cmpw CR6, R10, R29 */
		/* 82110F1Ch case    2:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R29);
		/* 82110F1Ch case    2:*/		return 0x82110F20;
		  /* 82110F20h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 82110F20h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82110F30;  }
		/* 82110F20h case    3:*/		return 0x82110F24;
	}
	return 0x82110F24;
} // Block from 82110F14h-82110F24h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82110F24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110F24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110F24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110F24);
		  /* 82110F24h */ case    0:  		/* addi R31, R31, 1 */
		/* 82110F24h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82110F24h case    0:*/		return 0x82110F28;
		  /* 82110F28h */ case    1:  		/* cmplw CR6, R31, R25 */
		/* 82110F28h case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R25);
		/* 82110F28h case    1:*/		return 0x82110F2C;
		  /* 82110F2Ch */ case    2:  		/* bc 12, CR6_LT, -436 */
		/* 82110F2Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x82110D78;  }
		/* 82110F2Ch case    2:*/		return 0x82110F30;
	}
	return 0x82110F30;
} // Block from 82110F24h-82110F30h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82110F30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110F30);
		  /* 82110F30h */ case    0:  		/* cmplw CR6, R31, R25 */
		/* 82110F30h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R25);
		/* 82110F30h case    0:*/		return 0x82110F34;
		  /* 82110F34h */ case    1:  		/* bc 4, CR6_EQ, 1052 */
		/* 82110F34h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82111350;  }
		/* 82110F34h case    1:*/		return 0x82110F38;
		  /* 82110F38h */ case    2:  		/* lwz R11, <#[R17 + 108]> */
		/* 82110F38h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000006C) );
		/* 82110F38h case    2:*/		return 0x82110F3C;
		  /* 82110F3Ch */ case    3:  		/* rlwinm. R11, R11, 0, 8, 8 */
		/* 82110F3Ch case    3:*/		cpu::op::rlwinm<1,0,8,8>(regs,&regs.R11,regs.R11);
		/* 82110F3Ch case    3:*/		return 0x82110F40;
		  /* 82110F40h */ case    4:  		/* bc 4, CR0_EQ, 160 */
		/* 82110F40h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82110FE0;  }
		/* 82110F40h case    4:*/		return 0x82110F44;
		  /* 82110F44h */ case    5:  		/* subfic R11, R29, 0 */
		/* 82110F44h case    5:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R29,0x0);
		/* 82110F44h case    5:*/		return 0x82110F48;
		  /* 82110F48h */ case    6:  		/* rlwimi R22, R25, 0, 12, 31 */
		/* 82110F48h case    6:*/		cpu::op::rlwimi<0,0,12,31>(regs,&regs.R22,regs.R25);
		/* 82110F48h case    6:*/		return 0x82110F4C;
		  /* 82110F4Ch */ case    7:  		/* subfe R11, R11, R11 */
		/* 82110F4Ch case    7:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82110F4Ch case    7:*/		return 0x82110F50;
		  /* 82110F50h */ case    8:  		/* addic R10, R29, -1 */
		/* 82110F50h case    8:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R29,0xFFFFFFFF);
		/* 82110F50h case    8:*/		return 0x82110F54;
		  /* 82110F54h */ case    9:  		/* stw R22, <#[R23]> */
		/* 82110F54h case    9:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R23 + 0x00000000) );
		/* 82110F54h case    9:*/		return 0x82110F58;
		  /* 82110F58h */ case   10:  		/* and R11, R11, R25 */
		/* 82110F58h case   10:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R25);
		/* 82110F58h case   10:*/		return 0x82110F5C;
		  /* 82110F5Ch */ case   11:  		/* subfe R10, R10, R10 */
		/* 82110F5Ch case   11:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82110F5Ch case   11:*/		return 0x82110F60;
		  /* 82110F60h */ case   12:  		/* li R27, 0 */
		/* 82110F60h case   12:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82110F60h case   12:*/		return 0x82110F64;
		  /* 82110F64h */ case   13:  		/* and R10, R10, R25 */
		/* 82110F64h case   13:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R25);
		/* 82110F64h case   13:*/		return 0x82110F68;
		  /* 82110F68h */ case   14:  		/* cmplwi CR6, R25, 0 */
		/* 82110F68h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82110F68h case   14:*/		return 0x82110F6C;
		  /* 82110F6Ch */ case   15:  		/* bc 12, CR6_EQ, 108 */
		/* 82110F6Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x82110FD8;  }
		/* 82110F6Ch case   15:*/		return 0x82110F70;
		  /* 82110F70h */ case   16:  		/* rlwinm R29, R11, 2, 0, 29 */
		/* 82110F70h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R11);
		/* 82110F70h case   16:*/		return 0x82110F74;
		  /* 82110F74h */ case   17:  		/* lwz R11, <#[R23 + 8]> */
		/* 82110F74h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82110F74h case   17:*/		return 0x82110F78;
		  /* 82110F78h */ case   18:  		/* rlwinm R31, R10, 2, 0, 29 */
		/* 82110F78h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R10);
		/* 82110F78h case   18:*/		return 0x82110F7C;
		  /* 82110F7Ch */ case   19:  		/* mr R28, R21 */
		/* 82110F7Ch case   19:*/		regs.R28 = regs.R21;
		/* 82110F7Ch case   19:*/		return 0x82110F80;
		  /* 82110F80h */ case   20:  		/* mr R30, R20 */
		/* 82110F80h case   20:*/		regs.R30 = regs.R20;
		/* 82110F80h case   20:*/		return 0x82110F84;
		  /* 82110F84h */ case   21:  		/* lwz R10, <#[R30]> */
		/* 82110F84h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82110F84h case   21:*/		return 0x82110F88;
		  /* 82110F88h */ case   22:  		/* li R6, 0 */
		/* 82110F88h case   22:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82110F88h case   22:*/		return 0x82110F8C;
		  /* 82110F8Ch */ case   23:  		/* li R5, 0 */
		/* 82110F8Ch case   23:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82110F8Ch case   23:*/		return 0x82110F90;
		  /* 82110F90h */ case   24:  		/* mr R3, R17 */
		/* 82110F90h case   24:*/		regs.R3 = regs.R17;
		/* 82110F90h case   24:*/		return 0x82110F94;
		  /* 82110F94h */ case   25:  		/* stwx R10, <#[R29 + R11]> */
		/* 82110F94h case   25:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 82110F94h case   25:*/		return 0x82110F98;
		  /* 82110F98h */ case   26:  		/* lwz R4, <#[R17 + 120]> */
		/* 82110F98h case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R17 + 0x00000078) );
		/* 82110F98h case   26:*/		return 0x82110F9C;
		  /* 82110F9Ch */ case   27:  		/* lfd FR1, <#[R28]> */
		/* 82110F9Ch case   27:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R28 + 0x00000000) );
		/* 82110F9Ch case   27:*/		return 0x82110FA0;
		  /* 82110FA0h */ case   28:  		/* bl -81272 */
		/* 82110FA0h case   28:*/		regs.LR = 0x82110FA4; return 0x820FD228;
		/* 82110FA0h case   28:*/		return 0x82110FA4;
		  /* 82110FA4h */ case   29:  		/* lwz R11, <#[R23 + 8]> */
		/* 82110FA4h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82110FA4h case   29:*/		return 0x82110FA8;
		  /* 82110FA8h */ case   30:  		/* stwx R3, <#[R31 + R11]> */
		/* 82110FA8h case   30:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 82110FA8h case   30:*/		return 0x82110FAC;
		  /* 82110FACh */ case   31:  		/* lwz R11, <#[R23 + 8]> */
		/* 82110FACh case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82110FACh case   31:*/		return 0x82110FB0;
		  /* 82110FB0h */ case   32:  		/* lwzx R10, <#[R31 + R11]> */
		/* 82110FB0h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 82110FB0h case   32:*/		return 0x82110FB4;
		  /* 82110FB4h */ case   33:  		/* cmpwi CR6, R10, -1 */
		/* 82110FB4h case   33:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82110FB4h case   33:*/		return 0x82110FB8;
		  /* 82110FB8h */ case   34:  		/* bc 12, CR6_EQ, 996 */
		/* 82110FB8h case   34:*/		if ( regs.CR[6].eq ) { return 0x8211139C;  }
		/* 82110FB8h case   34:*/		return 0x82110FBC;
		  /* 82110FBCh */ case   35:  		/* addi R27, R27, 1 */
		/* 82110FBCh case   35:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82110FBCh case   35:*/		return 0x82110FC0;
		  /* 82110FC0h */ case   36:  		/* addi R30, R30, 4 */
		/* 82110FC0h case   36:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82110FC0h case   36:*/		return 0x82110FC4;
		  /* 82110FC4h */ case   37:  		/* addi R29, R29, 4 */
		/* 82110FC4h case   37:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82110FC4h case   37:*/		return 0x82110FC8;
		  /* 82110FC8h */ case   38:  		/* addi R31, R31, 4 */
		/* 82110FC8h case   38:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82110FC8h case   38:*/		return 0x82110FCC;
		  /* 82110FCCh */ case   39:  		/* addi R28, R28, 8 */
		/* 82110FCCh case   39:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x8);
		/* 82110FCCh case   39:*/		return 0x82110FD0;
		  /* 82110FD0h */ case   40:  		/* cmplw CR6, R27, R25 */
		/* 82110FD0h case   40:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R25);
		/* 82110FD0h case   40:*/		return 0x82110FD4;
		  /* 82110FD4h */ case   41:  		/* bc 12, CR6_LT, -80 */
		/* 82110FD4h case   41:*/		if ( regs.CR[6].lt ) { return 0x82110F84;  }
		/* 82110FD4h case   41:*/		return 0x82110FD8;
	}
	return 0x82110FD8;
} // Block from 82110F30h-82110FD8h (42 instructions)

//////////////////////////////////////////////////////
// Block at 82110FD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110FD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110FD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110FD8);
		  /* 82110FD8h */ case    0:  		/* li R26, 1 */
		/* 82110FD8h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 82110FD8h case    0:*/		return 0x82110FDC;
		  /* 82110FDCh */ case    1:  		/* b 884 */
		/* 82110FDCh case    1:*/		return 0x82111350;
		/* 82110FDCh case    1:*/		return 0x82110FE0;
	}
	return 0x82110FE0;
} // Block from 82110FD8h-82110FE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82110FE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82110FE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82110FE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82110FE0);
		  /* 82110FE0h */ case    0:  		/* rlwinm R28, R25, 0, 12, 31 */
		/* 82110FE0h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R28,regs.R25);
		/* 82110FE0h case    0:*/		return 0x82110FE4;
		  /* 82110FE4h */ case    1:  		/* mr R6, R25 */
		/* 82110FE4h case    1:*/		regs.R6 = regs.R25;
		/* 82110FE4h case    1:*/		return 0x82110FE8;
		  /* 82110FE8h */ case    2:  		/* mr R5, R25 */
		/* 82110FE8h case    2:*/		regs.R5 = regs.R25;
		/* 82110FE8h case    2:*/		return 0x82110FEC;
		  /* 82110FECh */ case    3:  		/* oris R4, R28, 4112 */
		/* 82110FECh case    3:*/		cpu::op::oris<0>(regs,&regs.R4,regs.R28,0x1010);
		/* 82110FECh case    3:*/		return 0x82110FF0;
		  /* 82110FF0h */ case    4:  		/* mr R3, R17 */
		/* 82110FF0h case    4:*/		regs.R3 = regs.R17;
		/* 82110FF0h case    4:*/		return 0x82110FF4;
		  /* 82110FF4h */ case    5:  		/* bl -81196 */
		/* 82110FF4h case    5:*/		regs.LR = 0x82110FF8; return 0x820FD2C8;
		/* 82110FF4h case    5:*/		return 0x82110FF8;
		  /* 82110FF8h */ case    6:  		/* rlwinm R24, R25, 1, 0, 30 */
		/* 82110FF8h case    6:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R24,regs.R25);
		/* 82110FF8h case    6:*/		return 0x82110FFC;
		  /* 82110FFCh */ case    7:  		/* mr R31, R3 */
		/* 82110FFCh case    7:*/		regs.R31 = regs.R3;
		/* 82110FFCh case    7:*/		return 0x82111000;
		  /* 82111000h */ case    8:  		/* mr R6, R25 */
		/* 82111000h case    8:*/		regs.R6 = regs.R25;
		/* 82111000h case    8:*/		return 0x82111004;
		  /* 82111004h */ case    9:  		/* mr R5, R24 */
		/* 82111004h case    9:*/		regs.R5 = regs.R24;
		/* 82111004h case    9:*/		return 0x82111008;
		  /* 82111008h */ case   10:  		/* oris R4, R28, 8256 */
		/* 82111008h case   10:*/		cpu::op::oris<0>(regs,&regs.R4,regs.R28,0x2040);
		/* 82111008h case   10:*/		return 0x8211100C;
		  /* 8211100Ch */ case   11:  		/* mr R3, R17 */
		/* 8211100Ch case   11:*/		regs.R3 = regs.R17;
		/* 8211100Ch case   11:*/		return 0x82111010;
		  /* 82111010h */ case   12:  		/* bl -81224 */
		/* 82111010h case   12:*/		regs.LR = 0x82111014; return 0x820FD2C8;
		/* 82111010h case   12:*/		return 0x82111014;
		  /* 82111014h */ case   13:  		/* mr R30, R3 */
		/* 82111014h case   13:*/		regs.R30 = regs.R3;
		/* 82111014h case   13:*/		return 0x82111018;
		  /* 82111018h */ case   14:  		/* mr R6, R25 */
		/* 82111018h case   14:*/		regs.R6 = regs.R25;
		/* 82111018h case   14:*/		return 0x8211101C;
		  /* 8211101Ch */ case   15:  		/* mulli R5, R25, 3 */
		/* 8211101Ch case   15:*/		cpu::op::mulli<0>(regs,&regs.R5,regs.R25,0x3);
		/* 8211101Ch case   15:*/		return 0x82111020;
		  /* 82111020h */ case   16:  		/* oris R4, R28, 12288 */
		/* 82111020h case   16:*/		cpu::op::oris<0>(regs,&regs.R4,regs.R28,0x3000);
		/* 82111020h case   16:*/		return 0x82111024;
		  /* 82111024h */ case   17:  		/* mr R3, R17 */
		/* 82111024h case   17:*/		regs.R3 = regs.R17;
		/* 82111024h case   17:*/		return 0x82111028;
		  /* 82111028h */ case   18:  		/* bl -81248 */
		/* 82111028h case   18:*/		regs.LR = 0x8211102C; return 0x820FD2C8;
		/* 82111028h case   18:*/		return 0x8211102C;
		  /* 8211102Ch */ case   19:  		/* cmpwi CR6, R31, -1 */
		/* 8211102Ch case   19:*/		cpu::op::cmpwi<6>(regs,regs.R31,0xFFFFFFFF);
		/* 8211102Ch case   19:*/		return 0x82111030;
		  /* 82111030h */ case   20:  		/* bc 12, CR6_EQ, 876 */
		/* 82111030h case   20:*/		if ( regs.CR[6].eq ) { return 0x8211139C;  }
		/* 82111030h case   20:*/		return 0x82111034;
		  /* 82111034h */ case   21:  		/* cmpwi CR6, R30, -1 */
		/* 82111034h case   21:*/		cpu::op::cmpwi<6>(regs,regs.R30,0xFFFFFFFF);
		/* 82111034h case   21:*/		return 0x82111038;
		  /* 82111038h */ case   22:  		/* bc 12, CR6_EQ, 868 */
		/* 82111038h case   22:*/		if ( regs.CR[6].eq ) { return 0x8211139C;  }
		/* 82111038h case   22:*/		return 0x8211103C;
		  /* 8211103Ch */ case   23:  		/* cmpwi CR6, R3, -1 */
		/* 8211103Ch case   23:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8211103Ch case   23:*/		return 0x82111040;
		  /* 82111040h */ case   24:  		/* bc 12, CR6_EQ, 860 */
		/* 82111040h case   24:*/		if ( regs.CR[6].eq ) { return 0x8211139C;  }
		/* 82111040h case   24:*/		return 0x82111044;
		  /* 82111044h */ case   25:  		/* lwz R11, <#[R17 + 24]> */
		/* 82111044h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000018) );
		/* 82111044h case   25:*/		return 0x82111048;
		  /* 82111048h */ case   26:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82111048h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82111048h case   26:*/		return 0x8211104C;
		  /* 8211104Ch */ case   27:  		/* rlwinm R9, R3, 2, 0, 29 */
		/* 8211104Ch case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R3);
		/* 8211104Ch case   27:*/		return 0x82111050;
		  /* 82111050h */ case   28:  		/* rlwinm R8, R30, 2, 0, 29 */
		/* 82111050h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R30);
		/* 82111050h case   28:*/		return 0x82111054;
		  /* 82111054h */ case   29:  		/* mr R4, R23 */
		/* 82111054h case   29:*/		regs.R4 = regs.R23;
		/* 82111054h case   29:*/		return 0x82111058;
		  /* 82111058h */ case   30:  		/* lwzx R26, <#[R10 + R11]> */
		/* 82111058h case   30:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82111058h case   30:*/		return 0x8211105C;
		  /* 8211105Ch */ case   31:  		/* lwzx R27, <#[R9 + R11]> */
		/* 8211105Ch case   31:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8211105Ch case   31:*/		return 0x82111060;
		  /* 82111060h */ case   32:  		/* mr R3, R26 */
		/* 82111060h case   32:*/		regs.R3 = regs.R26;
		/* 82111060h case   32:*/		return 0x82111064;
		  /* 82111064h */ case   33:  		/* lwzx R28, <#[R8 + R11]> */
		/* 82111064h case   33:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82111064h case   33:*/		return 0x82111068;
		  /* 82111068h */ case   34:  		/* bl -86392 */
		/* 82111068h case   34:*/		regs.LR = 0x8211106C; return 0x820FBEF0;
		/* 82111068h case   34:*/		return 0x8211106C;
		  /* 8211106Ch */ case   35:  		/* mr R4, R23 */
		/* 8211106Ch case   35:*/		regs.R4 = regs.R23;
		/* 8211106Ch case   35:*/		return 0x82111070;
		  /* 82111070h */ case   36:  		/* mr R3, R28 */
		/* 82111070h case   36:*/		regs.R3 = regs.R28;
		/* 82111070h case   36:*/		return 0x82111074;
		  /* 82111074h */ case   37:  		/* bl -86404 */
		/* 82111074h case   37:*/		regs.LR = 0x82111078; return 0x820FBEF0;
		/* 82111074h case   37:*/		return 0x82111078;
		  /* 82111078h */ case   38:  		/* mr R4, R23 */
		/* 82111078h case   38:*/		regs.R4 = regs.R23;
		/* 82111078h case   38:*/		return 0x8211107C;
		  /* 8211107Ch */ case   39:  		/* mr R3, R27 */
		/* 8211107Ch case   39:*/		regs.R3 = regs.R27;
		/* 8211107Ch case   39:*/		return 0x82111080;
		  /* 82111080h */ case   40:  		/* bl -86416 */
		/* 82111080h case   40:*/		regs.LR = 0x82111084; return 0x820FBEF0;
		/* 82111080h case   40:*/		return 0x82111084;
		  /* 82111084h */ case   41:  		/* cmpwi CR6, R29, 0 */
		/* 82111084h case   41:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82111084h case   41:*/		return 0x82111088;
		  /* 82111088h */ case   42:  		/* li R29, 0 */
		/* 82111088h case   42:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82111088h case   42:*/		return 0x8211108C;
		  /* 8211108Ch */ case   43:  		/* bc 4, CR6_EQ, 104 */
		/* 8211108Ch case   43:*/		if ( !regs.CR[6].eq ) { return 0x821110F4;  }
		/* 8211108Ch case   43:*/		return 0x82111090;
		  /* 82111090h */ case   44:  		/* cmplwi CR6, R25, 0 */
		/* 82111090h case   44:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82111090h case   44:*/		return 0x82111094;
		  /* 82111094h */ case   45:  		/* bc 12, CR6_EQ, 192 */
		/* 82111094h case   45:*/		if ( regs.CR[6].eq ) { return 0x82111154;  }
		/* 82111094h case   45:*/		return 0x82111098;
		  /* 82111098h */ case   46:  		/* li R31, 0 */
		/* 82111098h case   46:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82111098h case   46:*/		return 0x8211109C;
		  /* 8211109Ch */ case   47:  		/* mr R30, R21 */
		/* 8211109Ch case   47:*/		regs.R30 = regs.R21;
		/* 8211109Ch case   47:*/		return 0x821110A0;
		  /* 821110A0h */ case   48:  		/* li R6, 0 */
		/* 821110A0h case   48:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821110A0h case   48:*/		return 0x821110A4;
		  /* 821110A4h */ case   49:  		/* lfd FR1, <#[R30]> */
		/* 821110A4h case   49:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R30 + 0x00000000) );
		/* 821110A4h case   49:*/		return 0x821110A8;
		  /* 821110A8h */ case   50:  		/* li R5, 0 */
		/* 821110A8h case   50:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821110A8h case   50:*/		return 0x821110AC;
		  /* 821110ACh */ case   51:  		/* lwz R4, <#[R17 + 120]> */
		/* 821110ACh case   51:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R17 + 0x00000078) );
		/* 821110ACh case   51:*/		return 0x821110B0;
		  /* 821110B0h */ case   52:  		/* mr R3, R17 */
		/* 821110B0h case   52:*/		regs.R3 = regs.R17;
		/* 821110B0h case   52:*/		return 0x821110B4;
		  /* 821110B4h */ case   53:  		/* bl -81548 */
		/* 821110B4h case   53:*/		regs.LR = 0x821110B8; return 0x820FD228;
		/* 821110B4h case   53:*/		return 0x821110B8;
		  /* 821110B8h */ case   54:  		/* lwz R11, <#[R26 + 8]> */
		/* 821110B8h case   54:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821110B8h case   54:*/		return 0x821110BC;
		  /* 821110BCh */ case   55:  		/* stwx R3, <#[R31 + R11]> */
		/* 821110BCh case   55:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 821110BCh case   55:*/		return 0x821110C0;
		  /* 821110C0h */ case   56:  		/* lwz R11, <#[R28 + 8]> */
		/* 821110C0h case   56:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 821110C0h case   56:*/		return 0x821110C4;
		  /* 821110C4h */ case   57:  		/* lwzx R10, <#[R31 + R20]> */
		/* 821110C4h case   57:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + regs.R20 + 0x00000000) );
		/* 821110C4h case   57:*/		return 0x821110C8;
		  /* 821110C8h */ case   58:  		/* stwx R10, <#[R31 + R11]> */
		/* 821110C8h case   58:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 821110C8h case   58:*/		return 0x821110CC;
		  /* 821110CCh */ case   59:  		/* lwz R11, <#[R26 + 8]> */
		/* 821110CCh case   59:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821110CCh case   59:*/		return 0x821110D0;
		  /* 821110D0h */ case   60:  		/* lwzx R11, <#[R31 + R11]> */
		/* 821110D0h case   60:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 821110D0h case   60:*/		return 0x821110D4;
		  /* 821110D4h */ case   61:  		/* cmpwi CR6, R11, -1 */
		/* 821110D4h case   61:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 821110D4h case   61:*/		return 0x821110D8;
		  /* 821110D8h */ case   62:  		/* bc 12, CR6_EQ, 708 */
		/* 821110D8h case   62:*/		if ( regs.CR[6].eq ) { return 0x8211139C;  }
		/* 821110D8h case   62:*/		return 0x821110DC;
		  /* 821110DCh */ case   63:  		/* addi R29, R29, 1 */
		/* 821110DCh case   63:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 821110DCh case   63:*/		return 0x821110E0;
		  /* 821110E0h */ case   64:  		/* addi R30, R30, 8 */
		/* 821110E0h case   64:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x8);
		/* 821110E0h case   64:*/		return 0x821110E4;
		  /* 821110E4h */ case   65:  		/* addi R31, R31, 4 */
		/* 821110E4h case   65:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 821110E4h case   65:*/		return 0x821110E8;
		  /* 821110E8h */ case   66:  		/* cmplw CR6, R29, R25 */
		/* 821110E8h case   66:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R25);
		/* 821110E8h case   66:*/		return 0x821110EC;
		  /* 821110ECh */ case   67:  		/* bc 12, CR6_LT, -76 */
		/* 821110ECh case   67:*/		if ( regs.CR[6].lt ) { return 0x821110A0;  }
		/* 821110ECh case   67:*/		return 0x821110F0;
		  /* 821110F0h */ case   68:  		/* b 100 */
		/* 821110F0h case   68:*/		return 0x82111154;
		/* 821110F0h case   68:*/		return 0x821110F4;
	}
	return 0x821110F4;
} // Block from 82110FE0h-821110F4h (69 instructions)

//////////////////////////////////////////////////////
// Block at 821110F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821110F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821110F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821110F4);
		  /* 821110F4h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 821110F4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 821110F4h case    0:*/		return 0x821110F8;
		  /* 821110F8h */ case    1:  		/* bc 12, CR6_EQ, 92 */
		/* 821110F8h case    1:*/		if ( regs.CR[6].eq ) { return 0x82111154;  }
		/* 821110F8h case    1:*/		return 0x821110FC;
		  /* 821110FCh */ case    2:  		/* li R31, 0 */
		/* 821110FCh case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 821110FCh case    2:*/		return 0x82111100;
		  /* 82111100h */ case    3:  		/* mr R30, R21 */
		/* 82111100h case    3:*/		regs.R30 = regs.R21;
		/* 82111100h case    3:*/		return 0x82111104;
		  /* 82111104h */ case    4:  		/* lwz R11, <#[R26 + 8]> */
		/* 82111104h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82111104h case    4:*/		return 0x82111108;
		  /* 82111108h */ case    5:  		/* li R6, 0 */
		/* 82111108h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82111108h case    5:*/		return 0x8211110C;
		  /* 8211110Ch */ case    6:  		/* lwzx R10, <#[R31 + R20]> */
		/* 8211110Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + regs.R20 + 0x00000000) );
		/* 8211110Ch case    6:*/		return 0x82111110;
		  /* 82111110h */ case    7:  		/* li R5, 0 */
		/* 82111110h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82111110h case    7:*/		return 0x82111114;
		  /* 82111114h */ case    8:  		/* mr R3, R17 */
		/* 82111114h case    8:*/		regs.R3 = regs.R17;
		/* 82111114h case    8:*/		return 0x82111118;
		  /* 82111118h */ case    9:  		/* stwx R10, <#[R31 + R11]> */
		/* 82111118h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 82111118h case    9:*/		return 0x8211111C;
		  /* 8211111Ch */ case   10:  		/* lfd FR1, <#[R30]> */
		/* 8211111Ch case   10:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R30 + 0x00000000) );
		/* 8211111Ch case   10:*/		return 0x82111120;
		  /* 82111120h */ case   11:  		/* lwz R4, <#[R17 + 120]> */
		/* 82111120h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R17 + 0x00000078) );
		/* 82111120h case   11:*/		return 0x82111124;
		  /* 82111124h */ case   12:  		/* bl -81660 */
		/* 82111124h case   12:*/		regs.LR = 0x82111128; return 0x820FD228;
		/* 82111124h case   12:*/		return 0x82111128;
		  /* 82111128h */ case   13:  		/* lwz R11, <#[R28 + 8]> */
		/* 82111128h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 82111128h case   13:*/		return 0x8211112C;
		  /* 8211112Ch */ case   14:  		/* stwx R3, <#[R31 + R11]> */
		/* 8211112Ch case   14:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8211112Ch case   14:*/		return 0x82111130;
		  /* 82111130h */ case   15:  		/* lwz R11, <#[R28 + 8]> */
		/* 82111130h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 82111130h case   15:*/		return 0x82111134;
		  /* 82111134h */ case   16:  		/* lwzx R11, <#[R31 + R11]> */
		/* 82111134h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 82111134h case   16:*/		return 0x82111138;
		  /* 82111138h */ case   17:  		/* cmpwi CR6, R11, -1 */
		/* 82111138h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82111138h case   17:*/		return 0x8211113C;
		  /* 8211113Ch */ case   18:  		/* bc 12, CR6_EQ, 608 */
		/* 8211113Ch case   18:*/		if ( regs.CR[6].eq ) { return 0x8211139C;  }
		/* 8211113Ch case   18:*/		return 0x82111140;
		  /* 82111140h */ case   19:  		/* addi R29, R29, 1 */
		/* 82111140h case   19:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82111140h case   19:*/		return 0x82111144;
		  /* 82111144h */ case   20:  		/* addi R30, R30, 8 */
		/* 82111144h case   20:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x8);
		/* 82111144h case   20:*/		return 0x82111148;
		  /* 82111148h */ case   21:  		/* addi R31, R31, 4 */
		/* 82111148h case   21:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82111148h case   21:*/		return 0x8211114C;
		  /* 8211114Ch */ case   22:  		/* cmplw CR6, R29, R25 */
		/* 8211114Ch case   22:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R25);
		/* 8211114Ch case   22:*/		return 0x82111150;
		  /* 82111150h */ case   23:  		/* bc 12, CR6_LT, -76 */
		/* 82111150h case   23:*/		if ( regs.CR[6].lt ) { return 0x82111104;  }
		/* 82111150h case   23:*/		return 0x82111154;
	}
	return 0x82111154;
} // Block from 821110F4h-82111154h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82111154h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111154( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111154) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111154);
		  /* 82111154h */ case    0:  		/* cmpwi CR6, R15, -1 */
		/* 82111154h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R15,0xFFFFFFFF);
		/* 82111154h case    0:*/		return 0x82111158;
		  /* 82111158h */ case    1:  		/* bc 4, CR6_EQ, 40 */
		/* 82111158h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82111180;  }
		/* 82111158h case    1:*/		return 0x8211115C;
		  /* 8211115Ch */ case    2:  		/* li R6, 0 */
		/* 8211115Ch case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8211115Ch case    2:*/		return 0x82111160;
		  /* 82111160h */ case    3:  		/* lwz R4, <#[R17 + 120]> */
		/* 82111160h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R17 + 0x00000078) );
		/* 82111160h case    3:*/		return 0x82111164;
		  /* 82111164h */ case    4:  		/* li R5, 0 */
		/* 82111164h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82111164h case    4:*/		return 0x82111168;
		  /* 82111168h */ case    5:  		/* fmr FR1, FR31 */
		/* 82111168h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82111168h case    5:*/		return 0x8211116C;
		  /* 8211116Ch */ case    6:  		/* mr R3, R17 */
		/* 8211116Ch case    6:*/		regs.R3 = regs.R17;
		/* 8211116Ch case    6:*/		return 0x82111170;
		  /* 82111170h */ case    7:  		/* bl -81736 */
		/* 82111170h case    7:*/		regs.LR = 0x82111174; return 0x820FD228;
		/* 82111170h case    7:*/		return 0x82111174;
		  /* 82111174h */ case    8:  		/* mr R15, R3 */
		/* 82111174h case    8:*/		regs.R15 = regs.R3;
		/* 82111174h case    8:*/		return 0x82111178;
		  /* 82111178h */ case    9:  		/* cmpwi CR6, R3, -1 */
		/* 82111178h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82111178h case    9:*/		return 0x8211117C;
		  /* 8211117Ch */ case   10:  		/* bc 12, CR6_EQ, 544 */
		/* 8211117Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x8211139C;  }
		/* 8211117Ch case   10:*/		return 0x82111180;
	}
	return 0x82111180;
} // Block from 82111154h-82111180h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82111180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111180);
		  /* 82111180h */ case    0:  		/* cmpwi CR6, R16, -1 */
		/* 82111180h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R16,0xFFFFFFFF);
		/* 82111180h case    0:*/		return 0x82111184;
		  /* 82111184h */ case    1:  		/* bc 4, CR6_EQ, 40 */
		/* 82111184h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821111AC;  }
		/* 82111184h case    1:*/		return 0x82111188;
		  /* 82111188h */ case    2:  		/* li R6, 0 */
		/* 82111188h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82111188h case    2:*/		return 0x8211118C;
		  /* 8211118Ch */ case    3:  		/* lwz R4, <#[R17 + 120]> */
		/* 8211118Ch case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R17 + 0x00000078) );
		/* 8211118Ch case    3:*/		return 0x82111190;
		  /* 82111190h */ case    4:  		/* li R5, 0 */
		/* 82111190h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82111190h case    4:*/		return 0x82111194;
		  /* 82111194h */ case    5:  		/* fmr FR1, FR30 */
		/* 82111194h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 82111194h case    5:*/		return 0x82111198;
		  /* 82111198h */ case    6:  		/* mr R3, R17 */
		/* 82111198h case    6:*/		regs.R3 = regs.R17;
		/* 82111198h case    6:*/		return 0x8211119C;
		  /* 8211119Ch */ case    7:  		/* bl -81780 */
		/* 8211119Ch case    7:*/		regs.LR = 0x821111A0; return 0x820FD228;
		/* 8211119Ch case    7:*/		return 0x821111A0;
		  /* 821111A0h */ case    8:  		/* mr R16, R3 */
		/* 821111A0h case    8:*/		regs.R16 = regs.R3;
		/* 821111A0h case    8:*/		return 0x821111A4;
		  /* 821111A4h */ case    9:  		/* cmpwi CR6, R3, -1 */
		/* 821111A4h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 821111A4h case    9:*/		return 0x821111A8;
		  /* 821111A8h */ case   10:  		/* bc 12, CR6_EQ, 500 */
		/* 821111A8h case   10:*/		if ( regs.CR[6].eq ) { return 0x8211139C;  }
		/* 821111A8h case   10:*/		return 0x821111AC;
	}
	return 0x821111AC;
} // Block from 82111180h-821111ACh (11 instructions)

//////////////////////////////////////////////////////
// Block at 821111ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821111AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821111AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821111AC);
		  /* 821111ACh */ case    0:  		/* lis R11, 8240 */
		/* 821111ACh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x2030);
		/* 821111ACh case    0:*/		return 0x821111B0;
		  /* 821111B0h */ case    1:  		/* li R10, 0 */
		/* 821111B0h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821111B0h case    1:*/		return 0x821111B4;
		  /* 821111B4h */ case    2:  		/* cmplw CR6, R22, R11 */
		/* 821111B4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 821111B4h case    2:*/		return 0x821111B8;
		  /* 821111B8h */ case    3:  		/* bc 4, CR6_EQ, 60 */
		/* 821111B8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821111F4;  }
		/* 821111B8h case    3:*/		return 0x821111BC;
		  /* 821111BCh */ case    4:  		/* cmplwi CR6, R25, 0 */
		/* 821111BCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 821111BCh case    4:*/		return 0x821111C0;
		  /* 821111C0h */ case    5:  		/* bc 12, CR6_EQ, 104 */
		/* 821111C0h case    5:*/		if ( regs.CR[6].eq ) { return 0x82111228;  }
		/* 821111C0h case    5:*/		return 0x821111C4;
		  /* 821111C4h */ case    6:  		/* mtspr CTR, R25 */
		/* 821111C4h case    6:*/		regs.CTR = regs.R25;
		/* 821111C4h case    6:*/		return 0x821111C8;
		  /* 821111C8h */ case    7:  		/* rlwinm R11, R25, 2, 0, 29 */
		/* 821111C8h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R25);
		/* 821111C8h case    7:*/		return 0x821111CC;
		  /* 821111CCh */ case    8:  		/* lwz R8, <#[R27 + 8]> */
		/* 821111CCh case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000008) );
		/* 821111CCh case    8:*/		return 0x821111D0;
		  /* 821111D0h */ case    9:  		/* add R9, R10, R24 */
		/* 821111D0h case    9:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R24);
		/* 821111D0h case    9:*/		return 0x821111D4;
		  /* 821111D4h */ case   10:  		/* addi R10, R10, 1 */
		/* 821111D4h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821111D4h case   10:*/		return 0x821111D8;
		  /* 821111D8h */ case   11:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821111D8h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821111D8h case   11:*/		return 0x821111DC;
		  /* 821111DCh */ case   12:  		/* stwx R15, <#[R8 + R11]> */
		/* 821111DCh case   12:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 821111DCh case   12:*/		return 0x821111E0;
		  /* 821111E0h */ case   13:  		/* addi R11, R11, 4 */
		/* 821111E0h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821111E0h case   13:*/		return 0x821111E4;
		  /* 821111E4h */ case   14:  		/* lwz R8, <#[R27 + 8]> */
		/* 821111E4h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000008) );
		/* 821111E4h case   14:*/		return 0x821111E8;
		  /* 821111E8h */ case   15:  		/* stwx R16, <#[R9 + R8]> */
		/* 821111E8h case   15:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 821111E8h case   15:*/		return 0x821111EC;
		  /* 821111ECh */ case   16:  		/* bc 16, CR0_LT, -32 */
		/* 821111ECh case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821111CC;  }
		/* 821111ECh case   16:*/		return 0x821111F0;
		  /* 821111F0h */ case   17:  		/* b 56 */
		/* 821111F0h case   17:*/		return 0x82111228;
		/* 821111F0h case   17:*/		return 0x821111F4;
	}
	return 0x821111F4;
} // Block from 821111ACh-821111F4h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821111F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821111F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821111F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821111F4);
		  /* 821111F4h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 821111F4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 821111F4h case    0:*/		return 0x821111F8;
		  /* 821111F8h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 821111F8h case    1:*/		if ( regs.CR[6].eq ) { return 0x82111228;  }
		/* 821111F8h case    1:*/		return 0x821111FC;
		  /* 821111FCh */ case    2:  		/* mtspr CTR, R25 */
		/* 821111FCh case    2:*/		regs.CTR = regs.R25;
		/* 821111FCh case    2:*/		return 0x82111200;
		  /* 82111200h */ case    3:  		/* rlwinm R11, R25, 2, 0, 29 */
		/* 82111200h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R25);
		/* 82111200h case    3:*/		return 0x82111204;
		  /* 82111204h */ case    4:  		/* lwz R9, <#[R27 + 8]> */
		/* 82111204h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000008) );
		/* 82111204h case    4:*/		return 0x82111208;
		  /* 82111208h */ case    5:  		/* add R8, R10, R24 */
		/* 82111208h case    5:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R24);
		/* 82111208h case    5:*/		return 0x8211120C;
		  /* 8211120Ch */ case    6:  		/* addi R10, R10, 1 */
		/* 8211120Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8211120Ch case    6:*/		return 0x82111210;
		  /* 82111210h */ case    7:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82111210h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82111210h case    7:*/		return 0x82111214;
		  /* 82111214h */ case    8:  		/* stwx R16, <#[R9 + R11]> */
		/* 82111214h case    8:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82111214h case    8:*/		return 0x82111218;
		  /* 82111218h */ case    9:  		/* addi R11, R11, 4 */
		/* 82111218h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82111218h case    9:*/		return 0x8211121C;
		  /* 8211121Ch */ case   10:  		/* lwz R9, <#[R27 + 8]> */
		/* 8211121Ch case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000008) );
		/* 8211121Ch case   10:*/		return 0x82111220;
		  /* 82111220h */ case   11:  		/* stwx R15, <#[R8 + R9]> */
		/* 82111220h case   11:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 82111220h case   11:*/		return 0x82111224;
		  /* 82111224h */ case   12:  		/* bc 16, CR0_LT, -32 */
		/* 82111224h case   12:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82111204;  }
		/* 82111224h case   12:*/		return 0x82111228;
	}
	return 0x82111228;
} // Block from 821111F4h-82111228h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82111228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111228);
		  /* 82111228h */ case    0:  		/* li R29, 0 */
		/* 82111228h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82111228h case    0:*/		return 0x8211122C;
		  /* 8211122Ch */ case    1:  		/* cmplwi CR6, R25, 0 */
		/* 8211122Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 8211122Ch case    1:*/		return 0x82111230;
		  /* 82111230h */ case    2:  		/* bc 12, CR6_EQ, 168 */
		/* 82111230h case    2:*/		if ( regs.CR[6].eq ) { return 0x821112D8;  }
		/* 82111230h case    2:*/		return 0x82111234;
		  /* 82111234h */ case    3:  		/* li R31, 0 */
		/* 82111234h case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82111234h case    3:*/		return 0x82111238;
		  /* 82111238h */ case    4:  		/* rlwinm R30, R25, 2, 0, 29 */
		/* 82111238h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R25);
		/* 82111238h case    4:*/		return 0x8211123C;
		  /* 8211123Ch */ case    5:  		/* li R6, 0 */
		/* 8211123Ch case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8211123Ch case    5:*/		return 0x82111240;
		  /* 82111240h */ case    6:  		/* lwz R4, <#[R17 + 136]> */
		/* 82111240h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R17 + 0x00000088) );
		/* 82111240h case    6:*/		return 0x82111244;
		  /* 82111244h */ case    7:  		/* li R5, 0 */
		/* 82111244h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82111244h case    7:*/		return 0x82111248;
		  /* 82111248h */ case    8:  		/* fmr FR1, FR30 */
		/* 82111248h case    8:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 82111248h case    8:*/		return 0x8211124C;
		  /* 8211124Ch */ case    9:  		/* mr R3, R17 */
		/* 8211124Ch case    9:*/		regs.R3 = regs.R17;
		/* 8211124Ch case    9:*/		return 0x82111250;
		  /* 82111250h */ case   10:  		/* bl -81960 */
		/* 82111250h case   10:*/		regs.LR = 0x82111254; return 0x820FD228;
		/* 82111250h case   10:*/		return 0x82111254;
		  /* 82111254h */ case   11:  		/* lwz R11, <#[R26 + 16]> */
		/* 82111254h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 82111254h case   11:*/		return 0x82111258;
		  /* 82111258h */ case   12:  		/* li R6, 0 */
		/* 82111258h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82111258h case   12:*/		return 0x8211125C;
		  /* 8211125Ch */ case   13:  		/* fmr FR1, FR30 */
		/* 8211125Ch case   13:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 8211125Ch case   13:*/		return 0x82111260;
		  /* 82111260h */ case   14:  		/* li R5, 0 */
		/* 82111260h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82111260h case   14:*/		return 0x82111264;
		  /* 82111264h */ case   15:  		/* stwx R3, <#[R31 + R11]> */
		/* 82111264h case   15:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 82111264h case   15:*/		return 0x82111268;
		  /* 82111268h */ case   16:  		/* mr R3, R17 */
		/* 82111268h case   16:*/		regs.R3 = regs.R17;
		/* 82111268h case   16:*/		return 0x8211126C;
		  /* 8211126Ch */ case   17:  		/* lwz R4, <#[R17 + 136]> */
		/* 8211126Ch case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R17 + 0x00000088) );
		/* 8211126Ch case   17:*/		return 0x82111270;
		  /* 82111270h */ case   18:  		/* bl -81992 */
		/* 82111270h case   18:*/		regs.LR = 0x82111274; return 0x820FD228;
		/* 82111270h case   18:*/		return 0x82111274;
		  /* 82111274h */ case   19:  		/* lwz R11, <#[R28 + 16]> */
		/* 82111274h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 82111274h case   19:*/		return 0x82111278;
		  /* 82111278h */ case   20:  		/* stwx R3, <#[R11 + R31]> */
		/* 82111278h case   20:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82111278h case   20:*/		return 0x8211127C;
		  /* 8211127Ch */ case   21:  		/* lwz R10, <#[R27 + 16]> */
		/* 8211127Ch case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000010) );
		/* 8211127Ch case   21:*/		return 0x82111280;
		  /* 82111280h */ case   22:  		/* lwz R11, <#[R23 + 16]> */
		/* 82111280h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000010) );
		/* 82111280h case   22:*/		return 0x82111284;
		  /* 82111284h */ case   23:  		/* lwzx R11, <#[R31 + R11]> */
		/* 82111284h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 82111284h case   23:*/		return 0x82111288;
		  /* 82111288h */ case   24:  		/* stwx R11, <#[R10 + R31]> */
		/* 82111288h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 82111288h case   24:*/		return 0x8211128C;
		  /* 8211128Ch */ case   25:  		/* lwz R11, <#[R26 + 16]> */
		/* 8211128Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 8211128Ch case   25:*/		return 0x82111290;
		  /* 82111290h */ case   26:  		/* lwzx R11, <#[R31 + R11]> */
		/* 82111290h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 82111290h case   26:*/		return 0x82111294;
		  /* 82111294h */ case   27:  		/* cmpwi CR6, R11, -1 */
		/* 82111294h case   27:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82111294h case   27:*/		return 0x82111298;
		  /* 82111298h */ case   28:  		/* bc 12, CR6_EQ, 260 */
		/* 82111298h case   28:*/		if ( regs.CR[6].eq ) { return 0x8211139C;  }
		/* 82111298h case   28:*/		return 0x8211129C;
		  /* 8211129Ch */ case   29:  		/* lwz R10, <#[R28 + 16]> */
		/* 8211129Ch case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000010) );
		/* 8211129Ch case   29:*/		return 0x821112A0;
		  /* 821112A0h */ case   30:  		/* lwzx R10, <#[R10 + R31]> */
		/* 821112A0h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 821112A0h case   30:*/		return 0x821112A4;
		  /* 821112A4h */ case   31:  		/* cmpwi CR6, R10, -1 */
		/* 821112A4h case   31:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 821112A4h case   31:*/		return 0x821112A8;
		  /* 821112A8h */ case   32:  		/* bc 12, CR6_EQ, 244 */
		/* 821112A8h case   32:*/		if ( regs.CR[6].eq ) { return 0x8211139C;  }
		/* 821112A8h case   32:*/		return 0x821112AC;
		  /* 821112ACh */ case   33:  		/* lwz R10, <#[R28 + 8]> */
		/* 821112ACh case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 821112ACh case   33:*/		return 0x821112B0;
		  /* 821112B0h */ case   34:  		/* addi R29, R29, 1 */
		/* 821112B0h case   34:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 821112B0h case   34:*/		return 0x821112B4;
		  /* 821112B4h */ case   35:  		/* cmplw CR6, R29, R25 */
		/* 821112B4h case   35:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R25);
		/* 821112B4h case   35:*/		return 0x821112B8;
		  /* 821112B8h */ case   36:  		/* stwx R11, <#[R10 + R30]> */
		/* 821112B8h case   36:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 821112B8h case   36:*/		return 0x821112BC;
		  /* 821112BCh */ case   37:  		/* addi R30, R30, 4 */
		/* 821112BCh case   37:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 821112BCh case   37:*/		return 0x821112C0;
		  /* 821112C0h */ case   38:  		/* lwz R10, <#[R28 + 16]> */
		/* 821112C0h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000010) );
		/* 821112C0h case   38:*/		return 0x821112C4;
		  /* 821112C4h */ case   39:  		/* lwz R11, <#[R27 + 8]> */
		/* 821112C4h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 821112C4h case   39:*/		return 0x821112C8;
		  /* 821112C8h */ case   40:  		/* lwzx R10, <#[R10 + R31]> */
		/* 821112C8h case   40:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 821112C8h case   40:*/		return 0x821112CC;
		  /* 821112CCh */ case   41:  		/* stwx R10, <#[R11 + R31]> */
		/* 821112CCh case   41:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 821112CCh case   41:*/		return 0x821112D0;
		  /* 821112D0h */ case   42:  		/* addi R31, R31, 4 */
		/* 821112D0h case   42:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 821112D0h case   42:*/		return 0x821112D4;
		  /* 821112D4h */ case   43:  		/* bc 12, CR6_LT, -152 */
		/* 821112D4h case   43:*/		if ( regs.CR[6].lt ) { return 0x8211123C;  }
		/* 821112D4h case   43:*/		return 0x821112D8;
	}
	return 0x821112D8;
} // Block from 82111228h-821112D8h (44 instructions)

//////////////////////////////////////////////////////
// Block at 821112D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821112D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821112D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821112D8);
		  /* 821112D8h */ case    0:  		/* lwz R11, <#[R17 + 12]> */
		/* 821112D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000000C) );
		/* 821112D8h case    0:*/		return 0x821112DC;
		  /* 821112DCh */ case    1:  		/* addi R11, R11, -3 */
		/* 821112DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFD);
		/* 821112DCh case    1:*/		return 0x821112E0;
		  /* 821112E0h */ case    2:  		/* cmplw CR6, R11, R19 */
		/* 821112E0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R19);
		/* 821112E0h case    2:*/		return 0x821112E4;
		  /* 821112E4h */ case    3:  		/* bc 4, CR6_GT, 40 */
		/* 821112E4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8211130C;  }
		/* 821112E4h case    3:*/		return 0x821112E8;
		  /* 821112E8h */ case    4:  		/* subf R10, R19, R11 */
		/* 821112E8h case    4:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R19,regs.R11);
		/* 821112E8h case    4:*/		return 0x821112EC;
		  /* 821112ECh */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821112ECh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821112ECh case    5:*/		return 0x821112F0;
		  /* 821112F0h */ case    6:  		/* mtspr CTR, R10 */
		/* 821112F0h case    6:*/		regs.CTR = regs.R10;
		/* 821112F0h case    6:*/		return 0x821112F4;
		  /* 821112F4h */ case    7:  		/* lwz R10, <#[R17 + 24]> */
		/* 821112F4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000018) );
		/* 821112F4h case    7:*/		return 0x821112F8;
		  /* 821112F8h */ case    8:  		/* addi R11, R11, -4 */
		/* 821112F8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821112F8h case    8:*/		return 0x821112FC;
		  /* 821112FCh */ case    9:  		/* add R9, R10, R11 */
		/* 821112FCh case    9:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 821112FCh case    9:*/		return 0x82111300;
		  /* 82111300h */ case   10:  		/* lwzx R10, <#[R10 + R11]> */
		/* 82111300h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82111300h case   10:*/		return 0x82111304;
		  /* 82111304h */ case   11:  		/* stw R10, <#[R9 + 12]> */
		/* 82111304h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x0000000C) );
		/* 82111304h case   11:*/		return 0x82111308;
		  /* 82111308h */ case   12:  		/* bc 16, CR0_LT, -20 */
		/* 82111308h case   12:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821112F4;  }
		/* 82111308h case   12:*/		return 0x8211130C;
	}
	return 0x8211130C;
} // Block from 821112D8h-8211130Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8211130Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211130C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211130C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211130C);
		  /* 8211130Ch */ case    0:  		/* lwz R11, <#[R17 + 24]> */
		/* 8211130Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000018) );
		/* 8211130Ch case    0:*/		return 0x82111310;
		  /* 82111310h */ case    1:  		/* addi R10, R19, 2 */
		/* 82111310h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R19,0x2);
		/* 82111310h case    1:*/		return 0x82111314;
		  /* 82111314h */ case    2:  		/* li R9, 1 */
		/* 82111314h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82111314h case    2:*/		return 0x82111318;
		  /* 82111318h */ case    3:  		/* add R11, R18, R11 */
		/* 82111318h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R18,regs.R11);
		/* 82111318h case    3:*/		return 0x8211131C;
		  /* 8211131Ch */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8211131Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8211131Ch case    4:*/		return 0x82111320;
		  /* 82111320h */ case    5:  		/* stw R9, <#[R1 + 80]> */
		/* 82111320h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 82111320h case    5:*/		return 0x82111324;
		  /* 82111324h */ case    6:  		/* addi R9, R19, 3 */
		/* 82111324h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R19,0x3);
		/* 82111324h case    6:*/		return 0x82111328;
		  /* 82111328h */ case    7:  		/* li R8, 0 */
		/* 82111328h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82111328h case    7:*/		return 0x8211132C;
		  /* 8211132Ch */ case    8:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8211132Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8211132Ch case    8:*/		return 0x82111330;
		  /* 82111330h */ case    9:  		/* stw R26, <#[R11 + 4]> */
		/* 82111330h case    9:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000004) );
		/* 82111330h case    9:*/		return 0x82111334;
		  /* 82111334h */ case   10:  		/* li R24, -1 */
		/* 82111334h case   10:*/		cpu::op::li<0>(regs,&regs.R24,0xFFFFFFFF);
		/* 82111334h case   10:*/		return 0x82111338;
		  /* 82111338h */ case   11:  		/* lwz R26, <#[R1 + 80]> */
		/* 82111338h case   11:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 82111338h case   11:*/		return 0x8211133C;
		  /* 8211133Ch */ case   12:  		/* lwz R11, <#[R17 + 24]> */
		/* 8211133Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000018) );
		/* 8211133Ch case   12:*/		return 0x82111340;
		  /* 82111340h */ case   13:  		/* stwx R28, <#[R10 + R11]> */
		/* 82111340h case   13:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82111340h case   13:*/		return 0x82111344;
		  /* 82111344h */ case   14:  		/* lwz R11, <#[R17 + 24]> */
		/* 82111344h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000018) );
		/* 82111344h case   14:*/		return 0x82111348;
		  /* 82111348h */ case   15:  		/* stwx R27, <#[R9 + R11]> */
		/* 82111348h case   15:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82111348h case   15:*/		return 0x8211134C;
		  /* 8211134Ch */ case   16:  		/* stw R8, <#[R23]> */
		/* 8211134Ch case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R23 + 0x00000000) );
		/* 8211134Ch case   16:*/		return 0x82111350;
	}
	return 0x82111350;
} // Block from 8211130Ch-82111350h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82111350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111350);
		  /* 82111350h */ case    0:  		/* cmplwi CR6, R19, 0 */
		/* 82111350h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 82111350h case    0:*/		return 0x82111354;
		  /* 82111354h */ case    1:  		/* bc 4, CR6_EQ, -2724 */
		/* 82111354h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821108B0;  }
		/* 82111354h case    1:*/		return 0x82111358;
		  /* 82111358h */ case    2:  		/* cmpwi CR6, R26, 0 */
		/* 82111358h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 82111358h case    2:*/		return 0x8211135C;
		  /* 8211135Ch */ case    3:  		/* bc 4, CR6_EQ, 52 */
		/* 8211135Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82111390;  }
		/* 8211135Ch case    3:*/		return 0x82111360;
	}
	return 0x82111360;
} // Block from 82111350h-82111360h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82111360h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111360);
		  /* 82111360h */ case    0:  		/* mr R3, R17 */
		/* 82111360h case    0:*/		regs.R3 = regs.R17;
		/* 82111360h case    0:*/		return 0x82111364;
		  /* 82111364h */ case    1:  		/* bl -41724 */
		/* 82111364h case    1:*/		regs.LR = 0x82111368; return 0x82107068;
		/* 82111364h case    1:*/		return 0x82111368;
		  /* 82111368h */ case    2:  		/* or. R31, R3, R3 */
		/* 82111368h case    2:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 82111368h case    2:*/		return 0x8211136C;
		  /* 8211136Ch */ case    3:  		/* bc 12, CR0_LT, 72 */
		/* 8211136Ch case    3:*/		if ( regs.CR[0].lt ) { return 0x821113B4;  }
		/* 8211136Ch case    3:*/		return 0x82111370;
		  /* 82111370h */ case    4:  		/* mr R3, R17 */
		/* 82111370h case    4:*/		regs.R3 = regs.R17;
		/* 82111370h case    4:*/		return 0x82111374;
		  /* 82111374h */ case    5:  		/* bl -63252 */
		/* 82111374h case    5:*/		regs.LR = 0x82111378; return 0x82101C60;
		/* 82111374h case    5:*/		return 0x82111378;
		  /* 82111378h */ case    6:  		/* or. R31, R3, R3 */
		/* 82111378h case    6:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 82111378h case    6:*/		return 0x8211137C;
		  /* 8211137Ch */ case    7:  		/* bc 12, CR0_LT, 56 */
		/* 8211137Ch case    7:*/		if ( regs.CR[0].lt ) { return 0x821113B4;  }
		/* 8211137Ch case    7:*/		return 0x82111380;
		  /* 82111380h */ case    8:  		/* mr R3, R17 */
		/* 82111380h case    8:*/		regs.R3 = regs.R17;
		/* 82111380h case    8:*/		return 0x82111384;
		  /* 82111384h */ case    9:  		/* bl -29140 */
		/* 82111384h case    9:*/		regs.LR = 0x82111388; return 0x8210A1B0;
		/* 82111384h case    9:*/		return 0x82111388;
		  /* 82111388h */ case   10:  		/* or. R31, R3, R3 */
		/* 82111388h case   10:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 82111388h case   10:*/		return 0x8211138C;
		  /* 8211138Ch */ case   11:  		/* bc 12, CR0_LT, 40 */
		/* 8211138Ch case   11:*/		if ( regs.CR[0].lt ) { return 0x821113B4;  }
		/* 8211138Ch case   11:*/		return 0x82111390;
	}
	return 0x82111390;
} // Block from 82111360h-82111390h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82111390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111390);
		  /* 82111390h */ case    0:  		/* cntlzw R11, R26 */
		/* 82111390h case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R26);
		/* 82111390h case    0:*/		return 0x82111394;
		  /* 82111394h */ case    1:  		/* rlwinm R31, R11, 27, 31, 31 */
		/* 82111394h case    1:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R31,regs.R11);
		/* 82111394h case    1:*/		return 0x82111398;
		  /* 82111398h */ case    2:  		/* b 28 */
		/* 82111398h case    2:*/		return 0x821113B4;
		/* 82111398h case    2:*/		return 0x8211139C;
	}
	return 0x8211139C;
} // Block from 82111390h-8211139Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8211139Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211139C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211139C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211139C);
		  /* 8211139Ch */ case    0:  		/* lis R31, -32761 */
		/* 8211139Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8007);
		/* 8211139Ch case    0:*/		return 0x821113A0;
		  /* 821113A0h */ case    1:  		/* ori R31, R31, 14 */
		/* 821113A0h case    1:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xE);
		/* 821113A0h case    1:*/		return 0x821113A4;
		  /* 821113A4h */ case    2:  		/* b 16 */
		/* 821113A4h case    2:*/		return 0x821113B4;
		/* 821113A4h case    2:*/		return 0x821113A8;
	}
	return 0x821113A8;
} // Block from 8211139Ch-821113A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821113A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821113A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821113A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821113A8);
		  /* 821113A8h */ case    0:  		/* lwz R20, <#[R1 + 92]> */
		/* 821113A8h case    0:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x0000005C) );
		/* 821113A8h case    0:*/		return 0x821113AC;
		  /* 821113ACh */ case    1:  		/* li R31, 0 */
		/* 821113ACh case    1:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 821113ACh case    1:*/		return 0x821113B0;
		  /* 821113B0h */ case    2:  		/* lwz R21, <#[R1 + 88]> */
		/* 821113B0h case    2:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000058) );
		/* 821113B0h case    2:*/		return 0x821113B4;
	}
	return 0x821113B4;
} // Block from 821113A8h-821113B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821113B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821113B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821113B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821113B4);
		  /* 821113B4h */ case    0:  		/* lis R4, 9345 */
		/* 821113B4h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 821113B4h case    0:*/		return 0x821113B8;
		  /* 821113B8h */ case    1:  		/* mr R3, R20 */
		/* 821113B8h case    1:*/		regs.R3 = regs.R20;
		/* 821113B8h case    1:*/		return 0x821113BC;
		  /* 821113BCh */ case    2:  		/* bl -561284 */
		/* 821113BCh case    2:*/		regs.LR = 0x821113C0; return 0x82088338;
		/* 821113BCh case    2:*/		return 0x821113C0;
		  /* 821113C0h */ case    3:  		/* lis R4, 9345 */
		/* 821113C0h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 821113C0h case    3:*/		return 0x821113C4;
		  /* 821113C4h */ case    4:  		/* mr R3, R21 */
		/* 821113C4h case    4:*/		regs.R3 = regs.R21;
		/* 821113C4h case    4:*/		return 0x821113C8;
		  /* 821113C8h */ case    5:  		/* bl -561296 */
		/* 821113C8h case    5:*/		regs.LR = 0x821113CC; return 0x82088338;
		/* 821113C8h case    5:*/		return 0x821113CC;
		  /* 821113CCh */ case    6:  		/* mr R3, R31 */
		/* 821113CCh case    6:*/		regs.R3 = regs.R31;
		/* 821113CCh case    6:*/		return 0x821113D0;
	}
	return 0x821113D0;
} // Block from 821113B4h-821113D0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821113D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821113D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821113D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821113D0);
		  /* 821113D0h */ case    0:  		/* addi R1, R1, 352 */
		/* 821113D0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x160);
		/* 821113D0h case    0:*/		return 0x821113D4;
		  /* 821113D4h */ case    1:  		/* addi R12, R1, -152 */
		/* 821113D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFF68);
		/* 821113D4h case    1:*/		return 0x821113D8;
		  /* 821113D8h */ case    2:  		/* bl -524148 */
		/* 821113D8h case    2:*/		regs.LR = 0x821113DC; return 0x82091464;
		/* 821113D8h case    2:*/		return 0x821113DC;
		  /* 821113DCh */ case    3:  		/* b -524652 */
		/* 821113DCh case    3:*/		return 0x82091270;
		/* 821113DCh case    3:*/		return 0x821113E0;
	}
	return 0x821113E0;
} // Block from 821113D0h-821113E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821113E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821113E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821113E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821113E0);
		  /* 821113E0h */ case    0:  		/* mfspr R12, LR */
		/* 821113E0h case    0:*/		regs.R12 = regs.LR;
		/* 821113E0h case    0:*/		return 0x821113E4;
		  /* 821113E4h */ case    1:  		/* bl -524704 */
		/* 821113E4h case    1:*/		regs.LR = 0x821113E8; return 0x82091244;
		/* 821113E4h case    1:*/		return 0x821113E8;
		  /* 821113E8h */ case    2:  		/* stfd FR30, <#[R1 - 96]> */
		/* 821113E8h case    2:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFFA0) );
		/* 821113E8h case    2:*/		return 0x821113EC;
		  /* 821113ECh */ case    3:  		/* stfd FR31, <#[R1 - 88]> */
		/* 821113ECh case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA8) );
		/* 821113ECh case    3:*/		return 0x821113F0;
		  /* 821113F0h */ case    4:  		/* stwu R1, <#[R1 - 224]> */
		/* 821113F0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 821113F0h case    4:*/		return 0x821113F4;
		  /* 821113F4h */ case    5:  		/* lwz R11, <#[R3 + 8]> */
		/* 821113F4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821113F4h case    5:*/		return 0x821113F8;
		  /* 821113F8h */ case    6:  		/* mr R31, R3 */
		/* 821113F8h case    6:*/		regs.R31 = regs.R3;
		/* 821113F8h case    6:*/		return 0x821113FC;
		  /* 821113FCh */ case    7:  		/* li R27, 0 */
		/* 821113FCh case    7:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 821113FCh case    7:*/		return 0x82111400;
		  /* 82111400h */ case    8:  		/* li R24, 0 */
		/* 82111400h case    8:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 82111400h case    8:*/		return 0x82111404;
		  /* 82111404h */ case    9:  		/* li R23, 0 */
		/* 82111404h case    9:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82111404h case    9:*/		return 0x82111408;
		  /* 82111408h */ case   10:  		/* li R26, 0 */
		/* 82111408h case   10:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82111408h case   10:*/		return 0x8211140C;
		  /* 8211140Ch */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 8211140Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8211140Ch case   11:*/		return 0x82111410;
		  /* 82111410h */ case   12:  		/* bc 4, CR6_GT, 1124 */
		/* 82111410h case   12:*/		if ( !regs.CR[6].gt ) { return 0x82111874;  }
		/* 82111410h case   12:*/		return 0x82111414;
		  /* 82111414h */ case   13:  		/* lis R11, -32256 */
		/* 82111414h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82111414h case   13:*/		return 0x82111418;
		  /* 82111418h */ case   14:  		/* lis R10, -32256 */
		/* 82111418h case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82111418h case   14:*/		return 0x8211141C;
		  /* 8211141Ch */ case   15:  		/* li R25, 0 */
		/* 8211141Ch case   15:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 8211141Ch case   15:*/		return 0x82111420;
		  /* 82111420h */ case   16:  		/* lfd FR30, <#[R11 + 4736]> */
		/* 82111420h case   16:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R11 + 0x00001280) );
		/* 82111420h case   16:*/		return 0x82111424;
		  /* 82111424h */ case   17:  		/* lfd FR31, <#[R10 + 1808]> */
		/* 82111424h case   17:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R10 + 0x00000710) );
		/* 82111424h case   17:*/		return 0x82111428;
		  /* 82111428h */ case   18:  		/* lwz R11, <#[R31 + 20]> */
		/* 82111428h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82111428h case   18:*/		return 0x8211142C;
		  /* 8211142Ch */ case   19:  		/* lwz R10, <#[R31 + 116]> */
		/* 8211142Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000074) );
		/* 8211142Ch case   19:*/		return 0x82111430;
		  /* 82111430h */ case   20:  		/* lwzx R30, <#[R11 + R25]> */
		/* 82111430h case   20:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 82111430h case   20:*/		return 0x82111434;
		  /* 82111434h */ case   21:  		/* lwz R11, <#[R30 + 4]> */
		/* 82111434h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82111434h case   21:*/		return 0x82111438;
		  /* 82111438h */ case   22:  		/* cmplw CR6, R10, R11 */
		/* 82111438h case   22:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82111438h case   22:*/		return 0x8211143C;
		  /* 8211143Ch */ case   23:  		/* bc 12, CR6_EQ, 1052 */
		/* 8211143Ch case   23:*/		if ( regs.CR[6].eq ) { return 0x82111858;  }
		/* 8211143Ch case   23:*/		return 0x82111440;
		  /* 82111440h */ case   24:  		/* lwz R11, <#[R30 + 8]> */
		/* 82111440h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82111440h case   24:*/		return 0x82111444;
		  /* 82111444h */ case   25:  		/* addi R29, R30, 8 */
		/* 82111444h case   25:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R30,0x8);
		/* 82111444h case   25:*/		return 0x82111448;
		  /* 82111448h */ case   26:  		/* cmpwi CR6, R11, -1 */
		/* 82111448h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82111448h case   26:*/		return 0x8211144C;
		  /* 8211144Ch */ case   27:  		/* bc 12, CR6_EQ, 1036 */
		/* 8211144Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x82111858;  }
		/* 8211144Ch case   27:*/		return 0x82111450;
		  /* 82111450h */ case   28:  		/* cmpwi CR6, R23, 0 */
		/* 82111450h case   28:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 82111450h case   28:*/		return 0x82111454;
		  /* 82111454h */ case   29:  		/* bc 4, CR6_EQ, 16 */
		/* 82111454h case   29:*/		if ( !regs.CR[6].eq ) { return 0x82111464;  }
		/* 82111454h case   29:*/		return 0x82111458;
		  /* 82111458h */ case   30:  		/* mr R3, R31 */
		/* 82111458h case   30:*/		regs.R3 = regs.R31;
		/* 82111458h case   30:*/		return 0x8211145C;
		  /* 8211145Ch */ case   31:  		/* bl -47300 */
		/* 8211145Ch case   31:*/		regs.LR = 0x82111460; return 0x82105B98;
		/* 8211145Ch case   31:*/		return 0x82111460;
		  /* 82111460h */ case   32:  		/* li R23, 1 */
		/* 82111460h case   32:*/		cpu::op::li<0>(regs,&regs.R23,0x1);
		/* 82111460h case   32:*/		return 0x82111464;
	}
	return 0x82111464;
} // Block from 821113E0h-82111464h (33 instructions)

//////////////////////////////////////////////////////
// Block at 82111464h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111464);
		  /* 82111464h */ case    0:  		/* lwz R28, <#[R29]> */
		/* 82111464h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x00000000) );
		/* 82111464h case    0:*/		return 0x82111468;
		  /* 82111468h */ case    1:  		/* lwz R5, <#[R31 + 20]> */
		/* 82111468h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000014) );
		/* 82111468h case    1:*/		return 0x8211146C;
		  /* 8211146Ch */ case    2:  		/* rlwinm R11, R28, 2, 0, 29 */
		/* 8211146Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R28);
		/* 8211146Ch case    2:*/		return 0x82111470;
		  /* 82111470h */ case    3:  		/* lwzx R11, <#[R11 + R5]> */
		/* 82111470h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 82111470h case    3:*/		return 0x82111474;
		  /* 82111474h */ case    4:  		/* lwz R11, <#[R11 + 72]> */
		/* 82111474h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 82111474h case    4:*/		return 0x82111478;
		  /* 82111478h */ case    5:  		/* cmpwi CR6, R11, -1 */
		/* 82111478h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82111478h case    5:*/		return 0x8211147C;
		  /* 8211147Ch */ case    6:  		/* bc 12, CR6_EQ, 104 */
		/* 8211147Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x821114E4;  }
		/* 8211147Ch case    6:*/		return 0x82111480;
		  /* 82111480h */ case    7:  		/* lwz R10, <#[R31 + 24]> */
		/* 82111480h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 82111480h case    7:*/		return 0x82111484;
		  /* 82111484h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82111484h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82111484h case    8:*/		return 0x82111488;
		  /* 82111488h */ case    9:  		/* lis R9, 4096 */
		/* 82111488h case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0x1000);
		/* 82111488h case    9:*/		return 0x8211148C;
		  /* 8211148Ch */ case   10:  		/* lwzx R10, <#[R11 + R10]> */
		/* 8211148Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8211148Ch case   10:*/		return 0x82111490;
		  /* 82111490h */ case   11:  		/* lwz R11, <#[R10]> */
		/* 82111490h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82111490h case   11:*/		return 0x82111494;
		  /* 82111494h */ case   12:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82111494h case   12:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82111494h case   12:*/		return 0x82111498;
		  /* 82111498h */ case   13:  		/* cmplw CR6, R11, R9 */
		/* 82111498h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82111498h case   13:*/		return 0x8211149C;
		  /* 8211149Ch */ case   14:  		/* bc 4, CR6_EQ, 72 */
		/* 8211149Ch case   14:*/		if ( !regs.CR[6].eq ) { return 0x821114E4;  }
		/* 8211149Ch case   14:*/		return 0x821114A0;
		  /* 821114A0h */ case   15:  		/* lwz R7, <#[R10 + 12]> */
		/* 821114A0h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x0000000C) );
		/* 821114A0h case   15:*/		return 0x821114A4;
		  /* 821114A4h */ case   16:  		/* li R9, 0 */
		/* 821114A4h case   16:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821114A4h case   16:*/		return 0x821114A8;
		  /* 821114A8h */ case   17:  		/* cmplwi CR6, R7, 0 */
		/* 821114A8h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 821114A8h case   17:*/		return 0x821114AC;
		  /* 821114ACh */ case   18:  		/* bc 12, CR6_EQ, 40 */
		/* 821114ACh case   18:*/		if ( regs.CR[6].eq ) { return 0x821114D4;  }
		/* 821114ACh case   18:*/		return 0x821114B0;
		  /* 821114B0h */ case   19:  		/* lwz R8, <#[R10 + 16]> */
		/* 821114B0h case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000010) );
		/* 821114B0h case   19:*/		return 0x821114B4;
		  /* 821114B4h */ case   20:  		/* li R11, 0 */
		/* 821114B4h case   20:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821114B4h case   20:*/		return 0x821114B8;
		  /* 821114B8h */ case   21:  		/* lwzx R6, <#[R11 + R8]> */
		/* 821114B8h case   21:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 821114B8h case   21:*/		return 0x821114BC;
		  /* 821114BCh */ case   22:  		/* cmplw CR6, R6, R28 */
		/* 821114BCh case   22:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R28);
		/* 821114BCh case   22:*/		return 0x821114C0;
		  /* 821114C0h */ case   23:  		/* bc 12, CR6_EQ, 20 */
		/* 821114C0h case   23:*/		if ( regs.CR[6].eq ) { return 0x821114D4;  }
		/* 821114C0h case   23:*/		return 0x821114C4;
		  /* 821114C4h */ case   24:  		/* addi R9, R9, 1 */
		/* 821114C4h case   24:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 821114C4h case   24:*/		return 0x821114C8;
		  /* 821114C8h */ case   25:  		/* addi R11, R11, 4 */
		/* 821114C8h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821114C8h case   25:*/		return 0x821114CC;
		  /* 821114CCh */ case   26:  		/* cmplw CR6, R9, R7 */
		/* 821114CCh case   26:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 821114CCh case   26:*/		return 0x821114D0;
		  /* 821114D0h */ case   27:  		/* bc 12, CR6_LT, -24 */
		/* 821114D0h case   27:*/		if ( regs.CR[6].lt ) { return 0x821114B8;  }
		/* 821114D0h case   27:*/		return 0x821114D4;
	}
	return 0x821114D4;
} // Block from 82111464h-821114D4h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821114D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821114D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821114D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821114D4);
		  /* 821114D4h */ case    0:  		/* lwz R11, <#[R10 + 8]> */
		/* 821114D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 821114D4h case    0:*/		return 0x821114D8;
		  /* 821114D8h */ case    1:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 821114D8h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 821114D8h case    1:*/		return 0x821114DC;
		  /* 821114DCh */ case    2:  		/* add R3, R10, R11 */
		/* 821114DCh case    2:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 821114DCh case    2:*/		return 0x821114E0;
		  /* 821114E0h */ case    3:  		/* b 8 */
		/* 821114E0h case    3:*/		return 0x821114E8;
		/* 821114E0h case    3:*/		return 0x821114E4;
	}
	return 0x821114E4;
} // Block from 821114D4h-821114E4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821114E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821114E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821114E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821114E4);
		  /* 821114E4h */ case    0:  		/* mr R3, R29 */
		/* 821114E4h case    0:*/		regs.R3 = regs.R29;
		/* 821114E4h case    0:*/		return 0x821114E8;
	}
	return 0x821114E8;
} // Block from 821114E4h-821114E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821114E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821114E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821114E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821114E8);
		  /* 821114E8h */ case    0:  		/* lwz R4, <#[R3]> */
		/* 821114E8h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000000) );
		/* 821114E8h case    0:*/		return 0x821114EC;
		  /* 821114ECh */ case    1:  		/* lwz R11, <#[R31 + 108]> */
		/* 821114ECh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 821114ECh case    1:*/		return 0x821114F0;
		  /* 821114F0h */ case    2:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 821114F0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 821114F0h case    2:*/		return 0x821114F4;
		  /* 821114F4h */ case    3:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 821114F4h case    3:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 821114F4h case    3:*/		return 0x821114F8;
		  /* 821114F8h */ case    4:  		/* lwzx R11, <#[R10 + R5]> */
		/* 821114F8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 821114F8h case    4:*/		return 0x821114FC;
		  /* 821114FCh */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 821114FCh case    5:*/		if ( regs.CR[0].eq ) { return 0x82111508;  }
		/* 821114FCh case    5:*/		return 0x82111500;
		  /* 82111500h */ case    6:  		/* fmr FR0, FR31 */
		/* 82111500h case    6:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR31);
		/* 82111500h case    6:*/		return 0x82111504;
		  /* 82111504h */ case    7:  		/* b 8 */
		/* 82111504h case    7:*/		return 0x8211150C;
		/* 82111504h case    7:*/		return 0x82111508;
	}
	return 0x82111508;
} // Block from 821114E8h-82111508h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82111508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111508);
		  /* 82111508h */ case    0:  		/* fmr FR0, FR30 */
		/* 82111508h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR30);
		/* 82111508h case    0:*/		return 0x8211150C;
	}
	return 0x8211150C;
} // Block from 82111508h-8211150Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8211150Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211150C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211150C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211150C);
		  /* 8211150Ch */ case    0:  		/* lwz R10, <#[R11 + 4]> */
		/* 8211150Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8211150Ch case    0:*/		return 0x82111510;
		  /* 82111510h */ case    1:  		/* lwz R6, <#[R31 + 16]> */
		/* 82111510h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000010) );
		/* 82111510h case    1:*/		return 0x82111514;
		  /* 82111514h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82111514h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82111514h case    2:*/		return 0x82111518;
		  /* 82111518h */ case    3:  		/* lwzx R10, <#[R10 + R6]> */
		/* 82111518h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 82111518h case    3:*/		return 0x8211151C;
		  /* 8211151Ch */ case    4:  		/* lwz R10, <#[R10 + 4]> */
		/* 8211151Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8211151Ch case    4:*/		return 0x82111520;
		  /* 82111520h */ case    5:  		/* rlwinm. R9, R10, 0, 23, 23 */
		/* 82111520h case    5:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R9,regs.R10);
		/* 82111520h case    5:*/		return 0x82111524;
		  /* 82111524h */ case    6:  		/* bc 12, CR0_EQ, 328 */
		/* 82111524h case    6:*/		if ( regs.CR[0].eq ) { return 0x8211166C;  }
		/* 82111524h case    6:*/		return 0x82111528;
		  /* 82111528h */ case    7:  		/* lwz R9, <#[R11 + 8]> */
		/* 82111528h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82111528h case    7:*/		return 0x8211152C;
		  /* 8211152Ch */ case    8:  		/* cmpwi CR6, R9, -1 */
		/* 8211152Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 8211152Ch case    8:*/		return 0x82111530;
		  /* 82111530h */ case    9:  		/* bc 4, CR6_EQ, 316 */
		/* 82111530h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8211166C;  }
		/* 82111530h case    9:*/		return 0x82111534;
		  /* 82111534h */ case   10:  		/* lfd FR13, <#[R11 + 32]> */
		/* 82111534h case   10:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 82111534h case   10:*/		return 0x82111538;
		  /* 82111538h */ case   11:  		/* lwz R9, <#[R31 + 8]> */
		/* 82111538h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82111538h case   11:*/		return 0x8211153C;
		  /* 8211153Ch */ case   12:  		/* fadd FR0, FR13, FR0 */
		/* 8211153Ch case   12:*/		cpu::op::fadd<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 8211153Ch case   12:*/		return 0x82111540;
		  /* 82111540h */ case   13:  		/* lwz R11, <#[R30 + 12]> */
		/* 82111540h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82111540h case   13:*/		return 0x82111544;
		  /* 82111544h */ case   14:  		/* li R8, 0 */
		/* 82111544h case   14:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82111544h case   14:*/		return 0x82111548;
		  /* 82111548h */ case   15:  		/* cmplwi CR6, R9, 0 */
		/* 82111548h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82111548h case   15:*/		return 0x8211154C;
		  /* 8211154Ch */ case   16:  		/* fctiwz FR0, FR0 */
		/* 8211154Ch case   16:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 8211154Ch case   16:*/		return 0x82111550;
		  /* 82111550h */ case   17:  		/* stfd FR0, <#[R1 + 112]> */
		/* 82111550h case   17:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000070) );
		/* 82111550h case   17:*/		return 0x82111554;
		  /* 82111554h */ case   18:  		/* lwz R10, <#[R1 + 116]> */
		/* 82111554h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000074) );
		/* 82111554h case   18:*/		return 0x82111558;
		  /* 82111558h */ case   19:  		/* add R7, R10, R11 */
		/* 82111558h case   19:*/		cpu::op::add<0>(regs,&regs.R7,regs.R10,regs.R11);
		/* 82111558h case   19:*/		return 0x8211155C;
		  /* 8211155Ch */ case   20:  		/* bc 12, CR6_EQ, 184 */
		/* 8211155Ch case   20:*/		if ( regs.CR[6].eq ) { return 0x82111614;  }
		/* 8211155Ch case   20:*/		return 0x82111560;
		  /* 82111560h */ case   21:  		/* li R10, 0 */
		/* 82111560h case   21:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82111560h case   21:*/		return 0x82111564;
		  /* 82111564h */ case   22:  		/* cmplw CR6, R8, R26 */
		/* 82111564h case   22:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R26);
		/* 82111564h case   22:*/		return 0x82111568;
		  /* 82111568h */ case   23:  		/* bc 12, CR6_EQ, 96 */
		/* 82111568h case   23:*/		if ( regs.CR[6].eq ) { return 0x821115C8;  }
		/* 82111568h case   23:*/		return 0x8211156C;
		  /* 8211156Ch */ case   24:  		/* lwzx R11, <#[R10 + R5]> */
		/* 8211156Ch case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 8211156Ch case   24:*/		return 0x82111570;
		  /* 82111570h */ case   25:  		/* lwz R6, <#[R30 + 4]> */
		/* 82111570h case   25:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000004) );
		/* 82111570h case   25:*/		return 0x82111574;
		  /* 82111574h */ case   26:  		/* lwz R4, <#[R11 + 4]> */
		/* 82111574h case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 82111574h case   26:*/		return 0x82111578;
		  /* 82111578h */ case   27:  		/* cmplw CR6, R4, R6 */
		/* 82111578h case   27:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R6);
		/* 82111578h case   27:*/		return 0x8211157C;
		  /* 8211157Ch */ case   28:  		/* bc 4, CR6_EQ, 76 */
		/* 8211157Ch case   28:*/		if ( !regs.CR[6].eq ) { return 0x821115C8;  }
		/* 8211157Ch case   28:*/		return 0x82111580;
		  /* 82111580h */ case   29:  		/* lwz R6, <#[R11 + 8]> */
		/* 82111580h case   29:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000008) );
		/* 82111580h case   29:*/		return 0x82111584;
		  /* 82111584h */ case   30:  		/* cmpwi CR6, R6, -1 */
		/* 82111584h case   30:*/		cpu::op::cmpwi<6>(regs,regs.R6,0xFFFFFFFF);
		/* 82111584h case   30:*/		return 0x82111588;
		  /* 82111588h */ case   31:  		/* bc 4, CR6_EQ, 64 */
		/* 82111588h case   31:*/		if ( !regs.CR[6].eq ) { return 0x821115C8;  }
		/* 82111588h case   31:*/		return 0x8211158C;
		  /* 8211158Ch */ case   32:  		/* lwz R6, <#[R11 + 12]> */
		/* 8211158Ch case   32:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x0000000C) );
		/* 8211158Ch case   32:*/		return 0x82111590;
		  /* 82111590h */ case   33:  		/* cmplw CR6, R6, R7 */
		/* 82111590h case   33:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R7);
		/* 82111590h case   33:*/		return 0x82111594;
		  /* 82111594h */ case   34:  		/* bc 4, CR6_EQ, 52 */
		/* 82111594h case   34:*/		if ( !regs.CR[6].eq ) { return 0x821115C8;  }
		/* 82111594h case   34:*/		return 0x82111598;
		  /* 82111598h */ case   35:  		/* lwz R6, <#[R11 + 16]> */
		/* 82111598h case   35:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000010) );
		/* 82111598h case   35:*/		return 0x8211159C;
		  /* 8211159Ch */ case   36:  		/* lwz R4, <#[R30 + 16]> */
		/* 8211159Ch case   36:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000010) );
		/* 8211159Ch case   36:*/		return 0x821115A0;
		  /* 821115A0h */ case   37:  		/* cmplw CR6, R6, R4 */
		/* 821115A0h case   37:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R4);
		/* 821115A0h case   37:*/		return 0x821115A4;
		  /* 821115A4h */ case   38:  		/* bc 4, CR6_EQ, 36 */
		/* 821115A4h case   38:*/		if ( !regs.CR[6].eq ) { return 0x821115C8;  }
		/* 821115A4h case   38:*/		return 0x821115A8;
		  /* 821115A8h */ case   39:  		/* lwz R6, <#[R11 + 20]> */
		/* 821115A8h case   39:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000014) );
		/* 821115A8h case   39:*/		return 0x821115AC;
		  /* 821115ACh */ case   40:  		/* lwz R4, <#[R30 + 20]> */
		/* 821115ACh case   40:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000014) );
		/* 821115ACh case   40:*/		return 0x821115B0;
		  /* 821115B0h */ case   41:  		/* cmplw CR6, R6, R4 */
		/* 821115B0h case   41:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R4);
		/* 821115B0h case   41:*/		return 0x821115B4;
		  /* 821115B4h */ case   42:  		/* bc 4, CR6_EQ, 20 */
		/* 821115B4h case   42:*/		if ( !regs.CR[6].eq ) { return 0x821115C8;  }
		/* 821115B4h case   42:*/		return 0x821115B8;
		  /* 821115B8h */ case   43:  		/* lwz R11, <#[R11 + 24]> */
		/* 821115B8h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 821115B8h case   43:*/		return 0x821115BC;
		  /* 821115BCh */ case   44:  		/* lwz R6, <#[R30 + 24]> */
		/* 821115BCh case   44:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000018) );
		/* 821115BCh case   44:*/		return 0x821115C0;
		  /* 821115C0h */ case   45:  		/* cmpw CR6, R11, R6 */
		/* 821115C0h case   45:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R6);
		/* 821115C0h case   45:*/		return 0x821115C4;
		  /* 821115C4h */ case   46:  		/* bc 12, CR6_EQ, 24 */
		/* 821115C4h case   46:*/		if ( regs.CR[6].eq ) { return 0x821115DC;  }
		/* 821115C4h case   46:*/		return 0x821115C8;
	}
	return 0x821115C8;
} // Block from 8211150Ch-821115C8h (47 instructions)

//////////////////////////////////////////////////////
// Block at 821115C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821115C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821115C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821115C8);
		  /* 821115C8h */ case    0:  		/* addi R8, R8, 1 */
		/* 821115C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821115C8h case    0:*/		return 0x821115CC;
		  /* 821115CCh */ case    1:  		/* addi R10, R10, 4 */
		/* 821115CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821115CCh case    1:*/		return 0x821115D0;
		  /* 821115D0h */ case    2:  		/* cmplw CR6, R8, R9 */
		/* 821115D0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 821115D0h case    2:*/		return 0x821115D4;
		  /* 821115D4h */ case    3:  		/* bc 12, CR6_LT, -112 */
		/* 821115D4h case    3:*/		if ( regs.CR[6].lt ) { return 0x82111564;  }
		/* 821115D4h case    3:*/		return 0x821115D8;
		  /* 821115D8h */ case    4:  		/* b 60 */
		/* 821115D8h case    4:*/		return 0x82111614;
		/* 821115D8h case    4:*/		return 0x821115DC;
	}
	return 0x821115DC;
} // Block from 821115C8h-821115DCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821115DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821115DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821115DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821115DC);
		  /* 821115DCh */ case    0:  		/* cmpwi CR6, R24, 0 */
		/* 821115DCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 821115DCh case    0:*/		return 0x821115E0;
		  /* 821115E0h */ case    1:  		/* bc 4, CR6_EQ, 48 */
		/* 821115E0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82111610;  }
		/* 821115E0h case    1:*/		return 0x821115E4;
		  /* 821115E4h */ case    2:  		/* li R11, 0 */
		/* 821115E4h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821115E4h case    2:*/		return 0x821115E8;
		  /* 821115E8h */ case    3:  		/* li R10, 0 */
		/* 821115E8h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821115E8h case    3:*/		return 0x821115EC;
		  /* 821115ECh */ case    4:  		/* lwz R9, <#[R31 + 20]> */
		/* 821115ECh case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 821115ECh case    4:*/		return 0x821115F0;
		  /* 821115F0h */ case    5:  		/* lwzx R9, <#[R10 + R9]> */
		/* 821115F0h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821115F0h case    5:*/		return 0x821115F4;
		  /* 821115F4h */ case    6:  		/* addi R10, R10, 4 */
		/* 821115F4h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821115F4h case    6:*/		return 0x821115F8;
		  /* 821115F8h */ case    7:  		/* stw R11, <#[R9 + 48]> */
		/* 821115F8h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000030) );
		/* 821115F8h case    7:*/		return 0x821115FC;
		  /* 821115FCh */ case    8:  		/* addi R11, R11, 1 */
		/* 821115FCh case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821115FCh case    8:*/		return 0x82111600;
		  /* 82111600h */ case    9:  		/* lwz R9, <#[R31 + 8]> */
		/* 82111600h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82111600h case    9:*/		return 0x82111604;
		  /* 82111604h */ case   10:  		/* cmplw CR6, R11, R9 */
		/* 82111604h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82111604h case   10:*/		return 0x82111608;
		  /* 82111608h */ case   11:  		/* bc 12, CR6_LT, -28 */
		/* 82111608h case   11:*/		if ( regs.CR[6].lt ) { return 0x821115EC;  }
		/* 82111608h case   11:*/		return 0x8211160C;
		  /* 8211160Ch */ case   12:  		/* li R24, 1 */
		/* 8211160Ch case   12:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 8211160Ch case   12:*/		return 0x82111610;
	}
	return 0x82111610;
} // Block from 821115DCh-82111610h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82111610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111610);
		  /* 82111610h */ case    0:  		/* stw R8, <#[R30 + 48]> */
		/* 82111610h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000030) );
		/* 82111610h case    0:*/		return 0x82111614;
	}
	return 0x82111614;
} // Block from 82111610h-82111614h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82111614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111614);
		  /* 82111614h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82111614h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82111614h case    0:*/		return 0x82111618;
		  /* 82111618h */ case    1:  		/* cmplw CR6, R8, R11 */
		/* 82111618h case    1:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 82111618h case    1:*/		return 0x8211161C;
		  /* 8211161Ch */ case    2:  		/* bc 4, CR6_EQ, 568 */
		/* 8211161Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82111854;  }
		/* 8211161Ch case    2:*/		return 0x82111620;
		  /* 82111620h */ case    3:  		/* li R11, -1 */
		/* 82111620h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 82111620h case    3:*/		return 0x82111624;
		  /* 82111624h */ case    4:  		/* lwz R10, <#[R30 + 4]> */
		/* 82111624h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 82111624h case    4:*/		return 0x82111628;
		  /* 82111628h */ case    5:  		/* stw R7, <#[R30 + 12]> */
		/* 82111628h case    5:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R30 + 0x0000000C) );
		/* 82111628h case    5:*/		return 0x8211162C;
		  /* 8211162Ch */ case    6:  		/* stw R11, <#[R29]> */
		/* 8211162Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8211162Ch case    6:*/		return 0x82111630;
		  /* 82111630h */ case    7:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 82111630h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 82111630h case    7:*/		return 0x82111634;
		  /* 82111634h */ case    8:  		/* lwz R10, <#[R31 + 16]> */
		/* 82111634h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82111634h case    8:*/		return 0x82111638;
		  /* 82111638h */ case    9:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82111638h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82111638h case    9:*/		return 0x8211163C;
		  /* 8211163Ch */ case   10:  		/* lwz R11, <#[R11 + 8]> */
		/* 8211163Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8211163Ch case   10:*/		return 0x82111640;
		  /* 82111640h */ case   11:  		/* cmplw CR6, R7, R11 */
		/* 82111640h case   11:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 82111640h case   11:*/		return 0x82111644;
		  /* 82111644h */ case   12:  		/* bc 12, CR6_LT, 528 */
		/* 82111644h case   12:*/		if ( regs.CR[6].lt ) { return 0x82111854;  }
		/* 82111644h case   12:*/		return 0x82111648;
		  /* 82111648h */ case   13:  		/* lis R11, -32255 */
		/* 82111648h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82111648h case   13:*/		return 0x8211164C;
		  /* 8211164Ch */ case   14:  		/* lwz R4, <#[R30 + 96]> */
		/* 8211164Ch case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000060) );
		/* 8211164Ch case   14:*/		return 0x82111650;
		  /* 82111650h */ case   15:  		/* li R5, 4007 */
		/* 82111650h case   15:*/		cpu::op::li<0>(regs,&regs.R5,0xFA7);
		/* 82111650h case   15:*/		return 0x82111654;
		  /* 82111654h */ case   16:  		/* addi R6, R11, 9184 */
		/* 82111654h case   16:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x23E0);
		/* 82111654h case   16:*/		return 0x82111658;
		  /* 82111658h */ case   17:  		/* mr R3, R31 */
		/* 82111658h case   17:*/		regs.R3 = regs.R31;
		/* 82111658h case   17:*/		return 0x8211165C;
		  /* 8211165Ch */ case   18:  		/* bl -12076 */
		/* 8211165Ch case   18:*/		regs.LR = 0x82111660; return 0x8210E730;
		/* 8211165Ch case   18:*/		return 0x82111660;
		  /* 82111660h */ case   19:  		/* lis R3, -32768 */
		/* 82111660h case   19:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 82111660h case   19:*/		return 0x82111664;
		  /* 82111664h */ case   20:  		/* ori R3, R3, 16389 */
		/* 82111664h case   20:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 82111664h case   20:*/		return 0x82111668;
		  /* 82111668h */ case   21:  		/* b 552 */
		/* 82111668h case   21:*/		return 0x82111890;
		/* 82111668h case   21:*/		return 0x8211166C;
	}
	return 0x8211166C;
} // Block from 82111614h-8211166Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 8211166Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211166C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211166C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211166C);
		  /* 8211166Ch */ case    0:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 8211166Ch case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 8211166Ch case    0:*/		return 0x82111670;
		  /* 82111670h */ case    1:  		/* bc 12, CR0_EQ, 488 */
		/* 82111670h case    1:*/		if ( regs.CR[0].eq ) { return 0x82111858;  }
		/* 82111670h case    1:*/		return 0x82111674;
		  /* 82111674h */ case    2:  		/* lwz R11, <#[R11 + 72]> */
		/* 82111674h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 82111674h case    2:*/		return 0x82111678;
		  /* 82111678h */ case    3:  		/* cmpwi CR6, R11, -1 */
		/* 82111678h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82111678h case    3:*/		return 0x8211167C;
		  /* 8211167Ch */ case    4:  		/* bc 12, CR6_EQ, 476 */
		/* 8211167Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82111858;  }
		/* 8211167Ch case    4:*/		return 0x82111680;
		  /* 82111680h */ case    5:  		/* lwz R10, <#[R31 + 24]> */
		/* 82111680h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 82111680h case    5:*/		return 0x82111684;
		  /* 82111684h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82111684h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82111684h case    6:*/		return 0x82111688;
		  /* 82111688h */ case    7:  		/* lis R9, 8256 */
		/* 82111688h case    7:*/		cpu::op::lis<0>(regs,&regs.R9,0x2040);
		/* 82111688h case    7:*/		return 0x8211168C;
		  /* 8211168Ch */ case    8:  		/* lwzx R10, <#[R11 + R10]> */
		/* 8211168Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8211168Ch case    8:*/		return 0x82111690;
		  /* 82111690h */ case    9:  		/* lwz R11, <#[R10]> */
		/* 82111690h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82111690h case    9:*/		return 0x82111694;
		  /* 82111694h */ case   10:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82111694h case   10:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82111694h case   10:*/		return 0x82111698;
		  /* 82111698h */ case   11:  		/* cmplw CR6, R11, R9 */
		/* 82111698h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82111698h case   11:*/		return 0x8211169C;
		  /* 8211169Ch */ case   12:  		/* bc 4, CR6_EQ, 444 */
		/* 8211169Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x82111858;  }
		/* 8211169Ch case   12:*/		return 0x821116A0;
		  /* 821116A0h */ case   13:  		/* lwz R8, <#[R10 + 12]> */
		/* 821116A0h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x0000000C) );
		/* 821116A0h case   13:*/		return 0x821116A4;
		  /* 821116A4h */ case   14:  		/* li R11, 0 */
		/* 821116A4h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821116A4h case   14:*/		return 0x821116A8;
		  /* 821116A8h */ case   15:  		/* cmplwi CR6, R8, 0 */
		/* 821116A8h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 821116A8h case   15:*/		return 0x821116AC;
		  /* 821116ACh */ case   16:  		/* bc 12, CR6_EQ, 40 */
		/* 821116ACh case   16:*/		if ( regs.CR[6].eq ) { return 0x821116D4;  }
		/* 821116ACh case   16:*/		return 0x821116B0;
		  /* 821116B0h */ case   17:  		/* lwz R7, <#[R10 + 16]> */
		/* 821116B0h case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000010) );
		/* 821116B0h case   17:*/		return 0x821116B4;
		  /* 821116B4h */ case   18:  		/* li R9, 0 */
		/* 821116B4h case   18:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821116B4h case   18:*/		return 0x821116B8;
		  /* 821116B8h */ case   19:  		/* lwzx R5, <#[R9 + R7]> */
		/* 821116B8h case   19:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 821116B8h case   19:*/		return 0x821116BC;
		  /* 821116BCh */ case   20:  		/* cmplw CR6, R5, R4 */
		/* 821116BCh case   20:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R4);
		/* 821116BCh case   20:*/		return 0x821116C0;
		  /* 821116C0h */ case   21:  		/* bc 12, CR6_EQ, 20 */
		/* 821116C0h case   21:*/		if ( regs.CR[6].eq ) { return 0x821116D4;  }
		/* 821116C0h case   21:*/		return 0x821116C4;
		  /* 821116C4h */ case   22:  		/* addi R11, R11, 1 */
		/* 821116C4h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821116C4h case   22:*/		return 0x821116C8;
		  /* 821116C8h */ case   23:  		/* addi R9, R9, 4 */
		/* 821116C8h case   23:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 821116C8h case   23:*/		return 0x821116CC;
		  /* 821116CCh */ case   24:  		/* cmplw CR6, R11, R8 */
		/* 821116CCh case   24:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 821116CCh case   24:*/		return 0x821116D0;
		  /* 821116D0h */ case   25:  		/* bc 12, CR6_LT, -24 */
		/* 821116D0h case   25:*/		if ( regs.CR[6].lt ) { return 0x821116B8;  }
		/* 821116D0h case   25:*/		return 0x821116D4;
	}
	return 0x821116D4;
} // Block from 8211166Ch-821116D4h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821116D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821116D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821116D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821116D4);
		  /* 821116D4h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 821116D4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821116D4h case    0:*/		return 0x821116D8;
		  /* 821116D8h */ case    1:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 821116D8h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 821116D8h case    1:*/		return 0x821116DC;
		  /* 821116DCh */ case    2:  		/* add R11, R8, R11 */
		/* 821116DCh case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 821116DCh case    2:*/		return 0x821116E0;
		  /* 821116E0h */ case    3:  		/* lwz R7, <#[R31 + 20]> */
		/* 821116E0h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000014) );
		/* 821116E0h case    3:*/		return 0x821116E4;
		  /* 821116E4h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821116E4h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821116E4h case    4:*/		return 0x821116E8;
		  /* 821116E8h */ case    5:  		/* lwzx R8, <#[R9 + R10]> */
		/* 821116E8h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821116E8h case    5:*/		return 0x821116EC;
		  /* 821116ECh */ case    6:  		/* rlwinm R9, R8, 2, 0, 29 */
		/* 821116ECh case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 821116ECh case    6:*/		return 0x821116F0;
		  /* 821116F0h */ case    7:  		/* lwzx R10, <#[R11 + R10]> */
		/* 821116F0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821116F0h case    7:*/		return 0x821116F4;
		  /* 821116F4h */ case    8:  		/* rlwinm R5, R10, 2, 0, 29 */
		/* 821116F4h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R10);
		/* 821116F4h case    8:*/		return 0x821116F8;
		  /* 821116F8h */ case    9:  		/* lwzx R11, <#[R9 + R7]> */
		/* 821116F8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 821116F8h case    9:*/		return 0x821116FC;
		  /* 821116FCh */ case   10:  		/* lwzx R9, <#[R5 + R7]> */
		/* 821116FCh case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + regs.R7 + 0x00000000) );
		/* 821116FCh case   10:*/		return 0x82111700;
		  /* 82111700h */ case   11:  		/* lwz R7, <#[R11 + 4]> */
		/* 82111700h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82111700h case   11:*/		return 0x82111704;
		  /* 82111704h */ case   12:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82111704h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82111704h case   12:*/		return 0x82111708;
		  /* 82111708h */ case   13:  		/* lwzx R7, <#[R7 + R6]> */
		/* 82111708h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R6 + 0x00000000) );
		/* 82111708h case   13:*/		return 0x8211170C;
		  /* 8211170Ch */ case   14:  		/* lwz R7, <#[R7 + 4]> */
		/* 8211170Ch case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000004) );
		/* 8211170Ch case   14:*/		return 0x82111710;
		  /* 82111710h */ case   15:  		/* rlwinm. R7, R7, 0, 23, 23 */
		/* 82111710h case   15:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R7,regs.R7);
		/* 82111710h case   15:*/		return 0x82111714;
		  /* 82111714h */ case   16:  		/* bc 12, CR0_EQ, 72 */
		/* 82111714h case   16:*/		if ( regs.CR[0].eq ) { return 0x8211175C;  }
		/* 82111714h case   16:*/		return 0x82111718;
		  /* 82111718h */ case   17:  		/* lwz R7, <#[R11 + 8]> */
		/* 82111718h case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 82111718h case   17:*/		return 0x8211171C;
		  /* 8211171Ch */ case   18:  		/* cmpwi CR6, R7, -1 */
		/* 8211171Ch case   18:*/		cpu::op::cmpwi<6>(regs,regs.R7,0xFFFFFFFF);
		/* 8211171Ch case   18:*/		return 0x82111720;
		  /* 82111720h */ case   19:  		/* bc 4, CR6_EQ, 60 */
		/* 82111720h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8211175C;  }
		/* 82111720h case   19:*/		return 0x82111724;
		  /* 82111724h */ case   20:  		/* lwz R7, <#[R11]> */
		/* 82111724h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 82111724h case   20:*/		return 0x82111728;
		  /* 82111728h */ case   21:  		/* rlwinm. R5, R7, 0, 29, 29 */
		/* 82111728h case   21:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R5,regs.R7);
		/* 82111728h case   21:*/		return 0x8211172C;
		  /* 8211172Ch */ case   22:  		/* bc 12, CR0_EQ, 48 */
		/* 8211172Ch case   22:*/		if ( regs.CR[0].eq ) { return 0x8211175C;  }
		/* 8211172Ch case   22:*/		return 0x82111730;
		  /* 82111730h */ case   23:  		/* rlwinm. R7, R7, 0, 30, 30 */
		/* 82111730h case   23:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R7,regs.R7);
		/* 82111730h case   23:*/		return 0x82111734;
		  /* 82111734h */ case   24:  		/* bc 4, CR0_EQ, 16 */
		/* 82111734h case   24:*/		if ( !regs.CR[0].eq ) { return 0x82111744;  }
		/* 82111734h case   24:*/		return 0x82111738;
		  /* 82111738h */ case   25:  		/* lwz R7, <#[R9]> */
		/* 82111738h case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 82111738h case   25:*/		return 0x8211173C;
		  /* 8211173Ch */ case   26:  		/* rlwinm. R7, R7, 0, 30, 30 */
		/* 8211173Ch case   26:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R7,regs.R7);
		/* 8211173Ch case   26:*/		return 0x82111740;
		  /* 82111740h */ case   27:  		/* bc 12, CR0_EQ, 28 */
		/* 82111740h case   27:*/		if ( regs.CR[0].eq ) { return 0x8211175C;  }
		/* 82111740h case   27:*/		return 0x82111744;
	}
	return 0x82111744;
} // Block from 821116D4h-82111744h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82111744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111744);
		  /* 82111744h */ case    0:  		/* lfd FR13, <#[R11 + 32]> */
		/* 82111744h case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 82111744h case    0:*/		return 0x82111748;
		  /* 82111748h */ case    1:  		/* fadd FR0, FR13, FR0 */
		/* 82111748h case    1:*/		cpu::op::fadd<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 82111748h case    1:*/		return 0x8211174C;
		  /* 8211174Ch */ case    2:  		/* fctiwz FR0, FR0 */
		/* 8211174Ch case    2:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 8211174Ch case    2:*/		return 0x82111750;
		  /* 82111750h */ case    3:  		/* stfd FR0, <#[R1 + 112]> */
		/* 82111750h case    3:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000070) );
		/* 82111750h case    3:*/		return 0x82111754;
		  /* 82111754h */ case    4:  		/* lwz R5, <#[R1 + 116]> */
		/* 82111754h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000074) );
		/* 82111754h case    4:*/		return 0x82111758;
		  /* 82111758h */ case    5:  		/* b 96 */
		/* 82111758h case    5:*/		return 0x821117B8;
		/* 82111758h case    5:*/		return 0x8211175C;
	}
	return 0x8211175C;
} // Block from 82111744h-8211175Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8211175Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211175C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211175C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211175C);
		  /* 8211175Ch */ case    0:  		/* lwz R10, <#[R9 + 4]> */
		/* 8211175Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 8211175Ch case    0:*/		return 0x82111760;
		  /* 82111760h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82111760h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82111760h case    1:*/		return 0x82111764;
		  /* 82111764h */ case    2:  		/* lwzx R10, <#[R10 + R6]> */
		/* 82111764h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 82111764h case    2:*/		return 0x82111768;
		  /* 82111768h */ case    3:  		/* lwz R10, <#[R10 + 4]> */
		/* 82111768h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82111768h case    3:*/		return 0x8211176C;
		  /* 8211176Ch */ case    4:  		/* rlwinm. R10, R10, 0, 23, 23 */
		/* 8211176Ch case    4:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R10);
		/* 8211176Ch case    4:*/		return 0x82111770;
		  /* 82111770h */ case    5:  		/* bc 12, CR0_EQ, 232 */
		/* 82111770h case    5:*/		if ( regs.CR[0].eq ) { return 0x82111858;  }
		/* 82111770h case    5:*/		return 0x82111774;
		  /* 82111774h */ case    6:  		/* lwz R10, <#[R9 + 8]> */
		/* 82111774h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000008) );
		/* 82111774h case    6:*/		return 0x82111778;
		  /* 82111778h */ case    7:  		/* cmpwi CR6, R10, -1 */
		/* 82111778h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82111778h case    7:*/		return 0x8211177C;
		  /* 8211177Ch */ case    8:  		/* bc 4, CR6_EQ, 220 */
		/* 8211177Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x82111858;  }
		/* 8211177Ch case    8:*/		return 0x82111780;
		  /* 82111780h */ case    9:  		/* lwz R10, <#[R9]> */
		/* 82111780h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 82111780h case    9:*/		return 0x82111784;
		  /* 82111784h */ case   10:  		/* rlwinm. R7, R10, 0, 29, 29 */
		/* 82111784h case   10:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R7,regs.R10);
		/* 82111784h case   10:*/		return 0x82111788;
		  /* 82111788h */ case   11:  		/* bc 12, CR0_EQ, 208 */
		/* 82111788h case   11:*/		if ( regs.CR[0].eq ) { return 0x82111858;  }
		/* 82111788h case   11:*/		return 0x8211178C;
		  /* 8211178Ch */ case   12:  		/* lwz R11, <#[R11]> */
		/* 8211178Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8211178Ch case   12:*/		return 0x82111790;
		  /* 82111790h */ case   13:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 82111790h case   13:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 82111790h case   13:*/		return 0x82111794;
		  /* 82111794h */ case   14:  		/* bc 4, CR0_EQ, 12 */
		/* 82111794h case   14:*/		if ( !regs.CR[0].eq ) { return 0x821117A0;  }
		/* 82111794h case   14:*/		return 0x82111798;
		  /* 82111798h */ case   15:  		/* rlwinm. R11, R10, 0, 30, 30 */
		/* 82111798h case   15:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R10);
		/* 82111798h case   15:*/		return 0x8211179C;
		  /* 8211179Ch */ case   16:  		/* bc 12, CR0_EQ, 188 */
		/* 8211179Ch case   16:*/		if ( regs.CR[0].eq ) { return 0x82111858;  }
		/* 8211179Ch case   16:*/		return 0x821117A0;
	}
	return 0x821117A0;
} // Block from 8211175Ch-821117A0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821117A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821117A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821117A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821117A0);
		  /* 821117A0h */ case    0:  		/* lfd FR13, <#[R9 + 32]> */
		/* 821117A0h case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R9 + 0x00000020) );
		/* 821117A0h case    0:*/		return 0x821117A4;
		  /* 821117A4h */ case    1:  		/* mr R10, R8 */
		/* 821117A4h case    1:*/		regs.R10 = regs.R8;
		/* 821117A4h case    1:*/		return 0x821117A8;
		  /* 821117A8h */ case    2:  		/* fadd FR0, FR13, FR0 */
		/* 821117A8h case    2:*/		cpu::op::fadd<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 821117A8h case    2:*/		return 0x821117AC;
		  /* 821117ACh */ case    3:  		/* fctiwz FR0, FR0 */
		/* 821117ACh case    3:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 821117ACh case    3:*/		return 0x821117B0;
		  /* 821117B0h */ case    4:  		/* stfd FR0, <#[R1 + 112]> */
		/* 821117B0h case    4:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000070) );
		/* 821117B0h case    4:*/		return 0x821117B4;
		  /* 821117B4h */ case    5:  		/* lwz R5, <#[R1 + 116]> */
		/* 821117B4h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000074) );
		/* 821117B4h case    5:*/		return 0x821117B8;
	}
	return 0x821117B8;
} // Block from 821117A0h-821117B8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821117B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821117B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821117B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821117B8);
		  /* 821117B8h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 821117B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821117B8h case    0:*/		return 0x821117BC;
		  /* 821117BCh */ case    1:  		/* cmplw CR6, R4, R28 */
		/* 821117BCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R28);
		/* 821117BCh case    1:*/		return 0x821117C0;
		  /* 821117C0h */ case    2:  		/* li R6, 0 */
		/* 821117C0h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821117C0h case    2:*/		return 0x821117C4;
		  /* 821117C4h */ case    3:  		/* bc 4, CR6_EQ, 76 */
		/* 821117C4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82111810;  }
		/* 821117C4h case    3:*/		return 0x821117C8;
		  /* 821117C8h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821117C8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821117C8h case    4:*/		return 0x821117CC;
		  /* 821117CCh */ case    5:  		/* bc 4, CR6_GT, 136 */
		/* 821117CCh case    5:*/		if ( !regs.CR[6].gt ) { return 0x82111854;  }
		/* 821117CCh case    5:*/		return 0x821117D0;
		  /* 821117D0h */ case    6:  		/* li R9, 0 */
		/* 821117D0h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821117D0h case    6:*/		return 0x821117D4;
		  /* 821117D4h */ case    7:  		/* lwz R11, <#[R31 + 20]> */
		/* 821117D4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 821117D4h case    7:*/		return 0x821117D8;
		  /* 821117D8h */ case    8:  		/* lwzx R11, <#[R9 + R11]> */
		/* 821117D8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821117D8h case    8:*/		return 0x821117DC;
		  /* 821117DCh */ case    9:  		/* lwz R8, <#[R11 + 8]> */
		/* 821117DCh case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 821117DCh case    9:*/		return 0x821117E0;
		  /* 821117E0h */ case   10:  		/* cmplw CR6, R28, R8 */
		/* 821117E0h case   10:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R8);
		/* 821117E0h case   10:*/		return 0x821117E4;
		  /* 821117E4h */ case   11:  		/* bc 4, CR6_EQ, 20 */
		/* 821117E4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821117F8;  }
		/* 821117E4h case   11:*/		return 0x821117E8;
		  /* 821117E8h */ case   12:  		/* lwz R7, <#[R11 + 12]> */
		/* 821117E8h case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 821117E8h case   12:*/		return 0x821117EC;
		  /* 821117ECh */ case   13:  		/* stw R10, <#[R11 + 8]> */
		/* 821117ECh case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821117ECh case   13:*/		return 0x821117F0;
		  /* 821117F0h */ case   14:  		/* add R8, R7, R5 */
		/* 821117F0h case   14:*/		cpu::op::add<0>(regs,&regs.R8,regs.R7,regs.R5);
		/* 821117F0h case   14:*/		return 0x821117F4;
		  /* 821117F4h */ case   15:  		/* stw R8, <#[R11 + 12]> */
		/* 821117F4h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 821117F4h case   15:*/		return 0x821117F8;
	}
	return 0x821117F8;
} // Block from 821117B8h-821117F8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821117F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821117F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821117F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821117F8);
		  /* 821117F8h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 821117F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821117F8h case    0:*/		return 0x821117FC;
		  /* 821117FCh */ case    1:  		/* addi R6, R6, 1 */
		/* 821117FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821117FCh case    1:*/		return 0x82111800;
		  /* 82111800h */ case    2:  		/* addi R9, R9, 4 */
		/* 82111800h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82111800h case    2:*/		return 0x82111804;
		  /* 82111804h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 82111804h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 82111804h case    3:*/		return 0x82111808;
		  /* 82111808h */ case    4:  		/* bc 12, CR6_LT, -52 */
		/* 82111808h case    4:*/		if ( regs.CR[6].lt ) { return 0x821117D4;  }
		/* 82111808h case    4:*/		return 0x8211180C;
		  /* 8211180Ch */ case    5:  		/* b 72 */
		/* 8211180Ch case    5:*/		return 0x82111854;
		/* 8211180Ch case    5:*/		return 0x82111810;
	}
	return 0x82111810;
} // Block from 821117F8h-82111810h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82111810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111810);
		  /* 82111810h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 82111810h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82111810h case    0:*/		return 0x82111814;
		  /* 82111814h */ case    1:  		/* bc 4, CR6_GT, 60 */
		/* 82111814h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82111850;  }
		/* 82111814h case    1:*/		return 0x82111818;
		  /* 82111818h */ case    2:  		/* li R9, 0 */
		/* 82111818h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82111818h case    2:*/		return 0x8211181C;
		  /* 8211181Ch */ case    3:  		/* lwz R11, <#[R31 + 20]> */
		/* 8211181Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8211181Ch case    3:*/		return 0x82111820;
		  /* 82111820h */ case    4:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82111820h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82111820h case    4:*/		return 0x82111824;
		  /* 82111824h */ case    5:  		/* lwz R8, <#[R11 + 8]> */
		/* 82111824h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 82111824h case    5:*/		return 0x82111828;
		  /* 82111828h */ case    6:  		/* cmplw CR6, R28, R8 */
		/* 82111828h case    6:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R8);
		/* 82111828h case    6:*/		return 0x8211182C;
		  /* 8211182Ch */ case    7:  		/* bc 4, CR6_EQ, 16 */
		/* 8211182Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x8211183C;  }
		/* 8211182Ch case    7:*/		return 0x82111830;
		  /* 82111830h */ case    8:  		/* lwz R7, <#[R11 + 12]> */
		/* 82111830h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 82111830h case    8:*/		return 0x82111834;
		  /* 82111834h */ case    9:  		/* add R8, R7, R5 */
		/* 82111834h case    9:*/		cpu::op::add<0>(regs,&regs.R8,regs.R7,regs.R5);
		/* 82111834h case    9:*/		return 0x82111838;
		  /* 82111838h */ case   10:  		/* stw R8, <#[R11 + 12]> */
		/* 82111838h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 82111838h case   10:*/		return 0x8211183C;
	}
	return 0x8211183C;
} // Block from 82111810h-8211183Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8211183Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211183C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211183C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211183C);
		  /* 8211183Ch */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8211183Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8211183Ch case    0:*/		return 0x82111840;
		  /* 82111840h */ case    1:  		/* addi R6, R6, 1 */
		/* 82111840h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82111840h case    1:*/		return 0x82111844;
		  /* 82111844h */ case    2:  		/* addi R9, R9, 4 */
		/* 82111844h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82111844h case    2:*/		return 0x82111848;
		  /* 82111848h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 82111848h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 82111848h case    3:*/		return 0x8211184C;
		  /* 8211184Ch */ case    4:  		/* bc 12, CR6_LT, -48 */
		/* 8211184Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x8211181C;  }
		/* 8211184Ch case    4:*/		return 0x82111850;
	}
	return 0x82111850;
} // Block from 8211183Ch-82111850h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82111850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111850);
		  /* 82111850h */ case    0:  		/* stw R10, <#[R3]> */
		/* 82111850h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82111850h case    0:*/		return 0x82111854;
	}
	return 0x82111854;
} // Block from 82111850h-82111854h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82111854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111854);
		  /* 82111854h */ case    0:  		/* li R27, 1 */
		/* 82111854h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 82111854h case    0:*/		return 0x82111858;
	}
	return 0x82111858;
} // Block from 82111854h-82111858h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82111858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111858);
		  /* 82111858h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82111858h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82111858h case    0:*/		return 0x8211185C;
		  /* 8211185Ch */ case    1:  		/* addi R26, R26, 1 */
		/* 8211185Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 8211185Ch case    1:*/		return 0x82111860;
		  /* 82111860h */ case    2:  		/* addi R25, R25, 4 */
		/* 82111860h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 82111860h case    2:*/		return 0x82111864;
		  /* 82111864h */ case    3:  		/* cmplw CR6, R26, R11 */
		/* 82111864h case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 82111864h case    3:*/		return 0x82111868;
		  /* 82111868h */ case    4:  		/* bc 12, CR6_LT, -1088 */
		/* 82111868h case    4:*/		if ( regs.CR[6].lt ) { return 0x82111428;  }
		/* 82111868h case    4:*/		return 0x8211186C;
		  /* 8211186Ch */ case    5:  		/* cmpwi CR6, R27, 0 */
		/* 8211186Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 8211186Ch case    5:*/		return 0x82111870;
		  /* 82111870h */ case    6:  		/* bc 4, CR6_EQ, 12 */
		/* 82111870h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8211187C;  }
		/* 82111870h case    6:*/		return 0x82111874;
	}
	return 0x82111874;
} // Block from 82111858h-82111874h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82111874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111874);
		  /* 82111874h */ case    0:  		/* li R3, 1 */
		/* 82111874h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82111874h case    0:*/		return 0x82111878;
		  /* 82111878h */ case    1:  		/* b 24 */
		/* 82111878h case    1:*/		return 0x82111890;
		/* 82111878h case    1:*/		return 0x8211187C;
	}
	return 0x8211187C;
} // Block from 82111874h-8211187Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8211187Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211187C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211187C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211187C);
		  /* 8211187Ch */ case    0:  		/* cmpwi CR6, R24, 0 */
		/* 8211187Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 8211187Ch case    0:*/		return 0x82111880;
		  /* 82111880h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82111880h case    1:*/		if ( regs.CR[6].eq ) { return 0x8211188C;  }
		/* 82111880h case    1:*/		return 0x82111884;
		  /* 82111884h */ case    2:  		/* mr R3, R31 */
		/* 82111884h case    2:*/		regs.R3 = regs.R31;
		/* 82111884h case    2:*/		return 0x82111888;
		  /* 82111888h */ case    3:  		/* bl -46184 */
		/* 82111888h case    3:*/		regs.LR = 0x8211188C; return 0x82106420;
		/* 82111888h case    3:*/		return 0x8211188C;
	}
	return 0x8211188C;
} // Block from 8211187Ch-8211188Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8211188Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211188C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211188C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211188C);
		  /* 8211188Ch */ case    0:  		/* li R3, 0 */
		/* 8211188Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8211188Ch case    0:*/		return 0x82111890;
	}
	return 0x82111890;
} // Block from 8211188Ch-82111890h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82111890h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111890);
		  /* 82111890h */ case    0:  		/* addi R1, R1, 224 */
		/* 82111890h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 82111890h case    0:*/		return 0x82111894;
		  /* 82111894h */ case    1:  		/* lfd FR30, <#[R1 - 96]> */
		/* 82111894h case    1:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFFA0) );
		/* 82111894h case    1:*/		return 0x82111898;
		  /* 82111898h */ case    2:  		/* lfd FR31, <#[R1 - 88]> */
		/* 82111898h case    2:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA8) );
		/* 82111898h case    2:*/		return 0x8211189C;
		  /* 8211189Ch */ case    3:  		/* b -525832 */
		/* 8211189Ch case    3:*/		return 0x82091294;
		/* 8211189Ch case    3:*/		return 0x821118A0;
	}
	return 0x821118A0;
} // Block from 82111890h-821118A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821118A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821118A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821118A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821118A0);
		  /* 821118A0h */ case    0:  		/* mfspr R12, LR */
		/* 821118A0h case    0:*/		regs.R12 = regs.LR;
		/* 821118A0h case    0:*/		return 0x821118A4;
		  /* 821118A4h */ case    1:  		/* bl -525952 */
		/* 821118A4h case    1:*/		regs.LR = 0x821118A8; return 0x82091224;
		/* 821118A4h case    1:*/		return 0x821118A8;
		  /* 821118A8h */ case    2:  		/* stfd FR31, <#[R1 - 152]> */
		/* 821118A8h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF68) );
		/* 821118A8h case    2:*/		return 0x821118AC;
		  /* 821118ACh */ case    3:  		/* stwu R1, <#[R1 - 272]> */
		/* 821118ACh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEF0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEF0);
		/* 821118ACh case    3:*/		return 0x821118B0;
		  /* 821118B0h */ case    4:  		/* lwz R11, <#[R3 + 20]> */
		/* 821118B0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 821118B0h case    4:*/		return 0x821118B4;
		  /* 821118B4h */ case    5:  		/* rlwinm R9, R5, 2, 0, 29 */
		/* 821118B4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R5);
		/* 821118B4h case    5:*/		return 0x821118B8;
		  /* 821118B8h */ case    6:  		/* rlwinm R8, R6, 2, 0, 29 */
		/* 821118B8h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R6);
		/* 821118B8h case    6:*/		return 0x821118BC;
		  /* 821118BCh */ case    7:  		/* lwz R7, <#[R3 + 16]> */
		/* 821118BCh case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000010) );
		/* 821118BCh case    7:*/		return 0x821118C0;
		  /* 821118C0h */ case    8:  		/* lwz R10, <#[R4]> */
		/* 821118C0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 821118C0h case    8:*/		return 0x821118C4;
		  /* 821118C4h */ case    9:  		/* mr R22, R3 */
		/* 821118C4h case    9:*/		regs.R22 = regs.R3;
		/* 821118C4h case    9:*/		return 0x821118C8;
		  /* 821118C8h */ case   10:  		/* lwzx R16, <#[R9 + R11]> */
		/* 821118C8h case   10:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821118C8h case   10:*/		return 0x821118CC;
		  /* 821118CCh */ case   11:  		/* lwzx R9, <#[R8 + R11]> */
		/* 821118CCh case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 821118CCh case   11:*/		return 0x821118D0;
		  /* 821118D0h */ case   12:  		/* lwz R8, <#[R16 + 4]> */
		/* 821118D0h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R16 + 0x00000004) );
		/* 821118D0h case   12:*/		return 0x821118D4;
		  /* 821118D4h */ case   13:  		/* lwz R17, <#[R9 + 48]> */
		/* 821118D4h case   13:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R9 + 0x00000030) );
		/* 821118D4h case   13:*/		return 0x821118D8;
		  /* 821118D8h */ case   14:  		/* rlwinm R9, R8, 2, 0, 29 */
		/* 821118D8h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 821118D8h case   14:*/		return 0x821118DC;
		  /* 821118DCh */ case   15:  		/* rlwinm R8, R17, 2, 0, 29 */
		/* 821118DCh case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R17);
		/* 821118DCh case   15:*/		return 0x821118E0;
		  /* 821118E0h */ case   16:  		/* lwzx R9, <#[R9 + R7]> */
		/* 821118E0h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 821118E0h case   16:*/		return 0x821118E4;
		  /* 821118E4h */ case   17:  		/* lwzx R23, <#[R8 + R11]> */
		/* 821118E4h case   17:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 821118E4h case   17:*/		return 0x821118E8;
		  /* 821118E8h */ case   18:  		/* lwz R11, <#[R9 + 4]> */
		/* 821118E8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 821118E8h case   18:*/		return 0x821118EC;
		  /* 821118ECh */ case   19:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 821118ECh case   19:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821118ECh case   19:*/		return 0x821118F0;
		  /* 821118F0h */ case   20:  		/* bc 12, CR0_EQ, 800 */
		/* 821118F0h case   20:*/		if ( regs.CR[0].eq ) { return 0x82111C10;  }
		/* 821118F0h case   20:*/		return 0x821118F4;
		  /* 821118F4h */ case   21:  		/* rlwinm. R11, R11, 0, 19, 19 */
		/* 821118F4h case   21:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R11,regs.R11);
		/* 821118F4h case   21:*/		return 0x821118F8;
		  /* 821118F8h */ case   22:  		/* bc 4, CR0_EQ, 792 */
		/* 821118F8h case   22:*/		if ( !regs.CR[0].eq ) { return 0x82111C10;  }
		/* 821118F8h case   22:*/		return 0x821118FC;
		  /* 821118FCh */ case   23:  		/* rlwinm R26, R10, 0, 0, 11 */
		/* 821118FCh case   23:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R26,regs.R10);
		/* 821118FCh case   23:*/		return 0x82111900;
		  /* 82111900h */ case   24:  		/* lwz R11, <#[R23]> */
		/* 82111900h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 82111900h case   24:*/		return 0x82111904;
		  /* 82111904h */ case   25:  		/* lwz R10, <#[R16]> */
		/* 82111904h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R16 + 0x00000000) );
		/* 82111904h case   25:*/		return 0x82111908;
		  /* 82111908h */ case   26:  		/* lis R8, 4096 */
		/* 82111908h case   26:*/		cpu::op::lis<0>(regs,&regs.R8,0x1000);
		/* 82111908h case   26:*/		return 0x8211190C;
		  /* 8211190Ch */ case   27:  		/* rlwinm R9, R11, 0, 27, 31 */
		/* 8211190Ch case   27:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R11);
		/* 8211190Ch case   27:*/		return 0x82111910;
		  /* 82111910h */ case   28:  		/* rlwinm R5, R10, 0, 25, 25 */
		/* 82111910h case   28:*/		cpu::op::rlwinm<0,0,25,25>(regs,&regs.R5,regs.R10);
		/* 82111910h case   28:*/		return 0x82111914;
		  /* 82111914h */ case   29:  		/* cmplw CR6, R26, R8 */
		/* 82111914h case   29:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R8);
		/* 82111914h case   29:*/		return 0x82111918;
		  /* 82111918h */ case   30:  		/* bc 4, CR6_EQ, 20 */
		/* 82111918h case   30:*/		if ( !regs.CR[6].eq ) { return 0x8211192C;  }
		/* 82111918h case   30:*/		return 0x8211191C;
		  /* 8211191Ch */ case   31:  		/* or R11, R10, R9 */
		/* 8211191Ch case   31:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R9);
		/* 8211191Ch case   31:*/		return 0x82111920;
		  /* 82111920h */ case   32:  		/* stw R17, <#[R16 + 48]> */
		/* 82111920h case   32:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R16 + 0x00000030) );
		/* 82111920h case   32:*/		return 0x82111924;
		  /* 82111924h */ case   33:  		/* stw R11, <#[R16]> */
		/* 82111924h case   33:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 82111924h case   33:*/		return 0x82111928;
		  /* 82111928h */ case   34:  		/* b 744 */
		/* 82111928h case   34:*/		return 0x82111C10;
		/* 82111928h case   34:*/		return 0x8211192C;
	}
	return 0x8211192C;
} // Block from 821118A0h-8211192Ch (35 instructions)

//////////////////////////////////////////////////////
// Block at 8211192Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211192C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211192C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211192C);
		  /* 8211192Ch */ case    0:  		/* lwz R10, <#[R16]> */
		/* 8211192Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R16 + 0x00000000) );
		/* 8211192Ch case    0:*/		return 0x82111930;
		  /* 82111930h */ case    1:  		/* rlwinm R11, R11, 0, 25, 25 */
		/* 82111930h case    1:*/		cpu::op::rlwinm<0,0,25,25>(regs,&regs.R11,regs.R11);
		/* 82111930h case    1:*/		return 0x82111934;
		  /* 82111934h */ case    2:  		/* lis R8, 4112 */
		/* 82111934h case    2:*/		cpu::op::lis<0>(regs,&regs.R8,0x1010);
		/* 82111934h case    2:*/		return 0x82111938;
		  /* 82111938h */ case    3:  		/* or R11, R11, R10 */
		/* 82111938h case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82111938h case    3:*/		return 0x8211193C;
		  /* 8211193Ch */ case    4:  		/* lis R3, 4144 */
		/* 8211193Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R3,0x1030);
		/* 8211193Ch case    4:*/		return 0x82111940;
		  /* 82111940h */ case    5:  		/* rlwinm. R31, R11, 0, 4, 6 */
		/* 82111940h case    5:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R31,regs.R11);
		/* 82111940h case    5:*/		return 0x82111944;
		  /* 82111944h */ case    6:  		/* stw R11, <#[R16]> */
		/* 82111944h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 82111944h case    6:*/		return 0x82111948;
		  /* 82111948h */ case    7:  		/* lis R10, 4160 */
		/* 82111948h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0x1040);
		/* 82111948h case    7:*/		return 0x8211194C;
		  /* 8211194Ch */ case    8:  		/* lis R7, 4304 */
		/* 8211194Ch case    8:*/		cpu::op::lis<0>(regs,&regs.R7,0x10D0);
		/* 8211194Ch case    8:*/		return 0x82111950;
		  /* 82111950h */ case    9:  		/* lis R6, 4320 */
		/* 82111950h case    9:*/		cpu::op::lis<0>(regs,&regs.R6,0x10E0);
		/* 82111950h case    9:*/		return 0x82111954;
		  /* 82111954h */ case   10:  		/* bc 4, CR0_EQ, 64 */
		/* 82111954h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82111994;  }
		/* 82111954h case   10:*/		return 0x82111958;
		  /* 82111958h */ case   11:  		/* cmplw CR6, R26, R8 */
		/* 82111958h case   11:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R8);
		/* 82111958h case   11:*/		return 0x8211195C;
		  /* 8211195Ch */ case   12:  		/* bc 12, CR6_EQ, 36 */
		/* 8211195Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x82111980;  }
		/* 8211195Ch case   12:*/		return 0x82111960;
		  /* 82111960h */ case   13:  		/* cmplw CR6, R26, R3 */
		/* 82111960h case   13:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R3);
		/* 82111960h case   13:*/		return 0x82111964;
		  /* 82111964h */ case   14:  		/* bc 12, CR6_EQ, 28 */
		/* 82111964h case   14:*/		if ( regs.CR[6].eq ) { return 0x82111980;  }
		/* 82111964h case   14:*/		return 0x82111968;
		  /* 82111968h */ case   15:  		/* cmplw CR6, R26, R10 */
		/* 82111968h case   15:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R10);
		/* 82111968h case   15:*/		return 0x8211196C;
		  /* 8211196Ch */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 8211196Ch case   16:*/		if ( regs.CR[6].eq ) { return 0x82111980;  }
		/* 8211196Ch case   16:*/		return 0x82111970;
		  /* 82111970h */ case   17:  		/* cmplw CR6, R26, R7 */
		/* 82111970h case   17:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R7);
		/* 82111970h case   17:*/		return 0x82111974;
		  /* 82111974h */ case   18:  		/* bc 12, CR6_EQ, 12 */
		/* 82111974h case   18:*/		if ( regs.CR[6].eq ) { return 0x82111980;  }
		/* 82111974h case   18:*/		return 0x82111978;
		  /* 82111978h */ case   19:  		/* cmplw CR6, R26, R6 */
		/* 82111978h case   19:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R6);
		/* 82111978h case   19:*/		return 0x8211197C;
		  /* 8211197Ch */ case   20:  		/* bc 4, CR6_EQ, 24 */
		/* 8211197Ch case   20:*/		if ( !regs.CR[6].eq ) { return 0x82111994;  }
		/* 8211197Ch case   20:*/		return 0x82111980;
	}
	return 0x82111980;
} // Block from 8211192Ch-82111980h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82111980h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111980);
		  /* 82111980h */ case    0:  		/* lwz R11, <#[R23]> */
		/* 82111980h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 82111980h case    0:*/		return 0x82111984;
		  /* 82111984h */ case    1:  		/* lwz R31, <#[R16]> */
		/* 82111984h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R16 + 0x00000000) );
		/* 82111984h case    1:*/		return 0x82111988;
		  /* 82111988h */ case    2:  		/* rlwinm R11, R11, 0, 4, 6 */
		/* 82111988h case    2:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82111988h case    2:*/		return 0x8211198C;
		  /* 8211198Ch */ case    3:  		/* or R11, R11, R31 */
		/* 8211198Ch case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8211198Ch case    3:*/		return 0x82111990;
		  /* 82111990h */ case    4:  		/* stw R11, <#[R16]> */
		/* 82111990h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 82111990h case    4:*/		return 0x82111994;
	}
	return 0x82111994;
} // Block from 82111980h-82111994h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82111994h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111994( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111994) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111994);
		  /* 82111994h */ case    0:  		/* lis R21, 4176 */
		/* 82111994h case    0:*/		cpu::op::lis<0>(regs,&regs.R21,0x1050);
		/* 82111994h case    0:*/		return 0x82111998;
		  /* 82111998h */ case    1:  		/* lis R20, 4208 */
		/* 82111998h case    1:*/		cpu::op::lis<0>(regs,&regs.R20,0x1070);
		/* 82111998h case    1:*/		return 0x8211199C;
		  /* 8211199Ch */ case    2:  		/* cmplw CR6, R26, R8 */
		/* 8211199Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R8);
		/* 8211199Ch case    2:*/		return 0x821119A0;
		  /* 821119A0h */ case    3:  		/* bc 12, CR6_EQ, 80 */
		/* 821119A0h case    3:*/		if ( regs.CR[6].eq ) { return 0x821119F0;  }
		/* 821119A0h case    3:*/		return 0x821119A4;
		  /* 821119A4h */ case    4:  		/* cmplw CR6, R26, R3 */
		/* 821119A4h case    4:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R3);
		/* 821119A4h case    4:*/		return 0x821119A8;
		  /* 821119A8h */ case    5:  		/* bc 12, CR6_EQ, 40 */
		/* 821119A8h case    5:*/		if ( regs.CR[6].eq ) { return 0x821119D0;  }
		/* 821119A8h case    5:*/		return 0x821119AC;
		  /* 821119ACh */ case    6:  		/* cmplw CR6, R26, R10 */
		/* 821119ACh case    6:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R10);
		/* 821119ACh case    6:*/		return 0x821119B0;
		  /* 821119B0h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 821119B0h case    7:*/		if ( regs.CR[6].eq ) { return 0x821119C4;  }
		/* 821119B0h case    7:*/		return 0x821119B4;
		  /* 821119B4h */ case    8:  		/* cmplw CR6, R26, R21 */
		/* 821119B4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R21);
		/* 821119B4h case    8:*/		return 0x821119B8;
		  /* 821119B8h */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 821119B8h case    9:*/		if ( regs.CR[6].eq ) { return 0x821119C4;  }
		/* 821119B8h case    9:*/		return 0x821119BC;
		  /* 821119BCh */ case   10:  		/* cmplw CR6, R26, R20 */
		/* 821119BCh case   10:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R20);
		/* 821119BCh case   10:*/		return 0x821119C0;
		  /* 821119C0h */ case   11:  		/* bc 4, CR6_EQ, 80 */
		/* 821119C0h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82111A10;  }
		/* 821119C0h case   11:*/		return 0x821119C4;
	}
	return 0x821119C4;
} // Block from 82111994h-821119C4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821119C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821119C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821119C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821119C4);
		  /* 821119C4h */ case    0:  		/* lwz R11, <#[R16]> */
		/* 821119C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 821119C4h case    0:*/		return 0x821119C8;
		  /* 821119C8h */ case    1:  		/* ori R11, R11, 4 */
		/* 821119C8h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821119C8h case    1:*/		return 0x821119CC;
		  /* 821119CCh */ case    2:  		/* b 64 */
		/* 821119CCh case    2:*/		return 0x82111A0C;
		/* 821119CCh case    2:*/		return 0x821119D0;
	}
	return 0x821119D0;
} // Block from 821119C4h-821119D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821119D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821119D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821119D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821119D0);
		  /* 821119D0h */ case    0:  		/* rlwinm. R11, R9, 0, 29, 29 */
		/* 821119D0h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R9);
		/* 821119D0h case    0:*/		return 0x821119D4;
		  /* 821119D4h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821119D4h case    1:*/		if ( regs.CR[0].eq ) { return 0x821119E0;  }
		/* 821119D4h case    1:*/		return 0x821119D8;
		  /* 821119D8h */ case    2:  		/* rlwinm. R11, R9, 0, 28, 28 */
		/* 821119D8h case    2:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R9);
		/* 821119D8h case    2:*/		return 0x821119DC;
		  /* 821119DCh */ case    3:  		/* bc 4, CR0_EQ, -24 */
		/* 821119DCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x821119C4;  }
		/* 821119DCh case    3:*/		return 0x821119E0;
	}
	return 0x821119E0;
} // Block from 821119D0h-821119E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821119E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821119E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821119E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821119E0);
		  /* 821119E0h */ case    0:  		/* lwz R11, <#[R16]> */
		/* 821119E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 821119E0h case    0:*/		return 0x821119E4;
		  /* 821119E4h */ case    1:  		/* rlwinm R31, R9, 0, 28, 29 */
		/* 821119E4h case    1:*/		cpu::op::rlwinm<0,0,28,29>(regs,&regs.R31,regs.R9);
		/* 821119E4h case    1:*/		return 0x821119E8;
		  /* 821119E8h */ case    2:  		/* or R11, R31, R11 */
		/* 821119E8h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 821119E8h case    2:*/		return 0x821119EC;
		  /* 821119ECh */ case    3:  		/* b 32 */
		/* 821119ECh case    3:*/		return 0x82111A0C;
		/* 821119ECh case    3:*/		return 0x821119F0;
	}
	return 0x821119F0;
} // Block from 821119E0h-821119F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821119F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821119F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821119F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821119F0);
		  /* 821119F0h */ case    0:  		/* rlwinm R11, R9, 31, 29, 29 */
		/* 821119F0h case    0:*/		cpu::op::rlwinm<0,31,29,29>(regs,&regs.R11,regs.R9);
		/* 821119F0h case    0:*/		return 0x821119F4;
		  /* 821119F4h */ case    1:  		/* lwz R31, <#[R16]> */
		/* 821119F4h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R16 + 0x00000000) );
		/* 821119F4h case    1:*/		return 0x821119F8;
		  /* 821119F8h */ case    2:  		/* rlwinm R30, R9, 1, 28, 28 */
		/* 821119F8h case    2:*/		cpu::op::rlwinm<0,1,28,28>(regs,&regs.R30,regs.R9);
		/* 821119F8h case    2:*/		return 0x821119FC;
		  /* 821119FCh */ case    3:  		/* rlwinm R29, R9, 0, 30, 27 */
		/* 821119FCh case    3:*/		cpu::op::rlwinm<0,0,30,27>(regs,&regs.R29,regs.R9);
		/* 821119FCh case    3:*/		return 0x82111A00;
		  /* 82111A00h */ case    4:  		/* or R11, R11, R30 */
		/* 82111A00h case    4:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82111A00h case    4:*/		return 0x82111A04;
		  /* 82111A04h */ case    5:  		/* or R11, R11, R29 */
		/* 82111A04h case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 82111A04h case    5:*/		return 0x82111A08;
		  /* 82111A08h */ case    6:  		/* or R11, R11, R31 */
		/* 82111A08h case    6:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82111A08h case    6:*/		return 0x82111A0C;
	}
	return 0x82111A0C;
} // Block from 821119F0h-82111A0Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82111A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111A0C);
		  /* 82111A0Ch */ case    0:  		/* stw R11, <#[R16]> */
		/* 82111A0Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 82111A0Ch case    0:*/		return 0x82111A10;
	}
	return 0x82111A10;
} // Block from 82111A0Ch-82111A10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82111A10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111A10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111A10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111A10);
		  /* 82111A10h */ case    0:  		/* lwz R11, <#[R23 + 4]> */
		/* 82111A10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82111A10h case    0:*/		return 0x82111A14;
		  /* 82111A14h */ case    1:  		/* lwz R18, <#[R22 + 16]> */
		/* 82111A14h case    1:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R22 + 0x00000010) );
		/* 82111A14h case    1:*/		return 0x82111A18;
		  /* 82111A18h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82111A18h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82111A18h case    2:*/		return 0x82111A1C;
		  /* 82111A1Ch */ case    3:  		/* lwzx R11, <#[R11 + R18]> */
		/* 82111A1Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R18 + 0x00000000) );
		/* 82111A1Ch case    3:*/		return 0x82111A20;
		  /* 82111A20h */ case    4:  		/* lwz R11, <#[R11 + 4]> */
		/* 82111A20h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82111A20h case    4:*/		return 0x82111A24;
		  /* 82111A24h */ case    5:  		/* rlwinm. R31, R11, 0, 23, 23 */
		/* 82111A24h case    5:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R31,regs.R11);
		/* 82111A24h case    5:*/		return 0x82111A28;
		  /* 82111A28h */ case    6:  		/* bc 12, CR0_EQ, 684 */
		/* 82111A28h case    6:*/		if ( regs.CR[0].eq ) { return 0x82111CD4;  }
		/* 82111A28h case    6:*/		return 0x82111A2C;
		  /* 82111A2Ch */ case    7:  		/* lwz R31, <#[R23 + 8]> */
		/* 82111A2Ch case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R23 + 0x00000008) );
		/* 82111A2Ch case    7:*/		return 0x82111A30;
		  /* 82111A30h */ case    8:  		/* cmpwi CR6, R31, -1 */
		/* 82111A30h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R31,0xFFFFFFFF);
		/* 82111A30h case    8:*/		return 0x82111A34;
		  /* 82111A34h */ case    9:  		/* bc 4, CR6_EQ, 672 */
		/* 82111A34h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82111CD4;  }
		/* 82111A34h case    9:*/		return 0x82111A38;
		  /* 82111A38h */ case   10:  		/* lis R11, 4224 */
		/* 82111A38h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0x1080);
		/* 82111A38h case   10:*/		return 0x82111A3C;
		  /* 82111A3Ch */ case   11:  		/* cmplw CR6, R26, R11 */
		/* 82111A3Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 82111A3Ch case   11:*/		return 0x82111A40;
		  /* 82111A40h */ case   12:  		/* bc 12, CR6_GT, 368 */
		/* 82111A40h case   12:*/		if ( regs.CR[6].gt ) { return 0x82111BB0;  }
		/* 82111A40h case   12:*/		return 0x82111A44;
		  /* 82111A44h */ case   13:  		/* bc 12, CR6_EQ, 352 */
		/* 82111A44h case   13:*/		if ( regs.CR[6].eq ) { return 0x82111BA4;  }
		/* 82111A44h case   13:*/		return 0x82111A48;
		  /* 82111A48h */ case   14:  		/* cmplw CR6, R26, R8 */
		/* 82111A48h case   14:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R8);
		/* 82111A48h case   14:*/		return 0x82111A4C;
		  /* 82111A4Ch */ case   15:  		/* bc 12, CR6_EQ, 332 */
		/* 82111A4Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x82111B98;  }
		/* 82111A4Ch case   15:*/		return 0x82111A50;
		  /* 82111A50h */ case   16:  		/* cmplw CR6, R26, R3 */
		/* 82111A50h case   16:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R3);
		/* 82111A50h case   16:*/		return 0x82111A54;
		  /* 82111A54h */ case   17:  		/* bc 12, CR6_EQ, 276 */
		/* 82111A54h case   17:*/		if ( regs.CR[6].eq ) { return 0x82111B68;  }
		/* 82111A54h case   17:*/		return 0x82111A58;
		  /* 82111A58h */ case   18:  		/* cmplw CR6, R26, R10 */
		/* 82111A58h case   18:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R10);
		/* 82111A58h case   18:*/		return 0x82111A5C;
		  /* 82111A5Ch */ case   19:  		/* bc 12, CR6_EQ, 232 */
		/* 82111A5Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x82111B44;  }
		/* 82111A5Ch case   19:*/		return 0x82111A60;
		  /* 82111A60h */ case   20:  		/* cmplw CR6, R26, R21 */
		/* 82111A60h case   20:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R21);
		/* 82111A60h case   20:*/		return 0x82111A64;
		  /* 82111A64h */ case   21:  		/* bc 12, CR6_EQ, 204 */
		/* 82111A64h case   21:*/		if ( regs.CR[6].eq ) { return 0x82111B30;  }
		/* 82111A64h case   21:*/		return 0x82111A68;
		  /* 82111A68h */ case   22:  		/* lis R11, 4192 */
		/* 82111A68h case   22:*/		cpu::op::lis<0>(regs,&regs.R11,0x1060);
		/* 82111A68h case   22:*/		return 0x82111A6C;
		  /* 82111A6Ch */ case   23:  		/* cmplw CR6, R26, R11 */
		/* 82111A6Ch case   23:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 82111A6Ch case   23:*/		return 0x82111A70;
		  /* 82111A70h */ case   24:  		/* bc 12, CR6_EQ, 108 */
		/* 82111A70h case   24:*/		if ( regs.CR[6].eq ) { return 0x82111ADC;  }
		/* 82111A70h case   24:*/		return 0x82111A74;
		  /* 82111A74h */ case   25:  		/* cmplw CR6, R26, R20 */
		/* 82111A74h case   25:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R20);
		/* 82111A74h case   25:*/		return 0x82111A78;
		  /* 82111A78h */ case   26:  		/* bc 4, CR6_EQ, 408 */
		/* 82111A78h case   26:*/		if ( !regs.CR[6].eq ) { return 0x82111C10;  }
		/* 82111A78h case   26:*/		return 0x82111A7C;
		  /* 82111A7Ch */ case   27:  		/* cmplwi CR6, R5, 0 */
		/* 82111A7Ch case   27:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82111A7Ch case   27:*/		return 0x82111A80;
		  /* 82111A80h */ case   28:  		/* bc 4, CR6_EQ, 80 */
		/* 82111A80h case   28:*/		if ( !regs.CR[6].eq ) { return 0x82111AD0;  }
		/* 82111A80h case   28:*/		return 0x82111A84;
		  /* 82111A84h */ case   29:  		/* lis R11, -32256 */
		/* 82111A84h case   29:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82111A84h case   29:*/		return 0x82111A88;
		  /* 82111A88h */ case   30:  		/* lfd FR0, <#[R23 + 32]> */
		/* 82111A88h case   30:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R23 + 0x00000020) );
		/* 82111A88h case   30:*/		return 0x82111A8C;
		  /* 82111A8Ch */ case   31:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 82111A8Ch case   31:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 82111A8Ch case   31:*/		return 0x82111A90;
		  /* 82111A90h */ case   32:  		/* fcmpu CR6, FR0, FR31 */
		/* 82111A90h case   32:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82111A90h case   32:*/		return 0x82111A94;
		  /* 82111A94h */ case   33:  		/* bc 4, CR6_LT, 20 */
		/* 82111A94h case   33:*/		if ( !regs.CR[6].lt ) { return 0x82111AA8;  }
		/* 82111A94h case   33:*/		return 0x82111A98;
		  /* 82111A98h */ case   34:  		/* lis R11, -32254 */
		/* 82111A98h case   34:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 82111A98h case   34:*/		return 0x82111A9C;
		  /* 82111A9Ch */ case   35:  		/* li R5, 4003 */
		/* 82111A9Ch case   35:*/		cpu::op::li<0>(regs,&regs.R5,0xFA3);
		/* 82111A9Ch case   35:*/		return 0x82111AA0;
		  /* 82111AA0h */ case   36:  		/* addi R6, R11, -13792 */
		/* 82111AA0h case   36:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCA20);
		/* 82111AA0h case   36:*/		return 0x82111AA4;
		  /* 82111AA4h */ case   37:  		/* b 24 */
		/* 82111AA4h case   37:*/		return 0x82111ABC;
		/* 82111AA4h case   37:*/		return 0x82111AA8;
	}
	return 0x82111AA8;
} // Block from 82111A10h-82111AA8h (38 instructions)

//////////////////////////////////////////////////////
// Block at 82111AA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111AA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111AA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111AA8);
		  /* 82111AA8h */ case    0:  		/* fcmpu CR6, FR0, FR31 */
		/* 82111AA8h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82111AA8h case    0:*/		return 0x82111AAC;
		  /* 82111AACh */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 82111AACh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82111AD0;  }
		/* 82111AACh case    1:*/		return 0x82111AB0;
		  /* 82111AB0h */ case    2:  		/* lis R11, -32254 */
		/* 82111AB0h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 82111AB0h case    2:*/		return 0x82111AB4;
		  /* 82111AB4h */ case    3:  		/* li R5, 4001 */
		/* 82111AB4h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0xFA1);
		/* 82111AB4h case    3:*/		return 0x82111AB8;
		  /* 82111AB8h */ case    4:  		/* addi R6, R11, -13812 */
		/* 82111AB8h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCA0C);
		/* 82111AB8h case    4:*/		return 0x82111ABC;
	}
	return 0x82111ABC;
} // Block from 82111AA8h-82111ABCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82111ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111ABC);
		  /* 82111ABCh */ case    0:  		/* mr R3, R22 */
		/* 82111ABCh case    0:*/		regs.R3 = regs.R22;
		/* 82111ABCh case    0:*/		return 0x82111AC0;
		  /* 82111AC0h */ case    1:  		/* lwz R4, <#[R4 + 60]> */
		/* 82111AC0h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x0000003C) );
		/* 82111AC0h case    1:*/		return 0x82111AC4;
		  /* 82111AC4h */ case    2:  		/* bl -13204 */
		/* 82111AC4h case    2:*/		regs.LR = 0x82111AC8; return 0x8210E730;
		/* 82111AC4h case    2:*/		return 0x82111AC8;
		  /* 82111AC8h */ case    3:  		/* fmr FR1, FR31 */
		/* 82111AC8h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82111AC8h case    3:*/		return 0x82111ACC;
		  /* 82111ACCh */ case    4:  		/* b 300 */
		/* 82111ACCh case    4:*/		return 0x82111BF8;
		/* 82111ACCh case    4:*/		return 0x82111AD0;
	}
	return 0x82111AD0;
} // Block from 82111ABCh-82111AD0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82111AD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111AD0);
		  /* 82111AD0h */ case    0:  		/* lfd FR0, <#[R23 + 32]> */
		/* 82111AD0h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R23 + 0x00000020) );
		/* 82111AD0h case    0:*/		return 0x82111AD4;
		  /* 82111AD4h */ case    1:  		/* fsqrt FR13, FR0 */
		/* 82111AD4h case    1:*/		cpu::op::fsqrt<0>(regs,&regs.FR13,regs.FR0);
		/* 82111AD4h case    1:*/		return 0x82111AD8;
		  /* 82111AD8h */ case    2:  		/* b 176 */
		/* 82111AD8h case    2:*/		return 0x82111B88;
		/* 82111AD8h case    2:*/		return 0x82111ADC;
	}
	return 0x82111ADC;
} // Block from 82111AD0h-82111ADCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82111ADCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111ADC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111ADC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111ADC);
		  /* 82111ADCh */ case    0:  		/* lis R11, -32256 */
		/* 82111ADCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82111ADCh case    0:*/		return 0x82111AE0;
		  /* 82111AE0h */ case    1:  		/* cmplwi CR6, R5, 0 */
		/* 82111AE0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82111AE0h case    1:*/		return 0x82111AE4;
		  /* 82111AE4h */ case    2:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 82111AE4h case    2:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 82111AE4h case    2:*/		return 0x82111AE8;
		  /* 82111AE8h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 82111AE8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82111AF8;  }
		/* 82111AE8h case    3:*/		return 0x82111AEC;
		  /* 82111AECh */ case    4:  		/* lfd FR0, <#[R23 + 32]> */
		/* 82111AECh case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R23 + 0x00000020) );
		/* 82111AECh case    4:*/		return 0x82111AF0;
		  /* 82111AF0h */ case    5:  		/* fcmpu CR6, FR0, FR31 */
		/* 82111AF0h case    5:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82111AF0h case    5:*/		return 0x82111AF4;
		  /* 82111AF4h */ case    6:  		/* bc 12, CR6_EQ, 284 */
		/* 82111AF4h case    6:*/		if ( regs.CR[6].eq ) { return 0x82111C10;  }
		/* 82111AF4h case    6:*/		return 0x82111AF8;
	}
	return 0x82111AF8;
} // Block from 82111ADCh-82111AF8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82111AF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111AF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111AF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111AF8);
		  /* 82111AF8h */ case    0:  		/* lfd FR1, <#[R23 + 32]> */
		/* 82111AF8h case    0:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R23 + 0x00000020) );
		/* 82111AF8h case    0:*/		return 0x82111AFC;
		  /* 82111AFCh */ case    1:  		/* fcmpu CR6, FR1, FR31 */
		/* 82111AFCh case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR31);
		/* 82111AFCh case    1:*/		return 0x82111B00;
		  /* 82111B00h */ case    2:  		/* bc 4, CR6_LT, 20 */
		/* 82111B00h case    2:*/		if ( !regs.CR[6].lt ) { return 0x82111B14;  }
		/* 82111B00h case    2:*/		return 0x82111B04;
		  /* 82111B04h */ case    3:  		/* lis R11, -32254 */
		/* 82111B04h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 82111B04h case    3:*/		return 0x82111B08;
		  /* 82111B08h */ case    4:  		/* li R5, 4002 */
		/* 82111B08h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0xFA2);
		/* 82111B08h case    4:*/		return 0x82111B0C;
		  /* 82111B0Ch */ case    5:  		/* addi R6, R11, -13836 */
		/* 82111B0Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFC9F4);
		/* 82111B0Ch case    5:*/		return 0x82111B10;
		  /* 82111B10h */ case    6:  		/* b -84 */
		/* 82111B10h case    6:*/		return 0x82111ABC;
		/* 82111B10h case    6:*/		return 0x82111B14;
	}
	return 0x82111B14;
} // Block from 82111AF8h-82111B14h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82111B14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111B14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111B14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111B14);
		  /* 82111B14h */ case    0:  		/* bl -499004 */
		/* 82111B14h case    0:*/		regs.LR = 0x82111B18; return 0x82097DD8;
		/* 82111B14h case    0:*/		return 0x82111B18;
		  /* 82111B18h */ case    1:  		/* lis R11, -32255 */
		/* 82111B18h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82111B18h case    1:*/		return 0x82111B1C;
		  /* 82111B1Ch */ case    2:  		/* fmr FR31, FR1 */
		/* 82111B1Ch case    2:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 82111B1Ch case    2:*/		return 0x82111B20;
		  /* 82111B20h */ case    3:  		/* lfd FR1, <#[R11 - 24504]> */
		/* 82111B20h case    3:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0xFFFFA048) );
		/* 82111B20h case    3:*/		return 0x82111B24;
		  /* 82111B24h */ case    4:  		/* bl -499020 */
		/* 82111B24h case    4:*/		regs.LR = 0x82111B28; return 0x82097DD8;
		/* 82111B24h case    4:*/		return 0x82111B28;
		  /* 82111B28h */ case    5:  		/* fdiv FR1, FR31, FR1 */
		/* 82111B28h case    5:*/		cpu::op::fdiv<0>(regs,&regs.FR1,regs.FR31,regs.FR1);
		/* 82111B28h case    5:*/		return 0x82111B2C;
		  /* 82111B2Ch */ case    6:  		/* b 204 */
		/* 82111B2Ch case    6:*/		return 0x82111BF8;
		/* 82111B2Ch case    6:*/		return 0x82111B30;
	}
	return 0x82111B30;
} // Block from 82111B14h-82111B30h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82111B30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111B30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111B30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111B30);
		  /* 82111B30h */ case    0:  		/* lis R11, -32255 */
		/* 82111B30h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82111B30h case    0:*/		return 0x82111B34;
		  /* 82111B34h */ case    1:  		/* lfd FR2, <#[R23 + 32]> */
		/* 82111B34h case    1:*/		cpu::mem::load64f( regs, &regs.FR2, (uint32)(regs.R23 + 0x00000020) );
		/* 82111B34h case    1:*/		return 0x82111B38;
		  /* 82111B38h */ case    2:  		/* lfd FR1, <#[R11 - 24504]> */
		/* 82111B38h case    2:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0xFFFFA048) );
		/* 82111B38h case    2:*/		return 0x82111B3C;
		  /* 82111B3Ch */ case    3:  		/* bl -521604 */
		/* 82111B3Ch case    3:*/		regs.LR = 0x82111B40; return 0x820925B8;
		/* 82111B3Ch case    3:*/		return 0x82111B40;
		  /* 82111B40h */ case    4:  		/* b 184 */
		/* 82111B40h case    4:*/		return 0x82111BF8;
		/* 82111B40h case    4:*/		return 0x82111B44;
	}
	return 0x82111B44;
} // Block from 82111B30h-82111B44h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82111B44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111B44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111B44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111B44);
		  /* 82111B44h */ case    0:  		/* lfd FR1, <#[R23 + 32]> */
		/* 82111B44h case    0:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R23 + 0x00000020) );
		/* 82111B44h case    0:*/		return 0x82111B48;
		  /* 82111B48h */ case    1:  		/* bl -498552 */
		/* 82111B48h case    1:*/		regs.LR = 0x82111B4C; return 0x82097FD0;
		/* 82111B48h case    1:*/		return 0x82111B4C;
		  /* 82111B4Ch */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 82111B4Ch case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82111B4Ch case    2:*/		return 0x82111B50;
		  /* 82111B50h */ case    3:  		/* bc 12, CR0_EQ, 160 */
		/* 82111B50h case    3:*/		if ( regs.CR[0].eq ) { return 0x82111BF0;  }
		/* 82111B50h case    3:*/		return 0x82111B54;
		  /* 82111B54h */ case    4:  		/* lfd FR1, <#[R23 + 32]> */
		/* 82111B54h case    4:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R23 + 0x00000020) );
		/* 82111B54h case    4:*/		return 0x82111B58;
		  /* 82111B58h */ case    5:  		/* bl -523384 */
		/* 82111B58h case    5:*/		regs.LR = 0x82111B5C; return 0x82091EE0;
		/* 82111B58h case    5:*/		return 0x82111B5C;
		  /* 82111B5Ch */ case    6:  		/* lfd FR0, <#[R23 + 32]> */
		/* 82111B5Ch case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R23 + 0x00000020) );
		/* 82111B5Ch case    6:*/		return 0x82111B60;
		  /* 82111B60h */ case    7:  		/* fsub FR1, FR0, FR1 */
		/* 82111B60h case    7:*/		cpu::op::fsub<0>(regs,&regs.FR1,regs.FR0,regs.FR1);
		/* 82111B60h case    7:*/		return 0x82111B64;
		  /* 82111B64h */ case    8:  		/* b 148 */
		/* 82111B64h case    8:*/		return 0x82111BF8;
		/* 82111B64h case    8:*/		return 0x82111B68;
	}
	return 0x82111B68;
} // Block from 82111B44h-82111B68h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82111B68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111B68);
		  /* 82111B68h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 82111B68h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82111B68h case    0:*/		return 0x82111B6C;
		  /* 82111B6Ch */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 82111B6Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82111B84;  }
		/* 82111B6Ch case    1:*/		return 0x82111B70;
		  /* 82111B70h */ case    2:  		/* lis R11, -32256 */
		/* 82111B70h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82111B70h case    2:*/		return 0x82111B74;
		  /* 82111B74h */ case    3:  		/* lfd FR0, <#[R23 + 32]> */
		/* 82111B74h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R23 + 0x00000020) );
		/* 82111B74h case    3:*/		return 0x82111B78;
		  /* 82111B78h */ case    4:  		/* lfd FR1, <#[R11 + 1808]> */
		/* 82111B78h case    4:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000710) );
		/* 82111B78h case    4:*/		return 0x82111B7C;
		  /* 82111B7Ch */ case    5:  		/* fcmpu CR6, FR0, FR1 */
		/* 82111B7Ch case    5:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR1);
		/* 82111B7Ch case    5:*/		return 0x82111B80;
		  /* 82111B80h */ case    6:  		/* bc 12, CR6_EQ, 120 */
		/* 82111B80h case    6:*/		if ( regs.CR[6].eq ) { return 0x82111BF8;  }
		/* 82111B80h case    6:*/		return 0x82111B84;
	}
	return 0x82111B84;
} // Block from 82111B68h-82111B84h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82111B84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111B84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111B84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111B84);
		  /* 82111B84h */ case    0:  		/* lfd FR13, <#[R23 + 32]> */
		/* 82111B84h case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R23 + 0x00000020) );
		/* 82111B84h case    0:*/		return 0x82111B88;
	}
	return 0x82111B88;
} // Block from 82111B84h-82111B88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82111B88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111B88);
		  /* 82111B88h */ case    0:  		/* lis R11, -32256 */
		/* 82111B88h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82111B88h case    0:*/		return 0x82111B8C;
		  /* 82111B8Ch */ case    1:  		/* lfd FR0, <#[R11 + 1848]> */
		/* 82111B8Ch case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000738) );
		/* 82111B8Ch case    1:*/		return 0x82111B90;
		  /* 82111B90h */ case    2:  		/* fdiv FR1, FR0, FR13 */
		/* 82111B90h case    2:*/		cpu::op::fdiv<0>(regs,&regs.FR1,regs.FR0,regs.FR13);
		/* 82111B90h case    2:*/		return 0x82111B94;
		  /* 82111B94h */ case    3:  		/* b 100 */
		/* 82111B94h case    3:*/		return 0x82111BF8;
		/* 82111B94h case    3:*/		return 0x82111B98;
	}
	return 0x82111B98;
} // Block from 82111B88h-82111B98h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82111B98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111B98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111B98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111B98);
		  /* 82111B98h */ case    0:  		/* lfd FR0, <#[R23 + 32]> */
		/* 82111B98h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R23 + 0x00000020) );
		/* 82111B98h case    0:*/		return 0x82111B9C;
		  /* 82111B9Ch */ case    1:  		/* fneg FR1, FR0 */
		/* 82111B9Ch case    1:*/		cpu::op::fneg<0>(regs,&regs.FR1,regs.FR0);
		/* 82111B9Ch case    1:*/		return 0x82111BA0;
		  /* 82111BA0h */ case    2:  		/* b 88 */
		/* 82111BA0h case    2:*/		return 0x82111BF8;
		/* 82111BA0h case    2:*/		return 0x82111BA4;
	}
	return 0x82111BA4;
} // Block from 82111B98h-82111BA4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82111BA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111BA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111BA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111BA4);
		  /* 82111BA4h */ case    0:  		/* lfd FR1, <#[R23 + 32]> */
		/* 82111BA4h case    0:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R23 + 0x00000020) );
		/* 82111BA4h case    0:*/		return 0x82111BA8;
		  /* 82111BA8h */ case    1:  		/* bl -528608 */
		/* 82111BA8h case    1:*/		regs.LR = 0x82111BAC; return 0x82090AC8;
		/* 82111BA8h case    1:*/		return 0x82111BAC;
		  /* 82111BACh */ case    2:  		/* b 76 */
		/* 82111BACh case    2:*/		return 0x82111BF8;
		/* 82111BACh case    2:*/		return 0x82111BB0;
	}
	return 0x82111BB0;
} // Block from 82111BA4h-82111BB0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82111BB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111BB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111BB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111BB0);
		  /* 82111BB0h */ case    0:  		/* lis R11, 4240 */
		/* 82111BB0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x1090);
		/* 82111BB0h case    0:*/		return 0x82111BB4;
		  /* 82111BB4h */ case    1:  		/* cmplw CR6, R26, R11 */
		/* 82111BB4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 82111BB4h case    1:*/		return 0x82111BB8;
		  /* 82111BB8h */ case    2:  		/* bc 12, CR6_EQ, 272 */
		/* 82111BB8h case    2:*/		if ( regs.CR[6].eq ) { return 0x82111CC8;  }
		/* 82111BB8h case    2:*/		return 0x82111BBC;
		  /* 82111BBCh */ case    3:  		/* lis R11, 4256 */
		/* 82111BBCh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0x10A0);
		/* 82111BBCh case    3:*/		return 0x82111BC0;
		  /* 82111BC0h */ case    4:  		/* cmplw CR6, R26, R11 */
		/* 82111BC0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 82111BC0h case    4:*/		return 0x82111BC4;
		  /* 82111BC4h */ case    5:  		/* bc 12, CR6_EQ, 188 */
		/* 82111BC4h case    5:*/		if ( regs.CR[6].eq ) { return 0x82111C80;  }
		/* 82111BC4h case    5:*/		return 0x82111BC8;
		  /* 82111BC8h */ case    6:  		/* lis R11, 4272 */
		/* 82111BC8h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0x10B0);
		/* 82111BC8h case    6:*/		return 0x82111BCC;
		  /* 82111BCCh */ case    7:  		/* cmplw CR6, R26, R11 */
		/* 82111BCCh case    7:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 82111BCCh case    7:*/		return 0x82111BD0;
		  /* 82111BD0h */ case    8:  		/* bc 12, CR6_EQ, 92 */
		/* 82111BD0h case    8:*/		if ( regs.CR[6].eq ) { return 0x82111C2C;  }
		/* 82111BD0h case    8:*/		return 0x82111BD4;
		  /* 82111BD4h */ case    9:  		/* lis R11, 4288 */
		/* 82111BD4h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0x10C0);
		/* 82111BD4h case    9:*/		return 0x82111BD8;
		  /* 82111BD8h */ case   10:  		/* cmplw CR6, R26, R11 */
		/* 82111BD8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 82111BD8h case   10:*/		return 0x82111BDC;
		  /* 82111BDCh */ case   11:  		/* bc 12, CR6_EQ, 68 */
		/* 82111BDCh case   11:*/		if ( regs.CR[6].eq ) { return 0x82111C20;  }
		/* 82111BDCh case   11:*/		return 0x82111BE0;
		  /* 82111BE0h */ case   12:  		/* cmplw CR6, R26, R7 */
		/* 82111BE0h case   12:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R7);
		/* 82111BE0h case   12:*/		return 0x82111BE4;
		  /* 82111BE4h */ case   13:  		/* bc 12, CR6_EQ, 12 */
		/* 82111BE4h case   13:*/		if ( regs.CR[6].eq ) { return 0x82111BF0;  }
		/* 82111BE4h case   13:*/		return 0x82111BE8;
		  /* 82111BE8h */ case   14:  		/* cmplw CR6, R26, R6 */
		/* 82111BE8h case   14:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R6);
		/* 82111BE8h case   14:*/		return 0x82111BEC;
		  /* 82111BECh */ case   15:  		/* bc 4, CR6_EQ, 36 */
		/* 82111BECh case   15:*/		if ( !regs.CR[6].eq ) { return 0x82111C10;  }
		/* 82111BECh case   15:*/		return 0x82111BF0;
	}
	return 0x82111BF0;
} // Block from 82111BB0h-82111BF0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82111BF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111BF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111BF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111BF0);
		  /* 82111BF0h */ case    0:  		/* lis R11, -32256 */
		/* 82111BF0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82111BF0h case    0:*/		return 0x82111BF4;
		  /* 82111BF4h */ case    1:  		/* lfd FR1, <#[R11 + 1808]> */
		/* 82111BF4h case    1:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000710) );
		/* 82111BF4h case    1:*/		return 0x82111BF8;
	}
	return 0x82111BF8;
} // Block from 82111BF0h-82111BF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82111BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111BF8);
		  /* 82111BF8h */ case    0:  		/* li R6, 0 */
		/* 82111BF8h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82111BF8h case    0:*/		return 0x82111BFC;
		  /* 82111BFCh */ case    1:  		/* lwz R4, <#[R22 + 120]> */
		/* 82111BFCh case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R22 + 0x00000078) );
		/* 82111BFCh case    1:*/		return 0x82111C00;
		  /* 82111C00h */ case    2:  		/* li R5, 0 */
		/* 82111C00h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82111C00h case    2:*/		return 0x82111C04;
		  /* 82111C04h */ case    3:  		/* mr R3, R22 */
		/* 82111C04h case    3:*/		regs.R3 = regs.R22;
		/* 82111C04h case    3:*/		return 0x82111C08;
		  /* 82111C08h */ case    4:  		/* bl -84448 */
		/* 82111C08h case    4:*/		regs.LR = 0x82111C0C; return 0x820FD228;
		/* 82111C08h case    4:*/		return 0x82111C0C;
		  /* 82111C0Ch */ case    5:  		/* stw R3, <#[R16 + 48]> */
		/* 82111C0Ch case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R16 + 0x00000030) );
		/* 82111C0Ch case    5:*/		return 0x82111C10;
	}
	return 0x82111C10;
} // Block from 82111BF8h-82111C10h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82111C10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111C10);
		  /* 82111C10h */ case    0:  		/* li R3, 0 */
		/* 82111C10h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82111C10h case    0:*/		return 0x82111C14;
		  /* 82111C14h */ case    1:  		/* addi R1, R1, 272 */
		/* 82111C14h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x110);
		/* 82111C14h case    1:*/		return 0x82111C18;
		  /* 82111C18h */ case    2:  		/* lfd FR31, <#[R1 - 152]> */
		/* 82111C18h case    2:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF68) );
		/* 82111C18h case    2:*/		return 0x82111C1C;
		  /* 82111C1Ch */ case    3:  		/* b -526760 */
		/* 82111C1Ch case    3:*/		return 0x82091274;
		/* 82111C1Ch case    3:*/		return 0x82111C20;
	}
	return 0x82111C20;
} // Block from 82111C10h-82111C20h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82111C20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111C20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111C20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111C20);
		  /* 82111C20h */ case    0:  		/* lfd FR1, <#[R23 + 32]> */
		/* 82111C20h case    0:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R23 + 0x00000020) );
		/* 82111C20h case    0:*/		return 0x82111C24;
		  /* 82111C24h */ case    1:  		/* bl 1401524 */
		/* 82111C24h case    1:*/		regs.LR = 0x82111C28; return 0x82267ED8;
		/* 82111C24h case    1:*/		return 0x82111C28;
		  /* 82111C28h */ case    2:  		/* b -48 */
		/* 82111C28h case    2:*/		return 0x82111BF8;
		/* 82111C28h case    2:*/		return 0x82111C2C;
	}
	return 0x82111C2C;
} // Block from 82111C20h-82111C2Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82111C2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111C2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111C2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111C2C);
		  /* 82111C2Ch */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 82111C2Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82111C2Ch case    0:*/		return 0x82111C30;
		  /* 82111C30h */ case    1:  		/* bc 4, CR6_EQ, 68 */
		/* 82111C30h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82111C74;  }
		/* 82111C30h case    1:*/		return 0x82111C34;
		  /* 82111C34h */ case    2:  		/* lis R11, -32255 */
		/* 82111C34h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82111C34h case    2:*/		return 0x82111C38;
		  /* 82111C38h */ case    3:  		/* lfd FR0, <#[R23 + 32]> */
		/* 82111C38h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R23 + 0x00000020) );
		/* 82111C38h case    3:*/		return 0x82111C3C;
		  /* 82111C3Ch */ case    4:  		/* lfd FR13, <#[R11 - 24488]> */
		/* 82111C3Ch case    4:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0xFFFFA058) );
		/* 82111C3Ch case    4:*/		return 0x82111C40;
		  /* 82111C40h */ case    5:  		/* fcmpu CR6, FR0, FR13 */
		/* 82111C40h case    5:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82111C40h case    5:*/		return 0x82111C44;
		  /* 82111C44h */ case    6:  		/* bc 12, CR6_LT, 20 */
		/* 82111C44h case    6:*/		if ( regs.CR[6].lt ) { return 0x82111C58;  }
		/* 82111C44h case    6:*/		return 0x82111C48;
		  /* 82111C48h */ case    7:  		/* lis R11, -32256 */
		/* 82111C48h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82111C48h case    7:*/		return 0x82111C4C;
		  /* 82111C4Ch */ case    8:  		/* lfd FR13, <#[R11 + 1848]> */
		/* 82111C4Ch case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000738) );
		/* 82111C4Ch case    8:*/		return 0x82111C50;
		  /* 82111C50h */ case    9:  		/* fcmpu CR6, FR0, FR13 */
		/* 82111C50h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82111C50h case    9:*/		return 0x82111C54;
		  /* 82111C54h */ case   10:  		/* bc 4, CR6_GT, 32 */
		/* 82111C54h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82111C74;  }
		/* 82111C54h case   10:*/		return 0x82111C58;
	}
	return 0x82111C58;
} // Block from 82111C2Ch-82111C58h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82111C58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111C58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111C58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111C58);
		  /* 82111C58h */ case    0:  		/* lis R11, -32254 */
		/* 82111C58h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 82111C58h case    0:*/		return 0x82111C5C;
		  /* 82111C5Ch */ case    1:  		/* li R5, 4006 */
		/* 82111C5Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0xFA6);
		/* 82111C5Ch case    1:*/		return 0x82111C60;
		  /* 82111C60h */ case    2:  		/* addi R6, R11, -13860 */
		/* 82111C60h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFC9DC);
		/* 82111C60h case    2:*/		return 0x82111C64;
		  /* 82111C64h */ case    3:  		/* mr R3, R22 */
		/* 82111C64h case    3:*/		regs.R3 = regs.R22;
		/* 82111C64h case    3:*/		return 0x82111C68;
		  /* 82111C68h */ case    4:  		/* lwz R4, <#[R4 + 60]> */
		/* 82111C68h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x0000003C) );
		/* 82111C68h case    4:*/		return 0x82111C6C;
		  /* 82111C6Ch */ case    5:  		/* bl -13628 */
		/* 82111C6Ch case    5:*/		regs.LR = 0x82111C70; return 0x8210E730;
		/* 82111C6Ch case    5:*/		return 0x82111C70;
		  /* 82111C70h */ case    6:  		/* b -128 */
		/* 82111C70h case    6:*/		return 0x82111BF0;
		/* 82111C70h case    6:*/		return 0x82111C74;
	}
	return 0x82111C74;
} // Block from 82111C58h-82111C74h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82111C74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111C74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111C74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111C74);
		  /* 82111C74h */ case    0:  		/* lfd FR1, <#[R23 + 32]> */
		/* 82111C74h case    0:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R23 + 0x00000020) );
		/* 82111C74h case    0:*/		return 0x82111C78;
		  /* 82111C78h */ case    1:  		/* bl 1402424 */
		/* 82111C78h case    1:*/		regs.LR = 0x82111C7C; return 0x822682B0;
		/* 82111C78h case    1:*/		return 0x82111C7C;
		  /* 82111C7Ch */ case    2:  		/* b -132 */
		/* 82111C7Ch case    2:*/		return 0x82111BF8;
		/* 82111C7Ch case    2:*/		return 0x82111C80;
	}
	return 0x82111C80;
} // Block from 82111C74h-82111C80h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82111C80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111C80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111C80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111C80);
		  /* 82111C80h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 82111C80h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82111C80h case    0:*/		return 0x82111C84;
		  /* 82111C84h */ case    1:  		/* bc 4, CR6_EQ, 56 */
		/* 82111C84h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82111CBC;  }
		/* 82111C84h case    1:*/		return 0x82111C88;
		  /* 82111C88h */ case    2:  		/* lis R11, -32255 */
		/* 82111C88h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82111C88h case    2:*/		return 0x82111C8C;
		  /* 82111C8Ch */ case    3:  		/* lfd FR0, <#[R23 + 32]> */
		/* 82111C8Ch case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R23 + 0x00000020) );
		/* 82111C8Ch case    3:*/		return 0x82111C90;
		  /* 82111C90h */ case    4:  		/* lfd FR13, <#[R11 - 24488]> */
		/* 82111C90h case    4:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0xFFFFA058) );
		/* 82111C90h case    4:*/		return 0x82111C94;
		  /* 82111C94h */ case    5:  		/* fcmpu CR6, FR0, FR13 */
		/* 82111C94h case    5:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82111C94h case    5:*/		return 0x82111C98;
		  /* 82111C98h */ case    6:  		/* bc 12, CR6_LT, 20 */
		/* 82111C98h case    6:*/		if ( regs.CR[6].lt ) { return 0x82111CAC;  }
		/* 82111C98h case    6:*/		return 0x82111C9C;
		  /* 82111C9Ch */ case    7:  		/* lis R11, -32256 */
		/* 82111C9Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82111C9Ch case    7:*/		return 0x82111CA0;
		  /* 82111CA0h */ case    8:  		/* lfd FR13, <#[R11 + 1848]> */
		/* 82111CA0h case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000738) );
		/* 82111CA0h case    8:*/		return 0x82111CA4;
		  /* 82111CA4h */ case    9:  		/* fcmpu CR6, FR0, FR13 */
		/* 82111CA4h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82111CA4h case    9:*/		return 0x82111CA8;
		  /* 82111CA8h */ case   10:  		/* bc 4, CR6_GT, 20 */
		/* 82111CA8h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82111CBC;  }
		/* 82111CA8h case   10:*/		return 0x82111CAC;
	}
	return 0x82111CAC;
} // Block from 82111C80h-82111CACh (11 instructions)

//////////////////////////////////////////////////////
// Block at 82111CACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111CAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111CAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111CAC);
		  /* 82111CACh */ case    0:  		/* lis R11, -32254 */
		/* 82111CACh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 82111CACh case    0:*/		return 0x82111CB0;
		  /* 82111CB0h */ case    1:  		/* li R5, 4005 */
		/* 82111CB0h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0xFA5);
		/* 82111CB0h case    1:*/		return 0x82111CB4;
		  /* 82111CB4h */ case    2:  		/* addi R6, R11, -13880 */
		/* 82111CB4h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFC9C8);
		/* 82111CB4h case    2:*/		return 0x82111CB8;
		  /* 82111CB8h */ case    3:  		/* b -84 */
		/* 82111CB8h case    3:*/		return 0x82111C64;
		/* 82111CB8h case    3:*/		return 0x82111CBC;
	}
	return 0x82111CBC;
} // Block from 82111CACh-82111CBCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 82111CBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111CBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111CBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111CBC);
		  /* 82111CBCh */ case    0:  		/* lfd FR1, <#[R23 + 32]> */
		/* 82111CBCh case    0:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R23 + 0x00000020) );
		/* 82111CBCh case    0:*/		return 0x82111CC0;
		  /* 82111CC0h */ case    1:  		/* bl 1402152 */
		/* 82111CC0h case    1:*/		regs.LR = 0x82111CC4; return 0x822681E8;
		/* 82111CC0h case    1:*/		return 0x82111CC4;
		  /* 82111CC4h */ case    2:  		/* b -204 */
		/* 82111CC4h case    2:*/		return 0x82111BF8;
		/* 82111CC4h case    2:*/		return 0x82111CC8;
	}
	return 0x82111CC8;
} // Block from 82111CBCh-82111CC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82111CC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111CC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111CC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111CC8);
		  /* 82111CC8h */ case    0:  		/* lfd FR1, <#[R23 + 32]> */
		/* 82111CC8h case    0:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R23 + 0x00000020) );
		/* 82111CC8h case    0:*/		return 0x82111CCC;
		  /* 82111CCCh */ case    1:  		/* bl -528676 */
		/* 82111CCCh case    1:*/		regs.LR = 0x82111CD0; return 0x82090BA8;
		/* 82111CCCh case    1:*/		return 0x82111CD0;
		  /* 82111CD0h */ case    2:  		/* b -216 */
		/* 82111CD0h case    2:*/		return 0x82111BF8;
		/* 82111CD0h case    2:*/		return 0x82111CD4;
	}
	return 0x82111CD4;
} // Block from 82111CC8h-82111CD4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82111CD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111CD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111CD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111CD4);
		  /* 82111CD4h */ case    0:  		/* rlwinm. R31, R9, 0, 31, 31 */
		/* 82111CD4h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R31,regs.R9);
		/* 82111CD4h case    0:*/		return 0x82111CD8;
		  /* 82111CD8h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82111CD8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82111CE4;  }
		/* 82111CD8h case    1:*/		return 0x82111CDC;
		  /* 82111CDCh */ case    2:  		/* cmplw CR6, R26, R10 */
		/* 82111CDCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R10);
		/* 82111CDCh case    2:*/		return 0x82111CE0;
		  /* 82111CE0h */ case    3:  		/* bc 12, CR6_EQ, -240 */
		/* 82111CE0h case    3:*/		if ( regs.CR[6].eq ) { return 0x82111BF0;  }
		/* 82111CE0h case    3:*/		return 0x82111CE4;
	}
	return 0x82111CE4;
} // Block from 82111CD4h-82111CE4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82111CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111CE4);
		  /* 82111CE4h */ case    0:  		/* rlwinm. R31, R9, 0, 30, 30 */
		/* 82111CE4h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R31,regs.R9);
		/* 82111CE4h case    0:*/		return 0x82111CE8;
		  /* 82111CE8h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82111CE8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82111CF4;  }
		/* 82111CE8h case    1:*/		return 0x82111CEC;
		  /* 82111CECh */ case    2:  		/* cmplw CR6, R26, R10 */
		/* 82111CECh case    2:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R10);
		/* 82111CECh case    2:*/		return 0x82111CF0;
		  /* 82111CF0h */ case    3:  		/* bc 12, CR6_EQ, -256 */
		/* 82111CF0h case    3:*/		if ( regs.CR[6].eq ) { return 0x82111BF0;  }
		/* 82111CF0h case    3:*/		return 0x82111CF4;
	}
	return 0x82111CF4;
} // Block from 82111CE4h-82111CF4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82111CF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111CF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111CF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111CF4);
		  /* 82111CF4h */ case    0:  		/* rlwinm. R10, R9, 0, 28, 28 */
		/* 82111CF4h case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R9);
		/* 82111CF4h case    0:*/		return 0x82111CF8;
		  /* 82111CF8h */ case    1:  		/* lis R19, 4192 */
		/* 82111CF8h case    1:*/		cpu::op::lis<0>(regs,&regs.R19,0x1060);
		/* 82111CF8h case    1:*/		return 0x82111CFC;
		  /* 82111CFCh */ case    2:  		/* bc 12, CR0_EQ, 88 */
		/* 82111CFCh case    2:*/		if ( regs.CR[0].eq ) { return 0x82111D54;  }
		/* 82111CFCh case    2:*/		return 0x82111D00;
		  /* 82111D00h */ case    3:  		/* cmplw CR6, R26, R19 */
		/* 82111D00h case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R19);
		/* 82111D00h case    3:*/		return 0x82111D04;
		  /* 82111D04h */ case    4:  		/* bc 12, CR6_EQ, 36 */
		/* 82111D04h case    4:*/		if ( regs.CR[6].eq ) { return 0x82111D28;  }
		/* 82111D04h case    4:*/		return 0x82111D08;
		  /* 82111D08h */ case    5:  		/* cmplw CR6, R26, R20 */
		/* 82111D08h case    5:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R20);
		/* 82111D08h case    5:*/		return 0x82111D0C;
		  /* 82111D0Ch */ case    6:  		/* bc 4, CR6_EQ, 72 */
		/* 82111D0Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x82111D54;  }
		/* 82111D0Ch case    6:*/		return 0x82111D10;
		  /* 82111D10h */ case    7:  		/* cmplwi CR6, R5, 0 */
		/* 82111D10h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82111D10h case    7:*/		return 0x82111D14;
		  /* 82111D14h */ case    8:  		/* bc 4, CR6_EQ, -260 */
		/* 82111D14h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82111C10;  }
		/* 82111D14h case    8:*/		return 0x82111D18;
		  /* 82111D18h */ case    9:  		/* lis R11, -32254 */
		/* 82111D18h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 82111D18h case    9:*/		return 0x82111D1C;
		  /* 82111D1Ch */ case   10:  		/* li R5, 4003 */
		/* 82111D1Ch case   10:*/		cpu::op::li<0>(regs,&regs.R5,0xFA3);
		/* 82111D1Ch case   10:*/		return 0x82111D20;
		  /* 82111D20h */ case   11:  		/* addi R6, R11, -13792 */
		/* 82111D20h case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCA20);
		/* 82111D20h case   11:*/		return 0x82111D24;
		  /* 82111D24h */ case   12:  		/* b -192 */
		/* 82111D24h case   12:*/		return 0x82111C64;
		/* 82111D24h case   12:*/		return 0x82111D28;
	}
	return 0x82111D28;
} // Block from 82111CF4h-82111D28h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82111D28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111D28);
		  /* 82111D28h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 82111D28h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82111D28h case    0:*/		return 0x82111D2C;
		  /* 82111D2Ch */ case    1:  		/* bc 4, CR6_EQ, -284 */
		/* 82111D2Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82111C10;  }
		/* 82111D2Ch case    1:*/		return 0x82111D30;
		  /* 82111D30h */ case    2:  		/* rlwinm. R11, R9, 0, 29, 29 */
		/* 82111D30h case    2:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R9);
		/* 82111D30h case    2:*/		return 0x82111D34;
		  /* 82111D34h */ case    3:  		/* bc 4, CR0_EQ, -292 */
		/* 82111D34h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82111C10;  }
		/* 82111D34h case    3:*/		return 0x82111D38;
		  /* 82111D38h */ case    4:  		/* lis R11, -32254 */
		/* 82111D38h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 82111D38h case    4:*/		return 0x82111D3C;
		  /* 82111D3Ch */ case    5:  		/* lwz R4, <#[R4 + 60]> */
		/* 82111D3Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x0000003C) );
		/* 82111D3Ch case    5:*/		return 0x82111D40;
		  /* 82111D40h */ case    6:  		/* li R5, 4002 */
		/* 82111D40h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0xFA2);
		/* 82111D40h case    6:*/		return 0x82111D44;
		  /* 82111D44h */ case    7:  		/* addi R6, R11, -13836 */
		/* 82111D44h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFC9F4);
		/* 82111D44h case    7:*/		return 0x82111D48;
		  /* 82111D48h */ case    8:  		/* mr R3, R22 */
		/* 82111D48h case    8:*/		regs.R3 = regs.R22;
		/* 82111D48h case    8:*/		return 0x82111D4C;
		  /* 82111D4Ch */ case    9:  		/* bl -13852 */
		/* 82111D4Ch case    9:*/		regs.LR = 0x82111D50; return 0x8210E730;
		/* 82111D4Ch case    9:*/		return 0x82111D50;
		  /* 82111D50h */ case   10:  		/* b -320 */
		/* 82111D50h case   10:*/		return 0x82111C10;
		/* 82111D50h case   10:*/		return 0x82111D54;
	}
	return 0x82111D54;
} // Block from 82111D28h-82111D54h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82111D54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111D54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111D54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111D54);
		  /* 82111D54h */ case    0:  		/* rlwinm. R10, R11, 0, 22, 22 */
		/* 82111D54h case    0:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R10,regs.R11);
		/* 82111D54h case    0:*/		return 0x82111D58;
		  /* 82111D58h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 82111D58h case    1:*/		if ( regs.CR[0].eq ) { return 0x82111D6C;  }
		/* 82111D58h case    1:*/		return 0x82111D5C;
		  /* 82111D5Ch */ case    2:  		/* cmplw CR6, R26, R7 */
		/* 82111D5Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R7);
		/* 82111D5Ch case    2:*/		return 0x82111D60;
		  /* 82111D60h */ case    3:  		/* bc 12, CR6_EQ, -368 */
		/* 82111D60h case    3:*/		if ( regs.CR[6].eq ) { return 0x82111BF0;  }
		/* 82111D60h case    3:*/		return 0x82111D64;
		  /* 82111D64h */ case    4:  		/* cmplw CR6, R26, R6 */
		/* 82111D64h case    4:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R6);
		/* 82111D64h case    4:*/		return 0x82111D68;
		  /* 82111D68h */ case    5:  		/* bc 12, CR6_EQ, -376 */
		/* 82111D68h case    5:*/		if ( regs.CR[6].eq ) { return 0x82111BF0;  }
		/* 82111D68h case    5:*/		return 0x82111D6C;
	}
	return 0x82111D6C;
} // Block from 82111D54h-82111D6Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82111D6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111D6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111D6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111D6C);
		  /* 82111D6Ch */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 82111D6Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82111D6Ch case    0:*/		return 0x82111D70;
		  /* 82111D70h */ case    1:  		/* bc 4, CR6_EQ, -352 */
		/* 82111D70h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82111C10;  }
		/* 82111D70h case    1:*/		return 0x82111D74;
		  /* 82111D74h */ case    2:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 82111D74h case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 82111D74h case    2:*/		return 0x82111D78;
		  /* 82111D78h */ case    3:  		/* bc 12, CR0_EQ, -360 */
		/* 82111D78h case    3:*/		if ( regs.CR[0].eq ) { return 0x82111C10;  }
		/* 82111D78h case    3:*/		return 0x82111D7C;
		  /* 82111D7Ch */ case    4:  		/* cmplw CR6, R26, R8 */
		/* 82111D7Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R8);
		/* 82111D7Ch case    4:*/		return 0x82111D80;
		  /* 82111D80h */ case    5:  		/* bc 4, CR6_EQ, 36 */
		/* 82111D80h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82111DA4;  }
		/* 82111D80h case    5:*/		return 0x82111D84;
		  /* 82111D84h */ case    6:  		/* lwz R11, <#[R23 + 72]> */
		/* 82111D84h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000048) );
		/* 82111D84h case    6:*/		return 0x82111D88;
		  /* 82111D88h */ case    7:  		/* lwz R10, <#[R22 + 24]> */
		/* 82111D88h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000018) );
		/* 82111D88h case    7:*/		return 0x82111D8C;
		  /* 82111D8Ch */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82111D8Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82111D8Ch case    8:*/		return 0x82111D90;
		  /* 82111D90h */ case    9:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82111D90h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82111D90h case    9:*/		return 0x82111D94;
		  /* 82111D94h */ case   10:  		/* lwz R10, <#[R11]> */
		/* 82111D94h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82111D94h case   10:*/		return 0x82111D98;
		  /* 82111D98h */ case   11:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 82111D98h case   11:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 82111D98h case   11:*/		return 0x82111D9C;
		  /* 82111D9Ch */ case   12:  		/* cmplw CR6, R10, R8 */
		/* 82111D9Ch case   12:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 82111D9Ch case   12:*/		return 0x82111DA0;
		  /* 82111DA0h */ case   13:  		/* bc 12, CR6_EQ, 124 */
		/* 82111DA0h case   13:*/		if ( regs.CR[6].eq ) { return 0x82111E1C;  }
		/* 82111DA0h case   13:*/		return 0x82111DA4;
	}
	return 0x82111DA4;
} // Block from 82111D6Ch-82111DA4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82111DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111DA4);
		  /* 82111DA4h */ case    0:  		/* cmplw CR6, R26, R3 */
		/* 82111DA4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R3);
		/* 82111DA4h case    0:*/		return 0x82111DA8;
		  /* 82111DA8h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 82111DA8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82111DCC;  }
		/* 82111DA8h case    1:*/		return 0x82111DAC;
		  /* 82111DACh */ case    2:  		/* lwz R11, <#[R23 + 72]> */
		/* 82111DACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000048) );
		/* 82111DACh case    2:*/		return 0x82111DB0;
		  /* 82111DB0h */ case    3:  		/* lwz R10, <#[R22 + 24]> */
		/* 82111DB0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000018) );
		/* 82111DB0h case    3:*/		return 0x82111DB4;
		  /* 82111DB4h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82111DB4h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82111DB4h case    4:*/		return 0x82111DB8;
		  /* 82111DB8h */ case    5:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82111DB8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82111DB8h case    5:*/		return 0x82111DBC;
		  /* 82111DBCh */ case    6:  		/* lwz R10, <#[R11]> */
		/* 82111DBCh case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82111DBCh case    6:*/		return 0x82111DC0;
		  /* 82111DC0h */ case    7:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 82111DC0h case    7:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 82111DC0h case    7:*/		return 0x82111DC4;
		  /* 82111DC4h */ case    8:  		/* cmplw CR6, R10, R3 */
		/* 82111DC4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R3);
		/* 82111DC4h case    8:*/		return 0x82111DC8;
		  /* 82111DC8h */ case    9:  		/* bc 12, CR6_EQ, 84 */
		/* 82111DC8h case    9:*/		if ( regs.CR[6].eq ) { return 0x82111E1C;  }
		/* 82111DC8h case    9:*/		return 0x82111DCC;
	}
	return 0x82111DCC;
} // Block from 82111DA4h-82111DCCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 82111DCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111DCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111DCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111DCC);
		  /* 82111DCCh */ case    0:  		/* cmplw CR6, R26, R21 */
		/* 82111DCCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R21);
		/* 82111DCCh case    0:*/		return 0x82111DD0;
		  /* 82111DD0h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 82111DD0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82111DF4;  }
		/* 82111DD0h case    1:*/		return 0x82111DD4;
		  /* 82111DD4h */ case    2:  		/* lwz R11, <#[R23 + 72]> */
		/* 82111DD4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000048) );
		/* 82111DD4h case    2:*/		return 0x82111DD8;
		  /* 82111DD8h */ case    3:  		/* lwz R10, <#[R22 + 24]> */
		/* 82111DD8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000018) );
		/* 82111DD8h case    3:*/		return 0x82111DDC;
		  /* 82111DDCh */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82111DDCh case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82111DDCh case    4:*/		return 0x82111DE0;
		  /* 82111DE0h */ case    5:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82111DE0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82111DE0h case    5:*/		return 0x82111DE4;
		  /* 82111DE4h */ case    6:  		/* lwz R10, <#[R11]> */
		/* 82111DE4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82111DE4h case    6:*/		return 0x82111DE8;
		  /* 82111DE8h */ case    7:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 82111DE8h case    7:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 82111DE8h case    7:*/		return 0x82111DEC;
		  /* 82111DECh */ case    8:  		/* cmplw CR6, R10, R19 */
		/* 82111DECh case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R19);
		/* 82111DECh case    8:*/		return 0x82111DF0;
		  /* 82111DF0h */ case    9:  		/* bc 12, CR6_EQ, 44 */
		/* 82111DF0h case    9:*/		if ( regs.CR[6].eq ) { return 0x82111E1C;  }
		/* 82111DF0h case    9:*/		return 0x82111DF4;
	}
	return 0x82111DF4;
} // Block from 82111DCCh-82111DF4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82111DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111DF4);
		  /* 82111DF4h */ case    0:  		/* cmplw CR6, R26, R19 */
		/* 82111DF4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R19);
		/* 82111DF4h case    0:*/		return 0x82111DF8;
		  /* 82111DF8h */ case    1:  		/* bc 4, CR6_EQ, 132 */
		/* 82111DF8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82111E7C;  }
		/* 82111DF8h case    1:*/		return 0x82111DFC;
		  /* 82111DFCh */ case    2:  		/* lwz R11, <#[R23 + 72]> */
		/* 82111DFCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000048) );
		/* 82111DFCh case    2:*/		return 0x82111E00;
		  /* 82111E00h */ case    3:  		/* lwz R10, <#[R22 + 24]> */
		/* 82111E00h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000018) );
		/* 82111E00h case    3:*/		return 0x82111E04;
		  /* 82111E04h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82111E04h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82111E04h case    4:*/		return 0x82111E08;
		  /* 82111E08h */ case    5:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82111E08h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82111E08h case    5:*/		return 0x82111E0C;
		  /* 82111E0Ch */ case    6:  		/* lwz R10, <#[R11]> */
		/* 82111E0Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82111E0Ch case    6:*/		return 0x82111E10;
		  /* 82111E10h */ case    7:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 82111E10h case    7:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 82111E10h case    7:*/		return 0x82111E14;
		  /* 82111E14h */ case    8:  		/* cmplw CR6, R10, R21 */
		/* 82111E14h case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R21);
		/* 82111E14h case    8:*/		return 0x82111E18;
		  /* 82111E18h */ case    9:  		/* bc 4, CR6_EQ, 100 */
		/* 82111E18h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82111E7C;  }
		/* 82111E18h case    9:*/		return 0x82111E1C;
	}
	return 0x82111E1C;
} // Block from 82111DF4h-82111E1Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82111E1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111E1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111E1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111E1C);
		  /* 82111E1Ch */ case    0:  		/* lwz R8, <#[R11 + 12]> */
		/* 82111E1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 82111E1Ch case    0:*/		return 0x82111E20;
		  /* 82111E20h */ case    1:  		/* li R9, 0 */
		/* 82111E20h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82111E20h case    1:*/		return 0x82111E24;
		  /* 82111E24h */ case    2:  		/* cmplwi CR6, R8, 0 */
		/* 82111E24h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82111E24h case    2:*/		return 0x82111E28;
		  /* 82111E28h */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 82111E28h case    3:*/		if ( regs.CR[6].eq ) { return 0x82111E50;  }
		/* 82111E28h case    3:*/		return 0x82111E2C;
		  /* 82111E2Ch */ case    4:  		/* lwz R7, <#[R11 + 16]> */
		/* 82111E2Ch case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000010) );
		/* 82111E2Ch case    4:*/		return 0x82111E30;
		  /* 82111E30h */ case    5:  		/* li R10, 0 */
		/* 82111E30h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82111E30h case    5:*/		return 0x82111E34;
		  /* 82111E34h */ case    6:  		/* lwzx R6, <#[R10 + R7]> */
		/* 82111E34h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 82111E34h case    6:*/		return 0x82111E38;
		  /* 82111E38h */ case    7:  		/* cmplw CR6, R6, R17 */
		/* 82111E38h case    7:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R17);
		/* 82111E38h case    7:*/		return 0x82111E3C;
		  /* 82111E3Ch */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 82111E3Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x82111E50;  }
		/* 82111E3Ch case    8:*/		return 0x82111E40;
		  /* 82111E40h */ case    9:  		/* addi R9, R9, 1 */
		/* 82111E40h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82111E40h case    9:*/		return 0x82111E44;
		  /* 82111E44h */ case   10:  		/* addi R10, R10, 4 */
		/* 82111E44h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82111E44h case   10:*/		return 0x82111E48;
		  /* 82111E48h */ case   11:  		/* cmplw CR6, R9, R8 */
		/* 82111E48h case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 82111E48h case   11:*/		return 0x82111E4C;
		  /* 82111E4Ch */ case   12:  		/* bc 12, CR6_LT, -24 */
		/* 82111E4Ch case   12:*/		if ( regs.CR[6].lt ) { return 0x82111E34;  }
		/* 82111E4Ch case   12:*/		return 0x82111E50;
	}
	return 0x82111E50;
} // Block from 82111E1Ch-82111E50h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82111E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111E50);
		  /* 82111E50h */ case    0:  		/* cmplw CR6, R9, R8 */
		/* 82111E50h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 82111E50h case    0:*/		return 0x82111E54;
		  /* 82111E54h */ case    1:  		/* bc 4, CR6_LT, 40 */
		/* 82111E54h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82111E7C;  }
		/* 82111E54h case    1:*/		return 0x82111E58;
		  /* 82111E58h */ case    2:  		/* lwz R11, <#[R11 + 8]> */
		/* 82111E58h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82111E58h case    2:*/		return 0x82111E5C;
		  /* 82111E5Ch */ case    3:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 82111E5Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 82111E5Ch case    3:*/		return 0x82111E60;
		  /* 82111E60h */ case    4:  		/* lwz R9, <#[R22 + 20]> */
		/* 82111E60h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R22 + 0x00000014) );
		/* 82111E60h case    4:*/		return 0x82111E64;
		  /* 82111E64h */ case    5:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82111E64h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82111E64h case    5:*/		return 0x82111E68;
		  /* 82111E68h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82111E68h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82111E68h case    6:*/		return 0x82111E6C;
		  /* 82111E6Ch */ case    7:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82111E6Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82111E6Ch case    7:*/		return 0x82111E70;
		  /* 82111E70h */ case    8:  		/* lwz R11, <#[R11 + 48]> */
		/* 82111E70h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82111E70h case    8:*/		return 0x82111E74;
		  /* 82111E74h */ case    9:  		/* stw R11, <#[R16 + 48]> */
		/* 82111E74h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R16 + 0x00000030) );
		/* 82111E74h case    9:*/		return 0x82111E78;
		  /* 82111E78h */ case   10:  		/* b -616 */
		/* 82111E78h case   10:*/		return 0x82111C10;
		/* 82111E78h case   10:*/		return 0x82111E7C;
	}
	return 0x82111E7C;
} // Block from 82111E50h-82111E7Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 82111E7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111E7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111E7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111E7C);
		  /* 82111E7Ch */ case    0:  		/* lis R24, 8272 */
		/* 82111E7Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R24,0x2050);
		/* 82111E7Ch case    0:*/		return 0x82111E80;
		  /* 82111E80h */ case    1:  		/* cmplw CR6, R26, R3 */
		/* 82111E80h case    1:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R3);
		/* 82111E80h case    1:*/		return 0x82111E84;
		  /* 82111E84h */ case    2:  		/* bc 4, CR6_EQ, 292 */
		/* 82111E84h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82111FA8;  }
		/* 82111E84h case    2:*/		return 0x82111E88;
		  /* 82111E88h */ case    3:  		/* lwz R11, <#[R23 + 72]> */
		/* 82111E88h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000048) );
		/* 82111E88h case    3:*/		return 0x82111E8C;
		  /* 82111E8Ch */ case    4:  		/* lwz R25, <#[R22 + 24]> */
		/* 82111E8Ch case    4:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R22 + 0x00000018) );
		/* 82111E8Ch case    4:*/		return 0x82111E90;
		  /* 82111E90h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82111E90h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82111E90h case    5:*/		return 0x82111E94;
		  /* 82111E94h */ case    6:  		/* lwzx R10, <#[R11 + R25]> */
		/* 82111E94h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 82111E94h case    6:*/		return 0x82111E98;
		  /* 82111E98h */ case    7:  		/* lwz R11, <#[R10]> */
		/* 82111E98h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82111E98h case    7:*/		return 0x82111E9C;
		  /* 82111E9Ch */ case    8:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82111E9Ch case    8:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82111E9Ch case    8:*/		return 0x82111EA0;
		  /* 82111EA0h */ case    9:  		/* cmplw CR6, R11, R24 */
		/* 82111EA0h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 82111EA0h case    9:*/		return 0x82111EA4;
		  /* 82111EA4h */ case   10:  		/* bc 4, CR6_EQ, 260 */
		/* 82111EA4h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82111FA8;  }
		/* 82111EA4h case   10:*/		return 0x82111EA8;
		  /* 82111EA8h */ case   11:  		/* lwz R7, <#[R10 + 12]> */
		/* 82111EA8h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x0000000C) );
		/* 82111EA8h case   11:*/		return 0x82111EAC;
		  /* 82111EACh */ case   12:  		/* li R9, 0 */
		/* 82111EACh case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82111EACh case   12:*/		return 0x82111EB0;
		  /* 82111EB0h */ case   13:  		/* cmplwi CR6, R7, 0 */
		/* 82111EB0h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82111EB0h case   13:*/		return 0x82111EB4;
		  /* 82111EB4h */ case   14:  		/* bc 12, CR6_EQ, 40 */
		/* 82111EB4h case   14:*/		if ( regs.CR[6].eq ) { return 0x82111EDC;  }
		/* 82111EB4h case   14:*/		return 0x82111EB8;
		  /* 82111EB8h */ case   15:  		/* lwz R8, <#[R10 + 16]> */
		/* 82111EB8h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000010) );
		/* 82111EB8h case   15:*/		return 0x82111EBC;
		  /* 82111EBCh */ case   16:  		/* li R11, 0 */
		/* 82111EBCh case   16:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82111EBCh case   16:*/		return 0x82111EC0;
		  /* 82111EC0h */ case   17:  		/* lwzx R6, <#[R11 + R8]> */
		/* 82111EC0h case   17:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82111EC0h case   17:*/		return 0x82111EC4;
		  /* 82111EC4h */ case   18:  		/* cmplw CR6, R6, R17 */
		/* 82111EC4h case   18:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R17);
		/* 82111EC4h case   18:*/		return 0x82111EC8;
		  /* 82111EC8h */ case   19:  		/* bc 12, CR6_EQ, 20 */
		/* 82111EC8h case   19:*/		if ( regs.CR[6].eq ) { return 0x82111EDC;  }
		/* 82111EC8h case   19:*/		return 0x82111ECC;
		  /* 82111ECCh */ case   20:  		/* addi R9, R9, 1 */
		/* 82111ECCh case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82111ECCh case   20:*/		return 0x82111ED0;
		  /* 82111ED0h */ case   21:  		/* addi R11, R11, 4 */
		/* 82111ED0h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82111ED0h case   21:*/		return 0x82111ED4;
		  /* 82111ED4h */ case   22:  		/* cmplw CR6, R9, R7 */
		/* 82111ED4h case   22:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 82111ED4h case   22:*/		return 0x82111ED8;
		  /* 82111ED8h */ case   23:  		/* bc 12, CR6_LT, -24 */
		/* 82111ED8h case   23:*/		if ( regs.CR[6].lt ) { return 0x82111EC0;  }
		/* 82111ED8h case   23:*/		return 0x82111EDC;
	}
	return 0x82111EDC;
} // Block from 82111E7Ch-82111EDCh (24 instructions)

//////////////////////////////////////////////////////
// Block at 82111EDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111EDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111EDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111EDC);
		  /* 82111EDCh */ case    0:  		/* lwz R11, <#[R10 + 12]> */
		/* 82111EDCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 82111EDCh case    0:*/		return 0x82111EE0;
		  /* 82111EE0h */ case    1:  		/* rlwinm R8, R9, 2, 0, 29 */
		/* 82111EE0h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R9);
		/* 82111EE0h case    1:*/		return 0x82111EE4;
		  /* 82111EE4h */ case    2:  		/* lwz R10, <#[R10 + 8]> */
		/* 82111EE4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82111EE4h case    2:*/		return 0x82111EE8;
		  /* 82111EE8h */ case    3:  		/* li R31, 0 */
		/* 82111EE8h case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82111EE8h case    3:*/		return 0x82111EEC;
		  /* 82111EECh */ case    4:  		/* add R9, R11, R9 */
		/* 82111EECh case    4:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 82111EECh case    4:*/		return 0x82111EF0;
		  /* 82111EF0h */ case    5:  		/* lwz R30, <#[R22 + 20]> */
		/* 82111EF0h case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R22 + 0x00000014) );
		/* 82111EF0h case    5:*/		return 0x82111EF4;
		  /* 82111EF4h */ case    6:  		/* rlwinm R28, R11, 2, 0, 29 */
		/* 82111EF4h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R11);
		/* 82111EF4h case    6:*/		return 0x82111EF8;
		  /* 82111EF8h */ case    7:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82111EF8h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82111EF8h case    7:*/		return 0x82111EFC;
		  /* 82111EFCh */ case    8:  		/* mulli R27, R11, -4 */
		/* 82111EFCh case    8:*/		cpu::op::mulli<0>(regs,&regs.R27,regs.R11,0xFFFFFFFC);
		/* 82111EFCh case    8:*/		return 0x82111F00;
		  /* 82111F00h */ case    9:  		/* add R8, R8, R10 */
		/* 82111F00h case    9:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R10);
		/* 82111F00h case    9:*/		return 0x82111F04;
		  /* 82111F04h */ case   10:  		/* add R9, R9, R10 */
		/* 82111F04h case   10:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 82111F04h case   10:*/		return 0x82111F08;
		  /* 82111F08h */ case   11:  		/* lwz R3, <#[R8]> */
		/* 82111F08h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R8 + 0x00000000) );
		/* 82111F08h case   11:*/		return 0x82111F0C;
		  /* 82111F0Ch */ case   12:  		/* lwz R29, <#[R9]> */
		/* 82111F0Ch case   12:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R9 + 0x00000000) );
		/* 82111F0Ch case   12:*/		return 0x82111F10;
		  /* 82111F10h */ case   13:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 82111F10h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 82111F10h case   13:*/		return 0x82111F14;
		  /* 82111F14h */ case   14:  		/* lwzx R4, <#[R11 + R30]> */
		/* 82111F14h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82111F14h case   14:*/		return 0x82111F18;
		  /* 82111F18h */ case   15:  		/* lwz R11, <#[R4 + 4]> */
		/* 82111F18h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 82111F18h case   15:*/		return 0x82111F1C;
		  /* 82111F1Ch */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82111F1Ch case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82111F1Ch case   16:*/		return 0x82111F20;
		  /* 82111F20h */ case   17:  		/* lwzx R11, <#[R11 + R18]> */
		/* 82111F20h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R18 + 0x00000000) );
		/* 82111F20h case   17:*/		return 0x82111F24;
		  /* 82111F24h */ case   18:  		/* lwz R11, <#[R11 + 4]> */
		/* 82111F24h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82111F24h case   18:*/		return 0x82111F28;
		  /* 82111F28h */ case   19:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 82111F28h case   19:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 82111F28h case   19:*/		return 0x82111F2C;
		  /* 82111F2Ch */ case   20:  		/* bc 12, CR0_EQ, 104 */
		/* 82111F2Ch case   20:*/		if ( regs.CR[0].eq ) { return 0x82111F94;  }
		/* 82111F2Ch case   20:*/		return 0x82111F30;
		  /* 82111F30h */ case   21:  		/* lwz R11, <#[R4 + 72]> */
		/* 82111F30h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000048) );
		/* 82111F30h case   21:*/		return 0x82111F34;
		  /* 82111F34h */ case   22:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82111F34h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82111F34h case   22:*/		return 0x82111F38;
		  /* 82111F38h */ case   23:  		/* lwzx R10, <#[R11 + R25]> */
		/* 82111F38h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 82111F38h case   23:*/		return 0x82111F3C;
		  /* 82111F3Ch */ case   24:  		/* lwz R11, <#[R10]> */
		/* 82111F3Ch case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82111F3Ch case   24:*/		return 0x82111F40;
		  /* 82111F40h */ case   25:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82111F40h case   25:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82111F40h case   25:*/		return 0x82111F44;
		  /* 82111F44h */ case   26:  		/* cmplw CR6, R11, R20 */
		/* 82111F44h case   26:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R20);
		/* 82111F44h case   26:*/		return 0x82111F48;
	}
	return 0x82111F48;
} // Block from 82111EDCh-82111F48h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82111F48h
// Function '?SimplifyAddresses@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111F48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111F48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111F48);
		  /* 82111F48h */ case    0:  		/* bc 4, CR6_EQ, 76 */
		/* 82111F48h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82111F94;  }
		/* 82111F48h case    0:*/		return 0x82111F4C;
		  /* 82111F4Ch */ case    1:  		/* lwz R5, <#[R10 + 12]> */
		/* 82111F4Ch case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x0000000C) );
		/* 82111F4Ch case    1:*/		return 0x82111F50;
		  /* 82111F50h */ case    2:  		/* li R7, 0 */
		/* 82111F50h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82111F50h case    2:*/		return 0x82111F54;
		  /* 82111F54h */ case    3:  		/* cmplwi CR6, R5, 0 */
		/* 82111F54h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82111F54h case    3:*/		return 0x82111F58;
		  /* 82111F58h */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 82111F58h case    4:*/		if ( regs.CR[6].eq ) { return 0x82111F80;  }
		/* 82111F58h case    4:*/		return 0x82111F5C;
		  /* 82111F5Ch */ case    5:  		/* lwz R6, <#[R10 + 16]> */
		/* 82111F5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000010) );
		/* 82111F5Ch case    5:*/		return 0x82111F60;
		  /* 82111F60h */ case    6:  		/* li R11, 0 */
		/* 82111F60h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82111F60h case    6:*/		return 0x82111F64;
		  /* 82111F64h */ case    7:  		/* lwzx R15, <#[R11 + R6]> */
		/* 82111F64h case    7:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82111F64h case    7:*/		return 0x82111F68;
		  /* 82111F68h */ case    8:  		/* cmplw CR6, R15, R3 */
		/* 82111F68h case    8:*/		cpu::op::cmplw<6>(regs,regs.R15,regs.R3);
		/* 82111F68h case    8:*/		return 0x82111F6C;
		  /* 82111F6Ch */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 82111F6Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x82111F80;  }
		/* 82111F6Ch case    9:*/		return 0x82111F70;
		  /* 82111F70h */ case   10:  		/* addi R7, R7, 1 */
		/* 82111F70h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82111F70h case   10:*/		return 0x82111F74;
		  /* 82111F74h */ case   11:  		/* addi R11, R11, 4 */
		/* 82111F74h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82111F74h case   11:*/		return 0x82111F78;
		  /* 82111F78h */ case   12:  		/* cmplw CR6, R7, R5 */
		/* 82111F78h case   12:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R5);
		/* 82111F78h case   12:*/		return 0x82111F7C;
		  /* 82111F7Ch */ case   13:  		/* bc 12, CR6_LT, -24 */
		/* 82111F7Ch case   13:*/		if ( regs.CR[6].lt ) { return 0x82111F64;  }
		/* 82111F7Ch case   13:*/		return 0x82111F80;
	}
	return 0x82111F80;
} // Block from 82111F48h-82111F80h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82111F80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111F80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111F80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111F80);
		  /* 82111F80h */ case    0:  		/* lwz R11, <#[R10 + 8]> */
		/* 82111F80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82111F80h case    0:*/		return 0x82111F84;
		  /* 82111F84h */ case    1:  		/* rlwinm R10, R7, 2, 0, 29 */
		/* 82111F84h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R7);
		/* 82111F84h case    1:*/		return 0x82111F88;
		  /* 82111F88h */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82111F88h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82111F88h case    2:*/		return 0x82111F8C;
		  /* 82111F8Ch */ case    3:  		/* cmplw CR6, R11, R29 */
		/* 82111F8Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 82111F8Ch case    3:*/		return 0x82111F90;
		  /* 82111F90h */ case    4:  		/* bc 12, CR6_EQ, 316 */
		/* 82111F90h case    4:*/		if ( regs.CR[6].eq ) { return 0x821120CC;  }
		/* 82111F90h case    4:*/		return 0x82111F94;
	}
	return 0x82111F94;
} // Block from 82111F80h-82111F94h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82111F94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111F94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111F94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111F94);
		  /* 82111F94h */ case    0:  		/* addi R31, R31, 1 */
		/* 82111F94h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82111F94h case    0:*/		return 0x82111F98;
		  /* 82111F98h */ case    1:  		/* add R8, R28, R8 */
		/* 82111F98h case    1:*/		cpu::op::add<0>(regs,&regs.R8,regs.R28,regs.R8);
		/* 82111F98h case    1:*/		return 0x82111F9C;
		  /* 82111F9Ch */ case    2:  		/* add R9, R27, R9 */
		/* 82111F9Ch case    2:*/		cpu::op::add<0>(regs,&regs.R9,regs.R27,regs.R9);
		/* 82111F9Ch case    2:*/		return 0x82111FA0;
		  /* 82111FA0h */ case    3:  		/* cmplwi CR6, R31, 2 */
		/* 82111FA0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000002);
		/* 82111FA0h case    3:*/		return 0x82111FA4;
		  /* 82111FA4h */ case    4:  		/* bc 12, CR6_LT, -156 */
		/* 82111FA4h case    4:*/		if ( regs.CR[6].lt ) { return 0x82111F08;  }
		/* 82111FA4h case    4:*/		return 0x82111FA8;
	}
	return 0x82111FA8;
} // Block from 82111F94h-82111FA8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82111FA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82111FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82111FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82111FA8);
		  /* 82111FA8h */ case    0:  		/* cmplw CR6, R26, R21 */
		/* 82111FA8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R21);
		/* 82111FA8h case    0:*/		return 0x82111FAC;
		  /* 82111FACh */ case    1:  		/* bc 4, CR6_EQ, -924 */
		/* 82111FACh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82111C10;  }
		/* 82111FACh case    1:*/		return 0x82111FB0;
		  /* 82111FB0h */ case    2:  		/* lwz R11, <#[R23 + 72]> */
		/* 82111FB0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000048) );
		/* 82111FB0h case    2:*/		return 0x82111FB4;
		  /* 82111FB4h */ case    3:  		/* lwz R30, <#[R22 + 24]> */
		/* 82111FB4h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R22 + 0x00000018) );
		/* 82111FB4h case    3:*/		return 0x82111FB8;
		  /* 82111FB8h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82111FB8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82111FB8h case    4:*/		return 0x82111FBC;
		  /* 82111FBCh */ case    5:  		/* lwzx R11, <#[R11 + R30]> */
		/* 82111FBCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82111FBCh case    5:*/		return 0x82111FC0;
		  /* 82111FC0h */ case    6:  		/* lwz R10, <#[R11]> */
		/* 82111FC0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82111FC0h case    6:*/		return 0x82111FC4;
		  /* 82111FC4h */ case    7:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 82111FC4h case    7:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 82111FC4h case    7:*/		return 0x82111FC8;
		  /* 82111FC8h */ case    8:  		/* cmplw CR6, R10, R24 */
		/* 82111FC8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R24);
		/* 82111FC8h case    8:*/		return 0x82111FCC;
		  /* 82111FCCh */ case    9:  		/* bc 4, CR6_EQ, -956 */
		/* 82111FCCh case    9:*/		if ( !regs.CR[6].eq ) { return 0x82111C10;  }
		/* 82111FCCh case    9:*/		return 0x82111FD0;
		  /* 82111FD0h */ case   10:  		/* lwz R9, <#[R11 + 12]> */
		/* 82111FD0h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82111FD0h case   10:*/		return 0x82111FD4;
		  /* 82111FD4h */ case   11:  		/* li R10, 0 */
		/* 82111FD4h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82111FD4h case   11:*/		return 0x82111FD8;
		  /* 82111FD8h */ case   12:  		/* cmplwi CR6, R9, 0 */
		/* 82111FD8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82111FD8h case   12:*/		return 0x82111FDC;
		  /* 82111FDCh */ case   13:  		/* bc 12, CR6_EQ, 40 */
		/* 82111FDCh case   13:*/		if ( regs.CR[6].eq ) { return 0x82112004;  }
		/* 82111FDCh case   13:*/		return 0x82111FE0;
		  /* 82111FE0h */ case   14:  		/* lwz R7, <#[R11 + 16]> */
		/* 82111FE0h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000010) );
		/* 82111FE0h case   14:*/		return 0x82111FE4;
		  /* 82111FE4h */ case   15:  		/* li R8, 0 */
		/* 82111FE4h case   15:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82111FE4h case   15:*/		return 0x82111FE8;
		  /* 82111FE8h */ case   16:  		/* lwzx R6, <#[R8 + R7]> */
		/* 82111FE8h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 82111FE8h case   16:*/		return 0x82111FEC;
		  /* 82111FECh */ case   17:  		/* cmplw CR6, R6, R17 */
		/* 82111FECh case   17:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R17);
		/* 82111FECh case   17:*/		return 0x82111FF0;
		  /* 82111FF0h */ case   18:  		/* bc 12, CR6_EQ, 20 */
		/* 82111FF0h case   18:*/		if ( regs.CR[6].eq ) { return 0x82112004;  }
		/* 82111FF0h case   18:*/		return 0x82111FF4;
		  /* 82111FF4h */ case   19:  		/* addi R10, R10, 1 */
		/* 82111FF4h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82111FF4h case   19:*/		return 0x82111FF8;
		  /* 82111FF8h */ case   20:  		/* addi R8, R8, 4 */
		/* 82111FF8h case   20:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82111FF8h case   20:*/		return 0x82111FFC;
		  /* 82111FFCh */ case   21:  		/* cmplw CR6, R10, R9 */
		/* 82111FFCh case   21:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82111FFCh case   21:*/		return 0x82112000;
		  /* 82112000h */ case   22:  		/* bc 12, CR6_LT, -24 */
		/* 82112000h case   22:*/		if ( regs.CR[6].lt ) { return 0x82111FE8;  }
		/* 82112000h case   22:*/		return 0x82112004;
	}
	return 0x82112004;
} // Block from 82111FA8h-82112004h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82112004h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112004( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112004) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112004);
		  /* 82112004h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82112004h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82112004h case    0:*/		return 0x82112008;
		  /* 82112008h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82112008h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82112008h case    1:*/		return 0x8211200C;
		  /* 8211200Ch */ case    2:  		/* lwz R4, <#[R22 + 20]> */
		/* 8211200Ch case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R22 + 0x00000014) );
		/* 8211200Ch case    2:*/		return 0x82112010;
		  /* 82112010h */ case    3:  		/* li R3, 0 */
		/* 82112010h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82112010h case    3:*/		return 0x82112014;
		  /* 82112014h */ case    4:  		/* rlwinm R31, R9, 2, 0, 29 */
		/* 82112014h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R9);
		/* 82112014h case    4:*/		return 0x82112018;
		  /* 82112018h */ case    5:  		/* add R6, R10, R11 */
		/* 82112018h case    5:*/		cpu::op::add<0>(regs,&regs.R6,regs.R10,regs.R11);
		/* 82112018h case    5:*/		return 0x8211201C;
		  /* 8211201Ch */ case    6:  		/* lwz R5, <#[R6]> */
		/* 8211201Ch case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R6 + 0x00000000) );
		/* 8211201Ch case    6:*/		return 0x82112020;
		  /* 82112020h */ case    7:  		/* rlwinm R11, R5, 2, 0, 29 */
		/* 82112020h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R5);
		/* 82112020h case    7:*/		return 0x82112024;
		  /* 82112024h */ case    8:  		/* lwzx R11, <#[R11 + R4]> */
		/* 82112024h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R4 + 0x00000000) );
		/* 82112024h case    8:*/		return 0x82112028;
		  /* 82112028h */ case    9:  		/* lwz R10, <#[R11 + 4]> */
		/* 82112028h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82112028h case    9:*/		return 0x8211202C;
		  /* 8211202Ch */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8211202Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8211202Ch case   10:*/		return 0x82112030;
		  /* 82112030h */ case   11:  		/* lwzx R10, <#[R10 + R18]> */
		/* 82112030h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R18 + 0x00000000) );
		/* 82112030h case   11:*/		return 0x82112034;
		  /* 82112034h */ case   12:  		/* lwz R10, <#[R10 + 4]> */
		/* 82112034h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82112034h case   12:*/		return 0x82112038;
		  /* 82112038h */ case   13:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 82112038h case   13:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 82112038h case   13:*/		return 0x8211203C;
		  /* 8211203Ch */ case   14:  		/* bc 12, CR0_EQ, 124 */
		/* 8211203Ch case   14:*/		if ( regs.CR[0].eq ) { return 0x821120B8;  }
		/* 8211203Ch case   14:*/		return 0x82112040;
		  /* 82112040h */ case   15:  		/* lwz R11, <#[R11 + 72]> */
		/* 82112040h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 82112040h case   15:*/		return 0x82112044;
		  /* 82112044h */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82112044h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82112044h case   16:*/		return 0x82112048;
		  /* 82112048h */ case   17:  		/* lwzx R11, <#[R11 + R30]> */
		/* 82112048h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82112048h case   17:*/		return 0x8211204C;
		  /* 8211204Ch */ case   18:  		/* lwz R10, <#[R11]> */
		/* 8211204Ch case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8211204Ch case   18:*/		return 0x82112050;
		  /* 82112050h */ case   19:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 82112050h case   19:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 82112050h case   19:*/		return 0x82112054;
		  /* 82112054h */ case   20:  		/* cmplw CR6, R10, R19 */
		/* 82112054h case   20:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R19);
		/* 82112054h case   20:*/		return 0x82112058;
		  /* 82112058h */ case   21:  		/* bc 4, CR6_EQ, 96 */
		/* 82112058h case   21:*/		if ( !regs.CR[6].eq ) { return 0x821120B8;  }
		/* 82112058h case   21:*/		return 0x8211205C;
		  /* 8211205Ch */ case   22:  		/* lwz R7, <#[R11 + 12]> */
		/* 8211205Ch case   22:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 8211205Ch case   22:*/		return 0x82112060;
		  /* 82112060h */ case   23:  		/* li R9, 0 */
		/* 82112060h case   23:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82112060h case   23:*/		return 0x82112064;
		  /* 82112064h */ case   24:  		/* cmplwi CR6, R7, 0 */
		/* 82112064h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82112064h case   24:*/		return 0x82112068;
		  /* 82112068h */ case   25:  		/* bc 12, CR6_EQ, 40 */
		/* 82112068h case   25:*/		if ( regs.CR[6].eq ) { return 0x82112090;  }
		/* 82112068h case   25:*/		return 0x8211206C;
		  /* 8211206Ch */ case   26:  		/* lwz R8, <#[R11 + 16]> */
		/* 8211206Ch case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 8211206Ch case   26:*/		return 0x82112070;
		  /* 82112070h */ case   27:  		/* li R10, 0 */
		/* 82112070h case   27:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82112070h case   27:*/		return 0x82112074;
		  /* 82112074h */ case   28:  		/* lwzx R29, <#[R10 + R8]> */
		/* 82112074h case   28:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 82112074h case   28:*/		return 0x82112078;
		  /* 82112078h */ case   29:  		/* cmplw CR6, R29, R5 */
		/* 82112078h case   29:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R5);
		/* 82112078h case   29:*/		return 0x8211207C;
		  /* 8211207Ch */ case   30:  		/* bc 12, CR6_EQ, 20 */
		/* 8211207Ch case   30:*/		if ( regs.CR[6].eq ) { return 0x82112090;  }
		/* 8211207Ch case   30:*/		return 0x82112080;
		  /* 82112080h */ case   31:  		/* addi R9, R9, 1 */
		/* 82112080h case   31:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82112080h case   31:*/		return 0x82112084;
		  /* 82112084h */ case   32:  		/* addi R10, R10, 4 */
		/* 82112084h case   32:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82112084h case   32:*/		return 0x82112088;
		  /* 82112088h */ case   33:  		/* cmplw CR6, R9, R7 */
		/* 82112088h case   33:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 82112088h case   33:*/		return 0x8211208C;
		  /* 8211208Ch */ case   34:  		/* bc 12, CR6_LT, -24 */
		/* 8211208Ch case   34:*/		if ( regs.CR[6].lt ) { return 0x82112074;  }
		/* 8211208Ch case   34:*/		return 0x82112090;
	}
	return 0x82112090;
} // Block from 82112004h-82112090h (35 instructions)

//////////////////////////////////////////////////////
// Block at 82112090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112090);
		  /* 82112090h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82112090h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82112090h case    0:*/		return 0x82112094;
		  /* 82112094h */ case    1:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 82112094h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 82112094h case    1:*/		return 0x82112098;
		  /* 82112098h */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82112098h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82112098h case    2:*/		return 0x8211209C;
		  /* 8211209Ch */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8211209Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8211209Ch case    3:*/		return 0x821120A0;
		  /* 821120A0h */ case    4:  		/* lwzx R11, <#[R11 + R4]> */
		/* 821120A0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R4 + 0x00000000) );
		/* 821120A0h case    4:*/		return 0x821120A4;
		  /* 821120A4h */ case    5:  		/* lwz R11, <#[R11]> */
		/* 821120A4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821120A4h case    5:*/		return 0x821120A8;
		  /* 821120A8h */ case    6:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 821120A8h case    6:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 821120A8h case    6:*/		return 0x821120AC;
		  /* 821120ACh */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 821120ACh case    7:*/		if ( regs.CR[0].eq ) { return 0x821120B8;  }
		/* 821120ACh case    7:*/		return 0x821120B0;
		  /* 821120B0h */ case    8:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 821120B0h case    8:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 821120B0h case    8:*/		return 0x821120B4;
		  /* 821120B4h */ case    9:  		/* bc 4, CR0_EQ, -1220 */
		/* 821120B4h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82111BF0;  }
		/* 821120B4h case    9:*/		return 0x821120B8;
	}
	return 0x821120B8;
} // Block from 82112090h-821120B8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821120B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821120B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821120B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821120B8);
		  /* 821120B8h */ case    0:  		/* addi R3, R3, 1 */
		/* 821120B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 821120B8h case    0:*/		return 0x821120BC;
		  /* 821120BCh */ case    1:  		/* add R6, R31, R6 */
		/* 821120BCh case    1:*/		cpu::op::add<0>(regs,&regs.R6,regs.R31,regs.R6);
		/* 821120BCh case    1:*/		return 0x821120C0;
		  /* 821120C0h */ case    2:  		/* cmplwi CR6, R3, 2 */
		/* 821120C0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000002);
		/* 821120C0h case    2:*/		return 0x821120C4;
		  /* 821120C4h */ case    3:  		/* bc 12, CR6_LT, -168 */
		/* 821120C4h case    3:*/		if ( regs.CR[6].lt ) { return 0x8211201C;  }
		/* 821120C4h case    3:*/		return 0x821120C8;
		  /* 821120C8h */ case    4:  		/* b -1208 */
		/* 821120C8h case    4:*/		return 0x82111C10;
		/* 821120C8h case    4:*/		return 0x821120CC;
	}
	return 0x821120CC;
} // Block from 821120B8h-821120CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821120CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821120CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821120CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821120CC);
		  /* 821120CCh */ case    0:  		/* lwz R11, <#[R4 + 48]> */
		/* 821120CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000030) );
		/* 821120CCh case    0:*/		return 0x821120D0;
		  /* 821120D0h */ case    1:  		/* b -604 */
		/* 821120D0h case    1:*/		return 0x82111E74;
		/* 821120D0h case    1:*/		return 0x821120D4;
		  /* 821120D4h */ case    2:  		/* nop */
		/* 821120D4h case    2:*/		cpu::op::nop();
		/* 821120D4h case    2:*/		return 0x821120D8;
	}
	return 0x821120D8;
} // Block from 821120CCh-821120D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821120D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821120D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821120D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821120D8);
		  /* 821120D8h */ case    0:  		/* mfspr R12, LR */
		/* 821120D8h case    0:*/		regs.R12 = regs.LR;
		/* 821120D8h case    0:*/		return 0x821120DC;
		  /* 821120DCh */ case    1:  		/* bl -528060 */
		/* 821120DCh case    1:*/		regs.LR = 0x821120E0; return 0x82091220;
		/* 821120DCh case    1:*/		return 0x821120E0;
		  /* 821120E0h */ case    2:  		/* stfd FR29, <#[R1 - 176]> */
		/* 821120E0h case    2:*/		cpu::mem::store64f( regs, regs.FR29, (uint32)(regs.R1 + 0xFFFFFF50) );
		/* 821120E0h case    2:*/		return 0x821120E4;
		  /* 821120E4h */ case    3:  		/* stfd FR30, <#[R1 - 168]> */
		/* 821120E4h case    3:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFF58) );
		/* 821120E4h case    3:*/		return 0x821120E8;
		  /* 821120E8h */ case    4:  		/* stfd FR31, <#[R1 - 160]> */
		/* 821120E8h case    4:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 821120E8h case    4:*/		return 0x821120EC;
		  /* 821120ECh */ case    5:  		/* stwu R1, <#[R1 - 496]> */
		/* 821120ECh case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE10);
		/* 821120ECh case    5:*/		return 0x821120F0;
		  /* 821120F0h */ case    6:  		/* mr R19, R3 */
		/* 821120F0h case    6:*/		regs.R19 = regs.R3;
		/* 821120F0h case    6:*/		return 0x821120F4;
		  /* 821120F4h */ case    7:  		/* stw R3, <#[R1 + 516]> */
		/* 821120F4h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000204) );
		/* 821120F4h case    7:*/		return 0x821120F8;
		  /* 821120F8h */ case    8:  		/* mr R14, R4 */
		/* 821120F8h case    8:*/		regs.R14 = regs.R4;
		/* 821120F8h case    8:*/		return 0x821120FC;
		  /* 821120FCh */ case    9:  		/* stw R4, <#[R1 + 524]> */
		/* 821120FCh case    9:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000020C) );
		/* 821120FCh case    9:*/		return 0x82112100;
		  /* 82112100h */ case   10:  		/* mr R16, R5 */
		/* 82112100h case   10:*/		regs.R16 = regs.R5;
		/* 82112100h case   10:*/		return 0x82112104;
		  /* 82112104h */ case   11:  		/* stw R5, <#[R1 + 532]> */
		/* 82112104h case   11:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000214) );
		/* 82112104h case   11:*/		return 0x82112108;
		  /* 82112108h */ case   12:  		/* mr R31, R6 */
		/* 82112108h case   12:*/		regs.R31 = regs.R6;
		/* 82112108h case   12:*/		return 0x8211210C;
		  /* 8211210Ch */ case   13:  		/* stw R6, <#[R1 + 540]> */
		/* 8211210Ch case   13:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000021C) );
		/* 8211210Ch case   13:*/		return 0x82112110;
		  /* 82112110h */ case   14:  		/* stw R7, <#[R1 + 548]> */
		/* 82112110h case   14:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000224) );
		/* 82112110h case   14:*/		return 0x82112114;
		  /* 82112114h */ case   15:  		/* mr R18, R8 */
		/* 82112114h case   15:*/		regs.R18 = regs.R8;
		/* 82112114h case   15:*/		return 0x82112118;
		  /* 82112118h */ case   16:  		/* stw R8, <#[R1 + 556]> */
		/* 82112118h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x0000022C) );
		/* 82112118h case   16:*/		return 0x8211211C;
		  /* 8211211Ch */ case   17:  		/* mr R24, R9 */
		/* 8211211Ch case   17:*/		regs.R24 = regs.R9;
		/* 8211211Ch case   17:*/		return 0x82112120;
		  /* 82112120h */ case   18:  		/* stw R9, <#[R1 + 564]> */
		/* 82112120h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000234) );
		/* 82112120h case   18:*/		return 0x82112124;
		  /* 82112124h */ case   19:  		/* mr R23, R10 */
		/* 82112124h case   19:*/		regs.R23 = regs.R10;
		/* 82112124h case   19:*/		return 0x82112128;
		  /* 82112128h */ case   20:  		/* stw R10, <#[R1 + 572]> */
		/* 82112128h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000023C) );
		/* 82112128h case   20:*/		return 0x8211212C;
		  /* 8211212Ch */ case   21:  		/* cmplwi CR6, R5, 0 */
		/* 8211212Ch case   21:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8211212Ch case   21:*/		return 0x82112130;
		  /* 82112130h */ case   22:  		/* bc 12, CR6_EQ, 5440 */
		/* 82112130h case   22:*/		if ( regs.CR[6].eq ) { return 0x82113670;  }
		/* 82112130h case   22:*/		return 0x82112134;
		  /* 82112134h */ case   23:  		/* cmplwi CR6, R5, 4 */
		/* 82112134h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000004);
		/* 82112134h case   23:*/		return 0x82112138;
		  /* 82112138h */ case   24:  		/* bc 4, CR6_GT, 12 */
		/* 82112138h case   24:*/		if ( !regs.CR[6].gt ) { return 0x82112144;  }
		/* 82112138h case   24:*/		return 0x8211213C;
		  /* 8211213Ch */ case   25:  		/* li R3, 0 */
		/* 8211213Ch case   25:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8211213Ch case   25:*/		return 0x82112140;
		  /* 82112140h */ case   26:  		/* b 5428 */
		/* 82112140h case   26:*/		return 0x82113674;
		/* 82112140h case   26:*/		return 0x82112144;
	}
	return 0x82112144;
} // Block from 821120D8h-82112144h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82112144h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112144( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112144) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112144);
		  /* 82112144h */ case    0:  		/* li R6, 1 */
		/* 82112144h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82112144h case    0:*/		return 0x82112148;
		  /* 82112148h */ case    1:  		/* cmplwi CR6, R16, 1 */
		/* 82112148h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000001);
		/* 82112148h case    1:*/		return 0x8211214C;
		  /* 8211214Ch */ case    2:  		/* bc 4, CR6_GT, 48 */
		/* 8211214Ch case    2:*/		if ( !regs.CR[6].gt ) { return 0x8211217C;  }
		/* 8211214Ch case    2:*/		return 0x82112150;
		  /* 82112150h */ case    3:  		/* lwz R4, <#[R14]> */
		/* 82112150h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R14 + 0x00000000) );
		/* 82112150h case    3:*/		return 0x82112154;
		  /* 82112154h */ case    4:  		/* addi R7, R14, 4 */
		/* 82112154h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R14,0x4);
		/* 82112154h case    4:*/		return 0x82112158;
		  /* 82112158h */ case    5:  		/* mr R3, R19 */
		/* 82112158h case    5:*/		regs.R3 = regs.R19;
		/* 82112158h case    5:*/		return 0x8211215C;
		  /* 8211215Ch */ case    6:  		/* lwz R5, <#[R7]> */
		/* 8211215Ch case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R7 + 0x00000000) );
		/* 8211215Ch case    6:*/		return 0x82112160;
		  /* 82112160h */ case    7:  		/* bl -71368 */
		/* 82112160h case    7:*/		regs.LR = 0x82112164; return 0x82100A98;
		/* 82112160h case    7:*/		return 0x82112164;
		  /* 82112164h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 82112164h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82112164h case    8:*/		return 0x82112168;
		  /* 82112168h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 82112168h case    9:*/		if ( regs.CR[0].eq ) { return 0x8211217C;  }
		/* 82112168h case    9:*/		return 0x8211216C;
		  /* 8211216Ch */ case   10:  		/* addi R6, R6, 1 */
		/* 8211216Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8211216Ch case   10:*/		return 0x82112170;
		  /* 82112170h */ case   11:  		/* addi R7, R7, 4 */
		/* 82112170h case   11:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82112170h case   11:*/		return 0x82112174;
		  /* 82112174h */ case   12:  		/* cmplw CR6, R6, R16 */
		/* 82112174h case   12:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R16);
		/* 82112174h case   12:*/		return 0x82112178;
		  /* 82112178h */ case   13:  		/* bc 12, CR6_LT, -32 */
		/* 82112178h case   13:*/		if ( regs.CR[6].lt ) { return 0x82112158;  }
		/* 82112178h case   13:*/		return 0x8211217C;
	}
	return 0x8211217C;
} // Block from 82112144h-8211217Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8211217Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211217C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211217C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211217C);
		  /* 8211217Ch */ case    0:  		/* cmplw CR6, R6, R16 */
		/* 8211217Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R16);
		/* 8211217Ch case    0:*/		return 0x82112180;
		  /* 82112180h */ case    1:  		/* bc 12, CR6_EQ, 5360 */
		/* 82112180h case    1:*/		if ( regs.CR[6].eq ) { return 0x82113670;  }
		/* 82112180h case    1:*/		return 0x82112184;
		  /* 82112184h */ case    2:  		/* rlwinm R17, R16, 2, 0, 29 */
		/* 82112184h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R17,regs.R16);
		/* 82112184h case    2:*/		return 0x82112188;
		  /* 82112188h */ case    3:  		/* mr R4, R14 */
		/* 82112188h case    3:*/		regs.R4 = regs.R14;
		/* 82112188h case    3:*/		return 0x8211218C;
		  /* 8211218Ch */ case    4:  		/* mr R5, R17 */
		/* 8211218Ch case    4:*/		regs.R5 = regs.R17;
		/* 8211218Ch case    4:*/		return 0x82112190;
		  /* 82112190h */ case    5:  		/* stw R17, <#[R1 + 192]> */
		/* 82112190h case    5:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R1 + 0x000000C0) );
		/* 82112190h case    5:*/		return 0x82112194;
		  /* 82112194h */ case    6:  		/* addi R3, R1, 160 */
		/* 82112194h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 82112194h case    6:*/		return 0x82112198;
		  /* 82112198h */ case    7:  		/* bl -526312 */
		/* 82112198h case    7:*/		regs.LR = 0x8211219C; return 0x820919B0;
		/* 82112198h case    7:*/		return 0x8211219C;
		  /* 8211219Ch */ case    8:  		/* mr R5, R17 */
		/* 8211219Ch case    8:*/		regs.R5 = regs.R17;
		/* 8211219Ch case    8:*/		return 0x821121A0;
		  /* 821121A0h */ case    9:  		/* li R4, 0 */
		/* 821121A0h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821121A0h case    9:*/		return 0x821121A4;
		  /* 821121A4h */ case   10:  		/* addi R3, R1, 208 */
		/* 821121A4h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xD0);
		/* 821121A4h case   10:*/		return 0x821121A8;
		  /* 821121A8h */ case   11:  		/* bl -527976 */
		/* 821121A8h case   11:*/		regs.LR = 0x821121AC; return 0x82091340;
		/* 821121A8h case   11:*/		return 0x821121AC;
		  /* 821121ACh */ case   12:  		/* li R15, 0 */
		/* 821121ACh case   12:*/		cpu::op::li<0>(regs,&regs.R15,0x0);
		/* 821121ACh case   12:*/		return 0x821121B0;
		  /* 821121B0h */ case   13:  		/* cmplwi CR6, R31, 0 */
		/* 821121B0h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821121B0h case   13:*/		return 0x821121B4;
		  /* 821121B4h */ case   14:  		/* bc 12, CR6_EQ, 32 */
		/* 821121B4h case   14:*/		if ( regs.CR[6].eq ) { return 0x821121D4;  }
		/* 821121B4h case   14:*/		return 0x821121B8;
		  /* 821121B8h */ case   15:  		/* lwz R11, <#[R18]> */
		/* 821121B8h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 821121B8h case   15:*/		return 0x821121BC;
		  /* 821121BCh */ case   16:  		/* lis R10, 4384 */
		/* 821121BCh case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0x1120);
		/* 821121BCh case   16:*/		return 0x821121C0;
		  /* 821121C0h */ case   17:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 821121C0h case   17:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 821121C0h case   17:*/		return 0x821121C4;
		  /* 821121C4h */ case   18:  		/* cmplw CR6, R11, R10 */
		/* 821121C4h case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821121C4h case   18:*/		return 0x821121C8;
		  /* 821121C8h */ case   19:  		/* bc 12, CR6_EQ, 12 */
		/* 821121C8h case   19:*/		if ( regs.CR[6].eq ) { return 0x821121D4;  }
		/* 821121C8h case   19:*/		return 0x821121CC;
		  /* 821121CCh */ case   20:  		/* stw R15, <#[R1 + 144]> */
		/* 821121CCh case   20:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x00000090) );
		/* 821121CCh case   20:*/		return 0x821121D0;
		  /* 821121D0h */ case   21:  		/* b 12 */
		/* 821121D0h case   21:*/		return 0x821121DC;
		/* 821121D0h case   21:*/		return 0x821121D4;
	}
	return 0x821121D4;
} // Block from 8211217Ch-821121D4h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821121D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821121D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821121D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821121D4);
		  /* 821121D4h */ case    0:  		/* li R11, 1 */
		/* 821121D4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821121D4h case    0:*/		return 0x821121D8;
		  /* 821121D8h */ case    1:  		/* stw R11, <#[R1 + 144]> */
		/* 821121D8h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 821121D8h case    1:*/		return 0x821121DC;
	}
	return 0x821121DC;
} // Block from 821121D4h-821121DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821121DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821121DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821121DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821121DC);
		  /* 821121DCh */ case    0:  		/* lis R11, -32256 */
		/* 821121DCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821121DCh case    0:*/		return 0x821121E0;
		  /* 821121E0h */ case    1:  		/* lis R10, -32256 */
		/* 821121E0h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 821121E0h case    1:*/		return 0x821121E4;
		  /* 821121E4h */ case    2:  		/* mr R25, R15 */
		/* 821121E4h case    2:*/		regs.R25 = regs.R15;
		/* 821121E4h case    2:*/		return 0x821121E8;
		  /* 821121E8h */ case    3:  		/* mr R26, R15 */
		/* 821121E8h case    3:*/		regs.R26 = regs.R15;
		/* 821121E8h case    3:*/		return 0x821121EC;
		  /* 821121ECh */ case    4:  		/* cmplwi CR6, R16, 0 */
		/* 821121ECh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 821121ECh case    4:*/		return 0x821121F0;
		  /* 821121F0h */ case    5:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 821121F0h case    5:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 821121F0h case    5:*/		return 0x821121F4;
		  /* 821121F4h */ case    6:  		/* lfd FR29, <#[R10 + 1848]> */
		/* 821121F4h case    6:*/		cpu::mem::load64f( regs, &regs.FR29, (uint32)(regs.R10 + 0x00000738) );
		/* 821121F4h case    6:*/		return 0x821121F8;
		  /* 821121F8h */ case    7:  		/* bc 12, CR6_EQ, 396 */
		/* 821121F8h case    7:*/		if ( regs.CR[6].eq ) { return 0x82112384;  }
		/* 821121F8h case    7:*/		return 0x821121FC;
		  /* 821121FCh */ case    8:  		/* addi R28, R1, 160 */
		/* 821121FCh case    8:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0xA0);
		/* 821121FCh case    8:*/		return 0x82112200;
		  /* 82112200h */ case    9:  		/* mr R27, R15 */
		/* 82112200h case    9:*/		regs.R27 = regs.R15;
		/* 82112200h case    9:*/		return 0x82112204;
		  /* 82112204h */ case   10:  		/* lwz R29, <#[R28]> */
		/* 82112204h case   10:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R28 + 0x00000000) );
		/* 82112204h case   10:*/		return 0x82112208;
		  /* 82112208h */ case   11:  		/* mr R7, R23 */
		/* 82112208h case   11:*/		regs.R7 = regs.R23;
		/* 82112208h case   11:*/		return 0x8211220C;
		  /* 8211220Ch */ case   12:  		/* mr R6, R24 */
		/* 8211220Ch case   12:*/		regs.R6 = regs.R24;
		/* 8211220Ch case   12:*/		return 0x82112210;
		  /* 82112210h */ case   13:  		/* mr R5, R18 */
		/* 82112210h case   13:*/		regs.R5 = regs.R18;
		/* 82112210h case   13:*/		return 0x82112214;
		  /* 82112214h */ case   14:  		/* mr R4, R29 */
		/* 82112214h case   14:*/		regs.R4 = regs.R29;
		/* 82112214h case   14:*/		return 0x82112218;
		  /* 82112218h */ case   15:  		/* mr R3, R19 */
		/* 82112218h case   15:*/		regs.R3 = regs.R19;
		/* 82112218h case   15:*/		return 0x8211221C;
		  /* 8211221Ch */ case   16:  		/* bl -71716 */
		/* 8211221Ch case   16:*/		regs.LR = 0x82112220; return 0x821009F8;
		/* 8211221Ch case   16:*/		return 0x82112220;
		  /* 82112220h */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 82112220h case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82112220h case   17:*/		return 0x82112224;
		  /* 82112224h */ case   18:  		/* bc 12, CR0_EQ, 296 */
		/* 82112224h case   18:*/		if ( regs.CR[0].eq ) { return 0x8211234C;  }
		/* 82112224h case   18:*/		return 0x82112228;
		  /* 82112228h */ case   19:  		/* stfd FR29, <#[R1 + 184]> */
		/* 82112228h case   19:*/		cpu::mem::store64f( regs, regs.FR29, (uint32)(regs.R1 + 0x000000B8) );
		/* 82112228h case   19:*/		return 0x8211222C;
		  /* 8211222Ch */ case   20:  		/* mr R3, R29 */
		/* 8211222Ch case   20:*/		regs.R3 = regs.R29;
		/* 8211222Ch case   20:*/		return 0x82112230;
		  /* 82112230h */ case   21:  		/* stfd FR31, <#[R1 + 176]> */
		/* 82112230h case   21:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0x000000B0) );
		/* 82112230h case   21:*/		return 0x82112234;
		  /* 82112234h */ case   22:  		/* cmpwi CR6, R29, -1 */
		/* 82112234h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFF);
		/* 82112234h case   22:*/		return 0x82112238;
		  /* 82112238h */ case   23:  		/* bc 12, CR6_EQ, 276 */
		/* 82112238h case   23:*/		if ( regs.CR[6].eq ) { return 0x8211234C;  }
		/* 82112238h case   23:*/		return 0x8211223C;
		  /* 8211223Ch */ case   24:  		/* lwz R31, <#[R19 + 16]> */
		/* 8211223Ch case   24:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R19 + 0x00000010) );
		/* 8211223Ch case   24:*/		return 0x82112240;
		  /* 82112240h */ case   25:  		/* lwz R30, <#[R19 + 20]> */
		/* 82112240h case   25:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R19 + 0x00000014) );
		/* 82112240h case   25:*/		return 0x82112244;
		  /* 82112244h */ case   26:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 82112244h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 82112244h case   26:*/		return 0x82112248;
		  /* 82112248h */ case   27:  		/* lwzx R11, <#[R11 + R30]> */
		/* 82112248h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82112248h case   27:*/		return 0x8211224C;
		  /* 8211224Ch */ case   28:  		/* lwz R10, <#[R11 + 4]> */
		/* 8211224Ch case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8211224Ch case   28:*/		return 0x82112250;
		  /* 82112250h */ case   29:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82112250h case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82112250h case   29:*/		return 0x82112254;
		  /* 82112254h */ case   30:  		/* lwzx R10, <#[R10 + R31]> */
		/* 82112254h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 82112254h case   30:*/		return 0x82112258;
		  /* 82112258h */ case   31:  		/* lwz R10, <#[R10 + 4]> */
		/* 82112258h case   31:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82112258h case   31:*/		return 0x8211225C;
		  /* 8211225Ch */ case   32:  		/* rlwinm. R10, R10, 0, 23, 23 */
		/* 8211225Ch case   32:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R10);
		/* 8211225Ch case   32:*/		return 0x82112260;
		  /* 82112260h */ case   33:  		/* bc 12, CR0_EQ, 16 */
		/* 82112260h case   33:*/		if ( regs.CR[0].eq ) { return 0x82112270;  }
		/* 82112260h case   33:*/		return 0x82112264;
		  /* 82112264h */ case   34:  		/* lwz R10, <#[R11 + 8]> */
		/* 82112264h case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82112264h case   34:*/		return 0x82112268;
		  /* 82112268h */ case   35:  		/* cmpwi CR6, R10, -1 */
		/* 82112268h case   35:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82112268h case   35:*/		return 0x8211226C;
		  /* 8211226Ch */ case   36:  		/* bc 12, CR6_EQ, 36 */
		/* 8211226Ch case   36:*/		if ( regs.CR[6].eq ) { return 0x82112290;  }
		/* 8211226Ch case   36:*/		return 0x82112270;
	}
	return 0x82112270;
} // Block from 821121DCh-82112270h (37 instructions)

//////////////////////////////////////////////////////
// Block at 82112270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112270);
		  /* 82112270h */ case    0:  		/* mr R4, R3 */
		/* 82112270h case    0:*/		regs.R4 = regs.R3;
		/* 82112270h case    0:*/		return 0x82112274;
		  /* 82112274h */ case    1:  		/* addi R6, R1, 176 */
		/* 82112274h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0xB0);
		/* 82112274h case    1:*/		return 0x82112278;
		  /* 82112278h */ case    2:  		/* addi R5, R1, 184 */
		/* 82112278h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xB8);
		/* 82112278h case    2:*/		return 0x8211227C;
		  /* 8211227Ch */ case    3:  		/* mr R3, R19 */
		/* 8211227Ch case    3:*/		regs.R3 = regs.R19;
		/* 8211227Ch case    3:*/		return 0x82112280;
		  /* 82112280h */ case    4:  		/* bl -71552 */
		/* 82112280h case    4:*/		regs.LR = 0x82112284; return 0x82100B00;
		/* 82112280h case    4:*/		return 0x82112284;
		  /* 82112284h */ case    5:  		/* cmpwi CR6, R3, -1 */
		/* 82112284h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82112284h case    5:*/		return 0x82112288;
		  /* 82112288h */ case    6:  		/* bc 4, CR6_EQ, -68 */
		/* 82112288h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82112244;  }
		/* 82112288h case    6:*/		return 0x8211228C;
		  /* 8211228Ch */ case    7:  		/* b 192 */
		/* 8211228Ch case    7:*/		return 0x8211234C;
		/* 8211228Ch case    7:*/		return 0x82112290;
	}
	return 0x82112290;
} // Block from 82112270h-82112290h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82112290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112290);
		  /* 82112290h */ case    0:  		/* lfd FR13, <#[R1 + 184]> */
		/* 82112290h case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x000000B8) );
		/* 82112290h case    0:*/		return 0x82112294;
		  /* 82112294h */ case    1:  		/* lfd FR0, <#[R1 + 176]> */
		/* 82112294h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000B0) );
		/* 82112294h case    1:*/		return 0x82112298;
		  /* 82112298h */ case    2:  		/* fcmpu CR6, FR13, FR29 */
		/* 82112298h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR29);
		/* 82112298h case    2:*/		return 0x8211229C;
		  /* 8211229Ch */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 8211229Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x821122A8;  }
		/* 8211229Ch case    3:*/		return 0x821122A0;
		  /* 821122A0h */ case    4:  		/* fcmpu CR6, FR0, FR31 */
		/* 821122A0h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 821122A0h case    4:*/		return 0x821122A4;
		  /* 821122A4h */ case    5:  		/* bc 12, CR6_EQ, 136 */
		/* 821122A4h case    5:*/		if ( regs.CR[6].eq ) { return 0x8211232C;  }
		/* 821122A4h case    5:*/		return 0x821122A8;
	}
	return 0x821122A8;
} // Block from 82112290h-821122A8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821122A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821122A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821122A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821122A8);
		  /* 821122A8h */ case    0:  		/* lwz R9, <#[R19 + 8]> */
		/* 821122A8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R19 + 0x00000008) );
		/* 821122A8h case    0:*/		return 0x821122AC;
		  /* 821122ACh */ case    1:  		/* lfd FR12, <#[R11 + 32]> */
		/* 821122ACh case    1:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000020) );
		/* 821122ACh case    1:*/		return 0x821122B0;
		  /* 821122B0h */ case    2:  		/* fmadd FR1, FR12, FR13, FR0 */
		/* 821122B0h case    2:*/		cpu::op::fmadd<0>(regs,&regs.FR1,regs.FR12,regs.FR13,regs.FR0);
		/* 821122B0h case    2:*/		return 0x821122B4;
		  /* 821122B4h */ case    3:  		/* mr R3, R15 */
		/* 821122B4h case    3:*/		regs.R3 = regs.R15;
		/* 821122B4h case    3:*/		return 0x821122B8;
		  /* 821122B8h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 821122B8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821122B8h case    4:*/		return 0x821122BC;
		  /* 821122BCh */ case    5:  		/* bc 12, CR6_EQ, 76 */
		/* 821122BCh case    5:*/		if ( regs.CR[6].eq ) { return 0x82112308;  }
		/* 821122BCh case    5:*/		return 0x821122C0;
		  /* 821122C0h */ case    6:  		/* mr R11, R15 */
		/* 821122C0h case    6:*/		regs.R11 = regs.R15;
		/* 821122C0h case    6:*/		return 0x821122C4;
		  /* 821122C4h */ case    7:  		/* lwzx R10, <#[R11 + R30]> */
		/* 821122C4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 821122C4h case    7:*/		return 0x821122C8;
		  /* 821122C8h */ case    8:  		/* lwz R8, <#[R10 + 4]> */
		/* 821122C8h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821122C8h case    8:*/		return 0x821122CC;
		  /* 821122CCh */ case    9:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 821122CCh case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 821122CCh case    9:*/		return 0x821122D0;
		  /* 821122D0h */ case   10:  		/* lwzx R8, <#[R8 + R31]> */
		/* 821122D0h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R31 + 0x00000000) );
		/* 821122D0h case   10:*/		return 0x821122D4;
		  /* 821122D4h */ case   11:  		/* lwz R8, <#[R8 + 4]> */
		/* 821122D4h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 821122D4h case   11:*/		return 0x821122D8;
		  /* 821122D8h */ case   12:  		/* rlwinm. R8, R8, 0, 23, 23 */
		/* 821122D8h case   12:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R8,regs.R8);
		/* 821122D8h case   12:*/		return 0x821122DC;
		  /* 821122DCh */ case   13:  		/* bc 12, CR0_EQ, 28 */
		/* 821122DCh case   13:*/		if ( regs.CR[0].eq ) { return 0x821122F8;  }
		/* 821122DCh case   13:*/		return 0x821122E0;
		  /* 821122E0h */ case   14:  		/* lwz R8, <#[R10 + 8]> */
		/* 821122E0h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 821122E0h case   14:*/		return 0x821122E4;
		  /* 821122E4h */ case   15:  		/* cmpwi CR6, R8, -1 */
		/* 821122E4h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 821122E4h case   15:*/		return 0x821122E8;
		  /* 821122E8h */ case   16:  		/* bc 4, CR6_EQ, 16 */
		/* 821122E8h case   16:*/		if ( !regs.CR[6].eq ) { return 0x821122F8;  }
		/* 821122E8h case   16:*/		return 0x821122EC;
		  /* 821122ECh */ case   17:  		/* lfd FR0, <#[R10 + 32]> */
		/* 821122ECh case   17:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 821122ECh case   17:*/		return 0x821122F0;
		  /* 821122F0h */ case   18:  		/* fcmpu CR6, FR1, FR0 */
		/* 821122F0h case   18:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 821122F0h case   18:*/		return 0x821122F4;
		  /* 821122F4h */ case   19:  		/* bc 12, CR6_EQ, 20 */
		/* 821122F4h case   19:*/		if ( regs.CR[6].eq ) { return 0x82112308;  }
		/* 821122F4h case   19:*/		return 0x821122F8;
	}
	return 0x821122F8;
} // Block from 821122A8h-821122F8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821122F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821122F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821122F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821122F8);
		  /* 821122F8h */ case    0:  		/* addi R3, R3, 1 */
		/* 821122F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 821122F8h case    0:*/		return 0x821122FC;
		  /* 821122FCh */ case    1:  		/* addi R11, R11, 4 */
		/* 821122FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821122FCh case    1:*/		return 0x82112300;
		  /* 82112300h */ case    2:  		/* cmplw CR6, R3, R9 */
		/* 82112300h case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R9);
		/* 82112300h case    2:*/		return 0x82112304;
		  /* 82112304h */ case    3:  		/* bc 12, CR6_LT, -64 */
		/* 82112304h case    3:*/		if ( regs.CR[6].lt ) { return 0x821122C4;  }
		/* 82112304h case    3:*/		return 0x82112308;
	}
	return 0x82112308;
} // Block from 821122F8h-82112308h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82112308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112308);
		  /* 82112308h */ case    0:  		/* cmplw CR6, R3, R9 */
		/* 82112308h case    0:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R9);
		/* 82112308h case    0:*/		return 0x8211230C;
		  /* 8211230Ch */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 8211230Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8211232C;  }
		/* 8211230Ch case    1:*/		return 0x82112310;
		  /* 82112310h */ case    2:  		/* li R6, 0 */
		/* 82112310h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82112310h case    2:*/		return 0x82112314;
		  /* 82112314h */ case    3:  		/* lwz R4, <#[R19 + 120]> */
		/* 82112314h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R19 + 0x00000078) );
		/* 82112314h case    3:*/		return 0x82112318;
		  /* 82112318h */ case    4:  		/* li R5, 0 */
		/* 82112318h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82112318h case    4:*/		return 0x8211231C;
		  /* 8211231Ch */ case    5:  		/* mr R3, R19 */
		/* 8211231Ch case    5:*/		regs.R3 = regs.R19;
		/* 8211231Ch case    5:*/		return 0x82112320;
		  /* 82112320h */ case    6:  		/* bl -86264 */
		/* 82112320h case    6:*/		regs.LR = 0x82112324; return 0x820FD228;
		/* 82112320h case    6:*/		return 0x82112324;
		  /* 82112324h */ case    7:  		/* cmpwi CR6, R3, -1 */
		/* 82112324h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82112324h case    7:*/		return 0x82112328;
		  /* 82112328h */ case    8:  		/* bc 12, CR6_EQ, -492 */
		/* 82112328h case    8:*/		if ( regs.CR[6].eq ) { return 0x8211213C;  }
		/* 82112328h case    8:*/		return 0x8211232C;
	}
	return 0x8211232C;
} // Block from 82112308h-8211232Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8211232Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211232C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211232C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211232C);
		  /* 8211232Ch */ case    0:  		/* addi R11, R1, 272 */
		/* 8211232Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x110);
		/* 8211232Ch case    0:*/		return 0x82112330;
		  /* 82112330h */ case    1:  		/* stw R3, <#[R28]> */
		/* 82112330h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000000) );
		/* 82112330h case    1:*/		return 0x82112334;
		  /* 82112334h */ case    2:  		/* addi R10, R1, 240 */
		/* 82112334h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xF0);
		/* 82112334h case    2:*/		return 0x82112338;
		  /* 82112338h */ case    3:  		/* addi R25, R25, 1 */
		/* 82112338h case    3:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 82112338h case    3:*/		return 0x8211233C;
		  /* 8211233Ch */ case    4:  		/* cmpwi CR6, R3, -1 */
		/* 8211233Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8211233Ch case    4:*/		return 0x82112340;
		  /* 82112340h */ case    5:  		/* stfdx FR29, <#[R27 + R11]> */
		/* 82112340h case    5:*/		cpu::mem::store64f( regs, regs.FR29, (uint32)(regs.R27 + regs.R11 + 0x00000000) );
		/* 82112340h case    5:*/		return 0x82112344;
		  /* 82112344h */ case    6:  		/* stfdx FR31, <#[R27 + R10]> */
		/* 82112344h case    6:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R27 + regs.R10 + 0x00000000) );
		/* 82112344h case    6:*/		return 0x82112348;
		  /* 82112348h */ case    7:  		/* bc 4, CR6_EQ, 40 */
		/* 82112348h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82112370;  }
		/* 82112348h case    7:*/		return 0x8211234C;
	}
	return 0x8211234C;
} // Block from 8211232Ch-8211234Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8211234Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211234C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211234C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211234C);
		  /* 8211234Ch */ case    0:  		/* lwz R11, <#[R19 + 20]> */
		/* 8211234Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8211234Ch case    0:*/		return 0x82112350;
		  /* 82112350h */ case    1:  		/* rlwinm R10, R29, 2, 0, 29 */
		/* 82112350h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R29);
		/* 82112350h case    1:*/		return 0x82112354;
		  /* 82112354h */ case    2:  		/* lwz R9, <#[R28]> */
		/* 82112354h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000000) );
		/* 82112354h case    2:*/		return 0x82112358;
		  /* 82112358h */ case    3:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82112358h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82112358h case    3:*/		return 0x8211235C;
		  /* 8211235Ch */ case    4:  		/* lwz R11, <#[R11 + 52]> */
		/* 8211235Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 8211235Ch case    4:*/		return 0x82112360;
		  /* 82112360h */ case    5:  		/* cmplw CR6, R9, R11 */
		/* 82112360h case    5:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82112360h case    5:*/		return 0x82112364;
		  /* 82112364h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 82112364h case    6:*/		if ( regs.CR[6].eq ) { return 0x82112370;  }
		/* 82112364h case    6:*/		return 0x82112368;
		  /* 82112368h */ case    7:  		/* mr R29, R11 */
		/* 82112368h case    7:*/		regs.R29 = regs.R11;
		/* 82112368h case    7:*/		return 0x8211236C;
		  /* 8211236Ch */ case    8:  		/* b -356 */
		/* 8211236Ch case    8:*/		return 0x82112208;
		/* 8211236Ch case    8:*/		return 0x82112370;
	}
	return 0x82112370;
} // Block from 8211234Ch-82112370h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82112370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112370);
		  /* 82112370h */ case    0:  		/* addi R26, R26, 1 */
		/* 82112370h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 82112370h case    0:*/		return 0x82112374;
		  /* 82112374h */ case    1:  		/* addi R28, R28, 4 */
		/* 82112374h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82112374h case    1:*/		return 0x82112378;
		  /* 82112378h */ case    2:  		/* addi R27, R27, 8 */
		/* 82112378h case    2:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x8);
		/* 82112378h case    2:*/		return 0x8211237C;
		  /* 8211237Ch */ case    3:  		/* cmplw CR6, R26, R16 */
		/* 8211237Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R16);
		/* 8211237Ch case    3:*/		return 0x82112380;
		  /* 82112380h */ case    4:  		/* bc 12, CR6_LT, -380 */
		/* 82112380h case    4:*/		if ( regs.CR[6].lt ) { return 0x82112204;  }
		/* 82112380h case    4:*/		return 0x82112384;
	}
	return 0x82112384;
} // Block from 82112370h-82112384h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82112384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112384);
		  /* 82112384h */ case    0:  		/* cmplw CR6, R25, R16 */
		/* 82112384h case    0:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R16);
		/* 82112384h case    0:*/		return 0x82112388;
		  /* 82112388h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 82112388h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821123A0;  }
		/* 82112388h case    1:*/		return 0x8211238C;
		  /* 8211238Ch */ case    2:  		/* mr R5, R17 */
		/* 8211238Ch case    2:*/		regs.R5 = regs.R17;
		/* 8211238Ch case    2:*/		return 0x82112390;
		  /* 82112390h */ case    3:  		/* addi R4, R1, 160 */
		/* 82112390h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xA0);
		/* 82112390h case    3:*/		return 0x82112394;
		  /* 82112394h */ case    4:  		/* mr R3, R14 */
		/* 82112394h case    4:*/		regs.R3 = regs.R14;
		/* 82112394h case    4:*/		return 0x82112398;
		  /* 82112398h */ case    5:  		/* bl -526824 */
		/* 82112398h case    5:*/		regs.LR = 0x8211239C; return 0x820919B0;
		/* 82112398h case    5:*/		return 0x8211239C;
		  /* 8211239Ch */ case    6:  		/* b 4820 */
		/* 8211239Ch case    6:*/		return 0x82113670;
		/* 8211239Ch case    6:*/		return 0x821123A0;
	}
	return 0x821123A0;
} // Block from 82112384h-821123A0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821123A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821123A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821123A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821123A0);
		  /* 821123A0h */ case    0:  		/* li R22, -1 */
		/* 821123A0h case    0:*/		cpu::op::li<0>(regs,&regs.R22,0xFFFFFFFF);
		/* 821123A0h case    0:*/		return 0x821123A4;
		  /* 821123A4h */ case    1:  		/* cmplwi CR6, R16, 0 */
		/* 821123A4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 821123A4h case    1:*/		return 0x821123A8;
		  /* 821123A8h */ case    2:  		/* bc 12, CR6_EQ, 952 */
		/* 821123A8h case    2:*/		if ( regs.CR[6].eq ) { return 0x82112760;  }
		/* 821123A8h case    2:*/		return 0x821123AC;
		  /* 821123ACh */ case    3:  		/* mr R17, R15 */
		/* 821123ACh case    3:*/		regs.R17 = regs.R15;
		/* 821123ACh case    3:*/		return 0x821123B0;
		  /* 821123B0h */ case    4:  		/* mr R16, R15 */
		/* 821123B0h case    4:*/		regs.R16 = regs.R15;
		/* 821123B0h case    4:*/		return 0x821123B4;
		  /* 821123B4h */ case    5:  		/* addi R19, R1, 208 */
		/* 821123B4h case    5:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R1,0xD0);
		/* 821123B4h case    5:*/		return 0x821123B8;
		  /* 821123B8h */ case    6:  		/* lwzx R11, <#[R17 + R19]> */
		/* 821123B8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + regs.R19 + 0x00000000) );
		/* 821123B8h case    6:*/		return 0x821123BC;
		  /* 821123BCh */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 821123BCh case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821123BCh case    7:*/		return 0x821123C0;
		  /* 821123C0h */ case    8:  		/* bc 4, CR6_EQ, 880 */
		/* 821123C0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82112730;  }
		/* 821123C0h case    8:*/		return 0x821123C4;
		  /* 821123C4h */ case    9:  		/* addi R20, R1, 160 */
		/* 821123C4h case    9:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R1,0xA0);
		/* 821123C4h case    9:*/		return 0x821123C8;
		  /* 821123C8h */ case   10:  		/* lwz R3, <#[R1 + 516]> */
		/* 821123C8h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000204) );
		/* 821123C8h case   10:*/		return 0x821123CC;
		  /* 821123CCh */ case   11:  		/* lwzx R22, <#[R17 + R20]> */
		/* 821123CCh case   11:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R17 + regs.R20 + 0x00000000) );
		/* 821123CCh case   11:*/		return 0x821123D0;
		  /* 821123D0h */ case   12:  		/* lwz R11, <#[R3 + 20]> */
		/* 821123D0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 821123D0h case   12:*/		return 0x821123D4;
		  /* 821123D4h */ case   13:  		/* rlwinm R10, R22, 2, 0, 29 */
		/* 821123D4h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R22);
		/* 821123D4h case   13:*/		return 0x821123D8;
		  /* 821123D8h */ case   14:  		/* lwz R9, <#[R3 + 16]> */
		/* 821123D8h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000010) );
		/* 821123D8h case   14:*/		return 0x821123DC;
		  /* 821123DCh */ case   15:  		/* lwzx R11, <#[R10 + R11]> */
		/* 821123DCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821123DCh case   15:*/		return 0x821123E0;
		  /* 821123E0h */ case   16:  		/* lwz R10, <#[R11 + 4]> */
		/* 821123E0h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821123E0h case   16:*/		return 0x821123E4;
		  /* 821123E4h */ case   17:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821123E4h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821123E4h case   17:*/		return 0x821123E8;
		  /* 821123E8h */ case   18:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821123E8h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821123E8h case   18:*/		return 0x821123EC;
		  /* 821123ECh */ case   19:  		/* lwz R10, <#[R10 + 4]> */
		/* 821123ECh case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 821123ECh case   19:*/		return 0x821123F0;
		  /* 821123F0h */ case   20:  		/* rlwinm. R10, R10, 0, 23, 23 */
		/* 821123F0h case   20:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R10);
		/* 821123F0h case   20:*/		return 0x821123F4;
		  /* 821123F4h */ case   21:  		/* bc 12, CR0_EQ, 20 */
		/* 821123F4h case   21:*/		if ( regs.CR[0].eq ) { return 0x82112408;  }
		/* 821123F4h case   21:*/		return 0x821123F8;
		  /* 821123F8h */ case   22:  		/* lwz R11, <#[R11 + 8]> */
		/* 821123F8h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821123F8h case   22:*/		return 0x821123FC;
		  /* 821123FCh */ case   23:  		/* cmpwi CR6, R11, -1 */
		/* 821123FCh case   23:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 821123FCh case   23:*/		return 0x82112400;
		  /* 82112400h */ case   24:  		/* bc 12, CR6_EQ, 816 */
		/* 82112400h case   24:*/		if ( regs.CR[6].eq ) { return 0x82112730;  }
		/* 82112400h case   24:*/		return 0x82112404;
		  /* 82112404h */ case   25:  		/* rlwinm R3, R3, 0, 0, 31 */
		/* 82112404h case   25:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R3);
		/* 82112404h case   25:*/		return 0x82112408;
	}
	return 0x82112408;
} // Block from 821123A0h-82112408h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82112408h
// Function '?SimplifyUnary@CProgram@D3DXShader@@AAAJPAVCInstruction@2@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112408);
		  /* 82112408h */ case    0:  		/* li R18, -1 */
		/* 82112408h case    0:*/		cpu::op::li<0>(regs,&regs.R18,0xFFFFFFFF);
		/* 82112408h case    0:*/		return 0x8211240C;
		  /* 8211240Ch */ case    1:  		/* fmr FR11, FR31 */
		/* 8211240Ch case    1:*/		cpu::op::fmr<0>(regs,&regs.FR11,regs.FR31);
		/* 8211240Ch case    1:*/		return 0x82112410;
		  /* 82112410h */ case    2:  		/* fmr FR10, FR31 */
		/* 82112410h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR10,regs.FR31);
		/* 82112410h case    2:*/		return 0x82112414;
		  /* 82112414h */ case    3:  		/* li R23, 0 */
		/* 82112414h case    3:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82112414h case    3:*/		return 0x82112418;
		  /* 82112418h */ case    4:  		/* li R21, 0 */
		/* 82112418h case    4:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 82112418h case    4:*/		return 0x8211241C;
		  /* 8211241Ch */ case    5:  		/* mr R24, R22 */
		/* 8211241Ch case    5:*/		regs.R24 = regs.R22;
		/* 8211241Ch case    5:*/		return 0x82112420;
		  /* 82112420h */ case    6:  		/* mr R4, R24 */
		/* 82112420h case    6:*/		regs.R4 = regs.R24;
		/* 82112420h case    6:*/		return 0x82112424;
		  /* 82112424h */ case    7:  		/* lwz R7, <#[R1 + 572]> */
		/* 82112424h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x0000023C) );
		/* 82112424h case    7:*/		return 0x82112428;
		  /* 82112428h */ case    8:  		/* lwz R6, <#[R1 + 564]> */
		/* 82112428h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000234) );
		/* 82112428h case    8:*/		return 0x8211242C;
		  /* 8211242Ch */ case    9:  		/* lwz R5, <#[R1 + 556]> */
		/* 8211242Ch case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000022C) );
		/* 8211242Ch case    9:*/		return 0x82112430;
		  /* 82112430h */ case   10:  		/* bl -72248 */
		/* 82112430h case   10:*/		regs.LR = 0x82112434; return 0x821009F8;
		/* 82112430h case   10:*/		return 0x82112434;
		  /* 82112434h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 82112434h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82112434h case   11:*/		return 0x82112438;
		  /* 82112438h */ case   12:  		/* bc 12, CR0_EQ, 416 */
		/* 82112438h case   12:*/		if ( regs.CR[0].eq ) { return 0x821125D8;  }
		/* 82112438h case   12:*/		return 0x8211243C;
		  /* 8211243Ch */ case   13:  		/* stfd FR29, <#[R1 + 176]> */
		/* 8211243Ch case   13:*/		cpu::mem::store64f( regs, regs.FR29, (uint32)(regs.R1 + 0x000000B0) );
		/* 8211243Ch case   13:*/		return 0x82112440;
		  /* 82112440h */ case   14:  		/* mr R26, R24 */
		/* 82112440h case   14:*/		regs.R26 = regs.R24;
		/* 82112440h case   14:*/		return 0x82112444;
		  /* 82112444h */ case   15:  		/* stfd FR31, <#[R1 + 184]> */
		/* 82112444h case   15:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0x000000B8) );
		/* 82112444h case   15:*/		return 0x82112448;
		  /* 82112448h */ case   16:  		/* cmpwi CR6, R24, -1 */
		/* 82112448h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R24,0xFFFFFFFF);
		/* 82112448h case   16:*/		return 0x8211244C;
		  /* 8211244Ch */ case   17:  		/* bc 12, CR6_EQ, 396 */
		/* 8211244Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x821125D8;  }
		/* 8211244Ch case   17:*/		return 0x82112450;
		  /* 82112450h */ case   18:  		/* lwz R14, <#[R1 + 516]> */
		/* 82112450h case   18:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R1 + 0x00000204) );
		/* 82112450h case   18:*/		return 0x82112454;
		  /* 82112454h */ case   19:  		/* lwz R11, <#[R14 + 20]> */
		/* 82112454h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000014) );
		/* 82112454h case   19:*/		return 0x82112458;
		  /* 82112458h */ case   20:  		/* rlwinm R10, R26, 2, 0, 29 */
		/* 82112458h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R26);
		/* 82112458h case   20:*/		return 0x8211245C;
		  /* 8211245Ch */ case   21:  		/* li R28, 0 */
		/* 8211245Ch case   21:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8211245Ch case   21:*/		return 0x82112460;
		  /* 82112460h */ case   22:  		/* li R30, 0 */
		/* 82112460h case   22:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82112460h case   22:*/		return 0x82112464;
		  /* 82112464h */ case   23:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82112464h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82112464h case   23:*/		return 0x82112468;
		  /* 82112468h */ case   24:  		/* lwz R11, <#[R11 + 72]> */
		/* 82112468h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 82112468h case   24:*/		return 0x8211246C;
		  /* 8211246Ch */ case   25:  		/* cmpwi CR6, R11, -1 */
		/* 8211246Ch case   25:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8211246Ch case   25:*/		return 0x82112470;
		  /* 82112470h */ case   26:  		/* bc 4, CR6_EQ, 8 */
		/* 82112470h case   26:*/		if ( !regs.CR[6].eq ) { return 0x82112478;  }
		/* 82112470h case   26:*/		return 0x82112474;
		  /* 82112474h */ case   27:  		/* li R30, -1 */
		/* 82112474h case   27:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFFFFF);
		/* 82112474h case   27:*/		return 0x82112478;
	}
	return 0x82112478;
} // Block from 82112408h-82112478h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82112478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112478);
		  /* 82112478h */ case    0:  		/* lwz R25, <#[R1 + 532]> */
		/* 82112478h case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000214) );
		/* 82112478h case    0:*/		return 0x8211247C;
		  /* 8211247Ch */ case    1:  		/* li R27, 0 */
		/* 8211247Ch case    1:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8211247Ch case    1:*/		return 0x82112480;
		  /* 82112480h */ case    2:  		/* addi R11, R1, 208 */
		/* 82112480h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 82112480h case    2:*/		return 0x82112484;
		  /* 82112484h */ case    3:  		/* lwzx R11, <#[R27 + R11]> */
		/* 82112484h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + regs.R11 + 0x00000000) );
		/* 82112484h case    3:*/		return 0x82112488;
		  /* 82112488h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 82112488h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82112488h case    4:*/		return 0x8211248C;
		  /* 8211248Ch */ case    5:  		/* bc 4, CR6_EQ, 236 */
		/* 8211248Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x82112578;  }
		/* 8211248Ch case    5:*/		return 0x82112490;
		  /* 82112490h */ case    6:  		/* addi R11, R1, 160 */
		/* 82112490h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xA0);
		/* 82112490h case    6:*/		return 0x82112494;
		  /* 82112494h */ case    7:  		/* lwzx R29, <#[R27 + R11]> */
		/* 82112494h case    7:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R27 + regs.R11 + 0x00000000) );
		/* 82112494h case    7:*/		return 0x82112498;
		  /* 82112498h */ case    8:  		/* mr R31, R29 */
		/* 82112498h case    8:*/		regs.R31 = regs.R29;
		/* 82112498h case    8:*/		return 0x8211249C;
		  /* 8211249Ch */ case    9:  		/* mr R4, R31 */
		/* 8211249Ch case    9:*/		regs.R4 = regs.R31;
		/* 8211249Ch case    9:*/		return 0x821124A0;
		  /* 821124A0h */ case   10:  		/* lwz R7, <#[R1 + 572]> */
		/* 821124A0h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x0000023C) );
		/* 821124A0h case   10:*/		return 0x821124A4;
		  /* 821124A4h */ case   11:  		/* mr R3, R14 */
		/* 821124A4h case   11:*/		regs.R3 = regs.R14;
		/* 821124A4h case   11:*/		return 0x821124A8;
		  /* 821124A8h */ case   12:  		/* lwz R6, <#[R1 + 564]> */
		/* 821124A8h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000234) );
		/* 821124A8h case   12:*/		return 0x821124AC;
		  /* 821124ACh */ case   13:  		/* lwz R5, <#[R1 + 556]> */
		/* 821124ACh case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000022C) );
		/* 821124ACh case   13:*/		return 0x821124B0;
		  /* 821124B0h */ case   14:  		/* bl -72376 */
		/* 821124B0h case   14:*/		regs.LR = 0x821124B4; return 0x821009F8;
		/* 821124B0h case   14:*/		return 0x821124B4;
		  /* 821124B4h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 821124B4h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821124B4h case   15:*/		return 0x821124B8;
		  /* 821124B8h */ case   16:  		/* bc 12, CR0_EQ, 160 */
		/* 821124B8h case   16:*/		if ( regs.CR[0].eq ) { return 0x82112558;  }
		/* 821124B8h case   16:*/		return 0x821124BC;
		  /* 821124BCh */ case   17:  		/* mr R7, R31 */
		/* 821124BCh case   17:*/		regs.R7 = regs.R31;
		/* 821124BCh case   17:*/		return 0x821124C0;
		  /* 821124C0h */ case   18:  		/* cmpwi CR6, R31, -1 */
		/* 821124C0h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R31,0xFFFFFFFF);
		/* 821124C0h case   18:*/		return 0x821124C4;
		  /* 821124C4h */ case   19:  		/* bc 12, CR6_EQ, 148 */
		/* 821124C4h case   19:*/		if ( regs.CR[6].eq ) { return 0x82112558;  }
		/* 821124C4h case   19:*/		return 0x821124C8;
		  /* 821124C8h */ case   20:  		/* mr R5, R7 */
		/* 821124C8h case   20:*/		regs.R5 = regs.R7;
		/* 821124C8h case   20:*/		return 0x821124CC;
		  /* 821124CCh */ case   21:  		/* mr R4, R26 */
		/* 821124CCh case   21:*/		regs.R4 = regs.R26;
		/* 821124CCh case   21:*/		return 0x821124D0;
		  /* 821124D0h */ case   22:  		/* mr R3, R14 */
		/* 821124D0h case   22:*/		regs.R3 = regs.R14;
		/* 821124D0h case   22:*/		return 0x821124D4;
		  /* 821124D4h */ case   23:  		/* bl -72252 */
		/* 821124D4h case   23:*/		regs.LR = 0x821124D8; return 0x82100A98;
		/* 821124D4h case   23:*/		return 0x821124D8;
		  /* 821124D8h */ case   24:  		/* cmpwi CR0, R3, 0 */
		/* 821124D8h case   24:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821124D8h case   24:*/		return 0x821124DC;
		  /* 821124DCh */ case   25:  		/* bc 4, CR0_EQ, 52 */
		/* 821124DCh case   25:*/		if ( !regs.CR[0].eq ) { return 0x82112510;  }
		/* 821124DCh case   25:*/		return 0x821124E0;
		  /* 821124E0h */ case   26:  		/* lwz R11, <#[R1 + 144]> */
		/* 821124E0h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 821124E0h case   26:*/		return 0x821124E4;
		  /* 821124E4h */ case   27:  		/* cmpwi CR6, R11, 0 */
		/* 821124E4h case   27:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821124E4h case   27:*/		return 0x821124E8;
		  /* 821124E8h */ case   28:  		/* bc 4, CR6_EQ, 100 */
		/* 821124E8h case   28:*/		if ( !regs.CR[6].eq ) { return 0x8211254C;  }
		/* 821124E8h case   28:*/		return 0x821124EC;
		  /* 821124ECh */ case   29:  		/* li R6, 0 */
		/* 821124ECh case   29:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821124ECh case   29:*/		return 0x821124F0;
		  /* 821124F0h */ case   30:  		/* li R5, 0 */
		/* 821124F0h case   30:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821124F0h case   30:*/		return 0x821124F4;
		  /* 821124F4h */ case   31:  		/* mr R4, R7 */
		/* 821124F4h case   31:*/		regs.R4 = regs.R7;
		/* 821124F4h case   31:*/		return 0x821124F8;
		  /* 821124F8h */ case   32:  		/* mr R3, R14 */
		/* 821124F8h case   32:*/		regs.R3 = regs.R14;
		/* 821124F8h case   32:*/		return 0x821124FC;
		  /* 821124FCh */ case   33:  		/* bl -72188 */
		/* 821124FCh case   33:*/		regs.LR = 0x82112500; return 0x82100B00;
		/* 821124FCh case   33:*/		return 0x82112500;
		  /* 82112500h */ case   34:  		/* mr R7, R3 */
		/* 82112500h case   34:*/		regs.R7 = regs.R3;
		/* 82112500h case   34:*/		return 0x82112504;
		  /* 82112504h */ case   35:  		/* cmpwi CR6, R3, -1 */
		/* 82112504h case   35:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82112504h case   35:*/		return 0x82112508;
		  /* 82112508h */ case   36:  		/* bc 4, CR6_EQ, -64 */
		/* 82112508h case   36:*/		if ( !regs.CR[6].eq ) { return 0x821124C8;  }
		/* 82112508h case   36:*/		return 0x8211250C;
		  /* 8211250Ch */ case   37:  		/* b 76 */
		/* 8211250Ch case   37:*/		return 0x82112558;
		/* 8211250Ch case   37:*/		return 0x82112510;
	}
	return 0x82112510;
} // Block from 82112478h-82112510h (38 instructions)

//////////////////////////////////////////////////////
// Block at 82112510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112510);
		  /* 82112510h */ case    0:  		/* lwz R10, <#[R14 + 20]> */
		/* 82112510h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000014) );
		/* 82112510h case    0:*/		return 0x82112514;
		  /* 82112514h */ case    1:  		/* rlwinm R11, R7, 2, 0, 29 */
		/* 82112514h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 82112514h case    1:*/		return 0x82112518;
		  /* 82112518h */ case    2:  		/* addi R28, R28, 1 */
		/* 82112518h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82112518h case    2:*/		return 0x8211251C;
		  /* 8211251Ch */ case    3:  		/* lwzx R10, <#[R11 + R10]> */
		/* 8211251Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8211251Ch case    3:*/		return 0x82112520;
		  /* 82112520h */ case    4:  		/* lwz R10, <#[R10 + 72]> */
		/* 82112520h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000048) );
		/* 82112520h case    4:*/		return 0x82112524;
		  /* 82112524h */ case    5:  		/* cmpwi CR6, R10, -1 */
		/* 82112524h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82112524h case    5:*/		return 0x82112528;
		  /* 82112528h */ case    6:  		/* bc 12, CR6_EQ, 40 */
		/* 82112528h case    6:*/		if ( regs.CR[6].eq ) { return 0x82112550;  }
		/* 82112528h case    6:*/		return 0x8211252C;
		  /* 8211252Ch */ case    7:  		/* lwz R10, <#[R14 + 20]> */
		/* 8211252Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000014) );
		/* 8211252Ch case    7:*/		return 0x82112530;
		  /* 82112530h */ case    8:  		/* lwz R9, <#[R1 + 564]> */
		/* 82112530h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000234) );
		/* 82112530h case    8:*/		return 0x82112534;
		  /* 82112534h */ case    9:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82112534h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82112534h case    9:*/		return 0x82112538;
		  /* 82112538h */ case   10:  		/* lwz R11, <#[R11 + 72]> */
		/* 82112538h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 82112538h case   10:*/		return 0x8211253C;
		  /* 8211253Ch */ case   11:  		/* subf R11, R9, R11 */
		/* 8211253Ch case   11:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8211253Ch case   11:*/		return 0x82112540;
		  /* 82112540h */ case   12:  		/* mullw R11, R11, R11 */
		/* 82112540h case   12:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82112540h case   12:*/		return 0x82112544;
		  /* 82112544h */ case   13:  		/* add R30, R11, R30 */
		/* 82112544h case   13:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R30);
		/* 82112544h case   13:*/		return 0x82112548;
		  /* 82112548h */ case   14:  		/* b 8 */
		/* 82112548h case   14:*/		return 0x82112550;
		/* 82112548h case   14:*/		return 0x8211254C;
	}
	return 0x8211254C;
} // Block from 82112510h-8211254Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8211254Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211254C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211254C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211254C);
		  /* 8211254Ch */ case    0:  		/* li R7, -1 */
		/* 8211254Ch case    0:*/		cpu::op::li<0>(regs,&regs.R7,0xFFFFFFFF);
		/* 8211254Ch case    0:*/		return 0x82112550;
	}
	return 0x82112550;
} // Block from 8211254Ch-82112550h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82112550h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112550);
		  /* 82112550h */ case    0:  		/* cmpwi CR6, R7, -1 */
		/* 82112550h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R7,0xFFFFFFFF);
		/* 82112550h case    0:*/		return 0x82112554;
		  /* 82112554h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 82112554h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82112578;  }
		/* 82112554h case    1:*/		return 0x82112558;
	}
	return 0x82112558;
} // Block from 82112550h-82112558h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82112558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112558);
		  /* 82112558h */ case    0:  		/* lwz R11, <#[R14 + 20]> */
		/* 82112558h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000014) );
		/* 82112558h case    0:*/		return 0x8211255C;
		  /* 8211255Ch */ case    1:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 8211255Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 8211255Ch case    1:*/		return 0x82112560;
		  /* 82112560h */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82112560h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82112560h case    2:*/		return 0x82112564;
		  /* 82112564h */ case    3:  		/* lwz R11, <#[R11 + 52]> */
		/* 82112564h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 82112564h case    3:*/		return 0x82112568;
		  /* 82112568h */ case    4:  		/* cmplw CR6, R29, R11 */
		/* 82112568h case    4:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82112568h case    4:*/		return 0x8211256C;
		  /* 8211256Ch */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 8211256Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82112578;  }
		/* 8211256Ch case    5:*/		return 0x82112570;
		  /* 82112570h */ case    6:  		/* mr R31, R11 */
		/* 82112570h case    6:*/		regs.R31 = regs.R11;
		/* 82112570h case    6:*/		return 0x82112574;
		  /* 82112574h */ case    7:  		/* b -216 */
		/* 82112574h case    7:*/		return 0x8211249C;
		/* 82112574h case    7:*/		return 0x82112578;
	}
	return 0x82112578;
} // Block from 82112558h-82112578h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82112578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112578);
		  /* 82112578h */ case    0:  		/* addic. R25, R25, -1 */
		/* 82112578h case    0:*/		cpu::op::addic<1>(regs,&regs.R25,regs.R25,0xFFFFFFFF);
		/* 82112578h case    0:*/		return 0x8211257C;
		  /* 8211257Ch */ case    1:  		/* addi R27, R27, 4 */
		/* 8211257Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 8211257Ch case    1:*/		return 0x82112580;
		  /* 82112580h */ case    2:  		/* bc 4, CR0_EQ, -256 */
		/* 82112580h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82112480;  }
		/* 82112580h case    2:*/		return 0x82112584;
		  /* 82112584h */ case    3:  		/* cmplw CR6, R23, R28 */
		/* 82112584h case    3:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R28);
		/* 82112584h case    3:*/		return 0x82112588;
		  /* 82112588h */ case    4:  		/* bc 12, CR6_LT, 16 */
		/* 82112588h case    4:*/		if ( regs.CR[6].lt ) { return 0x82112598;  }
		/* 82112588h case    4:*/		return 0x8211258C;
		  /* 8211258Ch */ case    5:  		/* bc 4, CR6_EQ, 32 */
		/* 8211258Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x821125AC;  }
		/* 8211258Ch case    5:*/		return 0x82112590;
		  /* 82112590h */ case    6:  		/* cmplw CR6, R21, R30 */
		/* 82112590h case    6:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R30);
		/* 82112590h case    6:*/		return 0x82112594;
		  /* 82112594h */ case    7:  		/* bc 4, CR6_LT, 24 */
		/* 82112594h case    7:*/		if ( !regs.CR[6].lt ) { return 0x821125AC;  }
		/* 82112594h case    7:*/		return 0x82112598;
	}
	return 0x82112598;
} // Block from 82112578h-82112598h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82112598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112598);
		  /* 82112598h */ case    0:  		/* lfd FR11, <#[R1 + 176]> */
		/* 82112598h case    0:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R1 + 0x000000B0) );
		/* 82112598h case    0:*/		return 0x8211259C;
		  /* 8211259Ch */ case    1:  		/* mr R18, R26 */
		/* 8211259Ch case    1:*/		regs.R18 = regs.R26;
		/* 8211259Ch case    1:*/		return 0x821125A0;
		  /* 821125A0h */ case    2:  		/* lfd FR10, <#[R1 + 184]> */
		/* 821125A0h case    2:*/		cpu::mem::load64f( regs, &regs.FR10, (uint32)(regs.R1 + 0x000000B8) );
		/* 821125A0h case    2:*/		return 0x821125A4;
		  /* 821125A4h */ case    3:  		/* mr R23, R28 */
		/* 821125A4h case    3:*/		regs.R23 = regs.R28;
		/* 821125A4h case    3:*/		return 0x821125A8;
		  /* 821125A8h */ case    4:  		/* mr R21, R30 */
		/* 821125A8h case    4:*/		regs.R21 = regs.R30;
		/* 821125A8h case    4:*/		return 0x821125AC;
	}
	return 0x821125AC;
} // Block from 82112598h-821125ACh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821125ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821125AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821125AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821125AC);
		  /* 821125ACh */ case    0:  		/* lwz R11, <#[R1 + 144]> */
		/* 821125ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 821125ACh case    0:*/		return 0x821125B0;
		  /* 821125B0h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 821125B0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821125B0h case    1:*/		return 0x821125B4;
		  /* 821125B4h */ case    2:  		/* bc 4, CR6_EQ, 36 */
		/* 821125B4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821125D8;  }
		/* 821125B4h case    2:*/		return 0x821125B8;
		  /* 821125B8h */ case    3:  		/* addi R6, R1, 184 */
		/* 821125B8h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0xB8);
		/* 821125B8h case    3:*/		return 0x821125BC;
		  /* 821125BCh */ case    4:  		/* addi R5, R1, 176 */
		/* 821125BCh case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xB0);
		/* 821125BCh case    4:*/		return 0x821125C0;
		  /* 821125C0h */ case    5:  		/* mr R4, R26 */
		/* 821125C0h case    5:*/		regs.R4 = regs.R26;
		/* 821125C0h case    5:*/		return 0x821125C4;
		  /* 821125C4h */ case    6:  		/* mr R3, R14 */
		/* 821125C4h case    6:*/		regs.R3 = regs.R14;
		/* 821125C4h case    6:*/		return 0x821125C8;
		  /* 821125C8h */ case    7:  		/* bl -72392 */
		/* 821125C8h case    7:*/		regs.LR = 0x821125CC; return 0x82100B00;
		/* 821125C8h case    7:*/		return 0x821125CC;
		  /* 821125CCh */ case    8:  		/* mr R26, R3 */
		/* 821125CCh case    8:*/		regs.R26 = regs.R3;
		/* 821125CCh case    8:*/		return 0x821125D0;
		  /* 821125D0h */ case    9:  		/* cmpwi CR6, R3, -1 */
		/* 821125D0h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 821125D0h case    9:*/		return 0x821125D4;
		  /* 821125D4h */ case   10:  		/* bc 4, CR6_EQ, -384 */
		/* 821125D4h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82112454;  }
		/* 821125D4h case   10:*/		return 0x821125D8;
	}
	return 0x821125D8;
} // Block from 821125ACh-821125D8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821125D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821125D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821125D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821125D8);
		  /* 821125D8h */ case    0:  		/* lwz R14, <#[R1 + 516]> */
		/* 821125D8h case    0:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R1 + 0x00000204) );
		/* 821125D8h case    0:*/		return 0x821125DC;
		  /* 821125DCh */ case    1:  		/* rlwinm R11, R24, 2, 0, 29 */
		/* 821125DCh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R24);
		/* 821125DCh case    1:*/		return 0x821125E0;
		  /* 821125E0h */ case    2:  		/* lwz R25, <#[R14 + 20]> */
		/* 821125E0h case    2:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R14 + 0x00000014) );
		/* 821125E0h case    2:*/		return 0x821125E4;
		  /* 821125E4h */ case    3:  		/* lwzx R11, <#[R11 + R25]> */
		/* 821125E4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 821125E4h case    3:*/		return 0x821125E8;
		  /* 821125E8h */ case    4:  		/* lwz R11, <#[R11 + 52]> */
		/* 821125E8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 821125E8h case    4:*/		return 0x821125EC;
		  /* 821125ECh */ case    5:  		/* cmplw CR6, R22, R11 */
		/* 821125ECh case    5:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 821125ECh case    5:*/		return 0x821125F0;
		  /* 821125F0h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 821125F0h case    6:*/		if ( regs.CR[6].eq ) { return 0x82112600;  }
		/* 821125F0h case    6:*/		return 0x821125F4;
		  /* 821125F4h */ case    7:  		/* rlwinm R3, R14, 0, 0, 31 */
		/* 821125F4h case    7:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R14);
		/* 821125F4h case    7:*/		return 0x821125F8;
		  /* 821125F8h */ case    8:  		/* mr R24, R11 */
		/* 821125F8h case    8:*/		regs.R24 = regs.R11;
		/* 821125F8h case    8:*/		return 0x821125FC;
		  /* 821125FCh */ case    9:  		/* b -476 */
		/* 821125FCh case    9:*/		return 0x82112420;
		/* 821125FCh case    9:*/		return 0x82112600;
	}
	return 0x82112600;
} // Block from 821125D8h-82112600h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82112600h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112600);
		  /* 82112600h */ case    0:  		/* cmpwi CR6, R18, -1 */
		/* 82112600h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R18,0xFFFFFFFF);
		/* 82112600h case    0:*/		return 0x82112604;
		  /* 82112604h */ case    1:  		/* bc 12, CR6_EQ, -1224 */
		/* 82112604h case    1:*/		if ( regs.CR[6].eq ) { return 0x8211213C;  }
		/* 82112604h case    1:*/		return 0x82112608;
		  /* 82112608h */ case    2:  		/* addi R11, R1, 272 */
		/* 82112608h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x110);
		/* 82112608h case    2:*/		return 0x8211260C;
		  /* 8211260Ch */ case    3:  		/* lwz R27, <#[R1 + 532]> */
		/* 8211260Ch case    3:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000214) );
		/* 8211260Ch case    3:*/		return 0x82112610;
		  /* 82112610h */ case    4:  		/* addi R10, R1, 240 */
		/* 82112610h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xF0);
		/* 82112610h case    4:*/		return 0x82112614;
		  /* 82112614h */ case    5:  		/* stwx R18, <#[R17 + R20]> */
		/* 82112614h case    5:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R17 + regs.R20 + 0x00000000) );
		/* 82112614h case    5:*/		return 0x82112618;
		  /* 82112618h */ case    6:  		/* li R24, 1 */
		/* 82112618h case    6:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 82112618h case    6:*/		return 0x8211261C;
		  /* 8211261Ch */ case    7:  		/* li R31, 0 */
		/* 8211261Ch case    7:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8211261Ch case    7:*/		return 0x82112620;
		  /* 82112620h */ case    8:  		/* stwx R24, <#[R17 + R19]> */
		/* 82112620h case    8:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R17 + regs.R19 + 0x00000000) );
		/* 82112620h case    8:*/		return 0x82112624;
		  /* 82112624h */ case    9:  		/* li R29, 0 */
		/* 82112624h case    9:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82112624h case    9:*/		return 0x82112628;
		  /* 82112628h */ case   10:  		/* stfdx FR11, <#[R16 + R11]> */
		/* 82112628h case   10:*/		cpu::mem::store64f( regs, regs.FR11, (uint32)(regs.R16 + regs.R11 + 0x00000000) );
		/* 82112628h case   10:*/		return 0x8211262C;
		  /* 8211262Ch */ case   11:  		/* stfdx FR10, <#[R16 + R10]> */
		/* 8211262Ch case   11:*/		cpu::mem::store64f( regs, regs.FR10, (uint32)(regs.R16 + regs.R10 + 0x00000000) );
		/* 8211262Ch case   11:*/		return 0x82112630;
		  /* 82112630h */ case   12:  		/* addi R26, R1, 208 */
		/* 82112630h case   12:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R1,0xD0);
		/* 82112630h case   12:*/		return 0x82112634;
		  /* 82112634h */ case   13:  		/* lwzx R11, <#[R31 + R26]> */
		/* 82112634h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R26 + 0x00000000) );
		/* 82112634h case   13:*/		return 0x82112638;
		  /* 82112638h */ case   14:  		/* cmpwi CR6, R11, 0 */
		/* 82112638h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82112638h case   14:*/		return 0x8211263C;
		  /* 8211263Ch */ case   15:  		/* bc 4, CR6_EQ, 228 */
		/* 8211263Ch case   15:*/		if ( !regs.CR[6].eq ) { return 0x82112720;  }
		/* 8211263Ch case   15:*/		return 0x82112640;
		  /* 82112640h */ case   16:  		/* addi R28, R1, 160 */
		/* 82112640h case   16:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0xA0);
		/* 82112640h case   16:*/		return 0x82112644;
		  /* 82112644h */ case   17:  		/* lwzx R30, <#[R31 + R28]> */
		/* 82112644h case   17:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + regs.R28 + 0x00000000) );
		/* 82112644h case   17:*/		return 0x82112648;
		  /* 82112648h */ case   18:  		/* cmpwi CR6, R30, -1 */
		/* 82112648h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R30,0xFFFFFFFF);
		/* 82112648h case   18:*/		return 0x8211264C;
		  /* 8211264Ch */ case   19:  		/* bc 12, CR6_EQ, 212 */
		/* 8211264Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x82112720;  }
		/* 8211264Ch case   19:*/		return 0x82112650;
		  /* 82112650h */ case   20:  		/* mr R4, R30 */
		/* 82112650h case   20:*/		regs.R4 = regs.R30;
		/* 82112650h case   20:*/		return 0x82112654;
		  /* 82112654h */ case   21:  		/* lwz R7, <#[R1 + 572]> */
		/* 82112654h case   21:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x0000023C) );
		/* 82112654h case   21:*/		return 0x82112658;
		  /* 82112658h */ case   22:  		/* mr R3, R14 */
		/* 82112658h case   22:*/		regs.R3 = regs.R14;
		/* 82112658h case   22:*/		return 0x8211265C;
		  /* 8211265Ch */ case   23:  		/* lwz R6, <#[R1 + 564]> */
		/* 8211265Ch case   23:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000234) );
		/* 8211265Ch case   23:*/		return 0x82112660;
		  /* 82112660h */ case   24:  		/* lwz R5, <#[R1 + 556]> */
		/* 82112660h case   24:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000022C) );
		/* 82112660h case   24:*/		return 0x82112664;
		  /* 82112664h */ case   25:  		/* bl -72812 */
		/* 82112664h case   25:*/		regs.LR = 0x82112668; return 0x821009F8;
		/* 82112664h case   25:*/		return 0x82112668;
		  /* 82112668h */ case   26:  		/* cmpwi CR0, R3, 0 */
		/* 82112668h case   26:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82112668h case   26:*/		return 0x8211266C;
		  /* 8211266Ch */ case   27:  		/* bc 12, CR0_EQ, 144 */
		/* 8211266Ch case   27:*/		if ( regs.CR[0].eq ) { return 0x821126FC;  }
		/* 8211266Ch case   27:*/		return 0x82112670;
		  /* 82112670h */ case   28:  		/* stfd FR29, <#[R1 + 184]> */
		/* 82112670h case   28:*/		cpu::mem::store64f( regs, regs.FR29, (uint32)(regs.R1 + 0x000000B8) );
		/* 82112670h case   28:*/		return 0x82112674;
		  /* 82112674h */ case   29:  		/* mr R7, R30 */
		/* 82112674h case   29:*/		regs.R7 = regs.R30;
		/* 82112674h case   29:*/		return 0x82112678;
		  /* 82112678h */ case   30:  		/* stfd FR31, <#[R1 + 176]> */
		/* 82112678h case   30:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0x000000B0) );
		/* 82112678h case   30:*/		return 0x8211267C;
		  /* 8211267Ch */ case   31:  		/* cmpwi CR6, R30, -1 */
		/* 8211267Ch case   31:*/		cpu::op::cmpwi<6>(regs,regs.R30,0xFFFFFFFF);
		/* 8211267Ch case   31:*/		return 0x82112680;
		  /* 82112680h */ case   32:  		/* bc 12, CR6_EQ, 124 */
		/* 82112680h case   32:*/		if ( regs.CR[6].eq ) { return 0x821126FC;  }
		/* 82112680h case   32:*/		return 0x82112684;
		  /* 82112684h */ case   33:  		/* mr R5, R7 */
		/* 82112684h case   33:*/		regs.R5 = regs.R7;
		/* 82112684h case   33:*/		return 0x82112688;
		  /* 82112688h */ case   34:  		/* mr R4, R18 */
		/* 82112688h case   34:*/		regs.R4 = regs.R18;
		/* 82112688h case   34:*/		return 0x8211268C;
		  /* 8211268Ch */ case   35:  		/* mr R3, R14 */
		/* 8211268Ch case   35:*/		regs.R3 = regs.R14;
		/* 8211268Ch case   35:*/		return 0x82112690;
		  /* 82112690h */ case   36:  		/* bl -72696 */
		/* 82112690h case   36:*/		regs.LR = 0x82112694; return 0x82100A98;
		/* 82112690h case   36:*/		return 0x82112694;
		  /* 82112694h */ case   37:  		/* cmpwi CR0, R3, 0 */
		/* 82112694h case   37:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82112694h case   37:*/		return 0x82112698;
		  /* 82112698h */ case   38:  		/* bc 4, CR0_EQ, 52 */
		/* 82112698h case   38:*/		if ( !regs.CR[0].eq ) { return 0x821126CC;  }
		/* 82112698h case   38:*/		return 0x8211269C;
		  /* 8211269Ch */ case   39:  		/* lwz R11, <#[R1 + 144]> */
		/* 8211269Ch case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 8211269Ch case   39:*/		return 0x821126A0;
		  /* 821126A0h */ case   40:  		/* cmpwi CR6, R11, 0 */
		/* 821126A0h case   40:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821126A0h case   40:*/		return 0x821126A4;
		  /* 821126A4h */ case   41:  		/* bc 4, CR6_EQ, 76 */
		/* 821126A4h case   41:*/		if ( !regs.CR[6].eq ) { return 0x821126F0;  }
		/* 821126A4h case   41:*/		return 0x821126A8;
		  /* 821126A8h */ case   42:  		/* addi R6, R1, 176 */
		/* 821126A8h case   42:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0xB0);
		/* 821126A8h case   42:*/		return 0x821126AC;
		  /* 821126ACh */ case   43:  		/* addi R5, R1, 184 */
		/* 821126ACh case   43:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xB8);
		/* 821126ACh case   43:*/		return 0x821126B0;
		  /* 821126B0h */ case   44:  		/* mr R4, R7 */
		/* 821126B0h case   44:*/		regs.R4 = regs.R7;
		/* 821126B0h case   44:*/		return 0x821126B4;
		  /* 821126B4h */ case   45:  		/* mr R3, R14 */
		/* 821126B4h case   45:*/		regs.R3 = regs.R14;
		/* 821126B4h case   45:*/		return 0x821126B8;
		  /* 821126B8h */ case   46:  		/* bl -72632 */
		/* 821126B8h case   46:*/		regs.LR = 0x821126BC; return 0x82100B00;
		/* 821126B8h case   46:*/		return 0x821126BC;
		  /* 821126BCh */ case   47:  		/* mr R7, R3 */
		/* 821126BCh case   47:*/		regs.R7 = regs.R3;
		/* 821126BCh case   47:*/		return 0x821126C0;
		  /* 821126C0h */ case   48:  		/* cmpwi CR6, R3, -1 */
		/* 821126C0h case   48:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 821126C0h case   48:*/		return 0x821126C4;
		  /* 821126C4h */ case   49:  		/* bc 4, CR6_EQ, -64 */
		/* 821126C4h case   49:*/		if ( !regs.CR[6].eq ) { return 0x82112684;  }
		/* 821126C4h case   49:*/		return 0x821126C8;
		  /* 821126C8h */ case   50:  		/* b 52 */
		/* 821126C8h case   50:*/		return 0x821126FC;
		/* 821126C8h case   50:*/		return 0x821126CC;
	}
	return 0x821126CC;
} // Block from 82112600h-821126CCh (51 instructions)

//////////////////////////////////////////////////////
// Block at 821126CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821126CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821126CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821126CC);
		  /* 821126CCh */ case    0:  		/* addi R11, R1, 272 */
		/* 821126CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x110);
		/* 821126CCh case    0:*/		return 0x821126D0;
		  /* 821126D0h */ case    1:  		/* lfd FR0, <#[R1 + 184]> */
		/* 821126D0h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000B8) );
		/* 821126D0h case    1:*/		return 0x821126D4;
		  /* 821126D4h */ case    2:  		/* addi R10, R1, 240 */
		/* 821126D4h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xF0);
		/* 821126D4h case    2:*/		return 0x821126D8;
		  /* 821126D8h */ case    3:  		/* lfd FR13, <#[R1 + 176]> */
		/* 821126D8h case    3:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x000000B0) );
		/* 821126D8h case    3:*/		return 0x821126DC;
		  /* 821126DCh */ case    4:  		/* stwx R7, <#[R31 + R28]> */
		/* 821126DCh case    4:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + regs.R28 + 0x00000000) );
		/* 821126DCh case    4:*/		return 0x821126E0;
		  /* 821126E0h */ case    5:  		/* stwx R24, <#[R31 + R26]> */
		/* 821126E0h case    5:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + regs.R26 + 0x00000000) );
		/* 821126E0h case    5:*/		return 0x821126E4;
		  /* 821126E4h */ case    6:  		/* stfdx FR0, <#[R29 + R11]> */
		/* 821126E4h case    6:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 821126E4h case    6:*/		return 0x821126E8;
		  /* 821126E8h */ case    7:  		/* stfdx FR13, <#[R29 + R10]> */
		/* 821126E8h case    7:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R29 + regs.R10 + 0x00000000) );
		/* 821126E8h case    7:*/		return 0x821126EC;
		  /* 821126ECh */ case    8:  		/* b 8 */
		/* 821126ECh case    8:*/		return 0x821126F4;
		/* 821126ECh case    8:*/		return 0x821126F0;
	}
	return 0x821126F0;
} // Block from 821126CCh-821126F0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821126F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821126F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821126F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821126F0);
		  /* 821126F0h */ case    0:  		/* li R7, -1 */
		/* 821126F0h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0xFFFFFFFF);
		/* 821126F0h case    0:*/		return 0x821126F4;
	}
	return 0x821126F4;
} // Block from 821126F0h-821126F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821126F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821126F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821126F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821126F4);
		  /* 821126F4h */ case    0:  		/* cmpwi CR6, R7, -1 */
		/* 821126F4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R7,0xFFFFFFFF);
		/* 821126F4h case    0:*/		return 0x821126F8;
		  /* 821126F8h */ case    1:  		/* bc 4, CR6_EQ, 40 */
		/* 821126F8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82112720;  }
		/* 821126F8h case    1:*/		return 0x821126FC;
	}
	return 0x821126FC;
} // Block from 821126F4h-821126FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821126FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821126FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821126FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821126FC);
		  /* 821126FCh */ case    0:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 821126FCh case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 821126FCh case    0:*/		return 0x82112700;
		  /* 82112700h */ case    1:  		/* lwzx R10, <#[R31 + R28]> */
		/* 82112700h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + regs.R28 + 0x00000000) );
		/* 82112700h case    1:*/		return 0x82112704;
		  /* 82112704h */ case    2:  		/* lwzx R11, <#[R11 + R25]> */
		/* 82112704h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 82112704h case    2:*/		return 0x82112708;
		  /* 82112708h */ case    3:  		/* lwz R11, <#[R11 + 52]> */
		/* 82112708h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 82112708h case    3:*/		return 0x8211270C;
		  /* 8211270Ch */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 8211270Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8211270Ch case    4:*/		return 0x82112710;
		  /* 82112710h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 82112710h case    5:*/		if ( regs.CR[6].eq ) { return 0x82112720;  }
		/* 82112710h case    5:*/		return 0x82112714;
		  /* 82112714h */ case    6:  		/* mr R30, R11 */
		/* 82112714h case    6:*/		regs.R30 = regs.R11;
		/* 82112714h case    6:*/		return 0x82112718;
		  /* 82112718h */ case    7:  		/* cmpwi CR6, R11, -1 */
		/* 82112718h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82112718h case    7:*/		return 0x8211271C;
		  /* 8211271Ch */ case    8:  		/* bc 4, CR6_EQ, -204 */
		/* 8211271Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x82112650;  }
		/* 8211271Ch case    8:*/		return 0x82112720;
	}
	return 0x82112720;
} // Block from 821126FCh-82112720h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82112720h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112720);
		  /* 82112720h */ case    0:  		/* addic. R27, R27, -1 */
		/* 82112720h case    0:*/		cpu::op::addic<1>(regs,&regs.R27,regs.R27,0xFFFFFFFF);
		/* 82112720h case    0:*/		return 0x82112724;
		  /* 82112724h */ case    1:  		/* addi R31, R31, 4 */
		/* 82112724h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82112724h case    1:*/		return 0x82112728;
		  /* 82112728h */ case    2:  		/* addi R29, R29, 8 */
		/* 82112728h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x8);
		/* 82112728h case    2:*/		return 0x8211272C;
		  /* 8211272Ch */ case    3:  		/* bc 4, CR0_EQ, -252 */
		/* 8211272Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x82112630;  }
		/* 8211272Ch case    3:*/		return 0x82112730;
	}
	return 0x82112730;
} // Block from 82112720h-82112730h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82112730h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112730);
		  /* 82112730h */ case    0:  		/* lwz R11, <#[R1 + 532]> */
		/* 82112730h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000214) );
		/* 82112730h case    0:*/		return 0x82112734;
		  /* 82112734h */ case    1:  		/* addi R15, R15, 1 */
		/* 82112734h case    1:*/		cpu::op::addi<0>(regs,&regs.R15,regs.R15,0x1);
		/* 82112734h case    1:*/		return 0x82112738;
		  /* 82112738h */ case    2:  		/* addi R16, R16, 8 */
		/* 82112738h case    2:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R16,0x8);
		/* 82112738h case    2:*/		return 0x8211273C;
		  /* 8211273Ch */ case    3:  		/* addi R17, R17, 4 */
		/* 8211273Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x4);
		/* 8211273Ch case    3:*/		return 0x82112740;
		  /* 82112740h */ case    4:  		/* cmplw CR6, R15, R11 */
		/* 82112740h case    4:*/		cpu::op::cmplw<6>(regs,regs.R15,regs.R11);
		/* 82112740h case    4:*/		return 0x82112744;
		  /* 82112744h */ case    5:  		/* bc 12, CR6_LT, -912 */
		/* 82112744h case    5:*/		if ( regs.CR[6].lt ) { return 0x821123B4;  }
		/* 82112744h case    5:*/		return 0x82112748;
		  /* 82112748h */ case    6:  		/* lwz R19, <#[R1 + 516]> */
		/* 82112748h case    6:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R1 + 0x00000204) );
		/* 82112748h case    6:*/		return 0x8211274C;
		  /* 8211274Ch */ case    7:  		/* li R22, -1 */
		/* 8211274Ch case    7:*/		cpu::op::li<0>(regs,&regs.R22,0xFFFFFFFF);
		/* 8211274Ch case    7:*/		return 0x82112750;
		  /* 82112750h */ case    8:  		/* lwz R18, <#[R1 + 556]> */
		/* 82112750h case    8:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R1 + 0x0000022C) );
		/* 82112750h case    8:*/		return 0x82112754;
		  /* 82112754h */ case    9:  		/* rlwinm R16, R11, 0, 0, 31 */
		/* 82112754h case    9:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R16,regs.R11);
		/* 82112754h case    9:*/		return 0x82112758;
		  /* 82112758h */ case   10:  		/* lwz R14, <#[R1 + 524]> */
		/* 82112758h case   10:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R1 + 0x0000020C) );
		/* 82112758h case   10:*/		return 0x8211275C;
		  /* 8211275Ch */ case   11:  		/* lwz R17, <#[R1 + 192]> */
		/* 8211275Ch case   11:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R1 + 0x000000C0) );
		/* 8211275Ch case   11:*/		return 0x82112760;
	}
	return 0x82112760;
} // Block from 82112730h-82112760h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82112760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112760);
		  /* 82112760h */ case    0:  		/* lwz R15, <#[R1 + 540]> */
		/* 82112760h case    0:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R1 + 0x0000021C) );
		/* 82112760h case    0:*/		return 0x82112764;
		  /* 82112764h */ case    1:  		/* li R29, 0 */
		/* 82112764h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82112764h case    1:*/		return 0x82112768;
		  /* 82112768h */ case    2:  		/* li R23, 0 */
		/* 82112768h case    2:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82112768h case    2:*/		return 0x8211276C;
		  /* 8211276Ch */ case    3:  		/* li R21, 0 */
		/* 8211276Ch case    3:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 8211276Ch case    3:*/		return 0x82112770;
		  /* 82112770h */ case    4:  		/* li R20, 0 */
		/* 82112770h case    4:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 82112770h case    4:*/		return 0x82112774;
		  /* 82112774h */ case    5:  		/* cmplwi CR6, R16, 0 */
		/* 82112774h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 82112774h case    5:*/		return 0x82112778;
		  /* 82112778h */ case    6:  		/* bc 12, CR6_EQ, 180 */
		/* 82112778h case    6:*/		if ( regs.CR[6].eq ) { return 0x8211282C;  }
		/* 82112778h case    6:*/		return 0x8211277C;
		  /* 8211277Ch */ case    7:  		/* lwz R26, <#[R19 + 20]> */
		/* 8211277Ch case    7:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R19 + 0x00000014) );
		/* 8211277Ch case    7:*/		return 0x82112780;
		  /* 82112780h */ case    8:  		/* addi R7, R1, 160 */
		/* 82112780h case    8:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xA0);
		/* 82112780h case    8:*/		return 0x82112784;
		  /* 82112784h */ case    9:  		/* lwz R24, <#[R19 + 16]> */
		/* 82112784h case    9:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R19 + 0x00000010) );
		/* 82112784h case    9:*/		return 0x82112788;
		  /* 82112788h */ case   10:  		/* li R31, 0 */
		/* 82112788h case   10:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82112788h case   10:*/		return 0x8211278C;
		  /* 8211278Ch */ case   11:  		/* mr R30, R16 */
		/* 8211278Ch case   11:*/		regs.R30 = regs.R16;
		/* 8211278Ch case   11:*/		return 0x82112790;
		  /* 82112790h */ case   12:  		/* lwz R4, <#[R7]> */
		/* 82112790h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R7 + 0x00000000) );
		/* 82112790h case   12:*/		return 0x82112794;
		  /* 82112794h */ case   13:  		/* mr R3, R19 */
		/* 82112794h case   13:*/		regs.R3 = regs.R19;
		/* 82112794h case   13:*/		return 0x82112798;
		  /* 82112798h */ case   14:  		/* lwz R5, <#[R1 + 160]> */
		/* 82112798h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000A0) );
		/* 82112798h case   14:*/		return 0x8211279C;
		  /* 8211279Ch */ case   15:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 8211279Ch case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 8211279Ch case   15:*/		return 0x821127A0;
		  /* 821127A0h */ case   16:  		/* lwzx R6, <#[R11 + R26]> */
		/* 821127A0h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 821127A0h case   16:*/		return 0x821127A4;
		  /* 821127A4h */ case   17:  		/* bl -72972 */
		/* 821127A4h case   17:*/		regs.LR = 0x821127A8; return 0x82100A98;
		/* 821127A4h case   17:*/		return 0x821127A8;
		  /* 821127A8h */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 821127A8h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821127A8h case   18:*/		return 0x821127AC;
		  /* 821127ACh */ case   19:  		/* bc 4, CR0_EQ, 8 */
		/* 821127ACh case   19:*/		if ( !regs.CR[0].eq ) { return 0x821127B4;  }
		/* 821127ACh case   19:*/		return 0x821127B0;
		  /* 821127B0h */ case   20:  		/* li R29, 1 */
		/* 821127B0h case   20:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 821127B0h case   20:*/		return 0x821127B4;
	}
	return 0x821127B4;
} // Block from 82112760h-821127B4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821127B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821127B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821127B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821127B4);
		  /* 821127B4h */ case    0:  		/* addi R11, R1, 272 */
		/* 821127B4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x110);
		/* 821127B4h case    0:*/		return 0x821127B8;
		  /* 821127B8h */ case    1:  		/* lfdx FR0, <#[R31 + R11]> */
		/* 821127B8h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 821127B8h case    1:*/		return 0x821127BC;
		  /* 821127BCh */ case    2:  		/* fcmpu CR6, FR0, FR29 */
		/* 821127BCh case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR29);
		/* 821127BCh case    2:*/		return 0x821127C0;
		  /* 821127C0h */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 821127C0h case    3:*/		if ( regs.CR[6].eq ) { return 0x821127C8;  }
		/* 821127C0h case    3:*/		return 0x821127C4;
		  /* 821127C4h */ case    4:  		/* li R23, 1 */
		/* 821127C4h case    4:*/		cpu::op::li<0>(regs,&regs.R23,0x1);
		/* 821127C4h case    4:*/		return 0x821127C8;
	}
	return 0x821127C8;
} // Block from 821127B4h-821127C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821127C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821127C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821127C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821127C8);
		  /* 821127C8h */ case    0:  		/* addi R11, R1, 240 */
		/* 821127C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xF0);
		/* 821127C8h case    0:*/		return 0x821127CC;
		  /* 821127CCh */ case    1:  		/* lfdx FR0, <#[R31 + R11]> */
		/* 821127CCh case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 821127CCh case    1:*/		return 0x821127D0;
		  /* 821127D0h */ case    2:  		/* fcmpu CR6, FR0, FR31 */
		/* 821127D0h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 821127D0h case    2:*/		return 0x821127D4;
		  /* 821127D4h */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 821127D4h case    3:*/		if ( regs.CR[6].eq ) { return 0x821127DC;  }
		/* 821127D4h case    3:*/		return 0x821127D8;
		  /* 821127D8h */ case    4:  		/* li R21, 1 */
		/* 821127D8h case    4:*/		cpu::op::li<0>(regs,&regs.R21,0x1);
		/* 821127D8h case    4:*/		return 0x821127DC;
	}
	return 0x821127DC;
} // Block from 821127C8h-821127DCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821127DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821127DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821127DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821127DC);
		  /* 821127DCh */ case    0:  		/* lwz R11, <#[R6 + 4]> */
		/* 821127DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000004) );
		/* 821127DCh case    0:*/		return 0x821127E0;
		  /* 821127E0h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821127E0h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821127E0h case    1:*/		return 0x821127E4;
		  /* 821127E4h */ case    2:  		/* lwzx R11, <#[R11 + R24]> */
		/* 821127E4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R24 + 0x00000000) );
		/* 821127E4h case    2:*/		return 0x821127E8;
		  /* 821127E8h */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 821127E8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821127E8h case    3:*/		return 0x821127EC;
		  /* 821127ECh */ case    4:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 821127ECh case    4:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 821127ECh case    4:*/		return 0x821127F0;
		  /* 821127F0h */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 821127F0h case    5:*/		if ( regs.CR[0].eq ) { return 0x82112804;  }
		/* 821127F0h case    5:*/		return 0x821127F4;
		  /* 821127F4h */ case    6:  		/* lwz R11, <#[R6 + 8]> */
		/* 821127F4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000008) );
		/* 821127F4h case    6:*/		return 0x821127F8;
		  /* 821127F8h */ case    7:  		/* cmpwi CR6, R11, -1 */
		/* 821127F8h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 821127F8h case    7:*/		return 0x821127FC;
		  /* 821127FCh */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 821127FCh case    8:*/		if ( !regs.CR[6].eq ) { return 0x82112804;  }
		/* 821127FCh case    8:*/		return 0x82112800;
		  /* 82112800h */ case    9:  		/* li R20, 1 */
		/* 82112800h case    9:*/		cpu::op::li<0>(regs,&regs.R20,0x1);
		/* 82112800h case    9:*/		return 0x82112804;
	}
	return 0x82112804;
} // Block from 821127DCh-82112804h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82112804h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112804( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112804) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112804);
		  /* 82112804h */ case    0:  		/* addic. R30, R30, -1 */
		/* 82112804h case    0:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 82112804h case    0:*/		return 0x82112808;
		  /* 82112808h */ case    1:  		/* addi R7, R7, 4 */
		/* 82112808h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82112808h case    1:*/		return 0x8211280C;
		  /* 8211280Ch */ case    2:  		/* addi R31, R31, 8 */
		/* 8211280Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x8);
		/* 8211280Ch case    2:*/		return 0x82112810;
		  /* 82112810h */ case    3:  		/* bc 4, CR0_EQ, -128 */
		/* 82112810h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82112790;  }
		/* 82112810h case    3:*/		return 0x82112814;
		  /* 82112814h */ case    4:  		/* cmpwi CR6, R23, 0 */
		/* 82112814h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 82112814h case    4:*/		return 0x82112818;
		  /* 82112818h */ case    5:  		/* bc 4, CR6_EQ, 48 */
		/* 82112818h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82112848;  }
		/* 82112818h case    5:*/		return 0x8211281C;
		  /* 8211281Ch */ case    6:  		/* cmpwi CR6, R21, 0 */
		/* 8211281Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 8211281Ch case    6:*/		return 0x82112820;
		  /* 82112820h */ case    7:  		/* bc 4, CR6_EQ, 40 */
		/* 82112820h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82112848;  }
		/* 82112820h case    7:*/		return 0x82112824;
		  /* 82112824h */ case    8:  		/* cmpwi CR6, R29, 0 */
		/* 82112824h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82112824h case    8:*/		return 0x82112828;
		  /* 82112828h */ case    9:  		/* bc 4, CR6_EQ, 32 */
		/* 82112828h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82112848;  }
		/* 82112828h case    9:*/		return 0x8211282C;
	}
	return 0x8211282C;
} // Block from 82112804h-8211282Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8211282Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211282C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211282C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211282C);
		  /* 8211282Ch */ case    0:  		/* li R31, 1 */
		/* 8211282Ch case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 8211282Ch case    0:*/		return 0x82112830;
		  /* 82112830h */ case    1:  		/* mr R5, R17 */
		/* 82112830h case    1:*/		regs.R5 = regs.R17;
		/* 82112830h case    1:*/		return 0x82112834;
		  /* 82112834h */ case    2:  		/* addi R4, R1, 160 */
		/* 82112834h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xA0);
		/* 82112834h case    2:*/		return 0x82112838;
		  /* 82112838h */ case    3:  		/* mr R3, R14 */
		/* 82112838h case    3:*/		regs.R3 = regs.R14;
		/* 82112838h case    3:*/		return 0x8211283C;
		  /* 8211283Ch */ case    4:  		/* bl -528012 */
		/* 8211283Ch case    4:*/		regs.LR = 0x82112840; return 0x820919B0;
		/* 8211283Ch case    4:*/		return 0x82112840;
		  /* 82112840h */ case    5:  		/* mr R3, R31 */
		/* 82112840h case    5:*/		regs.R3 = regs.R31;
		/* 82112840h case    5:*/		return 0x82112844;
		  /* 82112844h */ case    6:  		/* b 3632 */
		/* 82112844h case    6:*/		return 0x82113674;
		/* 82112844h case    6:*/		return 0x82112848;
	}
	return 0x82112848;
} // Block from 8211282Ch-82112848h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82112848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112848);
		  /* 82112848h */ case    0:  		/* lwz R11, <#[R1 + 144]> */
		/* 82112848h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 82112848h case    0:*/		return 0x8211284C;
		  /* 8211284Ch */ case    1:  		/* li R3, 0 */
		/* 8211284Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8211284Ch case    1:*/		return 0x82112850;
		  /* 82112850h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 82112850h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82112850h case    2:*/		return 0x82112854;
		  /* 82112854h */ case    3:  		/* bc 4, CR6_EQ, 3616 */
		/* 82112854h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82113674;  }
		/* 82112854h case    3:*/		return 0x82112858;
		  /* 82112858h */ case    4:  		/* lwz R25, <#[R19 + 108]> */
		/* 82112858h case    4:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R19 + 0x0000006C) );
		/* 82112858h case    4:*/		return 0x8211285C;
		  /* 8211285Ch */ case    5:  		/* li R29, 0 */
		/* 8211285Ch case    5:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8211285Ch case    5:*/		return 0x82112860;
		  /* 82112860h */ case    6:  		/* li R7, 0 */
		/* 82112860h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82112860h case    6:*/		return 0x82112864;
		  /* 82112864h */ case    7:  		/* rlwinm R11, R25, 3, 0, 28 */
		/* 82112864h case    7:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R25);
		/* 82112864h case    7:*/		return 0x82112868;
		  /* 82112868h */ case    8:  		/* srawi R28, R11, 31 */
		/* 82112868h case    8:*/		cpu::op::srawi<0,31>(regs,&regs.R28,regs.R11);
		/* 82112868h case    8:*/		return 0x8211286C;
		  /* 8211286Ch */ case    9:  		/* addi R11, R1, 160 */
		/* 8211286Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xA0);
		/* 8211286Ch case    9:*/		return 0x82112870;
		  /* 82112870h */ case   10:  		/* cmpwi CR6, R28, 0 */
		/* 82112870h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 82112870h case   10:*/		return 0x82112874;
		  /* 82112874h */ case   11:  		/* lwzx R11, <#[R3 + R11]> */
		/* 82112874h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 82112874h case   11:*/		return 0x82112878;
		  /* 82112878h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82112878h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82112878h case   12:*/		return 0x8211287C;
		  /* 8211287Ch */ case   13:  		/* lwzx R5, <#[R11 + R26]> */
		/* 8211287Ch case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 8211287Ch case   13:*/		return 0x82112880;
		  /* 82112880h */ case   14:  		/* bc 4, CR6_EQ, 304 */
		/* 82112880h case   14:*/		if ( !regs.CR[6].eq ) { return 0x821129B0;  }
		/* 82112880h case   14:*/		return 0x82112884;
		  /* 82112884h */ case   15:  		/* rlwinm. R11, R25, 0, 2, 2 */
		/* 82112884h case   15:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R11,regs.R25);
		/* 82112884h case   15:*/		return 0x82112888;
		  /* 82112888h */ case   16:  		/* bc 4, CR0_EQ, 296 */
		/* 82112888h case   16:*/		if ( !regs.CR[0].eq ) { return 0x821129B0;  }
		/* 82112888h case   16:*/		return 0x8211288C;
		  /* 8211288Ch */ case   17:  		/* lwz R4, <#[R5 + 4]> */
		/* 8211288Ch case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x00000004) );
		/* 8211288Ch case   17:*/		return 0x82112890;
		  /* 82112890h */ case   18:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 82112890h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 82112890h case   18:*/		return 0x82112894;
		  /* 82112894h */ case   19:  		/* lwzx R11, <#[R11 + R24]> */
		/* 82112894h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R24 + 0x00000000) );
		/* 82112894h case   19:*/		return 0x82112898;
		  /* 82112898h */ case   20:  		/* lwz R11, <#[R11 + 4]> */
		/* 82112898h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82112898h case   20:*/		return 0x8211289C;
		  /* 8211289Ch */ case   21:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 8211289Ch case   21:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 8211289Ch case   21:*/		return 0x821128A0;
		  /* 821128A0h */ case   22:  		/* bc 12, CR0_EQ, 104 */
		/* 821128A0h case   22:*/		if ( regs.CR[0].eq ) { return 0x82112908;  }
		/* 821128A0h case   22:*/		return 0x821128A4;
		  /* 821128A4h */ case   23:  		/* lwz R11, <#[R5 + 8]> */
		/* 821128A4h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 821128A4h case   23:*/		return 0x821128A8;
		  /* 821128A8h */ case   24:  		/* cmpwi CR6, R11, -1 */
		/* 821128A8h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 821128A8h case   24:*/		return 0x821128AC;
		  /* 821128ACh */ case   25:  		/* bc 4, CR6_EQ, 92 */
		/* 821128ACh case   25:*/		if ( !regs.CR[6].eq ) { return 0x82112908;  }
		/* 821128ACh case   25:*/		return 0x821128B0;
		  /* 821128B0h */ case   26:  		/* li R8, 0 */
		/* 821128B0h case   26:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821128B0h case   26:*/		return 0x821128B4;
		  /* 821128B4h */ case   27:  		/* cmplwi CR6, R7, 0 */
		/* 821128B4h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 821128B4h case   27:*/		return 0x821128B8;
		  /* 821128B8h */ case   28:  		/* bc 12, CR6_EQ, 252 */
		/* 821128B8h case   28:*/		if ( regs.CR[6].eq ) { return 0x821129B4;  }
		/* 821128B8h case   28:*/		return 0x821128BC;
		  /* 821128BCh */ case   29:  		/* addi R10, R1, 160 */
		/* 821128BCh case   29:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xA0);
		/* 821128BCh case   29:*/		return 0x821128C0;
		  /* 821128C0h */ case   30:  		/* lwz R11, <#[R10]> */
		/* 821128C0h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821128C0h case   30:*/		return 0x821128C4;
		  /* 821128C4h */ case   31:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821128C4h case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821128C4h case   31:*/		return 0x821128C8;
		  /* 821128C8h */ case   32:  		/* lwzx R11, <#[R11 + R26]> */
		/* 821128C8h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 821128C8h case   32:*/		return 0x821128CC;
		  /* 821128CCh */ case   33:  		/* lwz R9, <#[R11 + 4]> */
		/* 821128CCh case   33:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 821128CCh case   33:*/		return 0x821128D0;
		  /* 821128D0h */ case   34:  		/* cmplw CR6, R4, R9 */
		/* 821128D0h case   34:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R9);
		/* 821128D0h case   34:*/		return 0x821128D4;
		  /* 821128D4h */ case   35:  		/* bc 4, CR6_EQ, 32 */
		/* 821128D4h case   35:*/		if ( !regs.CR[6].eq ) { return 0x821128F4;  }
		/* 821128D4h case   35:*/		return 0x821128D8;
		  /* 821128D8h */ case   36:  		/* lwz R9, <#[R11 + 8]> */
		/* 821128D8h case   36:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821128D8h case   36:*/		return 0x821128DC;
		  /* 821128DCh */ case   37:  		/* cmpwi CR6, R9, -1 */
		/* 821128DCh case   37:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 821128DCh case   37:*/		return 0x821128E0;
		  /* 821128E0h */ case   38:  		/* bc 4, CR6_EQ, 20 */
		/* 821128E0h case   38:*/		if ( !regs.CR[6].eq ) { return 0x821128F4;  }
		/* 821128E0h case   38:*/		return 0x821128E4;
		  /* 821128E4h */ case   39:  		/* lfd FR0, <#[R5 + 32]> */
		/* 821128E4h case   39:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R5 + 0x00000020) );
		/* 821128E4h case   39:*/		return 0x821128E8;
		  /* 821128E8h */ case   40:  		/* lfd FR13, <#[R11 + 32]> */
		/* 821128E8h case   40:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 821128E8h case   40:*/		return 0x821128EC;
		  /* 821128ECh */ case   41:  		/* fcmpu CR6, FR0, FR13 */
		/* 821128ECh case   41:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 821128ECh case   41:*/		return 0x821128F0;
		  /* 821128F0h */ case   42:  		/* bc 12, CR6_EQ, 196 */
		/* 821128F0h case   42:*/		if ( regs.CR[6].eq ) { return 0x821129B4;  }
		/* 821128F0h case   42:*/		return 0x821128F4;
	}
	return 0x821128F4;
} // Block from 82112848h-821128F4h (43 instructions)

//////////////////////////////////////////////////////
// Block at 821128F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821128F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821128F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821128F4);
		  /* 821128F4h */ case    0:  		/* addi R8, R8, 1 */
		/* 821128F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821128F4h case    0:*/		return 0x821128F8;
		  /* 821128F8h */ case    1:  		/* addi R10, R10, 4 */
		/* 821128F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821128F8h case    1:*/		return 0x821128FC;
		  /* 821128FCh */ case    2:  		/* cmplw CR6, R8, R7 */
		/* 821128FCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 821128FCh case    2:*/		return 0x82112900;
		  /* 82112900h */ case    3:  		/* bc 12, CR6_LT, -64 */
		/* 82112900h case    3:*/		if ( regs.CR[6].lt ) { return 0x821128C0;  }
		/* 82112900h case    3:*/		return 0x82112904;
		  /* 82112904h */ case    4:  		/* b 176 */
		/* 82112904h case    4:*/		return 0x821129B4;
		/* 82112904h case    4:*/		return 0x82112908;
	}
	return 0x82112908;
} // Block from 821128F4h-82112908h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82112908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112908);
		  /* 82112908h */ case    0:  		/* li R8, 0 */
		/* 82112908h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82112908h case    0:*/		return 0x8211290C;
		  /* 8211290Ch */ case    1:  		/* cmplwi CR6, R7, 0 */
		/* 8211290Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8211290Ch case    1:*/		return 0x82112910;
		  /* 82112910h */ case    2:  		/* bc 12, CR6_EQ, 164 */
		/* 82112910h case    2:*/		if ( regs.CR[6].eq ) { return 0x821129B4;  }
		/* 82112910h case    2:*/		return 0x82112914;
		  /* 82112914h */ case    3:  		/* rlwinm R6, R7, 3, 0, 28 */
		/* 82112914h case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R6,regs.R7);
		/* 82112914h case    3:*/		return 0x82112918;
		  /* 82112918h */ case    4:  		/* addi R9, R1, 160 */
		/* 82112918h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xA0);
		/* 82112918h case    4:*/		return 0x8211291C;
		  /* 8211291Ch */ case    5:  		/* li R11, 0 */
		/* 8211291Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8211291Ch case    5:*/		return 0x82112920;
		  /* 82112920h */ case    6:  		/* lwz R10, <#[R9]> */
		/* 82112920h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 82112920h case    6:*/		return 0x82112924;
		  /* 82112924h */ case    7:  		/* addi R31, R1, 272 */
		/* 82112924h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0x110);
		/* 82112924h case    7:*/		return 0x82112928;
		  /* 82112928h */ case    8:  		/* addi R30, R1, 272 */
		/* 82112928h case    8:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0x110);
		/* 82112928h case    8:*/		return 0x8211292C;
		  /* 8211292Ch */ case    9:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8211292Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8211292Ch case    9:*/		return 0x82112930;
		  /* 82112930h */ case   10:  		/* lfdx FR0, <#[R6 + R31]> */
		/* 82112930h case   10:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R6 + regs.R31 + 0x00000000) );
		/* 82112930h case   10:*/		return 0x82112934;
		  /* 82112934h */ case   11:  		/* lfdx FR13, <#[R11 + R30]> */
		/* 82112934h case   11:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82112934h case   11:*/		return 0x82112938;
		  /* 82112938h */ case   12:  		/* lwzx R10, <#[R10 + R26]> */
		/* 82112938h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R26 + 0x00000000) );
		/* 82112938h case   12:*/		return 0x8211293C;
		  /* 8211293Ch */ case   13:  		/* fcmpu CR6, FR0, FR13 */
		/* 8211293Ch case   13:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 8211293Ch case   13:*/		return 0x82112940;
		  /* 82112940h */ case   14:  		/* bc 4, CR6_EQ, 88 */
		/* 82112940h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82112998;  }
		/* 82112940h case   14:*/		return 0x82112944;
		  /* 82112944h */ case   15:  		/* addi R31, R1, 240 */
		/* 82112944h case   15:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xF0);
		/* 82112944h case   15:*/		return 0x82112948;
		  /* 82112948h */ case   16:  		/* addi R30, R1, 240 */
		/* 82112948h case   16:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0xF0);
		/* 82112948h case   16:*/		return 0x8211294C;
		  /* 8211294Ch */ case   17:  		/* lfdx FR0, <#[R6 + R31]> */
		/* 8211294Ch case   17:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R6 + regs.R31 + 0x00000000) );
		/* 8211294Ch case   17:*/		return 0x82112950;
		  /* 82112950h */ case   18:  		/* lfdx FR13, <#[R11 + R30]> */
		/* 82112950h case   18:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82112950h case   18:*/		return 0x82112954;
		  /* 82112954h */ case   19:  		/* fcmpu CR6, FR0, FR13 */
		/* 82112954h case   19:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82112954h case   19:*/		return 0x82112958;
		  /* 82112958h */ case   20:  		/* bc 4, CR6_EQ, 64 */
		/* 82112958h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82112998;  }
		/* 82112958h case   20:*/		return 0x8211295C;
		  /* 8211295Ch */ case   21:  		/* lwz R31, <#[R10 + 4]> */
		/* 8211295Ch case   21:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x00000004) );
		/* 8211295Ch case   21:*/		return 0x82112960;
		  /* 82112960h */ case   22:  		/* cmplw CR6, R4, R31 */
		/* 82112960h case   22:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R31);
		/* 82112960h case   22:*/		return 0x82112964;
		  /* 82112964h */ case   23:  		/* bc 4, CR6_EQ, 52 */
		/* 82112964h case   23:*/		if ( !regs.CR[6].eq ) { return 0x82112998;  }
		/* 82112964h case   23:*/		return 0x82112968;
		  /* 82112968h */ case   24:  		/* lwz R31, <#[R5 + 8]> */
		/* 82112968h case   24:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R5 + 0x00000008) );
		/* 82112968h case   24:*/		return 0x8211296C;
		  /* 8211296Ch */ case   25:  		/* lwz R30, <#[R10 + 8]> */
		/* 8211296Ch case   25:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + 0x00000008) );
		/* 8211296Ch case   25:*/		return 0x82112970;
		  /* 82112970h */ case   26:  		/* cmplw CR6, R31, R30 */
		/* 82112970h case   26:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 82112970h case   26:*/		return 0x82112974;
		  /* 82112974h */ case   27:  		/* bc 4, CR6_EQ, 36 */
		/* 82112974h case   27:*/		if ( !regs.CR[6].eq ) { return 0x82112998;  }
		/* 82112974h case   27:*/		return 0x82112978;
		  /* 82112978h */ case   28:  		/* lwz R31, <#[R5 + 12]> */
		/* 82112978h case   28:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R5 + 0x0000000C) );
		/* 82112978h case   28:*/		return 0x8211297C;
		  /* 8211297Ch */ case   29:  		/* lwz R30, <#[R10 + 12]> */
		/* 8211297Ch case   29:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + 0x0000000C) );
		/* 8211297Ch case   29:*/		return 0x82112980;
		  /* 82112980h */ case   30:  		/* cmplw CR6, R31, R30 */
		/* 82112980h case   30:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 82112980h case   30:*/		return 0x82112984;
		  /* 82112984h */ case   31:  		/* bc 4, CR6_EQ, 20 */
		/* 82112984h case   31:*/		if ( !regs.CR[6].eq ) { return 0x82112998;  }
		/* 82112984h case   31:*/		return 0x82112988;
		  /* 82112988h */ case   32:  		/* lwz R31, <#[R5 + 16]> */
		/* 82112988h case   32:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R5 + 0x00000010) );
		/* 82112988h case   32:*/		return 0x8211298C;
		  /* 8211298Ch */ case   33:  		/* lwz R10, <#[R10 + 16]> */
		/* 8211298Ch case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 8211298Ch case   33:*/		return 0x82112990;
		  /* 82112990h */ case   34:  		/* cmplw CR6, R31, R10 */
		/* 82112990h case   34:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R10);
		/* 82112990h case   34:*/		return 0x82112994;
		  /* 82112994h */ case   35:  		/* bc 12, CR6_EQ, 32 */
		/* 82112994h case   35:*/		if ( regs.CR[6].eq ) { return 0x821129B4;  }
		/* 82112994h case   35:*/		return 0x82112998;
	}
	return 0x82112998;
} // Block from 82112908h-82112998h (36 instructions)

//////////////////////////////////////////////////////
// Block at 82112998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112998);
		  /* 82112998h */ case    0:  		/* addi R8, R8, 1 */
		/* 82112998h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82112998h case    0:*/		return 0x8211299C;
		  /* 8211299Ch */ case    1:  		/* addi R9, R9, 4 */
		/* 8211299Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8211299Ch case    1:*/		return 0x821129A0;
		  /* 821129A0h */ case    2:  		/* addi R11, R11, 8 */
		/* 821129A0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 821129A0h case    2:*/		return 0x821129A4;
		  /* 821129A4h */ case    3:  		/* cmplw CR6, R8, R7 */
		/* 821129A4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 821129A4h case    3:*/		return 0x821129A8;
		  /* 821129A8h */ case    4:  		/* bc 12, CR6_LT, -136 */
		/* 821129A8h case    4:*/		if ( regs.CR[6].lt ) { return 0x82112920;  }
		/* 821129A8h case    4:*/		return 0x821129AC;
		  /* 821129ACh */ case    5:  		/* b 8 */
		/* 821129ACh case    5:*/		return 0x821129B4;
		/* 821129ACh case    5:*/		return 0x821129B0;
	}
	return 0x821129B0;
} // Block from 82112998h-821129B0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821129B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821129B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821129B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821129B0);
		  /* 821129B0h */ case    0:  		/* mr R8, R7 */
		/* 821129B0h case    0:*/		regs.R8 = regs.R7;
		/* 821129B0h case    0:*/		return 0x821129B4;
	}
	return 0x821129B4;
} // Block from 821129B0h-821129B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821129B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821129B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821129B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821129B4);
		  /* 821129B4h */ case    0:  		/* addi R11, R1, 304 */
		/* 821129B4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x130);
		/* 821129B4h case    0:*/		return 0x821129B8;
		  /* 821129B8h */ case    1:  		/* cmplw CR6, R7, R8 */
		/* 821129B8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 821129B8h case    1:*/		return 0x821129BC;
		  /* 821129BCh */ case    2:  		/* stwx R8, <#[R3 + R11]> */
		/* 821129BCh case    2:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 821129BCh case    2:*/		return 0x821129C0;
		  /* 821129C0h */ case    3:  		/* bc 4, CR6_EQ, 8 */
		/* 821129C0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821129C8;  }
		/* 821129C0h case    3:*/		return 0x821129C4;
		  /* 821129C4h */ case    4:  		/* addi R29, R29, 1 */
		/* 821129C4h case    4:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 821129C4h case    4:*/		return 0x821129C8;
	}
	return 0x821129C8;
} // Block from 821129B4h-821129C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821129C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821129C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821129C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821129C8);
		  /* 821129C8h */ case    0:  		/* addi R7, R7, 1 */
		/* 821129C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 821129C8h case    0:*/		return 0x821129CC;
		  /* 821129CCh */ case    1:  		/* addi R3, R3, 4 */
		/* 821129CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 821129CCh case    1:*/		return 0x821129D0;
		  /* 821129D0h */ case    2:  		/* cmplw CR6, R7, R16 */
		/* 821129D0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R16);
		/* 821129D0h case    2:*/		return 0x821129D4;
		  /* 821129D4h */ case    3:  		/* bc 12, CR6_LT, -360 */
		/* 821129D4h case    3:*/		if ( regs.CR[6].lt ) { return 0x8211286C;  }
		/* 821129D4h case    3:*/		return 0x821129D8;
		  /* 821129D8h */ case    4:  		/* li R27, 1 */
		/* 821129D8h case    4:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 821129D8h case    4:*/		return 0x821129DC;
		  /* 821129DCh */ case    5:  		/* mr R31, R22 */
		/* 821129DCh case    5:*/		regs.R31 = regs.R22;
		/* 821129DCh case    5:*/		return 0x821129E0;
		  /* 821129E0h */ case    6:  		/* li R30, 0 */
		/* 821129E0h case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 821129E0h case    6:*/		return 0x821129E4;
		  /* 821129E4h */ case    7:  		/* li R4, 0 */
		/* 821129E4h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821129E4h case    7:*/		return 0x821129E8;
		  /* 821129E8h */ case    8:  		/* li R3, 0 */
		/* 821129E8h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821129E8h case    8:*/		return 0x821129EC;
		  /* 821129ECh */ case    9:  		/* addi R11, R1, 304 */
		/* 821129ECh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x130);
		/* 821129ECh case    9:*/		return 0x821129F0;
		  /* 821129F0h */ case   10:  		/* lwzx R11, <#[R3 + R11]> */
		/* 821129F0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 821129F0h case   10:*/		return 0x821129F4;
		  /* 821129F4h */ case   11:  		/* cmplw CR6, R4, R11 */
		/* 821129F4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 821129F4h case   11:*/		return 0x821129F8;
		  /* 821129F8h */ case   12:  		/* bc 4, CR6_EQ, 216 */
		/* 821129F8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82112AD0;  }
		/* 821129F8h case   12:*/		return 0x821129FC;
		  /* 821129FCh */ case   13:  		/* addi R11, R1, 160 */
		/* 821129FCh case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xA0);
		/* 821129FCh case   13:*/		return 0x82112A00;
		  /* 82112A00h */ case   14:  		/* lwz R6, <#[R19 + 136]> */
		/* 82112A00h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R19 + 0x00000088) );
		/* 82112A00h case   14:*/		return 0x82112A04;
		  /* 82112A04h */ case   15:  		/* lwzx R11, <#[R3 + R11]> */
		/* 82112A04h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 82112A04h case   15:*/		return 0x82112A08;
		  /* 82112A08h */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82112A08h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82112A08h case   16:*/		return 0x82112A0C;
		  /* 82112A0Ch */ case   17:  		/* lwzx R5, <#[R11 + R26]> */
		/* 82112A0Ch case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 82112A0Ch case   17:*/		return 0x82112A10;
		  /* 82112A10h */ case   18:  		/* lwz R11, <#[R5 + 4]> */
		/* 82112A10h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000004) );
		/* 82112A10h case   18:*/		return 0x82112A14;
		  /* 82112A14h */ case   19:  		/* cmplw CR6, R6, R11 */
		/* 82112A14h case   19:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 82112A14h case   19:*/		return 0x82112A18;
		  /* 82112A18h */ case   20:  		/* bc 4, CR6_EQ, 184 */
		/* 82112A18h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82112AD0;  }
		/* 82112A18h case   20:*/		return 0x82112A1C;
		  /* 82112A1Ch */ case   21:  		/* mr R9, R29 */
		/* 82112A1Ch case   21:*/		regs.R9 = regs.R29;
		/* 82112A1Ch case   21:*/		return 0x82112A20;
		  /* 82112A20h */ case   22:  		/* mtspr CTR, R16 */
		/* 82112A20h case   22:*/		regs.CTR = regs.R16;
		/* 82112A20h case   22:*/		return 0x82112A24;
		  /* 82112A24h */ case   23:  		/* li R8, 0 */
		/* 82112A24h case   23:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82112A24h case   23:*/		return 0x82112A28;
		  /* 82112A28h */ case   24:  		/* li R11, 0 */
		/* 82112A28h case   24:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82112A28h case   24:*/		return 0x82112A2C;
		  /* 82112A2Ch */ case   25:  		/* li R7, 0 */
		/* 82112A2Ch case   25:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82112A2Ch case   25:*/		return 0x82112A30;
		  /* 82112A30h */ case   26:  		/* addi R10, R1, 304 */
		/* 82112A30h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x130);
		/* 82112A30h case   26:*/		return 0x82112A34;
		  /* 82112A34h */ case   27:  		/* lwzx R10, <#[R11 + R10]> */
		/* 82112A34h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82112A34h case   27:*/		return 0x82112A38;
		  /* 82112A38h */ case   28:  		/* cmplw CR6, R8, R10 */
		/* 82112A38h case   28:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 82112A38h case   28:*/		return 0x82112A3C;
		  /* 82112A3Ch */ case   29:  		/* bc 4, CR6_EQ, 88 */
		/* 82112A3Ch case   29:*/		if ( !regs.CR[6].eq ) { return 0x82112A94;  }
		/* 82112A3Ch case   29:*/		return 0x82112A40;
		  /* 82112A40h */ case   30:  		/* addi R10, R1, 160 */
		/* 82112A40h case   30:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xA0);
		/* 82112A40h case   30:*/		return 0x82112A44;
		  /* 82112A44h */ case   31:  		/* lwzx R10, <#[R11 + R10]> */
		/* 82112A44h case   31:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82112A44h case   31:*/		return 0x82112A48;
		  /* 82112A48h */ case   32:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82112A48h case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82112A48h case   32:*/		return 0x82112A4C;
		  /* 82112A4Ch */ case   33:  		/* lwzx R10, <#[R10 + R26]> */
		/* 82112A4Ch case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R26 + 0x00000000) );
		/* 82112A4Ch case   33:*/		return 0x82112A50;
		  /* 82112A50h */ case   34:  		/* lwz R15, <#[R10 + 4]> */
		/* 82112A50h case   34:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R10 + 0x00000004) );
		/* 82112A50h case   34:*/		return 0x82112A54;
		  /* 82112A54h */ case   35:  		/* cmplw CR6, R6, R15 */
		/* 82112A54h case   35:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R15);
		/* 82112A54h case   35:*/		return 0x82112A58;
		  /* 82112A58h */ case   36:  		/* bc 4, CR6_EQ, 56 */
		/* 82112A58h case   36:*/		if ( !regs.CR[6].eq ) { return 0x82112A90;  }
		/* 82112A58h case   36:*/		return 0x82112A5C;
		  /* 82112A5Ch */ case   37:  		/* lwz R15, <#[R5 + 12]> */
		/* 82112A5Ch case   37:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R5 + 0x0000000C) );
		/* 82112A5Ch case   37:*/		return 0x82112A60;
		  /* 82112A60h */ case   38:  		/* lwz R10, <#[R10 + 12]> */
		/* 82112A60h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 82112A60h case   38:*/		return 0x82112A64;
		  /* 82112A64h */ case   39:  		/* cmplw CR6, R15, R10 */
		/* 82112A64h case   39:*/		cpu::op::cmplw<6>(regs,regs.R15,regs.R10);
		/* 82112A64h case   39:*/		return 0x82112A68;
		  /* 82112A68h */ case   40:  		/* bc 4, CR6_EQ, 40 */
		/* 82112A68h case   40:*/		if ( !regs.CR[6].eq ) { return 0x82112A90;  }
		/* 82112A68h case   40:*/		return 0x82112A6C;
		  /* 82112A6Ch */ case   41:  		/* addi R10, R1, 272 */
		/* 82112A6Ch case   41:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x110);
		/* 82112A6Ch case   41:*/		return 0x82112A70;
		  /* 82112A70h */ case   42:  		/* lfdx FR0, <#[R7 + R10]> */
		/* 82112A70h case   42:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 82112A70h case   42:*/		return 0x82112A74;
		  /* 82112A74h */ case   43:  		/* fcmpu CR6, FR0, FR29 */
		/* 82112A74h case   43:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR29);
		/* 82112A74h case   43:*/		return 0x82112A78;
		  /* 82112A78h */ case   44:  		/* bc 4, CR6_EQ, 24 */
		/* 82112A78h case   44:*/		if ( !regs.CR[6].eq ) { return 0x82112A90;  }
		/* 82112A78h case   44:*/		return 0x82112A7C;
		  /* 82112A7Ch */ case   45:  		/* addi R10, R1, 240 */
		/* 82112A7Ch case   45:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xF0);
		/* 82112A7Ch case   45:*/		return 0x82112A80;
		  /* 82112A80h */ case   46:  		/* lfdx FR0, <#[R7 + R10]> */
		/* 82112A80h case   46:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 82112A80h case   46:*/		return 0x82112A84;
		  /* 82112A84h */ case   47:  		/* fcmpu CR6, FR0, FR31 */
		/* 82112A84h case   47:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82112A84h case   47:*/		return 0x82112A88;
		  /* 82112A88h */ case   48:  		/* bc 4, CR6_EQ, 8 */
		/* 82112A88h case   48:*/		if ( !regs.CR[6].eq ) { return 0x82112A90;  }
		/* 82112A88h case   48:*/		return 0x82112A8C;
		  /* 82112A8Ch */ case   49:  		/* addi R9, R9, -1 */
		/* 82112A8Ch case   49:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82112A8Ch case   49:*/		return 0x82112A90;
	}
	return 0x82112A90;
} // Block from 821129C8h-82112A90h (50 instructions)

//////////////////////////////////////////////////////
// Block at 82112A90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112A90);
		  /* 82112A90h */ case    0:  		/* lwz R15, <#[R1 + 540]> */
		/* 82112A90h case    0:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R1 + 0x0000021C) );
		/* 82112A90h case    0:*/		return 0x82112A94;
	}
	return 0x82112A94;
} // Block from 82112A90h-82112A94h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82112A94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112A94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112A94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112A94);
		  /* 82112A94h */ case    0:  		/* addi R8, R8, 1 */
		/* 82112A94h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82112A94h case    0:*/		return 0x82112A98;
		  /* 82112A98h */ case    1:  		/* addi R11, R11, 4 */
		/* 82112A98h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82112A98h case    1:*/		return 0x82112A9C;
		  /* 82112A9Ch */ case    2:  		/* addi R7, R7, 8 */
		/* 82112A9Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x8);
		/* 82112A9Ch case    2:*/		return 0x82112AA0;
		  /* 82112AA0h */ case    3:  		/* bc 16, CR0_LT, -112 */
		/* 82112AA0h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82112A30;  }
		/* 82112AA0h case    3:*/		return 0x82112AA4;
		  /* 82112AA4h */ case    4:  		/* lwz R11, <#[R5 + 12]> */
		/* 82112AA4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x0000000C) );
		/* 82112AA4h case    4:*/		return 0x82112AA8;
		  /* 82112AA8h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82112AA8h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82112AA8h case    5:*/		return 0x82112AAC;
		  /* 82112AACh */ case    6:  		/* lwzx R11, <#[R11 + R15]> */
		/* 82112AACh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R15 + 0x00000000) );
		/* 82112AACh case    6:*/		return 0x82112AB0;
		  /* 82112AB0h */ case    7:  		/* add R11, R11, R9 */
		/* 82112AB0h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82112AB0h case    7:*/		return 0x82112AB4;
		  /* 82112AB4h */ case    8:  		/* cmplwi CR6, R11, 4 */
		/* 82112AB4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 82112AB4h case    8:*/		return 0x82112AB8;
		  /* 82112AB8h */ case    9:  		/* bc 12, CR6_GT, 24 */
		/* 82112AB8h case    9:*/		if ( regs.CR[6].gt ) { return 0x82112AD0;  }
		/* 82112AB8h case    9:*/		return 0x82112ABC;
		  /* 82112ABCh */ case   10:  		/* cmplw CR6, R9, R31 */
		/* 82112ABCh case   10:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R31);
		/* 82112ABCh case   10:*/		return 0x82112AC0;
		  /* 82112AC0h */ case   11:  		/* bc 4, CR6_LT, 16 */
		/* 82112AC0h case   11:*/		if ( !regs.CR[6].lt ) { return 0x82112AD0;  }
		/* 82112AC0h case   11:*/		return 0x82112AC4;
		  /* 82112AC4h */ case   12:  		/* li R27, 0 */
		/* 82112AC4h case   12:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82112AC4h case   12:*/		return 0x82112AC8;
		  /* 82112AC8h */ case   13:  		/* mr R31, R9 */
		/* 82112AC8h case   13:*/		regs.R31 = regs.R9;
		/* 82112AC8h case   13:*/		return 0x82112ACC;
		  /* 82112ACCh */ case   14:  		/* mr R30, R4 */
		/* 82112ACCh case   14:*/		regs.R30 = regs.R4;
		/* 82112ACCh case   14:*/		return 0x82112AD0;
	}
	return 0x82112AD0;
} // Block from 82112A94h-82112AD0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82112AD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112AD0);
		  /* 82112AD0h */ case    0:  		/* addi R4, R4, 1 */
		/* 82112AD0h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 82112AD0h case    0:*/		return 0x82112AD4;
		  /* 82112AD4h */ case    1:  		/* addi R3, R3, 4 */
		/* 82112AD4h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 82112AD4h case    1:*/		return 0x82112AD8;
		  /* 82112AD8h */ case    2:  		/* cmplw CR6, R4, R16 */
		/* 82112AD8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R16);
		/* 82112AD8h case    2:*/		return 0x82112ADC;
		  /* 82112ADCh */ case    3:  		/* bc 12, CR6_LT, -240 */
		/* 82112ADCh case    3:*/		if ( regs.CR[6].lt ) { return 0x821129EC;  }
		/* 82112ADCh case    3:*/		return 0x82112AE0;
		  /* 82112AE0h */ case    4:  		/* lis R4, 4096 */
		/* 82112AE0h case    4:*/		cpu::op::lis<0>(regs,&regs.R4,0x1000);
		/* 82112AE0h case    4:*/		return 0x82112AE4;
		  /* 82112AE4h */ case    5:  		/* cmpwi CR6, R28, 0 */
		/* 82112AE4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 82112AE4h case    5:*/		return 0x82112AE8;
		  /* 82112AE8h */ case    6:  		/* bc 4, CR6_EQ, 12 */
		/* 82112AE8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82112AF4;  }
		/* 82112AE8h case    6:*/		return 0x82112AEC;
		  /* 82112AECh */ case    7:  		/* rlwinm. R11, R25, 0, 2, 2 */
		/* 82112AECh case    7:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R11,regs.R25);
		/* 82112AECh case    7:*/		return 0x82112AF0;
		  /* 82112AF0h */ case    8:  		/* bc 12, CR0_EQ, 240 */
		/* 82112AF0h case    8:*/		if ( regs.CR[0].eq ) { return 0x82112BE0;  }
		/* 82112AF0h case    8:*/		return 0x82112AF4;
	}
	return 0x82112AF4;
} // Block from 82112AD0h-82112AF4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82112AF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112AF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112AF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112AF4);
		  /* 82112AF4h */ case    0:  		/* lwz R11, <#[R18]> */
		/* 82112AF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 82112AF4h case    0:*/		return 0x82112AF8;
		  /* 82112AF8h */ case    1:  		/* rlwinm R11, R11, 0, 0, 3 */
		/* 82112AF8h case    1:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R11,regs.R11);
		/* 82112AF8h case    1:*/		return 0x82112AFC;
		  /* 82112AFCh */ case    2:  		/* cmplw CR6, R11, R4 */
		/* 82112AFCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 82112AFCh case    2:*/		return 0x82112B00;
		  /* 82112B00h */ case    3:  		/* bc 12, CR6_LT, 224 */
		/* 82112B00h case    3:*/		if ( regs.CR[6].lt ) { return 0x82112BE0;  }
		/* 82112B00h case    3:*/		return 0x82112B04;
		  /* 82112B04h */ case    4:  		/* lis R10, 16384 */
		/* 82112B04h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0x4000);
		/* 82112B04h case    4:*/		return 0x82112B08;
		  /* 82112B08h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 82112B08h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82112B08h case    5:*/		return 0x82112B0C;
		  /* 82112B0Ch */ case    6:  		/* bc 12, CR6_GT, 212 */
		/* 82112B0Ch case    6:*/		if ( regs.CR[6].gt ) { return 0x82112BE0;  }
		/* 82112B0Ch case    6:*/		return 0x82112B10;
		  /* 82112B10h */ case    7:  		/* li R5, 0 */
		/* 82112B10h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82112B10h case    7:*/		return 0x82112B14;
		  /* 82112B14h */ case    8:  		/* li R8, 0 */
		/* 82112B14h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82112B14h case    8:*/		return 0x82112B18;
		  /* 82112B18h */ case    9:  		/* cmpwi CR6, R27, 0 */
		/* 82112B18h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 82112B18h case    9:*/		return 0x82112B1C;
		  /* 82112B1Ch */ case   10:  		/* bc 4, CR6_EQ, 196 */
		/* 82112B1Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x82112BE0;  }
		/* 82112B1Ch case   10:*/		return 0x82112B20;
		  /* 82112B20h */ case   11:  		/* addi R11, R1, 160 */
		/* 82112B20h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xA0);
		/* 82112B20h case   11:*/		return 0x82112B24;
		  /* 82112B24h */ case   12:  		/* lwzx R11, <#[R8 + R11]> */
		/* 82112B24h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82112B24h case   12:*/		return 0x82112B28;
		  /* 82112B28h */ case   13:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82112B28h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82112B28h case   13:*/		return 0x82112B2C;
		  /* 82112B2Ch */ case   14:  		/* lwzx R10, <#[R11 + R26]> */
		/* 82112B2Ch case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 82112B2Ch case   14:*/		return 0x82112B30;
		  /* 82112B30h */ case   15:  		/* lwz R7, <#[R10 + 4]> */
		/* 82112B30h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 82112B30h case   15:*/		return 0x82112B34;
		  /* 82112B34h */ case   16:  		/* rlwinm R11, R7, 2, 0, 29 */
		/* 82112B34h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 82112B34h case   16:*/		return 0x82112B38;
		  /* 82112B38h */ case   17:  		/* lwzx R11, <#[R11 + R24]> */
		/* 82112B38h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R24 + 0x00000000) );
		/* 82112B38h case   17:*/		return 0x82112B3C;
		  /* 82112B3Ch */ case   18:  		/* lwz R11, <#[R11 + 4]> */
		/* 82112B3Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82112B3Ch case   18:*/		return 0x82112B40;
		  /* 82112B40h */ case   19:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 82112B40h case   19:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 82112B40h case   19:*/		return 0x82112B44;
		  /* 82112B44h */ case   20:  		/* bc 12, CR0_EQ, 16 */
		/* 82112B44h case   20:*/		if ( regs.CR[0].eq ) { return 0x82112B54;  }
		/* 82112B44h case   20:*/		return 0x82112B48;
		  /* 82112B48h */ case   21:  		/* lwz R11, <#[R10 + 8]> */
		/* 82112B48h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82112B48h case   21:*/		return 0x82112B4C;
		  /* 82112B4Ch */ case   22:  		/* cmpwi CR6, R11, -1 */
		/* 82112B4Ch case   22:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82112B4Ch case   22:*/		return 0x82112B50;
		  /* 82112B50h */ case   23:  		/* bc 4, CR6_EQ, 128 */
		/* 82112B50h case   23:*/		if ( !regs.CR[6].eq ) { return 0x82112BD0;  }
		/* 82112B50h case   23:*/		return 0x82112B54;
	}
	return 0x82112B54;
} // Block from 82112AF4h-82112B54h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82112B54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112B54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112B54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112B54);
		  /* 82112B54h */ case    0:  		/* lwz R11, <#[R18 + 16]> */
		/* 82112B54h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000010) );
		/* 82112B54h case    0:*/		return 0x82112B58;
		  /* 82112B58h */ case    1:  		/* lwz R9, <#[R10 + 16]> */
		/* 82112B58h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 82112B58h case    1:*/		return 0x82112B5C;
		  /* 82112B5Ch */ case    2:  		/* lwzx R11, <#[R11 + R8]> */
		/* 82112B5Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82112B5Ch case    2:*/		return 0x82112B60;
		  /* 82112B60h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82112B60h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82112B60h case    3:*/		return 0x82112B64;
		  /* 82112B64h */ case    4:  		/* lwzx R11, <#[R11 + R26]> */
		/* 82112B64h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 82112B64h case    4:*/		return 0x82112B68;
		  /* 82112B68h */ case    5:  		/* lwz R11, <#[R11 + 16]> */
		/* 82112B68h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 82112B68h case    5:*/		return 0x82112B6C;
		  /* 82112B6Ch */ case    6:  		/* cmplw CR6, R9, R11 */
		/* 82112B6Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82112B6Ch case    6:*/		return 0x82112B70;
		  /* 82112B70h */ case    7:  		/* bc 12, CR6_EQ, 96 */
		/* 82112B70h case    7:*/		if ( regs.CR[6].eq ) { return 0x82112BD0;  }
		/* 82112B70h case    7:*/		return 0x82112B74;
		  /* 82112B74h */ case    8:  		/* li R6, 0 */
		/* 82112B74h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82112B74h case    8:*/		return 0x82112B78;
		  /* 82112B78h */ case    9:  		/* mtspr CTR, R16 */
		/* 82112B78h case    9:*/		regs.CTR = regs.R16;
		/* 82112B78h case    9:*/		return 0x82112B7C;
		  /* 82112B7Ch */ case   10:  		/* addi R9, R1, 160 */
		/* 82112B7Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xA0);
		/* 82112B7Ch case   10:*/		return 0x82112B80;
		  /* 82112B80h */ case   11:  		/* lwz R11, <#[R9]> */
		/* 82112B80h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 82112B80h case   11:*/		return 0x82112B84;
		  /* 82112B84h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82112B84h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82112B84h case   12:*/		return 0x82112B88;
		  /* 82112B88h */ case   13:  		/* lwzx R11, <#[R11 + R26]> */
		/* 82112B88h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 82112B88h case   13:*/		return 0x82112B8C;
		  /* 82112B8Ch */ case   14:  		/* lwz R3, <#[R11 + 4]> */
		/* 82112B8Ch case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000004) );
		/* 82112B8Ch case   14:*/		return 0x82112B90;
		  /* 82112B90h */ case   15:  		/* cmplw CR6, R3, R7 */
		/* 82112B90h case   15:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R7);
		/* 82112B90h case   15:*/		return 0x82112B94;
		  /* 82112B94h */ case   16:  		/* bc 4, CR6_EQ, 40 */
		/* 82112B94h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82112BBC;  }
		/* 82112B94h case   16:*/		return 0x82112B98;
		  /* 82112B98h */ case   17:  		/* lwz R3, <#[R11 + 12]> */
		/* 82112B98h case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x0000000C) );
		/* 82112B98h case   17:*/		return 0x82112B9C;
		  /* 82112B9Ch */ case   18:  		/* lwz R31, <#[R10 + 12]> */
		/* 82112B9Ch case   18:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x0000000C) );
		/* 82112B9Ch case   18:*/		return 0x82112BA0;
		  /* 82112BA0h */ case   19:  		/* cmplw CR6, R3, R31 */
		/* 82112BA0h case   19:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R31);
		/* 82112BA0h case   19:*/		return 0x82112BA4;
		  /* 82112BA4h */ case   20:  		/* bc 4, CR6_EQ, 24 */
		/* 82112BA4h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82112BBC;  }
		/* 82112BA4h case   20:*/		return 0x82112BA8;
		  /* 82112BA8h */ case   21:  		/* lwz R11, <#[R11 + 8]> */
		/* 82112BA8h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82112BA8h case   21:*/		return 0x82112BAC;
		  /* 82112BACh */ case   22:  		/* lwz R3, <#[R10 + 8]> */
		/* 82112BACh case   22:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x00000008) );
		/* 82112BACh case   22:*/		return 0x82112BB0;
		  /* 82112BB0h */ case   23:  		/* cmplw CR6, R11, R3 */
		/* 82112BB0h case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R3);
		/* 82112BB0h case   23:*/		return 0x82112BB4;
		  /* 82112BB4h */ case   24:  		/* bc 4, CR6_EQ, 8 */
		/* 82112BB4h case   24:*/		if ( !regs.CR[6].eq ) { return 0x82112BBC;  }
		/* 82112BB4h case   24:*/		return 0x82112BB8;
		  /* 82112BB8h */ case   25:  		/* addi R6, R6, 1 */
		/* 82112BB8h case   25:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82112BB8h case   25:*/		return 0x82112BBC;
	}
	return 0x82112BBC;
} // Block from 82112B54h-82112BBCh (26 instructions)

//////////////////////////////////////////////////////
// Block at 82112BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112BBC);
		  /* 82112BBCh */ case    0:  		/* addi R9, R9, 4 */
		/* 82112BBCh case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82112BBCh case    0:*/		return 0x82112BC0;
		  /* 82112BC0h */ case    1:  		/* bc 16, CR0_LT, -64 */
		/* 82112BC0h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82112B80;  }
		/* 82112BC0h case    1:*/		return 0x82112BC4;
		  /* 82112BC4h */ case    2:  		/* cmplwi CR6, R6, 1 */
		/* 82112BC4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000001);
		/* 82112BC4h case    2:*/		return 0x82112BC8;
		  /* 82112BC8h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 82112BC8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82112BD0;  }
		/* 82112BC8h case    3:*/		return 0x82112BCC;
		  /* 82112BCCh */ case    4:  		/* li R27, 1 */
		/* 82112BCCh case    4:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 82112BCCh case    4:*/		return 0x82112BD0;
	}
	return 0x82112BD0;
} // Block from 82112BBCh-82112BD0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82112BD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112BD0);
		  /* 82112BD0h */ case    0:  		/* addi R5, R5, 1 */
		/* 82112BD0h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 82112BD0h case    0:*/		return 0x82112BD4;
		  /* 82112BD4h */ case    1:  		/* addi R8, R8, 4 */
		/* 82112BD4h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82112BD4h case    1:*/		return 0x82112BD8;
		  /* 82112BD8h */ case    2:  		/* cmplw CR6, R5, R16 */
		/* 82112BD8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R16);
		/* 82112BD8h case    2:*/		return 0x82112BDC;
		  /* 82112BDCh */ case    3:  		/* bc 12, CR6_LT, -196 */
		/* 82112BDCh case    3:*/		if ( regs.CR[6].lt ) { return 0x82112B18;  }
		/* 82112BDCh case    3:*/		return 0x82112BE0;
	}
	return 0x82112BE0;
} // Block from 82112BD0h-82112BE0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82112BE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112BE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112BE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112BE0);
		  /* 82112BE0h */ case    0:  		/* lwz R11, <#[R18]> */
		/* 82112BE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 82112BE0h case    0:*/		return 0x82112BE4;
		  /* 82112BE4h */ case    1:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82112BE4h case    1:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82112BE4h case    1:*/		return 0x82112BE8;
		  /* 82112BE8h */ case    2:  		/* cmplw CR6, R11, R4 */
		/* 82112BE8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 82112BE8h case    2:*/		return 0x82112BEC;
		  /* 82112BECh */ case    3:  		/* bc 4, CR6_EQ, 52 */
		/* 82112BECh case    3:*/		if ( !regs.CR[6].eq ) { return 0x82112C20;  }
		/* 82112BECh case    3:*/		return 0x82112BF0;
		  /* 82112BF0h */ case    4:  		/* rlwinm. R10, R25, 0, 4, 4 */
		/* 82112BF0h case    4:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R10,regs.R25);
		/* 82112BF0h case    4:*/		return 0x82112BF4;
		  /* 82112BF4h */ case    5:  		/* bc 4, CR0_EQ, 44 */
		/* 82112BF4h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82112C20;  }
		/* 82112BF4h case    5:*/		return 0x82112BF8;
		  /* 82112BF8h */ case    6:  		/* lwz R10, <#[R18 + 16]> */
		/* 82112BF8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R18 + 0x00000010) );
		/* 82112BF8h case    6:*/		return 0x82112BFC;
		  /* 82112BFCh */ case    7:  		/* lwz R10, <#[R10]> */
		/* 82112BFCh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 82112BFCh case    7:*/		return 0x82112C00;
		  /* 82112C00h */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82112C00h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82112C00h case    8:*/		return 0x82112C04;
		  /* 82112C04h */ case    9:  		/* lwzx R10, <#[R10 + R26]> */
		/* 82112C04h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R26 + 0x00000000) );
		/* 82112C04h case    9:*/		return 0x82112C08;
		  /* 82112C08h */ case   10:  		/* lwz R10, <#[R10 + 4]> */
		/* 82112C08h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82112C08h case   10:*/		return 0x82112C0C;
		  /* 82112C0Ch */ case   11:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82112C0Ch case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82112C0Ch case   11:*/		return 0x82112C10;
		  /* 82112C10h */ case   12:  		/* lwzx R10, <#[R10 + R24]> */
		/* 82112C10h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R24 + 0x00000000) );
		/* 82112C10h case   12:*/		return 0x82112C14;
		  /* 82112C14h */ case   13:  		/* lwz R10, <#[R10 + 4]> */
		/* 82112C14h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82112C14h case   13:*/		return 0x82112C18;
		  /* 82112C18h */ case   14:  		/* rlwinm. R10, R10, 0, 26, 26 */
		/* 82112C18h case   14:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R10,regs.R10);
		/* 82112C18h case   14:*/		return 0x82112C1C;
		  /* 82112C1Ch */ case   15:  		/* bc 4, CR0_EQ, 56 */
		/* 82112C1Ch case   15:*/		if ( !regs.CR[0].eq ) { return 0x82112C54;  }
		/* 82112C1Ch case   15:*/		return 0x82112C20;
	}
	return 0x82112C20;
} // Block from 82112BE0h-82112C20h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82112C20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112C20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112C20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112C20);
		  /* 82112C20h */ case    0:  		/* lis R10, 4384 */
		/* 82112C20h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x1120);
		/* 82112C20h case    0:*/		return 0x82112C24;
		  /* 82112C24h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 82112C24h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82112C24h case    1:*/		return 0x82112C28;
		  /* 82112C28h */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 82112C28h case    2:*/		if ( regs.CR[6].eq ) { return 0x82112C54;  }
		/* 82112C28h case    2:*/		return 0x82112C2C;
		  /* 82112C2Ch */ case    3:  		/* cmplw CR6, R11, R4 */
		/* 82112C2Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 82112C2Ch case    3:*/		return 0x82112C30;
		  /* 82112C30h */ case    4:  		/* bc 4, CR6_EQ, 36 */
		/* 82112C30h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82112C54;  }
		/* 82112C30h case    4:*/		return 0x82112C34;
		  /* 82112C34h */ case    5:  		/* cmpwi CR6, R23, 0 */
		/* 82112C34h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 82112C34h case    5:*/		return 0x82112C38;
		  /* 82112C38h */ case    6:  		/* bc 4, CR6_EQ, 28 */
		/* 82112C38h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82112C54;  }
		/* 82112C38h case    6:*/		return 0x82112C3C;
		  /* 82112C3Ch */ case    7:  		/* cmpwi CR6, R21, 0 */
		/* 82112C3Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 82112C3Ch case    7:*/		return 0x82112C40;
	}
	return 0x82112C40;
} // Block from 82112C20h-82112C40h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82112C40h
// Function '?CanVectorize@CProgram@D3DXShader@@AAAHPAII00PAVCInstruction@2@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112C40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112C40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112C40);
		  /* 82112C40h */ case    0:  		/* bc 4, CR6_EQ, 20 */
		/* 82112C40h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82112C54;  }
		/* 82112C40h case    0:*/		return 0x82112C44;
		  /* 82112C44h */ case    1:  		/* cmpwi CR6, R20, 0 */
		/* 82112C44h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 82112C44h case    1:*/		return 0x82112C48;
		  /* 82112C48h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 82112C48h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82112C54;  }
		/* 82112C48h case    2:*/		return 0x82112C4C;
		  /* 82112C4Ch */ case    3:  		/* li R31, 0 */
		/* 82112C4Ch case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82112C4Ch case    3:*/		return 0x82112C50;
		  /* 82112C50h */ case    4:  		/* b -1056 */
		/* 82112C50h case    4:*/		return 0x82112830;
		/* 82112C50h case    4:*/		return 0x82112C54;
	}
	return 0x82112C54;
} // Block from 82112C40h-82112C54h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82112C54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112C54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112C54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112C54);
		  /* 82112C54h */ case    0:  		/* stw R22, <#[R1 + 144]> */
		/* 82112C54h case    0:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000090) );
		/* 82112C54h case    0:*/		return 0x82112C58;
		  /* 82112C58h */ case    1:  		/* cmpwi CR6, R27, 0 */
		/* 82112C58h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 82112C58h case    1:*/		return 0x82112C5C;
		  /* 82112C5Ch */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 82112C5Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82112C78;  }
		/* 82112C5Ch case    2:*/		return 0x82112C60;
		  /* 82112C60h */ case    3:  		/* lwz R10, <#[R1 + 548]> */
		/* 82112C60h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000224) );
		/* 82112C60h case    3:*/		return 0x82112C64;
		  /* 82112C64h */ case    4:  		/* lwz R11, <#[R10]> */
		/* 82112C64h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82112C64h case    4:*/		return 0x82112C68;
		  /* 82112C68h */ case    5:  		/* addi R9, R11, 1 */
		/* 82112C68h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 82112C68h case    5:*/		return 0x82112C6C;
		  /* 82112C6Ch */ case    6:  		/* mr R23, R11 */
		/* 82112C6Ch case    6:*/		regs.R23 = regs.R11;
		/* 82112C6Ch case    6:*/		return 0x82112C70;
		  /* 82112C70h */ case    7:  		/* stw R9, <#[R10]> */
		/* 82112C70h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82112C70h case    7:*/		return 0x82112C74;
		  /* 82112C74h */ case    8:  		/* b 28 */
		/* 82112C74h case    8:*/		return 0x82112C90;
		/* 82112C74h case    8:*/		return 0x82112C78;
	}
	return 0x82112C78;
} // Block from 82112C54h-82112C78h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82112C78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112C78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112C78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112C78);
		  /* 82112C78h */ case    0:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 82112C78h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 82112C78h case    0:*/		return 0x82112C7C;
		  /* 82112C7Ch */ case    1:  		/* addi R10, R1, 160 */
		/* 82112C7Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xA0);
		/* 82112C7Ch case    1:*/		return 0x82112C80;
		  /* 82112C80h */ case    2:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82112C80h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82112C80h case    2:*/		return 0x82112C84;
		  /* 82112C84h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82112C84h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82112C84h case    3:*/		return 0x82112C88;
		  /* 82112C88h */ case    4:  		/* lwzx R11, <#[R11 + R26]> */
		/* 82112C88h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 82112C88h case    4:*/		return 0x82112C8C;
		  /* 82112C8Ch */ case    5:  		/* lwz R23, <#[R11 + 12]> */
		/* 82112C8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R11 + 0x0000000C) );
		/* 82112C8Ch case    5:*/		return 0x82112C90;
	}
	return 0x82112C90;
} // Block from 82112C78h-82112C90h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82112C90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112C90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112C90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112C90);
		  /* 82112C90h */ case    0:  		/* lwz R11, <#[R18 + 16]> */
		/* 82112C90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000010) );
		/* 82112C90h case    0:*/		return 0x82112C94;
		  /* 82112C94h */ case    1:  		/* mr R5, R17 */
		/* 82112C94h case    1:*/		regs.R5 = regs.R17;
		/* 82112C94h case    1:*/		return 0x82112C98;
		  /* 82112C98h */ case    2:  		/* lwz R10, <#[R19 + 20]> */
		/* 82112C98h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R19 + 0x00000014) );
		/* 82112C98h case    2:*/		return 0x82112C9C;
		  /* 82112C9Ch */ case    3:  		/* li R4, 0 */
		/* 82112C9Ch case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82112C9Ch case    3:*/		return 0x82112CA0;
		  /* 82112CA0h */ case    4:  		/* addi R3, R1, 208 */
		/* 82112CA0h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xD0);
		/* 82112CA0h case    4:*/		return 0x82112CA4;
		  /* 82112CA4h */ case    5:  		/* stw R23, <#[R1 + 224]> */
		/* 82112CA4h case    5:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x000000E0) );
		/* 82112CA4h case    5:*/		return 0x82112CA8;
		  /* 82112CA8h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 82112CA8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82112CA8h case    6:*/		return 0x82112CAC;
		  /* 82112CACh */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82112CACh case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82112CACh case    7:*/		return 0x82112CB0;
		  /* 82112CB0h */ case    8:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82112CB0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82112CB0h case    8:*/		return 0x82112CB4;
		  /* 82112CB4h */ case    9:  		/* lwz R10, <#[R11 + 20]> */
		/* 82112CB4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 82112CB4h case    9:*/		return 0x82112CB8;
		  /* 82112CB8h */ case   10:  		/* lwz R11, <#[R11 + 24]> */
		/* 82112CB8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82112CB8h case   10:*/		return 0x82112CBC;
		  /* 82112CBCh */ case   11:  		/* stw R10, <#[R1 + 228]> */
		/* 82112CBCh case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000E4) );
		/* 82112CBCh case   11:*/		return 0x82112CC0;
		  /* 82112CC0h */ case   12:  		/* stw R11, <#[R1 + 176]> */
		/* 82112CC0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000B0) );
		/* 82112CC0h case   12:*/		return 0x82112CC4;
		  /* 82112CC4h */ case   13:  		/* bl -530820 */
		/* 82112CC4h case   13:*/		regs.LR = 0x82112CC8; return 0x82091340;
		/* 82112CC4h case   13:*/		return 0x82112CC8;
		  /* 82112CC8h */ case   14:  		/* li R21, 0 */
		/* 82112CC8h case   14:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 82112CC8h case   14:*/		return 0x82112CCC;
		  /* 82112CCCh */ case   15:  		/* mtspr CTR, R16 */
		/* 82112CCCh case   15:*/		regs.CTR = regs.R16;
		/* 82112CCCh case   15:*/		return 0x82112CD0;
		  /* 82112CD0h */ case   16:  		/* li R22, 1 */
		/* 82112CD0h case   16:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 82112CD0h case   16:*/		return 0x82112CD4;
		  /* 82112CD4h */ case   17:  		/* mr R10, R21 */
		/* 82112CD4h case   17:*/		regs.R10 = regs.R21;
		/* 82112CD4h case   17:*/		return 0x82112CD8;
		  /* 82112CD8h */ case   18:  		/* mr R11, R21 */
		/* 82112CD8h case   18:*/		regs.R11 = regs.R21;
		/* 82112CD8h case   18:*/		return 0x82112CDC;
		  /* 82112CDCh */ case   19:  		/* mr R9, R21 */
		/* 82112CDCh case   19:*/		regs.R9 = regs.R21;
		/* 82112CDCh case   19:*/		return 0x82112CE0;
		  /* 82112CE0h */ case   20:  		/* addi R8, R1, 304 */
		/* 82112CE0h case   20:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x130);
		/* 82112CE0h case   20:*/		return 0x82112CE4;
		  /* 82112CE4h */ case   21:  		/* lwzx R8, <#[R11 + R8]> */
		/* 82112CE4h case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82112CE4h case   21:*/		return 0x82112CE8;
		  /* 82112CE8h */ case   22:  		/* cmplw CR6, R10, R8 */
		/* 82112CE8h case   22:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 82112CE8h case   22:*/		return 0x82112CEC;
		  /* 82112CECh */ case   23:  		/* bc 4, CR6_EQ, 84 */
		/* 82112CECh case   23:*/		if ( !regs.CR[6].eq ) { return 0x82112D40;  }
		/* 82112CECh case   23:*/		return 0x82112CF0;
		  /* 82112CF0h */ case   24:  		/* addi R8, R1, 160 */
		/* 82112CF0h case   24:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xA0);
		/* 82112CF0h case   24:*/		return 0x82112CF4;
		  /* 82112CF4h */ case   25:  		/* lwz R7, <#[R19 + 20]> */
		/* 82112CF4h case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R19 + 0x00000014) );
		/* 82112CF4h case   25:*/		return 0x82112CF8;
		  /* 82112CF8h */ case   26:  		/* lwz R6, <#[R19 + 136]> */
		/* 82112CF8h case   26:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R19 + 0x00000088) );
		/* 82112CF8h case   26:*/		return 0x82112CFC;
		  /* 82112CFCh */ case   27:  		/* lwzx R8, <#[R11 + R8]> */
		/* 82112CFCh case   27:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82112CFCh case   27:*/		return 0x82112D00;
		  /* 82112D00h */ case   28:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82112D00h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82112D00h case   28:*/		return 0x82112D04;
		  /* 82112D04h */ case   29:  		/* lwzx R8, <#[R8 + R7]> */
		/* 82112D04h case   29:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 82112D04h case   29:*/		return 0x82112D08;
		  /* 82112D08h */ case   30:  		/* lwz R7, <#[R8 + 4]> */
		/* 82112D08h case   30:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x00000004) );
		/* 82112D08h case   30:*/		return 0x82112D0C;
		  /* 82112D0Ch */ case   31:  		/* cmplw CR6, R6, R7 */
		/* 82112D0Ch case   31:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R7);
		/* 82112D0Ch case   31:*/		return 0x82112D10;
		  /* 82112D10h */ case   32:  		/* bc 4, CR6_EQ, 56 */
		/* 82112D10h case   32:*/		if ( !regs.CR[6].eq ) { return 0x82112D48;  }
		/* 82112D10h case   32:*/		return 0x82112D14;
		  /* 82112D14h */ case   33:  		/* lwz R8, <#[R8 + 12]> */
		/* 82112D14h case   33:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x0000000C) );
		/* 82112D14h case   33:*/		return 0x82112D18;
		  /* 82112D18h */ case   34:  		/* cmplw CR6, R23, R8 */
		/* 82112D18h case   34:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R8);
		/* 82112D18h case   34:*/		return 0x82112D1C;
		  /* 82112D1Ch */ case   35:  		/* bc 4, CR6_EQ, 44 */
		/* 82112D1Ch case   35:*/		if ( !regs.CR[6].eq ) { return 0x82112D48;  }
		/* 82112D1Ch case   35:*/		return 0x82112D20;
		  /* 82112D20h */ case   36:  		/* addi R8, R1, 272 */
		/* 82112D20h case   36:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x110);
		/* 82112D20h case   36:*/		return 0x82112D24;
		  /* 82112D24h */ case   37:  		/* lfdx FR0, <#[R9 + R8]> */
		/* 82112D24h case   37:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82112D24h case   37:*/		return 0x82112D28;
		  /* 82112D28h */ case   38:  		/* fcmpu CR6, FR0, FR29 */
		/* 82112D28h case   38:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR29);
		/* 82112D28h case   38:*/		return 0x82112D2C;
		  /* 82112D2Ch */ case   39:  		/* bc 4, CR6_EQ, 28 */
		/* 82112D2Ch case   39:*/		if ( !regs.CR[6].eq ) { return 0x82112D48;  }
		/* 82112D2Ch case   39:*/		return 0x82112D30;
		  /* 82112D30h */ case   40:  		/* addi R8, R1, 240 */
		/* 82112D30h case   40:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xF0);
		/* 82112D30h case   40:*/		return 0x82112D34;
		  /* 82112D34h */ case   41:  		/* lfdx FR0, <#[R9 + R8]> */
		/* 82112D34h case   41:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82112D34h case   41:*/		return 0x82112D38;
		  /* 82112D38h */ case   42:  		/* fcmpu CR6, FR0, FR31 */
		/* 82112D38h case   42:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82112D38h case   42:*/		return 0x82112D3C;
		  /* 82112D3Ch */ case   43:  		/* bc 4, CR6_EQ, 12 */
		/* 82112D3Ch case   43:*/		if ( !regs.CR[6].eq ) { return 0x82112D48;  }
		/* 82112D3Ch case   43:*/		return 0x82112D40;
	}
	return 0x82112D40;
} // Block from 82112C90h-82112D40h (44 instructions)

//////////////////////////////////////////////////////
// Block at 82112D40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112D40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112D40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112D40);
		  /* 82112D40h */ case    0:  		/* addi R8, R1, 208 */
		/* 82112D40h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xD0);
		/* 82112D40h case    0:*/		return 0x82112D44;
		  /* 82112D44h */ case    1:  		/* stwx R22, <#[R11 + R8]> */
		/* 82112D44h case    1:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82112D44h case    1:*/		return 0x82112D48;
	}
	return 0x82112D48;
} // Block from 82112D40h-82112D48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82112D48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112D48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112D48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112D48);
		  /* 82112D48h */ case    0:  		/* addi R10, R10, 1 */
		/* 82112D48h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82112D48h case    0:*/		return 0x82112D4C;
		  /* 82112D4Ch */ case    1:  		/* addi R9, R9, 8 */
		/* 82112D4Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x8);
		/* 82112D4Ch case    1:*/		return 0x82112D50;
		  /* 82112D50h */ case    2:  		/* addi R11, R11, 4 */
		/* 82112D50h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82112D50h case    2:*/		return 0x82112D54;
		  /* 82112D54h */ case    3:  		/* bc 16, CR0_LT, -116 */
		/* 82112D54h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82112CE0;  }
		/* 82112D54h case    3:*/		return 0x82112D58;
		  /* 82112D58h */ case    4:  		/* cmpwi CR6, R27, 0 */
		/* 82112D58h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 82112D58h case    4:*/		return 0x82112D5C;
		  /* 82112D5Ch */ case    5:  		/* bc 4, CR6_EQ, 440 */
		/* 82112D5Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x82112F14;  }
		/* 82112D5Ch case    5:*/		return 0x82112D60;
		  /* 82112D60h */ case    6:  		/* mr R25, R21 */
		/* 82112D60h case    6:*/		regs.R25 = regs.R21;
		/* 82112D60h case    6:*/		return 0x82112D64;
		  /* 82112D64h */ case    7:  		/* mr R24, R16 */
		/* 82112D64h case    7:*/		regs.R24 = regs.R16;
		/* 82112D64h case    7:*/		return 0x82112D68;
		  /* 82112D68h */ case    8:  		/* addi R11, R1, 208 */
		/* 82112D68h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 82112D68h case    8:*/		return 0x82112D6C;
		  /* 82112D6Ch */ case    9:  		/* lwzx R11, <#[R25 + R11]> */
		/* 82112D6Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + regs.R11 + 0x00000000) );
		/* 82112D6Ch case    9:*/		return 0x82112D70;
		  /* 82112D70h */ case   10:  		/* cmpwi CR6, R11, 0 */
		/* 82112D70h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82112D70h case   10:*/		return 0x82112D74;
		  /* 82112D74h */ case   11:  		/* bc 4, CR6_EQ, 404 */
		/* 82112D74h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82112F08;  }
		/* 82112D74h case   11:*/		return 0x82112D78;
		  /* 82112D78h */ case   12:  		/* addi R11, R1, 160 */
		/* 82112D78h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xA0);
		/* 82112D78h case   12:*/		return 0x82112D7C;
		  /* 82112D7Ch */ case   13:  		/* lwz R27, <#[R19 + 20]> */
		/* 82112D7Ch case   13:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R19 + 0x00000014) );
		/* 82112D7Ch case   13:*/		return 0x82112D80;
		  /* 82112D80h */ case   14:  		/* lwz R26, <#[R19 + 136]> */
		/* 82112D80h case   14:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R19 + 0x00000088) );
		/* 82112D80h case   14:*/		return 0x82112D84;
		  /* 82112D84h */ case   15:  		/* lwzx R4, <#[R25 + R11]> */
		/* 82112D84h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R25 + regs.R11 + 0x00000000) );
		/* 82112D84h case   15:*/		return 0x82112D88;
		  /* 82112D88h */ case   16:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 82112D88h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 82112D88h case   16:*/		return 0x82112D8C;
		  /* 82112D8Ch */ case   17:  		/* lwzx R28, <#[R11 + R27]> */
		/* 82112D8Ch case   17:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 82112D8Ch case   17:*/		return 0x82112D90;
		  /* 82112D90h */ case   18:  		/* lwz R11, <#[R28 + 4]> */
		/* 82112D90h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82112D90h case   18:*/		return 0x82112D94;
		  /* 82112D94h */ case   19:  		/* cmplw CR6, R26, R11 */
		/* 82112D94h case   19:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 82112D94h case   19:*/		return 0x82112D98;
		  /* 82112D98h */ case   20:  		/* bc 4, CR6_EQ, 368 */
		/* 82112D98h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82112F08;  }
		/* 82112D98h case   20:*/		return 0x82112D9C;
		  /* 82112D9Ch */ case   21:  		/* mr R6, R21 */
		/* 82112D9Ch case   21:*/		regs.R6 = regs.R21;
		/* 82112D9Ch case   21:*/		return 0x82112DA0;
		  /* 82112DA0h */ case   22:  		/* mr R29, R21 */
		/* 82112DA0h case   22:*/		regs.R29 = regs.R21;
		/* 82112DA0h case   22:*/		return 0x82112DA4;
		  /* 82112DA4h */ case   23:  		/* mr R31, R21 */
		/* 82112DA4h case   23:*/		regs.R31 = regs.R21;
		/* 82112DA4h case   23:*/		return 0x82112DA8;
		  /* 82112DA8h */ case   24:  		/* mr R7, R21 */
		/* 82112DA8h case   24:*/		regs.R7 = regs.R21;
		/* 82112DA8h case   24:*/		return 0x82112DAC;
		  /* 82112DACh */ case   25:  		/* mr R30, R21 */
		/* 82112DACh case   25:*/		regs.R30 = regs.R21;
		/* 82112DACh case   25:*/		return 0x82112DB0;
		  /* 82112DB0h */ case   26:  		/* addi R11, R1, 208 */
		/* 82112DB0h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 82112DB0h case   26:*/		return 0x82112DB4;
		  /* 82112DB4h */ case   27:  		/* lwzx R11, <#[R7 + R11]> */
		/* 82112DB4h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 82112DB4h case   27:*/		return 0x82112DB8;
		  /* 82112DB8h */ case   28:  		/* cmpwi CR6, R11, 0 */
		/* 82112DB8h case   28:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82112DB8h case   28:*/		return 0x82112DBC;
		  /* 82112DBCh */ case   29:  		/* bc 4, CR6_EQ, 68 */
		/* 82112DBCh case   29:*/		if ( !regs.CR[6].eq ) { return 0x82112E00;  }
		/* 82112DBCh case   29:*/		return 0x82112DC0;
		  /* 82112DC0h */ case   30:  		/* addi R11, R1, 160 */
		/* 82112DC0h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xA0);
		/* 82112DC0h case   30:*/		return 0x82112DC4;
		  /* 82112DC4h */ case   31:  		/* mr R3, R19 */
		/* 82112DC4h case   31:*/		regs.R3 = regs.R19;
		/* 82112DC4h case   31:*/		return 0x82112DC8;
		  /* 82112DC8h */ case   32:  		/* addi R6, R6, 1 */
		/* 82112DC8h case   32:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82112DC8h case   32:*/		return 0x82112DCC;
		  /* 82112DCCh */ case   33:  		/* lwzx R5, <#[R7 + R11]> */
		/* 82112DCCh case   33:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 82112DCCh case   33:*/		return 0x82112DD0;
		  /* 82112DD0h */ case   34:  		/* bl -74552 */
		/* 82112DD0h case   34:*/		regs.LR = 0x82112DD4; return 0x82100A98;
		/* 82112DD0h case   34:*/		return 0x82112DD4;
		  /* 82112DD4h */ case   35:  		/* cmpwi CR0, R3, 0 */
		/* 82112DD4h case   35:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82112DD4h case   35:*/		return 0x82112DD8;
		  /* 82112DD8h */ case   36:  		/* bc 12, CR0_EQ, 40 */
		/* 82112DD8h case   36:*/		if ( regs.CR[0].eq ) { return 0x82112E00;  }
		/* 82112DD8h case   36:*/		return 0x82112DDC;
		  /* 82112DDCh */ case   37:  		/* addi R11, R1, 272 */
		/* 82112DDCh case   37:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x110);
		/* 82112DDCh case   37:*/		return 0x82112DE0;
		  /* 82112DE0h */ case   38:  		/* addi R29, R29, 1 */
		/* 82112DE0h case   38:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82112DE0h case   38:*/		return 0x82112DE4;
		  /* 82112DE4h */ case   39:  		/* lfdx FR0, <#[R30 + R11]> */
		/* 82112DE4h case   39:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 82112DE4h case   39:*/		return 0x82112DE8;
		  /* 82112DE8h */ case   40:  		/* fcmpu CR6, FR0, FR29 */
		/* 82112DE8h case   40:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR29);
		/* 82112DE8h case   40:*/		return 0x82112DEC;
		  /* 82112DECh */ case   41:  		/* bc 4, CR6_EQ, 40 */
		/* 82112DECh case   41:*/		if ( !regs.CR[6].eq ) { return 0x82112E14;  }
		/* 82112DECh case   41:*/		return 0x82112DF0;
		  /* 82112DF0h */ case   42:  		/* addi R11, R1, 240 */
		/* 82112DF0h case   42:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xF0);
		/* 82112DF0h case   42:*/		return 0x82112DF4;
		  /* 82112DF4h */ case   43:  		/* lfdx FR0, <#[R30 + R11]> */
		/* 82112DF4h case   43:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 82112DF4h case   43:*/		return 0x82112DF8;
		  /* 82112DF8h */ case   44:  		/* fcmpu CR6, FR0, FR31 */
		/* 82112DF8h case   44:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82112DF8h case   44:*/		return 0x82112DFC;
		  /* 82112DFCh */ case   45:  		/* bc 4, CR6_EQ, 24 */
		/* 82112DFCh case   45:*/		if ( !regs.CR[6].eq ) { return 0x82112E14;  }
		/* 82112DFCh case   45:*/		return 0x82112E00;
	}
	return 0x82112E00;
} // Block from 82112D48h-82112E00h (46 instructions)

//////////////////////////////////////////////////////
// Block at 82112E00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112E00);
		  /* 82112E00h */ case    0:  		/* addi R31, R31, 1 */
		/* 82112E00h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82112E00h case    0:*/		return 0x82112E04;
		  /* 82112E04h */ case    1:  		/* addi R7, R7, 4 */
		/* 82112E04h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82112E04h case    1:*/		return 0x82112E08;
		  /* 82112E08h */ case    2:  		/* addi R30, R30, 8 */
		/* 82112E08h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x8);
		/* 82112E08h case    2:*/		return 0x82112E0C;
		  /* 82112E0Ch */ case    3:  		/* cmplw CR6, R31, R16 */
		/* 82112E0Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R16);
		/* 82112E0Ch case    3:*/		return 0x82112E10;
		  /* 82112E10h */ case    4:  		/* bc 12, CR6_LT, -96 */
		/* 82112E10h case    4:*/		if ( regs.CR[6].lt ) { return 0x82112DB0;  }
		/* 82112E10h case    4:*/		return 0x82112E14;
	}
	return 0x82112E14;
} // Block from 82112E00h-82112E14h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82112E14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112E14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112E14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112E14);
		  /* 82112E14h */ case    0:  		/* cmplw CR6, R31, R16 */
		/* 82112E14h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R16);
		/* 82112E14h case    0:*/		return 0x82112E18;
		  /* 82112E18h */ case    1:  		/* bc 12, CR6_LT, 240 */
		/* 82112E18h case    1:*/		if ( regs.CR[6].lt ) { return 0x82112F08;  }
		/* 82112E18h case    1:*/		return 0x82112E1C;
		  /* 82112E1Ch */ case    2:  		/* lwz R5, <#[R28 + 12]> */
		/* 82112E1Ch case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 82112E1Ch case    2:*/		return 0x82112E20;
		  /* 82112E20h */ case    3:  		/* rlwinm R8, R23, 2, 0, 29 */
		/* 82112E20h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R23);
		/* 82112E20h case    3:*/		return 0x82112E24;
		  /* 82112E24h */ case    4:  		/* rlwinm R11, R5, 2, 0, 29 */
		/* 82112E24h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R5);
		/* 82112E24h case    4:*/		return 0x82112E28;
		  /* 82112E28h */ case    5:  		/* lwzx R10, <#[R8 + R15]> */
		/* 82112E28h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R15 + 0x00000000) );
		/* 82112E28h case    5:*/		return 0x82112E2C;
		  /* 82112E2Ch */ case    6:  		/* lwzx R11, <#[R11 + R15]> */
		/* 82112E2Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R15 + 0x00000000) );
		/* 82112E2Ch case    6:*/		return 0x82112E30;
		  /* 82112E30h */ case    7:  		/* subf R11, R29, R11 */
		/* 82112E30h case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 82112E30h case    7:*/		return 0x82112E34;
		  /* 82112E34h */ case    8:  		/* add R11, R11, R6 */
		/* 82112E34h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 82112E34h case    8:*/		return 0x82112E38;
		  /* 82112E38h */ case    9:  		/* add R11, R11, R10 */
		/* 82112E38h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82112E38h case    9:*/		return 0x82112E3C;
		  /* 82112E3Ch */ case   10:  		/* cmplwi CR6, R11, 4 */
		/* 82112E3Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 82112E3Ch case   10:*/		return 0x82112E40;
		  /* 82112E40h */ case   11:  		/* bc 12, CR6_GT, 200 */
		/* 82112E40h case   11:*/		if ( regs.CR[6].gt ) { return 0x82112F08;  }
		/* 82112E40h case   11:*/		return 0x82112E44;
		  /* 82112E44h */ case   12:  		/* mtspr CTR, R16 */
		/* 82112E44h case   12:*/		regs.CTR = regs.R16;
		/* 82112E44h case   12:*/		return 0x82112E48;
		  /* 82112E48h */ case   13:  		/* mr R11, R21 */
		/* 82112E48h case   13:*/		regs.R11 = regs.R21;
		/* 82112E48h case   13:*/		return 0x82112E4C;
		  /* 82112E4Ch */ case   14:  		/* addi R9, R1, 208 */
		/* 82112E4Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xD0);
		/* 82112E4Ch case   14:*/		return 0x82112E50;
		  /* 82112E50h */ case   15:  		/* lwzx R10, <#[R11 + R9]> */
		/* 82112E50h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82112E50h case   15:*/		return 0x82112E54;
		  /* 82112E54h */ case   16:  		/* cmpwi CR6, R10, 0 */
		/* 82112E54h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82112E54h case   16:*/		return 0x82112E58;
		  /* 82112E58h */ case   17:  		/* bc 4, CR6_EQ, 48 */
		/* 82112E58h case   17:*/		if ( !regs.CR[6].eq ) { return 0x82112E88;  }
		/* 82112E58h case   17:*/		return 0x82112E5C;
		  /* 82112E5Ch */ case   18:  		/* addi R10, R1, 160 */
		/* 82112E5Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xA0);
		/* 82112E5Ch case   18:*/		return 0x82112E60;
		  /* 82112E60h */ case   19:  		/* lwzx R10, <#[R11 + R10]> */
		/* 82112E60h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82112E60h case   19:*/		return 0x82112E64;
		  /* 82112E64h */ case   20:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82112E64h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82112E64h case   20:*/		return 0x82112E68;
		  /* 82112E68h */ case   21:  		/* lwzx R10, <#[R10 + R27]> */
		/* 82112E68h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 82112E68h case   21:*/		return 0x82112E6C;
		  /* 82112E6Ch */ case   22:  		/* lwz R7, <#[R10 + 4]> */
		/* 82112E6Ch case   22:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 82112E6Ch case   22:*/		return 0x82112E70;
		  /* 82112E70h */ case   23:  		/* cmplw CR6, R26, R7 */
		/* 82112E70h case   23:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R7);
		/* 82112E70h case   23:*/		return 0x82112E74;
		  /* 82112E74h */ case   24:  		/* bc 4, CR6_EQ, 20 */
		/* 82112E74h case   24:*/		if ( !regs.CR[6].eq ) { return 0x82112E88;  }
		/* 82112E74h case   24:*/		return 0x82112E78;
		  /* 82112E78h */ case   25:  		/* lwz R10, <#[R10 + 12]> */
		/* 82112E78h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 82112E78h case   25:*/		return 0x82112E7C;
		  /* 82112E7Ch */ case   26:  		/* cmplw CR6, R5, R10 */
		/* 82112E7Ch case   26:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R10);
		/* 82112E7Ch case   26:*/		return 0x82112E80;
		  /* 82112E80h */ case   27:  		/* bc 4, CR6_EQ, 8 */
		/* 82112E80h case   27:*/		if ( !regs.CR[6].eq ) { return 0x82112E88;  }
		/* 82112E80h case   27:*/		return 0x82112E84;
		  /* 82112E84h */ case   28:  		/* stwx R22, <#[R11 + R9]> */
		/* 82112E84h case   28:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82112E84h case   28:*/		return 0x82112E88;
	}
	return 0x82112E88;
} // Block from 82112E14h-82112E88h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82112E88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112E88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112E88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112E88);
		  /* 82112E88h */ case    0:  		/* addi R11, R11, 4 */
		/* 82112E88h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82112E88h case    0:*/		return 0x82112E8C;
		  /* 82112E8Ch */ case    1:  		/* bc 16, CR0_LT, -64 */
		/* 82112E8Ch case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82112E4C;  }
		/* 82112E8Ch case    1:*/		return 0x82112E90;
		  /* 82112E90h */ case    2:  		/* lwz R11, <#[R19 + 8]> */
		/* 82112E90h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000008) );
		/* 82112E90h case    2:*/		return 0x82112E94;
		  /* 82112E94h */ case    3:  		/* mr R6, R21 */
		/* 82112E94h case    3:*/		regs.R6 = regs.R21;
		/* 82112E94h case    3:*/		return 0x82112E98;
		  /* 82112E98h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82112E98h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82112E98h case    4:*/		return 0x82112E9C;
		  /* 82112E9Ch */ case    5:  		/* bc 4, CR6_GT, 84 */
		/* 82112E9Ch case    5:*/		if ( !regs.CR[6].gt ) { return 0x82112EF0;  }
		/* 82112E9Ch case    5:*/		return 0x82112EA0;
		  /* 82112EA0h */ case    6:  		/* mr R7, R21 */
		/* 82112EA0h case    6:*/		regs.R7 = regs.R21;
		/* 82112EA0h case    6:*/		return 0x82112EA4;
		  /* 82112EA4h */ case    7:  		/* lwz R11, <#[R19 + 20]> */
		/* 82112EA4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82112EA4h case    7:*/		return 0x82112EA8;
		  /* 82112EA8h */ case    8:  		/* lwz R10, <#[R19 + 136]> */
		/* 82112EA8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R19 + 0x00000088) );
		/* 82112EA8h case    8:*/		return 0x82112EAC;
		  /* 82112EACh */ case    9:  		/* lwzx R11, <#[R7 + R11]> */
		/* 82112EACh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 82112EACh case    9:*/		return 0x82112EB0;
		  /* 82112EB0h */ case   10:  		/* lwz R9, <#[R11 + 4]> */
		/* 82112EB0h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82112EB0h case   10:*/		return 0x82112EB4;
		  /* 82112EB4h */ case   11:  		/* cmplw CR6, R10, R9 */
		/* 82112EB4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82112EB4h case   11:*/		return 0x82112EB8;
		  /* 82112EB8h */ case   12:  		/* bc 4, CR6_EQ, 36 */
		/* 82112EB8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82112EDC;  }
		/* 82112EB8h case   12:*/		return 0x82112EBC;
		  /* 82112EBCh */ case   13:  		/* lwz R10, <#[R11 + 12]> */
		/* 82112EBCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82112EBCh case   13:*/		return 0x82112EC0;
		  /* 82112EC0h */ case   14:  		/* cmplw CR6, R5, R10 */
		/* 82112EC0h case   14:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R10);
		/* 82112EC0h case   14:*/		return 0x82112EC4;
		  /* 82112EC4h */ case   15:  		/* bc 4, CR6_EQ, 24 */
		/* 82112EC4h case   15:*/		if ( !regs.CR[6].eq ) { return 0x82112EDC;  }
		/* 82112EC4h case   15:*/		return 0x82112EC8;
		  /* 82112EC8h */ case   16:  		/* lwz R9, <#[R11 + 16]> */
		/* 82112EC8h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 82112EC8h case   16:*/		return 0x82112ECC;
		  /* 82112ECCh */ case   17:  		/* stw R23, <#[R11 + 12]> */
		/* 82112ECCh case   17:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x0000000C) );
		/* 82112ECCh case   17:*/		return 0x82112ED0;
		  /* 82112ED0h */ case   18:  		/* lwzx R10, <#[R8 + R15]> */
		/* 82112ED0h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R15 + 0x00000000) );
		/* 82112ED0h case   18:*/		return 0x82112ED4;
		  /* 82112ED4h */ case   19:  		/* add R10, R9, R10 */
		/* 82112ED4h case   19:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82112ED4h case   19:*/		return 0x82112ED8;
		  /* 82112ED8h */ case   20:  		/* stw R10, <#[R11 + 16]> */
		/* 82112ED8h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82112ED8h case   20:*/		return 0x82112EDC;
	}
	return 0x82112EDC;
} // Block from 82112E88h-82112EDCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 82112EDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112EDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112EDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112EDC);
		  /* 82112EDCh */ case    0:  		/* lwz R11, <#[R19 + 8]> */
		/* 82112EDCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000008) );
		/* 82112EDCh case    0:*/		return 0x82112EE0;
		  /* 82112EE0h */ case    1:  		/* addi R6, R6, 1 */
		/* 82112EE0h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82112EE0h case    1:*/		return 0x82112EE4;
		  /* 82112EE4h */ case    2:  		/* addi R7, R7, 4 */
		/* 82112EE4h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82112EE4h case    2:*/		return 0x82112EE8;
		  /* 82112EE8h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 82112EE8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 82112EE8h case    3:*/		return 0x82112EEC;
		  /* 82112EECh */ case    4:  		/* bc 12, CR6_LT, -72 */
		/* 82112EECh case    4:*/		if ( regs.CR[6].lt ) { return 0x82112EA4;  }
		/* 82112EECh case    4:*/		return 0x82112EF0;
	}
	return 0x82112EF0;
} // Block from 82112EDCh-82112EF0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82112EF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112EF0);
		  /* 82112EF0h */ case    0:  		/* rlwinm R11, R5, 2, 0, 29 */
		/* 82112EF0h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R5);
		/* 82112EF0h case    0:*/		return 0x82112EF4;
		  /* 82112EF4h */ case    1:  		/* lwzx R10, <#[R8 + R15]> */
		/* 82112EF4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R15 + 0x00000000) );
		/* 82112EF4h case    1:*/		return 0x82112EF8;
		  /* 82112EF8h */ case    2:  		/* lwzx R9, <#[R11 + R15]> */
		/* 82112EF8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R15 + 0x00000000) );
		/* 82112EF8h case    2:*/		return 0x82112EFC;
		  /* 82112EFCh */ case    3:  		/* add R10, R9, R10 */
		/* 82112EFCh case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82112EFCh case    3:*/		return 0x82112F00;
		  /* 82112F00h */ case    4:  		/* stwx R10, <#[R8 + R15]> */
		/* 82112F00h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + regs.R15 + 0x00000000) );
		/* 82112F00h case    4:*/		return 0x82112F04;
		  /* 82112F04h */ case    5:  		/* stwx R21, <#[R11 + R15]> */
		/* 82112F04h case    5:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R11 + regs.R15 + 0x00000000) );
		/* 82112F04h case    5:*/		return 0x82112F08;
	}
	return 0x82112F08;
} // Block from 82112EF0h-82112F08h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82112F08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112F08);
		  /* 82112F08h */ case    0:  		/* addic. R24, R24, -1 */
		/* 82112F08h case    0:*/		cpu::op::addic<1>(regs,&regs.R24,regs.R24,0xFFFFFFFF);
		/* 82112F08h case    0:*/		return 0x82112F0C;
		  /* 82112F0Ch */ case    1:  		/* addi R25, R25, 4 */
		/* 82112F0Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 82112F0Ch case    1:*/		return 0x82112F10;
		  /* 82112F10h */ case    2:  		/* bc 4, CR0_EQ, -424 */
		/* 82112F10h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82112D68;  }
		/* 82112F10h case    2:*/		return 0x82112F14;
	}
	return 0x82112F14;
} // Block from 82112F08h-82112F14h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82112F14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112F14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112F14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112F14);
		  /* 82112F14h */ case    0:  		/* lwz R11, <#[R19 + 108]> */
		/* 82112F14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x0000006C) );
		/* 82112F14h case    0:*/		return 0x82112F18;
		  /* 82112F18h */ case    1:  		/* rlwinm. R10, R11, 0, 3, 3 */
		/* 82112F18h case    1:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R10,regs.R11);
		/* 82112F18h case    1:*/		return 0x82112F1C;
		  /* 82112F1Ch */ case    2:  		/* bc 4, CR0_EQ, 328 */
		/* 82112F1Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x82113064;  }
		/* 82112F1Ch case    2:*/		return 0x82112F20;
		  /* 82112F20h */ case    3:  		/* rlwinm. R11, R11, 0, 2, 2 */
		/* 82112F20h case    3:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R11,regs.R11);
		/* 82112F20h case    3:*/		return 0x82112F24;
		  /* 82112F24h */ case    4:  		/* bc 4, CR0_EQ, 320 */
		/* 82112F24h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82113064;  }
		/* 82112F24h case    4:*/		return 0x82112F28;
		  /* 82112F28h */ case    5:  		/* mr R30, R21 */
		/* 82112F28h case    5:*/		regs.R30 = regs.R21;
		/* 82112F28h case    5:*/		return 0x82112F2C;
		  /* 82112F2Ch */ case    6:  		/* mr R26, R16 */
		/* 82112F2Ch case    6:*/		regs.R26 = regs.R16;
		/* 82112F2Ch case    6:*/		return 0x82112F30;
		  /* 82112F30h */ case    7:  		/* addi R11, R1, 208 */
		/* 82112F30h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 82112F30h case    7:*/		return 0x82112F34;
		  /* 82112F34h */ case    8:  		/* lwzx R11, <#[R30 + R11]> */
		/* 82112F34h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 82112F34h case    8:*/		return 0x82112F38;
		  /* 82112F38h */ case    9:  		/* cmpwi CR6, R11, 0 */
		/* 82112F38h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82112F38h case    9:*/		return 0x82112F3C;
		  /* 82112F3Ch */ case   10:  		/* bc 4, CR6_EQ, 284 */
		/* 82112F3Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x82113058;  }
		/* 82112F3Ch case   10:*/		return 0x82112F40;
		  /* 82112F40h */ case   11:  		/* addi R29, R1, 160 */
		/* 82112F40h case   11:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R1,0xA0);
		/* 82112F40h case   11:*/		return 0x82112F44;
		  /* 82112F44h */ case   12:  		/* lwz R28, <#[R19 + 20]> */
		/* 82112F44h case   12:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R19 + 0x00000014) );
		/* 82112F44h case   12:*/		return 0x82112F48;
		  /* 82112F48h */ case   13:  		/* lwz R27, <#[R19 + 16]> */
		/* 82112F48h case   13:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R19 + 0x00000010) );
		/* 82112F48h case   13:*/		return 0x82112F4C;
		  /* 82112F4Ch */ case   14:  		/* lwzx R4, <#[R30 + R29]> */
		/* 82112F4Ch case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + regs.R29 + 0x00000000) );
		/* 82112F4Ch case   14:*/		return 0x82112F50;
		  /* 82112F50h */ case   15:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 82112F50h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 82112F50h case   15:*/		return 0x82112F54;
		  /* 82112F54h */ case   16:  		/* lwzx R11, <#[R11 + R28]> */
		/* 82112F54h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 82112F54h case   16:*/		return 0x82112F58;
		  /* 82112F58h */ case   17:  		/* lwz R10, <#[R11 + 4]> */
		/* 82112F58h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82112F58h case   17:*/		return 0x82112F5C;
		  /* 82112F5Ch */ case   18:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82112F5Ch case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82112F5Ch case   18:*/		return 0x82112F60;
		  /* 82112F60h */ case   19:  		/* lwzx R10, <#[R10 + R27]> */
		/* 82112F60h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 82112F60h case   19:*/		return 0x82112F64;
		  /* 82112F64h */ case   20:  		/* lwz R10, <#[R10 + 4]> */
		/* 82112F64h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82112F64h case   20:*/		return 0x82112F68;
		  /* 82112F68h */ case   21:  		/* rlwinm. R10, R10, 0, 23, 23 */
		/* 82112F68h case   21:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R10);
		/* 82112F68h case   21:*/		return 0x82112F6C;
		  /* 82112F6Ch */ case   22:  		/* bc 12, CR0_EQ, 16 */
		/* 82112F6Ch case   22:*/		if ( regs.CR[0].eq ) { return 0x82112F7C;  }
		/* 82112F6Ch case   22:*/		return 0x82112F70;
		  /* 82112F70h */ case   23:  		/* lwz R11, <#[R11 + 8]> */
		/* 82112F70h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82112F70h case   23:*/		return 0x82112F74;
		  /* 82112F74h */ case   24:  		/* cmpwi CR6, R11, -1 */
		/* 82112F74h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82112F74h case   24:*/		return 0x82112F78;
		  /* 82112F78h */ case   25:  		/* bc 12, CR6_EQ, 224 */
		/* 82112F78h case   25:*/		if ( regs.CR[6].eq ) { return 0x82113058;  }
		/* 82112F78h case   25:*/		return 0x82112F7C;
	}
	return 0x82112F7C;
} // Block from 82112F14h-82112F7Ch (26 instructions)

//////////////////////////////////////////////////////
// Block at 82112F7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112F7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112F7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112F7C);
		  /* 82112F7Ch */ case    0:  		/* mr R31, R21 */
		/* 82112F7Ch case    0:*/		regs.R31 = regs.R21;
		/* 82112F7Ch case    0:*/		return 0x82112F80;
		  /* 82112F80h */ case    1:  		/* mr R7, R21 */
		/* 82112F80h case    1:*/		regs.R7 = regs.R21;
		/* 82112F80h case    1:*/		return 0x82112F84;
		  /* 82112F84h */ case    2:  		/* mr R6, R16 */
		/* 82112F84h case    2:*/		regs.R6 = regs.R16;
		/* 82112F84h case    2:*/		return 0x82112F88;
		  /* 82112F88h */ case    3:  		/* addi R11, R1, 208 */
		/* 82112F88h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 82112F88h case    3:*/		return 0x82112F8C;
		  /* 82112F8Ch */ case    4:  		/* lwzx R11, <#[R7 + R11]> */
		/* 82112F8Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 82112F8Ch case    4:*/		return 0x82112F90;
		  /* 82112F90h */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 82112F90h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82112F90h case    5:*/		return 0x82112F94;
		  /* 82112F94h */ case    6:  		/* bc 4, CR6_EQ, 32 */
		/* 82112F94h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82112FB4;  }
		/* 82112F94h case    6:*/		return 0x82112F98;
		  /* 82112F98h */ case    7:  		/* addi R11, R1, 160 */
		/* 82112F98h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xA0);
		/* 82112F98h case    7:*/		return 0x82112F9C;
		  /* 82112F9Ch */ case    8:  		/* mr R3, R19 */
		/* 82112F9Ch case    8:*/		regs.R3 = regs.R19;
		/* 82112F9Ch case    8:*/		return 0x82112FA0;
		  /* 82112FA0h */ case    9:  		/* lwzx R5, <#[R7 + R11]> */
		/* 82112FA0h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 82112FA0h case    9:*/		return 0x82112FA4;
		  /* 82112FA4h */ case   10:  		/* bl -75020 */
		/* 82112FA4h case   10:*/		regs.LR = 0x82112FA8; return 0x82100A98;
		/* 82112FA4h case   10:*/		return 0x82112FA8;
		  /* 82112FA8h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 82112FA8h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82112FA8h case   11:*/		return 0x82112FAC;
		  /* 82112FACh */ case   12:  		/* bc 12, CR0_EQ, 8 */
		/* 82112FACh case   12:*/		if ( regs.CR[0].eq ) { return 0x82112FB4;  }
		/* 82112FACh case   12:*/		return 0x82112FB0;
		  /* 82112FB0h */ case   13:  		/* addi R31, R31, 1 */
		/* 82112FB0h case   13:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82112FB0h case   13:*/		return 0x82112FB4;
	}
	return 0x82112FB4;
} // Block from 82112F7Ch-82112FB4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82112FB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82112FB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82112FB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82112FB4);
		  /* 82112FB4h */ case    0:  		/* addic. R6, R6, -1 */
		/* 82112FB4h case    0:*/		cpu::op::addic<1>(regs,&regs.R6,regs.R6,0xFFFFFFFF);
		/* 82112FB4h case    0:*/		return 0x82112FB8;
		  /* 82112FB8h */ case    1:  		/* addi R7, R7, 4 */
		/* 82112FB8h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82112FB8h case    1:*/		return 0x82112FBC;
		  /* 82112FBCh */ case    2:  		/* bc 4, CR0_EQ, -52 */
		/* 82112FBCh case    2:*/		if ( !regs.CR[0].eq ) { return 0x82112F88;  }
		/* 82112FBCh case    2:*/		return 0x82112FC0;
		  /* 82112FC0h */ case    3:  		/* mr R5, R21 */
		/* 82112FC0h case    3:*/		regs.R5 = regs.R21;
		/* 82112FC0h case    3:*/		return 0x82112FC4;
		  /* 82112FC4h */ case    4:  		/* mr R8, R21 */
		/* 82112FC4h case    4:*/		regs.R8 = regs.R21;
		/* 82112FC4h case    4:*/		return 0x82112FC8;
		  /* 82112FC8h */ case    5:  		/* mr R11, R21 */
		/* 82112FC8h case    5:*/		regs.R11 = regs.R21;
		/* 82112FC8h case    5:*/		return 0x82112FCC;
		  /* 82112FCCh */ case    6:  		/* cmplwi CR6, R31, 4 */
		/* 82112FCCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000004);
		/* 82112FCCh case    6:*/		return 0x82112FD0;
		  /* 82112FD0h */ case    7:  		/* bc 4, CR6_LT, 136 */
		/* 82112FD0h case    7:*/		if ( !regs.CR[6].lt ) { return 0x82113058;  }
		/* 82112FD0h case    7:*/		return 0x82112FD4;
		  /* 82112FD4h */ case    8:  		/* addi R10, R1, 208 */
		/* 82112FD4h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xD0);
		/* 82112FD4h case    8:*/		return 0x82112FD8;
		  /* 82112FD8h */ case    9:  		/* lwzx R10, <#[R8 + R10]> */
		/* 82112FD8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 82112FD8h case    9:*/		return 0x82112FDC;
		  /* 82112FDCh */ case   10:  		/* cmpwi CR6, R10, 0 */
		/* 82112FDCh case   10:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82112FDCh case   10:*/		return 0x82112FE0;
		  /* 82112FE0h */ case   11:  		/* bc 4, CR6_EQ, 100 */
		/* 82112FE0h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82113044;  }
		/* 82112FE0h case   11:*/		return 0x82112FE4;
		  /* 82112FE4h */ case   12:  		/* addi R6, R1, 160 */
		/* 82112FE4h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0xA0);
		/* 82112FE4h case   12:*/		return 0x82112FE8;
		  /* 82112FE8h */ case   13:  		/* lwzx R10, <#[R8 + R6]> */
		/* 82112FE8h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R6 + 0x00000000) );
		/* 82112FE8h case   13:*/		return 0x82112FEC;
		  /* 82112FECh */ case   14:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82112FECh case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82112FECh case   14:*/		return 0x82112FF0;
		  /* 82112FF0h */ case   15:  		/* lwzx R7, <#[R10 + R28]> */
		/* 82112FF0h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 82112FF0h case   15:*/		return 0x82112FF4;
		  /* 82112FF4h */ case   16:  		/* lwz R10, <#[R7 + 4]> */
		/* 82112FF4h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000004) );
		/* 82112FF4h case   16:*/		return 0x82112FF8;
		  /* 82112FF8h */ case   17:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82112FF8h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82112FF8h case   17:*/		return 0x82112FFC;
		  /* 82112FFCh */ case   18:  		/* lwzx R10, <#[R10 + R27]> */
		/* 82112FFCh case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 82112FFCh case   18:*/		return 0x82113000;
		  /* 82113000h */ case   19:  		/* lwz R10, <#[R10 + 4]> */
		/* 82113000h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82113000h case   19:*/		return 0x82113004;
		  /* 82113004h */ case   20:  		/* rlwinm. R10, R10, 0, 23, 23 */
		/* 82113004h case   20:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R10);
		/* 82113004h case   20:*/		return 0x82113008;
		  /* 82113008h */ case   21:  		/* bc 12, CR0_EQ, 60 */
		/* 82113008h case   21:*/		if ( regs.CR[0].eq ) { return 0x82113044;  }
		/* 82113008h case   21:*/		return 0x8211300C;
		  /* 8211300Ch */ case   22:  		/* lwz R10, <#[R7 + 8]> */
		/* 8211300Ch case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000008) );
		/* 8211300Ch case   22:*/		return 0x82113010;
		  /* 82113010h */ case   23:  		/* cmpwi CR6, R10, -1 */
		/* 82113010h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82113010h case   23:*/		return 0x82113014;
		  /* 82113014h */ case   24:  		/* bc 4, CR6_EQ, 48 */
		/* 82113014h case   24:*/		if ( !regs.CR[6].eq ) { return 0x82113044;  }
		/* 82113014h case   24:*/		return 0x82113018;
		  /* 82113018h */ case   25:  		/* addi R9, R1, 272 */
		/* 82113018h case   25:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x110);
		/* 82113018h case   25:*/		return 0x8211301C;
		  /* 8211301Ch */ case   26:  		/* lwzx R4, <#[R30 + R29]> */
		/* 8211301Ch case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + regs.R29 + 0x00000000) );
		/* 8211301Ch case   26:*/		return 0x82113020;
		  /* 82113020h */ case   27:  		/* addi R10, R1, 240 */
		/* 82113020h case   27:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xF0);
		/* 82113020h case   27:*/		return 0x82113024;
		  /* 82113024h */ case   28:  		/* lfd FR0, <#[R7 + 32]> */
		/* 82113024h case   28:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R7 + 0x00000020) );
		/* 82113024h case   28:*/		return 0x82113028;
		  /* 82113028h */ case   29:  		/* addi R31, R31, 1 */
		/* 82113028h case   29:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82113028h case   29:*/		return 0x8211302C;
		  /* 8211302Ch */ case   30:  		/* lfdx FR13, <#[R11 + R9]> */
		/* 8211302Ch case   30:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8211302Ch case   30:*/		return 0x82113030;
		  /* 82113030h */ case   31:  		/* stwx R4, <#[R8 + R6]> */
		/* 82113030h case   31:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R8 + regs.R6 + 0x00000000) );
		/* 82113030h case   31:*/		return 0x82113034;
		  /* 82113034h */ case   32:  		/* lfdx FR12, <#[R11 + R10]> */
		/* 82113034h case   32:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82113034h case   32:*/		return 0x82113038;
		  /* 82113038h */ case   33:  		/* fmadd FR0, FR0, FR13, FR12 */
		/* 82113038h case   33:*/		cpu::op::fmadd<0>(regs,&regs.FR0,regs.FR0,regs.FR13,regs.FR12);
		/* 82113038h case   33:*/		return 0x8211303C;
		  /* 8211303Ch */ case   34:  		/* stfdx FR0, <#[R11 + R10]> */
		/* 8211303Ch case   34:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8211303Ch case   34:*/		return 0x82113040;
		  /* 82113040h */ case   35:  		/* stfdx FR31, <#[R11 + R9]> */
		/* 82113040h case   35:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82113040h case   35:*/		return 0x82113044;
	}
	return 0x82113044;
} // Block from 82112FB4h-82113044h (36 instructions)

//////////////////////////////////////////////////////
// Block at 82113044h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113044( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113044) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113044);
		  /* 82113044h */ case    0:  		/* addi R5, R5, 1 */
		/* 82113044h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 82113044h case    0:*/		return 0x82113048;
		  /* 82113048h */ case    1:  		/* addi R8, R8, 4 */
		/* 82113048h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82113048h case    1:*/		return 0x8211304C;
		  /* 8211304Ch */ case    2:  		/* addi R11, R11, 8 */
		/* 8211304Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8211304Ch case    2:*/		return 0x82113050;
		  /* 82113050h */ case    3:  		/* cmplw CR6, R5, R16 */
		/* 82113050h case    3:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R16);
		/* 82113050h case    3:*/		return 0x82113054;
		  /* 82113054h */ case    4:  		/* bc 12, CR6_LT, -136 */
		/* 82113054h case    4:*/		if ( regs.CR[6].lt ) { return 0x82112FCC;  }
		/* 82113054h case    4:*/		return 0x82113058;
	}
	return 0x82113058;
} // Block from 82113044h-82113058h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82113058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113058);
		  /* 82113058h */ case    0:  		/* addic. R26, R26, -1 */
		/* 82113058h case    0:*/		cpu::op::addic<1>(regs,&regs.R26,regs.R26,0xFFFFFFFF);
		/* 82113058h case    0:*/		return 0x8211305C;
		  /* 8211305Ch */ case    1:  		/* addi R30, R30, 4 */
		/* 8211305Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8211305Ch case    1:*/		return 0x82113060;
		  /* 82113060h */ case    2:  		/* bc 4, CR0_EQ, -304 */
		/* 82113060h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82112F30;  }
		/* 82113060h case    2:*/		return 0x82113064;
	}
	return 0x82113064;
} // Block from 82113058h-82113064h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82113064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113064);
		  /* 82113064h */ case    0:  		/* lis R9, -32255 */
		/* 82113064h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 82113064h case    0:*/		return 0x82113068;
		  /* 82113068h */ case    1:  		/* stw R21, <#[R1 + 192]> */
		/* 82113068h case    1:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x000000C0) );
		/* 82113068h case    1:*/		return 0x8211306C;
		  /* 8211306Ch */ case    2:  		/* lis R11, -32254 */
		/* 8211306Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 8211306Ch case    2:*/		return 0x82113070;
		  /* 82113070h */ case    3:  		/* stw R21, <#[R1 + 196]> */
		/* 82113070h case    3:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x000000C4) );
		/* 82113070h case    3:*/		return 0x82113074;
		  /* 82113074h */ case    4:  		/* mr R10, R21 */
		/* 82113074h case    4:*/		regs.R10 = regs.R21;
		/* 82113074h case    4:*/		return 0x82113078;
		  /* 82113078h */ case    5:  		/* addi R11, R11, -13768 */
		/* 82113078h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFCA38);
		/* 82113078h case    5:*/		return 0x8211307C;
		  /* 8211307Ch */ case    6:  		/* lfd FR30, <#[R9 - 24488]> */
		/* 8211307Ch case    6:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R9 + 0xFFFFA058) );
		/* 8211307Ch case    6:*/		return 0x82113080;
		  /* 82113080h */ case    7:  		/* stw R11, <#[R1 + 232]> */
		/* 82113080h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000E8) );
		/* 82113080h case    7:*/		return 0x82113084;
		  /* 82113084h */ case    8:  		/* addi R11, R1, 208 */
		/* 82113084h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 82113084h case    8:*/		return 0x82113088;
		  /* 82113088h */ case    9:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82113088h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82113088h case    9:*/		return 0x8211308C;
		  /* 8211308Ch */ case   10:  		/* cmpwi CR6, R11, 0 */
		/* 8211308Ch case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8211308Ch case   10:*/		return 0x82113090;
		  /* 82113090h */ case   11:  		/* bc 4, CR6_EQ, 1388 */
		/* 82113090h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821135FC;  }
		/* 82113090h case   11:*/		return 0x82113094;
		  /* 82113094h */ case   12:  		/* lwz R11, <#[R1 + 196]> */
		/* 82113094h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000C4) );
		/* 82113094h case   12:*/		return 0x82113098;
		  /* 82113098h */ case   13:  		/* addi R10, R1, 160 */
		/* 82113098h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xA0);
		/* 82113098h case   13:*/		return 0x8211309C;
		  /* 8211309Ch */ case   14:  		/* li R29, 1 */
		/* 8211309Ch case   14:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 8211309Ch case   14:*/		return 0x821130A0;
		  /* 821130A0h */ case   15:  		/* lwz R31, <#[R1 + 532]> */
		/* 821130A0h case   15:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000214) );
		/* 821130A0h case   15:*/		return 0x821130A4;
		  /* 821130A4h */ case   16:  		/* lwz R28, <#[R1 + 516]> */
		/* 821130A4h case   16:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000204) );
		/* 821130A4h case   16:*/		return 0x821130A8;
		  /* 821130A8h */ case   17:  		/* li R30, 0 */
		/* 821130A8h case   17:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 821130A8h case   17:*/		return 0x821130AC;
		  /* 821130ACh */ case   18:  		/* li R14, 0 */
		/* 821130ACh case   18:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 821130ACh case   18:*/		return 0x821130B0;
		  /* 821130B0h */ case   19:  		/* stw R29, <#[R1 + 236]> */
		/* 821130B0h case   19:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x000000EC) );
		/* 821130B0h case   19:*/		return 0x821130B4;
		  /* 821130B4h */ case   20:  		/* li R15, 0 */
		/* 821130B4h case   20:*/		cpu::op::li<0>(regs,&regs.R15,0x0);
		/* 821130B4h case   20:*/		return 0x821130B8;
		  /* 821130B8h */ case   21:  		/* lwzx R27, <#[R11 + R10]> */
		/* 821130B8h case   21:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821130B8h case   21:*/		return 0x821130BC;
		  /* 821130BCh */ case   22:  		/* li R16, 1 */
		/* 821130BCh case   22:*/		cpu::op::li<0>(regs,&regs.R16,0x1);
		/* 821130BCh case   22:*/		return 0x821130C0;
		  /* 821130C0h */ case   23:  		/* li R7, 0 */
		/* 821130C0h case   23:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821130C0h case   23:*/		return 0x821130C4;
		  /* 821130C4h */ case   24:  		/* li R6, 0 */
		/* 821130C4h case   24:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821130C4h case   24:*/		return 0x821130C8;
		  /* 821130C8h */ case   25:  		/* stw R27, <#[R1 + 184]> */
		/* 821130C8h case   25:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x000000B8) );
		/* 821130C8h case   25:*/		return 0x821130CC;
		  /* 821130CCh */ case   26:  		/* addi R11, R1, 208 */
		/* 821130CCh case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 821130CCh case   26:*/		return 0x821130D0;
		  /* 821130D0h */ case   27:  		/* lwzx R11, <#[R7 + R11]> */
		/* 821130D0h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 821130D0h case   27:*/		return 0x821130D4;
		  /* 821130D4h */ case   28:  		/* cmpwi CR6, R11, 0 */
		/* 821130D4h case   28:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821130D4h case   28:*/		return 0x821130D8;
		  /* 821130D8h */ case   29:  		/* bc 4, CR6_EQ, 100 */
		/* 821130D8h case   29:*/		if ( !regs.CR[6].eq ) { return 0x8211313C;  }
		/* 821130D8h case   29:*/		return 0x821130DC;
		  /* 821130DCh */ case   30:  		/* addi R11, R1, 160 */
		/* 821130DCh case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xA0);
		/* 821130DCh case   30:*/		return 0x821130E0;
		  /* 821130E0h */ case   31:  		/* mr R4, R27 */
		/* 821130E0h case   31:*/		regs.R4 = regs.R27;
		/* 821130E0h case   31:*/		return 0x821130E4;
		  /* 821130E4h */ case   32:  		/* mr R3, R28 */
		/* 821130E4h case   32:*/		regs.R3 = regs.R28;
		/* 821130E4h case   32:*/		return 0x821130E8;
		  /* 821130E8h */ case   33:  		/* lwzx R5, <#[R7 + R11]> */
		/* 821130E8h case   33:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 821130E8h case   33:*/		return 0x821130EC;
		  /* 821130ECh */ case   34:  		/* bl -75348 */
		/* 821130ECh case   34:*/		regs.LR = 0x821130F0; return 0x82100A98;
		/* 821130ECh case   34:*/		return 0x821130F0;
		  /* 821130F0h */ case   35:  		/* cmpwi CR0, R3, 0 */
		/* 821130F0h case   35:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821130F0h case   35:*/		return 0x821130F4;
		  /* 821130F4h */ case   36:  		/* bc 12, CR0_EQ, 72 */
		/* 821130F4h case   36:*/		if ( regs.CR[0].eq ) { return 0x8211313C;  }
		/* 821130F4h case   36:*/		return 0x821130F8;
		  /* 821130F8h */ case   37:  		/* addi R11, R1, 272 */
		/* 821130F8h case   37:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x110);
		/* 821130F8h case   37:*/		return 0x821130FC;
		  /* 821130FCh */ case   38:  		/* addi R30, R30, 1 */
		/* 821130FCh case   38:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 821130FCh case   38:*/		return 0x82113100;
		  /* 82113100h */ case   39:  		/* lfdx FR0, <#[R6 + R11]> */
		/* 82113100h case   39:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 82113100h case   39:*/		return 0x82113104;
		  /* 82113104h */ case   40:  		/* fcmpu CR6, FR0, FR29 */
		/* 82113104h case   40:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR29);
		/* 82113104h case   40:*/		return 0x82113108;
		  /* 82113108h */ case   41:  		/* bc 12, CR6_EQ, 8 */
		/* 82113108h case   41:*/		if ( regs.CR[6].eq ) { return 0x82113110;  }
		/* 82113108h case   41:*/		return 0x8211310C;
		  /* 8211310Ch */ case   42:  		/* li R14, 1 */
		/* 8211310Ch case   42:*/		cpu::op::li<0>(regs,&regs.R14,0x1);
		/* 8211310Ch case   42:*/		return 0x82113110;
	}
	return 0x82113110;
} // Block from 82113064h-82113110h (43 instructions)

//////////////////////////////////////////////////////
// Block at 82113110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113110);
		  /* 82113110h */ case    0:  		/* fcmpu CR6, FR0, FR30 */
		/* 82113110h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 82113110h case    0:*/		return 0x82113114;
		  /* 82113114h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 82113114h case    1:*/		if ( regs.CR[6].eq ) { return 0x8211311C;  }
		/* 82113114h case    1:*/		return 0x82113118;
		  /* 82113118h */ case    2:  		/* li R29, 0 */
		/* 82113118h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82113118h case    2:*/		return 0x8211311C;
	}
	return 0x8211311C;
} // Block from 82113110h-8211311Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8211311Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211311C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211311C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211311C);
		  /* 8211311Ch */ case    0:  		/* addi R11, R1, 240 */
		/* 8211311Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xF0);
		/* 8211311Ch case    0:*/		return 0x82113120;
		  /* 82113120h */ case    1:  		/* lfdx FR13, <#[R6 + R11]> */
		/* 82113120h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 82113120h case    1:*/		return 0x82113124;
		  /* 82113124h */ case    2:  		/* fcmpu CR6, FR13, FR31 */
		/* 82113124h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR31);
		/* 82113124h case    2:*/		return 0x82113128;
		  /* 82113128h */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 82113128h case    3:*/		if ( regs.CR[6].eq ) { return 0x82113130;  }
		/* 82113128h case    3:*/		return 0x8211312C;
		  /* 8211312Ch */ case    4:  		/* li R15, 1 */
		/* 8211312Ch case    4:*/		cpu::op::li<0>(regs,&regs.R15,0x1);
		/* 8211312Ch case    4:*/		return 0x82113130;
	}
	return 0x82113130;
} // Block from 8211311Ch-82113130h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82113130h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113130);
		  /* 82113130h */ case    0:  		/* fcmpu CR6, FR0, FR31 */
		/* 82113130h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82113130h case    0:*/		return 0x82113134;
		  /* 82113134h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 82113134h case    1:*/		if ( regs.CR[6].eq ) { return 0x8211313C;  }
		/* 82113134h case    1:*/		return 0x82113138;
		  /* 82113138h */ case    2:  		/* li R16, 0 */
		/* 82113138h case    2:*/		cpu::op::li<0>(regs,&regs.R16,0x0);
		/* 82113138h case    2:*/		return 0x8211313C;
	}
	return 0x8211313C;
} // Block from 82113130h-8211313Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8211313Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211313C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211313C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211313C);
		  /* 8211313Ch */ case    0:  		/* addic. R31, R31, -1 */
		/* 8211313Ch case    0:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 8211313Ch case    0:*/		return 0x82113140;
		  /* 82113140h */ case    1:  		/* addi R7, R7, 4 */
		/* 82113140h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82113140h case    1:*/		return 0x82113144;
		  /* 82113144h */ case    2:  		/* addi R6, R6, 8 */
		/* 82113144h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x8);
		/* 82113144h case    2:*/		return 0x82113148;
		  /* 82113148h */ case    3:  		/* bc 4, CR0_EQ, -124 */
		/* 82113148h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821130CC;  }
		/* 82113148h case    3:*/		return 0x8211314C;
		  /* 8211314Ch */ case    4:  		/* stw R29, <#[R1 + 236]> */
		/* 8211314Ch case    4:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x000000EC) );
		/* 8211314Ch case    4:*/		return 0x82113150;
		  /* 82113150h */ case    5:  		/* li R17, 0 */
		/* 82113150h case    5:*/		cpu::op::li<0>(regs,&regs.R17,0x0);
		/* 82113150h case    5:*/		return 0x82113154;
		  /* 82113154h */ case    6:  		/* li R22, 0 */
		/* 82113154h case    6:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 82113154h case    6:*/		return 0x82113158;
		  /* 82113158h */ case    7:  		/* li R21, 0 */
		/* 82113158h case    7:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 82113158h case    7:*/		return 0x8211315C;
		  /* 8211315Ch */ case    8:  		/* li R26, 0 */
		/* 8211315Ch case    8:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8211315Ch case    8:*/		return 0x82113160;
		  /* 82113160h */ case    9:  		/* cmpwi CR6, R16, 0 */
		/* 82113160h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R16,0x00000000);
		/* 82113160h case    9:*/		return 0x82113164;
		  /* 82113164h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 82113164h case   10:*/		if ( regs.CR[6].eq ) { return 0x82113170;  }
		/* 82113164h case   10:*/		return 0x82113168;
		  /* 82113168h */ case   11:  		/* li R14, 0 */
		/* 82113168h case   11:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 82113168h case   11:*/		return 0x8211316C;
		  /* 8211316Ch */ case   12:  		/* li R15, 0 */
		/* 8211316Ch case   12:*/		cpu::op::li<0>(regs,&regs.R15,0x0);
		/* 8211316Ch case   12:*/		return 0x82113170;
	}
	return 0x82113170;
} // Block from 8211313Ch-82113170h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82113170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113170);
		  /* 82113170h */ case    0:  		/* cmpwi CR6, R14, 0 */
		/* 82113170h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 82113170h case    0:*/		return 0x82113174;
		  /* 82113174h */ case    1:  		/* li R31, -1 */
		/* 82113174h case    1:*/		cpu::op::li<0>(regs,&regs.R31,0xFFFFFFFF);
		/* 82113174h case    1:*/		return 0x82113178;
		  /* 82113178h */ case    2:  		/* bc 12, CR6_EQ, 104 */
		/* 82113178h case    2:*/		if ( regs.CR[6].eq ) { return 0x821131E0;  }
		/* 82113178h case    2:*/		return 0x8211317C;
		  /* 8211317Ch */ case    3:  		/* cmpwi CR6, R29, 0 */
		/* 8211317Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 8211317Ch case    3:*/		return 0x82113180;
		  /* 82113180h */ case    4:  		/* mr R4, R30 */
		/* 82113180h case    4:*/		regs.R4 = regs.R30;
		/* 82113180h case    4:*/		return 0x82113184;
		  /* 82113184h */ case    5:  		/* mr R3, R28 */
		/* 82113184h case    5:*/		regs.R3 = regs.R28;
		/* 82113184h case    5:*/		return 0x82113188;
		  /* 82113188h */ case    6:  		/* mr R6, R31 */
		/* 82113188h case    6:*/		regs.R6 = regs.R31;
		/* 82113188h case    6:*/		return 0x8211318C;
		  /* 8211318Ch */ case    7:  		/* mr R5, R31 */
		/* 8211318Ch case    7:*/		regs.R5 = regs.R31;
		/* 8211318Ch case    7:*/		return 0x82113190;
		  /* 82113190h */ case    8:  		/* li R11, 257 */
		/* 82113190h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x101);
		/* 82113190h case    8:*/		return 0x82113194;
		  /* 82113194h */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 82113194h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8211319C;  }
		/* 82113194h case    9:*/		return 0x82113198;
		  /* 82113198h */ case   10:  		/* li R11, 517 */
		/* 82113198h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x205);
		/* 82113198h case   10:*/		return 0x8211319C;
	}
	return 0x8211319C;
} // Block from 82113170h-8211319Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8211319Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211319C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211319C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211319C);
		  /* 8211319Ch */ case    0:  		/* rlwimi R4, R11, 20, 0, 11 */
		/* 8211319Ch case    0:*/		cpu::op::rlwimi<0,20,0,11>(regs,&regs.R4,regs.R11);
		/* 8211319Ch case    0:*/		return 0x821131A0;
		  /* 821131A0h */ case    1:  		/* bl -89816 */
		/* 821131A0h case    1:*/		regs.LR = 0x821131A4; return 0x820FD2C8;
		/* 821131A0h case    1:*/		return 0x821131A4;
		  /* 821131A4h */ case    2:  		/* mr R17, R3 */
		/* 821131A4h case    2:*/		regs.R17 = regs.R3;
		/* 821131A4h case    2:*/		return 0x821131A8;
		  /* 821131A8h */ case    3:  		/* cmpwi CR6, R3, -1 */
		/* 821131A8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 821131A8h case    3:*/		return 0x821131AC;
		  /* 821131ACh */ case    4:  		/* bc 12, CR6_EQ, -4208 */
		/* 821131ACh case    4:*/		if ( regs.CR[6].eq ) { return 0x8211213C;  }
		/* 821131ACh case    4:*/		return 0x821131B0;
		  /* 821131B0h */ case    5:  		/* lwz R11, <#[R28 + 24]> */
		/* 821131B0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000018) );
		/* 821131B0h case    5:*/		return 0x821131B4;
		  /* 821131B4h */ case    6:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 821131B4h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 821131B4h case    6:*/		return 0x821131B8;
		  /* 821131B8h */ case    7:  		/* lwz R29, <#[R1 + 556]> */
		/* 821131B8h case    7:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x0000022C) );
		/* 821131B8h case    7:*/		return 0x821131BC;
		  /* 821131BCh */ case    8:  		/* mr R4, R29 */
		/* 821131BCh case    8:*/		regs.R4 = regs.R29;
		/* 821131BCh case    8:*/		return 0x821131C0;
		  /* 821131C0h */ case    9:  		/* lwzx R21, <#[R10 + R11]> */
		/* 821131C0h case    9:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821131C0h case    9:*/		return 0x821131C4;
		  /* 821131C4h */ case   10:  		/* mr R3, R21 */
		/* 821131C4h case   10:*/		regs.R3 = regs.R21;
		/* 821131C4h case   10:*/		return 0x821131C8;
		  /* 821131C8h */ case   11:  		/* bl -94936 */
		/* 821131C8h case   11:*/		regs.LR = 0x821131CC; return 0x820FBEF0;
		/* 821131C8h case   11:*/		return 0x821131CC;
		  /* 821131CCh */ case   12:  		/* cmpwi CR6, R15, 0 */
		/* 821131CCh case   12:*/		cpu::op::cmpwi<6>(regs,regs.R15,0x00000000);
		/* 821131CCh case   12:*/		return 0x821131D0;
		  /* 821131D0h */ case   13:  		/* bc 4, CR6_EQ, 28 */
		/* 821131D0h case   13:*/		if ( !regs.CR[6].eq ) { return 0x821131EC;  }
		/* 821131D0h case   13:*/		return 0x821131D4;
		  /* 821131D4h */ case   14:  		/* mr R22, R17 */
		/* 821131D4h case   14:*/		regs.R22 = regs.R17;
		/* 821131D4h case   14:*/		return 0x821131D8;
		  /* 821131D8h */ case   15:  		/* mr R26, R21 */
		/* 821131D8h case   15:*/		regs.R26 = regs.R21;
		/* 821131D8h case   15:*/		return 0x821131DC;
		  /* 821131DCh */ case   16:  		/* b 8 */
		/* 821131DCh case   16:*/		return 0x821131E4;
		/* 821131DCh case   16:*/		return 0x821131E0;
	}
	return 0x821131E0;
} // Block from 8211319Ch-821131E0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821131E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821131E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821131E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821131E0);
		  /* 821131E0h */ case    0:  		/* lwz R29, <#[R1 + 556]> */
		/* 821131E0h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x0000022C) );
		/* 821131E0h case    0:*/		return 0x821131E4;
	}
	return 0x821131E4;
} // Block from 821131E0h-821131E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821131E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821131E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821131E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821131E4);
		  /* 821131E4h */ case    0:  		/* cmpwi CR6, R15, 0 */
		/* 821131E4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R15,0x00000000);
		/* 821131E4h case    0:*/		return 0x821131E8;
		  /* 821131E8h */ case    1:  		/* bc 12, CR6_EQ, 84 */
		/* 821131E8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8211323C;  }
		/* 821131E8h case    1:*/		return 0x821131EC;
	}
	return 0x821131EC;
} // Block from 821131E4h-821131ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821131ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821131EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821131EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821131EC);
		  /* 821131ECh */ case    0:  		/* li R11, 129 */
		/* 821131ECh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x81);
		/* 821131ECh case    0:*/		return 0x821131F0;
		  /* 821131F0h */ case    1:  		/* mr R4, R30 */
		/* 821131F0h case    1:*/		regs.R4 = regs.R30;
		/* 821131F0h case    1:*/		return 0x821131F4;
		  /* 821131F4h */ case    2:  		/* mr R6, R31 */
		/* 821131F4h case    2:*/		regs.R6 = regs.R31;
		/* 821131F4h case    2:*/		return 0x821131F8;
		  /* 821131F8h */ case    3:  		/* rlwimi R4, R11, 22, 0, 11 */
		/* 821131F8h case    3:*/		cpu::op::rlwimi<0,22,0,11>(regs,&regs.R4,regs.R11);
		/* 821131F8h case    3:*/		return 0x821131FC;
		  /* 821131FCh */ case    4:  		/* mr R5, R31 */
		/* 821131FCh case    4:*/		regs.R5 = regs.R31;
		/* 821131FCh case    4:*/		return 0x82113200;
		  /* 82113200h */ case    5:  		/* mr R3, R28 */
		/* 82113200h case    5:*/		regs.R3 = regs.R28;
		/* 82113200h case    5:*/		return 0x82113204;
		  /* 82113204h */ case    6:  		/* bl -89916 */
		/* 82113204h case    6:*/		regs.LR = 0x82113208; return 0x820FD2C8;
		/* 82113204h case    6:*/		return 0x82113208;
		  /* 82113208h */ case    7:  		/* mr R22, R3 */
		/* 82113208h case    7:*/		regs.R22 = regs.R3;
		/* 82113208h case    7:*/		return 0x8211320C;
		  /* 8211320Ch */ case    8:  		/* cmpwi CR6, R3, -1 */
		/* 8211320Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8211320Ch case    8:*/		return 0x82113210;
		  /* 82113210h */ case    9:  		/* bc 12, CR6_EQ, -4308 */
		/* 82113210h case    9:*/		if ( regs.CR[6].eq ) { return 0x8211213C;  }
		/* 82113210h case    9:*/		return 0x82113214;
		  /* 82113214h */ case   10:  		/* lwz R11, <#[R28 + 24]> */
		/* 82113214h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000018) );
		/* 82113214h case   10:*/		return 0x82113218;
		  /* 82113218h */ case   11:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82113218h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82113218h case   11:*/		return 0x8211321C;
		  /* 8211321Ch */ case   12:  		/* mr R4, R29 */
		/* 8211321Ch case   12:*/		regs.R4 = regs.R29;
		/* 8211321Ch case   12:*/		return 0x82113220;
		  /* 82113220h */ case   13:  		/* lwzx R26, <#[R10 + R11]> */
		/* 82113220h case   13:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82113220h case   13:*/		return 0x82113224;
		  /* 82113224h */ case   14:  		/* mr R3, R26 */
		/* 82113224h case   14:*/		regs.R3 = regs.R26;
		/* 82113224h case   14:*/		return 0x82113228;
		  /* 82113228h */ case   15:  		/* bl -95032 */
		/* 82113228h case   15:*/		regs.LR = 0x8211322C; return 0x820FBEF0;
		/* 82113228h case   15:*/		return 0x8211322C;
		  /* 8211322Ch */ case   16:  		/* cmpwi CR6, R14, 0 */
		/* 8211322Ch case   16:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 8211322Ch case   16:*/		return 0x82113230;
		  /* 82113230h */ case   17:  		/* bc 4, CR6_EQ, 100 */
		/* 82113230h case   17:*/		if ( !regs.CR[6].eq ) { return 0x82113294;  }
		/* 82113230h case   17:*/		return 0x82113234;
		  /* 82113234h */ case   18:  		/* mr R17, R22 */
		/* 82113234h case   18:*/		regs.R17 = regs.R22;
		/* 82113234h case   18:*/		return 0x82113238;
		  /* 82113238h */ case   19:  		/* mr R21, R26 */
		/* 82113238h case   19:*/		regs.R21 = regs.R26;
		/* 82113238h case   19:*/		return 0x8211323C;
	}
	return 0x8211323C;
} // Block from 821131ECh-8211323Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 8211323Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211323C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211323C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211323C);
		  /* 8211323Ch */ case    0:  		/* cmpwi CR6, R14, 0 */
		/* 8211323Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 8211323Ch case    0:*/		return 0x82113240;
		  /* 82113240h */ case    1:  		/* bc 4, CR6_EQ, 84 */
		/* 82113240h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82113294;  }
		/* 82113240h case    1:*/		return 0x82113244;
		  /* 82113244h */ case    2:  		/* cmpwi CR6, R15, 0 */
		/* 82113244h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R15,0x00000000);
		/* 82113244h case    2:*/		return 0x82113248;
		  /* 82113248h */ case    3:  		/* bc 4, CR6_EQ, 76 */
		/* 82113248h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82113294;  }
		/* 82113248h case    3:*/		return 0x8211324C;
		  /* 8211324Ch */ case    4:  		/* li R11, 1 */
		/* 8211324Ch case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8211324Ch case    4:*/		return 0x82113250;
		  /* 82113250h */ case    5:  		/* mr R4, R30 */
		/* 82113250h case    5:*/		regs.R4 = regs.R30;
		/* 82113250h case    5:*/		return 0x82113254;
		  /* 82113254h */ case    6:  		/* mr R6, R31 */
		/* 82113254h case    6:*/		regs.R6 = regs.R31;
		/* 82113254h case    6:*/		return 0x82113258;
		  /* 82113258h */ case    7:  		/* rlwimi R4, R11, 28, 0, 11 */
		/* 82113258h case    7:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R4,regs.R11);
		/* 82113258h case    7:*/		return 0x8211325C;
		  /* 8211325Ch */ case    8:  		/* mr R5, R31 */
		/* 8211325Ch case    8:*/		regs.R5 = regs.R31;
		/* 8211325Ch case    8:*/		return 0x82113260;
		  /* 82113260h */ case    9:  		/* mr R3, R28 */
		/* 82113260h case    9:*/		regs.R3 = regs.R28;
		/* 82113260h case    9:*/		return 0x82113264;
		  /* 82113264h */ case   10:  		/* bl -90012 */
		/* 82113264h case   10:*/		regs.LR = 0x82113268; return 0x820FD2C8;
		/* 82113264h case   10:*/		return 0x82113268;
		  /* 82113268h */ case   11:  		/* mr R22, R3 */
		/* 82113268h case   11:*/		regs.R22 = regs.R3;
		/* 82113268h case   11:*/		return 0x8211326C;
		  /* 8211326Ch */ case   12:  		/* mr R17, R3 */
		/* 8211326Ch case   12:*/		regs.R17 = regs.R3;
		/* 8211326Ch case   12:*/		return 0x82113270;
		  /* 82113270h */ case   13:  		/* cmpwi CR6, R3, -1 */
		/* 82113270h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82113270h case   13:*/		return 0x82113274;
		  /* 82113274h */ case   14:  		/* bc 12, CR6_EQ, -4408 */
		/* 82113274h case   14:*/		if ( regs.CR[6].eq ) { return 0x8211213C;  }
		/* 82113274h case   14:*/		return 0x82113278;
		  /* 82113278h */ case   15:  		/* lwz R11, <#[R28 + 24]> */
		/* 82113278h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000018) );
		/* 82113278h case   15:*/		return 0x8211327C;
		  /* 8211327Ch */ case   16:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 8211327Ch case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 8211327Ch case   16:*/		return 0x82113280;
		  /* 82113280h */ case   17:  		/* mr R4, R29 */
		/* 82113280h case   17:*/		regs.R4 = regs.R29;
		/* 82113280h case   17:*/		return 0x82113284;
		  /* 82113284h */ case   18:  		/* lwzx R26, <#[R10 + R11]> */
		/* 82113284h case   18:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82113284h case   18:*/		return 0x82113288;
		  /* 82113288h */ case   19:  		/* mr R3, R26 */
		/* 82113288h case   19:*/		regs.R3 = regs.R26;
		/* 82113288h case   19:*/		return 0x8211328C;
		  /* 8211328Ch */ case   20:  		/* mr R21, R26 */
		/* 8211328Ch case   20:*/		regs.R21 = regs.R26;
		/* 8211328Ch case   20:*/		return 0x82113290;
		  /* 82113290h */ case   21:  		/* bl -95136 */
		/* 82113290h case   21:*/		regs.LR = 0x82113294; return 0x820FBEF0;
		/* 82113290h case   21:*/		return 0x82113294;
	}
	return 0x82113294;
} // Block from 8211323Ch-82113294h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82113294h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113294( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113294) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113294);
		  /* 82113294h */ case    0:  		/* lwz R11, <#[R1 + 524]> */
		/* 82113294h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000020C) );
		/* 82113294h case    0:*/		return 0x82113298;
		  /* 82113298h */ case    1:  		/* addi R10, R1, 160 */
		/* 82113298h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xA0);
		/* 82113298h case    1:*/		return 0x8211329C;
		  /* 8211329Ch */ case    2:  		/* li R18, 0 */
		/* 8211329Ch case    2:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 8211329Ch case    2:*/		return 0x821132A0;
		  /* 821132A0h */ case    3:  		/* li R29, 0 */
		/* 821132A0h case    3:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821132A0h case    3:*/		return 0x821132A4;
		  /* 821132A4h */ case    4:  		/* rlwinm R24, R30, 2, 0, 29 */
		/* 821132A4h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R24,regs.R30);
		/* 821132A4h case    4:*/		return 0x821132A8;
		  /* 821132A8h */ case    5:  		/* li R20, 0 */
		/* 821132A8h case    5:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 821132A8h case    5:*/		return 0x821132AC;
		  /* 821132ACh */ case    6:  		/* subf R25, R10, R11 */
		/* 821132ACh case    6:*/		cpu::op::subf<0>(regs,&regs.R25,regs.R10,regs.R11);
		/* 821132ACh case    6:*/		return 0x821132B0;
		  /* 821132B0h */ case    7:  		/* li R23, 0 */
		/* 821132B0h case    7:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 821132B0h case    7:*/		return 0x821132B4;
		  /* 821132B4h */ case    8:  		/* b 12 */
		/* 821132B4h case    8:*/		return 0x821132C0;
		/* 821132B4h case    8:*/		return 0x821132B8;
		  /* 821132B8h */ case    9:  		/* lwz R28, <#[R1 + 516]> */
		/* 821132B8h case    9:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000204) );
		/* 821132B8h case    9:*/		return 0x821132BC;
		  /* 821132BCh */ case   10:  		/* lwz R27, <#[R1 + 184]> */
		/* 821132BCh case   10:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000000B8) );
		/* 821132BCh case   10:*/		return 0x821132C0;
	}
	return 0x821132C0;
} // Block from 82113294h-821132C0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821132C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821132C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821132C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821132C0);
		  /* 821132C0h */ case    0:  		/* addi R19, R1, 208 */
		/* 821132C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R1,0xD0);
		/* 821132C0h case    0:*/		return 0x821132C4;
		  /* 821132C4h */ case    1:  		/* lwzx R11, <#[R23 + R19]> */
		/* 821132C4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + regs.R19 + 0x00000000) );
		/* 821132C4h case    1:*/		return 0x821132C8;
		  /* 821132C8h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 821132C8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821132C8h case    2:*/		return 0x821132CC;
		  /* 821132CCh */ case    3:  		/* bc 4, CR6_EQ, 792 */
		/* 821132CCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x821135E4;  }
		/* 821132CCh case    3:*/		return 0x821132D0;
		  /* 821132D0h */ case    4:  		/* addi R11, R1, 160 */
		/* 821132D0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xA0);
		/* 821132D0h case    4:*/		return 0x821132D4;
		  /* 821132D4h */ case    5:  		/* mr R4, R27 */
		/* 821132D4h case    5:*/		regs.R4 = regs.R27;
		/* 821132D4h case    5:*/		return 0x821132D8;
		  /* 821132D8h */ case    6:  		/* mr R3, R28 */
		/* 821132D8h case    6:*/		regs.R3 = regs.R28;
		/* 821132D8h case    6:*/		return 0x821132DC;
		  /* 821132DCh */ case    7:  		/* add R27, R23, R11 */
		/* 821132DCh case    7:*/		cpu::op::add<0>(regs,&regs.R27,regs.R23,regs.R11);
		/* 821132DCh case    7:*/		return 0x821132E0;
		  /* 821132E0h */ case    8:  		/* lwzx R5, <#[R23 + R11]> */
		/* 821132E0h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R23 + regs.R11 + 0x00000000) );
		/* 821132E0h case    8:*/		return 0x821132E4;
		  /* 821132E4h */ case    9:  		/* bl -75852 */
		/* 821132E4h case    9:*/		regs.LR = 0x821132E8; return 0x82100A98;
		/* 821132E4h case    9:*/		return 0x821132E8;
		  /* 821132E8h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 821132E8h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821132E8h case   10:*/		return 0x821132EC;
		  /* 821132ECh */ case   11:  		/* bc 12, CR0_EQ, 760 */
		/* 821132ECh case   11:*/		if ( regs.CR[0].eq ) { return 0x821135E4;  }
		/* 821132ECh case   11:*/		return 0x821132F0;
		  /* 821132F0h */ case   12:  		/* cmpwi CR6, R16, 0 */
		/* 821132F0h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R16,0x00000000);
		/* 821132F0h case   12:*/		return 0x821132F4;
		  /* 821132F4h */ case   13:  		/* bc 12, CR6_EQ, 36 */
		/* 821132F4h case   13:*/		if ( regs.CR[6].eq ) { return 0x82113318;  }
		/* 821132F4h case   13:*/		return 0x821132F8;
		  /* 821132F8h */ case   14:  		/* addi R11, R1, 240 */
		/* 821132F8h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xF0);
		/* 821132F8h case   14:*/		return 0x821132FC;
		  /* 821132FCh */ case   15:  		/* lwz R4, <#[R28 + 120]> */
		/* 821132FCh case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000078) );
		/* 821132FCh case   15:*/		return 0x82113300;
		  /* 82113300h */ case   16:  		/* li R6, 0 */
		/* 82113300h case   16:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82113300h case   16:*/		return 0x82113304;
		  /* 82113304h */ case   17:  		/* li R5, 0 */
		/* 82113304h case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82113304h case   17:*/		return 0x82113308;
		  /* 82113308h */ case   18:  		/* mr R3, R28 */
		/* 82113308h case   18:*/		regs.R3 = regs.R28;
		/* 82113308h case   18:*/		return 0x8211330C;
		  /* 8211330Ch */ case   19:  		/* lfdx FR1, <#[R20 + R11]> */
		/* 8211330Ch case   19:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R20 + regs.R11 + 0x00000000) );
		/* 8211330Ch case   19:*/		return 0x82113310;
		  /* 82113310h */ case   20:  		/* bl -90344 */
		/* 82113310h case   20:*/		regs.LR = 0x82113314; return 0x820FD228;
		/* 82113310h case   20:*/		return 0x82113314;
		  /* 82113314h */ case   21:  		/* b 8 */
		/* 82113314h case   21:*/		return 0x8211331C;
		/* 82113314h case   21:*/		return 0x82113318;
	}
	return 0x82113318;
} // Block from 821132C0h-82113318h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82113318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113318);
		  /* 82113318h */ case    0:  		/* mr R3, R5 */
		/* 82113318h case    0:*/		regs.R3 = regs.R5;
		/* 82113318h case    0:*/		return 0x8211331C;
	}
	return 0x8211331C;
} // Block from 82113318h-8211331Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8211331Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211331C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211331C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211331C);
		  /* 8211331Ch */ case    0:  		/* cmpwi CR6, R3, -1 */
		/* 8211331Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8211331Ch case    0:*/		return 0x82113320;
		  /* 82113320h */ case    1:  		/* bc 12, CR6_EQ, -4580 */
		/* 82113320h case    1:*/		if ( regs.CR[6].eq ) { return 0x8211213C;  }
		/* 82113320h case    1:*/		return 0x82113324;
		  /* 82113324h */ case    2:  		/* lwz R31, <#[R1 + 516]> */
		/* 82113324h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000204) );
		/* 82113324h case    2:*/		return 0x82113328;
		  /* 82113328h */ case    3:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 82113328h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 82113328h case    3:*/		return 0x8211332C;
		  /* 8211332Ch */ case    4:  		/* lwz R10, <#[R21 + 8]> */
		/* 8211332Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R21 + 0x00000008) );
		/* 8211332Ch case    4:*/		return 0x82113330;
		  /* 82113330h */ case    5:  		/* cmpwi CR6, R16, 0 */
		/* 82113330h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R16,0x00000000);
		/* 82113330h case    5:*/		return 0x82113334;
		  /* 82113334h */ case    6:  		/* lwz R9, <#[R31 + 20]> */
		/* 82113334h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 82113334h case    6:*/		return 0x82113338;
		  /* 82113338h */ case    7:  		/* lwzx R28, <#[R11 + R9]> */
		/* 82113338h case    7:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82113338h case    7:*/		return 0x8211333C;
		  /* 8211333Ch */ case    8:  		/* stwx R3, <#[R29 + R10]> */
		/* 8211333Ch case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + regs.R10 + 0x00000000) );
		/* 8211333Ch case    8:*/		return 0x82113340;
		  /* 82113340h */ case    9:  		/* bc 12, CR6_EQ, 8 */
		/* 82113340h case    9:*/		if ( regs.CR[6].eq ) { return 0x82113348;  }
		/* 82113340h case    9:*/		return 0x82113344;
		  /* 82113344h */ case   10:  		/* stw R3, <#[R28 + 52]> */
		/* 82113344h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000034) );
		/* 82113344h case   10:*/		return 0x82113348;
	}
	return 0x82113348;
} // Block from 8211331Ch-82113348h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82113348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113348);
		  /* 82113348h */ case    0:  		/* cmpwi CR6, R14, 0 */
		/* 82113348h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 82113348h case    0:*/		return 0x8211334C;
		  /* 8211334Ch */ case    1:  		/* bc 12, CR6_EQ, 264 */
		/* 8211334Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82113454;  }
		/* 8211334Ch case    1:*/		return 0x82113350;
		  /* 82113350h */ case    2:  		/* lwz R11, <#[R1 + 236]> */
		/* 82113350h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000EC) );
		/* 82113350h case    2:*/		return 0x82113354;
		  /* 82113354h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 82113354h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82113354h case    3:*/		return 0x82113358;
		  /* 82113358h */ case    4:  		/* bc 4, CR6_EQ, 56 */
		/* 82113358h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82113390;  }
		/* 82113358h case    4:*/		return 0x8211335C;
		  /* 8211335Ch */ case    5:  		/* addi R11, R1, 272 */
		/* 8211335Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x110);
		/* 8211335Ch case    5:*/		return 0x82113360;
		  /* 82113360h */ case    6:  		/* lwz R4, <#[R31 + 120]> */
		/* 82113360h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000078) );
		/* 82113360h case    6:*/		return 0x82113364;
		  /* 82113364h */ case    7:  		/* li R6, 0 */
		/* 82113364h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82113364h case    7:*/		return 0x82113368;
		  /* 82113368h */ case    8:  		/* li R5, 0 */
		/* 82113368h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82113368h case    8:*/		return 0x8211336C;
		  /* 8211336Ch */ case    9:  		/* mr R3, R31 */
		/* 8211336Ch case    9:*/		regs.R3 = regs.R31;
		/* 8211336Ch case    9:*/		return 0x82113370;
		  /* 82113370h */ case   10:  		/* lfdx FR1, <#[R20 + R11]> */
		/* 82113370h case   10:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R20 + regs.R11 + 0x00000000) );
		/* 82113370h case   10:*/		return 0x82113374;
		  /* 82113374h */ case   11:  		/* bl -90444 */
		/* 82113374h case   11:*/		regs.LR = 0x82113378; return 0x820FD228;
		/* 82113374h case   11:*/		return 0x82113378;
		  /* 82113378h */ case   12:  		/* lwz R11, <#[R21 + 8]> */
		/* 82113378h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 82113378h case   12:*/		return 0x8211337C;
		  /* 8211337Ch */ case   13:  		/* stwx R3, <#[R11 + R24]> */
		/* 8211337Ch case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + regs.R24 + 0x00000000) );
		/* 8211337Ch case   13:*/		return 0x82113380;
		  /* 82113380h */ case   14:  		/* lwz R11, <#[R21 + 8]> */
		/* 82113380h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 82113380h case   14:*/		return 0x82113384;
		  /* 82113384h */ case   15:  		/* lwzx R11, <#[R11 + R24]> */
		/* 82113384h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R24 + 0x00000000) );
		/* 82113384h case   15:*/		return 0x82113388;
		  /* 82113388h */ case   16:  		/* cmpwi CR6, R11, -1 */
		/* 82113388h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82113388h case   16:*/		return 0x8211338C;
		  /* 8211338Ch */ case   17:  		/* bc 12, CR6_EQ, -4688 */
		/* 8211338Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x8211213C;  }
		/* 8211338Ch case   17:*/		return 0x82113390;
	}
	return 0x82113390;
} // Block from 82113348h-82113390h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82113390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113390);
		  /* 82113390h */ case    0:  		/* cmpwi CR6, R15, 0 */
		/* 82113390h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R15,0x00000000);
		/* 82113390h case    0:*/		return 0x82113394;
		  /* 82113394h */ case    1:  		/* bc 12, CR6_EQ, 360 */
		/* 82113394h case    1:*/		if ( regs.CR[6].eq ) { return 0x821134FC;  }
		/* 82113394h case    1:*/		return 0x82113398;
		  /* 82113398h */ case    2:  		/* lwz R11, <#[R1 + 144]> */
		/* 82113398h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 82113398h case    2:*/		return 0x8211339C;
		  /* 8211339Ch */ case    3:  		/* cmpwi CR6, R11, -1 */
		/* 8211339Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8211339Ch case    3:*/		return 0x821133A0;
		  /* 821133A0h */ case    4:  		/* bc 4, CR6_EQ, 24 */
		/* 821133A0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821133B8;  }
		/* 821133A0h case    4:*/		return 0x821133A4;
		  /* 821133A4h */ case    5:  		/* lwz R10, <#[R1 + 548]> */
		/* 821133A4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000224) );
		/* 821133A4h case    5:*/		return 0x821133A8;
		  /* 821133A8h */ case    6:  		/* lwz R11, <#[R10]> */
		/* 821133A8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821133A8h case    6:*/		return 0x821133AC;
		  /* 821133ACh */ case    7:  		/* addi R9, R11, 1 */
		/* 821133ACh case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 821133ACh case    7:*/		return 0x821133B0;
		  /* 821133B0h */ case    8:  		/* stw R9, <#[R10]> */
		/* 821133B0h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821133B0h case    8:*/		return 0x821133B4;
		  /* 821133B4h */ case    9:  		/* stw R11, <#[R1 + 144]> */
		/* 821133B4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 821133B4h case    9:*/		return 0x821133B8;
	}
	return 0x821133B8;
} // Block from 82113390h-821133B8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821133B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821133B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821133B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821133B8);
		  /* 821133B8h */ case    0:  		/* lwz R5, <#[R1 + 144]> */
		/* 821133B8h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000090) );
		/* 821133B8h case    0:*/		return 0x821133BC;
		  /* 821133BCh */ case    1:  		/* fmr FR1, FR31 */
		/* 821133BCh case    1:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 821133BCh case    1:*/		return 0x821133C0;
		  /* 821133C0h */ case    2:  		/* lwz R11, <#[R1 + 540]> */
		/* 821133C0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000021C) );
		/* 821133C0h case    2:*/		return 0x821133C4;
		  /* 821133C4h */ case    3:  		/* rlwinm R30, R5, 2, 0, 29 */
		/* 821133C4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R5);
		/* 821133C4h case    3:*/		return 0x821133C8;
		  /* 821133C8h */ case    4:  		/* lwz R3, <#[R1 + 516]> */
		/* 821133C8h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000204) );
		/* 821133C8h case    4:*/		return 0x821133CC;
		  /* 821133CCh */ case    5:  		/* lwzx R6, <#[R30 + R11]> */
		/* 821133CCh case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 821133CCh case    5:*/		return 0x821133D0;
		  /* 821133D0h */ case    6:  		/* addi R10, R6, 1 */
		/* 821133D0h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0x1);
		/* 821133D0h case    6:*/		return 0x821133D4;
		  /* 821133D4h */ case    7:  		/* stwx R10, <#[R30 + R11]> */
		/* 821133D4h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 821133D4h case    7:*/		return 0x821133D8;
		  /* 821133D8h */ case    8:  		/* lwz R4, <#[R3 + 136]> */
		/* 821133D8h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000088) );
		/* 821133D8h case    8:*/		return 0x821133DC;
		  /* 821133DCh */ case    9:  		/* bl -90548 */
		/* 821133DCh case    9:*/		regs.LR = 0x821133E0; return 0x820FD228;
		/* 821133DCh case    9:*/		return 0x821133E0;
		  /* 821133E0h */ case   10:  		/* mr R31, R3 */
		/* 821133E0h case   10:*/		regs.R31 = regs.R3;
		/* 821133E0h case   10:*/		return 0x821133E4;
		  /* 821133E4h */ case   11:  		/* cmpwi CR6, R3, -1 */
		/* 821133E4h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 821133E4h case   11:*/		return 0x821133E8;
		  /* 821133E8h */ case   12:  		/* bc 12, CR6_EQ, -4780 */
		/* 821133E8h case   12:*/		if ( regs.CR[6].eq ) { return 0x8211213C;  }
		/* 821133E8h case   12:*/		return 0x821133EC;
		  /* 821133ECh */ case   13:  		/* lwz R11, <#[R1 + 540]> */
		/* 821133ECh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000021C) );
		/* 821133ECh case   13:*/		return 0x821133F0;
		  /* 821133F0h */ case   14:  		/* lwzx R11, <#[R30 + R11]> */
		/* 821133F0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 821133F0h case   14:*/		return 0x821133F4;
		  /* 821133F4h */ case   15:  		/* cmplwi CR6, R11, 4 */
		/* 821133F4h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 821133F4h case   15:*/		return 0x821133F8;
		  /* 821133F8h */ case   16:  		/* bc 4, CR6_GT, 24 */
		/* 821133F8h case   16:*/		if ( !regs.CR[6].gt ) { return 0x82113410;  }
		/* 821133F8h case   16:*/		return 0x821133FC;
		  /* 821133FCh */ case   17:  		/* li R5, 0 */
		/* 821133FCh case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821133FCh case   17:*/		return 0x82113400;
		  /* 82113400h */ case   18:  		/* lwz R6, <#[R1 + 232]> */
		/* 82113400h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x000000E8) );
		/* 82113400h case   18:*/		return 0x82113404;
		  /* 82113404h */ case   19:  		/* li R4, 0 */
		/* 82113404h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82113404h case   19:*/		return 0x82113408;
		  /* 82113408h */ case   20:  		/* lwz R3, <#[R1 + 516]> */
		/* 82113408h case   20:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000204) );
		/* 82113408h case   20:*/		return 0x8211340C;
		  /* 8211340Ch */ case   21:  		/* bl -19676 */
		/* 8211340Ch case   21:*/		regs.LR = 0x82113410; return 0x8210E730;
		/* 8211340Ch case   21:*/		return 0x82113410;
	}
	return 0x82113410;
} // Block from 821133B8h-82113410h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82113410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113410);
		  /* 82113410h */ case    0:  		/* lwz R11, <#[R1 + 516]> */
		/* 82113410h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000204) );
		/* 82113410h case    0:*/		return 0x82113414;
		  /* 82113414h */ case    1:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82113414h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82113414h case    1:*/		return 0x82113418;
		  /* 82113418h */ case    2:  		/* lwz R8, <#[R1 + 176]> */
		/* 82113418h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x000000B0) );
		/* 82113418h case    2:*/		return 0x8211341C;
		  /* 8211341Ch */ case    3:  		/* lwz R9, <#[R1 + 228]> */
		/* 8211341Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000E4) );
		/* 8211341Ch case    3:*/		return 0x82113420;
		  /* 82113420h */ case    4:  		/* lwz R11, <#[R11 + 20]> */
		/* 82113420h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82113420h case    4:*/		return 0x82113424;
		  /* 82113424h */ case    5:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82113424h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82113424h case    5:*/		return 0x82113428;
		  /* 82113428h */ case    6:  		/* stw R8, <#[R11 + 24]> */
		/* 82113428h case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000018) );
		/* 82113428h case    6:*/		return 0x8211342C;
		  /* 8211342Ch */ case    7:  		/* stw R9, <#[R11 + 20]> */
		/* 8211342Ch case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 8211342Ch case    7:*/		return 0x82113430;
		  /* 82113430h */ case    8:  		/* lwz R10, <#[R28]> */
		/* 82113430h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 82113430h case    8:*/		return 0x82113434;
		  /* 82113434h */ case    9:  		/* rlwinm R10, R10, 0, 4, 6 */
		/* 82113434h case    9:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R10,regs.R10);
		/* 82113434h case    9:*/		return 0x82113438;
		  /* 82113438h */ case   10:  		/* stw R10, <#[R11]> */
		/* 82113438h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82113438h case   10:*/		return 0x8211343C;
		  /* 8211343Ch */ case   11:  		/* stw R17, <#[R11 + 72]> */
		/* 8211343Ch case   11:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R11 + 0x00000048) );
		/* 8211343Ch case   11:*/		return 0x82113440;
		  /* 82113440h */ case   12:  		/* lwz R11, <#[R26 + 8]> */
		/* 82113440h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82113440h case   12:*/		return 0x82113444;
		  /* 82113444h */ case   13:  		/* stwx R31, <#[R11 + R29]> */
		/* 82113444h case   13:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82113444h case   13:*/		return 0x82113448;
		  /* 82113448h */ case   14:  		/* lwz R11, <#[R21 + 16]> */
		/* 82113448h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000010) );
		/* 82113448h case   14:*/		return 0x8211344C;
		  /* 8211344Ch */ case   15:  		/* stwx R31, <#[R11 + R29]> */
		/* 8211344Ch case   15:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 8211344Ch case   15:*/		return 0x82113450;
		  /* 82113450h */ case   16:  		/* lwz R31, <#[R1 + 516]> */
		/* 82113450h case   16:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000204) );
		/* 82113450h case   16:*/		return 0x82113454;
	}
	return 0x82113454;
} // Block from 82113410h-82113454h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82113454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113454);
		  /* 82113454h */ case    0:  		/* cmpwi CR6, R15, 0 */
		/* 82113454h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R15,0x00000000);
		/* 82113454h case    0:*/		return 0x82113458;
		  /* 82113458h */ case    1:  		/* bc 12, CR6_EQ, 164 */
		/* 82113458h case    1:*/		if ( regs.CR[6].eq ) { return 0x821134FC;  }
		/* 82113458h case    1:*/		return 0x8211345C;
		  /* 8211345Ch */ case    2:  		/* lwz R7, <#[R31 + 8]> */
		/* 8211345Ch case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000008) );
		/* 8211345Ch case    2:*/		return 0x82113460;
		  /* 82113460h */ case    3:  		/* li R3, 0 */
		/* 82113460h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82113460h case    3:*/		return 0x82113464;
		  /* 82113464h */ case    4:  		/* cmplwi CR6, R7, 0 */
		/* 82113464h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82113464h case    4:*/		return 0x82113468;
		  /* 82113468h */ case    5:  		/* bc 12, CR6_EQ, 80 */
		/* 82113468h case    5:*/		if ( regs.CR[6].eq ) { return 0x821134B8;  }
		/* 82113468h case    5:*/		return 0x8211346C;
		  /* 8211346Ch */ case    6:  		/* lwz R9, <#[R31 + 120]> */
		/* 8211346Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000078) );
		/* 8211346Ch case    6:*/		return 0x82113470;
		  /* 82113470h */ case    7:  		/* li R11, 0 */
		/* 82113470h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82113470h case    7:*/		return 0x82113474;
		  /* 82113474h */ case    8:  		/* lwz R8, <#[R31 + 20]> */
		/* 82113474h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000014) );
		/* 82113474h case    8:*/		return 0x82113478;
		  /* 82113478h */ case    9:  		/* lwzx R10, <#[R11 + R8]> */
		/* 82113478h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82113478h case    9:*/		return 0x8211347C;
		  /* 8211347Ch */ case   10:  		/* lwz R6, <#[R10 + 4]> */
		/* 8211347Ch case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 8211347Ch case   10:*/		return 0x82113480;
		  /* 82113480h */ case   11:  		/* cmplw CR6, R9, R6 */
		/* 82113480h case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 82113480h case   11:*/		return 0x82113484;
		  /* 82113484h */ case   12:  		/* bc 4, CR6_EQ, 36 */
		/* 82113484h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821134A8;  }
		/* 82113484h case   12:*/		return 0x82113488;
		  /* 82113488h */ case   13:  		/* lwz R6, <#[R10 + 8]> */
		/* 82113488h case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000008) );
		/* 82113488h case   13:*/		return 0x8211348C;
		  /* 8211348Ch */ case   14:  		/* cmpwi CR6, R6, -1 */
		/* 8211348Ch case   14:*/		cpu::op::cmpwi<6>(regs,regs.R6,0xFFFFFFFF);
		/* 8211348Ch case   14:*/		return 0x82113490;
		  /* 82113490h */ case   15:  		/* bc 4, CR6_EQ, 24 */
		/* 82113490h case   15:*/		if ( !regs.CR[6].eq ) { return 0x821134A8;  }
		/* 82113490h case   15:*/		return 0x82113494;
		  /* 82113494h */ case   16:  		/* addi R6, R1, 240 */
		/* 82113494h case   16:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0xF0);
		/* 82113494h case   16:*/		return 0x82113498;
		  /* 82113498h */ case   17:  		/* lfd FR0, <#[R10 + 32]> */
		/* 82113498h case   17:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 82113498h case   17:*/		return 0x8211349C;
		  /* 8211349Ch */ case   18:  		/* lfdx FR13, <#[R20 + R6]> */
		/* 8211349Ch case   18:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R20 + regs.R6 + 0x00000000) );
		/* 8211349Ch case   18:*/		return 0x821134A0;
		  /* 821134A0h */ case   19:  		/* fcmpu CR6, FR0, FR13 */
		/* 821134A0h case   19:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 821134A0h case   19:*/		return 0x821134A4;
		  /* 821134A4h */ case   20:  		/* bc 12, CR6_EQ, 20 */
		/* 821134A4h case   20:*/		if ( regs.CR[6].eq ) { return 0x821134B8;  }
		/* 821134A4h case   20:*/		return 0x821134A8;
	}
	return 0x821134A8;
} // Block from 82113454h-821134A8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821134A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821134A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821134A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821134A8);
		  /* 821134A8h */ case    0:  		/* addi R3, R3, 1 */
		/* 821134A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 821134A8h case    0:*/		return 0x821134AC;
		  /* 821134ACh */ case    1:  		/* addi R11, R11, 4 */
		/* 821134ACh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821134ACh case    1:*/		return 0x821134B0;
		  /* 821134B0h */ case    2:  		/* cmplw CR6, R3, R7 */
		/* 821134B0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R7);
		/* 821134B0h case    2:*/		return 0x821134B4;
		  /* 821134B4h */ case    3:  		/* bc 12, CR6_LT, -60 */
		/* 821134B4h case    3:*/		if ( regs.CR[6].lt ) { return 0x82113478;  }
		/* 821134B4h case    3:*/		return 0x821134B8;
	}
	return 0x821134B8;
} // Block from 821134A8h-821134B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821134B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821134B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821134B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821134B8);
		  /* 821134B8h */ case    0:  		/* cmplw CR6, R3, R7 */
		/* 821134B8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R7);
		/* 821134B8h case    0:*/		return 0x821134BC;
		  /* 821134BCh */ case    1:  		/* bc 4, CR6_EQ, 56 */
		/* 821134BCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x821134F4;  }
		/* 821134BCh case    1:*/		return 0x821134C0;
		  /* 821134C0h */ case    2:  		/* addi R11, R1, 240 */
		/* 821134C0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xF0);
		/* 821134C0h case    2:*/		return 0x821134C4;
		  /* 821134C4h */ case    3:  		/* lwz R4, <#[R31 + 120]> */
		/* 821134C4h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000078) );
		/* 821134C4h case    3:*/		return 0x821134C8;
		  /* 821134C8h */ case    4:  		/* li R6, 0 */
		/* 821134C8h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821134C8h case    4:*/		return 0x821134CC;
		  /* 821134CCh */ case    5:  		/* li R5, 0 */
		/* 821134CCh case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821134CCh case    5:*/		return 0x821134D0;
		  /* 821134D0h */ case    6:  		/* mr R3, R31 */
		/* 821134D0h case    6:*/		regs.R3 = regs.R31;
		/* 821134D0h case    6:*/		return 0x821134D4;
		  /* 821134D4h */ case    7:  		/* lfdx FR1, <#[R20 + R11]> */
		/* 821134D4h case    7:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R20 + regs.R11 + 0x00000000) );
		/* 821134D4h case    7:*/		return 0x821134D8;
		  /* 821134D8h */ case    8:  		/* bl -90800 */
		/* 821134D8h case    8:*/		regs.LR = 0x821134DC; return 0x820FD228;
		/* 821134D8h case    8:*/		return 0x821134DC;
		  /* 821134DCh */ case    9:  		/* cmpwi CR6, R3, -1 */
		/* 821134DCh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 821134DCh case    9:*/		return 0x821134E0;
		  /* 821134E0h */ case   10:  		/* bc 12, CR6_EQ, -5028 */
		/* 821134E0h case   10:*/		if ( regs.CR[6].eq ) { return 0x8211213C;  }
		/* 821134E0h case   10:*/		return 0x821134E4;
		  /* 821134E4h */ case   11:  		/* lwz R11, <#[R31 + 20]> */
		/* 821134E4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 821134E4h case   11:*/		return 0x821134E8;
		  /* 821134E8h */ case   12:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 821134E8h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 821134E8h case   12:*/		return 0x821134EC;
		  /* 821134ECh */ case   13:  		/* lwzx R11, <#[R10 + R11]> */
		/* 821134ECh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821134ECh case   13:*/		return 0x821134F0;
		  /* 821134F0h */ case   14:  		/* stw R3, <#[R11 + 52]> */
		/* 821134F0h case   14:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000034) );
		/* 821134F0h case   14:*/		return 0x821134F4;
	}
	return 0x821134F4;
} // Block from 821134B8h-821134F4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821134F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821134F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821134F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821134F4);
		  /* 821134F4h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 821134F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821134F4h case    0:*/		return 0x821134F8;
		  /* 821134F8h */ case    1:  		/* stwx R3, <#[R11 + R24]> */
		/* 821134F8h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + regs.R24 + 0x00000000) );
		/* 821134F8h case    1:*/		return 0x821134FC;
	}
	return 0x821134FC;
} // Block from 821134F4h-821134FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821134FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821134FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821134FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821134FC);
		  /* 821134FCh */ case    0:  		/* lwz R5, <#[R1 + 224]> */
		/* 821134FCh case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000E0) );
		/* 821134FCh case    0:*/		return 0x82113500;
		  /* 82113500h */ case    1:  		/* fmr FR1, FR31 */
		/* 82113500h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82113500h case    1:*/		return 0x82113504;
		  /* 82113504h */ case    2:  		/* lwz R11, <#[R1 + 540]> */
		/* 82113504h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000021C) );
		/* 82113504h case    2:*/		return 0x82113508;
		  /* 82113508h */ case    3:  		/* rlwinm R30, R5, 2, 0, 29 */
		/* 82113508h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R5);
		/* 82113508h case    3:*/		return 0x8211350C;
		  /* 8211350Ch */ case    4:  		/* lwz R28, <#[R1 + 516]> */
		/* 8211350Ch case    4:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000204) );
		/* 8211350Ch case    4:*/		return 0x82113510;
		  /* 82113510h */ case    5:  		/* mr R3, R28 */
		/* 82113510h case    5:*/		regs.R3 = regs.R28;
		/* 82113510h case    5:*/		return 0x82113514;
		  /* 82113514h */ case    6:  		/* lwzx R6, <#[R30 + R11]> */
		/* 82113514h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 82113514h case    6:*/		return 0x82113518;
		  /* 82113518h */ case    7:  		/* addi R10, R6, 1 */
		/* 82113518h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0x1);
		/* 82113518h case    7:*/		return 0x8211351C;
		  /* 8211351Ch */ case    8:  		/* stwx R10, <#[R30 + R11]> */
		/* 8211351Ch case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8211351Ch case    8:*/		return 0x82113520;
		  /* 82113520h */ case    9:  		/* lwz R4, <#[R28 + 136]> */
		/* 82113520h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000088) );
		/* 82113520h case    9:*/		return 0x82113524;
		  /* 82113524h */ case   10:  		/* bl -90876 */
		/* 82113524h case   10:*/		regs.LR = 0x82113528; return 0x820FD228;
		/* 82113524h case   10:*/		return 0x82113528;
		  /* 82113528h */ case   11:  		/* mr R31, R3 */
		/* 82113528h case   11:*/		regs.R31 = regs.R3;
		/* 82113528h case   11:*/		return 0x8211352C;
		  /* 8211352Ch */ case   12:  		/* cmpwi CR6, R3, -1 */
		/* 8211352Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8211352Ch case   12:*/		return 0x82113530;
		  /* 82113530h */ case   13:  		/* bc 12, CR6_EQ, -5108 */
		/* 82113530h case   13:*/		if ( regs.CR[6].eq ) { return 0x8211213C;  }
		/* 82113530h case   13:*/		return 0x82113534;
		  /* 82113534h */ case   14:  		/* lwz R11, <#[R1 + 540]> */
		/* 82113534h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000021C) );
		/* 82113534h case   14:*/		return 0x82113538;
		  /* 82113538h */ case   15:  		/* lwzx R11, <#[R30 + R11]> */
		/* 82113538h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 82113538h case   15:*/		return 0x8211353C;
		  /* 8211353Ch */ case   16:  		/* cmplwi CR6, R11, 4 */
		/* 8211353Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 8211353Ch case   16:*/		return 0x82113540;
		  /* 82113540h */ case   17:  		/* bc 4, CR6_GT, 24 */
		/* 82113540h case   17:*/		if ( !regs.CR[6].gt ) { return 0x82113558;  }
		/* 82113540h case   17:*/		return 0x82113544;
		  /* 82113544h */ case   18:  		/* li R5, 0 */
		/* 82113544h case   18:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82113544h case   18:*/		return 0x82113548;
		  /* 82113548h */ case   19:  		/* lwz R6, <#[R1 + 232]> */
		/* 82113548h case   19:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x000000E8) );
		/* 82113548h case   19:*/		return 0x8211354C;
		  /* 8211354Ch */ case   20:  		/* li R4, 0 */
		/* 8211354Ch case   20:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8211354Ch case   20:*/		return 0x82113550;
		  /* 82113550h */ case   21:  		/* mr R3, R28 */
		/* 82113550h case   21:*/		regs.R3 = regs.R28;
		/* 82113550h case   21:*/		return 0x82113554;
		  /* 82113554h */ case   22:  		/* bl -20004 */
		/* 82113554h case   22:*/		regs.LR = 0x82113558; return 0x8210E730;
		/* 82113554h case   22:*/		return 0x82113558;
	}
	return 0x82113558;
} // Block from 821134FCh-82113558h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82113558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113558);
		  /* 82113558h */ case    0:  		/* lwz R11, <#[R28 + 20]> */
		/* 82113558h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 82113558h case    0:*/		return 0x8211355C;
		  /* 8211355Ch */ case    1:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 8211355Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 8211355Ch case    1:*/		return 0x82113560;
		  /* 82113560h */ case    2:  		/* lwz R9, <#[R1 + 228]> */
		/* 82113560h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000E4) );
		/* 82113560h case    2:*/		return 0x82113564;
		  /* 82113564h */ case    3:  		/* li R8, 1 */
		/* 82113564h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82113564h case    3:*/		return 0x82113568;
		  /* 82113568h */ case    4:  		/* lwz R7, <#[R1 + 176]> */
		/* 82113568h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x000000B0) );
		/* 82113568h case    4:*/		return 0x8211356C;
		  /* 8211356Ch */ case    5:  		/* addi R24, R24, 4 */
		/* 8211356Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x4);
		/* 8211356Ch case    5:*/		return 0x82113570;
		  /* 82113570h */ case    6:  		/* stwx R8, <#[R23 + R19]> */
		/* 82113570h case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R23 + regs.R19 + 0x00000000) );
		/* 82113570h case    6:*/		return 0x82113574;
		  /* 82113574h */ case    7:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82113574h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82113574h case    7:*/		return 0x82113578;
		  /* 82113578h */ case    8:  		/* stw R9, <#[R11 + 20]> */
		/* 82113578h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 82113578h case    8:*/		return 0x8211357C;
		  /* 8211357Ch */ case    9:  		/* stw R7, <#[R11 + 24]> */
		/* 8211357Ch case    9:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000018) );
		/* 8211357Ch case    9:*/		return 0x82113580;
		  /* 82113580h */ case   10:  		/* lwz R8, <#[R28 + 20]> */
		/* 82113580h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R28 + 0x00000014) );
		/* 82113580h case   10:*/		return 0x82113584;
		  /* 82113584h */ case   11:  		/* lwzx R9, <#[R27 + R25]> */
		/* 82113584h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + regs.R25 + 0x00000000) );
		/* 82113584h case   11:*/		return 0x82113588;
		  /* 82113588h */ case   12:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82113588h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82113588h case   12:*/		return 0x8211358C;
		  /* 8211358Ch */ case   13:  		/* lwzx R9, <#[R9 + R8]> */
		/* 8211358Ch case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 8211358Ch case   13:*/		return 0x82113590;
		  /* 82113590h */ case   14:  		/* lwz R9, <#[R9]> */
		/* 82113590h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 82113590h case   14:*/		return 0x82113594;
		  /* 82113594h */ case   15:  		/* stw R22, <#[R11 + 72]> */
		/* 82113594h case   15:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R11 + 0x00000048) );
		/* 82113594h case   15:*/		return 0x82113598;
		  /* 82113598h */ case   16:  		/* stw R9, <#[R11]> */
		/* 82113598h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82113598h case   16:*/		return 0x8211359C;
		  /* 8211359Ch */ case   17:  		/* lwz R11, <#[R26 + 16]> */
		/* 8211359Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 8211359Ch case   17:*/		return 0x821135A0;
		  /* 821135A0h */ case   18:  		/* stwx R31, <#[R29 + R11]> */
		/* 821135A0h case   18:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 821135A0h case   18:*/		return 0x821135A4;
		  /* 821135A4h */ case   19:  		/* lwz R11, <#[R28 + 20]> */
		/* 821135A4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 821135A4h case   19:*/		return 0x821135A8;
		  /* 821135A8h */ case   20:  		/* lwzx R9, <#[R27 + R25]> */
		/* 821135A8h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + regs.R25 + 0x00000000) );
		/* 821135A8h case   20:*/		return 0x821135AC;
		  /* 821135ACh */ case   21:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821135ACh case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821135ACh case   21:*/		return 0x821135B0;
		  /* 821135B0h */ case   22:  		/* lwzx R9, <#[R9 + R11]> */
		/* 821135B0h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821135B0h case   22:*/		return 0x821135B4;
		  /* 821135B4h */ case   23:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821135B4h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821135B4h case   23:*/		return 0x821135B8;
		  /* 821135B8h */ case   24:  		/* lwz R10, <#[R9 + 52]> */
		/* 821135B8h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000034) );
		/* 821135B8h case   24:*/		return 0x821135BC;
		  /* 821135BCh */ case   25:  		/* stw R10, <#[R11 + 52]> */
		/* 821135BCh case   25:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000034) );
		/* 821135BCh case   25:*/		return 0x821135C0;
		  /* 821135C0h */ case   26:  		/* lwz R11, <#[R28 + 20]> */
		/* 821135C0h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 821135C0h case   26:*/		return 0x821135C4;
		  /* 821135C4h */ case   27:  		/* lwzx R10, <#[R27 + R25]> */
		/* 821135C4h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + regs.R25 + 0x00000000) );
		/* 821135C4h case   27:*/		return 0x821135C8;
		  /* 821135C8h */ case   28:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821135C8h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821135C8h case   28:*/		return 0x821135CC;
		  /* 821135CCh */ case   29:  		/* lwzx R11, <#[R10 + R11]> */
		/* 821135CCh case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821135CCh case   29:*/		return 0x821135D0;
		  /* 821135D0h */ case   30:  		/* stw R31, <#[R11 + 52]> */
		/* 821135D0h case   30:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000034) );
		/* 821135D0h case   30:*/		return 0x821135D4;
		  /* 821135D4h */ case   31:  		/* lwz R11, <#[R26 + 16]> */
		/* 821135D4h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 821135D4h case   31:*/		return 0x821135D8;
		  /* 821135D8h */ case   32:  		/* lwzx R11, <#[R29 + R11]> */
		/* 821135D8h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 821135D8h case   32:*/		return 0x821135DC;
		  /* 821135DCh */ case   33:  		/* addi R29, R29, 4 */
		/* 821135DCh case   33:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 821135DCh case   33:*/		return 0x821135E0;
		  /* 821135E0h */ case   34:  		/* stw R11, <#[R27]> */
		/* 821135E0h case   34:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 821135E0h case   34:*/		return 0x821135E4;
	}
	return 0x821135E4;
} // Block from 82113558h-821135E4h (35 instructions)

//////////////////////////////////////////////////////
// Block at 821135E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821135E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821135E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821135E4);
		  /* 821135E4h */ case    0:  		/* lwz R11, <#[R1 + 532]> */
		/* 821135E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000214) );
		/* 821135E4h case    0:*/		return 0x821135E8;
		  /* 821135E8h */ case    1:  		/* addi R18, R18, 1 */
		/* 821135E8h case    1:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R18,0x1);
		/* 821135E8h case    1:*/		return 0x821135EC;
		  /* 821135ECh */ case    2:  		/* addi R20, R20, 8 */
		/* 821135ECh case    2:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0x8);
		/* 821135ECh case    2:*/		return 0x821135F0;
		  /* 821135F0h */ case    3:  		/* addi R23, R23, 4 */
		/* 821135F0h case    3:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x4);
		/* 821135F0h case    3:*/		return 0x821135F4;
		  /* 821135F4h */ case    4:  		/* cmplw CR6, R18, R11 */
		/* 821135F4h case    4:*/		cpu::op::cmplw<6>(regs,regs.R18,regs.R11);
		/* 821135F4h case    4:*/		return 0x821135F8;
		  /* 821135F8h */ case    5:  		/* bc 12, CR6_LT, -832 */
		/* 821135F8h case    5:*/		if ( regs.CR[6].lt ) { return 0x821132B8;  }
		/* 821135F8h case    5:*/		return 0x821135FC;
	}
	return 0x821135FC;
} // Block from 821135E4h-821135FCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821135FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821135FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821135FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821135FC);
		  /* 821135FCh */ case    0:  		/* lwz R11, <#[R1 + 192]> */
		/* 821135FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000C0) );
		/* 821135FCh case    0:*/		return 0x82113600;
		  /* 82113600h */ case    1:  		/* lwz R10, <#[R1 + 196]> */
		/* 82113600h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000C4) );
		/* 82113600h case    1:*/		return 0x82113604;
		  /* 82113604h */ case    2:  		/* lwz R9, <#[R1 + 532]> */
		/* 82113604h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000214) );
		/* 82113604h case    2:*/		return 0x82113608;
		  /* 82113608h */ case    3:  		/* addi R11, R11, 1 */
		/* 82113608h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82113608h case    3:*/		return 0x8211360C;
		  /* 8211360Ch */ case    4:  		/* addi R10, R10, 4 */
		/* 8211360Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8211360Ch case    4:*/		return 0x82113610;
		  /* 82113610h */ case    5:  		/* stw R11, <#[R1 + 192]> */
		/* 82113610h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000C0) );
		/* 82113610h case    5:*/		return 0x82113614;
		  /* 82113614h */ case    6:  		/* cmplw CR6, R11, R9 */
		/* 82113614h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82113614h case    6:*/		return 0x82113618;
		  /* 82113618h */ case    7:  		/* stw R10, <#[R1 + 196]> */
		/* 82113618h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000C4) );
		/* 82113618h case    7:*/		return 0x8211361C;
		  /* 8211361Ch */ case    8:  		/* bc 12, CR6_LT, -1432 */
		/* 8211361Ch case    8:*/		if ( regs.CR[6].lt ) { return 0x82113084;  }
		/* 8211361Ch case    8:*/		return 0x82113620;
		  /* 82113620h */ case    9:  		/* lwz R11, <#[R1 + 524]> */
		/* 82113620h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000020C) );
		/* 82113620h case    9:*/		return 0x82113624;
		  /* 82113624h */ case   10:  		/* addi R10, R1, 304 */
		/* 82113624h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x130);
		/* 82113624h case   10:*/		return 0x82113628;
		  /* 82113628h */ case   11:  		/* mtspr CTR, R9 */
		/* 82113628h case   11:*/		regs.CTR = regs.R9;
		/* 82113628h case   11:*/		return 0x8211362C;
		  /* 8211362Ch */ case   12:  		/* subf R10, R11, R10 */
		/* 8211362Ch case   12:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 8211362Ch case   12:*/		return 0x82113630;
		  /* 82113630h */ case   13:  		/* lwzx R8, <#[R10 + R11]> */
		/* 82113630h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82113630h case   13:*/		return 0x82113634;
		  /* 82113634h */ case   14:  		/* addi R7, R1, 160 */
		/* 82113634h case   14:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xA0);
		/* 82113634h case   14:*/		return 0x82113638;
		  /* 82113638h */ case   15:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82113638h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82113638h case   15:*/		return 0x8211363C;
		  /* 8211363Ch */ case   16:  		/* lwzx R8, <#[R8 + R7]> */
		/* 8211363Ch case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 8211363Ch case   16:*/		return 0x82113640;
		  /* 82113640h */ case   17:  		/* stw R8, <#[R11]> */
		/* 82113640h case   17:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82113640h case   17:*/		return 0x82113644;
		  /* 82113644h */ case   18:  		/* addi R11, R11, 4 */
		/* 82113644h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82113644h case   18:*/		return 0x82113648;
		  /* 82113648h */ case   19:  		/* bc 16, CR0_LT, -24 */
		/* 82113648h case   19:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82113630;  }
		/* 82113648h case   19:*/		return 0x8211364C;
		  /* 8211364Ch */ case   20:  		/* li R11, 0 */
		/* 8211364Ch case   20:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8211364Ch case   20:*/		return 0x82113650;
		  /* 82113650h */ case   21:  		/* addi R10, R1, 208 */
		/* 82113650h case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xD0);
		/* 82113650h case   21:*/		return 0x82113654;
		  /* 82113654h */ case   22:  		/* lwz R8, <#[R10]> */
		/* 82113654h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82113654h case   22:*/		return 0x82113658;
		  /* 82113658h */ case   23:  		/* cmpwi CR6, R8, 0 */
		/* 82113658h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 82113658h case   23:*/		return 0x8211365C;
		  /* 8211365Ch */ case   24:  		/* bc 12, CR6_EQ, -5408 */
		/* 8211365Ch case   24:*/		if ( regs.CR[6].eq ) { return 0x8211213C;  }
		/* 8211365Ch case   24:*/		return 0x82113660;
		  /* 82113660h */ case   25:  		/* addi R11, R11, 1 */
		/* 82113660h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82113660h case   25:*/		return 0x82113664;
		  /* 82113664h */ case   26:  		/* addi R10, R10, 4 */
		/* 82113664h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82113664h case   26:*/		return 0x82113668;
		  /* 82113668h */ case   27:  		/* cmplw CR6, R11, R9 */
		/* 82113668h case   27:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82113668h case   27:*/		return 0x8211366C;
		  /* 8211366Ch */ case   28:  		/* bc 12, CR6_LT, -24 */
		/* 8211366Ch case   28:*/		if ( regs.CR[6].lt ) { return 0x82113654;  }
		/* 8211366Ch case   28:*/		return 0x82113670;
	}
	return 0x82113670;
} // Block from 821135FCh-82113670h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82113670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113670);
		  /* 82113670h */ case    0:  		/* li R3, 1 */
		/* 82113670h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82113670h case    0:*/		return 0x82113674;
	}
	return 0x82113674;
} // Block from 82113670h-82113674h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82113674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113674);
		  /* 82113674h */ case    0:  		/* addi R1, R1, 496 */
		/* 82113674h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1F0);
		/* 82113674h case    0:*/		return 0x82113678;
		  /* 82113678h */ case    1:  		/* lfd FR29, <#[R1 - 176]> */
		/* 82113678h case    1:*/		cpu::mem::load64f( regs, &regs.FR29, (uint32)(regs.R1 + 0xFFFFFF50) );
		/* 82113678h case    1:*/		return 0x8211367C;
		  /* 8211367Ch */ case    2:  		/* lfd FR30, <#[R1 - 168]> */
		/* 8211367Ch case    2:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFF58) );
		/* 8211367Ch case    2:*/		return 0x82113680;
		  /* 82113680h */ case    3:  		/* lfd FR31, <#[R1 - 160]> */
		/* 82113680h case    3:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 82113680h case    3:*/		return 0x82113684;
		  /* 82113684h */ case    4:  		/* b -533524 */
		/* 82113684h case    4:*/		return 0x82091270;
		/* 82113684h case    4:*/		return 0x82113688;
	}
	return 0x82113688;
} // Block from 82113674h-82113688h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82113688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113688);
		  /* 82113688h */ case    0:  		/* mfspr R12, LR */
		/* 82113688h case    0:*/		regs.R12 = regs.LR;
		/* 82113688h case    0:*/		return 0x8211368C;
		  /* 8211368Ch */ case    1:  		/* bl -533588 */
		/* 8211368Ch case    1:*/		regs.LR = 0x82113690; return 0x82091238;
		/* 8211368Ch case    1:*/		return 0x82113690;
		  /* 82113690h */ case    2:  		/* stwu R1, <#[R1 - 272]> */
		/* 82113690h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEF0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEF0);
		/* 82113690h case    2:*/		return 0x82113694;
		  /* 82113694h */ case    3:  		/* lwz R11, <#[R3 + 20]> */
		/* 82113694h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82113694h case    3:*/		return 0x82113698;
		  /* 82113698h */ case    4:  		/* rlwinm R10, R5, 2, 0, 29 */
		/* 82113698h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R5);
		/* 82113698h case    4:*/		return 0x8211369C;
		  /* 8211369Ch */ case    5:  		/* mr R22, R3 */
		/* 8211369Ch case    5:*/		regs.R22 = regs.R3;
		/* 8211369Ch case    5:*/		return 0x821136A0;
		  /* 821136A0h */ case    6:  		/* mr R31, R4 */
		/* 821136A0h case    6:*/		regs.R31 = regs.R4;
		/* 821136A0h case    6:*/		return 0x821136A4;
		  /* 821136A4h */ case    7:  		/* mr R27, R5 */
		/* 821136A4h case    7:*/		regs.R27 = regs.R5;
		/* 821136A4h case    7:*/		return 0x821136A8;
		  /* 821136A8h */ case    8:  		/* mr R24, R6 */
		/* 821136A8h case    8:*/		regs.R24 = regs.R6;
		/* 821136A8h case    8:*/		return 0x821136AC;
		  /* 821136ACh */ case    9:  		/* lwzx R10, <#[R10 + R11]> */
		/* 821136ACh case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821136ACh case    9:*/		return 0x821136B0;
		  /* 821136B0h */ case   10:  		/* mr R23, R7 */
		/* 821136B0h case   10:*/		regs.R23 = regs.R7;
		/* 821136B0h case   10:*/		return 0x821136B4;
		  /* 821136B4h */ case   11:  		/* lwz R10, <#[R10 + 56]> */
		/* 821136B4h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000038) );
		/* 821136B4h case   11:*/		return 0x821136B8;
		  /* 821136B8h */ case   12:  		/* cmpwi CR6, R10, -1 */
		/* 821136B8h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 821136B8h case   12:*/		return 0x821136BC;
		  /* 821136BCh */ case   13:  		/* bc 12, CR6_EQ, 8 */
		/* 821136BCh case   13:*/		if ( regs.CR[6].eq ) { return 0x821136C4;  }
		/* 821136BCh case   13:*/		return 0x821136C0;
		  /* 821136C0h */ case   14:  		/* mr R27, R10 */
		/* 821136C0h case   14:*/		regs.R27 = regs.R10;
		/* 821136C0h case   14:*/		return 0x821136C4;
	}
	return 0x821136C4;
} // Block from 82113688h-821136C4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821136C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821136C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821136C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821136C4);
		  /* 821136C4h */ case    0:  		/* rlwinm R10, R27, 2, 0, 29 */
		/* 821136C4h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R27);
		/* 821136C4h case    0:*/		return 0x821136C8;
		  /* 821136C8h */ case    1:  		/* lwz R9, <#[R31]> */
		/* 821136C8h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821136C8h case    1:*/		return 0x821136CC;
		  /* 821136CCh */ case    2:  		/* li R20, -1 */
		/* 821136CCh case    2:*/		cpu::op::li<0>(regs,&regs.R20,0xFFFFFFFF);
		/* 821136CCh case    2:*/		return 0x821136D0;
		  /* 821136D0h */ case    3:  		/* lwzx R21, <#[R10 + R11]> */
		/* 821136D0h case    3:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821136D0h case    3:*/		return 0x821136D4;
		  /* 821136D4h */ case    4:  		/* lwz R11, <#[R21 + 4]> */
		/* 821136D4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 821136D4h case    4:*/		return 0x821136D8;
		  /* 821136D8h */ case    5:  		/* cmplw CR6, R9, R11 */
		/* 821136D8h case    5:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 821136D8h case    5:*/		return 0x821136DC;
		  /* 821136DCh */ case    6:  		/* bc 4, CR6_EQ, 876 */
		/* 821136DCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x82113A48;  }
		/* 821136DCh case    6:*/		return 0x821136E0;
		  /* 821136E0h */ case    7:  		/* lwz R11, <#[R21 + 12]> */
		/* 821136E0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x0000000C) );
		/* 821136E0h case    7:*/		return 0x821136E4;
		  /* 821136E4h */ case    8:  		/* lwz R10, <#[R31 + 16]> */
		/* 821136E4h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 821136E4h case    8:*/		return 0x821136E8;
		  /* 821136E8h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821136E8h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821136E8h case    9:*/		return 0x821136EC;
		  /* 821136ECh */ case   10:  		/* lwzx R10, <#[R11 + R10]> */
		/* 821136ECh case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821136ECh case   10:*/		return 0x821136F0;
		  /* 821136F0h */ case   11:  		/* cmpwi CR6, R10, -1 */
		/* 821136F0h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 821136F0h case   11:*/		return 0x821136F4;
		  /* 821136F4h */ case   12:  		/* bc 4, CR6_EQ, 852 */
		/* 821136F4h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82113A48;  }
		/* 821136F4h case   12:*/		return 0x821136F8;
		  /* 821136F8h */ case   13:  		/* lwz R9, <#[R31 + 8]> */
		/* 821136F8h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821136F8h case   13:*/		return 0x821136FC;
		  /* 821136FCh */ case   14:  		/* lwz R10, <#[R31 + 4]> */
		/* 821136FCh case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 821136FCh case   14:*/		return 0x82113700;
		  /* 82113700h */ case   15:  		/* lwzx R9, <#[R9 + R11]> */
		/* 82113700h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82113700h case   15:*/		return 0x82113704;
		  /* 82113704h */ case   16:  		/* cmplw CR6, R9, R10 */
		/* 82113704h case   16:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82113704h case   16:*/		return 0x82113708;
		  /* 82113708h */ case   17:  		/* bc 4, CR6_LT, 20 */
		/* 82113708h case   17:*/		if ( !regs.CR[6].lt ) { return 0x8211371C;  }
		/* 82113708h case   17:*/		return 0x8211370C;
		  /* 8211370Ch */ case   18:  		/* lwz R9, <#[R31 + 12]> */
		/* 8211370Ch case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 8211370Ch case   18:*/		return 0x82113710;
		  /* 82113710h */ case   19:  		/* lwzx R11, <#[R9 + R11]> */
		/* 82113710h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82113710h case   19:*/		return 0x82113714;
		  /* 82113714h */ case   20:  		/* cmplw CR6, R11, R10 */
		/* 82113714h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82113714h case   20:*/		return 0x82113718;
		  /* 82113718h */ case   21:  		/* bc 12, CR6_LT, 816 */
		/* 82113718h case   21:*/		if ( regs.CR[6].lt ) { return 0x82113A48;  }
		/* 82113718h case   21:*/		return 0x8211371C;
	}
	return 0x8211371C;
} // Block from 821136C4h-8211371Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 8211371Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211371C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211371C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211371C);
		  /* 8211371Ch */ case    0:  		/* mr R26, R20 */
		/* 8211371Ch case    0:*/		regs.R26 = regs.R20;
		/* 8211371Ch case    0:*/		return 0x82113720;
		  /* 82113720h */ case    1:  		/* mr R29, R20 */
		/* 82113720h case    1:*/		regs.R29 = regs.R20;
		/* 82113720h case    1:*/		return 0x82113724;
		  /* 82113724h */ case    2:  		/* cmpwi CR6, R8, -1 */
		/* 82113724h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 82113724h case    2:*/		return 0x82113728;
		  /* 82113728h */ case    3:  		/* bc 4, CR6_EQ, 352 */
		/* 82113728h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82113888;  }
		/* 82113728h case    3:*/		return 0x8211372C;
		  /* 8211372Ch */ case    4:  		/* lwz R11, <#[R31 + 44]> */
		/* 8211372Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 8211372Ch case    4:*/		return 0x82113730;
		  /* 82113730h */ case    5:  		/* li R25, 0 */
		/* 82113730h case    5:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82113730h case    5:*/		return 0x82113734;
		  /* 82113734h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82113734h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82113734h case    6:*/		return 0x82113738;
		  /* 82113738h */ case    7:  		/* bc 4, CR6_GT, 392 */
		/* 82113738h case    7:*/		if ( !regs.CR[6].gt ) { return 0x821138C0;  }
		/* 82113738h case    7:*/		return 0x8211373C;
		  /* 8211373Ch */ case    8:  		/* li R28, 0 */
		/* 8211373Ch case    8:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8211373Ch case    8:*/		return 0x82113740;
		  /* 82113740h */ case    9:  		/* lwz R11, <#[R21 + 12]> */
		/* 82113740h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x0000000C) );
		/* 82113740h case    9:*/		return 0x82113744;
		  /* 82113744h */ case   10:  		/* li R6, 0 */
		/* 82113744h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82113744h case   10:*/		return 0x82113748;
		  /* 82113748h */ case   11:  		/* lwz R9, <#[R31 + 64]> */
		/* 82113748h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000040) );
		/* 82113748h case   11:*/		return 0x8211374C;
		  /* 8211374Ch */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8211374Ch case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8211374Ch case   12:*/		return 0x82113750;
		  /* 82113750h */ case   13:  		/* lwz R8, <#[R31 + 60]> */
		/* 82113750h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000003C) );
		/* 82113750h case   13:*/		return 0x82113754;
		  /* 82113754h */ case   14:  		/* lwz R5, <#[R31 + 32]> */
		/* 82113754h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000020) );
		/* 82113754h case   14:*/		return 0x82113758;
		  /* 82113758h */ case   15:  		/* lwz R7, <#[R31 + 68]> */
		/* 82113758h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000044) );
		/* 82113758h case   15:*/		return 0x8211375C;
		  /* 8211375Ch */ case   16:  		/* lwzx R4, <#[R9 + R11]> */
		/* 8211375Ch case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8211375Ch case   16:*/		return 0x82113760;
		  /* 82113760h */ case   17:  		/* lwzx R10, <#[R8 + R11]> */
		/* 82113760h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82113760h case   17:*/		return 0x82113764;
		  /* 82113764h */ case   18:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 82113764h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 82113764h case   18:*/		return 0x82113768;
		  /* 82113768h */ case   19:  		/* lwzx R30, <#[R28 + R5]> */
		/* 82113768h case   19:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + regs.R5 + 0x00000000) );
		/* 82113768h case   19:*/		return 0x8211376C;
		  /* 8211376Ch */ case   20:  		/* cmplwi CR6, R10, 0 */
		/* 8211376Ch case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8211376Ch case   20:*/		return 0x82113770;
		  /* 82113770h */ case   21:  		/* add R11, R11, R7 */
		/* 82113770h case   21:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 82113770h case   21:*/		return 0x82113774;
		  /* 82113774h */ case   22:  		/* bc 12, CR6_EQ, 52 */
		/* 82113774h case   22:*/		if ( regs.CR[6].eq ) { return 0x821137A8;  }
		/* 82113774h case   22:*/		return 0x82113778;
		  /* 82113778h */ case   23:  		/* lwz R5, <#[R31 + 16]> */
		/* 82113778h case   23:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000010) );
		/* 82113778h case   23:*/		return 0x8211377C;
		  /* 8211377Ch */ case   24:  		/* lwz R4, <#[R11]> */
		/* 8211377Ch case   24:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 8211377Ch case   24:*/		return 0x82113780;
		  /* 82113780h */ case   25:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 82113780h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 82113780h case   25:*/		return 0x82113784;
		  /* 82113784h */ case   26:  		/* lwzx R4, <#[R4 + R5]> */
		/* 82113784h case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + regs.R5 + 0x00000000) );
		/* 82113784h case   26:*/		return 0x82113788;
		  /* 82113788h */ case   27:  		/* cmplw CR6, R30, R4 */
		/* 82113788h case   27:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R4);
		/* 82113788h case   27:*/		return 0x8211378C;
		  /* 8211378Ch */ case   28:  		/* bc 12, CR6_EQ, 20 */
		/* 8211378Ch case   28:*/		if ( regs.CR[6].eq ) { return 0x821137A0;  }
		/* 8211378Ch case   28:*/		return 0x82113790;
		  /* 82113790h */ case   29:  		/* addi R6, R6, 1 */
		/* 82113790h case   29:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82113790h case   29:*/		return 0x82113794;
		  /* 82113794h */ case   30:  		/* addi R11, R11, 4 */
		/* 82113794h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82113794h case   30:*/		return 0x82113798;
		  /* 82113798h */ case   31:  		/* cmplw CR6, R6, R10 */
		/* 82113798h case   31:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 82113798h case   31:*/		return 0x8211379C;
		  /* 8211379Ch */ case   32:  		/* bc 12, CR6_LT, -32 */
		/* 8211379Ch case   32:*/		if ( regs.CR[6].lt ) { return 0x8211377C;  }
		/* 8211379Ch case   32:*/		return 0x821137A0;
	}
	return 0x821137A0;
} // Block from 8211371Ch-821137A0h (33 instructions)

//////////////////////////////////////////////////////
// Block at 821137A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821137A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821137A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821137A0);
		  /* 821137A0h */ case    0:  		/* cmplw CR6, R6, R10 */
		/* 821137A0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 821137A0h case    0:*/		return 0x821137A4;
		  /* 821137A4h */ case    1:  		/* bc 12, CR6_LT, 204 */
		/* 821137A4h case    1:*/		if ( regs.CR[6].lt ) { return 0x82113870;  }
		/* 821137A4h case    1:*/		return 0x821137A8;
	}
	return 0x821137A8;
} // Block from 821137A0h-821137A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821137A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821137A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821137A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821137A8);
		  /* 821137A8h */ case    0:  		/* cmpwi CR6, R23, -1 */
		/* 821137A8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R23,0xFFFFFFFF);
		/* 821137A8h case    0:*/		return 0x821137AC;
		  /* 821137ACh */ case    1:  		/* bc 12, CR6_EQ, 100 */
		/* 821137ACh case    1:*/		if ( regs.CR[6].eq ) { return 0x82113810;  }
		/* 821137ACh case    1:*/		return 0x821137B0;
		  /* 821137B0h */ case    2:  		/* lwz R11, <#[R22 + 20]> */
		/* 821137B0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000014) );
		/* 821137B0h case    2:*/		return 0x821137B4;
		  /* 821137B4h */ case    3:  		/* rlwinm R10, R23, 2, 0, 29 */
		/* 821137B4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R23);
		/* 821137B4h case    3:*/		return 0x821137B8;
		  /* 821137B8h */ case    4:  		/* li R6, 0 */
		/* 821137B8h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821137B8h case    4:*/		return 0x821137BC;
		  /* 821137BCh */ case    5:  		/* lwzx R11, <#[R10 + R11]> */
		/* 821137BCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821137BCh case    5:*/		return 0x821137C0;
		  /* 821137C0h */ case    6:  		/* lwz R11, <#[R11 + 12]> */
		/* 821137C0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 821137C0h case    6:*/		return 0x821137C4;
		  /* 821137C4h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821137C4h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821137C4h case    7:*/		return 0x821137C8;
		  /* 821137C8h */ case    8:  		/* lwzx R9, <#[R11 + R9]> */
		/* 821137C8h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 821137C8h case    8:*/		return 0x821137CC;
		  /* 821137CCh */ case    9:  		/* lwzx R10, <#[R11 + R8]> */
		/* 821137CCh case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 821137CCh case    9:*/		return 0x821137D0;
		  /* 821137D0h */ case   10:  		/* rlwinm R11, R9, 2, 0, 29 */
		/* 821137D0h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R9);
		/* 821137D0h case   10:*/		return 0x821137D4;
		  /* 821137D4h */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 821137D4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821137D4h case   11:*/		return 0x821137D8;
		  /* 821137D8h */ case   12:  		/* add R11, R11, R7 */
		/* 821137D8h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 821137D8h case   12:*/		return 0x821137DC;
		  /* 821137DCh */ case   13:  		/* bc 12, CR6_EQ, 52 */
		/* 821137DCh case   13:*/		if ( regs.CR[6].eq ) { return 0x82113810;  }
		/* 821137DCh case   13:*/		return 0x821137E0;
		  /* 821137E0h */ case   14:  		/* lwz R9, <#[R31 + 16]> */
		/* 821137E0h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 821137E0h case   14:*/		return 0x821137E4;
		  /* 821137E4h */ case   15:  		/* lwz R8, <#[R11]> */
		/* 821137E4h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 821137E4h case   15:*/		return 0x821137E8;
		  /* 821137E8h */ case   16:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 821137E8h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 821137E8h case   16:*/		return 0x821137EC;
		  /* 821137ECh */ case   17:  		/* lwzx R8, <#[R8 + R9]> */
		/* 821137ECh case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 821137ECh case   17:*/		return 0x821137F0;
		  /* 821137F0h */ case   18:  		/* cmplw CR6, R30, R8 */
		/* 821137F0h case   18:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R8);
		/* 821137F0h case   18:*/		return 0x821137F4;
		  /* 821137F4h */ case   19:  		/* bc 12, CR6_EQ, 20 */
		/* 821137F4h case   19:*/		if ( regs.CR[6].eq ) { return 0x82113808;  }
		/* 821137F4h case   19:*/		return 0x821137F8;
		  /* 821137F8h */ case   20:  		/* addi R6, R6, 1 */
		/* 821137F8h case   20:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821137F8h case   20:*/		return 0x821137FC;
		  /* 821137FCh */ case   21:  		/* addi R11, R11, 4 */
		/* 821137FCh case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821137FCh case   21:*/		return 0x82113800;
		  /* 82113800h */ case   22:  		/* cmplw CR6, R6, R10 */
		/* 82113800h case   22:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 82113800h case   22:*/		return 0x82113804;
		  /* 82113804h */ case   23:  		/* bc 12, CR6_LT, -32 */
		/* 82113804h case   23:*/		if ( regs.CR[6].lt ) { return 0x821137E4;  }
		/* 82113804h case   23:*/		return 0x82113808;
	}
	return 0x82113808;
} // Block from 821137A8h-82113808h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82113808h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113808);
		  /* 82113808h */ case    0:  		/* cmplw CR6, R6, R10 */
		/* 82113808h case    0:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 82113808h case    0:*/		return 0x8211380C;
		  /* 8211380Ch */ case    1:  		/* bc 12, CR6_LT, 100 */
		/* 8211380Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x82113870;  }
		/* 8211380Ch case    1:*/		return 0x82113810;
	}
	return 0x82113810;
} // Block from 82113808h-82113810h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82113810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113810);
		  /* 82113810h */ case    0:  		/* mr R9, R29 */
		/* 82113810h case    0:*/		regs.R9 = regs.R29;
		/* 82113810h case    0:*/		return 0x82113814;
		  /* 82113814h */ case    1:  		/* addi R8, R1, 144 */
		/* 82113814h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x90);
		/* 82113814h case    1:*/		return 0x82113818;
		  /* 82113818h */ case    2:  		/* mr R7, R24 */
		/* 82113818h case    2:*/		regs.R7 = regs.R24;
		/* 82113818h case    2:*/		return 0x8211381C;
		  /* 8211381Ch */ case    3:  		/* mr R6, R30 */
		/* 8211381Ch case    3:*/		regs.R6 = regs.R30;
		/* 8211381Ch case    3:*/		return 0x82113820;
		  /* 82113820h */ case    4:  		/* mr R5, R27 */
		/* 82113820h case    4:*/		regs.R5 = regs.R27;
		/* 82113820h case    4:*/		return 0x82113824;
		  /* 82113824h */ case    5:  		/* mr R4, R31 */
		/* 82113824h case    5:*/		regs.R4 = regs.R31;
		/* 82113824h case    5:*/		return 0x82113828;
		  /* 82113828h */ case    6:  		/* mr R3, R22 */
		/* 82113828h case    6:*/		regs.R3 = regs.R22;
		/* 82113828h case    6:*/		return 0x8211382C;
		  /* 8211382Ch */ case    7:  		/* bl -58164 */
		/* 8211382Ch case    7:*/		regs.LR = 0x82113830; return 0x821054F8;
		/* 8211382Ch case    7:*/		return 0x82113830;
		  /* 82113830h */ case    8:  		/* cmplw CR6, R3, R29 */
		/* 82113830h case    8:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R29);
		/* 82113830h case    8:*/		return 0x82113834;
		  /* 82113834h */ case    9:  		/* bc 4, CR6_LT, 60 */
		/* 82113834h case    9:*/		if ( !regs.CR[6].lt ) { return 0x82113870;  }
		/* 82113834h case    9:*/		return 0x82113838;
		  /* 82113838h */ case   10:  		/* addi R11, R1, 144 */
		/* 82113838h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x90);
		/* 82113838h case   10:*/		return 0x8211383C;
		  /* 8211383Ch */ case   11:  		/* addi R10, R1, 128 */
		/* 8211383Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 8211383Ch case   11:*/		return 0x82113840;
		  /* 82113840h */ case   12:  		/* mr R26, R30 */
		/* 82113840h case   12:*/		regs.R26 = regs.R30;
		/* 82113840h case   12:*/		return 0x82113844;
		  /* 82113844h */ case   13:  		/* mr R29, R3 */
		/* 82113844h case   13:*/		regs.R29 = regs.R3;
		/* 82113844h case   13:*/		return 0x82113848;
		  /* 82113848h */ case   14:  		/* cmplwi CR6, R3, 0 */
		/* 82113848h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82113848h case   14:*/		return 0x8211384C;
		  /* 8211384Ch */ case   15:  		/* lwz R9, <#[R11]> */
		/* 8211384Ch case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8211384Ch case   15:*/		return 0x82113850;
		  /* 82113850h */ case   16:  		/* lwz R8, <#[R11 + 4]> */
		/* 82113850h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82113850h case   16:*/		return 0x82113854;
		  /* 82113854h */ case   17:  		/* lwz R7, <#[R11 + 8]> */
		/* 82113854h case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 82113854h case   17:*/		return 0x82113858;
		  /* 82113858h */ case   18:  		/* lwz R11, <#[R11 + 12]> */
		/* 82113858h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 82113858h case   18:*/		return 0x8211385C;
		  /* 8211385Ch */ case   19:  		/* stw R9, <#[R10]> */
		/* 8211385Ch case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8211385Ch case   19:*/		return 0x82113860;
		  /* 82113860h */ case   20:  		/* stw R8, <#[R10 + 4]> */
		/* 82113860h case   20:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 82113860h case   20:*/		return 0x82113864;
		  /* 82113864h */ case   21:  		/* stw R7, <#[R10 + 8]> */
		/* 82113864h case   21:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000008) );
		/* 82113864h case   21:*/		return 0x82113868;
		  /* 82113868h */ case   22:  		/* stw R11, <#[R10 + 12]> */
		/* 82113868h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 82113868h case   22:*/		return 0x8211386C;
		  /* 8211386Ch */ case   23:  		/* bc 12, CR6_EQ, 76 */
		/* 8211386Ch case   23:*/		if ( regs.CR[6].eq ) { return 0x821138B8;  }
		/* 8211386Ch case   23:*/		return 0x82113870;
	}
	return 0x82113870;
} // Block from 82113810h-82113870h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82113870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113870);
		  /* 82113870h */ case    0:  		/* lwz R11, <#[R31 + 44]> */
		/* 82113870h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 82113870h case    0:*/		return 0x82113874;
		  /* 82113874h */ case    1:  		/* addi R25, R25, 1 */
		/* 82113874h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 82113874h case    1:*/		return 0x82113878;
		  /* 82113878h */ case    2:  		/* addi R28, R28, 4 */
		/* 82113878h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82113878h case    2:*/		return 0x8211387C;
		  /* 8211387Ch */ case    3:  		/* cmplw CR6, R25, R11 */
		/* 8211387Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 8211387Ch case    3:*/		return 0x82113880;
		  /* 82113880h */ case    4:  		/* bc 12, CR6_LT, -320 */
		/* 82113880h case    4:*/		if ( regs.CR[6].lt ) { return 0x82113740;  }
		/* 82113880h case    4:*/		return 0x82113884;
		  /* 82113884h */ case    5:  		/* b 52 */
		/* 82113884h case    5:*/		return 0x821138B8;
		/* 82113884h case    5:*/		return 0x82113888;
	}
	return 0x82113888;
} // Block from 82113870h-82113888h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82113888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113888);
		  /* 82113888h */ case    0:  		/* lwz R11, <#[R31 + 32]> */
		/* 82113888h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 82113888h case    0:*/		return 0x8211388C;
		  /* 8211388Ch */ case    1:  		/* rlwinm R10, R8, 2, 0, 29 */
		/* 8211388Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R8);
		/* 8211388Ch case    1:*/		return 0x82113890;
		  /* 82113890h */ case    2:  		/* mr R9, R20 */
		/* 82113890h case    2:*/		regs.R9 = regs.R20;
		/* 82113890h case    2:*/		return 0x82113894;
		  /* 82113894h */ case    3:  		/* addi R8, R1, 128 */
		/* 82113894h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x80);
		/* 82113894h case    3:*/		return 0x82113898;
		  /* 82113898h */ case    4:  		/* mr R7, R24 */
		/* 82113898h case    4:*/		regs.R7 = regs.R24;
		/* 82113898h case    4:*/		return 0x8211389C;
		  /* 8211389Ch */ case    5:  		/* mr R5, R27 */
		/* 8211389Ch case    5:*/		regs.R5 = regs.R27;
		/* 8211389Ch case    5:*/		return 0x821138A0;
		  /* 821138A0h */ case    6:  		/* lwzx R26, <#[R10 + R11]> */
		/* 821138A0h case    6:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821138A0h case    6:*/		return 0x821138A4;
		  /* 821138A4h */ case    7:  		/* mr R4, R31 */
		/* 821138A4h case    7:*/		regs.R4 = regs.R31;
		/* 821138A4h case    7:*/		return 0x821138A8;
		  /* 821138A8h */ case    8:  		/* mr R3, R22 */
		/* 821138A8h case    8:*/		regs.R3 = regs.R22;
		/* 821138A8h case    8:*/		return 0x821138AC;
		  /* 821138ACh */ case    9:  		/* mr R6, R26 */
		/* 821138ACh case    9:*/		regs.R6 = regs.R26;
		/* 821138ACh case    9:*/		return 0x821138B0;
		  /* 821138B0h */ case   10:  		/* bl -58296 */
		/* 821138B0h case   10:*/		regs.LR = 0x821138B4; return 0x821054F8;
		/* 821138B0h case   10:*/		return 0x821138B4;
		  /* 821138B4h */ case   11:  		/* mr R29, R3 */
		/* 821138B4h case   11:*/		regs.R29 = regs.R3;
		/* 821138B4h case   11:*/		return 0x821138B8;
	}
	return 0x821138B8;
} // Block from 82113888h-821138B8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821138B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821138B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821138B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821138B8);
		  /* 821138B8h */ case    0:  		/* cmpwi CR6, R29, -1 */
		/* 821138B8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFF);
		/* 821138B8h case    0:*/		return 0x821138BC;
		  /* 821138BCh */ case    1:  		/* bc 4, CR6_EQ, 56 */
		/* 821138BCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x821138F4;  }
		/* 821138BCh case    1:*/		return 0x821138C0;
	}
	return 0x821138C0;
} // Block from 821138B8h-821138C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821138C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821138C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821138C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821138C0);
		  /* 821138C0h */ case    0:  		/* lwz R11, <#[R31 + 96]> */
		/* 821138C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 821138C0h case    0:*/		return 0x821138C4;
		  /* 821138C4h */ case    1:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 821138C4h case    1:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 821138C4h case    1:*/		return 0x821138C8;
		  /* 821138C8h */ case    2:  		/* bc 12, CR0_EQ, 32 */
		/* 821138C8h case    2:*/		if ( regs.CR[0].eq ) { return 0x821138E8;  }
		/* 821138C8h case    2:*/		return 0x821138CC;
		  /* 821138CCh */ case    3:  		/* lwz R11, <#[R31 + 92]> */
		/* 821138CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 821138CCh case    3:*/		return 0x821138D0;
		  /* 821138D0h */ case    4:  		/* lis R10, -32254 */
		/* 821138D0h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 821138D0h case    4:*/		return 0x821138D4;
		  /* 821138D4h */ case    5:  		/* li R5, 4004 */
		/* 821138D4h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0xFA4);
		/* 821138D4h case    5:*/		return 0x821138D8;
		  /* 821138D8h */ case    6:  		/* addi R6, R10, -13728 */
		/* 821138D8h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFCA60);
		/* 821138D8h case    6:*/		return 0x821138DC;
		  /* 821138DCh */ case    7:  		/* mr R3, R22 */
		/* 821138DCh case    7:*/		regs.R3 = regs.R22;
		/* 821138DCh case    7:*/		return 0x821138E0;
		  /* 821138E0h */ case    8:  		/* lwz R4, <#[R11 + 60]> */
		/* 821138E0h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000003C) );
		/* 821138E0h case    8:*/		return 0x821138E4;
		  /* 821138E4h */ case    9:  		/* bl -20916 */
		/* 821138E4h case    9:*/		regs.LR = 0x821138E8; return 0x8210E730;
		/* 821138E4h case    9:*/		return 0x821138E8;
	}
	return 0x821138E8;
} // Block from 821138C0h-821138E8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821138E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821138E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821138E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821138E8);
		  /* 821138E8h */ case    0:  		/* lis R3, -32768 */
		/* 821138E8h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 821138E8h case    0:*/		return 0x821138EC;
		  /* 821138ECh */ case    1:  		/* ori R3, R3, 16389 */
		/* 821138ECh case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 821138ECh case    1:*/		return 0x821138F0;
		  /* 821138F0h */ case    2:  		/* b 392 */
		/* 821138F0h case    2:*/		return 0x82113A78;
		/* 821138F0h case    2:*/		return 0x821138F4;
	}
	return 0x821138F4;
} // Block from 821138E8h-821138F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821138F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821138F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821138F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821138F4);
		  /* 821138F4h */ case    0:  		/* lwz R11, <#[R21 + 12]> */
		/* 821138F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x0000000C) );
		/* 821138F4h case    0:*/		return 0x821138F8;
		  /* 821138F8h */ case    1:  		/* lwz R10, <#[R31 + 16]> */
		/* 821138F8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 821138F8h case    1:*/		return 0x821138FC;
		  /* 821138FCh */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821138FCh case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821138FCh case    2:*/		return 0x82113900;
		  /* 82113900h */ case    3:  		/* stwx R26, <#[R11 + R10]> */
		/* 82113900h case    3:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82113900h case    3:*/		return 0x82113904;
		  /* 82113904h */ case    4:  		/* lwz R11, <#[R22 + 204]> */
		/* 82113904h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x000000CC) );
		/* 82113904h case    4:*/		return 0x82113908;
		  /* 82113908h */ case    5:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 82113908h case    5:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 82113908h case    5:*/		return 0x8211390C;
		  /* 8211390Ch */ case    6:  		/* bc 12, CR0_EQ, 128 */
		/* 8211390Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x8211398C;  }
		/* 8211390Ch case    6:*/		return 0x82113910;
		  /* 82113910h */ case    7:  		/* lwz R9, <#[R31 + 36]> */
		/* 82113910h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000024) );
		/* 82113910h case    7:*/		return 0x82113914;
		  /* 82113914h */ case    8:  		/* cmplw CR6, R26, R9 */
		/* 82113914h case    8:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R9);
		/* 82113914h case    8:*/		return 0x82113918;
		  /* 82113918h */ case    9:  		/* bc 4, CR6_LT, 116 */
		/* 82113918h case    9:*/		if ( !regs.CR[6].lt ) { return 0x8211398C;  }
		/* 82113918h case    9:*/		return 0x8211391C;
		  /* 8211391Ch */ case   10:  		/* lwz R8, <#[R31 + 32]> */
		/* 8211391Ch case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000020) );
		/* 8211391Ch case   10:*/		return 0x82113920;
		  /* 82113920h */ case   11:  		/* li R10, 0 */
		/* 82113920h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82113920h case   11:*/		return 0x82113924;
		  /* 82113924h */ case   12:  		/* lwz R11, <#[R8]> */
		/* 82113924h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82113924h case   12:*/		return 0x82113928;
		  /* 82113928h */ case   13:  		/* cmplw CR6, R11, R26 */
		/* 82113928h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 82113928h case   13:*/		return 0x8211392C;
		  /* 8211392Ch */ case   14:  		/* bc 12, CR6_EQ, 28 */
		/* 8211392Ch case   14:*/		if ( regs.CR[6].eq ) { return 0x82113948;  }
		/* 8211392Ch case   14:*/		return 0x82113930;
		  /* 82113930h */ case   15:  		/* li R11, 0 */
		/* 82113930h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82113930h case   15:*/		return 0x82113934;
		  /* 82113934h */ case   16:  		/* addi R11, R11, 4 */
		/* 82113934h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82113934h case   16:*/		return 0x82113938;
		  /* 82113938h */ case   17:  		/* addi R10, R10, 1 */
		/* 82113938h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82113938h case   17:*/		return 0x8211393C;
		  /* 8211393Ch */ case   18:  		/* lwzx R7, <#[R11 + R8]> */
		/* 8211393Ch case   18:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8211393Ch case   18:*/		return 0x82113940;
		  /* 82113940h */ case   19:  		/* cmplw CR6, R7, R26 */
		/* 82113940h case   19:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R26);
		/* 82113940h case   19:*/		return 0x82113944;
		  /* 82113944h */ case   20:  		/* bc 4, CR6_EQ, -16 */
		/* 82113944h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82113934;  }
		/* 82113944h case   20:*/		return 0x82113948;
	}
	return 0x82113948;
} // Block from 821138F4h-82113948h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82113948h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113948( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113948) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113948);
		  /* 82113948h */ case    0:  		/* addi R11, R10, 1 */
		/* 82113948h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x1);
		/* 82113948h case    0:*/		return 0x8211394C;
		  /* 8211394Ch */ case    1:  		/* cmplw CR6, R11, R9 */
		/* 8211394Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8211394Ch case    1:*/		return 0x82113950;
		  /* 82113950h */ case    2:  		/* bc 4, CR6_LT, 44 */
		/* 82113950h case    2:*/		if ( !regs.CR[6].lt ) { return 0x8211397C;  }
		/* 82113950h case    2:*/		return 0x82113954;
		  /* 82113954h */ case    3:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 82113954h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 82113954h case    3:*/		return 0x82113958;
		  /* 82113958h */ case    4:  		/* lwz R9, <#[R31 + 32]> */
		/* 82113958h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000020) );
		/* 82113958h case    4:*/		return 0x8211395C;
		  /* 8211395Ch */ case    5:  		/* addi R11, R11, 1 */
		/* 8211395Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8211395Ch case    5:*/		return 0x82113960;
		  /* 82113960h */ case    6:  		/* add R9, R10, R9 */
		/* 82113960h case    6:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 82113960h case    6:*/		return 0x82113964;
		  /* 82113964h */ case    7:  		/* addi R10, R10, 4 */
		/* 82113964h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82113964h case    7:*/		return 0x82113968;
		  /* 82113968h */ case    8:  		/* lwz R8, <#[R9]> */
		/* 82113968h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 82113968h case    8:*/		return 0x8211396C;
		  /* 8211396Ch */ case    9:  		/* stw R8, <#[R9 - 4]> */
		/* 8211396Ch case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0xFFFFFFFC) );
		/* 8211396Ch case    9:*/		return 0x82113970;
		  /* 82113970h */ case   10:  		/* lwz R9, <#[R31 + 36]> */
		/* 82113970h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000024) );
		/* 82113970h case   10:*/		return 0x82113974;
		  /* 82113974h */ case   11:  		/* cmplw CR6, R11, R9 */
		/* 82113974h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82113974h case   11:*/		return 0x82113978;
		  /* 82113978h */ case   12:  		/* bc 12, CR6_LT, -32 */
		/* 82113978h case   12:*/		if ( regs.CR[6].lt ) { return 0x82113958;  }
		/* 82113978h case   12:*/		return 0x8211397C;
	}
	return 0x8211397C;
} // Block from 82113948h-8211397Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8211397Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211397C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211397C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211397C);
		  /* 8211397Ch */ case    0:  		/* lwz R11, <#[R31 + 32]> */
		/* 8211397Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8211397Ch case    0:*/		return 0x82113980;
		  /* 82113980h */ case    1:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 82113980h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 82113980h case    1:*/		return 0x82113984;
		  /* 82113984h */ case    2:  		/* add R11, R10, R11 */
		/* 82113984h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82113984h case    2:*/		return 0x82113988;
		  /* 82113988h */ case    3:  		/* stw R26, <#[R11 - 4]> */
		/* 82113988h case    3:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 82113988h case    3:*/		return 0x8211398C;
	}
	return 0x8211398C;
} // Block from 8211397Ch-8211398Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8211398Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211398C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211398C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211398C);
		  /* 8211398Ch */ case    0:  		/* li R6, 0 */
		/* 8211398Ch case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8211398Ch case    0:*/		return 0x82113990;
		  /* 82113990h */ case    1:  		/* addi R7, R1, 128 */
		/* 82113990h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x80);
		/* 82113990h case    1:*/		return 0x82113994;
		  /* 82113994h */ case    2:  		/* lwz R11, <#[R21 + 12]> */
		/* 82113994h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x0000000C) );
		/* 82113994h case    2:*/		return 0x82113998;
		  /* 82113998h */ case    3:  		/* lwz R9, <#[R31 + 24]> */
		/* 82113998h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 82113998h case    3:*/		return 0x8211399C;
		  /* 8211399Ch */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8211399Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8211399Ch case    4:*/		return 0x821139A0;
		  /* 821139A0h */ case    5:  		/* add R11, R11, R6 */
		/* 821139A0h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 821139A0h case    5:*/		return 0x821139A4;
		  /* 821139A4h */ case    6:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 821139A4h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 821139A4h case    6:*/		return 0x821139A8;
		  /* 821139A8h */ case    7:  		/* lwzx R8, <#[R10 + R9]> */
		/* 821139A8h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821139A8h case    7:*/		return 0x821139AC;
		  /* 821139ACh */ case    8:  		/* cmpwi CR6, R8, -1 */
		/* 821139ACh case    8:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 821139ACh case    8:*/		return 0x821139B0;
		  /* 821139B0h */ case    9:  		/* bc 12, CR6_EQ, 136 */
		/* 821139B0h case    9:*/		if ( regs.CR[6].eq ) { return 0x82113A38;  }
		/* 821139B0h case    9:*/		return 0x821139B4;
		  /* 821139B4h */ case   10:  		/* lwz R11, <#[R7]> */
		/* 821139B4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 821139B4h case   10:*/		return 0x821139B8;
		  /* 821139B8h */ case   11:  		/* rlwinm R9, R26, 2, 0, 29 */
		/* 821139B8h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R26);
		/* 821139B8h case   11:*/		return 0x821139BC;
		  /* 821139BCh */ case   12:  		/* lwz R5, <#[R31 + 20]> */
		/* 821139BCh case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000014) );
		/* 821139BCh case   12:*/		return 0x821139C0;
		  /* 821139C0h */ case   13:  		/* add R9, R9, R11 */
		/* 821139C0h case   13:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 821139C0h case   13:*/		return 0x821139C4;
		  /* 821139C4h */ case   14:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821139C4h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821139C4h case   14:*/		return 0x821139C8;
		  /* 821139C8h */ case   15:  		/* stwx R11, <#[R5 + R10]> */
		/* 821139C8h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + regs.R10 + 0x00000000) );
		/* 821139C8h case   15:*/		return 0x821139CC;
		  /* 821139CCh */ case   16:  		/* lwz R11, <#[R31 + 28]> */
		/* 821139CCh case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 821139CCh case   16:*/		return 0x821139D0;
		  /* 821139D0h */ case   17:  		/* add R11, R9, R11 */
		/* 821139D0h case   17:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821139D0h case   17:*/		return 0x821139D4;
		  /* 821139D4h */ case   18:  		/* lwz R10, <#[R11]> */
		/* 821139D4h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821139D4h case   18:*/		return 0x821139D8;
		  /* 821139D8h */ case   19:  		/* cmpwi CR6, R10, -1 */
		/* 821139D8h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 821139D8h case   19:*/		return 0x821139DC;
		  /* 821139DCh */ case   20:  		/* bc 12, CR6_EQ, 68 */
		/* 821139DCh case   20:*/		if ( regs.CR[6].eq ) { return 0x82113A20;  }
		/* 821139DCh case   20:*/		return 0x821139E0;
		  /* 821139E0h */ case   21:  		/* rlwinm R9, R8, 2, 0, 29 */
		/* 821139E0h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 821139E0h case   21:*/		return 0x821139E4;
		  /* 821139E4h */ case   22:  		/* lwz R10, <#[R11]> */
		/* 821139E4h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821139E4h case   22:*/		return 0x821139E8;
		  /* 821139E8h */ case   23:  		/* lwz R5, <#[R22 + 20]> */
		/* 821139E8h case   23:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R22 + 0x00000014) );
		/* 821139E8h case   23:*/		return 0x821139EC;
		  /* 821139ECh */ case   24:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821139ECh case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821139ECh case   24:*/		return 0x821139F0;
		  /* 821139F0h */ case   25:  		/* lwzx R4, <#[R9 + R5]> */
		/* 821139F0h case   25:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R9 + regs.R5 + 0x00000000) );
		/* 821139F0h case   25:*/		return 0x821139F4;
		  /* 821139F4h */ case   26:  		/* lwzx R5, <#[R5 + R10]> */
		/* 821139F4h case   26:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R10 + 0x00000000) );
		/* 821139F4h case   26:*/		return 0x821139F8;
		  /* 821139F8h */ case   27:  		/* lwz R4, <#[R4 + 88]> */
		/* 821139F8h case   27:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000058) );
		/* 821139F8h case   27:*/		return 0x821139FC;
		  /* 821139FCh */ case   28:  		/* lwz R5, <#[R5 + 88]> */
		/* 821139FCh case   28:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000058) );
		/* 821139FCh case   28:*/		return 0x82113A00;
		  /* 82113A00h */ case   29:  		/* cmplw CR6, R5, R4 */
		/* 82113A00h case   29:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R4);
		/* 82113A00h case   29:*/		return 0x82113A04;
		  /* 82113A04h */ case   30:  		/* bc 4, CR6_GT, 28 */
		/* 82113A04h case   30:*/		if ( !regs.CR[6].gt ) { return 0x82113A20;  }
		/* 82113A04h case   30:*/		return 0x82113A08;
		  /* 82113A08h */ case   31:  		/* lwz R11, <#[R22 + 20]> */
		/* 82113A08h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000014) );
		/* 82113A08h case   31:*/		return 0x82113A0C;
		  /* 82113A0Ch */ case   32:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82113A0Ch case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82113A0Ch case   32:*/		return 0x82113A10;
		  /* 82113A10h */ case   33:  		/* addi R11, R11, 48 */
		/* 82113A10h case   33:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x30);
		/* 82113A10h case   33:*/		return 0x82113A14;
		  /* 82113A14h */ case   34:  		/* lwz R10, <#[R11]> */
		/* 82113A14h case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82113A14h case   34:*/		return 0x82113A18;
		  /* 82113A18h */ case   35:  		/* cmpwi CR6, R10, -1 */
		/* 82113A18h case   35:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82113A18h case   35:*/		return 0x82113A1C;
		  /* 82113A1Ch */ case   36:  		/* bc 4, CR6_EQ, -56 */
		/* 82113A1Ch case   36:*/		if ( !regs.CR[6].eq ) { return 0x821139E4;  }
		/* 82113A1Ch case   36:*/		return 0x82113A20;
	}
	return 0x82113A20;
} // Block from 8211398Ch-82113A20h (37 instructions)

//////////////////////////////////////////////////////
// Block at 82113A20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113A20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113A20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113A20);
		  /* 82113A20h */ case    0:  		/* lwz R10, <#[R22 + 20]> */
		/* 82113A20h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000014) );
		/* 82113A20h case    0:*/		return 0x82113A24;
		  /* 82113A24h */ case    1:  		/* rlwinm R9, R8, 2, 0, 29 */
		/* 82113A24h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 82113A24h case    1:*/		return 0x82113A28;
		  /* 82113A28h */ case    2:  		/* lwz R5, <#[R11]> */
		/* 82113A28h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 82113A28h case    2:*/		return 0x82113A2C;
		  /* 82113A2Ch */ case    3:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82113A2Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82113A2Ch case    3:*/		return 0x82113A30;
		  /* 82113A30h */ case    4:  		/* stw R5, <#[R10 + 48]> */
		/* 82113A30h case    4:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x00000030) );
		/* 82113A30h case    4:*/		return 0x82113A34;
		  /* 82113A34h */ case    5:  		/* stw R8, <#[R11]> */
		/* 82113A34h case    5:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82113A34h case    5:*/		return 0x82113A38;
	}
	return 0x82113A38;
} // Block from 82113A20h-82113A38h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82113A38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113A38);
		  /* 82113A38h */ case    0:  		/* addi R6, R6, 1 */
		/* 82113A38h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82113A38h case    0:*/		return 0x82113A3C;
		  /* 82113A3Ch */ case    1:  		/* addi R7, R7, 4 */
		/* 82113A3Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82113A3Ch case    1:*/		return 0x82113A40;
		  /* 82113A40h */ case    2:  		/* cmplwi CR6, R6, 4 */
		/* 82113A40h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000004);
		/* 82113A40h case    2:*/		return 0x82113A44;
		  /* 82113A44h */ case    3:  		/* bc 12, CR6_LT, -176 */
		/* 82113A44h case    3:*/		if ( regs.CR[6].lt ) { return 0x82113994;  }
		/* 82113A44h case    3:*/		return 0x82113A48;
	}
	return 0x82113A48;
} // Block from 82113A38h-82113A48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82113A48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113A48);
		  /* 82113A48h */ case    0:  		/* lwz R5, <#[R21 + 8]> */
		/* 82113A48h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R21 + 0x00000008) );
		/* 82113A48h case    0:*/		return 0x82113A4C;
		  /* 82113A4Ch */ case    1:  		/* cmpwi CR6, R5, -1 */
		/* 82113A4Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R5,0xFFFFFFFF);
		/* 82113A4Ch case    1:*/		return 0x82113A50;
		  /* 82113A50h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 82113A50h case    2:*/		if ( regs.CR[6].eq ) { return 0x82113A74;  }
		/* 82113A50h case    2:*/		return 0x82113A54;
		  /* 82113A54h */ case    3:  		/* mr R8, R20 */
		/* 82113A54h case    3:*/		regs.R8 = regs.R20;
		/* 82113A54h case    3:*/		return 0x82113A58;
		  /* 82113A58h */ case    4:  		/* mr R7, R20 */
		/* 82113A58h case    4:*/		regs.R7 = regs.R20;
		/* 82113A58h case    4:*/		return 0x82113A5C;
		  /* 82113A5Ch */ case    5:  		/* li R6, 0 */
		/* 82113A5Ch case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82113A5Ch case    5:*/		return 0x82113A60;
		  /* 82113A60h */ case    6:  		/* mr R4, R31 */
		/* 82113A60h case    6:*/		regs.R4 = regs.R31;
		/* 82113A60h case    6:*/		return 0x82113A64;
		  /* 82113A64h */ case    7:  		/* mr R3, R22 */
		/* 82113A64h case    7:*/		regs.R3 = regs.R22;
		/* 82113A64h case    7:*/		return 0x82113A68;
		  /* 82113A68h */ case    8:  		/* bl -992 */
		/* 82113A68h case    8:*/		regs.LR = 0x82113A6C; return 0x82113688;
		/* 82113A68h case    8:*/		return 0x82113A6C;
		  /* 82113A6Ch */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 82113A6Ch case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82113A6Ch case    9:*/		return 0x82113A70;
		  /* 82113A70h */ case   10:  		/* bc 12, CR0_LT, 8 */
		/* 82113A70h case   10:*/		if ( regs.CR[0].lt ) { return 0x82113A78;  }
		/* 82113A70h case   10:*/		return 0x82113A74;
	}
	return 0x82113A74;
} // Block from 82113A48h-82113A74h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82113A74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113A74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113A74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113A74);
		  /* 82113A74h */ case    0:  		/* li R3, 0 */
		/* 82113A74h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82113A74h case    0:*/		return 0x82113A78;
	}
	return 0x82113A78;
} // Block from 82113A74h-82113A78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82113A78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113A78);
		  /* 82113A78h */ case    0:  		/* addi R1, R1, 272 */
		/* 82113A78h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x110);
		/* 82113A78h case    0:*/		return 0x82113A7C;
		  /* 82113A7Ch */ case    1:  		/* b -534516 */
		/* 82113A7Ch case    1:*/		return 0x82091288;
		/* 82113A7Ch case    1:*/		return 0x82113A80;
	}
	return 0x82113A80;
} // Block from 82113A78h-82113A80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82113A80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113A80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113A80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113A80);
		  /* 82113A80h */ case    0:  		/* mfspr R12, LR */
		/* 82113A80h case    0:*/		regs.R12 = regs.LR;
		/* 82113A80h case    0:*/		return 0x82113A84;
		  /* 82113A84h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82113A84h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82113A84h case    1:*/		return 0x82113A88;
		  /* 82113A88h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82113A88h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82113A88h case    2:*/		return 0x82113A8C;
		  /* 82113A8Ch */ case    3:  		/* lwz R11, <#[R3 + 20]> */
		/* 82113A8Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82113A8Ch case    3:*/		return 0x82113A90;
		  /* 82113A90h */ case    4:  		/* rlwinm R10, R5, 2, 0, 29 */
		/* 82113A90h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R5);
		/* 82113A90h case    4:*/		return 0x82113A94;
		  /* 82113A94h */ case    5:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82113A94h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82113A94h case    5:*/		return 0x82113A98;
		  /* 82113A98h */ case    6:  		/* lwz R5, <#[R11 + 20]> */
		/* 82113A98h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000014) );
		/* 82113A98h case    6:*/		return 0x82113A9C;
		  /* 82113A9Ch */ case    7:  		/* cmpwi CR6, R5, -1 */
		/* 82113A9Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R5,0xFFFFFFFF);
		/* 82113A9Ch case    7:*/		return 0x82113AA0;
		  /* 82113AA0h */ case    8:  		/* bc 12, CR6_EQ, 28 */
		/* 82113AA0h case    8:*/		if ( regs.CR[6].eq ) { return 0x82113ABC;  }
		/* 82113AA0h case    8:*/		return 0x82113AA4;
		  /* 82113AA4h */ case    9:  		/* li R8, -1 */
		/* 82113AA4h case    9:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 82113AA4h case    9:*/		return 0x82113AA8;
		  /* 82113AA8h */ case   10:  		/* li R6, 0 */
		/* 82113AA8h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82113AA8h case   10:*/		return 0x82113AAC;
		  /* 82113AACh */ case   11:  		/* mr R7, R8 */
		/* 82113AACh case   11:*/		regs.R7 = regs.R8;
		/* 82113AACh case   11:*/		return 0x82113AB0;
		  /* 82113AB0h */ case   12:  		/* bl -1064 */
		/* 82113AB0h case   12:*/		regs.LR = 0x82113AB4; return 0x82113688;
		/* 82113AB0h case   12:*/		return 0x82113AB4;
		  /* 82113AB4h */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 82113AB4h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82113AB4h case   13:*/		return 0x82113AB8;
		  /* 82113AB8h */ case   14:  		/* bc 12, CR0_LT, 8 */
		/* 82113AB8h case   14:*/		if ( regs.CR[0].lt ) { return 0x82113AC0;  }
		/* 82113AB8h case   14:*/		return 0x82113ABC;
	}
	return 0x82113ABC;
} // Block from 82113A80h-82113ABCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 82113ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113ABC);
		  /* 82113ABCh */ case    0:  		/* li R3, 0 */
		/* 82113ABCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82113ABCh case    0:*/		return 0x82113AC0;
	}
	return 0x82113AC0;
} // Block from 82113ABCh-82113AC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82113AC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113AC0);
		  /* 82113AC0h */ case    0:  		/* addi R1, R1, 96 */
		/* 82113AC0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82113AC0h case    0:*/		return 0x82113AC4;
		  /* 82113AC4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82113AC4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82113AC4h case    1:*/		return 0x82113AC8;
		  /* 82113AC8h */ case    2:  		/* mtspr LR, R12 */
		/* 82113AC8h case    2:*/		regs.LR = regs.R12;
		/* 82113AC8h case    2:*/		return 0x82113ACC;
		  /* 82113ACCh */ case    3:  		/* bclr 20, CR0_LT */
		/* 82113ACCh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82113ACCh case    3:*/		return 0x82113AD0;
	}
	return 0x82113AD0;
} // Block from 82113AC0h-82113AD0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82113AD0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113AD0);
		  /* 82113AD0h */ case    0:  		/* mfspr R12, LR */
		/* 82113AD0h case    0:*/		regs.R12 = regs.LR;
		/* 82113AD0h case    0:*/		return 0x82113AD4;
		  /* 82113AD4h */ case    1:  		/* bl -534680 */
		/* 82113AD4h case    1:*/		regs.LR = 0x82113AD8; return 0x8209123C;
		/* 82113AD4h case    1:*/		return 0x82113AD8;
		  /* 82113AD8h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 82113AD8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82113AD8h case    2:*/		return 0x82113ADC;
		  /* 82113ADCh */ case    3:  		/* stw R4, <#[R3 + 188]> */
		/* 82113ADCh case    3:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x000000BC) );
		/* 82113ADCh case    3:*/		return 0x82113AE0;
		  /* 82113AE0h */ case    4:  		/* mr R26, R3 */
		/* 82113AE0h case    4:*/		regs.R26 = regs.R3;
		/* 82113AE0h case    4:*/		return 0x82113AE4;
		  /* 82113AE4h */ case    5:  		/* lwz R11, <#[R4 + 96]> */
		/* 82113AE4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000060) );
		/* 82113AE4h case    5:*/		return 0x82113AE8;
		  /* 82113AE8h */ case    6:  		/* rlwimi R11, R5, 30, 1, 1 */
		/* 82113AE8h case    6:*/		cpu::op::rlwimi<0,30,1,1>(regs,&regs.R11,regs.R5);
		/* 82113AE8h case    6:*/		return 0x82113AEC;
		  /* 82113AECh */ case    7:  		/* stw R11, <#[R4 + 96]> */
		/* 82113AECh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000060) );
		/* 82113AECh case    7:*/		return 0x82113AF0;
		  /* 82113AF0h */ case    8:  		/* mr R31, R4 */
		/* 82113AF0h case    8:*/		regs.R31 = regs.R4;
		/* 82113AF0h case    8:*/		return 0x82113AF4;
		  /* 82113AF4h */ case    9:  		/* bl -57180 */
		/* 82113AF4h case    9:*/		regs.LR = 0x82113AF8; return 0x82105B98;
		/* 82113AF4h case    9:*/		return 0x82113AF8;
		  /* 82113AF8h */ case   10:  		/* lwz R11, <#[R26 + 8]> */
		/* 82113AF8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82113AF8h case   10:*/		return 0x82113AFC;
		  /* 82113AFCh */ case   11:  		/* li R8, 0 */
		/* 82113AFCh case   11:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82113AFCh case   11:*/		return 0x82113B00;
		  /* 82113B00h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 82113B00h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82113B00h case   12:*/		return 0x82113B04;
		  /* 82113B04h */ case   13:  		/* bc 4, CR6_GT, 88 */
		/* 82113B04h case   13:*/		if ( !regs.CR[6].gt ) { return 0x82113B5C;  }
		/* 82113B04h case   13:*/		return 0x82113B08;
		  /* 82113B08h */ case   14:  		/* li R10, 0 */
		/* 82113B08h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82113B08h case   14:*/		return 0x82113B0C;
		  /* 82113B0Ch */ case   15:  		/* lwz R11, <#[R26 + 20]> */
		/* 82113B0Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82113B0Ch case   15:*/		return 0x82113B10;
		  /* 82113B10h */ case   16:  		/* lwz R9, <#[R31]> */
		/* 82113B10h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82113B10h case   16:*/		return 0x82113B14;
		  /* 82113B14h */ case   17:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82113B14h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82113B14h case   17:*/		return 0x82113B18;
		  /* 82113B18h */ case   18:  		/* lwz R7, <#[R11 + 4]> */
		/* 82113B18h case   18:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82113B18h case   18:*/		return 0x82113B1C;
		  /* 82113B1Ch */ case   19:  		/* cmplw CR6, R9, R7 */
		/* 82113B1Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 82113B1Ch case   19:*/		return 0x82113B20;
		  /* 82113B20h */ case   20:  		/* bc 4, CR6_EQ, 40 */
		/* 82113B20h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82113B48;  }
		/* 82113B20h case   20:*/		return 0x82113B24;
		  /* 82113B24h */ case   21:  		/* lwz R9, <#[R11 + 56]> */
		/* 82113B24h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000038) );
		/* 82113B24h case   21:*/		return 0x82113B28;
		  /* 82113B28h */ case   22:  		/* cmpwi CR6, R9, -1 */
		/* 82113B28h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 82113B28h case   22:*/		return 0x82113B2C;
		  /* 82113B2Ch */ case   23:  		/* bc 4, CR6_EQ, 28 */
		/* 82113B2Ch case   23:*/		if ( !regs.CR[6].eq ) { return 0x82113B48;  }
		/* 82113B2Ch case   23:*/		return 0x82113B30;
		  /* 82113B30h */ case   24:  		/* lwz R9, <#[R11 + 72]> */
		/* 82113B30h case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000048) );
		/* 82113B30h case   24:*/		return 0x82113B34;
		  /* 82113B34h */ case   25:  		/* lwz R7, <#[R11 + 88]> */
		/* 82113B34h case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000058) );
		/* 82113B34h case   25:*/		return 0x82113B38;
		  /* 82113B38h */ case   26:  		/* cmplw CR6, R7, R9 */
		/* 82113B38h case   26:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R9);
		/* 82113B38h case   26:*/		return 0x82113B3C;
		  /* 82113B3Ch */ case   27:  		/* bc 12, CR6_GT, 12 */
		/* 82113B3Ch case   27:*/		if ( regs.CR[6].gt ) { return 0x82113B48;  }
		/* 82113B3Ch case   27:*/		return 0x82113B40;
		  /* 82113B40h */ case   28:  		/* addi R9, R9, 1 */
		/* 82113B40h case   28:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82113B40h case   28:*/		return 0x82113B44;
		  /* 82113B44h */ case   29:  		/* stw R9, <#[R11 + 88]> */
		/* 82113B44h case   29:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000058) );
		/* 82113B44h case   29:*/		return 0x82113B48;
	}
	return 0x82113B48;
} // Block from 82113AD0h-82113B48h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82113B48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113B48);
		  /* 82113B48h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 82113B48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82113B48h case    0:*/		return 0x82113B4C;
		  /* 82113B4Ch */ case    1:  		/* addi R8, R8, 1 */
		/* 82113B4Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82113B4Ch case    1:*/		return 0x82113B50;
		  /* 82113B50h */ case    2:  		/* addi R10, R10, 4 */
		/* 82113B50h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82113B50h case    2:*/		return 0x82113B54;
		  /* 82113B54h */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 82113B54h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 82113B54h case    3:*/		return 0x82113B58;
		  /* 82113B58h */ case    4:  		/* bc 12, CR6_LT, -76 */
		/* 82113B58h case    4:*/		if ( regs.CR[6].lt ) { return 0x82113B0C;  }
		/* 82113B58h case    4:*/		return 0x82113B5C;
	}
	return 0x82113B5C;
} // Block from 82113B48h-82113B5Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82113B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113B5C);
		  /* 82113B5Ch */ case    0:  		/* lwz R11, <#[R31 + 40]> */
		/* 82113B5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 82113B5Ch case    0:*/		return 0x82113B60;
		  /* 82113B60h */ case    1:  		/* li R4, 255 */
		/* 82113B60h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xFF);
		/* 82113B60h case    1:*/		return 0x82113B64;
		  /* 82113B64h */ case    2:  		/* lwz R3, <#[R31 + 16]> */
		/* 82113B64h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82113B64h case    2:*/		return 0x82113B68;
		  /* 82113B68h */ case    3:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82113B68h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82113B68h case    3:*/		return 0x82113B6C;
		  /* 82113B6Ch */ case    4:  		/* bl -534572 */
		/* 82113B6Ch case    4:*/		regs.LR = 0x82113B70; return 0x82091340;
		/* 82113B6Ch case    4:*/		return 0x82113B70;
		  /* 82113B70h */ case    5:  		/* lwz R11, <#[R31 + 40]> */
		/* 82113B70h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 82113B70h case    5:*/		return 0x82113B74;
		  /* 82113B74h */ case    6:  		/* li R4, 255 */
		/* 82113B74h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0xFF);
		/* 82113B74h case    6:*/		return 0x82113B78;
		  /* 82113B78h */ case    7:  		/* lwz R3, <#[R31 + 20]> */
		/* 82113B78h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 82113B78h case    7:*/		return 0x82113B7C;
		  /* 82113B7Ch */ case    8:  		/* rlwinm R5, R11, 4, 0, 27 */
		/* 82113B7Ch case    8:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R5,regs.R11);
		/* 82113B7Ch case    8:*/		return 0x82113B80;
		  /* 82113B80h */ case    9:  		/* bl -534592 */
		/* 82113B80h case    9:*/		regs.LR = 0x82113B84; return 0x82091340;
		/* 82113B80h case    9:*/		return 0x82113B84;
		  /* 82113B84h */ case   10:  		/* lwz R11, <#[R31 + 40]> */
		/* 82113B84h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 82113B84h case   10:*/		return 0x82113B88;
		  /* 82113B88h */ case   11:  		/* li R4, 255 */
		/* 82113B88h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0xFF);
		/* 82113B88h case   11:*/		return 0x82113B8C;
		  /* 82113B8Ch */ case   12:  		/* lwz R3, <#[R31 + 24]> */
		/* 82113B8Ch case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 82113B8Ch case   12:*/		return 0x82113B90;
		  /* 82113B90h */ case   13:  		/* rlwinm R5, R11, 4, 0, 27 */
		/* 82113B90h case   13:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R5,regs.R11);
		/* 82113B90h case   13:*/		return 0x82113B94;
		  /* 82113B94h */ case   14:  		/* bl -534612 */
		/* 82113B94h case   14:*/		regs.LR = 0x82113B98; return 0x82091340;
		/* 82113B94h case   14:*/		return 0x82113B98;
		  /* 82113B98h */ case   15:  		/* lwz R11, <#[R26 + 8]> */
		/* 82113B98h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82113B98h case   15:*/		return 0x82113B9C;
		  /* 82113B9Ch */ case   16:  		/* li R10, 0 */
		/* 82113B9Ch case   16:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82113B9Ch case   16:*/		return 0x82113BA0;
		  /* 82113BA0h */ case   17:  		/* li R21, -1 */
		/* 82113BA0h case   17:*/		cpu::op::li<0>(regs,&regs.R21,0xFFFFFFFF);
		/* 82113BA0h case   17:*/		return 0x82113BA4;
		  /* 82113BA4h */ case   18:  		/* cmplwi CR6, R11, 0 */
		/* 82113BA4h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82113BA4h case   18:*/		return 0x82113BA8;
		  /* 82113BA8h */ case   19:  		/* bc 4, CR6_GT, 96 */
		/* 82113BA8h case   19:*/		if ( !regs.CR[6].gt ) { return 0x82113C08;  }
		/* 82113BA8h case   19:*/		return 0x82113BAC;
		  /* 82113BACh */ case   20:  		/* li R8, 0 */
		/* 82113BACh case   20:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82113BACh case   20:*/		return 0x82113BB0;
		  /* 82113BB0h */ case   21:  		/* lwz R11, <#[R26 + 20]> */
		/* 82113BB0h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82113BB0h case   21:*/		return 0x82113BB4;
		  /* 82113BB4h */ case   22:  		/* lwzx R11, <#[R8 + R11]> */
		/* 82113BB4h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82113BB4h case   22:*/		return 0x82113BB8;
		  /* 82113BB8h */ case   23:  		/* lwz R9, <#[R11 + 4]> */
		/* 82113BB8h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82113BB8h case   23:*/		return 0x82113BBC;
		  /* 82113BBCh */ case   24:  		/* stw R21, <#[R11 + 48]> */
		/* 82113BBCh case   24:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R11 + 0x00000030) );
		/* 82113BBCh case   24:*/		return 0x82113BC0;
		  /* 82113BC0h */ case   25:  		/* lwz R7, <#[R31]> */
		/* 82113BC0h case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000000) );
		/* 82113BC0h case   25:*/		return 0x82113BC4;
		  /* 82113BC4h */ case   26:  		/* cmplw CR6, R7, R9 */
		/* 82113BC4h case   26:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R9);
		/* 82113BC4h case   26:*/		return 0x82113BC8;
		  /* 82113BC8h */ case   27:  		/* bc 4, CR6_EQ, 44 */
		/* 82113BC8h case   27:*/		if ( !regs.CR[6].eq ) { return 0x82113BF4;  }
		/* 82113BC8h case   27:*/		return 0x82113BCC;
		  /* 82113BCCh */ case   28:  		/* lwz R9, <#[R11 + 56]> */
		/* 82113BCCh case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000038) );
		/* 82113BCCh case   28:*/		return 0x82113BD0;
		  /* 82113BD0h */ case   29:  		/* cmpwi CR6, R9, -1 */
		/* 82113BD0h case   29:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 82113BD0h case   29:*/		return 0x82113BD4;
		  /* 82113BD4h */ case   30:  		/* bc 4, CR6_EQ, 32 */
		/* 82113BD4h case   30:*/		if ( !regs.CR[6].eq ) { return 0x82113BF4;  }
		/* 82113BD4h case   30:*/		return 0x82113BD8;
		  /* 82113BD8h */ case   31:  		/* lwz R9, <#[R11 + 12]> */
		/* 82113BD8h case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82113BD8h case   31:*/		return 0x82113BDC;
		  /* 82113BDCh */ case   32:  		/* lwz R11, <#[R11 + 16]> */
		/* 82113BDCh case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 82113BDCh case   32:*/		return 0x82113BE0;
		  /* 82113BE0h */ case   33:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82113BE0h case   33:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82113BE0h case   33:*/		return 0x82113BE4;
		  /* 82113BE4h */ case   34:  		/* lwz R7, <#[R31 + 24]> */
		/* 82113BE4h case   34:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000018) );
		/* 82113BE4h case   34:*/		return 0x82113BE8;
		  /* 82113BE8h */ case   35:  		/* add R11, R9, R11 */
		/* 82113BE8h case   35:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82113BE8h case   35:*/		return 0x82113BEC;
		  /* 82113BECh */ case   36:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82113BECh case   36:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82113BECh case   36:*/		return 0x82113BF0;
		  /* 82113BF0h */ case   37:  		/* stwx R10, <#[R11 + R7]> */
		/* 82113BF0h case   37:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82113BF0h case   37:*/		return 0x82113BF4;
	}
	return 0x82113BF4;
} // Block from 82113B5Ch-82113BF4h (38 instructions)

//////////////////////////////////////////////////////
// Block at 82113BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113BF4);
		  /* 82113BF4h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 82113BF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82113BF4h case    0:*/		return 0x82113BF8;
		  /* 82113BF8h */ case    1:  		/* addi R10, R10, 1 */
		/* 82113BF8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82113BF8h case    1:*/		return 0x82113BFC;
		  /* 82113BFCh */ case    2:  		/* addi R8, R8, 4 */
		/* 82113BFCh case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82113BFCh case    2:*/		return 0x82113C00;
		  /* 82113C00h */ case    3:  		/* cmplw CR6, R10, R11 */
		/* 82113C00h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82113C00h case    3:*/		return 0x82113C04;
		  /* 82113C04h */ case    4:  		/* bc 12, CR6_LT, -84 */
		/* 82113C04h case    4:*/		if ( regs.CR[6].lt ) { return 0x82113BB0;  }
		/* 82113C04h case    4:*/		return 0x82113C08;
	}
	return 0x82113C08;
} // Block from 82113BF4h-82113C08h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82113C08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113C08);
		  /* 82113C08h */ case    0:  		/* lwz R11, <#[R31 + 40]> */
		/* 82113C08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 82113C08h case    0:*/		return 0x82113C0C;
		  /* 82113C0Ch */ case    1:  		/* li R4, 0 */
		/* 82113C0Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82113C0Ch case    1:*/		return 0x82113C10;
		  /* 82113C10h */ case    2:  		/* lwz R3, <#[R31 + 8]> */
		/* 82113C10h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 82113C10h case    2:*/		return 0x82113C14;
		  /* 82113C14h */ case    3:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82113C14h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82113C14h case    3:*/		return 0x82113C18;
		  /* 82113C18h */ case    4:  		/* bl -534744 */
		/* 82113C18h case    4:*/		regs.LR = 0x82113C1C; return 0x82091340;
		/* 82113C18h case    4:*/		return 0x82113C1C;
		  /* 82113C1Ch */ case    5:  		/* lwz R11, <#[R31 + 40]> */
		/* 82113C1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 82113C1Ch case    5:*/		return 0x82113C20;
		  /* 82113C20h */ case    6:  		/* li R6, 0 */
		/* 82113C20h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82113C20h case    6:*/		return 0x82113C24;
		  /* 82113C24h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82113C24h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82113C24h case    7:*/		return 0x82113C28;
		  /* 82113C28h */ case    8:  		/* bc 4, CR6_GT, 88 */
		/* 82113C28h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82113C80;  }
		/* 82113C28h case    8:*/		return 0x82113C2C;
		  /* 82113C2Ch */ case    9:  		/* li R8, 0 */
		/* 82113C2Ch case    9:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82113C2Ch case    9:*/		return 0x82113C30;
		  /* 82113C30h */ case   10:  		/* li R11, 4 */
		/* 82113C30h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 82113C30h case   10:*/		return 0x82113C34;
		  /* 82113C34h */ case   11:  		/* lwz R7, <#[R31 + 24]> */
		/* 82113C34h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000018) );
		/* 82113C34h case   11:*/		return 0x82113C38;
		  /* 82113C38h */ case   12:  		/* li R9, 0 */
		/* 82113C38h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82113C38h case   12:*/		return 0x82113C3C;
		  /* 82113C3Ch */ case   13:  		/* li R10, 0 */
		/* 82113C3Ch case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82113C3Ch case   13:*/		return 0x82113C40;
		  /* 82113C40h */ case   14:  		/* mtspr CTR, R11 */
		/* 82113C40h case   14:*/		regs.CTR = regs.R11;
		/* 82113C40h case   14:*/		return 0x82113C44;
		  /* 82113C44h */ case   15:  		/* add R11, R8, R10 */
		/* 82113C44h case   15:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R10);
		/* 82113C44h case   15:*/		return 0x82113C48;
		  /* 82113C48h */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82113C48h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82113C48h case   16:*/		return 0x82113C4C;
		  /* 82113C4Ch */ case   17:  		/* lwzx R11, <#[R11 + R7]> */
		/* 82113C4Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82113C4Ch case   17:*/		return 0x82113C50;
		  /* 82113C50h */ case   18:  		/* cmpwi CR6, R11, -1 */
		/* 82113C50h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82113C50h case   18:*/		return 0x82113C54;
		  /* 82113C54h */ case   19:  		/* bc 12, CR6_EQ, 8 */
		/* 82113C54h case   19:*/		if ( regs.CR[6].eq ) { return 0x82113C5C;  }
		/* 82113C54h case   19:*/		return 0x82113C58;
		  /* 82113C58h */ case   20:  		/* addi R9, R9, 1 */
		/* 82113C58h case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82113C58h case   20:*/		return 0x82113C5C;
	}
	return 0x82113C5C;
} // Block from 82113C08h-82113C5Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 82113C5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113C5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113C5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113C5C);
		  /* 82113C5Ch */ case    0:  		/* addi R10, R10, 1 */
		/* 82113C5Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82113C5Ch case    0:*/		return 0x82113C60;
		  /* 82113C60h */ case    1:  		/* bc 16, CR0_LT, -28 */
		/* 82113C60h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82113C44;  }
		/* 82113C60h case    1:*/		return 0x82113C64;
		  /* 82113C64h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 82113C64h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82113C64h case    2:*/		return 0x82113C68;
		  /* 82113C68h */ case    3:  		/* addi R6, R6, 1 */
		/* 82113C68h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82113C68h case    3:*/		return 0x82113C6C;
		  /* 82113C6Ch */ case    4:  		/* stwx R9, <#[R8 + R11]> */
		/* 82113C6Ch case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82113C6Ch case    4:*/		return 0x82113C70;
		  /* 82113C70h */ case    5:  		/* addi R8, R8, 4 */
		/* 82113C70h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82113C70h case    5:*/		return 0x82113C74;
		  /* 82113C74h */ case    6:  		/* lwz R11, <#[R31 + 40]> */
		/* 82113C74h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 82113C74h case    6:*/		return 0x82113C78;
		  /* 82113C78h */ case    7:  		/* cmplw CR6, R6, R11 */
		/* 82113C78h case    7:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 82113C78h case    7:*/		return 0x82113C7C;
		  /* 82113C7Ch */ case    8:  		/* bc 12, CR6_LT, -76 */
		/* 82113C7Ch case    8:*/		if ( regs.CR[6].lt ) { return 0x82113C30;  }
		/* 82113C7Ch case    8:*/		return 0x82113C80;
	}
	return 0x82113C80;
} // Block from 82113C5Ch-82113C80h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82113C80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113C80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113C80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113C80);
		  /* 82113C80h */ case    0:  		/* lwz R11, <#[R31 + 40]> */
		/* 82113C80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 82113C80h case    0:*/		return 0x82113C84;
		  /* 82113C84h */ case    1:  		/* li R4, 0 */
		/* 82113C84h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82113C84h case    1:*/		return 0x82113C88;
		  /* 82113C88h */ case    2:  		/* lwz R3, <#[R31 + 12]> */
		/* 82113C88h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 82113C88h case    2:*/		return 0x82113C8C;
		  /* 82113C8Ch */ case    3:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82113C8Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82113C8Ch case    3:*/		return 0x82113C90;
		  /* 82113C90h */ case    4:  		/* bl -534864 */
		/* 82113C90h case    4:*/		regs.LR = 0x82113C94; return 0x82091340;
		/* 82113C90h case    4:*/		return 0x82113C94;
		  /* 82113C94h */ case    5:  		/* lwz R11, <#[R26 + 12]> */
		/* 82113C94h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 82113C94h case    5:*/		return 0x82113C98;
		  /* 82113C98h */ case    6:  		/* li R28, 0 */
		/* 82113C98h case    6:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82113C98h case    6:*/		return 0x82113C9C;
		  /* 82113C9Ch */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82113C9Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82113C9Ch case    7:*/		return 0x82113CA0;
		  /* 82113CA0h */ case    8:  		/* bc 4, CR6_GT, 360 */
		/* 82113CA0h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82113E08;  }
		/* 82113CA0h case    8:*/		return 0x82113CA4;
		  /* 82113CA4h */ case    9:  		/* li R29, 0 */
		/* 82113CA4h case    9:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82113CA4h case    9:*/		return 0x82113CA8;
		  /* 82113CA8h */ case   10:  		/* lwz R11, <#[R26 + 24]> */
		/* 82113CA8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000018) );
		/* 82113CA8h case   10:*/		return 0x82113CAC;
		  /* 82113CACh */ case   11:  		/* lwzx R30, <#[R29 + R11]> */
		/* 82113CACh case   11:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 82113CACh case   11:*/		return 0x82113CB0;
		  /* 82113CB0h */ case   12:  		/* mr R3, R30 */
		/* 82113CB0h case   12:*/		regs.R3 = regs.R30;
		/* 82113CB0h case   12:*/		return 0x82113CB4;
		  /* 82113CB4h */ case   13:  		/* bl -97380 */
		/* 82113CB4h case   13:*/		regs.LR = 0x82113CB8; return 0x820FC050;
		/* 82113CB4h case   13:*/		return 0x82113CB8;
		  /* 82113CB8h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 82113CB8h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82113CB8h case   14:*/		return 0x82113CBC;
		  /* 82113CBCh */ case   15:  		/* bc 12, CR0_EQ, 312 */
		/* 82113CBCh case   15:*/		if ( regs.CR[0].eq ) { return 0x82113DF4;  }
		/* 82113CBCh case   15:*/		return 0x82113CC0;
		  /* 82113CC0h */ case   16:  		/* lwz R11, <#[R30 + 16]> */
		/* 82113CC0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82113CC0h case   16:*/		return 0x82113CC4;
		  /* 82113CC4h */ case   17:  		/* lwz R10, <#[R26 + 20]> */
		/* 82113CC4h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 82113CC4h case   17:*/		return 0x82113CC8;
		  /* 82113CC8h */ case   18:  		/* lwz R9, <#[R31]> */
		/* 82113CC8h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82113CC8h case   18:*/		return 0x82113CCC;
		  /* 82113CCCh */ case   19:  		/* lwz R11, <#[R11]> */
		/* 82113CCCh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82113CCCh case   19:*/		return 0x82113CD0;
		  /* 82113CD0h */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82113CD0h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82113CD0h case   20:*/		return 0x82113CD4;
		  /* 82113CD4h */ case   21:  		/* lwzx R7, <#[R11 + R10]> */
		/* 82113CD4h case   21:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82113CD4h case   21:*/		return 0x82113CD8;
		  /* 82113CD8h */ case   22:  		/* lwz R11, <#[R7 + 4]> */
		/* 82113CD8h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000004) );
		/* 82113CD8h case   22:*/		return 0x82113CDC;
		  /* 82113CDCh */ case   23:  		/* cmplw CR6, R9, R11 */
		/* 82113CDCh case   23:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82113CDCh case   23:*/		return 0x82113CE0;
		  /* 82113CE0h */ case   24:  		/* bc 4, CR6_EQ, 276 */
		/* 82113CE0h case   24:*/		if ( !regs.CR[6].eq ) { return 0x82113DF4;  }
		/* 82113CE0h case   24:*/		return 0x82113CE4;
		  /* 82113CE4h */ case   25:  		/* li R11, 2 */
		/* 82113CE4h case   25:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 82113CE4h case   25:*/		return 0x82113CE8;
		  /* 82113CE8h */ case   26:  		/* mtspr CTR, R11 */
		/* 82113CE8h case   26:*/		regs.CTR = regs.R11;
		/* 82113CE8h case   26:*/		return 0x82113CEC;
		  /* 82113CECh */ case   27:  		/* lwz R11, <#[R30 + 4]> */
		/* 82113CECh case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82113CECh case   27:*/		return 0x82113CF0;
		  /* 82113CF0h */ case   28:  		/* li R6, 0 */
		/* 82113CF0h case   28:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82113CF0h case   28:*/		return 0x82113CF4;
		  /* 82113CF4h */ case   29:  		/* cmplwi CR6, R11, 0 */
		/* 82113CF4h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82113CF4h case   29:*/		return 0x82113CF8;
		  /* 82113CF8h */ case   30:  		/* bc 4, CR6_GT, 248 */
		/* 82113CF8h case   30:*/		if ( !regs.CR[6].gt ) { return 0x82113DF0;  }
		/* 82113CF8h case   30:*/		return 0x82113CFC;
		  /* 82113CFCh */ case   31:  		/* lwz R11, <#[R30 + 8]> */
		/* 82113CFCh case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82113CFCh case   31:*/		return 0x82113D00;
		  /* 82113D00h */ case   32:  		/* rlwinm R10, R6, 2, 0, 29 */
		/* 82113D00h case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R6);
		/* 82113D00h case   32:*/		return 0x82113D04;
		  /* 82113D04h */ case   33:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82113D04h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82113D04h case   33:*/		return 0x82113D08;
		  /* 82113D08h */ case   34:  		/* cmpwi CR6, R11, -1 */
		/* 82113D08h case   34:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82113D08h case   34:*/		return 0x82113D0C;
		  /* 82113D0Ch */ case   35:  		/* bc 12, CR6_EQ, 32 */
		/* 82113D0Ch case   35:*/		if ( regs.CR[6].eq ) { return 0x82113D2C;  }
		/* 82113D0Ch case   35:*/		return 0x82113D10;
		  /* 82113D10h */ case   36:  		/* lwz R10, <#[R26 + 20]> */
		/* 82113D10h case   36:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 82113D10h case   36:*/		return 0x82113D14;
		  /* 82113D14h */ case   37:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 82113D14h case   37:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 82113D14h case   37:*/		return 0x82113D18;
		  /* 82113D18h */ case   38:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82113D18h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82113D18h case   38:*/		return 0x82113D1C;
		  /* 82113D1Ch */ case   39:  		/* lwz R10, <#[R10 + 56]> */
		/* 82113D1Ch case   39:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000038) );
		/* 82113D1Ch case   39:*/		return 0x82113D20;
		  /* 82113D20h */ case   40:  		/* cmpwi CR6, R10, -1 */
		/* 82113D20h case   40:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82113D20h case   40:*/		return 0x82113D24;
		  /* 82113D24h */ case   41:  		/* bc 12, CR6_EQ, 8 */
		/* 82113D24h case   41:*/		if ( regs.CR[6].eq ) { return 0x82113D2C;  }
		/* 82113D24h case   41:*/		return 0x82113D28;
		  /* 82113D28h */ case   42:  		/* mr R11, R10 */
		/* 82113D28h case   42:*/		regs.R11 = regs.R10;
		/* 82113D28h case   42:*/		return 0x82113D2C;
	}
	return 0x82113D2C;
} // Block from 82113C80h-82113D2Ch (43 instructions)

//////////////////////////////////////////////////////
// Block at 82113D2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113D2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113D2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113D2C);
		  /* 82113D2Ch */ case    0:  		/* lwz R10, <#[R26 + 20]> */
		/* 82113D2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 82113D2Ch case    0:*/		return 0x82113D30;
		  /* 82113D30h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82113D30h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82113D30h case    1:*/		return 0x82113D34;
		  /* 82113D34h */ case    2:  		/* lwz R9, <#[R26 + 16]> */
		/* 82113D34h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000010) );
		/* 82113D34h case    2:*/		return 0x82113D38;
		  /* 82113D38h */ case    3:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82113D38h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82113D38h case    3:*/		return 0x82113D3C;
		  /* 82113D3Ch */ case    4:  		/* lwz R8, <#[R11 + 4]> */
		/* 82113D3Ch case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82113D3Ch case    4:*/		return 0x82113D40;
		  /* 82113D40h */ case    5:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82113D40h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82113D40h case    5:*/		return 0x82113D44;
		  /* 82113D44h */ case    6:  		/* lwzx R9, <#[R8 + R9]> */
		/* 82113D44h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 82113D44h case    6:*/		return 0x82113D48;
		  /* 82113D48h */ case    7:  		/* lwz R9, <#[R9 + 4]> */
		/* 82113D48h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 82113D48h case    7:*/		return 0x82113D4C;
		  /* 82113D4Ch */ case    8:  		/* rlwinm. R9, R9, 0, 14, 14 */
		/* 82113D4Ch case    8:*/		cpu::op::rlwinm<1,0,14,14>(regs,&regs.R9,regs.R9);
		/* 82113D4Ch case    8:*/		return 0x82113D50;
		  /* 82113D50h */ case    9:  		/* bc 12, CR0_EQ, 36 */
		/* 82113D50h case    9:*/		if ( regs.CR[0].eq ) { return 0x82113D74;  }
		/* 82113D50h case    9:*/		return 0x82113D54;
		  /* 82113D54h */ case   10:  		/* lwz R11, <#[R11 + 72]> */
		/* 82113D54h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 82113D54h case   10:*/		return 0x82113D58;
		  /* 82113D58h */ case   11:  		/* lwz R9, <#[R26 + 24]> */
		/* 82113D58h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000018) );
		/* 82113D58h case   11:*/		return 0x82113D5C;
		  /* 82113D5Ch */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82113D5Ch case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82113D5Ch case   12:*/		return 0x82113D60;
		  /* 82113D60h */ case   13:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82113D60h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82113D60h case   13:*/		return 0x82113D64;
		  /* 82113D64h */ case   14:  		/* lwz R11, <#[R11 + 8]> */
		/* 82113D64h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82113D64h case   14:*/		return 0x82113D68;
		  /* 82113D68h */ case   15:  		/* lwz R11, <#[R11]> */
		/* 82113D68h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82113D68h case   15:*/		return 0x82113D6C;
		  /* 82113D6Ch */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82113D6Ch case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82113D6Ch case   16:*/		return 0x82113D70;
		  /* 82113D70h */ case   17:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82113D70h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82113D70h case   17:*/		return 0x82113D74;
	}
	return 0x82113D74;
} // Block from 82113D2Ch-82113D74h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82113D74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113D74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113D74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113D74);
		  /* 82113D74h */ case    0:  		/* lwz R10, <#[R31]> */
		/* 82113D74h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82113D74h case    0:*/		return 0x82113D78;
		  /* 82113D78h */ case    1:  		/* lwz R9, <#[R11 + 4]> */
		/* 82113D78h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82113D78h case    1:*/		return 0x82113D7C;
		  /* 82113D7Ch */ case    2:  		/* cmplw CR6, R10, R9 */
		/* 82113D7Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82113D7Ch case    2:*/		return 0x82113D80;
		  /* 82113D80h */ case    3:  		/* bc 4, CR6_EQ, 92 */
		/* 82113D80h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82113DDC;  }
		/* 82113D80h case    3:*/		return 0x82113D84;
		  /* 82113D84h */ case    4:  		/* lwz R10, <#[R11 + 12]> */
		/* 82113D84h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82113D84h case    4:*/		return 0x82113D88;
		  /* 82113D88h */ case    5:  		/* lwz R5, <#[R7 + 12]> */
		/* 82113D88h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R7 + 0x0000000C) );
		/* 82113D88h case    5:*/		return 0x82113D8C;
		  /* 82113D8Ch */ case    6:  		/* rlwinm R8, R10, 2, 0, 29 */
		/* 82113D8Ch case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R10);
		/* 82113D8Ch case    6:*/		return 0x82113D90;
		  /* 82113D90h */ case    7:  		/* lwz R9, <#[R31 + 12]> */
		/* 82113D90h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 82113D90h case    7:*/		return 0x82113D94;
		  /* 82113D94h */ case    8:  		/* lwz R10, <#[R31 + 8]> */
		/* 82113D94h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82113D94h case    8:*/		return 0x82113D98;
		  /* 82113D98h */ case    9:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 82113D98h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 82113D98h case    9:*/		return 0x82113D9C;
		  /* 82113D9Ch */ case   10:  		/* lwzx R4, <#[R8 + R9]> */
		/* 82113D9Ch case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 82113D9Ch case   10:*/		return 0x82113DA0;
		  /* 82113DA0h */ case   11:  		/* lwzx R10, <#[R5 + R10]> */
		/* 82113DA0h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + regs.R10 + 0x00000000) );
		/* 82113DA0h case   11:*/		return 0x82113DA4;
		  /* 82113DA4h */ case   12:  		/* cmplw CR6, R4, R10 */
		/* 82113DA4h case   12:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 82113DA4h case   12:*/		return 0x82113DA8;
		  /* 82113DA8h */ case   13:  		/* bc 4, CR6_LT, 8 */
		/* 82113DA8h case   13:*/		if ( !regs.CR[6].lt ) { return 0x82113DB0;  }
		/* 82113DA8h case   13:*/		return 0x82113DAC;
		  /* 82113DACh */ case   14:  		/* stwx R10, <#[R8 + R9]> */
		/* 82113DACh case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 82113DACh case   14:*/		return 0x82113DB0;
	}
	return 0x82113DB0;
} // Block from 82113D74h-82113DB0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82113DB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113DB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113DB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113DB0);
		  /* 82113DB0h */ case    0:  		/* lwz R11, <#[R11 + 12]> */
		/* 82113DB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 82113DB0h case    0:*/		return 0x82113DB4;
		  /* 82113DB4h */ case    1:  		/* lwz R9, <#[R7 + 12]> */
		/* 82113DB4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x0000000C) );
		/* 82113DB4h case    1:*/		return 0x82113DB8;
		  /* 82113DB8h */ case    2:  		/* lwz R10, <#[R31 + 12]> */
		/* 82113DB8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 82113DB8h case    2:*/		return 0x82113DBC;
		  /* 82113DBCh */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82113DBCh case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82113DBCh case    3:*/		return 0x82113DC0;
		  /* 82113DC0h */ case    4:  		/* lwz R8, <#[R31 + 8]> */
		/* 82113DC0h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 82113DC0h case    4:*/		return 0x82113DC4;
		  /* 82113DC4h */ case    5:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82113DC4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82113DC4h case    5:*/		return 0x82113DC8;
		  /* 82113DC8h */ case    6:  		/* lwzx R5, <#[R9 + R10]> */
		/* 82113DC8h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82113DC8h case    6:*/		return 0x82113DCC;
		  /* 82113DCCh */ case    7:  		/* lwzx R11, <#[R11 + R8]> */
		/* 82113DCCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82113DCCh case    7:*/		return 0x82113DD0;
		  /* 82113DD0h */ case    8:  		/* cmplw CR6, R5, R11 */
		/* 82113DD0h case    8:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 82113DD0h case    8:*/		return 0x82113DD4;
		  /* 82113DD4h */ case    9:  		/* bc 4, CR6_LT, 8 */
		/* 82113DD4h case    9:*/		if ( !regs.CR[6].lt ) { return 0x82113DDC;  }
		/* 82113DD4h case    9:*/		return 0x82113DD8;
		  /* 82113DD8h */ case   10:  		/* stwx R11, <#[R9 + R10]> */
		/* 82113DD8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82113DD8h case   10:*/		return 0x82113DDC;
	}
	return 0x82113DDC;
} // Block from 82113DB0h-82113DDCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 82113DDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113DDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113DDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113DDC);
		  /* 82113DDCh */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 82113DDCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82113DDCh case    0:*/		return 0x82113DE0;
		  /* 82113DE0h */ case    1:  		/* lwz R10, <#[R30 + 4]> */
		/* 82113DE0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 82113DE0h case    1:*/		return 0x82113DE4;
		  /* 82113DE4h */ case    2:  		/* add R6, R6, R11 */
		/* 82113DE4h case    2:*/		cpu::op::add<0>(regs,&regs.R6,regs.R6,regs.R11);
		/* 82113DE4h case    2:*/		return 0x82113DE8;
		  /* 82113DE8h */ case    3:  		/* cmplw CR6, R6, R10 */
		/* 82113DE8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 82113DE8h case    3:*/		return 0x82113DEC;
		  /* 82113DECh */ case    4:  		/* bc 12, CR6_LT, -240 */
		/* 82113DECh case    4:*/		if ( regs.CR[6].lt ) { return 0x82113CFC;  }
		/* 82113DECh case    4:*/		return 0x82113DF0;
	}
	return 0x82113DF0;
} // Block from 82113DDCh-82113DF0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82113DF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113DF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113DF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113DF0);
		  /* 82113DF0h */ case    0:  		/* bc 16, CR0_LT, -260 */
		/* 82113DF0h case    0:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82113CEC;  }
		/* 82113DF0h case    0:*/		return 0x82113DF4;
	}
	return 0x82113DF4;
} // Block from 82113DF0h-82113DF4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82113DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113DF4);
		  /* 82113DF4h */ case    0:  		/* lwz R11, <#[R26 + 12]> */
		/* 82113DF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 82113DF4h case    0:*/		return 0x82113DF8;
		  /* 82113DF8h */ case    1:  		/* addi R28, R28, 1 */
		/* 82113DF8h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82113DF8h case    1:*/		return 0x82113DFC;
		  /* 82113DFCh */ case    2:  		/* addi R29, R29, 4 */
		/* 82113DFCh case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82113DFCh case    2:*/		return 0x82113E00;
		  /* 82113E00h */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 82113E00h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 82113E00h case    3:*/		return 0x82113E04;
		  /* 82113E04h */ case    4:  		/* bc 12, CR6_LT, -348 */
		/* 82113E04h case    4:*/		if ( regs.CR[6].lt ) { return 0x82113CA8;  }
		/* 82113E04h case    4:*/		return 0x82113E08;
	}
	return 0x82113E08;
} // Block from 82113DF4h-82113E08h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82113E08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113E08);
		  /* 82113E08h */ case    0:  		/* lwz R11, <#[R31 + 72]> */
		/* 82113E08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 82113E08h case    0:*/		return 0x82113E0C;
		  /* 82113E0Ch */ case    1:  		/* li R4, 0 */
		/* 82113E0Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82113E0Ch case    1:*/		return 0x82113E10;
		  /* 82113E10h */ case    2:  		/* lwz R3, <#[R31 + 76]> */
		/* 82113E10h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000004C) );
		/* 82113E10h case    2:*/		return 0x82113E14;
		  /* 82113E14h */ case    3:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82113E14h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82113E14h case    3:*/		return 0x82113E18;
		  /* 82113E18h */ case    4:  		/* bl -535256 */
		/* 82113E18h case    4:*/		regs.LR = 0x82113E1C; return 0x82091340;
		/* 82113E18h case    4:*/		return 0x82113E1C;
		  /* 82113E1Ch */ case    5:  		/* lwz R11, <#[R26 + 12]> */
		/* 82113E1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 82113E1Ch case    5:*/		return 0x82113E20;
		  /* 82113E20h */ case    6:  		/* li R27, 0 */
		/* 82113E20h case    6:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82113E20h case    6:*/		return 0x82113E24;
		  /* 82113E24h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82113E24h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82113E24h case    7:*/		return 0x82113E28;
		  /* 82113E28h */ case    8:  		/* bc 4, CR6_GT, 280 */
		/* 82113E28h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82113F40;  }
		/* 82113E28h case    8:*/		return 0x82113E2C;
		  /* 82113E2Ch */ case    9:  		/* li R25, 0 */
		/* 82113E2Ch case    9:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82113E2Ch case    9:*/		return 0x82113E30;
		  /* 82113E30h */ case   10:  		/* lwz R11, <#[R26 + 24]> */
		/* 82113E30h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000018) );
		/* 82113E30h case   10:*/		return 0x82113E34;
		  /* 82113E34h */ case   11:  		/* lwzx R30, <#[R25 + R11]> */
		/* 82113E34h case   11:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R25 + regs.R11 + 0x00000000) );
		/* 82113E34h case   11:*/		return 0x82113E38;
		  /* 82113E38h */ case   12:  		/* lwz R11, <#[R30]> */
		/* 82113E38h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82113E38h case   12:*/		return 0x82113E3C;
		  /* 82113E3Ch */ case   13:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 82113E3Ch case   13:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82113E3Ch case   13:*/		return 0x82113E40;
		  /* 82113E40h */ case   14:  		/* bc 12, CR0_EQ, 236 */
		/* 82113E40h case   14:*/		if ( regs.CR[0].eq ) { return 0x82113F2C;  }
		/* 82113E40h case   14:*/		return 0x82113E44;
		  /* 82113E44h */ case   15:  		/* lwz R11, <#[R30 + 12]> */
		/* 82113E44h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82113E44h case   15:*/		return 0x82113E48;
		  /* 82113E48h */ case   16:  		/* li R28, 0 */
		/* 82113E48h case   16:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82113E48h case   16:*/		return 0x82113E4C;
		  /* 82113E4Ch */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 82113E4Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82113E4Ch case   17:*/		return 0x82113E50;
		  /* 82113E50h */ case   18:  		/* bc 4, CR6_GT, 76 */
		/* 82113E50h case   18:*/		if ( !regs.CR[6].gt ) { return 0x82113E9C;  }
		/* 82113E50h case   18:*/		return 0x82113E54;
		  /* 82113E54h */ case   19:  		/* li R29, 0 */
		/* 82113E54h case   19:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82113E54h case   19:*/		return 0x82113E58;
		  /* 82113E58h */ case   20:  		/* lwz R11, <#[R30 + 16]> */
		/* 82113E58h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82113E58h case   20:*/		return 0x82113E5C;
		  /* 82113E5Ch */ case   21:  		/* lwz R10, <#[R26 + 20]> */
		/* 82113E5Ch case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 82113E5Ch case   21:*/		return 0x82113E60;
		  /* 82113E60h */ case   22:  		/* lwzx R11, <#[R29 + R11]> */
		/* 82113E60h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 82113E60h case   22:*/		return 0x82113E64;
		  /* 82113E64h */ case   23:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82113E64h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82113E64h case   23:*/		return 0x82113E68;
		  /* 82113E68h */ case   24:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82113E68h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82113E68h case   24:*/		return 0x82113E6C;
		  /* 82113E6Ch */ case   25:  		/* lwz R5, <#[R11 + 20]> */
		/* 82113E6Ch case   25:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000014) );
		/* 82113E6Ch case   25:*/		return 0x82113E70;
		  /* 82113E70h */ case   26:  		/* cmpwi CR6, R5, -1 */
		/* 82113E70h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R5,0xFFFFFFFF);
		/* 82113E70h case   26:*/		return 0x82113E74;
		  /* 82113E74h */ case   27:  		/* bc 12, CR6_EQ, 20 */
		/* 82113E74h case   27:*/		if ( regs.CR[6].eq ) { return 0x82113E88;  }
		/* 82113E74h case   27:*/		return 0x82113E78;
		  /* 82113E78h */ case   28:  		/* mr R6, R27 */
		/* 82113E78h case   28:*/		regs.R6 = regs.R27;
		/* 82113E78h case   28:*/		return 0x82113E7C;
		  /* 82113E7Ch */ case   29:  		/* mr R4, R31 */
		/* 82113E7Ch case   29:*/		regs.R4 = regs.R31;
		/* 82113E7Ch case   29:*/		return 0x82113E80;
		  /* 82113E80h */ case   30:  		/* mr R3, R26 */
		/* 82113E80h case   30:*/		regs.R3 = regs.R26;
		/* 82113E80h case   30:*/		return 0x82113E84;
		  /* 82113E84h */ case   31:  		/* bl -58860 */
		/* 82113E84h case   31:*/		regs.LR = 0x82113E88; return 0x82105898;
		/* 82113E84h case   31:*/		return 0x82113E88;
	}
	return 0x82113E88;
} // Block from 82113E08h-82113E88h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82113E88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113E88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113E88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113E88);
		  /* 82113E88h */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 82113E88h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82113E88h case    0:*/		return 0x82113E8C;
		  /* 82113E8Ch */ case    1:  		/* addi R28, R28, 1 */
		/* 82113E8Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82113E8Ch case    1:*/		return 0x82113E90;
		  /* 82113E90h */ case    2:  		/* addi R29, R29, 4 */
		/* 82113E90h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82113E90h case    2:*/		return 0x82113E94;
		  /* 82113E94h */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 82113E94h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 82113E94h case    3:*/		return 0x82113E98;
		  /* 82113E98h */ case    4:  		/* bc 12, CR6_LT, -64 */
		/* 82113E98h case    4:*/		if ( regs.CR[6].lt ) { return 0x82113E58;  }
		/* 82113E98h case    4:*/		return 0x82113E9C;
	}
	return 0x82113E9C;
} // Block from 82113E88h-82113E9Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82113E9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113E9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113E9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113E9C);
		  /* 82113E9Ch */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 82113E9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82113E9Ch case    0:*/		return 0x82113EA0;
		  /* 82113EA0h */ case    1:  		/* li R28, 0 */
		/* 82113EA0h case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82113EA0h case    1:*/		return 0x82113EA4;
		  /* 82113EA4h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82113EA4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82113EA4h case    2:*/		return 0x82113EA8;
		  /* 82113EA8h */ case    3:  		/* bc 4, CR6_GT, 52 */
		/* 82113EA8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82113EDC;  }
		/* 82113EA8h case    3:*/		return 0x82113EAC;
		  /* 82113EACh */ case    4:  		/* li R29, 0 */
		/* 82113EACh case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82113EACh case    4:*/		return 0x82113EB0;
		  /* 82113EB0h */ case    5:  		/* lwz R11, <#[R30 + 8]> */
		/* 82113EB0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82113EB0h case    5:*/		return 0x82113EB4;
		  /* 82113EB4h */ case    6:  		/* mr R6, R27 */
		/* 82113EB4h case    6:*/		regs.R6 = regs.R27;
		/* 82113EB4h case    6:*/		return 0x82113EB8;
		  /* 82113EB8h */ case    7:  		/* mr R4, R31 */
		/* 82113EB8h case    7:*/		regs.R4 = regs.R31;
		/* 82113EB8h case    7:*/		return 0x82113EBC;
		  /* 82113EBCh */ case    8:  		/* mr R3, R26 */
		/* 82113EBCh case    8:*/		regs.R3 = regs.R26;
		/* 82113EBCh case    8:*/		return 0x82113EC0;
		  /* 82113EC0h */ case    9:  		/* lwzx R5, <#[R29 + R11]> */
		/* 82113EC0h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 82113EC0h case    9:*/		return 0x82113EC4;
		  /* 82113EC4h */ case   10:  		/* bl -58924 */
		/* 82113EC4h case   10:*/		regs.LR = 0x82113EC8; return 0x82105898;
		/* 82113EC4h case   10:*/		return 0x82113EC8;
		  /* 82113EC8h */ case   11:  		/* lwz R11, <#[R30 + 4]> */
		/* 82113EC8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82113EC8h case   11:*/		return 0x82113ECC;
		  /* 82113ECCh */ case   12:  		/* addi R28, R28, 1 */
		/* 82113ECCh case   12:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82113ECCh case   12:*/		return 0x82113ED0;
		  /* 82113ED0h */ case   13:  		/* addi R29, R29, 4 */
		/* 82113ED0h case   13:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82113ED0h case   13:*/		return 0x82113ED4;
		  /* 82113ED4h */ case   14:  		/* cmplw CR6, R28, R11 */
		/* 82113ED4h case   14:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 82113ED4h case   14:*/		return 0x82113ED8;
		  /* 82113ED8h */ case   15:  		/* bc 12, CR6_LT, -40 */
		/* 82113ED8h case   15:*/		if ( regs.CR[6].lt ) { return 0x82113EB0;  }
		/* 82113ED8h case   15:*/		return 0x82113EDC;
	}
	return 0x82113EDC;
} // Block from 82113E9Ch-82113EDCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 82113EDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113EDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113EDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113EDC);
		  /* 82113EDCh */ case    0:  		/* mr R3, R30 */
		/* 82113EDCh case    0:*/		regs.R3 = regs.R30;
		/* 82113EDCh case    0:*/		return 0x82113EE0;
		  /* 82113EE0h */ case    1:  		/* bl -98160 */
		/* 82113EE0h case    1:*/		regs.LR = 0x82113EE4; return 0x820FBF70;
		/* 82113EE0h case    1:*/		return 0x82113EE4;
		  /* 82113EE4h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 82113EE4h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82113EE4h case    2:*/		return 0x82113EE8;
		  /* 82113EE8h */ case    3:  		/* bc 12, CR0_EQ, 68 */
		/* 82113EE8h case    3:*/		if ( regs.CR[0].eq ) { return 0x82113F2C;  }
		/* 82113EE8h case    3:*/		return 0x82113EEC;
		  /* 82113EECh */ case    4:  		/* lwz R11, <#[R30 + 12]> */
		/* 82113EECh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82113EECh case    4:*/		return 0x82113EF0;
		  /* 82113EF0h */ case    5:  		/* li R28, 0 */
		/* 82113EF0h case    5:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82113EF0h case    5:*/		return 0x82113EF4;
		  /* 82113EF4h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82113EF4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82113EF4h case    6:*/		return 0x82113EF8;
		  /* 82113EF8h */ case    7:  		/* bc 4, CR6_GT, 52 */
		/* 82113EF8h case    7:*/		if ( !regs.CR[6].gt ) { return 0x82113F2C;  }
		/* 82113EF8h case    7:*/		return 0x82113EFC;
		  /* 82113EFCh */ case    8:  		/* li R29, 0 */
		/* 82113EFCh case    8:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82113EFCh case    8:*/		return 0x82113F00;
		  /* 82113F00h */ case    9:  		/* lwz R11, <#[R30 + 16]> */
		/* 82113F00h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82113F00h case    9:*/		return 0x82113F04;
		  /* 82113F04h */ case   10:  		/* mr R6, R27 */
		/* 82113F04h case   10:*/		regs.R6 = regs.R27;
		/* 82113F04h case   10:*/		return 0x82113F08;
		  /* 82113F08h */ case   11:  		/* mr R4, R31 */
		/* 82113F08h case   11:*/		regs.R4 = regs.R31;
		/* 82113F08h case   11:*/		return 0x82113F0C;
		  /* 82113F0Ch */ case   12:  		/* mr R3, R26 */
		/* 82113F0Ch case   12:*/		regs.R3 = regs.R26;
		/* 82113F0Ch case   12:*/		return 0x82113F10;
		  /* 82113F10h */ case   13:  		/* lwzx R5, <#[R29 + R11]> */
		/* 82113F10h case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 82113F10h case   13:*/		return 0x82113F14;
		  /* 82113F14h */ case   14:  		/* bl -59004 */
		/* 82113F14h case   14:*/		regs.LR = 0x82113F18; return 0x82105898;
		/* 82113F14h case   14:*/		return 0x82113F18;
		  /* 82113F18h */ case   15:  		/* lwz R11, <#[R30 + 12]> */
		/* 82113F18h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82113F18h case   15:*/		return 0x82113F1C;
		  /* 82113F1Ch */ case   16:  		/* addi R28, R28, 1 */
		/* 82113F1Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82113F1Ch case   16:*/		return 0x82113F20;
		  /* 82113F20h */ case   17:  		/* addi R29, R29, 4 */
		/* 82113F20h case   17:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82113F20h case   17:*/		return 0x82113F24;
		  /* 82113F24h */ case   18:  		/* cmplw CR6, R28, R11 */
		/* 82113F24h case   18:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 82113F24h case   18:*/		return 0x82113F28;
		  /* 82113F28h */ case   19:  		/* bc 12, CR6_LT, -40 */
		/* 82113F28h case   19:*/		if ( regs.CR[6].lt ) { return 0x82113F00;  }
		/* 82113F28h case   19:*/		return 0x82113F2C;
	}
	return 0x82113F2C;
} // Block from 82113EDCh-82113F2Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 82113F2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113F2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113F2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113F2C);
		  /* 82113F2Ch */ case    0:  		/* lwz R11, <#[R26 + 12]> */
		/* 82113F2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 82113F2Ch case    0:*/		return 0x82113F30;
		  /* 82113F30h */ case    1:  		/* addi R27, R27, 1 */
		/* 82113F30h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82113F30h case    1:*/		return 0x82113F34;
		  /* 82113F34h */ case    2:  		/* addi R25, R25, 4 */
		/* 82113F34h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 82113F34h case    2:*/		return 0x82113F38;
		  /* 82113F38h */ case    3:  		/* cmplw CR6, R27, R11 */
		/* 82113F38h case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 82113F38h case    3:*/		return 0x82113F3C;
		  /* 82113F3Ch */ case    4:  		/* bc 12, CR6_LT, -268 */
		/* 82113F3Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x82113E30;  }
		/* 82113F3Ch case    4:*/		return 0x82113F40;
	}
	return 0x82113F40;
} // Block from 82113F2Ch-82113F40h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82113F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113F40);
		  /* 82113F40h */ case    0:  		/* lwz R11, <#[R31 + 72]> */
		/* 82113F40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 82113F40h case    0:*/		return 0x82113F44;
		  /* 82113F44h */ case    1:  		/* li R27, 0 */
		/* 82113F44h case    1:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82113F44h case    1:*/		return 0x82113F48;
		  /* 82113F48h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82113F48h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82113F48h case    2:*/		return 0x82113F4C;
		  /* 82113F4Ch */ case    3:  		/* bc 4, CR6_GT, 236 */
		/* 82113F4Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x82114038;  }
		/* 82113F4Ch case    3:*/		return 0x82113F50;
		  /* 82113F50h */ case    4:  		/* li R28, 0 */
		/* 82113F50h case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82113F50h case    4:*/		return 0x82113F54;
		  /* 82113F54h */ case    5:  		/* lwz R11, <#[R31 + 80]> */
		/* 82113F54h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 82113F54h case    5:*/		return 0x82113F58;
		  /* 82113F58h */ case    6:  		/* lwz R9, <#[R31 + 76]> */
		/* 82113F58h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000004C) );
		/* 82113F58h case    6:*/		return 0x82113F5C;
		  /* 82113F5Ch */ case    7:  		/* lwz R10, <#[R31 + 84]> */
		/* 82113F5Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000054) );
		/* 82113F5Ch case    7:*/		return 0x82113F60;
		  /* 82113F60h */ case    8:  		/* lwzx R11, <#[R11 + R28]> */
		/* 82113F60h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 82113F60h case    8:*/		return 0x82113F64;
		  /* 82113F64h */ case    9:  		/* lwzx R30, <#[R9 + R28]> */
		/* 82113F64h case    9:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + regs.R28 + 0x00000000) );
		/* 82113F64h case    9:*/		return 0x82113F68;
		  /* 82113F68h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82113F68h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82113F68h case   10:*/		return 0x82113F6C;
		  /* 82113F6Ch */ case   11:  		/* cmplwi CR6, R30, 1 */
		/* 82113F6Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000001);
		/* 82113F6Ch case   11:*/		return 0x82113F70;
		  /* 82113F70h */ case   12:  		/* add R29, R11, R10 */
		/* 82113F70h case   12:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R10);
		/* 82113F70h case   12:*/		return 0x82113F74;
		  /* 82113F74h */ case   13:  		/* bc 4, CR6_GT, 176 */
		/* 82113F74h case   13:*/		if ( !regs.CR[6].gt ) { return 0x82114024;  }
		/* 82113F74h case   13:*/		return 0x82113F78;
		  /* 82113F78h */ case   14:  		/* lis R11, -32240 */
		/* 82113F78h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8210);
		/* 82113F78h case   14:*/		return 0x82113F7C;
		  /* 82113F7Ch */ case   15:  		/* mr R6, R26 */
		/* 82113F7Ch case   15:*/		regs.R6 = regs.R26;
		/* 82113F7Ch case   15:*/		return 0x82113F80;
		  /* 82113F80h */ case   16:  		/* mr R5, R30 */
		/* 82113F80h case   16:*/		regs.R5 = regs.R30;
		/* 82113F80h case   16:*/		return 0x82113F84;
		  /* 82113F84h */ case   17:  		/* mr R4, R29 */
		/* 82113F84h case   17:*/		regs.R4 = regs.R29;
		/* 82113F84h case   17:*/		return 0x82113F88;
		  /* 82113F88h */ case   18:  		/* addi R3, R11, -8728 */
		/* 82113F88h case   18:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFDDE8);
		/* 82113F88h case   18:*/		return 0x82113F8C;
		  /* 82113F8Ch */ case   19:  		/* bl -90348 */
		/* 82113F8Ch case   19:*/		regs.LR = 0x82113F90; return 0x820FDEA0;
		/* 82113F8Ch case   19:*/		return 0x82113F90;
		  /* 82113F90h */ case   20:  		/* li R5, 1 */
		/* 82113F90h case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82113F90h case   20:*/		return 0x82113F94;
		  /* 82113F94h */ case   21:  		/* cmplwi CR6, R30, 1 */
		/* 82113F94h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000001);
		/* 82113F94h case   21:*/		return 0x82113F98;
		  /* 82113F98h */ case   22:  		/* bc 4, CR6_GT, 112 */
		/* 82113F98h case   22:*/		if ( !regs.CR[6].gt ) { return 0x82114008;  }
		/* 82113F98h case   22:*/		return 0x82113F9C;
		  /* 82113F9Ch */ case   23:  		/* addi R10, R30, -1 */
		/* 82113F9Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0xFFFFFFFF);
		/* 82113F9Ch case   23:*/		return 0x82113FA0;
		  /* 82113FA0h */ case   24:  		/* addi R11, R29, 4 */
		/* 82113FA0h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x4);
		/* 82113FA0h case   24:*/		return 0x82113FA4;
		  /* 82113FA4h */ case   25:  		/* addi R6, R11, -4 */
		/* 82113FA4h case   25:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFFFC);
		/* 82113FA4h case   25:*/		return 0x82113FA8;
		  /* 82113FA8h */ case   26:  		/* mr R4, R11 */
		/* 82113FA8h case   26:*/		regs.R4 = regs.R11;
		/* 82113FA8h case   26:*/		return 0x82113FAC;
		  /* 82113FACh */ case   27:  		/* mtspr CTR, R10 */
		/* 82113FACh case   27:*/		regs.CTR = regs.R10;
		/* 82113FACh case   27:*/		return 0x82113FB0;
		  /* 82113FB0h */ case   28:  		/* lwz R11, <#[R26 + 188]> */
		/* 82113FB0h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x000000BC) );
		/* 82113FB0h case   28:*/		return 0x82113FB4;
		  /* 82113FB4h */ case   29:  		/* lwz R10, <#[R6]> */
		/* 82113FB4h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000000) );
		/* 82113FB4h case   29:*/		return 0x82113FB8;
		  /* 82113FB8h */ case   30:  		/* lwz R7, <#[R4]> */
		/* 82113FB8h case   30:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000000) );
		/* 82113FB8h case   30:*/		return 0x82113FBC;
		  /* 82113FBCh */ case   31:  		/* mulli R10, R10, 12 */
		/* 82113FBCh case   31:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0xC);
		/* 82113FBCh case   31:*/		return 0x82113FC0;
		  /* 82113FC0h */ case   32:  		/* lwz R11, <#[R11 + 88]> */
		/* 82113FC0h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000058) );
		/* 82113FC0h case   32:*/		return 0x82113FC4;
		  /* 82113FC4h */ case   33:  		/* mulli R9, R7, 12 */
		/* 82113FC4h case   33:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R7,0xC);
		/* 82113FC4h case   33:*/		return 0x82113FC8;
		  /* 82113FC8h */ case   34:  		/* add R10, R10, R11 */
		/* 82113FC8h case   34:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82113FC8h case   34:*/		return 0x82113FCC;
		  /* 82113FCCh */ case   35:  		/* add R11, R9, R11 */
		/* 82113FCCh case   35:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82113FCCh case   35:*/		return 0x82113FD0;
		  /* 82113FD0h */ case   36:  		/* lwz R9, <#[R10 + 4]> */
		/* 82113FD0h case   36:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 82113FD0h case   36:*/		return 0x82113FD4;
		  /* 82113FD4h */ case   37:  		/* lwz R8, <#[R11 + 4]> */
		/* 82113FD4h case   37:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82113FD4h case   37:*/		return 0x82113FD8;
		  /* 82113FD8h */ case   38:  		/* cmplw CR6, R9, R8 */
		/* 82113FD8h case   38:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 82113FD8h case   38:*/		return 0x82113FDC;
		  /* 82113FDCh */ case   39:  		/* bc 12, CR6_LT, 28 */
		/* 82113FDCh case   39:*/		if ( regs.CR[6].lt ) { return 0x82113FF8;  }
		/* 82113FDCh case   39:*/		return 0x82113FE0;
		  /* 82113FE0h */ case   40:  		/* bc 12, CR6_GT, 24 */
		/* 82113FE0h case   40:*/		if ( regs.CR[6].gt ) { return 0x82113FF8;  }
		/* 82113FE0h case   40:*/		return 0x82113FE4;
		  /* 82113FE4h */ case   41:  		/* lwz R10, <#[R10 + 8]> */
		/* 82113FE4h case   41:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82113FE4h case   41:*/		return 0x82113FE8;
		  /* 82113FE8h */ case   42:  		/* lwz R11, <#[R11 + 8]> */
		/* 82113FE8h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82113FE8h case   42:*/		return 0x82113FEC;
		  /* 82113FECh */ case   43:  		/* cmpw CR6, R10, R11 */
		/* 82113FECh case   43:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 82113FECh case   43:*/		return 0x82113FF0;
		  /* 82113FF0h */ case   44:  		/* bc 12, CR6_LT, 8 */
		/* 82113FF0h case   44:*/		if ( regs.CR[6].lt ) { return 0x82113FF8;  }
		/* 82113FF0h case   44:*/		return 0x82113FF4;
		  /* 82113FF4h */ case   45:  		/* bc 4, CR6_GT, 12 */
		/* 82113FF4h case   45:*/		if ( !regs.CR[6].gt ) { return 0x82114000;  }
		/* 82113FF4h case   45:*/		return 0x82113FF8;
	}
	return 0x82113FF8;
} // Block from 82113F40h-82113FF8h (46 instructions)

//////////////////////////////////////////////////////
// Block at 82113FF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82113FF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82113FF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82113FF8);
		  /* 82113FF8h */ case    0:  		/* stwu R7, <#[R6 + 4]> */
		/* 82113FF8h case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + 0x00000004) );
		regs.R6 = (uint32)(regs.R6 + 0x00000004);
		/* 82113FF8h case    0:*/		return 0x82113FFC;
		  /* 82113FFCh */ case    1:  		/* addi R5, R5, 1 */
		/* 82113FFCh case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 82113FFCh case    1:*/		return 0x82114000;
	}
	return 0x82114000;
} // Block from 82113FF8h-82114000h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82114000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114000);
		  /* 82114000h */ case    0:  		/* addi R4, R4, 4 */
		/* 82114000h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 82114000h case    0:*/		return 0x82114004;
		  /* 82114004h */ case    1:  		/* bc 16, CR0_LT, -84 */
		/* 82114004h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82113FB0;  }
		/* 82114004h case    1:*/		return 0x82114008;
	}
	return 0x82114008;
} // Block from 82114000h-82114008h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82114008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114008);
		  /* 82114008h */ case    0:  		/* lwz R11, <#[R31 + 76]> */
		/* 82114008h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 82114008h case    0:*/		return 0x8211400C;
		  /* 8211400Ch */ case    1:  		/* lis R10, -32240 */
		/* 8211400Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8210);
		/* 8211400Ch case    1:*/		return 0x82114010;
		  /* 82114010h */ case    2:  		/* mr R6, R26 */
		/* 82114010h case    2:*/		regs.R6 = regs.R26;
		/* 82114010h case    2:*/		return 0x82114014;
		  /* 82114014h */ case    3:  		/* mr R4, R29 */
		/* 82114014h case    3:*/		regs.R4 = regs.R29;
		/* 82114014h case    3:*/		return 0x82114018;
		  /* 82114018h */ case    4:  		/* addi R3, R10, -8784 */
		/* 82114018h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xFFFFDDB0);
		/* 82114018h case    4:*/		return 0x8211401C;
		  /* 8211401Ch */ case    5:  		/* stwx R5, <#[R11 + R28]> */
		/* 8211401Ch case    5:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8211401Ch case    5:*/		return 0x82114020;
		  /* 82114020h */ case    6:  		/* bl -90496 */
		/* 82114020h case    6:*/		regs.LR = 0x82114024; return 0x820FDEA0;
		/* 82114020h case    6:*/		return 0x82114024;
	}
	return 0x82114024;
} // Block from 82114008h-82114024h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82114024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114024);
		  /* 82114024h */ case    0:  		/* lwz R11, <#[R31 + 72]> */
		/* 82114024h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 82114024h case    0:*/		return 0x82114028;
		  /* 82114028h */ case    1:  		/* addi R27, R27, 1 */
		/* 82114028h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82114028h case    1:*/		return 0x8211402C;
		  /* 8211402Ch */ case    2:  		/* addi R28, R28, 4 */
		/* 8211402Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 8211402Ch case    2:*/		return 0x82114030;
		  /* 82114030h */ case    3:  		/* cmplw CR6, R27, R11 */
		/* 82114030h case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 82114030h case    3:*/		return 0x82114034;
		  /* 82114034h */ case    4:  		/* bc 12, CR6_LT, -224 */
		/* 82114034h case    4:*/		if ( regs.CR[6].lt ) { return 0x82113F54;  }
		/* 82114034h case    4:*/		return 0x82114038;
	}
	return 0x82114038;
} // Block from 82114024h-82114038h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82114038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114038);
		  /* 82114038h */ case    0:  		/* lwz R11, <#[R31 + 44]> */
		/* 82114038h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 82114038h case    0:*/		return 0x8211403C;
		  /* 8211403Ch */ case    1:  		/* li R4, 255 */
		/* 8211403Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xFF);
		/* 8211403Ch case    1:*/		return 0x82114040;
		  /* 82114040h */ case    2:  		/* lwz R3, <#[R31 + 28]> */
		/* 82114040h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000001C) );
		/* 82114040h case    2:*/		return 0x82114044;
		  /* 82114044h */ case    3:  		/* rlwinm R5, R11, 4, 0, 27 */
		/* 82114044h case    3:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R5,regs.R11);
		/* 82114044h case    3:*/		return 0x82114048;
		  /* 82114048h */ case    4:  		/* bl -535816 */
		/* 82114048h case    4:*/		regs.LR = 0x8211404C; return 0x82091340;
		/* 82114048h case    4:*/		return 0x8211404C;
		  /* 8211404Ch */ case    5:  		/* lwz R10, <#[R31 + 44]> */
		/* 8211404Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 8211404Ch case    5:*/		return 0x82114050;
		  /* 82114050h */ case    6:  		/* li R11, 0 */
		/* 82114050h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82114050h case    6:*/		return 0x82114054;
		  /* 82114054h */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 82114054h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82114054h case    7:*/		return 0x82114058;
		  /* 82114058h */ case    8:  		/* bc 4, CR6_GT, 36 */
		/* 82114058h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8211407C;  }
		/* 82114058h case    8:*/		return 0x8211405C;
		  /* 8211405Ch */ case    9:  		/* li R10, 0 */
		/* 8211405Ch case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8211405Ch case    9:*/		return 0x82114060;
		  /* 82114060h */ case   10:  		/* lwz R9, <#[R31 + 32]> */
		/* 82114060h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000020) );
		/* 82114060h case   10:*/		return 0x82114064;
		  /* 82114064h */ case   11:  		/* stwx R11, <#[R9 + R10]> */
		/* 82114064h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82114064h case   11:*/		return 0x82114068;
		  /* 82114068h */ case   12:  		/* addi R11, R11, 1 */
		/* 82114068h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82114068h case   12:*/		return 0x8211406C;
		  /* 8211406Ch */ case   13:  		/* addi R10, R10, 4 */
		/* 8211406Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8211406Ch case   13:*/		return 0x82114070;
		  /* 82114070h */ case   14:  		/* lwz R9, <#[R31 + 44]> */
		/* 82114070h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000002C) );
		/* 82114070h case   14:*/		return 0x82114074;
		  /* 82114074h */ case   15:  		/* cmplw CR6, R11, R9 */
		/* 82114074h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82114074h case   15:*/		return 0x82114078;
		  /* 82114078h */ case   16:  		/* bc 12, CR6_LT, -24 */
		/* 82114078h case   16:*/		if ( regs.CR[6].lt ) { return 0x82114060;  }
		/* 82114078h case   16:*/		return 0x8211407C;
	}
	return 0x8211407C;
} // Block from 82114038h-8211407Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8211407Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211407C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211407C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211407C);
		  /* 8211407Ch */ case    0:  		/* lwz R11, <#[R31 + 44]> */
		/* 8211407Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 8211407Ch case    0:*/		return 0x82114080;
		  /* 82114080h */ case    1:  		/* li R10, 0 */
		/* 82114080h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82114080h case    1:*/		return 0x82114084;
		  /* 82114084h */ case    2:  		/* rlwinm R11, R11, 31, 1, 31 */
		/* 82114084h case    2:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R11,regs.R11);
		/* 82114084h case    2:*/		return 0x82114088;
		  /* 82114088h */ case    3:  		/* stw R10, <#[R31 + 4]> */
		/* 82114088h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82114088h case    3:*/		return 0x8211408C;
		  /* 8211408Ch */ case    4:  		/* stw R11, <#[R31 + 36]> */
		/* 8211408Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 8211408Ch case    4:*/		return 0x82114090;
		  /* 82114090h */ case    5:  		/* lwz R24, <#[R26 + 12]> */
		/* 82114090h case    5:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R26 + 0x0000000C) );
		/* 82114090h case    5:*/		return 0x82114094;
		  /* 82114094h */ case    6:  		/* cmplwi CR6, R24, 0 */
		/* 82114094h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 82114094h case    6:*/		return 0x82114098;
		  /* 82114098h */ case    7:  		/* bc 12, CR6_EQ, 372 */
		/* 82114098h case    7:*/		if ( regs.CR[6].eq ) { return 0x8211420C;  }
		/* 82114098h case    7:*/		return 0x8211409C;
		  /* 8211409Ch */ case    8:  		/* rlwinm R23, R24, 2, 0, 29 */
		/* 8211409Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R23,regs.R24);
		/* 8211409Ch case    8:*/		return 0x821140A0;
		  /* 821140A0h */ case    9:  		/* lwz R11, <#[R26 + 24]> */
		/* 821140A0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000018) );
		/* 821140A0h case    9:*/		return 0x821140A4;
		  /* 821140A4h */ case   10:  		/* addi R23, R23, -4 */
		/* 821140A4h case   10:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0xFFFFFFFC);
		/* 821140A4h case   10:*/		return 0x821140A8;
		  /* 821140A8h */ case   11:  		/* lis R10, 8336 */
		/* 821140A8h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0x2090);
		/* 821140A8h case   11:*/		return 0x821140AC;
		  /* 821140ACh */ case   12:  		/* addi R24, R24, -1 */
		/* 821140ACh case   12:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0xFFFFFFFF);
		/* 821140ACh case   12:*/		return 0x821140B0;
		  /* 821140B0h */ case   13:  		/* lwzx R29, <#[R11 + R23]> */
		/* 821140B0h case   13:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R23 + 0x00000000) );
		/* 821140B0h case   13:*/		return 0x821140B4;
		  /* 821140B4h */ case   14:  		/* lwz R11, <#[R29]> */
		/* 821140B4h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821140B4h case   14:*/		return 0x821140B8;
		  /* 821140B8h */ case   15:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 821140B8h case   15:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 821140B8h case   15:*/		return 0x821140BC;
		  /* 821140BCh */ case   16:  		/* cmplw CR6, R11, R10 */
		/* 821140BCh case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821140BCh case   16:*/		return 0x821140C0;
		  /* 821140C0h */ case   17:  		/* bc 4, CR6_EQ, 324 */
		/* 821140C0h case   17:*/		if ( !regs.CR[6].eq ) { return 0x82114204;  }
		/* 821140C0h case   17:*/		return 0x821140C4;
		  /* 821140C4h */ case   18:  		/* lwz R11, <#[R29 + 12]> */
		/* 821140C4h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 821140C4h case   18:*/		return 0x821140C8;
		  /* 821140C8h */ case   19:  		/* li R25, 0 */
		/* 821140C8h case   19:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 821140C8h case   19:*/		return 0x821140CC;
		  /* 821140CCh */ case   20:  		/* cmplwi CR6, R11, 0 */
		/* 821140CCh case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821140CCh case   20:*/		return 0x821140D0;
		  /* 821140D0h */ case   21:  		/* bc 4, CR6_GT, 308 */
		/* 821140D0h case   21:*/		if ( !regs.CR[6].gt ) { return 0x82114204;  }
		/* 821140D0h case   21:*/		return 0x821140D4;
		  /* 821140D4h */ case   22:  		/* li R27, 0 */
		/* 821140D4h case   22:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 821140D4h case   22:*/		return 0x821140D8;
		  /* 821140D8h */ case   23:  		/* stw R29, <#[R31 + 92]> */
		/* 821140D8h case   23:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x0000005C) );
		/* 821140D8h case   23:*/		return 0x821140DC;
		  /* 821140DCh */ case   24:  		/* lwz R11, <#[R29 + 8]> */
		/* 821140DCh case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821140DCh case   24:*/		return 0x821140E0;
		  /* 821140E0h */ case   25:  		/* lwzx R11, <#[R11 + R27]> */
		/* 821140E0h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 821140E0h case   25:*/		return 0x821140E4;
		  /* 821140E4h */ case   26:  		/* cmpwi CR6, R11, -1 */
		/* 821140E4h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 821140E4h case   26:*/		return 0x821140E8;
		  /* 821140E8h */ case   27:  		/* bc 12, CR6_EQ, 32 */
		/* 821140E8h case   27:*/		if ( regs.CR[6].eq ) { return 0x82114108;  }
		/* 821140E8h case   27:*/		return 0x821140EC;
		  /* 821140ECh */ case   28:  		/* lwz R10, <#[R26 + 20]> */
		/* 821140ECh case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 821140ECh case   28:*/		return 0x821140F0;
		  /* 821140F0h */ case   29:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 821140F0h case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 821140F0h case   29:*/		return 0x821140F4;
		  /* 821140F4h */ case   30:  		/* lwzx R10, <#[R9 + R10]> */
		/* 821140F4h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821140F4h case   30:*/		return 0x821140F8;
		  /* 821140F8h */ case   31:  		/* lwz R10, <#[R10 + 56]> */
		/* 821140F8h case   31:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000038) );
		/* 821140F8h case   31:*/		return 0x821140FC;
		  /* 821140FCh */ case   32:  		/* cmpwi CR6, R10, -1 */
		/* 821140FCh case   32:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 821140FCh case   32:*/		return 0x82114100;
		  /* 82114100h */ case   33:  		/* bc 12, CR6_EQ, 8 */
		/* 82114100h case   33:*/		if ( regs.CR[6].eq ) { return 0x82114108;  }
		/* 82114100h case   33:*/		return 0x82114104;
		  /* 82114104h */ case   34:  		/* mr R11, R10 */
		/* 82114104h case   34:*/		regs.R11 = regs.R10;
		/* 82114104h case   34:*/		return 0x82114108;
	}
	return 0x82114108;
} // Block from 8211407Ch-82114108h (35 instructions)

//////////////////////////////////////////////////////
// Block at 82114108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114108);
		  /* 82114108h */ case    0:  		/* mr R8, R21 */
		/* 82114108h case    0:*/		regs.R8 = regs.R21;
		/* 82114108h case    0:*/		return 0x8211410C;
		  /* 8211410Ch */ case    1:  		/* mr R7, R21 */
		/* 8211410Ch case    1:*/		regs.R7 = regs.R21;
		/* 8211410Ch case    1:*/		return 0x82114110;
		  /* 82114110h */ case    2:  		/* li R6, 0 */
		/* 82114110h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82114110h case    2:*/		return 0x82114114;
		  /* 82114114h */ case    3:  		/* mr R5, R11 */
		/* 82114114h case    3:*/		regs.R5 = regs.R11;
		/* 82114114h case    3:*/		return 0x82114118;
		  /* 82114118h */ case    4:  		/* mr R4, R31 */
		/* 82114118h case    4:*/		regs.R4 = regs.R31;
		/* 82114118h case    4:*/		return 0x8211411C;
		  /* 8211411Ch */ case    5:  		/* mr R3, R26 */
		/* 8211411Ch case    5:*/		regs.R3 = regs.R26;
		/* 8211411Ch case    5:*/		return 0x82114120;
		  /* 82114120h */ case    6:  		/* bl -2712 */
		/* 82114120h case    6:*/		regs.LR = 0x82114124; return 0x82113688;
		/* 82114120h case    6:*/		return 0x82114124;
		  /* 82114124h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 82114124h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82114124h case    7:*/		return 0x82114128;
		  /* 82114128h */ case    8:  		/* bc 12, CR0_LT, 800 */
		/* 82114128h case    8:*/		if ( regs.CR[0].lt ) { return 0x82114448;  }
		/* 82114128h case    8:*/		return 0x8211412C;
		  /* 8211412Ch */ case    9:  		/* lwz R10, <#[R29 + 12]> */
		/* 8211412Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000000C) );
		/* 8211412Ch case    9:*/		return 0x82114130;
		  /* 82114130h */ case   10:  		/* li R11, 0 */
		/* 82114130h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82114130h case   10:*/		return 0x82114134;
		  /* 82114134h */ case   11:  		/* lwz R9, <#[R29 + 8]> */
		/* 82114134h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 82114134h case   11:*/		return 0x82114138;
		  /* 82114138h */ case   12:  		/* add R10, R10, R25 */
		/* 82114138h case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R25);
		/* 82114138h case   12:*/		return 0x8211413C;
		  /* 8211413Ch */ case   13:  		/* lwz R8, <#[R26 + 20]> */
		/* 8211413Ch case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000014) );
		/* 8211413Ch case   13:*/		return 0x82114140;
		  /* 82114140h */ case   14:  		/* lwz R7, <#[R26 + 24]> */
		/* 82114140h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R26 + 0x00000018) );
		/* 82114140h case   14:*/		return 0x82114144;
		  /* 82114144h */ case   15:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82114144h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82114144h case   15:*/		return 0x82114148;
		  /* 82114148h */ case   16:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82114148h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82114148h case   16:*/		return 0x8211414C;
		  /* 8211414Ch */ case   17:  		/* rlwinm R9, R10, 2, 0, 29 */
		/* 8211414Ch case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R10);
		/* 8211414Ch case   17:*/		return 0x82114150;
		  /* 82114150h */ case   18:  		/* lwzx R9, <#[R9 + R8]> */
		/* 82114150h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82114150h case   18:*/		return 0x82114154;
		  /* 82114154h */ case   19:  		/* lwz R9, <#[R9 + 72]> */
		/* 82114154h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000048) );
		/* 82114154h case   19:*/		return 0x82114158;
		  /* 82114158h */ case   20:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82114158h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82114158h case   20:*/		return 0x8211415C;
		  /* 8211415Ch */ case   21:  		/* lwzx R30, <#[R9 + R7]> */
		/* 8211415Ch case   21:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 8211415Ch case   21:*/		return 0x82114160;
		  /* 82114160h */ case   22:  		/* lwz R9, <#[R30 + 12]> */
		/* 82114160h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000000C) );
		/* 82114160h case   22:*/		return 0x82114164;
		  /* 82114164h */ case   23:  		/* cmplwi CR6, R9, 0 */
		/* 82114164h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82114164h case   23:*/		return 0x82114168;
		  /* 82114168h */ case   24:  		/* bc 12, CR6_EQ, 40 */
		/* 82114168h case   24:*/		if ( regs.CR[6].eq ) { return 0x82114190;  }
		/* 82114168h case   24:*/		return 0x8211416C;
		  /* 8211416Ch */ case   25:  		/* lwz R7, <#[R30 + 16]> */
		/* 8211416Ch case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000010) );
		/* 8211416Ch case   25:*/		return 0x82114170;
		  /* 82114170h */ case   26:  		/* li R8, 0 */
		/* 82114170h case   26:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82114170h case   26:*/		return 0x82114174;
		  /* 82114174h */ case   27:  		/* lwzx R6, <#[R7 + R8]> */
		/* 82114174h case   27:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 82114174h case   27:*/		return 0x82114178;
		  /* 82114178h */ case   28:  		/* cmplw CR6, R6, R10 */
		/* 82114178h case   28:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 82114178h case   28:*/		return 0x8211417C;
		  /* 8211417Ch */ case   29:  		/* bc 12, CR6_EQ, 20 */
		/* 8211417Ch case   29:*/		if ( regs.CR[6].eq ) { return 0x82114190;  }
		/* 8211417Ch case   29:*/		return 0x82114180;
		  /* 82114180h */ case   30:  		/* addi R11, R11, 1 */
		/* 82114180h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82114180h case   30:*/		return 0x82114184;
		  /* 82114184h */ case   31:  		/* addi R8, R8, 4 */
		/* 82114184h case   31:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82114184h case   31:*/		return 0x82114188;
		  /* 82114188h */ case   32:  		/* cmplw CR6, R11, R9 */
		/* 82114188h case   32:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82114188h case   32:*/		return 0x8211418C;
		  /* 8211418Ch */ case   33:  		/* bc 12, CR6_LT, -24 */
		/* 8211418Ch case   33:*/		if ( regs.CR[6].lt ) { return 0x82114174;  }
		/* 8211418Ch case   33:*/		return 0x82114190;
	}
	return 0x82114190;
} // Block from 82114108h-82114190h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82114190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114190);
		  /* 82114190h */ case    0:  		/* stw R30, <#[R31 + 92]> */
		/* 82114190h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000005C) );
		/* 82114190h case    0:*/		return 0x82114194;
		  /* 82114194h */ case    1:  		/* rlwinm R28, R11, 2, 0, 29 */
		/* 82114194h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R11);
		/* 82114194h case    1:*/		return 0x82114198;
		  /* 82114198h */ case    2:  		/* mr R8, R21 */
		/* 82114198h case    2:*/		regs.R8 = regs.R21;
		/* 82114198h case    2:*/		return 0x8211419C;
		  /* 8211419Ch */ case    3:  		/* lwz R10, <#[R29 + 16]> */
		/* 8211419Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000010) );
		/* 8211419Ch case    3:*/		return 0x821141A0;
		  /* 821141A0h */ case    4:  		/* li R6, 0 */
		/* 821141A0h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821141A0h case    4:*/		return 0x821141A4;
		  /* 821141A4h */ case    5:  		/* lwzx R5, <#[R10 + R27]> */
		/* 821141A4h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 821141A4h case    5:*/		return 0x821141A8;
		  /* 821141A8h */ case    6:  		/* mr R4, R31 */
		/* 821141A8h case    6:*/		regs.R4 = regs.R31;
		/* 821141A8h case    6:*/		return 0x821141AC;
		  /* 821141ACh */ case    7:  		/* mr R3, R26 */
		/* 821141ACh case    7:*/		regs.R3 = regs.R26;
		/* 821141ACh case    7:*/		return 0x821141B0;
		  /* 821141B0h */ case    8:  		/* lwz R11, <#[R30 + 8]> */
		/* 821141B0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821141B0h case    8:*/		return 0x821141B4;
		  /* 821141B4h */ case    9:  		/* lwzx R7, <#[R11 + R28]> */
		/* 821141B4h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 821141B4h case    9:*/		return 0x821141B8;
		  /* 821141B8h */ case   10:  		/* bl -2864 */
		/* 821141B8h case   10:*/		regs.LR = 0x821141BC; return 0x82113688;
		/* 821141B8h case   10:*/		return 0x821141BC;
		  /* 821141BCh */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 821141BCh case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821141BCh case   11:*/		return 0x821141C0;
		  /* 821141C0h */ case   12:  		/* bc 12, CR0_LT, 648 */
		/* 821141C0h case   12:*/		if ( regs.CR[0].lt ) { return 0x82114448;  }
		/* 821141C0h case   12:*/		return 0x821141C4;
		  /* 821141C4h */ case   13:  		/* lwz R11, <#[R29 + 16]> */
		/* 821141C4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821141C4h case   13:*/		return 0x821141C8;
		  /* 821141C8h */ case   14:  		/* mr R8, R21 */
		/* 821141C8h case   14:*/		regs.R8 = regs.R21;
		/* 821141C8h case   14:*/		return 0x821141CC;
		  /* 821141CCh */ case   15:  		/* lwz R10, <#[R30 + 8]> */
		/* 821141CCh case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 821141CCh case   15:*/		return 0x821141D0;
		  /* 821141D0h */ case   16:  		/* li R6, 0 */
		/* 821141D0h case   16:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821141D0h case   16:*/		return 0x821141D4;
		  /* 821141D4h */ case   17:  		/* mr R4, R31 */
		/* 821141D4h case   17:*/		regs.R4 = regs.R31;
		/* 821141D4h case   17:*/		return 0x821141D8;
		  /* 821141D8h */ case   18:  		/* mr R3, R26 */
		/* 821141D8h case   18:*/		regs.R3 = regs.R26;
		/* 821141D8h case   18:*/		return 0x821141DC;
		  /* 821141DCh */ case   19:  		/* lwzx R7, <#[R11 + R27]> */
		/* 821141DCh case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 821141DCh case   19:*/		return 0x821141E0;
		  /* 821141E0h */ case   20:  		/* lwzx R5, <#[R10 + R28]> */
		/* 821141E0h case   20:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 821141E0h case   20:*/		return 0x821141E4;
		  /* 821141E4h */ case   21:  		/* bl -2908 */
		/* 821141E4h case   21:*/		regs.LR = 0x821141E8; return 0x82113688;
		/* 821141E4h case   21:*/		return 0x821141E8;
		  /* 821141E8h */ case   22:  		/* cmpwi CR0, R3, 0 */
		/* 821141E8h case   22:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821141E8h case   22:*/		return 0x821141EC;
		  /* 821141ECh */ case   23:  		/* bc 12, CR0_LT, 604 */
		/* 821141ECh case   23:*/		if ( regs.CR[0].lt ) { return 0x82114448;  }
		/* 821141ECh case   23:*/		return 0x821141F0;
	}
	return 0x821141F0;
} // Block from 82114190h-821141F0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821141F0h
// Function '?CompactPool_Read@CProgram@D3DXShader@@AAAJPAU_D3DXCP_DATA@2@IHII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821141F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821141F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821141F0);
		  /* 821141F0h */ case    0:  		/* lwz R11, <#[R29 + 12]> */
		/* 821141F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 821141F0h case    0:*/		return 0x821141F4;
		  /* 821141F4h */ case    1:  		/* addi R25, R25, 1 */
		/* 821141F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 821141F4h case    1:*/		return 0x821141F8;
		  /* 821141F8h */ case    2:  		/* addi R27, R27, 4 */
		/* 821141F8h case    2:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 821141F8h case    2:*/		return 0x821141FC;
		  /* 821141FCh */ case    3:  		/* cmplw CR6, R25, R11 */
		/* 821141FCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 821141FCh case    3:*/		return 0x82114200;
		  /* 82114200h */ case    4:  		/* bc 12, CR6_LT, -296 */
		/* 82114200h case    4:*/		if ( regs.CR[6].lt ) { return 0x821140D8;  }
		/* 82114200h case    4:*/		return 0x82114204;
	}
	return 0x82114204;
} // Block from 821141F0h-82114204h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82114204h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114204( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114204) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114204);
		  /* 82114204h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 82114204h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 82114204h case    0:*/		return 0x82114208;
		  /* 82114208h */ case    1:  		/* bc 4, CR6_EQ, -360 */
		/* 82114208h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821140A0;  }
		/* 82114208h case    1:*/		return 0x8211420C;
	}
	return 0x8211420C;
} // Block from 82114204h-8211420Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8211420Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211420C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211420C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211420C);
		  /* 8211420Ch */ case    0:  		/* li R22, 4 */
		/* 8211420Ch case    0:*/		cpu::op::li<0>(regs,&regs.R22,0x4);
		/* 8211420Ch case    0:*/		return 0x82114210;
		  /* 82114210h */ case    1:  		/* stw R22, <#[R31 + 4]> */
		/* 82114210h case    1:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000004) );
		/* 82114210h case    1:*/		return 0x82114214;
		  /* 82114214h */ case    2:  		/* lwz R24, <#[R26 + 12]> */
		/* 82114214h case    2:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R26 + 0x0000000C) );
		/* 82114214h case    2:*/		return 0x82114218;
		  /* 82114218h */ case    3:  		/* cmplwi CR6, R24, 0 */
		/* 82114218h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 82114218h case    3:*/		return 0x8211421C;
		  /* 8211421Ch */ case    4:  		/* bc 12, CR6_EQ, 404 */
		/* 8211421Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x821143B0;  }
		/* 8211421Ch case    4:*/		return 0x82114220;
		  /* 82114220h */ case    5:  		/* rlwinm R23, R24, 2, 0, 29 */
		/* 82114220h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R23,regs.R24);
		/* 82114220h case    5:*/		return 0x82114224;
		  /* 82114224h */ case    6:  		/* lwz R11, <#[R26 + 24]> */
		/* 82114224h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000018) );
		/* 82114224h case    6:*/		return 0x82114228;
		  /* 82114228h */ case    7:  		/* addi R23, R23, -4 */
		/* 82114228h case    7:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0xFFFFFFFC);
		/* 82114228h case    7:*/		return 0x8211422C;
		  /* 8211422Ch */ case    8:  		/* addi R24, R24, -1 */
		/* 8211422Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0xFFFFFFFF);
		/* 8211422Ch case    8:*/		return 0x82114230;
		  /* 82114230h */ case    9:  		/* lwzx R29, <#[R11 + R23]> */
		/* 82114230h case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R23 + 0x00000000) );
		/* 82114230h case    9:*/		return 0x82114234;
		  /* 82114234h */ case   10:  		/* stw R29, <#[R31 + 92]> */
		/* 82114234h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x0000005C) );
		/* 82114234h case   10:*/		return 0x82114238;
		  /* 82114238h */ case   11:  		/* lwz R11, <#[R29]> */
		/* 82114238h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82114238h case   11:*/		return 0x8211423C;
		  /* 8211423Ch */ case   12:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 8211423Ch case   12:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 8211423Ch case   12:*/		return 0x82114240;
		  /* 82114240h */ case   13:  		/* bc 12, CR0_EQ, 360 */
		/* 82114240h case   13:*/		if ( regs.CR[0].eq ) { return 0x821143A8;  }
		/* 82114240h case   13:*/		return 0x82114244;
		  /* 82114244h */ case   14:  		/* lwz R11, <#[R29 + 12]> */
		/* 82114244h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 82114244h case   14:*/		return 0x82114248;
		  /* 82114248h */ case   15:  		/* li R28, 0 */
		/* 82114248h case   15:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82114248h case   15:*/		return 0x8211424C;
		  /* 8211424Ch */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 8211424Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8211424Ch case   16:*/		return 0x82114250;
		  /* 82114250h */ case   17:  		/* bc 4, CR6_GT, 56 */
		/* 82114250h case   17:*/		if ( !regs.CR[6].gt ) { return 0x82114288;  }
		/* 82114250h case   17:*/		return 0x82114254;
		  /* 82114254h */ case   18:  		/* li R30, 0 */
		/* 82114254h case   18:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82114254h case   18:*/		return 0x82114258;
		  /* 82114258h */ case   19:  		/* lwz R11, <#[R29 + 16]> */
		/* 82114258h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 82114258h case   19:*/		return 0x8211425C;
		  /* 8211425Ch */ case   20:  		/* mr R4, R31 */
		/* 8211425Ch case   20:*/		regs.R4 = regs.R31;
		/* 8211425Ch case   20:*/		return 0x82114260;
		  /* 82114260h */ case   21:  		/* mr R3, R26 */
		/* 82114260h case   21:*/		regs.R3 = regs.R26;
		/* 82114260h case   21:*/		return 0x82114264;
		  /* 82114264h */ case   22:  		/* lwzx R5, <#[R11 + R30]> */
		/* 82114264h case   22:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82114264h case   22:*/		return 0x82114268;
		  /* 82114268h */ case   23:  		/* bl -2024 */
		/* 82114268h case   23:*/		regs.LR = 0x8211426C; return 0x82113A80;
		/* 82114268h case   23:*/		return 0x8211426C;
		  /* 8211426Ch */ case   24:  		/* cmpwi CR0, R3, 0 */
		/* 8211426Ch case   24:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8211426Ch case   24:*/		return 0x82114270;
		  /* 82114270h */ case   25:  		/* bc 12, CR0_LT, 472 */
		/* 82114270h case   25:*/		if ( regs.CR[0].lt ) { return 0x82114448;  }
		/* 82114270h case   25:*/		return 0x82114274;
		  /* 82114274h */ case   26:  		/* lwz R11, <#[R29 + 12]> */
		/* 82114274h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 82114274h case   26:*/		return 0x82114278;
		  /* 82114278h */ case   27:  		/* addi R28, R28, 1 */
		/* 82114278h case   27:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82114278h case   27:*/		return 0x8211427C;
		  /* 8211427Ch */ case   28:  		/* addi R30, R30, 4 */
		/* 8211427Ch case   28:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8211427Ch case   28:*/		return 0x82114280;
		  /* 82114280h */ case   29:  		/* cmplw CR6, R28, R11 */
		/* 82114280h case   29:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 82114280h case   29:*/		return 0x82114284;
		  /* 82114284h */ case   30:  		/* bc 12, CR6_LT, -44 */
		/* 82114284h case   30:*/		if ( regs.CR[6].lt ) { return 0x82114258;  }
		/* 82114284h case   30:*/		return 0x82114288;
	}
	return 0x82114288;
} // Block from 8211420Ch-82114288h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82114288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114288);
		  /* 82114288h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 82114288h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82114288h case    0:*/		return 0x8211428C;
		  /* 8211428Ch */ case    1:  		/* li R25, 0 */
		/* 8211428Ch case    1:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 8211428Ch case    1:*/		return 0x82114290;
		  /* 82114290h */ case    2:  		/* lwz R10, <#[R29 + 4]> */
		/* 82114290h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 82114290h case    2:*/		return 0x82114294;
		  /* 82114294h */ case    3:  		/* rlwinm R28, R11, 0, 12, 31 */
		/* 82114294h case    3:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R28,regs.R11);
		/* 82114294h case    3:*/		return 0x82114298;
		  /* 82114298h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 82114298h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82114298h case    4:*/		return 0x8211429C;
		  /* 8211429Ch */ case    5:  		/* divwu R30, R10, R28 */
		/* 8211429Ch case    5:*/		cpu::op::divwu<0>(regs,&regs.R30,regs.R10,regs.R28);
		/* 8211429Ch case    5:*/		return 0x821142A0;
		  /* 821142A0h */ case    6:  		/* twi 6, R28, 0 */
		/* 821142A0h case    6:*/		cpu::op::tw<6>(regs, 0x821142A0, regs.R28, 0x00000000);
		/* 821142A0h case    6:*/		return 0x821142A4;
		  /* 821142A4h */ case    7:  		/* bc 12, CR6_EQ, 260 */
		/* 821142A4h case    7:*/		if ( regs.CR[6].eq ) { return 0x821143A8;  }
		/* 821142A4h case    7:*/		return 0x821142A8;
		  /* 821142A8h */ case    8:  		/* li R27, 0 */
		/* 821142A8h case    8:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 821142A8h case    8:*/		return 0x821142AC;
		  /* 821142ACh */ case    9:  		/* lwz R11, <#[R26 + 112]> */
		/* 821142ACh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000070) );
		/* 821142ACh case    9:*/		return 0x821142B0;
		  /* 821142B0h */ case   10:  		/* li R6, 0 */
		/* 821142B0h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821142B0h case   10:*/		return 0x821142B4;
		  /* 821142B4h */ case   11:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 821142B4h case   11:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 821142B4h case   11:*/		return 0x821142B8;
		  /* 821142B8h */ case   12:  		/* bc 12, CR0_EQ, 144 */
		/* 821142B8h case   12:*/		if ( regs.CR[0].eq ) { return 0x82114348;  }
		/* 821142B8h case   12:*/		return 0x821142BC;
		  /* 821142BCh */ case   13:  		/* cmplwi CR6, R30, 0 */
		/* 821142BCh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821142BCh case   13:*/		return 0x821142C0;
		  /* 821142C0h */ case   14:  		/* bc 12, CR6_EQ, 136 */
		/* 821142C0h case   14:*/		if ( regs.CR[6].eq ) { return 0x82114348;  }
		/* 821142C0h case   14:*/		return 0x821142C4;
		  /* 821142C4h */ case   15:  		/* lwz R5, <#[R29 + 8]> */
		/* 821142C4h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x00000008) );
		/* 821142C4h case   15:*/		return 0x821142C8;
		  /* 821142C8h */ case   16:  		/* li R8, 0 */
		/* 821142C8h case   16:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821142C8h case   16:*/		return 0x821142CC;
		  /* 821142CCh */ case   17:  		/* lwz R9, <#[R26 + 20]> */
		/* 821142CCh case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000014) );
		/* 821142CCh case   17:*/		return 0x821142D0;
		  /* 821142D0h */ case   18:  		/* rlwinm R4, R28, 2, 0, 29 */
		/* 821142D0h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R28);
		/* 821142D0h case   18:*/		return 0x821142D4;
		  /* 821142D4h */ case   19:  		/* lwz R7, <#[R31]> */
		/* 821142D4h case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000000) );
		/* 821142D4h case   19:*/		return 0x821142D8;
		  /* 821142D8h */ case   20:  		/* mtspr CTR, R30 */
		/* 821142D8h case   20:*/		regs.CTR = regs.R30;
		/* 821142D8h case   20:*/		return 0x821142DC;
		  /* 821142DCh */ case   21:  		/* lwzx R11, <#[R5 + R8]> */
		/* 821142DCh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + regs.R8 + 0x00000000) );
		/* 821142DCh case   21:*/		return 0x821142E0;
		  /* 821142E0h */ case   22:  		/* cmpwi CR6, R11, -1 */
		/* 821142E0h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 821142E0h case   22:*/		return 0x821142E4;
		  /* 821142E4h */ case   23:  		/* bc 12, CR6_EQ, 28 */
		/* 821142E4h case   23:*/		if ( regs.CR[6].eq ) { return 0x82114300;  }
		/* 821142E4h case   23:*/		return 0x821142E8;
		  /* 821142E8h */ case   24:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 821142E8h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 821142E8h case   24:*/		return 0x821142EC;
		  /* 821142ECh */ case   25:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821142ECh case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821142ECh case   25:*/		return 0x821142F0;
		  /* 821142F0h */ case   26:  		/* lwz R10, <#[R10 + 56]> */
		/* 821142F0h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000038) );
		/* 821142F0h case   26:*/		return 0x821142F4;
		  /* 821142F4h */ case   27:  		/* cmpwi CR6, R10, -1 */
		/* 821142F4h case   27:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 821142F4h case   27:*/		return 0x821142F8;
		  /* 821142F8h */ case   28:  		/* bc 12, CR6_EQ, 8 */
		/* 821142F8h case   28:*/		if ( regs.CR[6].eq ) { return 0x82114300;  }
		/* 821142F8h case   28:*/		return 0x821142FC;
		  /* 821142FCh */ case   29:  		/* mr R11, R10 */
		/* 821142FCh case   29:*/		regs.R11 = regs.R10;
		/* 821142FCh case   29:*/		return 0x82114300;
	}
	return 0x82114300;
} // Block from 82114288h-82114300h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82114300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114300);
		  /* 82114300h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82114300h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82114300h case    0:*/		return 0x82114304;
		  /* 82114304h */ case    1:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82114304h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82114304h case    1:*/		return 0x82114308;
		  /* 82114308h */ case    2:  		/* lwz R10, <#[R11 + 4]> */
		/* 82114308h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82114308h case    2:*/		return 0x8211430C;
		  /* 8211430Ch */ case    3:  		/* cmplw CR6, R7, R10 */
		/* 8211430Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 8211430Ch case    3:*/		return 0x82114310;
		  /* 82114310h */ case    4:  		/* bc 4, CR6_EQ, 48 */
		/* 82114310h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82114340;  }
		/* 82114310h case    4:*/		return 0x82114314;
		  /* 82114314h */ case    5:  		/* lwz R11, <#[R11 + 12]> */
		/* 82114314h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 82114314h case    5:*/		return 0x82114318;
		  /* 82114318h */ case    6:  		/* lwz R10, <#[R31 + 16]> */
		/* 82114318h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82114318h case    6:*/		return 0x8211431C;
		  /* 8211431Ch */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8211431Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8211431Ch case    7:*/		return 0x82114320;
		  /* 82114320h */ case    8:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82114320h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82114320h case    8:*/		return 0x82114324;
		  /* 82114324h */ case    9:  		/* cmpwi CR6, R11, -1 */
		/* 82114324h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82114324h case    9:*/		return 0x82114328;
		  /* 82114328h */ case   10:  		/* bc 12, CR6_EQ, 24 */
		/* 82114328h case   10:*/		if ( regs.CR[6].eq ) { return 0x82114340;  }
		/* 82114328h case   10:*/		return 0x8211432C;
		  /* 8211432Ch */ case   11:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8211432Ch case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8211432Ch case   11:*/		return 0x82114330;
		  /* 82114330h */ case   12:  		/* bc 12, CR0_EQ, 12 */
		/* 82114330h case   12:*/		if ( regs.CR[0].eq ) { return 0x8211433C;  }
		/* 82114330h case   12:*/		return 0x82114334;
		  /* 82114334h */ case   13:  		/* addi R6, R6, -1 */
		/* 82114334h case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0xFFFFFFFF);
		/* 82114334h case   13:*/		return 0x82114338;
		  /* 82114338h */ case   14:  		/* b 8 */
		/* 82114338h case   14:*/		return 0x82114340;
		/* 82114338h case   14:*/		return 0x8211433C;
	}
	return 0x8211433C;
} // Block from 82114300h-8211433Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8211433Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211433C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211433C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211433C);
		  /* 8211433Ch */ case    0:  		/* addi R6, R6, 1 */
		/* 8211433Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8211433Ch case    0:*/		return 0x82114340;
	}
	return 0x82114340;
} // Block from 8211433Ch-82114340h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82114340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114340);
		  /* 82114340h */ case    0:  		/* add R8, R4, R8 */
		/* 82114340h case    0:*/		cpu::op::add<0>(regs,&regs.R8,regs.R4,regs.R8);
		/* 82114340h case    0:*/		return 0x82114344;
		  /* 82114344h */ case    1:  		/* bc 16, CR0_LT, -104 */
		/* 82114344h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821142DC;  }
		/* 82114344h case    1:*/		return 0x82114348;
	}
	return 0x82114348;
} // Block from 82114340h-82114348h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82114348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114348);
		  /* 82114348h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 82114348h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82114348h case    0:*/		return 0x8211434C;
		  /* 8211434Ch */ case    1:  		/* lwzx R11, <#[R11 + R27]> */
		/* 8211434Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8211434Ch case    1:*/		return 0x82114350;
		  /* 82114350h */ case    2:  		/* cmpwi CR6, R11, -1 */
		/* 82114350h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82114350h case    2:*/		return 0x82114354;
		  /* 82114354h */ case    3:  		/* bc 12, CR6_EQ, 32 */
		/* 82114354h case    3:*/		if ( regs.CR[6].eq ) { return 0x82114374;  }
		/* 82114354h case    3:*/		return 0x82114358;
		  /* 82114358h */ case    4:  		/* lwz R10, <#[R26 + 20]> */
		/* 82114358h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 82114358h case    4:*/		return 0x8211435C;
		  /* 8211435Ch */ case    5:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8211435Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8211435Ch case    5:*/		return 0x82114360;
		  /* 82114360h */ case    6:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82114360h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82114360h case    6:*/		return 0x82114364;
		  /* 82114364h */ case    7:  		/* lwz R10, <#[R10 + 56]> */
		/* 82114364h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000038) );
		/* 82114364h case    7:*/		return 0x82114368;
		  /* 82114368h */ case    8:  		/* cmpwi CR6, R10, -1 */
		/* 82114368h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82114368h case    8:*/		return 0x8211436C;
		  /* 8211436Ch */ case    9:  		/* bc 12, CR6_EQ, 8 */
		/* 8211436Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x82114374;  }
		/* 8211436Ch case    9:*/		return 0x82114370;
		  /* 82114370h */ case   10:  		/* mr R11, R10 */
		/* 82114370h case   10:*/		regs.R11 = regs.R10;
		/* 82114370h case   10:*/		return 0x82114374;
	}
	return 0x82114374;
} // Block from 82114348h-82114374h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82114374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114374);
		  /* 82114374h */ case    0:  		/* mr R8, R21 */
		/* 82114374h case    0:*/		regs.R8 = regs.R21;
		/* 82114374h case    0:*/		return 0x82114378;
		  /* 82114378h */ case    1:  		/* mr R7, R21 */
		/* 82114378h case    1:*/		regs.R7 = regs.R21;
		/* 82114378h case    1:*/		return 0x8211437C;
		  /* 8211437Ch */ case    2:  		/* mr R5, R11 */
		/* 8211437Ch case    2:*/		regs.R5 = regs.R11;
		/* 8211437Ch case    2:*/		return 0x82114380;
		  /* 82114380h */ case    3:  		/* mr R4, R31 */
		/* 82114380h case    3:*/		regs.R4 = regs.R31;
		/* 82114380h case    3:*/		return 0x82114384;
		  /* 82114384h */ case    4:  		/* mr R3, R26 */
		/* 82114384h case    4:*/		regs.R3 = regs.R26;
		/* 82114384h case    4:*/		return 0x82114388;
		  /* 82114388h */ case    5:  		/* bl -3328 */
		/* 82114388h case    5:*/		regs.LR = 0x8211438C; return 0x82113688;
		/* 82114388h case    5:*/		return 0x8211438C;
		  /* 8211438Ch */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 8211438Ch case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8211438Ch case    6:*/		return 0x82114390;
		  /* 82114390h */ case    7:  		/* bc 12, CR0_LT, 184 */
		/* 82114390h case    7:*/		if ( regs.CR[0].lt ) { return 0x82114448;  }
		/* 82114390h case    7:*/		return 0x82114394;
		  /* 82114394h */ case    8:  		/* lwz R11, <#[R29 + 4]> */
		/* 82114394h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82114394h case    8:*/		return 0x82114398;
		  /* 82114398h */ case    9:  		/* addi R25, R25, 1 */
		/* 82114398h case    9:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 82114398h case    9:*/		return 0x8211439C;
		  /* 8211439Ch */ case   10:  		/* addi R27, R27, 4 */
		/* 8211439Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 8211439Ch case   10:*/		return 0x821143A0;
		  /* 821143A0h */ case   11:  		/* cmplw CR6, R25, R11 */
		/* 821143A0h case   11:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 821143A0h case   11:*/		return 0x821143A4;
		  /* 821143A4h */ case   12:  		/* bc 12, CR6_LT, -248 */
		/* 821143A4h case   12:*/		if ( regs.CR[6].lt ) { return 0x821142AC;  }
		/* 821143A4h case   12:*/		return 0x821143A8;
	}
	return 0x821143A8;
} // Block from 82114374h-821143A8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821143A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821143A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821143A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821143A8);
		  /* 821143A8h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 821143A8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 821143A8h case    0:*/		return 0x821143AC;
		  /* 821143ACh */ case    1:  		/* bc 4, CR6_EQ, -392 */
		/* 821143ACh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82114224;  }
		/* 821143ACh case    1:*/		return 0x821143B0;
	}
	return 0x821143B0;
} // Block from 821143A8h-821143B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821143B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821143B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821143B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821143B0);
		  /* 821143B0h */ case    0:  		/* addic. R22, R22, -1 */
		/* 821143B0h case    0:*/		cpu::op::addic<1>(regs,&regs.R22,regs.R22,0xFFFFFFFF);
		/* 821143B0h case    0:*/		return 0x821143B4;
		  /* 821143B4h */ case    1:  		/* bc 4, CR0_EQ, -420 */
		/* 821143B4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82114210;  }
		/* 821143B4h case    1:*/		return 0x821143B8;
		  /* 821143B8h */ case    2:  		/* lwz R11, <#[R31 + 96]> */
		/* 821143B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 821143B8h case    2:*/		return 0x821143BC;
		  /* 821143BCh */ case    3:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 821143BCh case    3:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 821143BCh case    3:*/		return 0x821143C0;
		  /* 821143C0h */ case    4:  		/* bc 12, CR0_EQ, 112 */
		/* 821143C0h case    4:*/		if ( regs.CR[0].eq ) { return 0x82114430;  }
		/* 821143C0h case    4:*/		return 0x821143C4;
		  /* 821143C4h */ case    5:  		/* lwz R11, <#[R26 + 8]> */
		/* 821143C4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821143C4h case    5:*/		return 0x821143C8;
		  /* 821143C8h */ case    6:  		/* li R7, 0 */
		/* 821143C8h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821143C8h case    6:*/		return 0x821143CC;
		  /* 821143CCh */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 821143CCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821143CCh case    7:*/		return 0x821143D0;
		  /* 821143D0h */ case    8:  		/* bc 4, CR6_GT, 96 */
		/* 821143D0h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82114430;  }
		/* 821143D0h case    8:*/		return 0x821143D4;
		  /* 821143D4h */ case    9:  		/* li R9, 0 */
		/* 821143D4h case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821143D4h case    9:*/		return 0x821143D8;
		  /* 821143D8h */ case   10:  		/* lwz R11, <#[R26 + 20]> */
		/* 821143D8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 821143D8h case   10:*/		return 0x821143DC;
		  /* 821143DCh */ case   11:  		/* lwz R10, <#[R31]> */
		/* 821143DCh case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821143DCh case   11:*/		return 0x821143E0;
		  /* 821143E0h */ case   12:  		/* lwzx R11, <#[R11 + R9]> */
		/* 821143E0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 821143E0h case   12:*/		return 0x821143E4;
		  /* 821143E4h */ case   13:  		/* lwz R8, <#[R11 + 4]> */
		/* 821143E4h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821143E4h case   13:*/		return 0x821143E8;
		  /* 821143E8h */ case   14:  		/* cmplw CR6, R10, R8 */
		/* 821143E8h case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 821143E8h case   14:*/		return 0x821143EC;
		  /* 821143ECh */ case   15:  		/* bc 4, CR6_EQ, 48 */
		/* 821143ECh case   15:*/		if ( !regs.CR[6].eq ) { return 0x8211441C;  }
		/* 821143ECh case   15:*/		return 0x821143F0;
		  /* 821143F0h */ case   16:  		/* lwz R10, <#[R11 + 12]> */
		/* 821143F0h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821143F0h case   16:*/		return 0x821143F4;
		  /* 821143F4h */ case   17:  		/* lwz R8, <#[R11 + 16]> */
		/* 821143F4h case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 821143F4h case   17:*/		return 0x821143F8;
		  /* 821143F8h */ case   18:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821143F8h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821143F8h case   18:*/		return 0x821143FC;
		  /* 821143FCh */ case   19:  		/* lwz R6, <#[R31 + 20]> */
		/* 821143FCh case   19:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000014) );
		/* 821143FCh case   19:*/		return 0x82114400;
		  /* 82114400h */ case   20:  		/* add R8, R10, R8 */
		/* 82114400h case   20:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R8);
		/* 82114400h case   20:*/		return 0x82114404;
		  /* 82114404h */ case   21:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82114404h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82114404h case   21:*/		return 0x82114408;
		  /* 82114408h */ case   22:  		/* lwzx R8, <#[R8 + R6]> */
		/* 82114408h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R6 + 0x00000000) );
		/* 82114408h case   22:*/		return 0x8211440C;
		  /* 8211440Ch */ case   23:  		/* stw R8, <#[R11 + 16]> */
		/* 8211440Ch case   23:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 8211440Ch case   23:*/		return 0x82114410;
		  /* 82114410h */ case   24:  		/* lwz R8, <#[R31 + 16]> */
		/* 82114410h case   24:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000010) );
		/* 82114410h case   24:*/		return 0x82114414;
		  /* 82114414h */ case   25:  		/* lwzx R10, <#[R10 + R8]> */
		/* 82114414h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 82114414h case   25:*/		return 0x82114418;
		  /* 82114418h */ case   26:  		/* stw R10, <#[R11 + 12]> */
		/* 82114418h case   26:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82114418h case   26:*/		return 0x8211441C;
	}
	return 0x8211441C;
} // Block from 821143B0h-8211441Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 8211441Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211441C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211441C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211441C);
		  /* 8211441Ch */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 8211441Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 8211441Ch case    0:*/		return 0x82114420;
		  /* 82114420h */ case    1:  		/* addi R7, R7, 1 */
		/* 82114420h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82114420h case    1:*/		return 0x82114424;
		  /* 82114424h */ case    2:  		/* addi R9, R9, 4 */
		/* 82114424h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82114424h case    2:*/		return 0x82114428;
		  /* 82114428h */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 82114428h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 82114428h case    3:*/		return 0x8211442C;
		  /* 8211442Ch */ case    4:  		/* bc 12, CR6_LT, -84 */
		/* 8211442Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x821143D8;  }
		/* 8211442Ch case    4:*/		return 0x82114430;
	}
	return 0x82114430;
} // Block from 8211441Ch-82114430h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82114430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114430);
		  /* 82114430h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82114430h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82114430h case    0:*/		return 0x82114434;
		  /* 82114434h */ case    1:  		/* li R3, 0 */
		/* 82114434h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82114434h case    1:*/		return 0x82114438;
		  /* 82114438h */ case    2:  		/* lwz R10, <#[R26 + 16]> */
		/* 82114438h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000010) );
		/* 82114438h case    2:*/		return 0x8211443C;
		  /* 8211443Ch */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8211443Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8211443Ch case    3:*/		return 0x82114440;
		  /* 82114440h */ case    4:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82114440h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82114440h case    4:*/		return 0x82114444;
		  /* 82114444h */ case    5:  		/* stw R21, <#[R11 + 8]> */
		/* 82114444h case    5:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R11 + 0x00000008) );
		/* 82114444h case    5:*/		return 0x82114448;
	}
	return 0x82114448;
} // Block from 82114430h-82114448h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82114448h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114448);
		  /* 82114448h */ case    0:  		/* addi R1, R1, 176 */
		/* 82114448h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82114448h case    0:*/		return 0x8211444C;
		  /* 8211444Ch */ case    1:  		/* b -537024 */
		/* 8211444Ch case    1:*/		return 0x8209128C;
		/* 8211444Ch case    1:*/		return 0x82114450;
	}
	return 0x82114450;
} // Block from 82114448h-82114450h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82114450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114450);
		  /* 82114450h */ case    0:  		/* mfspr R12, LR */
		/* 82114450h case    0:*/		regs.R12 = regs.LR;
		/* 82114450h case    0:*/		return 0x82114454;
		  /* 82114454h */ case    1:  		/* bl -537140 */
		/* 82114454h case    1:*/		regs.LR = 0x82114458; return 0x82091220;
		/* 82114454h case    1:*/		return 0x82114458;
		  /* 82114458h */ case    2:  		/* stfd FR30, <#[R1 - 168]> */
		/* 82114458h case    2:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFF58) );
		/* 82114458h case    2:*/		return 0x8211445C;
		  /* 8211445Ch */ case    3:  		/* stfd FR31, <#[R1 - 160]> */
		/* 8211445Ch case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8211445Ch case    3:*/		return 0x82114460;
		  /* 82114460h */ case    4:  		/* stwu R1, <#[R1 - 272]> */
		/* 82114460h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEF0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEF0);
		/* 82114460h case    4:*/		return 0x82114464;
		  /* 82114464h */ case    5:  		/* lwz R10, <#[R3 + 8]> */
		/* 82114464h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82114464h case    5:*/		return 0x82114468;
		  /* 82114468h */ case    6:  		/* li R22, 0 */
		/* 82114468h case    6:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 82114468h case    6:*/		return 0x8211446C;
		  /* 8211446Ch */ case    7:  		/* mr R26, R3 */
		/* 8211446Ch case    7:*/		regs.R26 = regs.R3;
		/* 8211446Ch case    7:*/		return 0x82114470;
		  /* 82114470h */ case    8:  		/* mr R23, R22 */
		/* 82114470h case    8:*/		regs.R23 = regs.R22;
		/* 82114470h case    8:*/		return 0x82114474;
		  /* 82114474h */ case    9:  		/* mr R11, R22 */
		/* 82114474h case    9:*/		regs.R11 = regs.R22;
		/* 82114474h case    9:*/		return 0x82114478;
		  /* 82114478h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 82114478h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82114478h case   10:*/		return 0x8211447C;
		  /* 8211447Ch */ case   11:  		/* bc 4, CR6_GT, 40 */
		/* 8211447Ch case   11:*/		if ( !regs.CR[6].gt ) { return 0x821144A4;  }
		/* 8211447Ch case   11:*/		return 0x82114480;
		  /* 82114480h */ case   12:  		/* mr R10, R22 */
		/* 82114480h case   12:*/		regs.R10 = regs.R22;
		/* 82114480h case   12:*/		return 0x82114484;
		  /* 82114484h */ case   13:  		/* lwz R9, <#[R26 + 20]> */
		/* 82114484h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000014) );
		/* 82114484h case   13:*/		return 0x82114488;
		  /* 82114488h */ case   14:  		/* lwzx R9, <#[R10 + R9]> */
		/* 82114488h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82114488h case   14:*/		return 0x8211448C;
		  /* 8211448Ch */ case   15:  		/* addi R10, R10, 4 */
		/* 8211448Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8211448Ch case   15:*/		return 0x82114490;
		  /* 82114490h */ case   16:  		/* stw R11, <#[R9 + 48]> */
		/* 82114490h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000030) );
		/* 82114490h case   16:*/		return 0x82114494;
		  /* 82114494h */ case   17:  		/* addi R11, R11, 1 */
		/* 82114494h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82114494h case   17:*/		return 0x82114498;
		  /* 82114498h */ case   18:  		/* lwz R9, <#[R26 + 8]> */
		/* 82114498h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000008) );
		/* 82114498h case   18:*/		return 0x8211449C;
		  /* 8211449Ch */ case   19:  		/* cmplw CR6, R11, R9 */
		/* 8211449Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8211449Ch case   19:*/		return 0x821144A0;
		  /* 821144A0h */ case   20:  		/* bc 12, CR6_LT, -28 */
		/* 821144A0h case   20:*/		if ( regs.CR[6].lt ) { return 0x82114484;  }
		/* 821144A0h case   20:*/		return 0x821144A4;
	}
	return 0x821144A4;
} // Block from 82114450h-821144A4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821144A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821144A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821144A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821144A4);
		  /* 821144A4h */ case    0:  		/* mr R3, R26 */
		/* 821144A4h case    0:*/		regs.R3 = regs.R26;
		/* 821144A4h case    0:*/		return 0x821144A8;
		  /* 821144A8h */ case    1:  		/* bl -59664 */
		/* 821144A8h case    1:*/		regs.LR = 0x821144AC; return 0x82105B98;
		/* 821144A8h case    1:*/		return 0x821144AC;
		  /* 821144ACh */ case    2:  		/* lwz R11, <#[R26 + 12]> */
		/* 821144ACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 821144ACh case    2:*/		return 0x821144B0;
		  /* 821144B0h */ case    3:  		/* li R20, -1 */
		/* 821144B0h case    3:*/		cpu::op::li<0>(regs,&regs.R20,0xFFFFFFFF);
		/* 821144B0h case    3:*/		return 0x821144B4;
		  /* 821144B4h */ case    4:  		/* mr R18, R22 */
		/* 821144B4h case    4:*/		regs.R18 = regs.R22;
		/* 821144B4h case    4:*/		return 0x821144B8;
		  /* 821144B8h */ case    5:  		/* mr R14, R20 */
		/* 821144B8h case    5:*/		regs.R14 = regs.R20;
		/* 821144B8h case    5:*/		return 0x821144BC;
		  /* 821144BCh */ case    6:  		/* mr R19, R20 */
		/* 821144BCh case    6:*/		regs.R19 = regs.R20;
		/* 821144BCh case    6:*/		return 0x821144C0;
		  /* 821144C0h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 821144C0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821144C0h case    7:*/		return 0x821144C4;
		  /* 821144C4h */ case    8:  		/* bc 4, CR6_GT, 4472 */
		/* 821144C4h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8211563C;  }
		/* 821144C4h case    8:*/		return 0x821144C8;
		  /* 821144C8h */ case    9:  		/* lis R11, -32256 */
		/* 821144C8h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821144C8h case    9:*/		return 0x821144CC;
		  /* 821144CCh */ case   10:  		/* lis R10, -32256 */
		/* 821144CCh case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 821144CCh case   10:*/		return 0x821144D0;
		  /* 821144D0h */ case   11:  		/* li R21, 1 */
		/* 821144D0h case   11:*/		cpu::op::li<0>(regs,&regs.R21,0x1);
		/* 821144D0h case   11:*/		return 0x821144D4;
		  /* 821144D4h */ case   12:  		/* lis R15, 4096 */
		/* 821144D4h case   12:*/		cpu::op::lis<0>(regs,&regs.R15,0x1000);
		/* 821144D4h case   12:*/		return 0x821144D8;
		  /* 821144D8h */ case   13:  		/* lis R16, 8192 */
		/* 821144D8h case   13:*/		cpu::op::lis<0>(regs,&regs.R16,0x2000);
		/* 821144D8h case   13:*/		return 0x821144DC;
		  /* 821144DCh */ case   14:  		/* lfd FR30, <#[R11 + 1848]> */
		/* 821144DCh case   14:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R11 + 0x00000738) );
		/* 821144DCh case   14:*/		return 0x821144E0;
		  /* 821144E0h */ case   15:  		/* lis R17, 12288 */
		/* 821144E0h case   15:*/		cpu::op::lis<0>(regs,&regs.R17,0x3000);
		/* 821144E0h case   15:*/		return 0x821144E4;
		  /* 821144E4h */ case   16:  		/* lfd FR31, <#[R10 + 1808]> */
		/* 821144E4h case   16:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R10 + 0x00000710) );
		/* 821144E4h case   16:*/		return 0x821144E8;
		  /* 821144E8h */ case   17:  		/* lwz R11, <#[R26 + 24]> */
		/* 821144E8h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000018) );
		/* 821144E8h case   17:*/		return 0x821144EC;
		  /* 821144ECh */ case   18:  		/* rlwinm R10, R18, 2, 0, 29 */
		/* 821144ECh case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R18);
		/* 821144ECh case   18:*/		return 0x821144F0;
		  /* 821144F0h */ case   19:  		/* lwzx R31, <#[R10 + R11]> */
		/* 821144F0h case   19:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821144F0h case   19:*/		return 0x821144F4;
		  /* 821144F4h */ case   20:  		/* lwz R9, <#[R31]> */
		/* 821144F4h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821144F4h case   20:*/		return 0x821144F8;
		  /* 821144F8h */ case   21:  		/* rlwinm. R10, R9, 0, 0, 11 */
		/* 821144F8h case   21:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R10,regs.R9);
		/* 821144F8h case   21:*/		return 0x821144FC;
		  /* 821144FCh */ case   22:  		/* bc 12, CR0_EQ, 4392 */
		/* 821144FCh case   22:*/		if ( regs.CR[0].eq ) { return 0x82115624;  }
		/* 821144FCh case   22:*/		return 0x82114500;
		  /* 82114500h */ case   23:  		/* lis R11, 4352 */
		/* 82114500h case   23:*/		cpu::op::lis<0>(regs,&regs.R11,0x1100);
		/* 82114500h case   23:*/		return 0x82114504;
		  /* 82114504h */ case   24:  		/* lwz R24, <#[R26 + 8]> */
		/* 82114504h case   24:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R26 + 0x00000008) );
		/* 82114504h case   24:*/		return 0x82114508;
		  /* 82114508h */ case   25:  		/* cmplw CR6, R10, R11 */
		/* 82114508h case   25:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82114508h case   25:*/		return 0x8211450C;
		  /* 8211450Ch */ case   26:  		/* bc 4, CR6_EQ, 100 */
		/* 8211450Ch case   26:*/		if ( !regs.CR[6].eq ) { return 0x82114570;  }
		/* 8211450Ch case   26:*/		return 0x82114510;
		  /* 82114510h */ case   27:  		/* lwz R7, <#[R31 + 4]> */
		/* 82114510h case   27:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000004) );
		/* 82114510h case   27:*/		return 0x82114514;
		  /* 82114514h */ case   28:  		/* mr R9, R22 */
		/* 82114514h case   28:*/		regs.R9 = regs.R22;
		/* 82114514h case   28:*/		return 0x82114518;
		  /* 82114518h */ case   29:  		/* cmplwi CR6, R7, 0 */
		/* 82114518h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82114518h case   29:*/		return 0x8211451C;
		  /* 8211451Ch */ case   30:  		/* bc 12, CR6_EQ, 72 */
		/* 8211451Ch case   30:*/		if ( regs.CR[6].eq ) { return 0x82114564;  }
		/* 8211451Ch case   30:*/		return 0x82114520;
		  /* 82114520h */ case   31:  		/* lwz R8, <#[R31 + 8]> */
		/* 82114520h case   31:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 82114520h case   31:*/		return 0x82114524;
		  /* 82114524h */ case   32:  		/* mr R11, R22 */
		/* 82114524h case   32:*/		regs.R11 = regs.R22;
		/* 82114524h case   32:*/		return 0x82114528;
		  /* 82114528h */ case   33:  		/* lwz R10, <#[R26 + 20]> */
		/* 82114528h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 82114528h case   33:*/		return 0x8211452C;
		  /* 8211452Ch */ case   34:  		/* lwzx R6, <#[R11 + R8]> */
		/* 8211452Ch case   34:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8211452Ch case   34:*/		return 0x82114530;
		  /* 82114530h */ case   35:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 82114530h case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 82114530h case   35:*/		return 0x82114534;
		  /* 82114534h */ case   36:  		/* lwzx R6, <#[R6 + R10]> */
		/* 82114534h case   36:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R10 + 0x00000000) );
		/* 82114534h case   36:*/		return 0x82114538;
		  /* 82114538h */ case   37:  		/* lwz R6, <#[R6 + 48]> */
		/* 82114538h case   37:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000030) );
		/* 82114538h case   37:*/		return 0x8211453C;
		  /* 8211453Ch */ case   38:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 8211453Ch case   38:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 8211453Ch case   38:*/		return 0x82114540;
		  /* 82114540h */ case   39:  		/* lwzx R6, <#[R6 + R10]> */
		/* 82114540h case   39:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R10 + 0x00000000) );
		/* 82114540h case   39:*/		return 0x82114544;
		  /* 82114544h */ case   40:  		/* lwz R6, <#[R6]> */
		/* 82114544h case   40:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000000) );
		/* 82114544h case   40:*/		return 0x82114548;
		  /* 82114548h */ case   41:  		/* rlwinm. R6, R6, 0, 29, 29 */
		/* 82114548h case   41:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R6,regs.R6);
		/* 82114548h case   41:*/		return 0x8211454C;
		  /* 8211454Ch */ case   42:  		/* bc 12, CR0_EQ, 24 */
		/* 8211454Ch case   42:*/		if ( regs.CR[0].eq ) { return 0x82114564;  }
		/* 8211454Ch case   42:*/		return 0x82114550;
		  /* 82114550h */ case   43:  		/* lwz R6, <#[R31 + 4]> */
		/* 82114550h case   43:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000004) );
		/* 82114550h case   43:*/		return 0x82114554;
		  /* 82114554h */ case   44:  		/* addi R9, R9, 1 */
		/* 82114554h case   44:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82114554h case   44:*/		return 0x82114558;
		  /* 82114558h */ case   45:  		/* addi R11, R11, 4 */
		/* 82114558h case   45:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82114558h case   45:*/		return 0x8211455C;
		  /* 8211455Ch */ case   46:  		/* cmplw CR6, R9, R6 */
		/* 8211455Ch case   46:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 8211455Ch case   46:*/		return 0x82114560;
		  /* 82114560h */ case   47:  		/* bc 12, CR6_LT, -52 */
		/* 82114560h case   47:*/		if ( regs.CR[6].lt ) { return 0x8211452C;  }
		/* 82114560h case   47:*/		return 0x82114564;
	}
	return 0x82114564;
} // Block from 821144A4h-82114564h (48 instructions)

//////////////////////////////////////////////////////
// Block at 82114564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114564);
		  /* 82114564h */ case    0:  		/* cmplw CR6, R9, R7 */
		/* 82114564h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 82114564h case    0:*/		return 0x82114568;
		  /* 82114568h */ case    1:  		/* bc 4, CR6_EQ, 4020 */
		/* 82114568h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8211551C;  }
		/* 82114568h case    1:*/		return 0x8211456C;
		  /* 8211456Ch */ case    2:  		/* b 4000 */
		/* 8211456Ch case    2:*/		return 0x8211550C;
		/* 8211456Ch case    2:*/		return 0x82114570;
	}
	return 0x82114570;
} // Block from 82114564h-82114570h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82114570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114570);
		  /* 82114570h */ case    0:  		/* rlwinm R11, R9, 0, 0, 3 */
		/* 82114570h case    0:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R11,regs.R9);
		/* 82114570h case    0:*/		return 0x82114574;
		  /* 82114574h */ case    1:  		/* cmplw CR6, R11, R15 */
		/* 82114574h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R15);
		/* 82114574h case    1:*/		return 0x82114578;
		  /* 82114578h */ case    2:  		/* bc 4, CR6_EQ, 632 */
		/* 82114578h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821147F0;  }
		/* 82114578h case    2:*/		return 0x8211457C;
		  /* 8211457Ch */ case    3:  		/* lwz R11, <#[R31 + 12]> */
		/* 8211457Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8211457Ch case    3:*/		return 0x82114580;
		  /* 82114580h */ case    4:  		/* mr R27, R22 */
		/* 82114580h case    4:*/		regs.R27 = regs.R22;
		/* 82114580h case    4:*/		return 0x82114584;
		  /* 82114584h */ case    5:  		/* mr R28, R22 */
		/* 82114584h case    5:*/		regs.R28 = regs.R22;
		/* 82114584h case    5:*/		return 0x82114588;
		  /* 82114588h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82114588h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82114588h case    6:*/		return 0x8211458C;
		  /* 8211458Ch */ case    7:  		/* bc 4, CR6_GT, 360 */
		/* 8211458Ch case    7:*/		if ( !regs.CR[6].gt ) { return 0x821146F4;  }
		/* 8211458Ch case    7:*/		return 0x82114590;
		  /* 82114590h */ case    8:  		/* mr R29, R22 */
		/* 82114590h case    8:*/		regs.R29 = regs.R22;
		/* 82114590h case    8:*/		return 0x82114594;
		  /* 82114594h */ case    9:  		/* lwz R10, <#[R31 + 8]> */
		/* 82114594h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82114594h case    9:*/		return 0x82114598;
		  /* 82114598h */ case   10:  		/* lwz R8, <#[R31]> */
		/* 82114598h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 82114598h case   10:*/		return 0x8211459C;
		  /* 8211459Ch */ case   11:  		/* lwz R9, <#[R31 + 16]> */
		/* 8211459Ch case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 8211459Ch case   11:*/		return 0x821145A0;
		  /* 821145A0h */ case   12:  		/* lwz R11, <#[R26 + 20]> */
		/* 821145A0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 821145A0h case   12:*/		return 0x821145A4;
		  /* 821145A4h */ case   13:  		/* lwzx R7, <#[R29 + R10]> */
		/* 821145A4h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R29 + regs.R10 + 0x00000000) );
		/* 821145A4h case   13:*/		return 0x821145A8;
		  /* 821145A8h */ case   14:  		/* rlwinm R10, R8, 0, 0, 11 */
		/* 821145A8h case   14:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R8);
		/* 821145A8h case   14:*/		return 0x821145AC;
		  /* 821145ACh */ case   15:  		/* rlwinm R8, R7, 2, 0, 29 */
		/* 821145ACh case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R7);
		/* 821145ACh case   15:*/		return 0x821145B0;
		  /* 821145B0h */ case   16:  		/* lwzx R30, <#[R29 + R9]> */
		/* 821145B0h case   16:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + regs.R9 + 0x00000000) );
		/* 821145B0h case   16:*/		return 0x821145B4;
		  /* 821145B4h */ case   17:  		/* cmplw CR6, R10, R15 */
		/* 821145B4h case   17:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R15);
		/* 821145B4h case   17:*/		return 0x821145B8;
		  /* 821145B8h */ case   18:  		/* lwzx R9, <#[R8 + R11]> */
		/* 821145B8h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 821145B8h case   18:*/		return 0x821145BC;
		  /* 821145BCh */ case   19:  		/* lwz R6, <#[R9 + 48]> */
		/* 821145BCh case   19:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + 0x00000030) );
		/* 821145BCh case   19:*/		return 0x821145C0;
		  /* 821145C0h */ case   20:  		/* bc 12, CR6_EQ, 16 */
		/* 821145C0h case   20:*/		if ( regs.CR[6].eq ) { return 0x821145D0;  }
		/* 821145C0h case   20:*/		return 0x821145C4;
		  /* 821145C4h */ case   21:  		/* lis R9, 4112 */
		/* 821145C4h case   21:*/		cpu::op::lis<0>(regs,&regs.R9,0x1010);
		/* 821145C4h case   21:*/		return 0x821145C8;
		  /* 821145C8h */ case   22:  		/* cmplw CR6, R10, R9 */
		/* 821145C8h case   22:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821145C8h case   22:*/		return 0x821145CC;
		  /* 821145CCh */ case   23:  		/* bc 4, CR6_EQ, 180 */
		/* 821145CCh case   23:*/		if ( !regs.CR[6].eq ) { return 0x82114680;  }
		/* 821145CCh case   23:*/		return 0x821145D0;
	}
	return 0x821145D0;
} // Block from 82114570h-821145D0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821145D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821145D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821145D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821145D0);
		  /* 821145D0h */ case    0:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 821145D0h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 821145D0h case    0:*/		return 0x821145D4;
		  /* 821145D4h */ case    1:  		/* rlwinm R9, R6, 2, 0, 29 */
		/* 821145D4h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R6);
		/* 821145D4h case    1:*/		return 0x821145D8;
		  /* 821145D8h */ case    2:  		/* lwzx R8, <#[R10 + R11]> */
		/* 821145D8h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821145D8h case    2:*/		return 0x821145DC;
		  /* 821145DCh */ case    3:  		/* lwzx R9, <#[R9 + R11]> */
		/* 821145DCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821145DCh case    3:*/		return 0x821145E0;
		  /* 821145E0h */ case    4:  		/* lwz R10, <#[R8]> */
		/* 821145E0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 821145E0h case    4:*/		return 0x821145E4;
		  /* 821145E4h */ case    5:  		/* lwz R11, <#[R9]> */
		/* 821145E4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 821145E4h case    5:*/		return 0x821145E8;
	}
	return 0x821145E8;
} // Block from 821145D0h-821145E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821145E8h
// Function '?CompactPool_Write@CProgram@D3DXShader@@AAAJPAU_D3DXCP_DATA@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821145E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821145E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821145E8);
		  /* 821145E8h */ case    0:  		/* or R11, R11, R10 */
		/* 821145E8h case    0:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821145E8h case    0:*/		return 0x821145EC;
		  /* 821145ECh */ case    1:  		/* rlwinm R11, R11, 0, 4, 6 */
		/* 821145ECh case    1:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821145ECh case    1:*/		return 0x821145F0;
		  /* 821145F0h */ case    2:  		/* rlwinm. R7, R11, 0, 6, 6 */
		/* 821145F0h case    2:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R7,regs.R11);
		/* 821145F0h case    2:*/		return 0x821145F4;
		  /* 821145F4h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 821145F4h case    3:*/		if ( regs.CR[0].eq ) { return 0x82114600;  }
		/* 821145F4h case    3:*/		return 0x821145F8;
		  /* 821145F8h */ case    4:  		/* lis R11, 512 */
		/* 821145F8h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0x200);
		/* 821145F8h case    4:*/		return 0x821145FC;
		  /* 821145FCh */ case    5:  		/* b 32 */
		/* 821145FCh case    5:*/		return 0x8211461C;
		/* 821145FCh case    5:*/		return 0x82114600;
	}
	return 0x82114600;
} // Block from 821145E8h-82114600h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82114600h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114600);
		  /* 82114600h */ case    0:  		/* rlwinm. R7, R11, 0, 5, 5 */
		/* 82114600h case    0:*/		cpu::op::rlwinm<1,0,5,5>(regs,&regs.R7,regs.R11);
		/* 82114600h case    0:*/		return 0x82114604;
		  /* 82114604h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82114604h case    1:*/		if ( regs.CR[0].eq ) { return 0x82114610;  }
		/* 82114604h case    1:*/		return 0x82114608;
		  /* 82114608h */ case    2:  		/* lis R11, 1024 */
		/* 82114608h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x400);
		/* 82114608h case    2:*/		return 0x8211460C;
		  /* 8211460Ch */ case    3:  		/* b 16 */
		/* 8211460Ch case    3:*/		return 0x8211461C;
		/* 8211460Ch case    3:*/		return 0x82114610;
	}
	return 0x82114610;
} // Block from 82114600h-82114610h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82114610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114610);
		  /* 82114610h */ case    0:  		/* rlwinm. R7, R11, 0, 4, 4 */
		/* 82114610h case    0:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R7,regs.R11);
		/* 82114610h case    0:*/		return 0x82114614;
		  /* 82114614h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 82114614h case    1:*/		if ( regs.CR[0].eq ) { return 0x8211461C;  }
		/* 82114614h case    1:*/		return 0x82114618;
		  /* 82114618h */ case    2:  		/* lis R11, 2048 */
		/* 82114618h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x800);
		/* 82114618h case    2:*/		return 0x8211461C;
	}
	return 0x8211461C;
} // Block from 82114610h-8211461Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8211461Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211461C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211461C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211461C);
		  /* 8211461Ch */ case    0:  		/* rlwinm R7, R10, 0, 4, 6 */
		/* 8211461Ch case    0:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R7,regs.R10);
		/* 8211461Ch case    0:*/		return 0x82114620;
		  /* 82114620h */ case    1:  		/* cmplw CR6, R11, R7 */
		/* 82114620h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 82114620h case    1:*/		return 0x82114624;
		  /* 82114624h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 82114624h case    2:*/		if ( regs.CR[6].eq ) { return 0x82114638;  }
		/* 82114624h case    2:*/		return 0x82114628;
		  /* 82114628h */ case    3:  		/* rlwinm R10, R10, 0, 7, 3 */
		/* 82114628h case    3:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R10,regs.R10);
		/* 82114628h case    3:*/		return 0x8211462C;
		  /* 8211462Ch */ case    4:  		/* mr R23, R21 */
		/* 8211462Ch case    4:*/		regs.R23 = regs.R21;
		/* 8211462Ch case    4:*/		return 0x82114630;
		  /* 82114630h */ case    5:  		/* or R10, R10, R11 */
		/* 82114630h case    5:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82114630h case    5:*/		return 0x82114634;
		  /* 82114634h */ case    6:  		/* stw R10, <#[R8]> */
		/* 82114634h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 82114634h case    6:*/		return 0x82114638;
	}
	return 0x82114638;
} // Block from 8211461Ch-82114638h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82114638h
// Function '?CompactPool_Process@CProgram@D3DXShader@@IAAJPAU_D3DXCP_DATA@2@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114638);
		  /* 82114638h */ case    0:  		/* lwz R10, <#[R9]> */
		/* 82114638h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 82114638h case    0:*/		return 0x8211463C;
		  /* 8211463Ch */ case    1:  		/* rlwinm R8, R10, 0, 4, 6 */
		/* 8211463Ch case    1:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R8,regs.R10);
		/* 8211463Ch case    1:*/		return 0x82114640;
		  /* 82114640h */ case    2:  		/* cmplw CR6, R11, R8 */
		/* 82114640h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 82114640h case    2:*/		return 0x82114644;
		  /* 82114644h */ case    3:  		/* bc 12, CR6_EQ, 60 */
		/* 82114644h case    3:*/		if ( regs.CR[6].eq ) { return 0x82114680;  }
		/* 82114644h case    3:*/		return 0x82114648;
		  /* 82114648h */ case    4:  		/* lwz R8, <#[R9 + 4]> */
		/* 82114648h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000004) );
		/* 82114648h case    4:*/		return 0x8211464C;
		  /* 8211464Ch */ case    5:  		/* lwz R7, <#[R26 + 16]> */
		/* 8211464Ch case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R26 + 0x00000010) );
		/* 8211464Ch case    5:*/		return 0x82114650;
		  /* 82114650h */ case    6:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82114650h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82114650h case    6:*/		return 0x82114654;
		  /* 82114654h */ case    7:  		/* lwzx R8, <#[R8 + R7]> */
		/* 82114654h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 82114654h case    7:*/		return 0x82114658;
		  /* 82114658h */ case    8:  		/* lwz R8, <#[R8 + 4]> */
		/* 82114658h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 82114658h case    8:*/		return 0x8211465C;
		  /* 8211465Ch */ case    9:  		/* rlwinm. R8, R8, 0, 30, 30 */
		/* 8211465Ch case    9:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R8,regs.R8);
		/* 8211465Ch case    9:*/		return 0x82114660;
		  /* 82114660h */ case   10:  		/* bc 12, CR0_EQ, 32 */
		/* 82114660h case   10:*/		if ( regs.CR[0].eq ) { return 0x82114680;  }
		/* 82114660h case   10:*/		return 0x82114664;
		  /* 82114664h */ case   11:  		/* lwz R8, <#[R9 + 92]> */
		/* 82114664h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x0000005C) );
		/* 82114664h case   11:*/		return 0x82114668;
		  /* 82114668h */ case   12:  		/* cmplwi CR6, R8, 1 */
		/* 82114668h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000001);
		/* 82114668h case   12:*/		return 0x8211466C;
		  /* 8211466Ch */ case   13:  		/* bc 4, CR6_EQ, 20 */
		/* 8211466Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x82114680;  }
		/* 8211466Ch case   13:*/		return 0x82114670;
		  /* 82114670h */ case   14:  		/* rlwinm R10, R10, 0, 7, 3 */
		/* 82114670h case   14:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R10,regs.R10);
		/* 82114670h case   14:*/		return 0x82114674;
		  /* 82114674h */ case   15:  		/* mr R23, R21 */
		/* 82114674h case   15:*/		regs.R23 = regs.R21;
		/* 82114674h case   15:*/		return 0x82114678;
		  /* 82114678h */ case   16:  		/* or R11, R10, R11 */
		/* 82114678h case   16:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82114678h case   16:*/		return 0x8211467C;
		  /* 8211467Ch */ case   17:  		/* stw R11, <#[R9]> */
		/* 8211467Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8211467Ch case   17:*/		return 0x82114680;
	}
	return 0x82114680;
} // Block from 82114638h-82114680h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82114680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114680);
		  /* 82114680h */ case    0:  		/* mr R5, R30 */
		/* 82114680h case    0:*/		regs.R5 = regs.R30;
		/* 82114680h case    0:*/		return 0x82114684;
		  /* 82114684h */ case    1:  		/* mr R4, R31 */
		/* 82114684h case    1:*/		regs.R4 = regs.R31;
		/* 82114684h case    1:*/		return 0x82114688;
		  /* 82114688h */ case    2:  		/* mr R3, R26 */
		/* 82114688h case    2:*/		regs.R3 = regs.R26;
		/* 82114688h case    2:*/		return 0x8211468C;
		  /* 8211468Ch */ case    3:  		/* bl -11756 */
		/* 8211468Ch case    3:*/		regs.LR = 0x82114690; return 0x821118A0;
		/* 8211468Ch case    3:*/		return 0x82114690;
		  /* 82114690h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 82114690h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82114690h case    4:*/		return 0x82114694;
		  /* 82114694h */ case    5:  		/* bc 12, CR0_LT, 4048 */
		/* 82114694h case    5:*/		if ( regs.CR[0].lt ) { return 0x82115664;  }
		/* 82114694h case    5:*/		return 0x82114698;
		  /* 82114698h */ case    6:  		/* lwz R11, <#[R26 + 20]> */
		/* 82114698h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82114698h case    6:*/		return 0x8211469C;
		  /* 8211469Ch */ case    7:  		/* rlwinm R9, R30, 2, 0, 29 */
		/* 8211469Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R30);
		/* 8211469Ch case    7:*/		return 0x821146A0;
		  /* 821146A0h */ case    8:  		/* lwzx R10, <#[R9 + R11]> */
		/* 821146A0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821146A0h case    8:*/		return 0x821146A4;
		  /* 821146A4h */ case    9:  		/* lwz R10, <#[R10 + 48]> */
		/* 821146A4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 821146A4h case    9:*/		return 0x821146A8;
		  /* 821146A8h */ case   10:  		/* cmplw CR6, R10, R30 */
		/* 821146A8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R30);
		/* 821146A8h case   10:*/		return 0x821146AC;
		  /* 821146ACh */ case   11:  		/* bc 4, CR6_EQ, 12 */
		/* 821146ACh case   11:*/		if ( !regs.CR[6].eq ) { return 0x821146B8;  }
		/* 821146ACh case   11:*/		return 0x821146B0;
		  /* 821146B0h */ case   12:  		/* addi R27, R27, 1 */
		/* 821146B0h case   12:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 821146B0h case   12:*/		return 0x821146B4;
		  /* 821146B4h */ case   13:  		/* b 44 */
		/* 821146B4h case   13:*/		return 0x821146E0;
		/* 821146B4h case   13:*/		return 0x821146B8;
	}
	return 0x821146B8;
} // Block from 82114680h-821146B8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821146B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821146B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821146B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821146B8);
		  /* 821146B8h */ case    0:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821146B8h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821146B8h case    0:*/		return 0x821146BC;
		  /* 821146BCh */ case    1:  		/* lwzx R10, <#[R10 + R11]> */
		/* 821146BCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821146BCh case    1:*/		return 0x821146C0;
		  /* 821146C0h */ case    2:  		/* lwz R10, <#[R10 + 48]> */
		/* 821146C0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 821146C0h case    2:*/		return 0x821146C4;
		  /* 821146C4h */ case    3:  		/* cmpwi CR6, R10, -1 */
		/* 821146C4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 821146C4h case    3:*/		return 0x821146C8;
		  /* 821146C8h */ case    4:  		/* bc 4, CR6_EQ, 24 */
		/* 821146C8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821146E0;  }
		/* 821146C8h case    4:*/		return 0x821146CC;
		  /* 821146CCh */ case    5:  		/* lwzx R10, <#[R9 + R11]> */
		/* 821146CCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821146CCh case    5:*/		return 0x821146D0;
		  /* 821146D0h */ case    6:  		/* lwz R10, <#[R10 + 48]> */
		/* 821146D0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 821146D0h case    6:*/		return 0x821146D4;
		  /* 821146D4h */ case    7:  		/* rlwinm R9, R10, 2, 0, 29 */
		/* 821146D4h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R10);
		/* 821146D4h case    7:*/		return 0x821146D8;
		  /* 821146D8h */ case    8:  		/* lwzx R11, <#[R9 + R11]> */
		/* 821146D8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821146D8h case    8:*/		return 0x821146DC;
		  /* 821146DCh */ case    9:  		/* stw R10, <#[R11 + 48]> */
		/* 821146DCh case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 821146DCh case    9:*/		return 0x821146E0;
	}
	return 0x821146E0;
} // Block from 821146B8h-821146E0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821146E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821146E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821146E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821146E0);
		  /* 821146E0h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 821146E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821146E0h case    0:*/		return 0x821146E4;
		  /* 821146E4h */ case    1:  		/* addi R28, R28, 1 */
		/* 821146E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 821146E4h case    1:*/		return 0x821146E8;
		  /* 821146E8h */ case    2:  		/* addi R29, R29, 4 */
		/* 821146E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 821146E8h case    2:*/		return 0x821146EC;
		  /* 821146ECh */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 821146ECh case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 821146ECh case    3:*/		return 0x821146F0;
		  /* 821146F0h */ case    4:  		/* bc 12, CR6_LT, -348 */
		/* 821146F0h case    4:*/		if ( regs.CR[6].lt ) { return 0x82114594;  }
		/* 821146F0h case    4:*/		return 0x821146F4;
	}
	return 0x821146F4;
} // Block from 821146E0h-821146F4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821146F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821146F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821146F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821146F4);
		  /* 821146F4h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 821146F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821146F4h case    0:*/		return 0x821146F8;
		  /* 821146F8h */ case    1:  		/* cmplw CR6, R27, R11 */
		/* 821146F8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 821146F8h case    1:*/		return 0x821146FC;
		  /* 821146FCh */ case    2:  		/* bc 12, CR6_EQ, 3616 */
		/* 821146FCh case    2:*/		if ( regs.CR[6].eq ) { return 0x8211551C;  }
		/* 821146FCh case    2:*/		return 0x82114700;
		  /* 82114700h */ case    3:  		/* mr R6, R22 */
		/* 82114700h case    3:*/		regs.R6 = regs.R22;
		/* 82114700h case    3:*/		return 0x82114704;
		  /* 82114704h */ case    4:  		/* mr R5, R22 */
		/* 82114704h case    4:*/		regs.R5 = regs.R22;
		/* 82114704h case    4:*/		return 0x82114708;
		  /* 82114708h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82114708h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82114708h case    5:*/		return 0x8211470C;
		  /* 8211470Ch */ case    6:  		/* bc 12, CR6_EQ, 208 */
		/* 8211470Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x821147DC;  }
		/* 8211470Ch case    6:*/		return 0x82114710;
		  /* 82114710h */ case    7:  		/* mr R9, R22 */
		/* 82114710h case    7:*/		regs.R9 = regs.R22;
		/* 82114710h case    7:*/		return 0x82114714;
		  /* 82114714h */ case    8:  		/* mr R7, R22 */
		/* 82114714h case    8:*/		regs.R7 = regs.R22;
		/* 82114714h case    8:*/		return 0x82114718;
		  /* 82114718h */ case    9:  		/* lwz R8, <#[R31 + 16]> */
		/* 82114718h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000010) );
		/* 82114718h case    9:*/		return 0x8211471C;
		  /* 8211471Ch */ case   10:  		/* lwz R10, <#[R26 + 20]> */
		/* 8211471Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 8211471Ch case   10:*/		return 0x82114720;
		  /* 82114720h */ case   11:  		/* lwzx R11, <#[R9 + R8]> */
		/* 82114720h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82114720h case   11:*/		return 0x82114724;
		  /* 82114724h */ case   12:  		/* rlwinm R4, R11, 2, 0, 29 */
		/* 82114724h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R11);
		/* 82114724h case   12:*/		return 0x82114728;
		  /* 82114728h */ case   13:  		/* lwzx R4, <#[R4 + R10]> */
		/* 82114728h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + regs.R10 + 0x00000000) );
		/* 82114728h case   13:*/		return 0x8211472C;
		  /* 8211472Ch */ case   14:  		/* lwz R4, <#[R4 + 48]> */
		/* 8211472Ch case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000030) );
		/* 8211472Ch case   14:*/		return 0x82114730;
		  /* 82114730h */ case   15:  		/* cmplw CR6, R4, R11 */
		/* 82114730h case   15:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 82114730h case   15:*/		return 0x82114734;
		  /* 82114734h */ case   16:  		/* bc 4, CR6_EQ, 32 */
		/* 82114734h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82114754;  }
		/* 82114734h case   16:*/		return 0x82114738;
		  /* 82114738h */ case   17:  		/* stwx R11, <#[R7 + R8]> */
		/* 82114738h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 82114738h case   17:*/		return 0x8211473C;
		  /* 8211473Ch */ case   18:  		/* addi R6, R6, 1 */
		/* 8211473Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8211473Ch case   18:*/		return 0x82114740;
		  /* 82114740h */ case   19:  		/* lwz R11, <#[R31 + 8]> */
		/* 82114740h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82114740h case   19:*/		return 0x82114744;
		  /* 82114744h */ case   20:  		/* lwzx R10, <#[R9 + R11]> */
		/* 82114744h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82114744h case   20:*/		return 0x82114748;
		  /* 82114748h */ case   21:  		/* stwx R10, <#[R7 + R11]> */
		/* 82114748h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 82114748h case   21:*/		return 0x8211474C;
		  /* 8211474Ch */ case   22:  		/* addi R7, R7, 4 */
		/* 8211474Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 8211474Ch case   22:*/		return 0x82114750;
		  /* 82114750h */ case   23:  		/* b 100 */
		/* 82114750h case   23:*/		return 0x821147B4;
		/* 82114750h case   23:*/		return 0x82114754;
	}
	return 0x82114754;
} // Block from 821146F4h-82114754h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82114754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114754);
		  /* 82114754h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82114754h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82114754h case    0:*/		return 0x82114758;
		  /* 82114758h */ case    1:  		/* lwz R4, <#[R26 + 16]> */
		/* 82114758h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000010) );
		/* 82114758h case    1:*/		return 0x8211475C;
		  /* 8211475Ch */ case    2:  		/* lwzx R8, <#[R11 + R10]> */
		/* 8211475Ch case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8211475Ch case    2:*/		return 0x82114760;
		  /* 82114760h */ case    3:  		/* lwz R11, <#[R8 + 48]> */
		/* 82114760h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000030) );
		/* 82114760h case    3:*/		return 0x82114764;
		  /* 82114764h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82114764h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82114764h case    4:*/		return 0x82114768;
		  /* 82114768h */ case    5:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82114768h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82114768h case    5:*/		return 0x8211476C;
		  /* 8211476Ch */ case    6:  		/* lwz R10, <#[R11 + 4]> */
		/* 8211476Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8211476Ch case    6:*/		return 0x82114770;
		  /* 82114770h */ case    7:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82114770h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82114770h case    7:*/		return 0x82114774;
		  /* 82114774h */ case    8:  		/* lwzx R10, <#[R10 + R4]> */
		/* 82114774h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 82114774h case    8:*/		return 0x82114778;
		  /* 82114778h */ case    9:  		/* lwz R10, <#[R10 + 4]> */
		/* 82114778h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82114778h case    9:*/		return 0x8211477C;
		  /* 8211477Ch */ case   10:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 8211477Ch case   10:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 8211477Ch case   10:*/		return 0x82114780;
		  /* 82114780h */ case   11:  		/* bc 12, CR0_EQ, 52 */
		/* 82114780h case   11:*/		if ( regs.CR[0].eq ) { return 0x821147B4;  }
		/* 82114780h case   11:*/		return 0x82114784;
		  /* 82114784h */ case   12:  		/* lwz R10, <#[R11 + 96]> */
		/* 82114784h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000060) );
		/* 82114784h case   12:*/		return 0x82114788;
		  /* 82114788h */ case   13:  		/* cmplwi CR6, R10, 0 */
		/* 82114788h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82114788h case   13:*/		return 0x8211478C;
		  /* 8211478Ch */ case   14:  		/* bc 4, CR6_EQ, 40 */
		/* 8211478Ch case   14:*/		if ( !regs.CR[6].eq ) { return 0x821147B4;  }
		/* 8211478Ch case   14:*/		return 0x82114790;
		  /* 82114790h */ case   15:  		/* lwz R10, <#[R8 + 96]> */
		/* 82114790h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000060) );
		/* 82114790h case   15:*/		return 0x82114794;
		  /* 82114794h */ case   16:  		/* stw R10, <#[R11 + 96]> */
		/* 82114794h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000060) );
		/* 82114794h case   16:*/		return 0x82114798;
		  /* 82114798h */ case   17:  		/* lwz R8, <#[R31 + 16]> */
		/* 82114798h case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000010) );
		/* 82114798h case   17:*/		return 0x8211479C;
		  /* 8211479Ch */ case   18:  		/* lwz R10, <#[R26 + 20]> */
		/* 8211479Ch case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 8211479Ch case   18:*/		return 0x821147A0;
		  /* 821147A0h */ case   19:  		/* lwzx R8, <#[R9 + R8]> */
		/* 821147A0h case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 821147A0h case   19:*/		return 0x821147A4;
		  /* 821147A4h */ case   20:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 821147A4h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 821147A4h case   20:*/		return 0x821147A8;
		  /* 821147A8h */ case   21:  		/* lwzx R10, <#[R8 + R10]> */
		/* 821147A8h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 821147A8h case   21:*/		return 0x821147AC;
		  /* 821147ACh */ case   22:  		/* lwz R10, <#[R10 + 100]> */
		/* 821147ACh case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000064) );
		/* 821147ACh case   22:*/		return 0x821147B0;
		  /* 821147B0h */ case   23:  		/* stw R10, <#[R11 + 100]> */
		/* 821147B0h case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000064) );
		/* 821147B0h case   23:*/		return 0x821147B4;
	}
	return 0x821147B4;
} // Block from 82114754h-821147B4h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821147B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821147B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821147B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821147B4);
		  /* 821147B4h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 821147B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821147B4h case    0:*/		return 0x821147B8;
		  /* 821147B8h */ case    1:  		/* addi R5, R5, 1 */
		/* 821147B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 821147B8h case    1:*/		return 0x821147BC;
		  /* 821147BCh */ case    2:  		/* addi R9, R9, 4 */
		/* 821147BCh case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 821147BCh case    2:*/		return 0x821147C0;
		  /* 821147C0h */ case    3:  		/* cmplw CR6, R5, R11 */
		/* 821147C0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 821147C0h case    3:*/		return 0x821147C4;
		  /* 821147C4h */ case    4:  		/* bc 12, CR6_LT, -172 */
		/* 821147C4h case    4:*/		if ( regs.CR[6].lt ) { return 0x82114718;  }
		/* 821147C4h case    4:*/		return 0x821147C8;
		  /* 821147C8h */ case    5:  		/* cmplwi CR6, R6, 0 */
		/* 821147C8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 821147C8h case    5:*/		return 0x821147CC;
		  /* 821147CCh */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 821147CCh case    6:*/		if ( regs.CR[6].eq ) { return 0x821147DC;  }
		/* 821147CCh case    6:*/		return 0x821147D0;
		  /* 821147D0h */ case    7:  		/* lwz R11, <#[R31]> */
		/* 821147D0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821147D0h case    7:*/		return 0x821147D4;
		  /* 821147D4h */ case    8:  		/* rlwimi R11, R6, 0, 12, 31 */
		/* 821147D4h case    8:*/		cpu::op::rlwimi<0,0,12,31>(regs,&regs.R11,regs.R6);
		/* 821147D4h case    8:*/		return 0x821147D8;
		  /* 821147D8h */ case    9:  		/* b 8 */
		/* 821147D8h case    9:*/		return 0x821147E0;
		/* 821147D8h case    9:*/		return 0x821147DC;
	}
	return 0x821147DC;
} // Block from 821147B4h-821147DCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 821147DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821147DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821147DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821147DC);
		  /* 821147DCh */ case    0:  		/* mr R11, R22 */
		/* 821147DCh case    0:*/		regs.R11 = regs.R22;
		/* 821147DCh case    0:*/		return 0x821147E0;
	}
	return 0x821147E0;
} // Block from 821147DCh-821147E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821147E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821147E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821147E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821147E0);
		  /* 821147E0h */ case    0:  		/* stw R11, <#[R31]> */
		/* 821147E0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821147E0h case    0:*/		return 0x821147E4;
		  /* 821147E4h */ case    1:  		/* stw R6, <#[R31 + 4]> */
		/* 821147E4h case    1:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R31 + 0x00000004) );
		/* 821147E4h case    1:*/		return 0x821147E8;
		  /* 821147E8h */ case    2:  		/* stw R6, <#[R31 + 12]> */
		/* 821147E8h case    2:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R31 + 0x0000000C) );
		/* 821147E8h case    2:*/		return 0x821147EC;
		  /* 821147ECh */ case    3:  		/* b 3372 */
		/* 821147ECh case    3:*/		return 0x82115518;
		/* 821147ECh case    3:*/		return 0x821147F0;
	}
	return 0x821147F0;
} // Block from 821147E0h-821147F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821147F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821147F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821147F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821147F0);
		  /* 821147F0h */ case    0:  		/* cmplw CR6, R11, R16 */
		/* 821147F0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R16);
		/* 821147F0h case    0:*/		return 0x821147F4;
		  /* 821147F4h */ case    1:  		/* bc 4, CR6_EQ, 1416 */
		/* 821147F4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82114D7C;  }
		/* 821147F4h case    1:*/		return 0x821147F8;
		  /* 821147F8h */ case    2:  		/* lwz R11, <#[R31 + 12]> */
		/* 821147F8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821147F8h case    2:*/		return 0x821147FC;
		  /* 821147FCh */ case    3:  		/* mr R25, R22 */
		/* 821147FCh case    3:*/		regs.R25 = regs.R22;
		/* 821147FCh case    3:*/		return 0x82114800;
		  /* 82114800h */ case    4:  		/* mr R28, R22 */
		/* 82114800h case    4:*/		regs.R28 = regs.R22;
		/* 82114800h case    4:*/		return 0x82114804;
		  /* 82114804h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82114804h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82114804h case    5:*/		return 0x82114808;
		  /* 82114808h */ case    6:  		/* bc 4, CR6_GT, 492 */
		/* 82114808h case    6:*/		if ( !regs.CR[6].gt ) { return 0x821149F4;  }
		/* 82114808h case    6:*/		return 0x8211480C;
		  /* 8211480Ch */ case    7:  		/* mr R29, R22 */
		/* 8211480Ch case    7:*/		regs.R29 = regs.R22;
		/* 8211480Ch case    7:*/		return 0x82114810;
		  /* 82114810h */ case    8:  		/* lwz R11, <#[R31 + 12]> */
		/* 82114810h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82114810h case    8:*/		return 0x82114814;
		  /* 82114814h */ case    9:  		/* lwz R9, <#[R31 + 8]> */
		/* 82114814h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82114814h case    9:*/		return 0x82114818;
		  /* 82114818h */ case   10:  		/* add R10, R28, R11 */
		/* 82114818h case   10:*/		cpu::op::add<0>(regs,&regs.R10,regs.R28,regs.R11);
		/* 82114818h case   10:*/		return 0x8211481C;
		  /* 8211481Ch */ case   11:  		/* lwz R8, <#[R31 + 16]> */
		/* 8211481Ch case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000010) );
		/* 8211481Ch case   11:*/		return 0x82114820;
		  /* 82114820h */ case   12:  		/* lwz R11, <#[R26 + 20]> */
		/* 82114820h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82114820h case   12:*/		return 0x82114824;
		  /* 82114824h */ case   13:  		/* rlwinm R7, R10, 2, 0, 29 */
		/* 82114824h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R10);
		/* 82114824h case   13:*/		return 0x82114828;
		  /* 82114828h */ case   14:  		/* lwz R10, <#[R31]> */
		/* 82114828h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82114828h case   14:*/		return 0x8211482C;
		  /* 8211482Ch */ case   15:  		/* lwzx R6, <#[R29 + R9]> */
		/* 8211482Ch case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R29 + regs.R9 + 0x00000000) );
		/* 8211482Ch case   15:*/		return 0x82114830;
		  /* 82114830h */ case   16:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 82114830h case   16:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 82114830h case   16:*/		return 0x82114834;
		  /* 82114834h */ case   17:  		/* lwzx R30, <#[R29 + R8]> */
		/* 82114834h case   17:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + regs.R8 + 0x00000000) );
		/* 82114834h case   17:*/		return 0x82114838;
		  /* 82114838h */ case   18:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 82114838h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 82114838h case   18:*/		return 0x8211483C;
		  /* 8211483Ch */ case   19:  		/* lwzx R9, <#[R7 + R9]> */
		/* 8211483Ch case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 8211483Ch case   19:*/		return 0x82114840;
		  /* 82114840h */ case   20:  		/* cmplw CR6, R10, R16 */
		/* 82114840h case   20:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R16);
		/* 82114840h case   20:*/		return 0x82114844;
		  /* 82114844h */ case   21:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82114844h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82114844h case   21:*/		return 0x82114848;
		  /* 82114848h */ case   22:  		/* lwzx R8, <#[R6 + R11]> */
		/* 82114848h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 82114848h case   22:*/		return 0x8211484C;
		  /* 8211484Ch */ case   23:  		/* lwzx R9, <#[R9 + R11]> */
		/* 8211484Ch case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8211484Ch case   23:*/		return 0x82114850;
		  /* 82114850h */ case   24:  		/* lwz R6, <#[R8 + 48]> */
		/* 82114850h case   24:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + 0x00000030) );
		/* 82114850h case   24:*/		return 0x82114854;
		  /* 82114854h */ case   25:  		/* lwz R7, <#[R9 + 48]> */
		/* 82114854h case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000030) );
		/* 82114854h case   25:*/		return 0x82114858;
		  /* 82114858h */ case   26:  		/* bc 12, CR6_EQ, 16 */
		/* 82114858h case   26:*/		if ( regs.CR[6].eq ) { return 0x82114868;  }
		/* 82114858h case   26:*/		return 0x8211485C;
		  /* 8211485Ch */ case   27:  		/* lis R9, 8208 */
		/* 8211485Ch case   27:*/		cpu::op::lis<0>(regs,&regs.R9,0x2010);
		/* 8211485Ch case   27:*/		return 0x82114860;
		  /* 82114860h */ case   28:  		/* cmplw CR6, R10, R9 */
		/* 82114860h case   28:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82114860h case   28:*/		return 0x82114864;
		  /* 82114864h */ case   29:  		/* bc 4, CR6_EQ, 284 */
		/* 82114864h case   29:*/		if ( !regs.CR[6].eq ) { return 0x82114980;  }
		/* 82114864h case   29:*/		return 0x82114868;
	}
	return 0x82114868;
} // Block from 821147F0h-82114868h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82114868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114868);
		  /* 82114868h */ case    0:  		/* rlwinm R9, R7, 2, 0, 29 */
		/* 82114868h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R7);
		/* 82114868h case    0:*/		return 0x8211486C;
		  /* 8211486Ch */ case    1:  		/* rlwinm R10, R6, 2, 0, 29 */
		/* 8211486Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R6);
		/* 8211486Ch case    1:*/		return 0x82114870;
		  /* 82114870h */ case    2:  		/* rlwinm R8, R30, 2, 0, 29 */
		/* 82114870h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R30);
		/* 82114870h case    2:*/		return 0x82114874;
		  /* 82114874h */ case    3:  		/* lwzx R5, <#[R9 + R11]> */
		/* 82114874h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82114874h case    3:*/		return 0x82114878;
		  /* 82114878h */ case    4:  		/* lwzx R10, <#[R10 + R11]> */
		/* 82114878h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82114878h case    4:*/		return 0x8211487C;
		  /* 8211487Ch */ case    5:  		/* lwzx R9, <#[R8 + R11]> */
		/* 8211487Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8211487Ch case    5:*/		return 0x82114880;
		  /* 82114880h */ case    6:  		/* lwz R11, <#[R5]> */
		/* 82114880h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 82114880h case    6:*/		return 0x82114884;
		  /* 82114884h */ case    7:  		/* lwz R8, <#[R10]> */
		/* 82114884h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82114884h case    7:*/		return 0x82114888;
		  /* 82114888h */ case    8:  		/* or R11, R8, R11 */
		/* 82114888h case    8:*/		cpu::op::or<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82114888h case    8:*/		return 0x8211488C;
		  /* 8211488Ch */ case    9:  		/* rlwinm R11, R11, 0, 4, 6 */
		/* 8211488Ch case    9:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R11,regs.R11);
		/* 8211488Ch case    9:*/		return 0x82114890;
		  /* 82114890h */ case   10:  		/* rlwinm. R4, R11, 0, 4, 4 */
		/* 82114890h case   10:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R4,regs.R11);
		/* 82114890h case   10:*/		return 0x82114894;
		  /* 82114894h */ case   11:  		/* bc 12, CR0_EQ, 12 */
		/* 82114894h case   11:*/		if ( regs.CR[0].eq ) { return 0x821148A0;  }
		/* 82114894h case   11:*/		return 0x82114898;
		  /* 82114898h */ case   12:  		/* lis R11, 2048 */
		/* 82114898h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0x800);
		/* 82114898h case   12:*/		return 0x8211489C;
		  /* 8211489Ch */ case   13:  		/* b 32 */
		/* 8211489Ch case   13:*/		return 0x821148BC;
		/* 8211489Ch case   13:*/		return 0x821148A0;
	}
	return 0x821148A0;
} // Block from 82114868h-821148A0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821148A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821148A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821148A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821148A0);
		  /* 821148A0h */ case    0:  		/* rlwinm. R4, R11, 0, 5, 5 */
		/* 821148A0h case    0:*/		cpu::op::rlwinm<1,0,5,5>(regs,&regs.R4,regs.R11);
		/* 821148A0h case    0:*/		return 0x821148A4;
		  /* 821148A4h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821148A4h case    1:*/		if ( regs.CR[0].eq ) { return 0x821148B0;  }
		/* 821148A4h case    1:*/		return 0x821148A8;
		  /* 821148A8h */ case    2:  		/* lis R11, 1024 */
		/* 821148A8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x400);
		/* 821148A8h case    2:*/		return 0x821148AC;
		  /* 821148ACh */ case    3:  		/* b 16 */
		/* 821148ACh case    3:*/		return 0x821148BC;
		/* 821148ACh case    3:*/		return 0x821148B0;
	}
	return 0x821148B0;
} // Block from 821148A0h-821148B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821148B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821148B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821148B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821148B0);
		  /* 821148B0h */ case    0:  		/* rlwinm. R4, R11, 0, 6, 6 */
		/* 821148B0h case    0:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R4,regs.R11);
		/* 821148B0h case    0:*/		return 0x821148B4;
		  /* 821148B4h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 821148B4h case    1:*/		if ( regs.CR[0].eq ) { return 0x821148BC;  }
		/* 821148B4h case    1:*/		return 0x821148B8;
		  /* 821148B8h */ case    2:  		/* lis R11, 512 */
		/* 821148B8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x200);
		/* 821148B8h case    2:*/		return 0x821148BC;
	}
	return 0x821148BC;
} // Block from 821148B0h-821148BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821148BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821148BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821148BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821148BC);
		  /* 821148BCh */ case    0:  		/* lwz R9, <#[R9]> */
		/* 821148BCh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 821148BCh case    0:*/		return 0x821148C0;
		  /* 821148C0h */ case    1:  		/* rlwinm R9, R9, 0, 4, 6 */
		/* 821148C0h case    1:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R9,regs.R9);
		/* 821148C0h case    1:*/		return 0x821148C4;
		  /* 821148C4h */ case    2:  		/* or R11, R9, R11 */
		/* 821148C4h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821148C4h case    2:*/		return 0x821148C8;
		  /* 821148C8h */ case    3:  		/* rlwinm. R9, R11, 0, 6, 6 */
		/* 821148C8h case    3:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R9,regs.R11);
		/* 821148C8h case    3:*/		return 0x821148CC;
		  /* 821148CCh */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 821148CCh case    4:*/		if ( regs.CR[0].eq ) { return 0x821148D8;  }
		/* 821148CCh case    4:*/		return 0x821148D0;
		  /* 821148D0h */ case    5:  		/* lis R11, 512 */
		/* 821148D0h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0x200);
		/* 821148D0h case    5:*/		return 0x821148D4;
		  /* 821148D4h */ case    6:  		/* b 32 */
		/* 821148D4h case    6:*/		return 0x821148F4;
		/* 821148D4h case    6:*/		return 0x821148D8;
	}
	return 0x821148D8;
} // Block from 821148BCh-821148D8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821148D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821148D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821148D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821148D8);
		  /* 821148D8h */ case    0:  		/* rlwinm. R9, R11, 0, 5, 5 */
		/* 821148D8h case    0:*/		cpu::op::rlwinm<1,0,5,5>(regs,&regs.R9,regs.R11);
		/* 821148D8h case    0:*/		return 0x821148DC;
		  /* 821148DCh */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821148DCh case    1:*/		if ( regs.CR[0].eq ) { return 0x821148E8;  }
		/* 821148DCh case    1:*/		return 0x821148E0;
		  /* 821148E0h */ case    2:  		/* lis R11, 1024 */
		/* 821148E0h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x400);
		/* 821148E0h case    2:*/		return 0x821148E4;
		  /* 821148E4h */ case    3:  		/* b 16 */
		/* 821148E4h case    3:*/		return 0x821148F4;
		/* 821148E4h case    3:*/		return 0x821148E8;
	}
	return 0x821148E8;
} // Block from 821148D8h-821148E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821148E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821148E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821148E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821148E8);
		  /* 821148E8h */ case    0:  		/* rlwinm. R9, R11, 0, 4, 4 */
		/* 821148E8h case    0:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R9,regs.R11);
		/* 821148E8h case    0:*/		return 0x821148EC;
		  /* 821148ECh */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 821148ECh case    1:*/		if ( regs.CR[0].eq ) { return 0x821148F4;  }
		/* 821148ECh case    1:*/		return 0x821148F0;
		  /* 821148F0h */ case    2:  		/* lis R11, 2048 */
		/* 821148F0h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x800);
		/* 821148F0h case    2:*/		return 0x821148F4;
	}
	return 0x821148F4;
} // Block from 821148E8h-821148F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821148F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821148F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821148F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821148F4);
		  /* 821148F4h */ case    0:  		/* rlwinm R9, R8, 0, 4, 6 */
		/* 821148F4h case    0:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R9,regs.R8);
		/* 821148F4h case    0:*/		return 0x821148F8;
		  /* 821148F8h */ case    1:  		/* cmplw CR6, R11, R9 */
		/* 821148F8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 821148F8h case    1:*/		return 0x821148FC;
		  /* 821148FCh */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 821148FCh case    2:*/		if ( regs.CR[6].eq ) { return 0x82114938;  }
		/* 821148FCh case    2:*/		return 0x82114900;
		  /* 82114900h */ case    3:  		/* lwz R9, <#[R10 + 4]> */
		/* 82114900h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 82114900h case    3:*/		return 0x82114904;
		  /* 82114904h */ case    4:  		/* lwz R4, <#[R26 + 16]> */
		/* 82114904h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000010) );
		/* 82114904h case    4:*/		return 0x82114908;
		  /* 82114908h */ case    5:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82114908h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82114908h case    5:*/		return 0x8211490C;
		  /* 8211490Ch */ case    6:  		/* lwzx R9, <#[R9 + R4]> */
		/* 8211490Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R4 + 0x00000000) );
		/* 8211490Ch case    6:*/		return 0x82114910;
		  /* 82114910h */ case    7:  		/* lwz R9, <#[R9 + 4]> */
		/* 82114910h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 82114910h case    7:*/		return 0x82114914;
		  /* 82114914h */ case    8:  		/* rlwinm. R9, R9, 0, 30, 30 */
		/* 82114914h case    8:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R9);
		/* 82114914h case    8:*/		return 0x82114918;
		  /* 82114918h */ case    9:  		/* bc 12, CR0_EQ, 32 */
		/* 82114918h case    9:*/		if ( regs.CR[0].eq ) { return 0x82114938;  }
		/* 82114918h case    9:*/		return 0x8211491C;
		  /* 8211491Ch */ case   10:  		/* lwz R9, <#[R10 + 92]> */
		/* 8211491Ch case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000005C) );
		/* 8211491Ch case   10:*/		return 0x82114920;
		  /* 82114920h */ case   11:  		/* cmplwi CR6, R9, 1 */
		/* 82114920h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 82114920h case   11:*/		return 0x82114924;
		  /* 82114924h */ case   12:  		/* bc 4, CR6_EQ, 20 */
		/* 82114924h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82114938;  }
		/* 82114924h case   12:*/		return 0x82114928;
		  /* 82114928h */ case   13:  		/* rlwinm R9, R8, 0, 7, 3 */
		/* 82114928h case   13:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R9,regs.R8);
		/* 82114928h case   13:*/		return 0x8211492C;
		  /* 8211492Ch */ case   14:  		/* mr R23, R21 */
		/* 8211492Ch case   14:*/		regs.R23 = regs.R21;
		/* 8211492Ch case   14:*/		return 0x82114930;
		  /* 82114930h */ case   15:  		/* or R9, R9, R11 */
		/* 82114930h case   15:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 82114930h case   15:*/		return 0x82114934;
		  /* 82114934h */ case   16:  		/* stw R9, <#[R10]> */
		/* 82114934h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82114934h case   16:*/		return 0x82114938;
	}
	return 0x82114938;
} // Block from 821148F4h-82114938h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82114938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114938);
		  /* 82114938h */ case    0:  		/* lwz R10, <#[R5]> */
		/* 82114938h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 82114938h case    0:*/		return 0x8211493C;
		  /* 8211493Ch */ case    1:  		/* rlwinm R9, R10, 0, 4, 6 */
		/* 8211493Ch case    1:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R9,regs.R10);
		/* 8211493Ch case    1:*/		return 0x82114940;
		  /* 82114940h */ case    2:  		/* cmplw CR6, R11, R9 */
		/* 82114940h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82114940h case    2:*/		return 0x82114944;
		  /* 82114944h */ case    3:  		/* bc 12, CR6_EQ, 60 */
		/* 82114944h case    3:*/		if ( regs.CR[6].eq ) { return 0x82114980;  }
		/* 82114944h case    3:*/		return 0x82114948;
		  /* 82114948h */ case    4:  		/* lwz R9, <#[R5 + 4]> */
		/* 82114948h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000004) );
		/* 82114948h case    4:*/		return 0x8211494C;
		  /* 8211494Ch */ case    5:  		/* lwz R8, <#[R26 + 16]> */
		/* 8211494Ch case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000010) );
		/* 8211494Ch case    5:*/		return 0x82114950;
		  /* 82114950h */ case    6:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82114950h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82114950h case    6:*/		return 0x82114954;
		  /* 82114954h */ case    7:  		/* lwzx R9, <#[R9 + R8]> */
		/* 82114954h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82114954h case    7:*/		return 0x82114958;
		  /* 82114958h */ case    8:  		/* lwz R9, <#[R9 + 4]> */
		/* 82114958h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 82114958h case    8:*/		return 0x8211495C;
		  /* 8211495Ch */ case    9:  		/* rlwinm. R9, R9, 0, 30, 30 */
		/* 8211495Ch case    9:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R9);
		/* 8211495Ch case    9:*/		return 0x82114960;
		  /* 82114960h */ case   10:  		/* bc 12, CR0_EQ, 32 */
		/* 82114960h case   10:*/		if ( regs.CR[0].eq ) { return 0x82114980;  }
		/* 82114960h case   10:*/		return 0x82114964;
		  /* 82114964h */ case   11:  		/* lwz R9, <#[R5 + 92]> */
		/* 82114964h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x0000005C) );
		/* 82114964h case   11:*/		return 0x82114968;
		  /* 82114968h */ case   12:  		/* cmplwi CR6, R9, 1 */
		/* 82114968h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 82114968h case   12:*/		return 0x8211496C;
		  /* 8211496Ch */ case   13:  		/* bc 4, CR6_EQ, 20 */
		/* 8211496Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x82114980;  }
		/* 8211496Ch case   13:*/		return 0x82114970;
		  /* 82114970h */ case   14:  		/* rlwinm R10, R10, 0, 7, 3 */
		/* 82114970h case   14:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R10,regs.R10);
		/* 82114970h case   14:*/		return 0x82114974;
		  /* 82114974h */ case   15:  		/* mr R23, R21 */
		/* 82114974h case   15:*/		regs.R23 = regs.R21;
		/* 82114974h case   15:*/		return 0x82114978;
		  /* 82114978h */ case   16:  		/* or R11, R10, R11 */
		/* 82114978h case   16:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82114978h case   16:*/		return 0x8211497C;
		  /* 8211497Ch */ case   17:  		/* stw R11, <#[R5]> */
		/* 8211497Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8211497Ch case   17:*/		return 0x82114980;
	}
	return 0x82114980;
} // Block from 82114938h-82114980h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82114980h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114980);
		  /* 82114980h */ case    0:  		/* mr R5, R30 */
		/* 82114980h case    0:*/		regs.R5 = regs.R30;
		/* 82114980h case    0:*/		return 0x82114984;
		  /* 82114984h */ case    1:  		/* mr R4, R31 */
		/* 82114984h case    1:*/		regs.R4 = regs.R31;
		/* 82114984h case    1:*/		return 0x82114988;
		  /* 82114988h */ case    2:  		/* mr R3, R26 */
		/* 82114988h case    2:*/		regs.R3 = regs.R26;
		/* 82114988h case    2:*/		return 0x8211498C;
		  /* 8211498Ch */ case    3:  		/* bl -74684 */
		/* 8211498Ch case    3:*/		regs.LR = 0x82114990; return 0x821025D0;
		/* 8211498Ch case    3:*/		return 0x82114990;
		  /* 82114990h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 82114990h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82114990h case    4:*/		return 0x82114994;
		  /* 82114994h */ case    5:  		/* bc 12, CR0_LT, 3280 */
		/* 82114994h case    5:*/		if ( regs.CR[0].lt ) { return 0x82115664;  }
		/* 82114994h case    5:*/		return 0x82114998;
		  /* 82114998h */ case    6:  		/* lwz R11, <#[R26 + 20]> */
		/* 82114998h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82114998h case    6:*/		return 0x8211499C;
		  /* 8211499Ch */ case    7:  		/* rlwinm R9, R30, 2, 0, 29 */
		/* 8211499Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R30);
		/* 8211499Ch case    7:*/		return 0x821149A0;
		  /* 821149A0h */ case    8:  		/* lwzx R10, <#[R9 + R11]> */
		/* 821149A0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821149A0h case    8:*/		return 0x821149A4;
		  /* 821149A4h */ case    9:  		/* lwz R10, <#[R10 + 48]> */
		/* 821149A4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 821149A4h case    9:*/		return 0x821149A8;
		  /* 821149A8h */ case   10:  		/* cmplw CR6, R10, R30 */
		/* 821149A8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R30);
		/* 821149A8h case   10:*/		return 0x821149AC;
		  /* 821149ACh */ case   11:  		/* bc 4, CR6_EQ, 12 */
		/* 821149ACh case   11:*/		if ( !regs.CR[6].eq ) { return 0x821149B8;  }
		/* 821149ACh case   11:*/		return 0x821149B0;
		  /* 821149B0h */ case   12:  		/* addi R25, R25, 1 */
		/* 821149B0h case   12:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 821149B0h case   12:*/		return 0x821149B4;
		  /* 821149B4h */ case   13:  		/* b 44 */
		/* 821149B4h case   13:*/		return 0x821149E0;
		/* 821149B4h case   13:*/		return 0x821149B8;
	}
	return 0x821149B8;
} // Block from 82114980h-821149B8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821149B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821149B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821149B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821149B8);
		  /* 821149B8h */ case    0:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821149B8h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821149B8h case    0:*/		return 0x821149BC;
		  /* 821149BCh */ case    1:  		/* lwzx R10, <#[R10 + R11]> */
		/* 821149BCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821149BCh case    1:*/		return 0x821149C0;
		  /* 821149C0h */ case    2:  		/* lwz R10, <#[R10 + 48]> */
		/* 821149C0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 821149C0h case    2:*/		return 0x821149C4;
		  /* 821149C4h */ case    3:  		/* cmpwi CR6, R10, -1 */
		/* 821149C4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 821149C4h case    3:*/		return 0x821149C8;
		  /* 821149C8h */ case    4:  		/* bc 4, CR6_EQ, 24 */
		/* 821149C8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821149E0;  }
		/* 821149C8h case    4:*/		return 0x821149CC;
		  /* 821149CCh */ case    5:  		/* lwzx R10, <#[R9 + R11]> */
		/* 821149CCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821149CCh case    5:*/		return 0x821149D0;
		  /* 821149D0h */ case    6:  		/* lwz R10, <#[R10 + 48]> */
		/* 821149D0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 821149D0h case    6:*/		return 0x821149D4;
		  /* 821149D4h */ case    7:  		/* rlwinm R9, R10, 2, 0, 29 */
		/* 821149D4h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R10);
		/* 821149D4h case    7:*/		return 0x821149D8;
		  /* 821149D8h */ case    8:  		/* lwzx R11, <#[R9 + R11]> */
		/* 821149D8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821149D8h case    8:*/		return 0x821149DC;
		  /* 821149DCh */ case    9:  		/* stw R10, <#[R11 + 48]> */
		/* 821149DCh case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 821149DCh case    9:*/		return 0x821149E0;
	}
	return 0x821149E0;
} // Block from 821149B8h-821149E0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821149E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821149E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821149E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821149E0);
		  /* 821149E0h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 821149E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821149E0h case    0:*/		return 0x821149E4;
		  /* 821149E4h */ case    1:  		/* addi R28, R28, 1 */
		/* 821149E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 821149E4h case    1:*/		return 0x821149E8;
		  /* 821149E8h */ case    2:  		/* addi R29, R29, 4 */
		/* 821149E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 821149E8h case    2:*/		return 0x821149EC;
		  /* 821149ECh */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 821149ECh case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 821149ECh case    3:*/		return 0x821149F0;
		  /* 821149F0h */ case    4:  		/* bc 12, CR6_LT, -480 */
		/* 821149F0h case    4:*/		if ( regs.CR[6].lt ) { return 0x82114810;  }
		/* 821149F0h case    4:*/		return 0x821149F4;
	}
	return 0x821149F4;
} // Block from 821149E0h-821149F4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821149F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821149F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821149F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821149F4);
		  /* 821149F4h */ case    0:  		/* lwz R7, <#[R31 + 12]> */
		/* 821149F4h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 821149F4h case    0:*/		return 0x821149F8;
		  /* 821149F8h */ case    1:  		/* cmplw CR6, R25, R7 */
		/* 821149F8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R7);
		/* 821149F8h case    1:*/		return 0x821149FC;
		  /* 821149FCh */ case    2:  		/* bc 12, CR6_EQ, 2848 */
		/* 821149FCh case    2:*/		if ( regs.CR[6].eq ) { return 0x8211551C;  }
		/* 821149FCh case    2:*/		return 0x82114A00;
		  /* 82114A00h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 82114A00h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82114A00h case    3:*/		return 0x82114A04;
		  /* 82114A04h */ case    4:  		/* mr R8, R22 */
		/* 82114A04h case    4:*/		regs.R8 = regs.R22;
		/* 82114A04h case    4:*/		return 0x82114A08;
		  /* 82114A08h */ case    5:  		/* mr R27, R22 */
		/* 82114A08h case    5:*/		regs.R27 = regs.R22;
		/* 82114A08h case    5:*/		return 0x82114A0C;
		  /* 82114A0Ch */ case    6:  		/* rlwinm. R29, R11, 0, 12, 31 */
		/* 82114A0Ch case    6:*/		cpu::op::rlwinm<1,0,12,31>(regs,&regs.R29,regs.R11);
		/* 82114A0Ch case    6:*/		return 0x82114A10;
		  /* 82114A10h */ case    7:  		/* bc 12, CR0_EQ, 372 */
		/* 82114A10h case    7:*/		if ( regs.CR[0].eq ) { return 0x82114B84;  }
		/* 82114A10h case    7:*/		return 0x82114A14;
		  /* 82114A14h */ case    8:  		/* lwz R9, <#[R31 + 16]> */
		/* 82114A14h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 82114A14h case    8:*/		return 0x82114A18;
		  /* 82114A18h */ case    9:  		/* mtspr CTR, R29 */
		/* 82114A18h case    9:*/		regs.CTR = regs.R29;
		/* 82114A18h case    9:*/		return 0x82114A1C;
		  /* 82114A1Ch */ case   10:  		/* lwz R11, <#[R26 + 20]> */
		/* 82114A1Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82114A1Ch case   10:*/		return 0x82114A20;
		  /* 82114A20h */ case   11:  		/* mr R10, R22 */
		/* 82114A20h case   11:*/		regs.R10 = regs.R22;
		/* 82114A20h case   11:*/		return 0x82114A24;
		  /* 82114A24h */ case   12:  		/* lwzx R6, <#[R10 + R9]> */
		/* 82114A24h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82114A24h case   12:*/		return 0x82114A28;
		  /* 82114A28h */ case   13:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 82114A28h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 82114A28h case   13:*/		return 0x82114A2C;
		  /* 82114A2Ch */ case   14:  		/* lwzx R6, <#[R6 + R11]> */
		/* 82114A2Ch case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 82114A2Ch case   14:*/		return 0x82114A30;
		  /* 82114A30h */ case   15:  		/* lwz R6, <#[R6 + 48]> */
		/* 82114A30h case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000030) );
		/* 82114A30h case   15:*/		return 0x82114A34;
		  /* 82114A34h */ case   16:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 82114A34h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 82114A34h case   16:*/		return 0x82114A38;
		  /* 82114A38h */ case   17:  		/* lwzx R6, <#[R6 + R11]> */
		/* 82114A38h case   17:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 82114A38h case   17:*/		return 0x82114A3C;
		  /* 82114A3Ch */ case   18:  		/* lwz R6, <#[R6 + 72]> */
		/* 82114A3Ch case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000048) );
		/* 82114A3Ch case   18:*/		return 0x82114A40;
		  /* 82114A40h */ case   19:  		/* cmplw CR6, R6, R18 */
		/* 82114A40h case   19:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R18);
		/* 82114A40h case   19:*/		return 0x82114A44;
		  /* 82114A44h */ case   20:  		/* bc 12, CR6_EQ, 8 */
		/* 82114A44h case   20:*/		if ( regs.CR[6].eq ) { return 0x82114A4C;  }
		/* 82114A44h case   20:*/		return 0x82114A48;
		  /* 82114A48h */ case   21:  		/* addi R8, R8, 1 */
		/* 82114A48h case   21:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82114A48h case   21:*/		return 0x82114A4C;
	}
	return 0x82114A4C;
} // Block from 821149F4h-82114A4Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 82114A4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114A4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114A4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114A4C);
		  /* 82114A4Ch */ case    0:  		/* addi R10, R10, 4 */
		/* 82114A4Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82114A4Ch case    0:*/		return 0x82114A50;
		  /* 82114A50h */ case    1:  		/* bc 16, CR0_LT, -44 */
		/* 82114A50h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82114A24;  }
		/* 82114A50h case    1:*/		return 0x82114A54;
		  /* 82114A54h */ case    2:  		/* cmplwi CR6, R8, 0 */
		/* 82114A54h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82114A54h case    2:*/		return 0x82114A58;
		  /* 82114A58h */ case    3:  		/* bc 12, CR6_EQ, 300 */
		/* 82114A58h case    3:*/		if ( regs.CR[6].eq ) { return 0x82114B84;  }
		/* 82114A58h case    3:*/		return 0x82114A5C;
		  /* 82114A5Ch */ case    4:  		/* cmplw CR6, R8, R7 */
		/* 82114A5Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 82114A5Ch case    4:*/		return 0x82114A60;
		  /* 82114A60h */ case    5:  		/* bc 12, CR6_EQ, 292 */
		/* 82114A60h case    5:*/		if ( regs.CR[6].eq ) { return 0x82114B84;  }
		/* 82114A60h case    5:*/		return 0x82114A64;
		  /* 82114A64h */ case    6:  		/* subf R11, R8, R7 */
		/* 82114A64h case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R8,regs.R7);
		/* 82114A64h case    6:*/		return 0x82114A68;
		  /* 82114A68h */ case    7:  		/* cmplw CR6, R25, R11 */
		/* 82114A68h case    7:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 82114A68h case    7:*/		return 0x82114A6C;
		  /* 82114A6Ch */ case    8:  		/* bc 4, CR6_EQ, 280 */
		/* 82114A6Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x82114B84;  }
		/* 82114A6Ch case    8:*/		return 0x82114A70;
		  /* 82114A70h */ case    9:  		/* li R3, 116 */
		/* 82114A70h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x74);
		/* 82114A70h case    9:*/		return 0x82114A74;
		  /* 82114A74h */ case   10:  		/* subf R28, R8, R29 */
		/* 82114A74h case   10:*/		cpu::op::subf<0>(regs,&regs.R28,regs.R8,regs.R29);
		/* 82114A74h case   10:*/		return 0x82114A78;
		  /* 82114A78h */ case   11:  		/* bl -99552 */
		/* 82114A78h case   11:*/		regs.LR = 0x82114A7C; return 0x820FC598;
		/* 82114A78h case   11:*/		return 0x82114A7C;
		  /* 82114A7Ch */ case   12:  		/* cmplwi CR0, R3, 0 */
		/* 82114A7Ch case   12:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82114A7Ch case   12:*/		return 0x82114A80;
		  /* 82114A80h */ case   13:  		/* bc 12, CR0_EQ, 16 */
		/* 82114A80h case   13:*/		if ( regs.CR[0].eq ) { return 0x82114A90;  }
		/* 82114A80h case   13:*/		return 0x82114A84;
		  /* 82114A84h */ case   14:  		/* bl -101348 */
		/* 82114A84h case   14:*/		regs.LR = 0x82114A88; return 0x820FBEA0;
		/* 82114A84h case   14:*/		return 0x82114A88;
		  /* 82114A88h */ case   15:  		/* mr R30, R3 */
		/* 82114A88h case   15:*/		regs.R30 = regs.R3;
		/* 82114A88h case   15:*/		return 0x82114A8C;
		  /* 82114A8Ch */ case   16:  		/* b 8 */
		/* 82114A8Ch case   16:*/		return 0x82114A94;
		/* 82114A8Ch case   16:*/		return 0x82114A90;
	}
	return 0x82114A90;
} // Block from 82114A4Ch-82114A90h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82114A90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114A90);
		  /* 82114A90h */ case    0:  		/* mr R30, R22 */
		/* 82114A90h case    0:*/		regs.R30 = regs.R22;
		/* 82114A90h case    0:*/		return 0x82114A94;
	}
	return 0x82114A94;
} // Block from 82114A90h-82114A94h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82114A94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114A94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114A94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114A94);
		  /* 82114A94h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 82114A94h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82114A94h case    0:*/		return 0x82114A98;
		  /* 82114A98h */ case    1:  		/* bc 12, CR6_EQ, 2988 */
		/* 82114A98h case    1:*/		if ( regs.CR[6].eq ) { return 0x82115644;  }
		/* 82114A98h case    1:*/		return 0x82114A9C;
		  /* 82114A9Ch */ case    2:  		/* lwz R4, <#[R31]> */
		/* 82114A9Ch case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 82114A9Ch case    2:*/		return 0x82114AA0;
		  /* 82114AA0h */ case    3:  		/* li R7, 0 */
		/* 82114AA0h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82114AA0h case    3:*/		return 0x82114AA4;
		  /* 82114AA4h */ case    4:  		/* mr R6, R28 */
		/* 82114AA4h case    4:*/		regs.R6 = regs.R28;
		/* 82114AA4h case    4:*/		return 0x82114AA8;
		  /* 82114AA8h */ case    5:  		/* rlwimi R4, R28, 0, 12, 31 */
		/* 82114AA8h case    5:*/		cpu::op::rlwimi<0,0,12,31>(regs,&regs.R4,regs.R28);
		/* 82114AA8h case    5:*/		return 0x82114AAC;
		  /* 82114AACh */ case    6:  		/* rlwinm R5, R28, 1, 0, 30 */
		/* 82114AACh case    6:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R5,regs.R28);
		/* 82114AACh case    6:*/		return 0x82114AB0;
		  /* 82114AB0h */ case    7:  		/* mr R3, R30 */
		/* 82114AB0h case    7:*/		regs.R3 = regs.R30;
		/* 82114AB0h case    7:*/		return 0x82114AB4;
		  /* 82114AB4h */ case    8:  		/* bl -99460 */
		/* 82114AB4h case    8:*/		regs.LR = 0x82114AB8; return 0x820FC630;
		/* 82114AB4h case    8:*/		return 0x82114AB8;
		  /* 82114AB8h */ case    9:  		/* mr R4, R31 */
		/* 82114AB8h case    9:*/		regs.R4 = regs.R31;
		/* 82114AB8h case    9:*/		return 0x82114ABC;
		  /* 82114ABCh */ case   10:  		/* mr R3, R30 */
		/* 82114ABCh case   10:*/		regs.R3 = regs.R30;
		/* 82114ABCh case   10:*/		return 0x82114AC0;
		  /* 82114AC0h */ case   11:  		/* bl -101328 */
		/* 82114AC0h case   11:*/		regs.LR = 0x82114AC4; return 0x820FBEF0;
		/* 82114AC0h case   11:*/		return 0x82114AC4;
		  /* 82114AC4h */ case   12:  		/* mr R10, R22 */
		/* 82114AC4h case   12:*/		regs.R10 = regs.R22;
		/* 82114AC4h case   12:*/		return 0x82114AC8;
		  /* 82114AC8h */ case   13:  		/* mr R11, R22 */
		/* 82114AC8h case   13:*/		regs.R11 = regs.R22;
		/* 82114AC8h case   13:*/		return 0x82114ACC;
		  /* 82114ACCh */ case   14:  		/* mtspr CTR, R29 */
		/* 82114ACCh case   14:*/		regs.CTR = regs.R29;
		/* 82114ACCh case   14:*/		return 0x82114AD0;
		  /* 82114AD0h */ case   15:  		/* rlwinm R9, R28, 2, 0, 29 */
		/* 82114AD0h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R28);
		/* 82114AD0h case   15:*/		return 0x82114AD4;
		  /* 82114AD4h */ case   16:  		/* rlwinm R8, R29, 2, 0, 29 */
		/* 82114AD4h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R29);
		/* 82114AD4h case   16:*/		return 0x82114AD8;
		  /* 82114AD8h */ case   17:  		/* lwz R7, <#[R31 + 16]> */
		/* 82114AD8h case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000010) );
		/* 82114AD8h case   17:*/		return 0x82114ADC;
		  /* 82114ADCh */ case   18:  		/* lwz R6, <#[R26 + 20]> */
		/* 82114ADCh case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R26 + 0x00000014) );
		/* 82114ADCh case   18:*/		return 0x82114AE0;
		  /* 82114AE0h */ case   19:  		/* lwzx R7, <#[R11 + R7]> */
		/* 82114AE0h case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82114AE0h case   19:*/		return 0x82114AE4;
		  /* 82114AE4h */ case   20:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82114AE4h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82114AE4h case   20:*/		return 0x82114AE8;
		  /* 82114AE8h */ case   21:  		/* lwzx R7, <#[R7 + R6]> */
		/* 82114AE8h case   21:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R6 + 0x00000000) );
		/* 82114AE8h case   21:*/		return 0x82114AEC;
		  /* 82114AECh */ case   22:  		/* lwz R5, <#[R7 + 48]> */
		/* 82114AECh case   22:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R7 + 0x00000030) );
		/* 82114AECh case   22:*/		return 0x82114AF0;
		  /* 82114AF0h */ case   23:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 82114AF0h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 82114AF0h case   23:*/		return 0x82114AF4;
		  /* 82114AF4h */ case   24:  		/* lwzx R6, <#[R5 + R6]> */
		/* 82114AF4h case   24:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R5 + regs.R6 + 0x00000000) );
		/* 82114AF4h case   24:*/		return 0x82114AF8;
		  /* 82114AF8h */ case   25:  		/* lwz R6, <#[R6 + 72]> */
		/* 82114AF8h case   25:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000048) );
		/* 82114AF8h case   25:*/		return 0x82114AFC;
		  /* 82114AFCh */ case   26:  		/* cmplw CR6, R6, R18 */
		/* 82114AFCh case   26:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R18);
		/* 82114AFCh case   26:*/		return 0x82114B00;
		  /* 82114B00h */ case   27:  		/* bc 12, CR6_EQ, 12 */
		/* 82114B00h case   27:*/		if ( regs.CR[6].eq ) { return 0x82114B0C;  }
		/* 82114B00h case   27:*/		return 0x82114B04;
		  /* 82114B04h */ case   28:  		/* stw R20, <#[R7 + 72]> */
		/* 82114B04h case   28:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R7 + 0x00000048) );
		/* 82114B04h case   28:*/		return 0x82114B08;
		  /* 82114B08h */ case   29:  		/* b 60 */
		/* 82114B08h case   29:*/		return 0x82114B44;
		/* 82114B08h case   29:*/		return 0x82114B0C;
	}
	return 0x82114B0C;
} // Block from 82114A94h-82114B0Ch (30 instructions)

//////////////////////////////////////////////////////
// Block at 82114B0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114B0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114B0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114B0C);
		  /* 82114B0Ch */ case    0:  		/* lwz R7, <#[R31 + 8]> */
		/* 82114B0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000008) );
		/* 82114B0Ch case    0:*/		return 0x82114B10;
		  /* 82114B10h */ case    1:  		/* lwz R6, <#[R30 + 8]> */
		/* 82114B10h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000008) );
		/* 82114B10h case    1:*/		return 0x82114B14;
		  /* 82114B14h */ case    2:  		/* lwzx R7, <#[R11 + R7]> */
		/* 82114B14h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82114B14h case    2:*/		return 0x82114B18;
		  /* 82114B18h */ case    3:  		/* stwx R7, <#[R10 + R6]> */
		/* 82114B18h case    3:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 82114B18h case    3:*/		return 0x82114B1C;
		  /* 82114B1Ch */ case    4:  		/* lwz R6, <#[R30 + 8]> */
		/* 82114B1Ch case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000008) );
		/* 82114B1Ch case    4:*/		return 0x82114B20;
		  /* 82114B20h */ case    5:  		/* lwz R7, <#[R31 + 8]> */
		/* 82114B20h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000008) );
		/* 82114B20h case    5:*/		return 0x82114B24;
		  /* 82114B24h */ case    6:  		/* lwzx R7, <#[R8 + R7]> */
		/* 82114B24h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 82114B24h case    6:*/		return 0x82114B28;
		  /* 82114B28h */ case    7:  		/* stwx R7, <#[R9 + R6]> */
		/* 82114B28h case    7:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 82114B28h case    7:*/		return 0x82114B2C;
		  /* 82114B2Ch */ case    8:  		/* addi R9, R9, 4 */
		/* 82114B2Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82114B2Ch case    8:*/		return 0x82114B30;
		  /* 82114B30h */ case    9:  		/* lwz R7, <#[R31 + 16]> */
		/* 82114B30h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000010) );
		/* 82114B30h case    9:*/		return 0x82114B34;
		  /* 82114B34h */ case   10:  		/* lwz R6, <#[R30 + 16]> */
		/* 82114B34h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000010) );
		/* 82114B34h case   10:*/		return 0x82114B38;
		  /* 82114B38h */ case   11:  		/* lwzx R7, <#[R11 + R7]> */
		/* 82114B38h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82114B38h case   11:*/		return 0x82114B3C;
		  /* 82114B3Ch */ case   12:  		/* stwx R7, <#[R6 + R10]> */
		/* 82114B3Ch case   12:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + regs.R10 + 0x00000000) );
		/* 82114B3Ch case   12:*/		return 0x82114B40;
		  /* 82114B40h */ case   13:  		/* addi R10, R10, 4 */
		/* 82114B40h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82114B40h case   13:*/		return 0x82114B44;
	}
	return 0x82114B44;
} // Block from 82114B0Ch-82114B44h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82114B44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114B44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114B44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114B44);
		  /* 82114B44h */ case    0:  		/* addi R11, R11, 4 */
		/* 82114B44h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82114B44h case    0:*/		return 0x82114B48;
		  /* 82114B48h */ case    1:  		/* addi R8, R8, 4 */
		/* 82114B48h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82114B48h case    1:*/		return 0x82114B4C;
		  /* 82114B4Ch */ case    2:  		/* bc 16, CR0_LT, -116 */
		/* 82114B4Ch case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82114AD8;  }
		/* 82114B4Ch case    2:*/		return 0x82114B50;
		  /* 82114B50h */ case    3:  		/* mr R4, R30 */
		/* 82114B50h case    3:*/		regs.R4 = regs.R30;
		/* 82114B50h case    3:*/		return 0x82114B54;
		  /* 82114B54h */ case    4:  		/* mr R3, R31 */
		/* 82114B54h case    4:*/		regs.R3 = regs.R31;
		/* 82114B54h case    4:*/		return 0x82114B58;
		  /* 82114B58h */ case    5:  		/* bl -98824 */
		/* 82114B58h case    5:*/		regs.LR = 0x82114B5C; return 0x820FC950;
		/* 82114B58h case    5:*/		return 0x82114B5C;
		  /* 82114B5Ch */ case    6:  		/* mr R29, R3 */
		/* 82114B5Ch case    6:*/		regs.R29 = regs.R3;
		/* 82114B5Ch case    6:*/		return 0x82114B60;
		  /* 82114B60h */ case    7:  		/* mr R3, R30 */
		/* 82114B60h case    7:*/		regs.R3 = regs.R30;
		/* 82114B60h case    7:*/		return 0x82114B64;
		  /* 82114B64h */ case    8:  		/* bl 1083484 */
		/* 82114B64h case    8:*/		regs.LR = 0x82114B68; return 0x8221D3C0;
		/* 82114B64h case    8:*/		return 0x82114B68;
		  /* 82114B68h */ case    9:  		/* mr R3, R30 */
		/* 82114B68h case    9:*/		regs.R3 = regs.R30;
		/* 82114B68h case    9:*/		return 0x82114B6C;
		  /* 82114B6Ch */ case   10:  		/* bl -99708 */
		/* 82114B6Ch case   10:*/		regs.LR = 0x82114B70; return 0x820FC5F0;
		/* 82114B6Ch case   10:*/		return 0x82114B70;
		  /* 82114B70h */ case   11:  		/* cmpwi CR6, R29, 0 */
		/* 82114B70h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82114B70h case   11:*/		return 0x82114B74;
		  /* 82114B74h */ case   12:  		/* bc 12, CR6_LT, 2780 */
		/* 82114B74h case   12:*/		if ( regs.CR[6].lt ) { return 0x82115650;  }
		/* 82114B74h case   12:*/		return 0x82114B78;
		  /* 82114B78h */ case   13:  		/* cmplw CR6, R25, R28 */
		/* 82114B78h case   13:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R28);
		/* 82114B78h case   13:*/		return 0x82114B7C;
		  /* 82114B7Ch */ case   14:  		/* bc 4, CR6_EQ, 8 */
		/* 82114B7Ch case   14:*/		if ( !regs.CR[6].eq ) { return 0x82114B84;  }
		/* 82114B7Ch case   14:*/		return 0x82114B80;
		  /* 82114B80h */ case   15:  		/* mr R27, R21 */
		/* 82114B80h case   15:*/		regs.R27 = regs.R21;
		/* 82114B80h case   15:*/		return 0x82114B84;
	}
	return 0x82114B84;
} // Block from 82114B44h-82114B84h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82114B84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114B84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114B84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114B84);
		  /* 82114B84h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 82114B84h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82114B84h case    0:*/		return 0x82114B88;
		  /* 82114B88h */ case    1:  		/* bc 4, CR6_EQ, 124 */
		/* 82114B88h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82114C04;  }
		/* 82114B88h case    1:*/		return 0x82114B8C;
		  /* 82114B8Ch */ case    2:  		/* lwz R6, <#[R31 + 12]> */
		/* 82114B8Ch case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x0000000C) );
		/* 82114B8Ch case    2:*/		return 0x82114B90;
		  /* 82114B90h */ case    3:  		/* mr R7, R21 */
		/* 82114B90h case    3:*/		regs.R7 = regs.R21;
		/* 82114B90h case    3:*/		return 0x82114B94;
		  /* 82114B94h */ case    4:  		/* cmplwi CR6, R6, 1 */
		/* 82114B94h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000001);
		/* 82114B94h case    4:*/		return 0x82114B98;
		  /* 82114B98h */ case    5:  		/* bc 4, CR6_GT, 108 */
		/* 82114B98h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82114C04;  }
		/* 82114B98h case    5:*/		return 0x82114B9C;
		  /* 82114B9Ch */ case    6:  		/* lwz R9, <#[R31 + 16]> */
		/* 82114B9Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 82114B9Ch case    6:*/		return 0x82114BA0;
		  /* 82114BA0h */ case    7:  		/* li R10, 4 */
		/* 82114BA0h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 82114BA0h case    7:*/		return 0x82114BA4;
		  /* 82114BA4h */ case    8:  		/* lwz R11, <#[R26 + 20]> */
		/* 82114BA4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82114BA4h case    8:*/		return 0x82114BA8;
		  /* 82114BA8h */ case    9:  		/* lwz R8, <#[R9]> */
		/* 82114BA8h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 82114BA8h case    9:*/		return 0x82114BAC;
		  /* 82114BACh */ case   10:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82114BACh case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82114BACh case   10:*/		return 0x82114BB0;
		  /* 82114BB0h */ case   11:  		/* lwzx R5, <#[R9 + R10]> */
		/* 82114BB0h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82114BB0h case   11:*/		return 0x82114BB4;
		  /* 82114BB4h */ case   12:  		/* lwzx R4, <#[R8 + R11]> */
		/* 82114BB4h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82114BB4h case   12:*/		return 0x82114BB8;
		  /* 82114BB8h */ case   13:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 82114BB8h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 82114BB8h case   13:*/		return 0x82114BBC;
		  /* 82114BBCh */ case   14:  		/* lwz R4, <#[R4 + 48]> */
		/* 82114BBCh case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000030) );
		/* 82114BBCh case   14:*/		return 0x82114BC0;
		  /* 82114BC0h */ case   15:  		/* lwzx R5, <#[R5 + R11]> */
		/* 82114BC0h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 82114BC0h case   15:*/		return 0x82114BC4;
		  /* 82114BC4h */ case   16:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 82114BC4h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 82114BC4h case   16:*/		return 0x82114BC8;
		  /* 82114BC8h */ case   17:  		/* lwz R5, <#[R5 + 48]> */
		/* 82114BC8h case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000030) );
		/* 82114BC8h case   17:*/		return 0x82114BCC;
		  /* 82114BCCh */ case   18:  		/* lwzx R4, <#[R4 + R11]> */
		/* 82114BCCh case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + regs.R11 + 0x00000000) );
		/* 82114BCCh case   18:*/		return 0x82114BD0;
		  /* 82114BD0h */ case   19:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 82114BD0h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 82114BD0h case   19:*/		return 0x82114BD4;
		  /* 82114BD4h */ case   20:  		/* lwz R4, <#[R4 + 4]> */
		/* 82114BD4h case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000004) );
		/* 82114BD4h case   20:*/		return 0x82114BD8;
		  /* 82114BD8h */ case   21:  		/* lwzx R5, <#[R5 + R11]> */
		/* 82114BD8h case   21:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 82114BD8h case   21:*/		return 0x82114BDC;
		  /* 82114BDCh */ case   22:  		/* lwz R5, <#[R5 + 4]> */
		/* 82114BDCh case   22:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000004) );
		/* 82114BDCh case   22:*/		return 0x82114BE0;
		  /* 82114BE0h */ case   23:  		/* cmplw CR6, R4, R5 */
		/* 82114BE0h case   23:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R5);
		/* 82114BE0h case   23:*/		return 0x82114BE4;
		  /* 82114BE4h */ case   24:  		/* bc 4, CR6_EQ, 28 */
		/* 82114BE4h case   24:*/		if ( !regs.CR[6].eq ) { return 0x82114C00;  }
		/* 82114BE4h case   24:*/		return 0x82114BE8;
		  /* 82114BE8h */ case   25:  		/* lwz R5, <#[R31 + 12]> */
		/* 82114BE8h case   25:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 82114BE8h case   25:*/		return 0x82114BEC;
		  /* 82114BECh */ case   26:  		/* addi R7, R7, 1 */
		/* 82114BECh case   26:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82114BECh case   26:*/		return 0x82114BF0;
		  /* 82114BF0h */ case   27:  		/* addi R10, R10, 4 */
		/* 82114BF0h case   27:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82114BF0h case   27:*/		return 0x82114BF4;
		  /* 82114BF4h */ case   28:  		/* cmplw CR6, R7, R5 */
		/* 82114BF4h case   28:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R5);
		/* 82114BF4h case   28:*/		return 0x82114BF8;
		  /* 82114BF8h */ case   29:  		/* bc 12, CR6_LT, -72 */
		/* 82114BF8h case   29:*/		if ( regs.CR[6].lt ) { return 0x82114BB0;  }
		/* 82114BF8h case   29:*/		return 0x82114BFC;
		  /* 82114BFCh */ case   30:  		/* b 8 */
		/* 82114BFCh case   30:*/		return 0x82114C04;
		/* 82114BFCh case   30:*/		return 0x82114C00;
	}
	return 0x82114C00;
} // Block from 82114B84h-82114C00h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82114C00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114C00);
		  /* 82114C00h */ case    0:  		/* mr R25, R6 */
		/* 82114C00h case    0:*/		regs.R25 = regs.R6;
		/* 82114C00h case    0:*/		return 0x82114C04;
	}
	return 0x82114C04;
} // Block from 82114C00h-82114C04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82114C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114C04);
		  /* 82114C04h */ case    0:  		/* cmpwi CR6, R27, 0 */
		/* 82114C04h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 82114C04h case    0:*/		return 0x82114C08;
		  /* 82114C08h */ case    1:  		/* bc 4, CR6_EQ, 2320 */
		/* 82114C08h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82115518;  }
		/* 82114C08h case    1:*/		return 0x82114C0C;
		  /* 82114C0Ch */ case    2:  		/* lwz R11, <#[R31 + 12]> */
		/* 82114C0Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82114C0Ch case    2:*/		return 0x82114C10;
		  /* 82114C10h */ case    3:  		/* cmplwi CR6, R25, 0 */
		/* 82114C10h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82114C10h case    3:*/		return 0x82114C14;
		  /* 82114C14h */ case    4:  		/* bc 12, CR6_EQ, 212 */
		/* 82114C14h case    4:*/		if ( regs.CR[6].eq ) { return 0x82114CE8;  }
		/* 82114C14h case    4:*/		return 0x82114C18;
		  /* 82114C18h */ case    5:  		/* mr R6, R22 */
		/* 82114C18h case    5:*/		regs.R6 = regs.R22;
		/* 82114C18h case    5:*/		return 0x82114C1C;
		  /* 82114C1Ch */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82114C1Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82114C1Ch case    6:*/		return 0x82114C20;
		  /* 82114C20h */ case    7:  		/* bc 4, CR6_GT, 120 */
		/* 82114C20h case    7:*/		if ( !regs.CR[6].gt ) { return 0x82114C98;  }
		/* 82114C20h case    7:*/		return 0x82114C24;
		  /* 82114C24h */ case    8:  		/* mr R7, R22 */
		/* 82114C24h case    8:*/		regs.R7 = regs.R22;
		/* 82114C24h case    8:*/		return 0x82114C28;
		  /* 82114C28h */ case    9:  		/* lwz R10, <#[R31 + 16]> */
		/* 82114C28h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82114C28h case    9:*/		return 0x82114C2C;
		  /* 82114C2Ch */ case   10:  		/* lwz R11, <#[R26 + 20]> */
		/* 82114C2Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82114C2Ch case   10:*/		return 0x82114C30;
		  /* 82114C30h */ case   11:  		/* lwzx R10, <#[R10 + R7]> */
		/* 82114C30h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 82114C30h case   11:*/		return 0x82114C34;
		  /* 82114C34h */ case   12:  		/* rlwinm R9, R10, 2, 0, 29 */
		/* 82114C34h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R10);
		/* 82114C34h case   12:*/		return 0x82114C38;
		  /* 82114C38h */ case   13:  		/* lwzx R8, <#[R9 + R11]> */
		/* 82114C38h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82114C38h case   13:*/		return 0x82114C3C;
		  /* 82114C3Ch */ case   14:  		/* lwz R5, <#[R8 + 48]> */
		/* 82114C3Ch case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R8 + 0x00000030) );
		/* 82114C3Ch case   14:*/		return 0x82114C40;
		  /* 82114C40h */ case   15:  		/* cmplw CR6, R5, R10 */
		/* 82114C40h case   15:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R10);
		/* 82114C40h case   15:*/		return 0x82114C44;
		  /* 82114C44h */ case   16:  		/* bc 12, CR6_EQ, 64 */
		/* 82114C44h case   16:*/		if ( regs.CR[6].eq ) { return 0x82114C84;  }
		/* 82114C44h case   16:*/		return 0x82114C48;
		  /* 82114C48h */ case   17:  		/* rlwinm R5, R8, 0, 0, 31 */
		/* 82114C48h case   17:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R5,regs.R8);
		/* 82114C48h case   17:*/		return 0x82114C4C;
		  /* 82114C4Ch */ case   18:  		/* lwz R4, <#[R5 + 48]> */
		/* 82114C4Ch case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x00000030) );
		/* 82114C4Ch case   18:*/		return 0x82114C50;
		  /* 82114C50h */ case   19:  		/* lwz R5, <#[R5]> */
		/* 82114C50h case   19:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000000) );
		/* 82114C50h case   19:*/		return 0x82114C54;
		  /* 82114C54h */ case   20:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 82114C54h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 82114C54h case   20:*/		return 0x82114C58;
		  /* 82114C58h */ case   21:  		/* lwzx R11, <#[R4 + R11]> */
		/* 82114C58h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + regs.R11 + 0x00000000) );
		/* 82114C58h case   21:*/		return 0x82114C5C;
		  /* 82114C5Ch */ case   22:  		/* lwz R11, <#[R11]> */
		/* 82114C5Ch case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82114C5Ch case   22:*/		return 0x82114C60;
		  /* 82114C60h */ case   23:  		/* rlwinm R11, R11, 0, 7, 3 */
		/* 82114C60h case   23:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R11,regs.R11);
		/* 82114C60h case   23:*/		return 0x82114C64;
		  /* 82114C64h */ case   24:  		/* or R11, R11, R5 */
		/* 82114C64h case   24:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 82114C64h case   24:*/		return 0x82114C68;
		  /* 82114C68h */ case   25:  		/* cmplw CR6, R5, R11 */
		/* 82114C68h case   25:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 82114C68h case   25:*/		return 0x82114C6C;
		  /* 82114C6Ch */ case   26:  		/* bc 12, CR6_EQ, 12 */
		/* 82114C6Ch case   26:*/		if ( regs.CR[6].eq ) { return 0x82114C78;  }
		/* 82114C6Ch case   26:*/		return 0x82114C70;
		  /* 82114C70h */ case   27:  		/* stw R11, <#[R8]> */
		/* 82114C70h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82114C70h case   27:*/		return 0x82114C74;
		  /* 82114C74h */ case   28:  		/* mr R23, R21 */
		/* 82114C74h case   28:*/		regs.R23 = regs.R21;
		/* 82114C74h case   28:*/		return 0x82114C78;
	}
	return 0x82114C78;
} // Block from 82114C04h-82114C78h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82114C78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114C78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114C78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114C78);
		  /* 82114C78h */ case    0:  		/* lwz R11, <#[R26 + 20]> */
		/* 82114C78h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82114C78h case    0:*/		return 0x82114C7C;
		  /* 82114C7Ch */ case    1:  		/* lwzx R11, <#[R9 + R11]> */
		/* 82114C7Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82114C7Ch case    1:*/		return 0x82114C80;
		  /* 82114C80h */ case    2:  		/* stw R10, <#[R11 + 48]> */
		/* 82114C80h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82114C80h case    2:*/		return 0x82114C84;
	}
	return 0x82114C84;
} // Block from 82114C78h-82114C84h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82114C84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114C84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114C84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114C84);
		  /* 82114C84h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82114C84h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82114C84h case    0:*/		return 0x82114C88;
		  /* 82114C88h */ case    1:  		/* addi R6, R6, 1 */
		/* 82114C88h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82114C88h case    1:*/		return 0x82114C8C;
		  /* 82114C8Ch */ case    2:  		/* addi R7, R7, 4 */
		/* 82114C8Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82114C8Ch case    2:*/		return 0x82114C90;
		  /* 82114C90h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 82114C90h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 82114C90h case    3:*/		return 0x82114C94;
		  /* 82114C94h */ case    4:  		/* bc 12, CR6_LT, -108 */
		/* 82114C94h case    4:*/		if ( regs.CR[6].lt ) { return 0x82114C28;  }
		/* 82114C94h case    4:*/		return 0x82114C98;
	}
	return 0x82114C98;
} // Block from 82114C84h-82114C98h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82114C98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114C98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114C98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114C98);
		  /* 82114C98h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 82114C98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82114C98h case    0:*/		return 0x82114C9C;
		  /* 82114C9Ch */ case    1:  		/* mr R28, R24 */
		/* 82114C9Ch case    1:*/		regs.R28 = regs.R24;
		/* 82114C9Ch case    1:*/		return 0x82114CA0;
		  /* 82114CA0h */ case    2:  		/* cmplw CR6, R24, R11 */
		/* 82114CA0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R11);
		/* 82114CA0h case    2:*/		return 0x82114CA4;
		  /* 82114CA4h */ case    3:  		/* bc 4, CR6_LT, 60 */
		/* 82114CA4h case    3:*/		if ( !regs.CR[6].lt ) { return 0x82114CE0;  }
		/* 82114CA4h case    3:*/		return 0x82114CA8;
		  /* 82114CA8h */ case    4:  		/* rlwinm R30, R24, 2, 0, 29 */
		/* 82114CA8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R24);
		/* 82114CA8h case    4:*/		return 0x82114CAC;
		  /* 82114CACh */ case    5:  		/* lwz R11, <#[R26 + 20]> */
		/* 82114CACh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82114CACh case    5:*/		return 0x82114CB0;
		  /* 82114CB0h */ case    6:  		/* lwzx R29, <#[R11 + R30]> */
		/* 82114CB0h case    6:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82114CB0h case    6:*/		return 0x82114CB4;
		  /* 82114CB4h */ case    7:  		/* cmplwi CR6, R29, 0 */
		/* 82114CB4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82114CB4h case    7:*/		return 0x82114CB8;
		  /* 82114CB8h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 82114CB8h case    8:*/		if ( regs.CR[6].eq ) { return 0x82114CCC;  }
		/* 82114CB8h case    8:*/		return 0x82114CBC;
		  /* 82114CBCh */ case    9:  		/* mr R3, R29 */
		/* 82114CBCh case    9:*/		regs.R3 = regs.R29;
		/* 82114CBCh case    9:*/		return 0x82114CC0;
		  /* 82114CC0h */ case   10:  		/* bl 1083136 */
		/* 82114CC0h case   10:*/		regs.LR = 0x82114CC4; return 0x8221D3C0;
		/* 82114CC0h case   10:*/		return 0x82114CC4;
		  /* 82114CC4h */ case   11:  		/* mr R3, R29 */
		/* 82114CC4h case   11:*/		regs.R3 = regs.R29;
		/* 82114CC4h case   11:*/		return 0x82114CC8;
		  /* 82114CC8h */ case   12:  		/* bl -98120 */
		/* 82114CC8h case   12:*/		regs.LR = 0x82114CCC; return 0x820FCD80;
		/* 82114CC8h case   12:*/		return 0x82114CCC;
	}
	return 0x82114CCC;
} // Block from 82114C98h-82114CCCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 82114CCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114CCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114CCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114CCC);
		  /* 82114CCCh */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 82114CCCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82114CCCh case    0:*/		return 0x82114CD0;
		  /* 82114CD0h */ case    1:  		/* addi R28, R28, 1 */
		/* 82114CD0h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82114CD0h case    1:*/		return 0x82114CD4;
		  /* 82114CD4h */ case    2:  		/* addi R30, R30, 4 */
		/* 82114CD4h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82114CD4h case    2:*/		return 0x82114CD8;
		  /* 82114CD8h */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 82114CD8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 82114CD8h case    3:*/		return 0x82114CDC;
		  /* 82114CDCh */ case    4:  		/* bc 12, CR6_LT, -48 */
		/* 82114CDCh case    4:*/		if ( regs.CR[6].lt ) { return 0x82114CAC;  }
		/* 82114CDCh case    4:*/		return 0x82114CE0;
	}
	return 0x82114CE0;
} // Block from 82114CCCh-82114CE0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82114CE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114CE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114CE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114CE0);
		  /* 82114CE0h */ case    0:  		/* stw R24, <#[R26 + 8]> */
		/* 82114CE0h case    0:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R26 + 0x00000008) );
		/* 82114CE0h case    0:*/		return 0x82114CE4;
		  /* 82114CE4h */ case    1:  		/* b 2104 */
		/* 82114CE4h case    1:*/		return 0x8211551C;
		/* 82114CE4h case    1:*/		return 0x82114CE8;
	}
	return 0x82114CE8;
} // Block from 82114CE0h-82114CE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82114CE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114CE8);
		  /* 82114CE8h */ case    0:  		/* mr R8, R22 */
		/* 82114CE8h case    0:*/		regs.R8 = regs.R22;
		/* 82114CE8h case    0:*/		return 0x82114CEC;
		  /* 82114CECh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82114CECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82114CECh case    1:*/		return 0x82114CF0;
		  /* 82114CF0h */ case    2:  		/* bc 4, CR6_GT, 2076 */
		/* 82114CF0h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8211550C;  }
		/* 82114CF0h case    2:*/		return 0x82114CF4;
		  /* 82114CF4h */ case    3:  		/* mr R10, R22 */
		/* 82114CF4h case    3:*/		regs.R10 = regs.R22;
		/* 82114CF4h case    3:*/		return 0x82114CF8;
		  /* 82114CF8h */ case    4:  		/* lwz R11, <#[R31 + 16]> */
		/* 82114CF8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82114CF8h case    4:*/		return 0x82114CFC;
		  /* 82114CFCh */ case    5:  		/* lwz R7, <#[R26 + 20]> */
		/* 82114CFCh case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R26 + 0x00000014) );
		/* 82114CFCh case    5:*/		return 0x82114D00;
		  /* 82114D00h */ case    6:  		/* lwz R6, <#[R26 + 16]> */
		/* 82114D00h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R26 + 0x00000010) );
		/* 82114D00h case    6:*/		return 0x82114D04;
		  /* 82114D04h */ case    7:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82114D04h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82114D04h case    7:*/		return 0x82114D08;
		  /* 82114D08h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82114D08h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82114D08h case    8:*/		return 0x82114D0C;
		  /* 82114D0Ch */ case    9:  		/* lwzx R9, <#[R11 + R7]> */
		/* 82114D0Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82114D0Ch case    9:*/		return 0x82114D10;
		  /* 82114D10h */ case   10:  		/* lwz R11, <#[R9 + 48]> */
		/* 82114D10h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000030) );
		/* 82114D10h case   10:*/		return 0x82114D14;
		  /* 82114D14h */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82114D14h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82114D14h case   11:*/		return 0x82114D18;
		  /* 82114D18h */ case   12:  		/* lwzx R11, <#[R11 + R7]> */
		/* 82114D18h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82114D18h case   12:*/		return 0x82114D1C;
		  /* 82114D1Ch */ case   13:  		/* lwz R7, <#[R11 + 4]> */
		/* 82114D1Ch case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82114D1Ch case   13:*/		return 0x82114D20;
		  /* 82114D20h */ case   14:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82114D20h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82114D20h case   14:*/		return 0x82114D24;
		  /* 82114D24h */ case   15:  		/* lwzx R7, <#[R7 + R6]> */
		/* 82114D24h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R6 + 0x00000000) );
		/* 82114D24h case   15:*/		return 0x82114D28;
		  /* 82114D28h */ case   16:  		/* lwz R7, <#[R7 + 4]> */
		/* 82114D28h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000004) );
		/* 82114D28h case   16:*/		return 0x82114D2C;
		  /* 82114D2Ch */ case   17:  		/* rlwinm. R7, R7, 0, 30, 30 */
		/* 82114D2Ch case   17:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R7,regs.R7);
		/* 82114D2Ch case   17:*/		return 0x82114D30;
		  /* 82114D30h */ case   18:  		/* bc 12, CR0_EQ, 52 */
		/* 82114D30h case   18:*/		if ( regs.CR[0].eq ) { return 0x82114D64;  }
		/* 82114D30h case   18:*/		return 0x82114D34;
		  /* 82114D34h */ case   19:  		/* lwz R7, <#[R11 + 96]> */
		/* 82114D34h case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000060) );
		/* 82114D34h case   19:*/		return 0x82114D38;
		  /* 82114D38h */ case   20:  		/* cmplwi CR6, R7, 0 */
		/* 82114D38h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82114D38h case   20:*/		return 0x82114D3C;
		  /* 82114D3Ch */ case   21:  		/* bc 4, CR6_EQ, 40 */
		/* 82114D3Ch case   21:*/		if ( !regs.CR[6].eq ) { return 0x82114D64;  }
		/* 82114D3Ch case   21:*/		return 0x82114D40;
		  /* 82114D40h */ case   22:  		/* lwz R9, <#[R9 + 96]> */
		/* 82114D40h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000060) );
		/* 82114D40h case   22:*/		return 0x82114D44;
		  /* 82114D44h */ case   23:  		/* stw R9, <#[R11 + 96]> */
		/* 82114D44h case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000060) );
		/* 82114D44h case   23:*/		return 0x82114D48;
		  /* 82114D48h */ case   24:  		/* lwz R9, <#[R31 + 16]> */
		/* 82114D48h case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 82114D48h case   24:*/		return 0x82114D4C;
		  /* 82114D4Ch */ case   25:  		/* lwz R7, <#[R26 + 20]> */
		/* 82114D4Ch case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R26 + 0x00000014) );
		/* 82114D4Ch case   25:*/		return 0x82114D50;
		  /* 82114D50h */ case   26:  		/* lwzx R9, <#[R9 + R10]> */
		/* 82114D50h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82114D50h case   26:*/		return 0x82114D54;
		  /* 82114D54h */ case   27:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82114D54h case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82114D54h case   27:*/		return 0x82114D58;
		  /* 82114D58h */ case   28:  		/* lwzx R9, <#[R9 + R7]> */
		/* 82114D58h case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 82114D58h case   28:*/		return 0x82114D5C;
		  /* 82114D5Ch */ case   29:  		/* lwz R9, <#[R9 + 100]> */
		/* 82114D5Ch case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000064) );
		/* 82114D5Ch case   29:*/		return 0x82114D60;
		  /* 82114D60h */ case   30:  		/* stw R9, <#[R11 + 100]> */
		/* 82114D60h case   30:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000064) );
		/* 82114D60h case   30:*/		return 0x82114D64;
	}
	return 0x82114D64;
} // Block from 82114CE8h-82114D64h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82114D64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114D64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114D64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114D64);
		  /* 82114D64h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82114D64h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82114D64h case    0:*/		return 0x82114D68;
		  /* 82114D68h */ case    1:  		/* addi R8, R8, 1 */
		/* 82114D68h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82114D68h case    1:*/		return 0x82114D6C;
		  /* 82114D6Ch */ case    2:  		/* addi R10, R10, 4 */
		/* 82114D6Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82114D6Ch case    2:*/		return 0x82114D70;
		  /* 82114D70h */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 82114D70h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 82114D70h case    3:*/		return 0x82114D74;
		  /* 82114D74h */ case    4:  		/* bc 12, CR6_LT, -124 */
		/* 82114D74h case    4:*/		if ( regs.CR[6].lt ) { return 0x82114CF8;  }
		/* 82114D74h case    4:*/		return 0x82114D78;
		  /* 82114D78h */ case    5:  		/* b 1940 */
		/* 82114D78h case    5:*/		return 0x8211550C;
		/* 82114D78h case    5:*/		return 0x82114D7C;
	}
	return 0x82114D7C;
} // Block from 82114D64h-82114D7Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82114D7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114D7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114D7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114D7C);
		  /* 82114D7Ch */ case    0:  		/* cmplw CR6, R11, R17 */
		/* 82114D7Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R17);
		/* 82114D7Ch case    0:*/		return 0x82114D80;
		  /* 82114D80h */ case    1:  		/* bc 4, CR6_EQ, 1016 */
		/* 82114D80h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82115178;  }
		/* 82114D80h case    1:*/		return 0x82114D84;
		  /* 82114D84h */ case    2:  		/* lwz R11, <#[R31 + 12]> */
		/* 82114D84h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82114D84h case    2:*/		return 0x82114D88;
		  /* 82114D88h */ case    3:  		/* mr R27, R22 */
		/* 82114D88h case    3:*/		regs.R27 = regs.R22;
		/* 82114D88h case    3:*/		return 0x82114D8C;
		  /* 82114D8Ch */ case    4:  		/* mr R29, R22 */
		/* 82114D8Ch case    4:*/		regs.R29 = regs.R22;
		/* 82114D8Ch case    4:*/		return 0x82114D90;
		  /* 82114D90h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82114D90h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82114D90h case    5:*/		return 0x82114D94;
		  /* 82114D94h */ case    6:  		/* bc 4, CR6_GT, 508 */
		/* 82114D94h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82114F90;  }
		/* 82114D94h case    6:*/		return 0x82114D98;
		  /* 82114D98h */ case    7:  		/* mr R28, R22 */
		/* 82114D98h case    7:*/		regs.R28 = regs.R22;
		/* 82114D98h case    7:*/		return 0x82114D9C;
		  /* 82114D9Ch */ case    8:  		/* lwz R10, <#[R31 + 12]> */
		/* 82114D9Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 82114D9Ch case    8:*/		return 0x82114DA0;
		  /* 82114DA0h */ case    9:  		/* lwz R8, <#[R31 + 8]> */
		/* 82114DA0h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 82114DA0h case    9:*/		return 0x82114DA4;
		  /* 82114DA4h */ case   10:  		/* rlwinm R9, R10, 1, 0, 30 */
		/* 82114DA4h case   10:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R10);
		/* 82114DA4h case   10:*/		return 0x82114DA8;
		  /* 82114DA8h */ case   11:  		/* lwz R11, <#[R26 + 20]> */
		/* 82114DA8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82114DA8h case   11:*/		return 0x82114DAC;
		  /* 82114DACh */ case   12:  		/* add R10, R10, R29 */
		/* 82114DACh case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R29);
		/* 82114DACh case   12:*/		return 0x82114DB0;
		  /* 82114DB0h */ case   13:  		/* lwz R6, <#[R31]> */
		/* 82114DB0h case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000000) );
		/* 82114DB0h case   13:*/		return 0x82114DB4;
		  /* 82114DB4h */ case   14:  		/* add R9, R9, R29 */
		/* 82114DB4h case   14:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R29);
		/* 82114DB4h case   14:*/		return 0x82114DB8;
		  /* 82114DB8h */ case   15:  		/* lwz R7, <#[R31 + 16]> */
		/* 82114DB8h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000010) );
		/* 82114DB8h case   15:*/		return 0x82114DBC;
		  /* 82114DBCh */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82114DBCh case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82114DBCh case   16:*/		return 0x82114DC0;
		  /* 82114DC0h */ case   17:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82114DC0h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82114DC0h case   17:*/		return 0x82114DC4;
		  /* 82114DC4h */ case   18:  		/* lwzx R5, <#[R8 + R28]> */
		/* 82114DC4h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R8 + regs.R28 + 0x00000000) );
		/* 82114DC4h case   18:*/		return 0x82114DC8;
		  /* 82114DC8h */ case   19:  		/* rlwinm R6, R6, 0, 0, 11 */
		/* 82114DC8h case   19:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R6,regs.R6);
		/* 82114DC8h case   19:*/		return 0x82114DCC;
		  /* 82114DCCh */ case   20:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 82114DCCh case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 82114DCCh case   20:*/		return 0x82114DD0;
		  /* 82114DD0h */ case   21:  		/* cmplw CR6, R6, R17 */
		/* 82114DD0h case   21:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R17);
		/* 82114DD0h case   21:*/		return 0x82114DD4;
		  /* 82114DD4h */ case   22:  		/* lwzx R30, <#[R7 + R28]> */
		/* 82114DD4h case   22:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R7 + regs.R28 + 0x00000000) );
		/* 82114DD4h case   22:*/		return 0x82114DD8;
		  /* 82114DD8h */ case   23:  		/* lwzx R10, <#[R10 + R8]> */
		/* 82114DD8h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 82114DD8h case   23:*/		return 0x82114DDC;
		  /* 82114DDCh */ case   24:  		/* lwzx R9, <#[R9 + R8]> */
		/* 82114DDCh case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82114DDCh case   24:*/		return 0x82114DE0;
		  /* 82114DE0h */ case   25:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82114DE0h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82114DE0h case   25:*/		return 0x82114DE4;
		  /* 82114DE4h */ case   26:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82114DE4h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82114DE4h case   26:*/		return 0x82114DE8;
		  /* 82114DE8h */ case   27:  		/* lwzx R8, <#[R5 + R11]> */
		/* 82114DE8h case   27:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 82114DE8h case   27:*/		return 0x82114DEC;
		  /* 82114DECh */ case   28:  		/* lwzx R10, <#[R10 + R11]> */
		/* 82114DECh case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82114DECh case   28:*/		return 0x82114DF0;
		  /* 82114DF0h */ case   29:  		/* lwzx R9, <#[R9 + R11]> */
		/* 82114DF0h case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82114DF0h case   29:*/		return 0x82114DF4;
		  /* 82114DF4h */ case   30:  		/* lwz R6, <#[R8 + 48]> */
		/* 82114DF4h case   30:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + 0x00000030) );
		/* 82114DF4h case   30:*/		return 0x82114DF8;
		  /* 82114DF8h */ case   31:  		/* lwz R7, <#[R10 + 48]> */
		/* 82114DF8h case   31:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000030) );
		/* 82114DF8h case   31:*/		return 0x82114DFC;
		  /* 82114DFCh */ case   32:  		/* lwz R8, <#[R9 + 48]> */
		/* 82114DFCh case   32:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000030) );
		/* 82114DFCh case   32:*/		return 0x82114E00;
		  /* 82114E00h */ case   33:  		/* bc 4, CR6_EQ, 284 */
		/* 82114E00h case   33:*/		if ( !regs.CR[6].eq ) { return 0x82114F1C;  }
		/* 82114E00h case   33:*/		return 0x82114E04;
		  /* 82114E04h */ case   34:  		/* rlwinm R9, R8, 2, 0, 29 */
		/* 82114E04h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 82114E04h case   34:*/		return 0x82114E08;
		  /* 82114E08h */ case   35:  		/* rlwinm R10, R7, 2, 0, 29 */
		/* 82114E08h case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R7);
		/* 82114E08h case   35:*/		return 0x82114E0C;
		  /* 82114E0Ch */ case   36:  		/* rlwinm R5, R30, 2, 0, 29 */
		/* 82114E0Ch case   36:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R30);
		/* 82114E0Ch case   36:*/		return 0x82114E10;
		  /* 82114E10h */ case   37:  		/* lwzx R4, <#[R9 + R11]> */
		/* 82114E10h case   37:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82114E10h case   37:*/		return 0x82114E14;
		  /* 82114E14h */ case   38:  		/* lwzx R10, <#[R10 + R11]> */
		/* 82114E14h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82114E14h case   38:*/		return 0x82114E18;
		  /* 82114E18h */ case   39:  		/* lwzx R9, <#[R5 + R11]> */
		/* 82114E18h case   39:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 82114E18h case   39:*/		return 0x82114E1C;
		  /* 82114E1Ch */ case   40:  		/* lwz R11, <#[R4]> */
		/* 82114E1Ch case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82114E1Ch case   40:*/		return 0x82114E20;
		  /* 82114E20h */ case   41:  		/* lwz R5, <#[R10]> */
		/* 82114E20h case   41:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000000) );
		/* 82114E20h case   41:*/		return 0x82114E24;
		  /* 82114E24h */ case   42:  		/* or R11, R5, R11 */
		/* 82114E24h case   42:*/		cpu::op::or<0>(regs,&regs.R11,regs.R5,regs.R11);
		/* 82114E24h case   42:*/		return 0x82114E28;
		  /* 82114E28h */ case   43:  		/* rlwinm R11, R11, 0, 4, 6 */
		/* 82114E28h case   43:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82114E28h case   43:*/		return 0x82114E2C;
		  /* 82114E2Ch */ case   44:  		/* rlwinm. R3, R11, 0, 4, 4 */
		/* 82114E2Ch case   44:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R3,regs.R11);
		/* 82114E2Ch case   44:*/		return 0x82114E30;
		  /* 82114E30h */ case   45:  		/* bc 12, CR0_EQ, 12 */
		/* 82114E30h case   45:*/		if ( regs.CR[0].eq ) { return 0x82114E3C;  }
		/* 82114E30h case   45:*/		return 0x82114E34;
		  /* 82114E34h */ case   46:  		/* lis R11, 2048 */
		/* 82114E34h case   46:*/		cpu::op::lis<0>(regs,&regs.R11,0x800);
		/* 82114E34h case   46:*/		return 0x82114E38;
		  /* 82114E38h */ case   47:  		/* b 32 */
		/* 82114E38h case   47:*/		return 0x82114E58;
		/* 82114E38h case   47:*/		return 0x82114E3C;
	}
	return 0x82114E3C;
} // Block from 82114D7Ch-82114E3Ch (48 instructions)

//////////////////////////////////////////////////////
// Block at 82114E3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114E3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114E3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114E3C);
		  /* 82114E3Ch */ case    0:  		/* rlwinm. R3, R11, 0, 5, 5 */
		/* 82114E3Ch case    0:*/		cpu::op::rlwinm<1,0,5,5>(regs,&regs.R3,regs.R11);
		/* 82114E3Ch case    0:*/		return 0x82114E40;
		  /* 82114E40h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82114E40h case    1:*/		if ( regs.CR[0].eq ) { return 0x82114E4C;  }
		/* 82114E40h case    1:*/		return 0x82114E44;
		  /* 82114E44h */ case    2:  		/* lis R11, 1024 */
		/* 82114E44h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x400);
		/* 82114E44h case    2:*/		return 0x82114E48;
		  /* 82114E48h */ case    3:  		/* b 16 */
		/* 82114E48h case    3:*/		return 0x82114E58;
		/* 82114E48h case    3:*/		return 0x82114E4C;
	}
	return 0x82114E4C;
} // Block from 82114E3Ch-82114E4Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82114E4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114E4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114E4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114E4C);
		  /* 82114E4Ch */ case    0:  		/* rlwinm. R3, R11, 0, 6, 6 */
		/* 82114E4Ch case    0:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R3,regs.R11);
		/* 82114E4Ch case    0:*/		return 0x82114E50;
		  /* 82114E50h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 82114E50h case    1:*/		if ( regs.CR[0].eq ) { return 0x82114E58;  }
		/* 82114E50h case    1:*/		return 0x82114E54;
		  /* 82114E54h */ case    2:  		/* lis R11, 512 */
		/* 82114E54h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x200);
		/* 82114E54h case    2:*/		return 0x82114E58;
	}
	return 0x82114E58;
} // Block from 82114E4Ch-82114E58h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82114E58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114E58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114E58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114E58);
		  /* 82114E58h */ case    0:  		/* lwz R9, <#[R9]> */
		/* 82114E58h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 82114E58h case    0:*/		return 0x82114E5C;
		  /* 82114E5Ch */ case    1:  		/* rlwinm R9, R9, 0, 4, 6 */
		/* 82114E5Ch case    1:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R9,regs.R9);
		/* 82114E5Ch case    1:*/		return 0x82114E60;
		  /* 82114E60h */ case    2:  		/* or R11, R9, R11 */
		/* 82114E60h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82114E60h case    2:*/		return 0x82114E64;
		  /* 82114E64h */ case    3:  		/* rlwinm. R9, R11, 0, 6, 6 */
		/* 82114E64h case    3:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R9,regs.R11);
		/* 82114E64h case    3:*/		return 0x82114E68;
		  /* 82114E68h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 82114E68h case    4:*/		if ( regs.CR[0].eq ) { return 0x82114E74;  }
		/* 82114E68h case    4:*/		return 0x82114E6C;
		  /* 82114E6Ch */ case    5:  		/* lis R11, 512 */
		/* 82114E6Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0x200);
		/* 82114E6Ch case    5:*/		return 0x82114E70;
		  /* 82114E70h */ case    6:  		/* b 32 */
		/* 82114E70h case    6:*/		return 0x82114E90;
		/* 82114E70h case    6:*/		return 0x82114E74;
	}
	return 0x82114E74;
} // Block from 82114E58h-82114E74h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82114E74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114E74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114E74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114E74);
		  /* 82114E74h */ case    0:  		/* rlwinm. R9, R11, 0, 5, 5 */
		/* 82114E74h case    0:*/		cpu::op::rlwinm<1,0,5,5>(regs,&regs.R9,regs.R11);
		/* 82114E74h case    0:*/		return 0x82114E78;
		  /* 82114E78h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82114E78h case    1:*/		if ( regs.CR[0].eq ) { return 0x82114E84;  }
		/* 82114E78h case    1:*/		return 0x82114E7C;
		  /* 82114E7Ch */ case    2:  		/* lis R11, 1024 */
		/* 82114E7Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x400);
		/* 82114E7Ch case    2:*/		return 0x82114E80;
		  /* 82114E80h */ case    3:  		/* b 16 */
		/* 82114E80h case    3:*/		return 0x82114E90;
		/* 82114E80h case    3:*/		return 0x82114E84;
	}
	return 0x82114E84;
} // Block from 82114E74h-82114E84h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82114E84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114E84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114E84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114E84);
		  /* 82114E84h */ case    0:  		/* rlwinm. R9, R11, 0, 4, 4 */
		/* 82114E84h case    0:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R9,regs.R11);
		/* 82114E84h case    0:*/		return 0x82114E88;
		  /* 82114E88h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 82114E88h case    1:*/		if ( regs.CR[0].eq ) { return 0x82114E90;  }
		/* 82114E88h case    1:*/		return 0x82114E8C;
		  /* 82114E8Ch */ case    2:  		/* lis R11, 2048 */
		/* 82114E8Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x800);
		/* 82114E8Ch case    2:*/		return 0x82114E90;
	}
	return 0x82114E90;
} // Block from 82114E84h-82114E90h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82114E90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114E90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114E90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114E90);
		  /* 82114E90h */ case    0:  		/* rlwinm R9, R5, 0, 4, 6 */
		/* 82114E90h case    0:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R9,regs.R5);
		/* 82114E90h case    0:*/		return 0x82114E94;
		  /* 82114E94h */ case    1:  		/* cmplw CR6, R11, R9 */
		/* 82114E94h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82114E94h case    1:*/		return 0x82114E98;
		  /* 82114E98h */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 82114E98h case    2:*/		if ( regs.CR[6].eq ) { return 0x82114ED4;  }
		/* 82114E98h case    2:*/		return 0x82114E9C;
		  /* 82114E9Ch */ case    3:  		/* lwz R9, <#[R10 + 4]> */
		/* 82114E9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 82114E9Ch case    3:*/		return 0x82114EA0;
		  /* 82114EA0h */ case    4:  		/* lwz R3, <#[R26 + 16]> */
		/* 82114EA0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x00000010) );
		/* 82114EA0h case    4:*/		return 0x82114EA4;
		  /* 82114EA4h */ case    5:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82114EA4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82114EA4h case    5:*/		return 0x82114EA8;
		  /* 82114EA8h */ case    6:  		/* lwzx R9, <#[R9 + R3]> */
		/* 82114EA8h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 82114EA8h case    6:*/		return 0x82114EAC;
		  /* 82114EACh */ case    7:  		/* lwz R9, <#[R9 + 4]> */
		/* 82114EACh case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 82114EACh case    7:*/		return 0x82114EB0;
		  /* 82114EB0h */ case    8:  		/* rlwinm. R9, R9, 0, 30, 30 */
		/* 82114EB0h case    8:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R9);
		/* 82114EB0h case    8:*/		return 0x82114EB4;
		  /* 82114EB4h */ case    9:  		/* bc 12, CR0_EQ, 32 */
		/* 82114EB4h case    9:*/		if ( regs.CR[0].eq ) { return 0x82114ED4;  }
		/* 82114EB4h case    9:*/		return 0x82114EB8;
		  /* 82114EB8h */ case   10:  		/* lwz R9, <#[R10 + 92]> */
		/* 82114EB8h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000005C) );
		/* 82114EB8h case   10:*/		return 0x82114EBC;
		  /* 82114EBCh */ case   11:  		/* cmplwi CR6, R9, 1 */
		/* 82114EBCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 82114EBCh case   11:*/		return 0x82114EC0;
		  /* 82114EC0h */ case   12:  		/* bc 4, CR6_EQ, 20 */
		/* 82114EC0h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82114ED4;  }
		/* 82114EC0h case   12:*/		return 0x82114EC4;
		  /* 82114EC4h */ case   13:  		/* rlwinm R9, R5, 0, 7, 3 */
		/* 82114EC4h case   13:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R9,regs.R5);
		/* 82114EC4h case   13:*/		return 0x82114EC8;
		  /* 82114EC8h */ case   14:  		/* mr R23, R21 */
		/* 82114EC8h case   14:*/		regs.R23 = regs.R21;
		/* 82114EC8h case   14:*/		return 0x82114ECC;
		  /* 82114ECCh */ case   15:  		/* or R9, R9, R11 */
		/* 82114ECCh case   15:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 82114ECCh case   15:*/		return 0x82114ED0;
		  /* 82114ED0h */ case   16:  		/* stw R9, <#[R10]> */
		/* 82114ED0h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82114ED0h case   16:*/		return 0x82114ED4;
	}
	return 0x82114ED4;
} // Block from 82114E90h-82114ED4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82114ED4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114ED4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114ED4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114ED4);
		  /* 82114ED4h */ case    0:  		/* lwz R10, <#[R4]> */
		/* 82114ED4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 82114ED4h case    0:*/		return 0x82114ED8;
		  /* 82114ED8h */ case    1:  		/* rlwinm R9, R10, 0, 4, 6 */
		/* 82114ED8h case    1:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R9,regs.R10);
		/* 82114ED8h case    1:*/		return 0x82114EDC;
		  /* 82114EDCh */ case    2:  		/* cmplw CR6, R11, R9 */
		/* 82114EDCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82114EDCh case    2:*/		return 0x82114EE0;
		  /* 82114EE0h */ case    3:  		/* bc 12, CR6_EQ, 60 */
		/* 82114EE0h case    3:*/		if ( regs.CR[6].eq ) { return 0x82114F1C;  }
		/* 82114EE0h case    3:*/		return 0x82114EE4;
		  /* 82114EE4h */ case    4:  		/* lwz R9, <#[R4 + 4]> */
		/* 82114EE4h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000004) );
		/* 82114EE4h case    4:*/		return 0x82114EE8;
		  /* 82114EE8h */ case    5:  		/* lwz R5, <#[R26 + 16]> */
		/* 82114EE8h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R26 + 0x00000010) );
		/* 82114EE8h case    5:*/		return 0x82114EEC;
		  /* 82114EECh */ case    6:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82114EECh case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82114EECh case    6:*/		return 0x82114EF0;
		  /* 82114EF0h */ case    7:  		/* lwzx R9, <#[R9 + R5]> */
		/* 82114EF0h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R5 + 0x00000000) );
		/* 82114EF0h case    7:*/		return 0x82114EF4;
		  /* 82114EF4h */ case    8:  		/* lwz R9, <#[R9 + 4]> */
		/* 82114EF4h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 82114EF4h case    8:*/		return 0x82114EF8;
		  /* 82114EF8h */ case    9:  		/* rlwinm. R9, R9, 0, 30, 30 */
		/* 82114EF8h case    9:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R9);
		/* 82114EF8h case    9:*/		return 0x82114EFC;
		  /* 82114EFCh */ case   10:  		/* bc 12, CR0_EQ, 32 */
		/* 82114EFCh case   10:*/		if ( regs.CR[0].eq ) { return 0x82114F1C;  }
		/* 82114EFCh case   10:*/		return 0x82114F00;
		  /* 82114F00h */ case   11:  		/* lwz R9, <#[R4 + 92]> */
		/* 82114F00h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x0000005C) );
		/* 82114F00h case   11:*/		return 0x82114F04;
		  /* 82114F04h */ case   12:  		/* cmplwi CR6, R9, 1 */
		/* 82114F04h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 82114F04h case   12:*/		return 0x82114F08;
		  /* 82114F08h */ case   13:  		/* bc 4, CR6_EQ, 20 */
		/* 82114F08h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82114F1C;  }
		/* 82114F08h case   13:*/		return 0x82114F0C;
		  /* 82114F0Ch */ case   14:  		/* rlwinm R10, R10, 0, 7, 3 */
		/* 82114F0Ch case   14:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R10,regs.R10);
		/* 82114F0Ch case   14:*/		return 0x82114F10;
		  /* 82114F10h */ case   15:  		/* mr R23, R21 */
		/* 82114F10h case   15:*/		regs.R23 = regs.R21;
		/* 82114F10h case   15:*/		return 0x82114F14;
		  /* 82114F14h */ case   16:  		/* or R11, R10, R11 */
		/* 82114F14h case   16:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82114F14h case   16:*/		return 0x82114F18;
		  /* 82114F18h */ case   17:  		/* stw R11, <#[R4]> */
		/* 82114F18h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82114F18h case   17:*/		return 0x82114F1C;
	}
	return 0x82114F1C;
} // Block from 82114ED4h-82114F1Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 82114F1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114F1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114F1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114F1C);
		  /* 82114F1Ch */ case    0:  		/* mr R5, R30 */
		/* 82114F1Ch case    0:*/		regs.R5 = regs.R30;
		/* 82114F1Ch case    0:*/		return 0x82114F20;
		  /* 82114F20h */ case    1:  		/* mr R4, R31 */
		/* 82114F20h case    1:*/		regs.R4 = regs.R31;
		/* 82114F20h case    1:*/		return 0x82114F24;
		  /* 82114F24h */ case    2:  		/* mr R3, R26 */
		/* 82114F24h case    2:*/		regs.R3 = regs.R26;
		/* 82114F24h case    2:*/		return 0x82114F28;
		  /* 82114F28h */ case    3:  		/* bl -70984 */
		/* 82114F28h case    3:*/		regs.LR = 0x82114F2C; return 0x821039E0;
		/* 82114F28h case    3:*/		return 0x82114F2C;
		  /* 82114F2Ch */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 82114F2Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82114F2Ch case    4:*/		return 0x82114F30;
		  /* 82114F30h */ case    5:  		/* bc 12, CR0_LT, 1844 */
		/* 82114F30h case    5:*/		if ( regs.CR[0].lt ) { return 0x82115664;  }
		/* 82114F30h case    5:*/		return 0x82114F34;
		  /* 82114F34h */ case    6:  		/* lwz R11, <#[R26 + 20]> */
		/* 82114F34h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82114F34h case    6:*/		return 0x82114F38;
		  /* 82114F38h */ case    7:  		/* rlwinm R9, R30, 2, 0, 29 */
		/* 82114F38h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R30);
		/* 82114F38h case    7:*/		return 0x82114F3C;
		  /* 82114F3Ch */ case    8:  		/* lwzx R10, <#[R9 + R11]> */
		/* 82114F3Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82114F3Ch case    8:*/		return 0x82114F40;
		  /* 82114F40h */ case    9:  		/* lwz R10, <#[R10 + 48]> */
		/* 82114F40h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 82114F40h case    9:*/		return 0x82114F44;
		  /* 82114F44h */ case   10:  		/* cmplw CR6, R10, R30 */
		/* 82114F44h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R30);
		/* 82114F44h case   10:*/		return 0x82114F48;
		  /* 82114F48h */ case   11:  		/* bc 4, CR6_EQ, 12 */
		/* 82114F48h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82114F54;  }
		/* 82114F48h case   11:*/		return 0x82114F4C;
		  /* 82114F4Ch */ case   12:  		/* addi R27, R27, 1 */
		/* 82114F4Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82114F4Ch case   12:*/		return 0x82114F50;
		  /* 82114F50h */ case   13:  		/* b 44 */
		/* 82114F50h case   13:*/		return 0x82114F7C;
		/* 82114F50h case   13:*/		return 0x82114F54;
	}
	return 0x82114F54;
} // Block from 82114F1Ch-82114F54h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82114F54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114F54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114F54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114F54);
		  /* 82114F54h */ case    0:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82114F54h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82114F54h case    0:*/		return 0x82114F58;
		  /* 82114F58h */ case    1:  		/* lwzx R10, <#[R10 + R11]> */
		/* 82114F58h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82114F58h case    1:*/		return 0x82114F5C;
		  /* 82114F5Ch */ case    2:  		/* lwz R10, <#[R10 + 48]> */
		/* 82114F5Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 82114F5Ch case    2:*/		return 0x82114F60;
		  /* 82114F60h */ case    3:  		/* cmpwi CR6, R10, -1 */
		/* 82114F60h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82114F60h case    3:*/		return 0x82114F64;
		  /* 82114F64h */ case    4:  		/* bc 4, CR6_EQ, 24 */
		/* 82114F64h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82114F7C;  }
		/* 82114F64h case    4:*/		return 0x82114F68;
		  /* 82114F68h */ case    5:  		/* lwzx R10, <#[R9 + R11]> */
		/* 82114F68h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82114F68h case    5:*/		return 0x82114F6C;
		  /* 82114F6Ch */ case    6:  		/* lwz R10, <#[R10 + 48]> */
		/* 82114F6Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 82114F6Ch case    6:*/		return 0x82114F70;
		  /* 82114F70h */ case    7:  		/* rlwinm R9, R10, 2, 0, 29 */
		/* 82114F70h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R10);
		/* 82114F70h case    7:*/		return 0x82114F74;
		  /* 82114F74h */ case    8:  		/* lwzx R11, <#[R9 + R11]> */
		/* 82114F74h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82114F74h case    8:*/		return 0x82114F78;
		  /* 82114F78h */ case    9:  		/* stw R10, <#[R11 + 48]> */
		/* 82114F78h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82114F78h case    9:*/		return 0x82114F7C;
	}
	return 0x82114F7C;
} // Block from 82114F54h-82114F7Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82114F7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114F7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114F7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114F7C);
		  /* 82114F7Ch */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82114F7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82114F7Ch case    0:*/		return 0x82114F80;
		  /* 82114F80h */ case    1:  		/* addi R29, R29, 1 */
		/* 82114F80h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82114F80h case    1:*/		return 0x82114F84;
		  /* 82114F84h */ case    2:  		/* addi R28, R28, 4 */
		/* 82114F84h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82114F84h case    2:*/		return 0x82114F88;
		  /* 82114F88h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 82114F88h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82114F88h case    3:*/		return 0x82114F8C;
		  /* 82114F8Ch */ case    4:  		/* bc 12, CR6_LT, -496 */
		/* 82114F8Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x82114D9C;  }
		/* 82114F8Ch case    4:*/		return 0x82114F90;
	}
	return 0x82114F90;
} // Block from 82114F7Ch-82114F90h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82114F90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114F90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114F90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114F90);
		  /* 82114F90h */ case    0:  		/* lwz R7, <#[R31 + 12]> */
		/* 82114F90h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 82114F90h case    0:*/		return 0x82114F94;
		  /* 82114F94h */ case    1:  		/* cmplw CR6, R27, R7 */
		/* 82114F94h case    1:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R7);
		/* 82114F94h case    1:*/		return 0x82114F98;
		  /* 82114F98h */ case    2:  		/* bc 12, CR6_EQ, 1412 */
		/* 82114F98h case    2:*/		if ( regs.CR[6].eq ) { return 0x8211551C;  }
		/* 82114F98h case    2:*/		return 0x82114F9C;
		  /* 82114F9Ch */ case    3:  		/* cmplwi CR6, R27, 0 */
		/* 82114F9Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82114F9Ch case    3:*/		return 0x82114FA0;
		  /* 82114FA0h */ case    4:  		/* bc 4, CR6_EQ, 268 */
		/* 82114FA0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821150AC;  }
		/* 82114FA0h case    4:*/		return 0x82114FA4;
		  /* 82114FA4h */ case    5:  		/* mr R6, R21 */
		/* 82114FA4h case    5:*/		regs.R6 = regs.R21;
		/* 82114FA4h case    5:*/		return 0x82114FA8;
		  /* 82114FA8h */ case    6:  		/* cmplwi CR6, R7, 1 */
		/* 82114FA8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000001);
		/* 82114FA8h case    6:*/		return 0x82114FAC;
		  /* 82114FACh */ case    7:  		/* bc 4, CR6_GT, 100 */
		/* 82114FACh case    7:*/		if ( !regs.CR[6].gt ) { return 0x82115010;  }
		/* 82114FACh case    7:*/		return 0x82114FB0;
		  /* 82114FB0h */ case    8:  		/* lwz R9, <#[R31 + 16]> */
		/* 82114FB0h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 82114FB0h case    8:*/		return 0x82114FB4;
		  /* 82114FB4h */ case    9:  		/* li R10, 4 */
		/* 82114FB4h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 82114FB4h case    9:*/		return 0x82114FB8;
	}
	return 0x82114FB8;
} // Block from 82114F90h-82114FB8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82114FB8h
// Function '?SimplifyInstructions@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82114FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82114FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82114FB8);
		  /* 82114FB8h */ case    0:  		/* lwz R11, <#[R26 + 20]> */
		/* 82114FB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82114FB8h case    0:*/		return 0x82114FBC;
		  /* 82114FBCh */ case    1:  		/* lwz R8, <#[R9]> */
		/* 82114FBCh case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 82114FBCh case    1:*/		return 0x82114FC0;
		  /* 82114FC0h */ case    2:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82114FC0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82114FC0h case    2:*/		return 0x82114FC4;
		  /* 82114FC4h */ case    3:  		/* lwzx R5, <#[R9 + R10]> */
		/* 82114FC4h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82114FC4h case    3:*/		return 0x82114FC8;
		  /* 82114FC8h */ case    4:  		/* lwzx R4, <#[R8 + R11]> */
		/* 82114FC8h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82114FC8h case    4:*/		return 0x82114FCC;
		  /* 82114FCCh */ case    5:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 82114FCCh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 82114FCCh case    5:*/		return 0x82114FD0;
		  /* 82114FD0h */ case    6:  		/* lwz R4, <#[R4 + 48]> */
		/* 82114FD0h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000030) );
		/* 82114FD0h case    6:*/		return 0x82114FD4;
		  /* 82114FD4h */ case    7:  		/* lwzx R5, <#[R5 + R11]> */
		/* 82114FD4h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 82114FD4h case    7:*/		return 0x82114FD8;
		  /* 82114FD8h */ case    8:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 82114FD8h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 82114FD8h case    8:*/		return 0x82114FDC;
		  /* 82114FDCh */ case    9:  		/* lwz R5, <#[R5 + 48]> */
		/* 82114FDCh case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000030) );
		/* 82114FDCh case    9:*/		return 0x82114FE0;
		  /* 82114FE0h */ case   10:  		/* lwzx R4, <#[R4 + R11]> */
		/* 82114FE0h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + regs.R11 + 0x00000000) );
		/* 82114FE0h case   10:*/		return 0x82114FE4;
		  /* 82114FE4h */ case   11:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 82114FE4h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 82114FE4h case   11:*/		return 0x82114FE8;
		  /* 82114FE8h */ case   12:  		/* lwz R4, <#[R4 + 4]> */
		/* 82114FE8h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000004) );
		/* 82114FE8h case   12:*/		return 0x82114FEC;
		  /* 82114FECh */ case   13:  		/* lwzx R5, <#[R5 + R11]> */
		/* 82114FECh case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 82114FECh case   13:*/		return 0x82114FF0;
		  /* 82114FF0h */ case   14:  		/* lwz R5, <#[R5 + 4]> */
		/* 82114FF0h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000004) );
		/* 82114FF0h case   14:*/		return 0x82114FF4;
		  /* 82114FF4h */ case   15:  		/* cmplw CR6, R4, R5 */
		/* 82114FF4h case   15:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R5);
		/* 82114FF4h case   15:*/		return 0x82114FF8;
		  /* 82114FF8h */ case   16:  		/* bc 4, CR6_EQ, 172 */
		/* 82114FF8h case   16:*/		if ( !regs.CR[6].eq ) { return 0x821150A4;  }
		/* 82114FF8h case   16:*/		return 0x82114FFC;
		  /* 82114FFCh */ case   17:  		/* lwz R5, <#[R31 + 12]> */
		/* 82114FFCh case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 82114FFCh case   17:*/		return 0x82115000;
		  /* 82115000h */ case   18:  		/* addi R6, R6, 1 */
		/* 82115000h case   18:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82115000h case   18:*/		return 0x82115004;
		  /* 82115004h */ case   19:  		/* addi R10, R10, 4 */
		/* 82115004h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82115004h case   19:*/		return 0x82115008;
		  /* 82115008h */ case   20:  		/* cmplw CR6, R6, R5 */
		/* 82115008h case   20:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R5);
		/* 82115008h case   20:*/		return 0x8211500C;
		  /* 8211500Ch */ case   21:  		/* bc 12, CR6_LT, -72 */
		/* 8211500Ch case   21:*/		if ( regs.CR[6].lt ) { return 0x82114FC4;  }
		/* 8211500Ch case   21:*/		return 0x82115010;
	}
	return 0x82115010;
} // Block from 82114FB8h-82115010h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82115010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82115010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82115010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82115010);
		  /* 82115010h */ case    0:  		/* mr R8, R22 */
		/* 82115010h case    0:*/		regs.R8 = regs.R22;
		/* 82115010h case    0:*/		return 0x82115014;
		  /* 82115014h */ case    1:  		/* cmplwi CR6, R7, 0 */
		/* 82115014h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82115014h case    1:*/		return 0x82115018;
		  /* 82115018h */ case    2:  		/* bc 12, CR6_EQ, 1268 */
		/* 82115018h case    2:*/		if ( regs.CR[6].eq ) { return 0x8211550C;  }
		/* 82115018h case    2:*/		return 0x8211501C;
		  /* 8211501Ch */ case    3:  		/* mr R10, R22 */
		/* 8211501Ch case    3:*/		regs.R10 = regs.R22;
		/* 8211501Ch case    3:*/		return 0x82115020;
		  /* 82115020h */ case    4:  		/* lwz R11, <#[R31 + 16]> */
		/* 82115020h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82115020h case    4:*/		return 0x82115024;
		  /* 82115024h */ case    5:  		/* lwz R7, <#[R26 + 20]> */
		/* 82115024h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R26 + 0x00000014) );
		/* 82115024h case    5:*/		return 0x82115028;
		  /* 82115028h */ case    6:  		/* lwz R6, <#[R26 + 16]> */
		/* 82115028h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R26 + 0x00000010) );
		/* 82115028h case    6:*/		return 0x8211502C;
		  /* 8211502Ch */ case    7:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8211502Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8211502Ch case    7:*/		return 0x82115030;
		  /* 82115030h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82115030h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82115030h case    8:*/		return 0x82115034;
		  /* 82115034h */ case    9:  		/* lwzx R9, <#[R11 + R7]> */
		/* 82115034h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82115034h case    9:*/		return 0x82115038;
		  /* 82115038h */ case   10:  		/* lwz R11, <#[R9 + 48]> */
		/* 82115038h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000030) );
		/* 82115038h case   10:*/		return 0x8211503C;
		  /* 8211503Ch */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8211503Ch case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8211503Ch case   11:*/		return 0x82115040;
		  /* 82115040h */ case   12:  		/* lwzx R11, <#[R11 + R7]> */
		/* 82115040h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82115040h case   12:*/		return 0x82115044;
		  /* 82115044h */ case   13:  		/* lwz R7, <#[R11 + 4]> */
		/* 82115044h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82115044h case   13:*/		return 0x82115048;
		  /* 82115048h */ case   14:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82115048h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82115048h case   14:*/		return 0x8211504C;
		  /* 8211504Ch */ case   15:  		/* lwzx R7, <#[R7 + R6]> */
		/* 8211504Ch case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R6 + 0x00000000) );
		/* 8211504Ch case   15:*/		return 0x82115050;
		  /* 82115050h */ case   16:  		/* lwz R7, <#[R7 + 4]> */
		/* 82115050h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000004) );
		/* 82115050h case   16:*/		return 0x82115054;
		  /* 82115054h */ case   17:  		/* rlwinm. R7, R7, 0, 30, 30 */
		/* 82115054h case   17:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R7,regs.R7);
		/* 82115054h case   17:*/		return 0x82115058;
		  /* 82115058h */ case   18:  		/* bc 12, CR0_EQ, 52 */
		/* 82115058h case   18:*/		if ( regs.CR[0].eq ) { return 0x8211508C;  }
		/* 82115058h case   18:*/		return 0x8211505C;
		  /* 8211505Ch */ case   19:  		/* lwz R7, <#[R11 + 96]> */
		/* 8211505Ch case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000060) );
		/* 8211505Ch case   19:*/		return 0x82115060;
		  /* 82115060h */ case   20:  		/* cmplwi CR6, R7, 0 */
		/* 82115060h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82115060h case   20:*/		return 0x82115064;
		  /* 82115064h */ case   21:  		/* bc 4, CR6_EQ, 40 */
		/* 82115064h case   21:*/		if ( !regs.CR[6].eq ) { return 0x8211508C;  }
		/* 82115064h case   21:*/		return 0x82115068;
		  /* 82115068h */ case   22:  		/* lwz R9, <#[R9 + 96]> */
		/* 82115068h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000060) );
		/* 82115068h case   22:*/		return 0x8211506C;
		  /* 8211506Ch */ case   23:  		/* stw R9, <#[R11 + 96]> */
		/* 8211506Ch case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000060) );
		/* 8211506Ch case   23:*/		return 0x82115070;
		  /* 82115070h */ case   24:  		/* lwz R9, <#[R31 + 16]> */
		/* 82115070h case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 82115070h case   24:*/		return 0x82115074;
		  /* 82115074h */ case   25:  		/* lwz R7, <#[R26 + 20]> */
		/* 82115074h case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R26 + 0x00000014) );
		/* 82115074h case   25:*/		return 0x82115078;
		  /* 82115078h */ case   26:  		/* lwzx R9, <#[R9 + R10]> */
		/* 82115078h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82115078h case   26:*/		return 0x8211507C;
		  /* 8211507Ch */ case   27:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8211507Ch case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8211507Ch case   27:*/		return 0x82115080;
		  /* 82115080h */ case   28:  		/* lwzx R9, <#[R9 + R7]> */
		/* 82115080h case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 82115080h case   28:*/		return 0x82115084;
		  /* 82115084h */ case   29:  		/* lwz R9, <#[R9 + 100]> */
		/* 82115084h case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000064) );
		/* 82115084h case   29:*/		return 0x82115088;
		  /* 82115088h */ case   30:  		/* stw R9, <#[R11 + 100]> */
		/* 82115088h case   30:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000064) );
		/* 82115088h case   30:*/		return 0x8211508C;
	}
	return 0x8211508C;
} // Block from 82115010h-8211508Ch (31 instructions)

//////////////////////////////////////////////////////
// Block at 8211508Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211508C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211508C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211508C);
		  /* 8211508Ch */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8211508Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8211508Ch case    0:*/		return 0x82115090;
		  /* 82115090h */ case    1:  		/* addi R8, R8, 1 */
		/* 82115090h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82115090h case    1:*/		return 0x82115094;
		  /* 82115094h */ case    2:  		/* addi R10, R10, 4 */
		/* 82115094h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82115094h case    2:*/		return 0x82115098;
		  /* 82115098h */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 82115098h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 82115098h case    3:*/		return 0x8211509C;
		  /* 8211509Ch */ case    4:  		/* bc 12, CR6_LT, -124 */
		/* 8211509Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x82115020;  }
		/* 8211509Ch case    4:*/		return 0x821150A0;
		  /* 821150A0h */ case    5:  		/* b 1132 */
		/* 821150A0h case    5:*/		return 0x8211550C;
		/* 821150A0h case    5:*/		return 0x821150A4;
	}
	return 0x821150A4;
} // Block from 8211508Ch-821150A4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821150A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821150A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821150A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821150A4);
		  /* 821150A4h */ case    0:  		/* cmplwi CR0, R7, 0 */
		/* 821150A4h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R7,0x00000000);
		/* 821150A4h case    0:*/		return 0x821150A8;
		  /* 821150A8h */ case    1:  		/* bc 12, CR0_EQ, -152 */
		/* 821150A8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82115010;  }
		/* 821150A8h case    1:*/		return 0x821150AC;
	}
	return 0x821150AC;
} // Block from 821150A4h-821150ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821150ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821150AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821150AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821150AC);
		  /* 821150ACh */ case    0:  		/* mr R6, R22 */
		/* 821150ACh case    0:*/		regs.R6 = regs.R22;
		/* 821150ACh case    0:*/		return 0x821150B0;
		  /* 821150B0h */ case    1:  		/* cmplwi CR6, R7, 0 */
		/* 821150B0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 821150B0h case    1:*/		return 0x821150B4;
		  /* 821150B4h */ case    2:  		/* bc 12, CR6_EQ, 120 */
		/* 821150B4h case    2:*/		if ( regs.CR[6].eq ) { return 0x8211512C;  }
		/* 821150B4h case    2:*/		return 0x821150B8;
		  /* 821150B8h */ case    3:  		/* mr R7, R22 */
		/* 821150B8h case    3:*/		regs.R7 = regs.R22;
		/* 821150B8h case    3:*/		return 0x821150BC;
		  /* 821150BCh */ case    4:  		/* lwz R10, <#[R31 + 16]> */
		/* 821150BCh case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 821150BCh case    4:*/		return 0x821150C0;
		  /* 821150C0h */ case    5:  		/* lwz R11, <#[R26 + 20]> */
		/* 821150C0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 821150C0h case    5:*/		return 0x821150C4;
		  /* 821150C4h */ case    6:  		/* lwzx R10, <#[R10 + R7]> */
		/* 821150C4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 821150C4h case    6:*/		return 0x821150C8;
		  /* 821150C8h */ case    7:  		/* rlwinm R9, R10, 2, 0, 29 */
		/* 821150C8h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R10);
		/* 821150C8h case    7:*/		return 0x821150CC;
		  /* 821150CCh */ case    8:  		/* lwzx R8, <#[R9 + R11]> */
		/* 821150CCh case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821150CCh case    8:*/		return 0x821150D0;
		  /* 821150D0h */ case    9:  		/* lwz R5, <#[R8 + 48]> */
		/* 821150D0h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R8 + 0x00000030) );
		/* 821150D0h case    9:*/		return 0x821150D4;
		  /* 821150D4h */ case   10:  		/* cmplw CR6, R5, R10 */
		/* 821150D4h case   10:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R10);
		/* 821150D4h case   10:*/		return 0x821150D8;
		  /* 821150D8h */ case   11:  		/* bc 12, CR6_EQ, 64 */
		/* 821150D8h case   11:*/		if ( regs.CR[6].eq ) { return 0x82115118;  }
		/* 821150D8h case   11:*/		return 0x821150DC;
		  /* 821150DCh */ case   12:  		/* rlwinm R5, R8, 0, 0, 31 */
		/* 821150DCh case   12:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R5,regs.R8);
		/* 821150DCh case   12:*/		return 0x821150E0;
		  /* 821150E0h */ case   13:  		/* lwz R4, <#[R5 + 48]> */
		/* 821150E0h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x00000030) );
		/* 821150E0h case   13:*/		return 0x821150E4;
		  /* 821150E4h */ case   14:  		/* lwz R5, <#[R5]> */
		/* 821150E4h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000000) );
		/* 821150E4h case   14:*/		return 0x821150E8;
		  /* 821150E8h */ case   15:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 821150E8h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 821150E8h case   15:*/		return 0x821150EC;
		  /* 821150ECh */ case   16:  		/* lwzx R11, <#[R4 + R11]> */
		/* 821150ECh case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + regs.R11 + 0x00000000) );
		/* 821150ECh case   16:*/		return 0x821150F0;
		  /* 821150F0h */ case   17:  		/* lwz R11, <#[R11]> */
		/* 821150F0h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821150F0h case   17:*/		return 0x821150F4;
		  /* 821150F4h */ case   18:  		/* rlwinm R11, R11, 0, 7, 3 */
		/* 821150F4h case   18:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R11,regs.R11);
		/* 821150F4h case   18:*/		return 0x821150F8;
		  /* 821150F8h */ case   19:  		/* or R11, R11, R5 */
		/* 821150F8h case   19:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 821150F8h case   19:*/		return 0x821150FC;
		  /* 821150FCh */ case   20:  		/* cmplw CR6, R5, R11 */
		/* 821150FCh case   20:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 821150FCh case   20:*/		return 0x82115100;
		  /* 82115100h */ case   21:  		/* bc 12, CR6_EQ, 12 */
		/* 82115100h case   21:*/		if ( regs.CR[6].eq ) { return 0x8211510C;  }
		/* 82115100h case   21:*/		return 0x82115104;
		  /* 82115104h */ case   22:  		/* stw R11, <#[R8]> */
		/* 82115104h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82115104h case   22:*/		return 0x82115108;
		  /* 82115108h */ case   23:  		/* mr R23, R21 */
		/* 82115108h case   23:*/		regs.R23 = regs.R21;
		/* 82115108h case   23:*/		return 0x8211510C;
	}
	return 0x8211510C;
} // Block from 821150ACh-8211510Ch (24 instructions)

//////////////////////////////////////////////////////
// Block at 8211510Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211510C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211510C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211510C);
		  /* 8211510Ch */ case    0:  		/* lwz R11, <#[R26 + 20]> */
		/* 8211510Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 8211510Ch case    0:*/		return 0x82115110;
		  /* 82115110h */ case    1:  		/* lwzx R11, <#[R9 + R11]> */
		/* 82115110h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82115110h case    1:*/		return 0x82115114;
		  /* 82115114h */ case    2:  		/* stw R10, <#[R11 + 48]> */
		/* 82115114h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82115114h case    2:*/		return 0x82115118;
	}
	return 0x82115118;
} // Block from 8211510Ch-82115118h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82115118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82115118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82115118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82115118);
		  /* 82115118h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82115118h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82115118h case    0:*/		return 0x8211511C;
		  /* 8211511Ch */ case    1:  		/* addi R6, R6, 1 */
		/* 8211511Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8211511Ch case    1:*/		return 0x82115120;
		  /* 82115120h */ case    2:  		/* addi R7, R7, 4 */
		/* 82115120h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82115120h case    2:*/		return 0x82115124;
		  /* 82115124h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 82115124h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 82115124h case    3:*/		return 0x82115128;
		  /* 82115128h */ case    4:  		/* bc 12, CR6_LT, -108 */
		/* 82115128h case    4:*/		if ( regs.CR[6].lt ) { return 0x821150BC;  }
		/* 82115128h case    4:*/		return 0x8211512C;
	}
	return 0x8211512C;
} // Block from 82115118h-8211512Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8211512Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211512C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211512C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211512C);
		  /* 8211512Ch */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 8211512Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 8211512Ch case    0:*/		return 0x82115130;
		  /* 82115130h */ case    1:  		/* mr R28, R24 */
		/* 82115130h case    1:*/		regs.R28 = regs.R24;
		/* 82115130h case    1:*/		return 0x82115134;
		  /* 82115134h */ case    2:  		/* cmplw CR6, R24, R11 */
		/* 82115134h case    2:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R11);
		/* 82115134h case    2:*/		return 0x82115138;
		  /* 82115138h */ case    3:  		/* bc 4, CR6_LT, -1112 */
		/* 82115138h case    3:*/		if ( !regs.CR[6].lt ) { return 0x82114CE0;  }
		/* 82115138h case    3:*/		return 0x8211513C;
		  /* 8211513Ch */ case    4:  		/* rlwinm R30, R24, 2, 0, 29 */
		/* 8211513Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R24);
		/* 8211513Ch case    4:*/		return 0x82115140;
		  /* 82115140h */ case    5:  		/* lwz R11, <#[R26 + 20]> */
		/* 82115140h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82115140h case    5:*/		return 0x82115144;
		  /* 82115144h */ case    6:  		/* lwzx R29, <#[R11 + R30]> */
		/* 82115144h case    6:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82115144h case    6:*/		return 0x82115148;
		  /* 82115148h */ case    7:  		/* cmplwi CR6, R29, 0 */
		/* 82115148h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82115148h case    7:*/		return 0x8211514C;
		  /* 8211514Ch */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 8211514Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x82115160;  }
		/* 8211514Ch case    8:*/		return 0x82115150;
		  /* 82115150h */ case    9:  		/* mr R3, R29 */
		/* 82115150h case    9:*/		regs.R3 = regs.R29;
		/* 82115150h case    9:*/		return 0x82115154;
		  /* 82115154h */ case   10:  		/* bl 1081964 */
		/* 82115154h case   10:*/		regs.LR = 0x82115158; return 0x8221D3C0;
		/* 82115154h case   10:*/		return 0x82115158;
		  /* 82115158h */ case   11:  		/* mr R3, R29 */
		/* 82115158h case   11:*/		regs.R3 = regs.R29;
		/* 82115158h case   11:*/		return 0x8211515C;
		  /* 8211515Ch */ case   12:  		/* bl -99292 */
		/* 8211515Ch case   12:*/		regs.LR = 0x82115160; return 0x820FCD80;
		/* 8211515Ch case   12:*/		return 0x82115160;
	}
	return 0x82115160;
} // Block from 8211512Ch-82115160h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82115160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82115160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82115160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82115160);
		  /* 82115160h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 82115160h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82115160h case    0:*/		return 0x82115164;
		  /* 82115164h */ case    1:  		/* addi R28, R28, 1 */
		/* 82115164h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82115164h case    1:*/		return 0x82115168;
		  /* 82115168h */ case    2:  		/* addi R30, R30, 4 */
		/* 82115168h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82115168h case    2:*/		return 0x8211516C;
		  /* 8211516Ch */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 8211516Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 8211516Ch case    3:*/		return 0x82115170;
		  /* 82115170h */ case    4:  		/* bc 12, CR6_LT, -48 */
		/* 82115170h case    4:*/		if ( regs.CR[6].lt ) { return 0x82115140;  }
		/* 82115170h case    4:*/		return 0x82115174;
		  /* 82115174h */ case    5:  		/* b -1172 */
		/* 82115174h case    5:*/		return 0x82114CE0;
		/* 82115174h case    5:*/		return 0x82115178;
	}
	return 0x82115178;
} // Block from 82115160h-82115178h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82115178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82115178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82115178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82115178);
		  /* 82115178h */ case    0:  		/* lis R11, 20480 */
		/* 82115178h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x5000);
		/* 82115178h case    0:*/		return 0x8211517C;
		  /* 8211517Ch */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 8211517Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8211517Ch case    1:*/		return 0x82115180;
		  /* 82115180h */ case    2:  		/* bc 4, CR6_EQ, 188 */
		/* 82115180h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8211523C;  }
		/* 82115180h case    2:*/		return 0x82115184;
		  /* 82115184h */ case    3:  		/* li R5, 1 */
		/* 82115184h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82115184h case    3:*/		return 0x82115188;
		  /* 82115188h */ case    4:  		/* mr R4, R31 */
		/* 82115188h case    4:*/		regs.R4 = regs.R31;
		/* 82115188h case    4:*/		return 0x8211518C;
		  /* 8211518Ch */ case    5:  		/* mr R3, R26 */
		/* 8211518Ch case    5:*/		regs.R3 = regs.R26;
		/* 8211518Ch case    5:*/		return 0x82115190;
		  /* 82115190h */ case    6:  		/* bl -69664 */
		/* 82115190h case    6:*/		regs.LR = 0x82115194; return 0x82104170;
		/* 82115190h case    6:*/		return 0x82115194;
		  /* 82115194h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 82115194h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82115194h case    7:*/		return 0x82115198;
		  /* 82115198h */ case    8:  		/* bc 12, CR0_LT, 1228 */
		/* 82115198h case    8:*/		if ( regs.CR[0].lt ) { return 0x82115664;  }
		/* 82115198h case    8:*/		return 0x8211519C;
		  /* 8211519Ch */ case    9:  		/* cmpwi CR6, R3, 1 */
		/* 8211519Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8211519Ch case    9:*/		return 0x821151A0;
		  /* 821151A0h */ case   10:  		/* bc 12, CR6_EQ, 8 */
		/* 821151A0h case   10:*/		if ( regs.CR[6].eq ) { return 0x821151A8;  }
		/* 821151A0h case   10:*/		return 0x821151A4;
		  /* 821151A4h */ case   11:  		/* mr R23, R21 */
		/* 821151A4h case   11:*/		regs.R23 = regs.R21;
		/* 821151A4h case   11:*/		return 0x821151A8;
	}
	return 0x821151A8;
} // Block from 82115178h-821151A8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821151A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821151A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821151A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821151A8);
		  /* 821151A8h */ case    0:  		/* lwz R10, <#[R31 + 16]> */
		/* 821151A8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 821151A8h case    0:*/		return 0x821151AC;
		  /* 821151ACh */ case    1:  		/* lwz R11, <#[R26 + 20]> */
		/* 821151ACh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 821151ACh case    1:*/		return 0x821151B0;
		  /* 821151B0h */ case    2:  		/* lwz R9, <#[R10]> */
		/* 821151B0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821151B0h case    2:*/		return 0x821151B4;
		  /* 821151B4h */ case    3:  		/* rlwinm R8, R9, 2, 0, 29 */
		/* 821151B4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R9);
		/* 821151B4h case    3:*/		return 0x821151B8;
		  /* 821151B8h */ case    4:  		/* lwzx R8, <#[R8 + R11]> */
		/* 821151B8h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 821151B8h case    4:*/		return 0x821151BC;
		  /* 821151BCh */ case    5:  		/* lwz R8, <#[R8 + 48]> */
		/* 821151BCh case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000030) );
		/* 821151BCh case    5:*/		return 0x821151C0;
		  /* 821151C0h */ case    6:  		/* cmplw CR6, R8, R9 */
		/* 821151C0h case    6:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 821151C0h case    6:*/		return 0x821151C4;
		  /* 821151C4h */ case    7:  		/* bc 12, CR6_EQ, 856 */
		/* 821151C4h case    7:*/		if ( regs.CR[6].eq ) { return 0x8211551C;  }
		/* 821151C4h case    7:*/		return 0x821151C8;
		  /* 821151C8h */ case    8:  		/* rlwinm R10, R9, 0, 0, 31 */
		/* 821151C8h case    8:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R9);
		/* 821151C8h case    8:*/		return 0x821151CC;
		  /* 821151CCh */ case    9:  		/* lwz R9, <#[R26 + 16]> */
		/* 821151CCh case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000010) );
		/* 821151CCh case    9:*/		return 0x821151D0;
		  /* 821151D0h */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821151D0h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821151D0h case   10:*/		return 0x821151D4;
		  /* 821151D4h */ case   11:  		/* lwzx R10, <#[R10 + R11]> */
		/* 821151D4h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821151D4h case   11:*/		return 0x821151D8;
		  /* 821151D8h */ case   12:  		/* lwz R8, <#[R10 + 48]> */
		/* 821151D8h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000030) );
		/* 821151D8h case   12:*/		return 0x821151DC;
		  /* 821151DCh */ case   13:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 821151DCh case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 821151DCh case   13:*/		return 0x821151E0;
		  /* 821151E0h */ case   14:  		/* lwzx R11, <#[R8 + R11]> */
		/* 821151E0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 821151E0h case   14:*/		return 0x821151E4;
		  /* 821151E4h */ case   15:  		/* lwz R8, <#[R11 + 4]> */
		/* 821151E4h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821151E4h case   15:*/		return 0x821151E8;
		  /* 821151E8h */ case   16:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 821151E8h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 821151E8h case   16:*/		return 0x821151EC;
		  /* 821151ECh */ case   17:  		/* lwzx R9, <#[R8 + R9]> */
		/* 821151ECh case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 821151ECh case   17:*/		return 0x821151F0;
		  /* 821151F0h */ case   18:  		/* lwz R9, <#[R9 + 4]> */
		/* 821151F0h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 821151F0h case   18:*/		return 0x821151F4;
		  /* 821151F4h */ case   19:  		/* rlwinm. R9, R9, 0, 30, 30 */
		/* 821151F4h case   19:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R9);
		/* 821151F4h case   19:*/		return 0x821151F8;
		  /* 821151F8h */ case   20:  		/* bc 12, CR0_EQ, 52 */
		/* 821151F8h case   20:*/		if ( regs.CR[0].eq ) { return 0x8211522C;  }
		/* 821151F8h case   20:*/		return 0x821151FC;
		  /* 821151FCh */ case   21:  		/* lwz R9, <#[R11 + 96]> */
		/* 821151FCh case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000060) );
		/* 821151FCh case   21:*/		return 0x82115200;
		  /* 82115200h */ case   22:  		/* cmplwi CR6, R9, 0 */
		/* 82115200h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82115200h case   22:*/		return 0x82115204;
		  /* 82115204h */ case   23:  		/* bc 4, CR6_EQ, 40 */
		/* 82115204h case   23:*/		if ( !regs.CR[6].eq ) { return 0x8211522C;  }
		/* 82115204h case   23:*/		return 0x82115208;
		  /* 82115208h */ case   24:  		/* lwz R10, <#[R10 + 96]> */
		/* 82115208h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000060) );
		/* 82115208h case   24:*/		return 0x8211520C;
		  /* 8211520Ch */ case   25:  		/* stw R10, <#[R11 + 96]> */
		/* 8211520Ch case   25:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000060) );
		/* 8211520Ch case   25:*/		return 0x82115210;
		  /* 82115210h */ case   26:  		/* lwz R10, <#[R31 + 16]> */
		/* 82115210h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82115210h case   26:*/		return 0x82115214;
		  /* 82115214h */ case   27:  		/* lwz R9, <#[R26 + 20]> */
		/* 82115214h case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000014) );
		/* 82115214h case   27:*/		return 0x82115218;
		  /* 82115218h */ case   28:  		/* lwz R10, <#[R10]> */
		/* 82115218h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 82115218h case   28:*/		return 0x8211521C;
		  /* 8211521Ch */ case   29:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8211521Ch case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8211521Ch case   29:*/		return 0x82115220;
		  /* 82115220h */ case   30:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82115220h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82115220h case   30:*/		return 0x82115224;
		  /* 82115224h */ case   31:  		/* lwz R10, <#[R10 + 100]> */
		/* 82115224h case   31:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000064) );
		/* 82115224h case   31:*/		return 0x82115228;
		  /* 82115228h */ case   32:  		/* stw R10, <#[R11 + 100]> */
		/* 82115228h case   32:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000064) );
		/* 82115228h case   32:*/		return 0x8211522C;
	}
	return 0x8211522C;
} // Block from 821151A8h-8211522Ch (33 instructions)

//////////////////////////////////////////////////////
// Block at 8211522Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211522C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211522C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211522C);
		  /* 8211522Ch */ case    0:  		/* stw R22, <#[R31]> */
		/* 8211522Ch case    0:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000000) );
		/* 8211522Ch case    0:*/		return 0x82115230;
		  /* 82115230h */ case    1:  		/* stw R22, <#[R31 + 4]> */
		/* 82115230h case    1:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000004) );
		/* 82115230h case    1:*/		return 0x82115234;
		  /* 82115234h */ case    2:  		/* stw R22, <#[R31 + 12]> */
		/* 82115234h case    2:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x0000000C) );
		/* 82115234h case    2:*/		return 0x82115238;
		  /* 82115238h */ case    3:  		/* b 740 */
		/* 82115238h case    3:*/		return 0x8211551C;
		/* 82115238h case    3:*/		return 0x8211523C;
	}
	return 0x8211523C;
} // Block from 8211522Ch-8211523Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8211523Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211523C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211523C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211523C);
		  /* 8211523Ch */ case    0:  		/* lis R11, 20496 */
		/* 8211523Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x5010);
		/* 8211523Ch case    0:*/		return 0x82115240;
		  /* 82115240h */ case    1:  		/* ori R11, R11, 4 */
		/* 82115240h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82115240h case    1:*/		return 0x82115244;
		  /* 82115244h */ case    2:  		/* cmplw CR6, R9, R11 */
		/* 82115244h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82115244h case    2:*/		return 0x82115248;
		  /* 82115248h */ case    3:  		/* bc 4, CR6_EQ, 724 */
		/* 82115248h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8211551C;  }
		/* 82115248h case    3:*/		return 0x8211524C;
		  /* 8211524Ch */ case    4:  		/* lwz R10, <#[R31 + 8]> */
		/* 8211524Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8211524Ch case    4:*/		return 0x82115250;
		  /* 82115250h */ case    5:  		/* mr R5, R20 */
		/* 82115250h case    5:*/		regs.R5 = regs.R20;
		/* 82115250h case    5:*/		return 0x82115254;
		  /* 82115254h */ case    6:  		/* lwz R11, <#[R26 + 20]> */
		/* 82115254h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82115254h case    6:*/		return 0x82115258;
		  /* 82115258h */ case    7:  		/* mr R8, R20 */
		/* 82115258h case    7:*/		regs.R8 = regs.R20;
		/* 82115258h case    7:*/		return 0x8211525C;
		  /* 8211525Ch */ case    8:  		/* lwz R9, <#[R26 + 16]> */
		/* 8211525Ch case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000010) );
		/* 8211525Ch case    8:*/		return 0x82115260;
		  /* 82115260h */ case    9:  		/* stw R21, <#[R1 + 92]> */
		/* 82115260h case    9:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x0000005C) );
		/* 82115260h case    9:*/		return 0x82115264;
		  /* 82115264h */ case   10:  		/* stw R21, <#[R1 + 80]> */
		/* 82115264h case   10:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000050) );
		/* 82115264h case   10:*/		return 0x82115268;
		  /* 82115268h */ case   11:  		/* lwz R7, <#[R10]> */
		/* 82115268h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 82115268h case   11:*/		return 0x8211526C;
		  /* 8211526Ch */ case   12:  		/* lwz R6, <#[R10 + 4]> */
		/* 8211526Ch case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 8211526Ch case   12:*/		return 0x82115270;
		  /* 82115270h */ case   13:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82115270h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82115270h case   13:*/		return 0x82115274;
		  /* 82115274h */ case   14:  		/* lwz R10, <#[R10 + 12]> */
		/* 82115274h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 82115274h case   14:*/		return 0x82115278;
		  /* 82115278h */ case   15:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 82115278h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 82115278h case   15:*/		return 0x8211527C;
		  /* 8211527Ch */ case   16:  		/* rlwinm R4, R10, 2, 0, 29 */
		/* 8211527Ch case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R10);
		/* 8211527Ch case   16:*/		return 0x82115280;
		  /* 82115280h */ case   17:  		/* lwzx R10, <#[R7 + R11]> */
		/* 82115280h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 82115280h case   17:*/		return 0x82115284;
		  /* 82115284h */ case   18:  		/* lwzx R7, <#[R6 + R11]> */
		/* 82115284h case   18:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 82115284h case   18:*/		return 0x82115288;
		  /* 82115288h */ case   19:  		/* lwzx R6, <#[R4 + R11]> */
		/* 82115288h case   19:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R4 + regs.R11 + 0x00000000) );
		/* 82115288h case   19:*/		return 0x8211528C;
		  /* 8211528Ch */ case   20:  		/* lwz R4, <#[R10 + 4]> */
		/* 8211528Ch case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000004) );
		/* 8211528Ch case   20:*/		return 0x82115290;
		  /* 82115290h */ case   21:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 82115290h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 82115290h case   21:*/		return 0x82115294;
		  /* 82115294h */ case   22:  		/* lwzx R4, <#[R4 + R9]> */
		/* 82115294h case   22:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + regs.R9 + 0x00000000) );
		/* 82115294h case   22:*/		return 0x82115298;
		  /* 82115298h */ case   23:  		/* lwz R4, <#[R4 + 4]> */
		/* 82115298h case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000004) );
		/* 82115298h case   23:*/		return 0x8211529C;
		  /* 8211529Ch */ case   24:  		/* rlwinm. R4, R4, 0, 23, 23 */
		/* 8211529Ch case   24:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R4,regs.R4);
		/* 8211529Ch case   24:*/		return 0x821152A0;
		  /* 821152A0h */ case   25:  		/* bc 12, CR0_EQ, 172 */
		/* 821152A0h case   25:*/		if ( regs.CR[0].eq ) { return 0x8211534C;  }
		/* 821152A0h case   25:*/		return 0x821152A4;
		  /* 821152A4h */ case   26:  		/* lwz R4, <#[R10 + 8]> */
		/* 821152A4h case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000008) );
		/* 821152A4h case   26:*/		return 0x821152A8;
		  /* 821152A8h */ case   27:  		/* cmpwi CR6, R4, -1 */
		/* 821152A8h case   27:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 821152A8h case   27:*/		return 0x821152AC;
		  /* 821152ACh */ case   28:  		/* bc 4, CR6_EQ, 160 */
		/* 821152ACh case   28:*/		if ( !regs.CR[6].eq ) { return 0x8211534C;  }
		/* 821152ACh case   28:*/		return 0x821152B0;
		  /* 821152B0h */ case   29:  		/* lfd FR0, <#[R10 + 32]> */
		/* 821152B0h case   29:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 821152B0h case   29:*/		return 0x821152B4;
		  /* 821152B4h */ case   30:  		/* fcmpu CR6, FR0, FR31 */
		/* 821152B4h case   30:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 821152B4h case   30:*/		return 0x821152B8;
		  /* 821152B8h */ case   31:  		/* bc 4, CR6_GT, 136 */
		/* 821152B8h case   31:*/		if ( !regs.CR[6].gt ) { return 0x82115340;  }
		/* 821152B8h case   31:*/		return 0x821152BC;
		  /* 821152BCh */ case   32:  		/* lwz R8, <#[R7 + 4]> */
		/* 821152BCh case   32:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + 0x00000004) );
		/* 821152BCh case   32:*/		return 0x821152C0;
		  /* 821152C0h */ case   33:  		/* li R10, 2 */
		/* 821152C0h case   33:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 821152C0h case   33:*/		return 0x821152C4;
		  /* 821152C4h */ case   34:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 821152C4h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 821152C4h case   34:*/		return 0x821152C8;
		  /* 821152C8h */ case   35:  		/* stw R10, <#[R1 + 84]> */
		/* 821152C8h case   35:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 821152C8h case   35:*/		return 0x821152CC;
		  /* 821152CCh */ case   36:  		/* lwzx R8, <#[R8 + R9]> */
		/* 821152CCh case   36:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 821152CCh case   36:*/		return 0x821152D0;
		  /* 821152D0h */ case   37:  		/* lwz R8, <#[R8 + 4]> */
		/* 821152D0h case   37:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 821152D0h case   37:*/		return 0x821152D4;
		  /* 821152D4h */ case   38:  		/* rlwinm. R8, R8, 0, 23, 23 */
		/* 821152D4h case   38:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R8,regs.R8);
		/* 821152D4h case   38:*/		return 0x821152D8;
		  /* 821152D8h */ case   39:  		/* bc 12, CR0_EQ, 152 */
		/* 821152D8h case   39:*/		if ( regs.CR[0].eq ) { return 0x82115370;  }
		/* 821152D8h case   39:*/		return 0x821152DC;
		  /* 821152DCh */ case   40:  		/* lwz R8, <#[R7 + 8]> */
		/* 821152DCh case   40:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + 0x00000008) );
		/* 821152DCh case   40:*/		return 0x821152E0;
		  /* 821152E0h */ case   41:  		/* cmpwi CR6, R8, -1 */
		/* 821152E0h case   41:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 821152E0h case   41:*/		return 0x821152E4;
		  /* 821152E4h */ case   42:  		/* bc 4, CR6_EQ, 140 */
		/* 821152E4h case   42:*/		if ( !regs.CR[6].eq ) { return 0x82115370;  }
		/* 821152E4h case   42:*/		return 0x821152E8;
		  /* 821152E8h */ case   43:  		/* lfd FR0, <#[R7 + 32]> */
		/* 821152E8h case   43:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R7 + 0x00000020) );
		/* 821152E8h case   43:*/		return 0x821152EC;
		  /* 821152ECh */ case   44:  		/* fcmpu CR6, FR0, FR31 */
		/* 821152ECh case   44:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 821152ECh case   44:*/		return 0x821152F0;
		  /* 821152F0h */ case   45:  		/* bc 4, CR6_GT, 84 */
		/* 821152F0h case   45:*/		if ( !regs.CR[6].gt ) { return 0x82115344;  }
		/* 821152F0h case   45:*/		return 0x821152F4;
		  /* 821152F4h */ case   46:  		/* lwz R8, <#[R6 + 4]> */
		/* 821152F4h case   46:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + 0x00000004) );
		/* 821152F4h case   46:*/		return 0x821152F8;
		  /* 821152F8h */ case   47:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 821152F8h case   47:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 821152F8h case   47:*/		return 0x821152FC;
		  /* 821152FCh */ case   48:  		/* lwzx R9, <#[R8 + R9]> */
		/* 821152FCh case   48:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 821152FCh case   48:*/		return 0x82115300;
		  /* 82115300h */ case   49:  		/* lwz R9, <#[R9 + 4]> */
		/* 82115300h case   49:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 82115300h case   49:*/		return 0x82115304;
		  /* 82115304h */ case   50:  		/* rlwinm. R9, R9, 0, 23, 23 */
		/* 82115304h case   50:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R9,regs.R9);
		/* 82115304h case   50:*/		return 0x82115308;
		  /* 82115308h */ case   51:  		/* bc 12, CR0_EQ, 104 */
		/* 82115308h case   51:*/		if ( regs.CR[0].eq ) { return 0x82115370;  }
		/* 82115308h case   51:*/		return 0x8211530C;
		  /* 8211530Ch */ case   52:  		/* lwz R9, <#[R6 + 8]> */
		/* 8211530Ch case   52:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000008) );
		/* 8211530Ch case   52:*/		return 0x82115310;
		  /* 82115310h */ case   53:  		/* cmpwi CR6, R9, -1 */
		/* 82115310h case   53:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 82115310h case   53:*/		return 0x82115314;
		  /* 82115314h */ case   54:  		/* bc 4, CR6_EQ, 92 */
		/* 82115314h case   54:*/		if ( !regs.CR[6].eq ) { return 0x82115370;  }
		/* 82115314h case   54:*/		return 0x82115318;
		  /* 82115318h */ case   55:  		/* lfd FR0, <#[R6 + 32]> */
		/* 82115318h case   55:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R6 + 0x00000020) );
		/* 82115318h case   55:*/		return 0x8211531C;
		  /* 8211531Ch */ case   56:  		/* fcmpu CR6, FR0, FR31 */
		/* 8211531Ch case   56:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 8211531Ch case   56:*/		return 0x82115320;
		  /* 82115320h */ case   57:  		/* bc 4, CR6_EQ, 12 */
		/* 82115320h case   57:*/		if ( !regs.CR[6].eq ) { return 0x8211532C;  }
		/* 82115320h case   57:*/		return 0x82115324;
		  /* 82115324h */ case   58:  		/* stw R21, <#[R1 + 88]> */
		/* 82115324h case   58:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000058) );
		/* 82115324h case   58:*/		return 0x82115328;
		  /* 82115328h */ case   59:  		/* b 124 */
		/* 82115328h case   59:*/		return 0x821153A4;
		/* 82115328h case   59:*/		return 0x8211532C;
	}
	return 0x8211532C;
} // Block from 8211523Ch-8211532Ch (60 instructions)

//////////////////////////////////////////////////////
// Block at 8211532Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211532C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211532C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211532C);
		  /* 8211532Ch */ case    0:  		/* fcmpu CR6, FR0, FR30 */
		/* 8211532Ch case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 8211532Ch case    0:*/		return 0x82115330;
		  /* 82115330h */ case    1:  		/* bc 4, CR6_EQ, 64 */
		/* 82115330h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82115370;  }
		/* 82115330h case    1:*/		return 0x82115334;
		  /* 82115334h */ case    2:  		/* li R11, 3 */
		/* 82115334h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 82115334h case    2:*/		return 0x82115338;
		  /* 82115338h */ case    3:  		/* stw R11, <#[R1 + 88]> */
		/* 82115338h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82115338h case    3:*/		return 0x8211533C;
		  /* 8211533Ch */ case    4:  		/* b 104 */
		/* 8211533Ch case    4:*/		return 0x821153A4;
		/* 8211533Ch case    4:*/		return 0x82115340;
	}
	return 0x82115340;
} // Block from 8211532Ch-82115340h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82115340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82115340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82115340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82115340);
		  /* 82115340h */ case    0:  		/* stw R22, <#[R1 + 84]> */
		/* 82115340h case    0:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000054) );
		/* 82115340h case    0:*/		return 0x82115344;
	}
	return 0x82115344;
} // Block from 82115340h-82115344h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82115344h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82115344( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82115344) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82115344);
		  /* 82115344h */ case    0:  		/* stw R22, <#[R1 + 88]> */
		/* 82115344h case    0:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000058) );
		/* 82115344h case    0:*/		return 0x82115348;
		  /* 82115348h */ case    1:  		/* b 92 */
		/* 82115348h case    1:*/		return 0x821153A4;
		/* 82115348h case    1:*/		return 0x8211534C;
	}
	return 0x8211534C;
} // Block from 82115344h-8211534Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8211534Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211534C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211534C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211534C);
		  /* 8211534Ch */ case    0:  		/* lwz R10, <#[R31 + 16]> */
		/* 8211534Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 8211534Ch case    0:*/		return 0x82115350;
		  /* 82115350h */ case    1:  		/* lwz R10, <#[R10 + 4]> */
		/* 82115350h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82115350h case    1:*/		return 0x82115354;
		  /* 82115354h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82115354h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82115354h case    2:*/		return 0x82115358;
		  /* 82115358h */ case    3:  		/* lwzx R10, <#[R10 + R11]> */
		/* 82115358h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82115358h case    3:*/		return 0x8211535C;
		  /* 8211535Ch */ case    4:  		/* lwz R10, <#[R10 + 92]> */
		/* 8211535Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000005C) );
		/* 8211535Ch case    4:*/		return 0x82115360;
		  /* 82115360h */ case    5:  		/* subfic R10, R10, 0 */
		/* 82115360h case    5:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0x0);
		/* 82115360h case    5:*/		return 0x82115364;
		  /* 82115364h */ case    6:  		/* subfe R10, R10, R10 */
		/* 82115364h case    6:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82115364h case    6:*/		return 0x82115368;
		  /* 82115368h */ case    7:  		/* and R10, R10, R8 */
		/* 82115368h case    7:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 82115368h case    7:*/		return 0x8211536C;
		  /* 8211536Ch */ case    8:  		/* stw R10, <#[R1 + 84]> */
		/* 8211536Ch case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 8211536Ch case    8:*/		return 0x82115370;
	}
	return 0x82115370;
} // Block from 8211534Ch-82115370h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82115370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82115370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82115370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82115370);
		  /* 82115370h */ case    0:  		/* lwz R9, <#[R31 + 16]> */
		/* 82115370h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 82115370h case    0:*/		return 0x82115374;
		  /* 82115374h */ case    1:  		/* cmpwi CR6, R10, -1 */
		/* 82115374h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82115374h case    1:*/		return 0x82115378;
		  /* 82115378h */ case    2:  		/* lwz R10, <#[R9 + 8]> */
		/* 82115378h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000008) );
		/* 82115378h case    2:*/		return 0x8211537C;
		  /* 8211537Ch */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8211537Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8211537Ch case    3:*/		return 0x82115380;
		  /* 82115380h */ case    4:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82115380h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82115380h case    4:*/		return 0x82115384;
		  /* 82115384h */ case    5:  		/* lwz R11, <#[R11 + 92]> */
		/* 82115384h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000005C) );
		/* 82115384h case    5:*/		return 0x82115388;
		  /* 82115388h */ case    6:  		/* subfic R11, R11, 0 */
		/* 82115388h case    6:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 82115388h case    6:*/		return 0x8211538C;
		  /* 8211538Ch */ case    7:  		/* subfe R11, R11, R11 */
		/* 8211538Ch case    7:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8211538Ch case    7:*/		return 0x82115390;
		  /* 82115390h */ case    8:  		/* and R11, R11, R5 */
		/* 82115390h case    8:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 82115390h case    8:*/		return 0x82115394;
		  /* 82115394h */ case    9:  		/* stw R11, <#[R1 + 88]> */
		/* 82115394h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82115394h case    9:*/		return 0x82115398;
		  /* 82115398h */ case   10:  		/* bc 12, CR6_EQ, 388 */
		/* 82115398h case   10:*/		if ( regs.CR[6].eq ) { return 0x8211551C;  }
		/* 82115398h case   10:*/		return 0x8211539C;
		  /* 8211539Ch */ case   11:  		/* cmpwi CR6, R11, -1 */
		/* 8211539Ch case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8211539Ch case   11:*/		return 0x821153A0;
		  /* 821153A0h */ case   12:  		/* bc 12, CR6_EQ, 380 */
		/* 821153A0h case   12:*/		if ( regs.CR[6].eq ) { return 0x8211551C;  }
		/* 821153A0h case   12:*/		return 0x821153A4;
	}
	return 0x821153A4;
} // Block from 82115370h-821153A4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821153A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821153A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821153A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821153A4);
		  /* 821153A4h */ case    0:  		/* mr R30, R22 */
		/* 821153A4h case    0:*/		regs.R30 = regs.R22;
		/* 821153A4h case    0:*/		return 0x821153A8;
		  /* 821153A8h */ case    1:  		/* addi R11, R1, 80 */
		/* 821153A8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 821153A8h case    1:*/		return 0x821153AC;
		  /* 821153ACh */ case    2:  		/* lwzx R11, <#[R30 + R11]> */
		/* 821153ACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 821153ACh case    2:*/		return 0x821153B0;
		  /* 821153B0h */ case    3:  		/* cmplwi CR6, R11, 1 */
		/* 821153B0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821153B0h case    3:*/		return 0x821153B4;
		  /* 821153B4h */ case    4:  		/* bc 12, CR6_LT, 148 */
		/* 821153B4h case    4:*/		if ( regs.CR[6].lt ) { return 0x82115448;  }
		/* 821153B4h case    4:*/		return 0x821153B8;
		  /* 821153B8h */ case    5:  		/* bc 12, CR6_EQ, 64 */
		/* 821153B8h case    5:*/		if ( regs.CR[6].eq ) { return 0x821153F8;  }
		/* 821153B8h case    5:*/		return 0x821153BC;
		  /* 821153BCh */ case    6:  		/* cmplwi CR6, R11, 3 */
		/* 821153BCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 821153BCh case    6:*/		return 0x821153C0;
		  /* 821153C0h */ case    7:  		/* bc 12, CR6_LT, 20 */
		/* 821153C0h case    7:*/		if ( regs.CR[6].lt ) { return 0x821153D4;  }
		/* 821153C0h case    7:*/		return 0x821153C4;
		  /* 821153C4h */ case    8:  		/* bc 4, CR6_EQ, 208 */
		/* 821153C4h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82115494;  }
		/* 821153C4h case    8:*/		return 0x821153C8;
		  /* 821153C8h */ case    9:  		/* lwz R10, <#[R31 + 8]> */
		/* 821153C8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821153C8h case    9:*/		return 0x821153CC;
		  /* 821153CCh */ case   10:  		/* lwz R10, <#[R10 + 4]> */
		/* 821153CCh case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 821153CCh case   10:*/		return 0x821153D0;
		  /* 821153D0h */ case   11:  		/* b 12 */
		/* 821153D0h case   11:*/		return 0x821153DC;
		/* 821153D0h case   11:*/		return 0x821153D4;
	}
	return 0x821153D4;
} // Block from 821153A4h-821153D4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821153D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821153D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821153D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821153D4);
		  /* 821153D4h */ case    0:  		/* lwz R10, <#[R31 + 8]> */
		/* 821153D4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821153D4h case    0:*/		return 0x821153D8;
		  /* 821153D8h */ case    1:  		/* lwz R10, <#[R10]> */
		/* 821153D8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821153D8h case    1:*/		return 0x821153DC;
	}
	return 0x821153DC;
} // Block from 821153D4h-821153DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821153DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821153DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821153DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821153DC);
		  /* 821153DCh */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 821153DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821153DCh case    0:*/		return 0x821153E0;
		  /* 821153E0h */ case    1:  		/* lwz R9, <#[R26 + 20]> */
		/* 821153E0h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000014) );
		/* 821153E0h case    1:*/		return 0x821153E4;
		  /* 821153E4h */ case    2:  		/* lwzx R11, <#[R11 + R30]> */
		/* 821153E4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 821153E4h case    2:*/		return 0x821153E8;
		  /* 821153E8h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821153E8h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821153E8h case    3:*/		return 0x821153EC;
		  /* 821153ECh */ case    4:  		/* lwzx R11, <#[R11 + R9]> */
		/* 821153ECh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 821153ECh case    4:*/		return 0x821153F0;
		  /* 821153F0h */ case    5:  		/* stw R10, <#[R11 + 48]> */
		/* 821153F0h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 821153F0h case    5:*/		return 0x821153F4;
		  /* 821153F4h */ case    6:  		/* b 160 */
		/* 821153F4h case    6:*/		return 0x82115494;
		/* 821153F4h case    6:*/		return 0x821153F8;
	}
	return 0x821153F8;
} // Block from 821153DCh-821153F8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821153F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821153F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821153F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821153F8);
		  /* 821153F8h */ case    0:  		/* cmpwi CR6, R14, -1 */
		/* 821153F8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0xFFFFFFFF);
		/* 821153F8h case    0:*/		return 0x821153FC;
		  /* 821153FCh */ case    1:  		/* bc 4, CR6_EQ, 48 */
		/* 821153FCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8211542C;  }
		/* 821153FCh case    1:*/		return 0x82115400;
		  /* 82115400h */ case    2:  		/* li R6, 0 */
		/* 82115400h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82115400h case    2:*/		return 0x82115404;
		  /* 82115404h */ case    3:  		/* lwz R4, <#[R26 + 120]> */
		/* 82115404h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000078) );
		/* 82115404h case    3:*/		return 0x82115408;
		  /* 82115408h */ case    4:  		/* li R5, 0 */
		/* 82115408h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82115408h case    4:*/		return 0x8211540C;
		  /* 8211540Ch */ case    5:  		/* fmr FR1, FR30 */
		/* 8211540Ch case    5:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 8211540Ch case    5:*/		return 0x82115410;
		  /* 82115410h */ case    6:  		/* mr R3, R26 */
		/* 82115410h case    6:*/		regs.R3 = regs.R26;
		/* 82115410h case    6:*/		return 0x82115414;
		  /* 82115414h */ case    7:  		/* bl -98796 */
		/* 82115414h case    7:*/		regs.LR = 0x82115418; return 0x820FD228;
		/* 82115414h case    7:*/		return 0x82115418;
		  /* 82115418h */ case    8:  		/* lwz R11, <#[R26 + 20]> */
		/* 82115418h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82115418h case    8:*/		return 0x8211541C;
		  /* 8211541Ch */ case    9:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 8211541Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 8211541Ch case    9:*/		return 0x82115420;
		  /* 82115420h */ case   10:  		/* mr R14, R3 */
		/* 82115420h case   10:*/		regs.R14 = regs.R3;
		/* 82115420h case   10:*/		return 0x82115424;
		  /* 82115424h */ case   11:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82115424h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82115424h case   11:*/		return 0x82115428;
		  /* 82115428h */ case   12:  		/* stw R3, <#[R11 + 48]> */
		/* 82115428h case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000030) );
		/* 82115428h case   12:*/		return 0x8211542C;
	}
	return 0x8211542C;
} // Block from 821153F8h-8211542Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8211542Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211542C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211542C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211542C);
		  /* 8211542Ch */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 8211542Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8211542Ch case    0:*/		return 0x82115430;
		  /* 82115430h */ case    1:  		/* lwz R10, <#[R26 + 20]> */
		/* 82115430h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 82115430h case    1:*/		return 0x82115434;
		  /* 82115434h */ case    2:  		/* lwzx R11, <#[R11 + R30]> */
		/* 82115434h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82115434h case    2:*/		return 0x82115438;
		  /* 82115438h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82115438h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82115438h case    3:*/		return 0x8211543C;
		  /* 8211543Ch */ case    4:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8211543Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8211543Ch case    4:*/		return 0x82115440;
		  /* 82115440h */ case    5:  		/* stw R14, <#[R11 + 48]> */
		/* 82115440h case    5:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R11 + 0x00000030) );
		/* 82115440h case    5:*/		return 0x82115444;
		  /* 82115444h */ case    6:  		/* b 80 */
		/* 82115444h case    6:*/		return 0x82115494;
		/* 82115444h case    6:*/		return 0x82115448;
	}
	return 0x82115448;
} // Block from 8211542Ch-82115448h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82115448h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82115448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82115448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82115448);
		  /* 82115448h */ case    0:  		/* cmpwi CR6, R19, -1 */
		/* 82115448h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R19,0xFFFFFFFF);
		/* 82115448h case    0:*/		return 0x8211544C;
		  /* 8211544Ch */ case    1:  		/* bc 4, CR6_EQ, 48 */
		/* 8211544Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8211547C;  }
		/* 8211544Ch case    1:*/		return 0x82115450;
		  /* 82115450h */ case    2:  		/* li R6, 0 */
		/* 82115450h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82115450h case    2:*/		return 0x82115454;
		  /* 82115454h */ case    3:  		/* lwz R4, <#[R26 + 120]> */
		/* 82115454h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000078) );
		/* 82115454h case    3:*/		return 0x82115458;
		  /* 82115458h */ case    4:  		/* li R5, 0 */
		/* 82115458h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82115458h case    4:*/		return 0x8211545C;
		  /* 8211545Ch */ case    5:  		/* fmr FR1, FR31 */
		/* 8211545Ch case    5:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8211545Ch case    5:*/		return 0x82115460;
		  /* 82115460h */ case    6:  		/* mr R3, R26 */
		/* 82115460h case    6:*/		regs.R3 = regs.R26;
		/* 82115460h case    6:*/		return 0x82115464;
		  /* 82115464h */ case    7:  		/* bl -98876 */
		/* 82115464h case    7:*/		regs.LR = 0x82115468; return 0x820FD228;
		/* 82115464h case    7:*/		return 0x82115468;
		  /* 82115468h */ case    8:  		/* lwz R11, <#[R26 + 20]> */
		/* 82115468h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82115468h case    8:*/		return 0x8211546C;
		  /* 8211546Ch */ case    9:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 8211546Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 8211546Ch case    9:*/		return 0x82115470;
		  /* 82115470h */ case   10:  		/* mr R19, R3 */
		/* 82115470h case   10:*/		regs.R19 = regs.R3;
		/* 82115470h case   10:*/		return 0x82115474;
		  /* 82115474h */ case   11:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82115474h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82115474h case   11:*/		return 0x82115478;
		  /* 82115478h */ case   12:  		/* stw R3, <#[R11 + 48]> */
		/* 82115478h case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000030) );
		/* 82115478h case   12:*/		return 0x8211547C;
	}
	return 0x8211547C;
} // Block from 82115448h-8211547Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8211547Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211547C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211547C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211547C);
		  /* 8211547Ch */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 8211547Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8211547Ch case    0:*/		return 0x82115480;
		  /* 82115480h */ case    1:  		/* lwz R10, <#[R26 + 20]> */
		/* 82115480h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 82115480h case    1:*/		return 0x82115484;
		  /* 82115484h */ case    2:  		/* lwzx R11, <#[R11 + R30]> */
		/* 82115484h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82115484h case    2:*/		return 0x82115488;
		  /* 82115488h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82115488h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82115488h case    3:*/		return 0x8211548C;
		  /* 8211548Ch */ case    4:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8211548Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8211548Ch case    4:*/		return 0x82115490;
		  /* 82115490h */ case    5:  		/* stw R19, <#[R11 + 48]> */
		/* 82115490h case    5:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000030) );
		/* 82115490h case    5:*/		return 0x82115494;
	}
	return 0x82115494;
} // Block from 8211547Ch-82115494h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82115494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82115494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82115494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82115494);
		  /* 82115494h */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 82115494h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82115494h case    0:*/		return 0x82115498;
		  /* 82115498h */ case    1:  		/* lwz R9, <#[R26 + 20]> */
		/* 82115498h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000014) );
		/* 82115498h case    1:*/		return 0x8211549C;
		  /* 8211549Ch */ case    2:  		/* lwz R8, <#[R26 + 16]> */
		/* 8211549Ch case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000010) );
		/* 8211549Ch case    2:*/		return 0x821154A0;
		  /* 821154A0h */ case    3:  		/* lwzx R11, <#[R11 + R30]> */
		/* 821154A0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 821154A0h case    3:*/		return 0x821154A4;
		  /* 821154A4h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821154A4h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821154A4h case    4:*/		return 0x821154A8;
		  /* 821154A8h */ case    5:  		/* lwzx R10, <#[R11 + R9]> */
		/* 821154A8h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 821154A8h case    5:*/		return 0x821154AC;
		  /* 821154ACh */ case    6:  		/* lwz R11, <#[R10 + 48]> */
		/* 821154ACh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000030) );
		/* 821154ACh case    6:*/		return 0x821154B0;
		  /* 821154B0h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821154B0h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821154B0h case    7:*/		return 0x821154B4;
		  /* 821154B4h */ case    8:  		/* lwzx R11, <#[R11 + R9]> */
		/* 821154B4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 821154B4h case    8:*/		return 0x821154B8;
		  /* 821154B8h */ case    9:  		/* lwz R9, <#[R11 + 4]> */
		/* 821154B8h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 821154B8h case    9:*/		return 0x821154BC;
		  /* 821154BCh */ case   10:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821154BCh case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821154BCh case   10:*/		return 0x821154C0;
		  /* 821154C0h */ case   11:  		/* lwzx R9, <#[R9 + R8]> */
		/* 821154C0h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 821154C0h case   11:*/		return 0x821154C4;
		  /* 821154C4h */ case   12:  		/* lwz R9, <#[R9 + 4]> */
		/* 821154C4h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 821154C4h case   12:*/		return 0x821154C8;
		  /* 821154C8h */ case   13:  		/* rlwinm. R9, R9, 0, 30, 30 */
		/* 821154C8h case   13:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R9);
		/* 821154C8h case   13:*/		return 0x821154CC;
		  /* 821154CCh */ case   14:  		/* bc 12, CR0_EQ, 52 */
		/* 821154CCh case   14:*/		if ( regs.CR[0].eq ) { return 0x82115500;  }
		/* 821154CCh case   14:*/		return 0x821154D0;
		  /* 821154D0h */ case   15:  		/* lwz R9, <#[R11 + 96]> */
		/* 821154D0h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000060) );
		/* 821154D0h case   15:*/		return 0x821154D4;
		  /* 821154D4h */ case   16:  		/* cmplwi CR6, R9, 0 */
		/* 821154D4h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821154D4h case   16:*/		return 0x821154D8;
		  /* 821154D8h */ case   17:  		/* bc 4, CR6_EQ, 40 */
		/* 821154D8h case   17:*/		if ( !regs.CR[6].eq ) { return 0x82115500;  }
		/* 821154D8h case   17:*/		return 0x821154DC;
		  /* 821154DCh */ case   18:  		/* lwz R10, <#[R10 + 96]> */
		/* 821154DCh case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000060) );
		/* 821154DCh case   18:*/		return 0x821154E0;
		  /* 821154E0h */ case   19:  		/* stw R10, <#[R11 + 96]> */
		/* 821154E0h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000060) );
		/* 821154E0h case   19:*/		return 0x821154E4;
		  /* 821154E4h */ case   20:  		/* lwz R10, <#[R31 + 16]> */
		/* 821154E4h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 821154E4h case   20:*/		return 0x821154E8;
		  /* 821154E8h */ case   21:  		/* lwz R9, <#[R26 + 20]> */
		/* 821154E8h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000014) );
		/* 821154E8h case   21:*/		return 0x821154EC;
		  /* 821154ECh */ case   22:  		/* lwzx R10, <#[R10 + R30]> */
		/* 821154ECh case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 821154ECh case   22:*/		return 0x821154F0;
		  /* 821154F0h */ case   23:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821154F0h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821154F0h case   23:*/		return 0x821154F4;
		  /* 821154F4h */ case   24:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821154F4h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821154F4h case   24:*/		return 0x821154F8;
		  /* 821154F8h */ case   25:  		/* lwz R10, <#[R10 + 100]> */
		/* 821154F8h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000064) );
		/* 821154F8h case   25:*/		return 0x821154FC;
		  /* 821154FCh */ case   26:  		/* stw R10, <#[R11 + 100]> */
		/* 821154FCh case   26:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000064) );
		/* 821154FCh case   26:*/		return 0x82115500;
	}
	return 0x82115500;
} // Block from 82115494h-82115500h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82115500h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82115500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82115500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82115500);
		  /* 82115500h */ case    0:  		/* addi R30, R30, 4 */
		/* 82115500h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82115500h case    0:*/		return 0x82115504;
		  /* 82115504h */ case    1:  		/* cmplwi CR6, R30, 16 */
		/* 82115504h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000010);
		/* 82115504h case    1:*/		return 0x82115508;
		  /* 82115508h */ case    2:  		/* bc 12, CR6_LT, -352 */
		/* 82115508h case    2:*/		if ( regs.CR[6].lt ) { return 0x821153A8;  }
		/* 82115508h case    2:*/		return 0x8211550C;
	}
	return 0x8211550C;
} // Block from 82115500h-8211550Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8211550Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211550C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211550C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211550C);
		  /* 8211550Ch */ case    0:  		/* stw R22, <#[R31 + 12]> */
		/* 8211550Ch case    0:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x0000000C) );
		/* 8211550Ch case    0:*/		return 0x82115510;
		  /* 82115510h */ case    1:  		/* stw R22, <#[R31 + 4]> */
		/* 82115510h case    1:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000004) );
		/* 82115510h case    1:*/		return 0x82115514;
		  /* 82115514h */ case    2:  		/* stw R22, <#[R31]> */
		/* 82115514h case    2:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000000) );
		/* 82115514h case    2:*/		return 0x82115518;
	}
	return 0x82115518;
} // Block from 8211550Ch-82115518h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82115518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82115518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82115518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82115518);
		  /* 82115518h */ case    0:  		/* mr R23, R21 */
		/* 82115518h case    0:*/		regs.R23 = regs.R21;
		/* 82115518h case    0:*/		return 0x8211551C;
	}
	return 0x8211551C;
} // Block from 82115518h-8211551Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8211551Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211551C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211551C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211551C);
		  /* 8211551Ch */ case    0:  		/* lwz R5, <#[R31 + 12]> */
		/* 8211551Ch case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 8211551Ch case    0:*/		return 0x82115520;
		  /* 82115520h */ case    1:  		/* cmplwi CR6, R5, 0 */
		/* 82115520h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82115520h case    1:*/		return 0x82115524;
		  /* 82115524h */ case    2:  		/* bc 12, CR6_EQ, 256 */
		/* 82115524h case    2:*/		if ( regs.CR[6].eq ) { return 0x82115624;  }
		/* 82115524h case    2:*/		return 0x82115528;
		  /* 82115528h */ case    3:  		/* lwz R8, <#[R31 + 16]> */
		/* 82115528h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000010) );
		/* 82115528h case    3:*/		return 0x8211552C;
		  /* 8211552Ch */ case    4:  		/* mr R6, R22 */
		/* 8211552Ch case    4:*/		regs.R6 = regs.R22;
		/* 8211552Ch case    4:*/		return 0x82115530;
		  /* 82115530h */ case    5:  		/* lwz R7, <#[R26 + 20]> */
		/* 82115530h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R26 + 0x00000014) );
		/* 82115530h case    5:*/		return 0x82115534;
		  /* 82115534h */ case    6:  		/* mr R11, R22 */
		/* 82115534h case    6:*/		regs.R11 = regs.R22;
		/* 82115534h case    6:*/		return 0x82115538;
		  /* 82115538h */ case    7:  		/* lwzx R10, <#[R8 + R11]> */
		/* 82115538h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82115538h case    7:*/		return 0x8211553C;
		  /* 8211553Ch */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8211553Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8211553Ch case    8:*/		return 0x82115540;
		  /* 82115540h */ case    9:  		/* lwzx R10, <#[R10 + R7]> */
		/* 82115540h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 82115540h case    9:*/		return 0x82115544;
		  /* 82115544h */ case   10:  		/* lwz R9, <#[R10]> */
		/* 82115544h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82115544h case   10:*/		return 0x82115548;
		  /* 82115548h */ case   11:  		/* rlwinm. R4, R9, 0, 25, 25 */
		/* 82115548h case   11:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R4,regs.R9);
		/* 82115548h case   11:*/		return 0x8211554C;
		  /* 8211554Ch */ case   12:  		/* bc 4, CR0_EQ, 76 */
		/* 8211554Ch case   12:*/		if ( !regs.CR[0].eq ) { return 0x82115598;  }
		/* 8211554Ch case   12:*/		return 0x82115550;
		  /* 82115550h */ case   13:  		/* lwz R10, <#[R10 + 4]> */
		/* 82115550h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82115550h case   13:*/		return 0x82115554;
		  /* 82115554h */ case   14:  		/* lis R12, 1 */
		/* 82115554h case   14:*/		cpu::op::lis<0>(regs,&regs.R12,0x1);
		/* 82115554h case   14:*/		return 0x82115558;
		  /* 82115558h */ case   15:  		/* lwz R4, <#[R26 + 16]> */
		/* 82115558h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000010) );
		/* 82115558h case   15:*/		return 0x8211555C;
		  /* 8211555Ch */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8211555Ch case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8211555Ch case   16:*/		return 0x82115560;
		  /* 82115560h */ case   17:  		/* ori R12, R12, 4136 */
		/* 82115560h case   17:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0x1028);
		/* 82115560h case   17:*/		return 0x82115564;
		  /* 82115564h */ case   18:  		/* lwzx R10, <#[R10 + R4]> */
		/* 82115564h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 82115564h case   18:*/		return 0x82115568;
		  /* 82115568h */ case   19:  		/* lwz R10, <#[R10 + 4]> */
		/* 82115568h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82115568h case   19:*/		return 0x8211556C;
		  /* 8211556Ch */ case   20:  		/* and. R10, R10, R12 */
		/* 8211556Ch case   20:*/		cpu::op::and<1>(regs,&regs.R10,regs.R10,regs.R12);
		/* 8211556Ch case   20:*/		return 0x82115570;
		  /* 82115570h */ case   21:  		/* bc 4, CR0_EQ, 40 */
		/* 82115570h case   21:*/		if ( !regs.CR[0].eq ) { return 0x82115598;  }
		/* 82115570h case   21:*/		return 0x82115574;
		  /* 82115574h */ case   22:  		/* rlwinm. R10, R9, 0, 29, 29 */
		/* 82115574h case   22:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R9);
		/* 82115574h case   22:*/		return 0x82115578;
		  /* 82115578h */ case   23:  		/* bc 12, CR0_EQ, 32 */
		/* 82115578h case   23:*/		if ( regs.CR[0].eq ) { return 0x82115598;  }
		/* 82115578h case   23:*/		return 0x8211557C;
		  /* 8211557Ch */ case   24:  		/* rlwinm. R10, R9, 0, 28, 28 */
		/* 8211557Ch case   24:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R9);
		/* 8211557Ch case   24:*/		return 0x82115580;
		  /* 82115580h */ case   25:  		/* bc 12, CR0_EQ, 24 */
		/* 82115580h case   25:*/		if ( regs.CR[0].eq ) { return 0x82115598;  }
		/* 82115580h case   25:*/		return 0x82115584;
		  /* 82115584h */ case   26:  		/* lwz R10, <#[R31 + 12]> */
		/* 82115584h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 82115584h case   26:*/		return 0x82115588;
		  /* 82115588h */ case   27:  		/* addi R6, R6, 1 */
		/* 82115588h case   27:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82115588h case   27:*/		return 0x8211558C;
		  /* 8211558Ch */ case   28:  		/* addi R11, R11, 4 */
		/* 8211558Ch case   28:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8211558Ch case   28:*/		return 0x82115590;
		  /* 82115590h */ case   29:  		/* cmplw CR6, R6, R10 */
		/* 82115590h case   29:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 82115590h case   29:*/		return 0x82115594;
		  /* 82115594h */ case   30:  		/* bc 12, CR6_LT, -92 */
		/* 82115594h case   30:*/		if ( regs.CR[6].lt ) { return 0x82115538;  }
		/* 82115594h case   30:*/		return 0x82115598;
	}
	return 0x82115598;
} // Block from 8211551Ch-82115598h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82115598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82115598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82115598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82115598);
		  /* 82115598h */ case    0:  		/* cmplw CR6, R6, R5 */
		/* 82115598h case    0:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R5);
		/* 82115598h case    0:*/		return 0x8211559C;
		  /* 8211559Ch */ case    1:  		/* bc 4, CR6_EQ, 136 */
		/* 8211559Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82115624;  }
		/* 8211559Ch case    1:*/		return 0x821155A0;
		  /* 821155A0h */ case    2:  		/* cmpwi CR6, R19, -1 */
		/* 821155A0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R19,0xFFFFFFFF);
		/* 821155A0h case    2:*/		return 0x821155A4;
		  /* 821155A4h */ case    3:  		/* bc 4, CR6_EQ, 48 */
		/* 821155A4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821155D4;  }
		/* 821155A4h case    3:*/		return 0x821155A8;
		  /* 821155A8h */ case    4:  		/* li R6, 0 */
		/* 821155A8h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821155A8h case    4:*/		return 0x821155AC;
		  /* 821155ACh */ case    5:  		/* lwz R4, <#[R26 + 120]> */
		/* 821155ACh case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000078) );
		/* 821155ACh case    5:*/		return 0x821155B0;
		  /* 821155B0h */ case    6:  		/* li R5, 0 */
		/* 821155B0h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821155B0h case    6:*/		return 0x821155B4;
		  /* 821155B4h */ case    7:  		/* fmr FR1, FR31 */
		/* 821155B4h case    7:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 821155B4h case    7:*/		return 0x821155B8;
		  /* 821155B8h */ case    8:  		/* mr R3, R26 */
		/* 821155B8h case    8:*/		regs.R3 = regs.R26;
		/* 821155B8h case    8:*/		return 0x821155BC;
		  /* 821155BCh */ case    9:  		/* bl -99220 */
		/* 821155BCh case    9:*/		regs.LR = 0x821155C0; return 0x820FD228;
		/* 821155BCh case    9:*/		return 0x821155C0;
		  /* 821155C0h */ case   10:  		/* lwz R11, <#[R26 + 20]> */
		/* 821155C0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 821155C0h case   10:*/		return 0x821155C4;
		  /* 821155C4h */ case   11:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 821155C4h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 821155C4h case   11:*/		return 0x821155C8;
		  /* 821155C8h */ case   12:  		/* mr R19, R3 */
		/* 821155C8h case   12:*/		regs.R19 = regs.R3;
		/* 821155C8h case   12:*/		return 0x821155CC;
		  /* 821155CCh */ case   13:  		/* lwzx R11, <#[R10 + R11]> */
		/* 821155CCh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821155CCh case   13:*/		return 0x821155D0;
		  /* 821155D0h */ case   14:  		/* stw R3, <#[R11 + 48]> */
		/* 821155D0h case   14:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000030) );
		/* 821155D0h case   14:*/		return 0x821155D4;
	}
	return 0x821155D4;
} // Block from 82115598h-821155D4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821155D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821155D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821155D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821155D4);
		  /* 821155D4h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 821155D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821155D4h case    0:*/		return 0x821155D8;
		  /* 821155D8h */ case    1:  		/* mr R10, R22 */
		/* 821155D8h case    1:*/		regs.R10 = regs.R22;
		/* 821155D8h case    1:*/		return 0x821155DC;
		  /* 821155DCh */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821155DCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821155DCh case    2:*/		return 0x821155E0;
		  /* 821155E0h */ case    3:  		/* bc 4, CR6_GT, 52 */
		/* 821155E0h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82115614;  }
		/* 821155E0h case    3:*/		return 0x821155E4;
		  /* 821155E4h */ case    4:  		/* mr R11, R22 */
		/* 821155E4h case    4:*/		regs.R11 = regs.R22;
		/* 821155E4h case    4:*/		return 0x821155E8;
		  /* 821155E8h */ case    5:  		/* lwz R9, <#[R31 + 16]> */
		/* 821155E8h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 821155E8h case    5:*/		return 0x821155EC;
		  /* 821155ECh */ case    6:  		/* addi R10, R10, 1 */
		/* 821155ECh case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821155ECh case    6:*/		return 0x821155F0;
		  /* 821155F0h */ case    7:  		/* lwz R8, <#[R26 + 20]> */
		/* 821155F0h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000014) );
		/* 821155F0h case    7:*/		return 0x821155F4;
		  /* 821155F4h */ case    8:  		/* lwzx R9, <#[R9 + R11]> */
		/* 821155F4h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821155F4h case    8:*/		return 0x821155F8;
		  /* 821155F8h */ case    9:  		/* addi R11, R11, 4 */
		/* 821155F8h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821155F8h case    9:*/		return 0x821155FC;
		  /* 821155FCh */ case   10:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821155FCh case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821155FCh case   10:*/		return 0x82115600;
		  /* 82115600h */ case   11:  		/* lwzx R9, <#[R9 + R8]> */
		/* 82115600h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82115600h case   11:*/		return 0x82115604;
		  /* 82115604h */ case   12:  		/* stw R19, <#[R9 + 48]> */
		/* 82115604h case   12:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R9 + 0x00000030) );
		/* 82115604h case   12:*/		return 0x82115608;
		  /* 82115608h */ case   13:  		/* lwz R9, <#[R31 + 12]> */
		/* 82115608h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 82115608h case   13:*/		return 0x8211560C;
		  /* 8211560Ch */ case   14:  		/* cmplw CR6, R10, R9 */
		/* 8211560Ch case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8211560Ch case   14:*/		return 0x82115610;
		  /* 82115610h */ case   15:  		/* bc 12, CR6_LT, -40 */
		/* 82115610h case   15:*/		if ( regs.CR[6].lt ) { return 0x821155E8;  }
		/* 82115610h case   15:*/		return 0x82115614;
	}
	return 0x82115614;
} // Block from 821155D4h-82115614h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82115614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82115614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82115614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82115614);
		  /* 82115614h */ case    0:  		/* stw R22, <#[R31]> */
		/* 82115614h case    0:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000000) );
		/* 82115614h case    0:*/		return 0x82115618;
		  /* 82115618h */ case    1:  		/* mr R23, R21 */
		/* 82115618h case    1:*/		regs.R23 = regs.R21;
		/* 82115618h case    1:*/		return 0x8211561C;
		  /* 8211561Ch */ case    2:  		/* stw R22, <#[R31 + 4]> */
		/* 8211561Ch case    2:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000004) );
		/* 8211561Ch case    2:*/		return 0x82115620;
		  /* 82115620h */ case    3:  		/* stw R22, <#[R31 + 12]> */
		/* 82115620h case    3:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x0000000C) );
		/* 82115620h case    3:*/		return 0x82115624;
	}
	return 0x82115624;
} // Block from 82115614h-82115624h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82115624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82115624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82115624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82115624);
		  /* 82115624h */ case    0:  		/* lwz R11, <#[R26 + 12]> */
		/* 82115624h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 82115624h case    0:*/		return 0x82115628;
		  /* 82115628h */ case    1:  		/* addi R18, R18, 1 */
		/* 82115628h case    1:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R18,0x1);
		/* 82115628h case    1:*/		return 0x8211562C;
		  /* 8211562Ch */ case    2:  		/* cmplw CR6, R18, R11 */
		/* 8211562Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R18,regs.R11);
		/* 8211562Ch case    2:*/		return 0x82115630;
		  /* 82115630h */ case    3:  		/* bc 12, CR6_LT, -4424 */
		/* 82115630h case    3:*/		if ( regs.CR[6].lt ) { return 0x821144E8;  }
		/* 82115630h case    3:*/		return 0x82115634;
		  /* 82115634h */ case    4:  		/* cmpwi CR6, R23, 0 */
		/* 82115634h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 82115634h case    4:*/		return 0x82115638;
		  /* 82115638h */ case    5:  		/* bc 4, CR6_EQ, 32 */
		/* 82115638h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82115658;  }
		/* 82115638h case    5:*/		return 0x8211563C;
	}
	return 0x8211563C;
} // Block from 82115624h-8211563Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8211563Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211563C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211563C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211563C);
		  /* 8211563Ch */ case    0:  		/* li R3, 1 */
		/* 8211563Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8211563Ch case    0:*/		return 0x82115640;
		  /* 82115640h */ case    1:  		/* b 36 */
		/* 82115640h case    1:*/		return 0x82115664;
		/* 82115640h case    1:*/		return 0x82115644;
	}
	return 0x82115644;
} // Block from 8211563Ch-82115644h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82115644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82115644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82115644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82115644);
		  /* 82115644h */ case    0:  		/* lis R3, -32761 */
		/* 82115644h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 82115644h case    0:*/		return 0x82115648;
		  /* 82115648h */ case    1:  		/* ori R3, R3, 14 */
		/* 82115648h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 82115648h case    1:*/		return 0x8211564C;
		  /* 8211564Ch */ case    2:  		/* b 24 */
		/* 8211564Ch case    2:*/		return 0x82115664;
		/* 8211564Ch case    2:*/		return 0x82115650;
	}
	return 0x82115650;
} // Block from 82115644h-82115650h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82115650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82115650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82115650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82115650);
		  /* 82115650h */ case    0:  		/* mr R3, R29 */
		/* 82115650h case    0:*/		regs.R3 = regs.R29;
		/* 82115650h case    0:*/		return 0x82115654;
		  /* 82115654h */ case    1:  		/* b 16 */
		/* 82115654h case    1:*/		return 0x82115664;
		/* 82115654h case    1:*/		return 0x82115658;
	}
	return 0x82115658;
} // Block from 82115650h-82115658h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82115658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82115658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82115658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82115658);
		  /* 82115658h */ case    0:  		/* mr R3, R26 */
		/* 82115658h case    0:*/		regs.R3 = regs.R26;
		/* 82115658h case    0:*/		return 0x8211565C;
		  /* 8211565Ch */ case    1:  		/* bl -62012 */
		/* 8211565Ch case    1:*/		regs.LR = 0x82115660; return 0x82106420;
		/* 8211565Ch case    1:*/		return 0x82115660;
		  /* 82115660h */ case    2:  		/* li R3, 0 */
		/* 82115660h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82115660h case    2:*/		return 0x82115664;
	}
	return 0x82115664;
} // Block from 82115658h-82115664h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82115664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82115664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82115664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82115664);
		  /* 82115664h */ case    0:  		/* addi R1, R1, 272 */
		/* 82115664h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x110);
		/* 82115664h case    0:*/		return 0x82115668;
		  /* 82115668h */ case    1:  		/* lfd FR30, <#[R1 - 168]> */
		/* 82115668h case    1:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFF58) );
		/* 82115668h case    1:*/		return 0x8211566C;
		  /* 8211566Ch */ case    2:  		/* lfd FR31, <#[R1 - 160]> */
		/* 8211566Ch case    2:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8211566Ch case    2:*/		return 0x82115670;
		  /* 82115670h */ case    3:  		/* b -541696 */
		/* 82115670h case    3:*/		return 0x82091270;
		/* 82115670h case    3:*/		return 0x82115674;
		  /* 82115674h */ case    4:  		/* nop */
		/* 82115674h case    4:*/		cpu::op::nop();
		/* 82115674h case    4:*/		return 0x82115678;
	}
	return 0x82115678;
} // Block from 82115664h-82115678h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82115678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82115678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82115678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82115678);
		  /* 82115678h */ case    0:  		/* mfspr R12, LR */
		/* 82115678h case    0:*/		regs.R12 = regs.LR;
		/* 82115678h case    0:*/		return 0x8211567C;
		  /* 8211567Ch */ case    1:  		/* bl -541788 */
		/* 8211567Ch case    1:*/		regs.LR = 0x82115680; return 0x82091220;
		/* 8211567Ch case    1:*/		return 0x82115680;
		  /* 82115680h */ case    2:  		/* stfd FR30, <#[R1 - 168]> */
		/* 82115680h case    2:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFF58) );
		/* 82115680h case    2:*/		return 0x82115684;
		  /* 82115684h */ case    3:  		/* stfd FR31, <#[R1 - 160]> */
		/* 82115684h case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 82115684h case    3:*/		return 0x82115688;
		  /* 82115688h */ case    4:  		/* stwu R1, <#[R1 - 320]> */
		/* 82115688h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEC0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEC0);
		/* 82115688h case    4:*/		return 0x8211568C;
		  /* 8211568Ch */ case    5:  		/* li R15, -1 */
		/* 8211568Ch case    5:*/		cpu::op::li<0>(regs,&regs.R15,0xFFFFFFFF);
		/* 8211568Ch case    5:*/		return 0x82115690;
		  /* 82115690h */ case    6:  		/* mr R31, R3 */
		/* 82115690h case    6:*/		regs.R31 = regs.R3;
		/* 82115690h case    6:*/		return 0x82115694;
		  /* 82115694h */ case    7:  		/* stw R15, <#[R1 + 84]> */
		/* 82115694h case    7:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x00000054) );
		/* 82115694h case    7:*/		return 0x82115698;
		  /* 82115698h */ case    8:  		/* bl -64256 */
		/* 82115698h case    8:*/		regs.LR = 0x8211569C; return 0x82105B98;
		/* 82115698h case    8:*/		return 0x8211569C;
		  /* 8211569Ch */ case    9:  		/* lwz R8, <#[R31 + 8]> */
		/* 8211569Ch case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 8211569Ch case    9:*/		return 0x821156A0;
		  /* 821156A0h */ case   10:  		/* li R14, 0 */
		/* 821156A0h case   10:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 821156A0h case   10:*/		return 0x821156A4;
		  /* 821156A4h */ case   11:  		/* mr R9, R14 */
		/* 821156A4h case   11:*/		regs.R9 = regs.R14;
		/* 821156A4h case   11:*/		return 0x821156A8;
		  /* 821156A8h */ case   12:  		/* stw R14, <#[R1 + 80]> */
		/* 821156A8h case   12:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000050) );
		/* 821156A8h case   12:*/		return 0x821156AC;
		  /* 821156ACh */ case   13:  		/* mr R7, R14 */
		/* 821156ACh case   13:*/		regs.R7 = regs.R14;
		/* 821156ACh case   13:*/		return 0x821156B0;
		  /* 821156B0h */ case   14:  		/* cmplwi CR6, R8, 0 */
		/* 821156B0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 821156B0h case   14:*/		return 0x821156B4;
		  /* 821156B4h */ case   15:  		/* bc 12, CR6_EQ, 68 */
		/* 821156B4h case   15:*/		if ( regs.CR[6].eq ) { return 0x821156F8;  }
		/* 821156B4h case   15:*/		return 0x821156B8;
		  /* 821156B8h */ case   16:  		/* lwz R6, <#[R31 + 20]> */
		/* 821156B8h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000014) );
		/* 821156B8h case   16:*/		return 0x821156BC;
		  /* 821156BCh */ case   17:  		/* mr R10, R14 */
		/* 821156BCh case   17:*/		regs.R10 = regs.R14;
		/* 821156BCh case   17:*/		return 0x821156C0;
		  /* 821156C0h */ case   18:  		/* lwz R5, <#[R31 + 136]> */
		/* 821156C0h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000088) );
		/* 821156C0h case   18:*/		return 0x821156C4;
		  /* 821156C4h */ case   19:  		/* lwzx R11, <#[R10 + R6]> */
		/* 821156C4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 821156C4h case   19:*/		return 0x821156C8;
		  /* 821156C8h */ case   20:  		/* lwz R4, <#[R11 + 4]> */
		/* 821156C8h case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 821156C8h case   20:*/		return 0x821156CC;
		  /* 821156CCh */ case   21:  		/* cmplw CR6, R5, R4 */
		/* 821156CCh case   21:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R4);
		/* 821156CCh case   21:*/		return 0x821156D0;
		  /* 821156D0h */ case   22:  		/* bc 4, CR6_EQ, 20 */
		/* 821156D0h case   22:*/		if ( !regs.CR[6].eq ) { return 0x821156E4;  }
		/* 821156D0h case   22:*/		return 0x821156D4;
		  /* 821156D4h */ case   23:  		/* lwz R11, <#[R11 + 12]> */
		/* 821156D4h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 821156D4h case   23:*/		return 0x821156D8;
		  /* 821156D8h */ case   24:  		/* cmplw CR6, R9, R11 */
		/* 821156D8h case   24:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 821156D8h case   24:*/		return 0x821156DC;
		  /* 821156DCh */ case   25:  		/* bc 12, CR6_GT, 8 */
		/* 821156DCh case   25:*/		if ( regs.CR[6].gt ) { return 0x821156E4;  }
		/* 821156DCh case   25:*/		return 0x821156E0;
		  /* 821156E0h */ case   26:  		/* addi R9, R11, 1 */
		/* 821156E0h case   26:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 821156E0h case   26:*/		return 0x821156E4;
	}
	return 0x821156E4;
} // Block from 82115678h-821156E4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 821156E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821156E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821156E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821156E4);
		  /* 821156E4h */ case    0:  		/* addi R7, R7, 1 */
		/* 821156E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 821156E4h case    0:*/		return 0x821156E8;
		  /* 821156E8h */ case    1:  		/* addi R10, R10, 4 */
		/* 821156E8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821156E8h case    1:*/		return 0x821156EC;
		  /* 821156ECh */ case    2:  		/* cmplw CR6, R7, R8 */
		/* 821156ECh case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 821156ECh case    2:*/		return 0x821156F0;
		  /* 821156F0h */ case    3:  		/* bc 12, CR6_LT, -44 */
		/* 821156F0h case    3:*/		if ( regs.CR[6].lt ) { return 0x821156C4;  }
		/* 821156F0h case    3:*/		return 0x821156F4;
		  /* 821156F4h */ case    4:  		/* stw R9, <#[R1 + 80]> */
		/* 821156F4h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 821156F4h case    4:*/		return 0x821156F8;
	}
	return 0x821156F8;
} // Block from 821156E4h-821156F8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821156F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821156F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821156F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821156F8);
		  /* 821156F8h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 821156F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821156F8h case    0:*/		return 0x821156FC;
		  /* 821156FCh */ case    1:  		/* lis R4, 9345 */
		/* 821156FCh case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 821156FCh case    1:*/		return 0x82115700;
		  /* 82115700h */ case    2:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 82115700h case    2:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 82115700h case    2:*/		return 0x82115704;
		  /* 82115704h */ case    3:  		/* add R11, R11, R9 */
		/* 82115704h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82115704h case    3:*/		return 0x82115708;
		  /* 82115708h */ case    4:  		/* rlwinm R30, R11, 2, 0, 29 */
		/* 82115708h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R11);
		/* 82115708h case    4:*/		return 0x8211570C;
		  /* 8211570Ch */ case    5:  		/* mr R3, R30 */
		/* 8211570Ch case    5:*/		regs.R3 = regs.R30;
		/* 8211570Ch case    5:*/		return 0x82115710;
		  /* 82115710h */ case    6:  		/* bl -578832 */
		/* 82115710h case    6:*/		regs.LR = 0x82115714; return 0x82088200;
		/* 82115710h case    6:*/		return 0x82115714;
		  /* 82115714h */ case    7:  		/* or. R27, R3, R3 */
		/* 82115714h case    7:*/		cpu::op::or<1>(regs,&regs.R27,regs.R3,regs.R3);
		/* 82115714h case    7:*/		return 0x82115718;
		  /* 82115718h */ case    8:  		/* stw R27, <#[R1 + 88]> */
		/* 82115718h case    8:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000058) );
		/* 82115718h case    8:*/		return 0x8211571C;
		  /* 8211571Ch */ case    9:  		/* bc 4, CR0_EQ, 16 */
		/* 8211571Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x8211572C;  }
		/* 8211571Ch case    9:*/		return 0x82115720;
		  /* 82115720h */ case   10:  		/* lis R3, -32761 */
		/* 82115720h case   10:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 82115720h case   10:*/		return 0x82115724;
		  /* 82115724h */ case   11:  		/* ori R3, R3, 14 */
		/* 82115724h case   11:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 82115724h case   11:*/		return 0x82115728;
		  /* 82115728h */ case   12:  		/* b 1844 */
		/* 82115728h case   12:*/		return 0x82115E5C;
		/* 82115728h case   12:*/		return 0x8211572C;
	}
	return 0x8211572C;
} // Block from 821156F8h-8211572Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8211572Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211572C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211572C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211572C);
		  /* 8211572Ch */ case    0:  		/* mr R5, R30 */
		/* 8211572Ch case    0:*/		regs.R5 = regs.R30;
		/* 8211572Ch case    0:*/		return 0x82115730;
		  /* 82115730h */ case    1:  		/* li R4, 0 */
		/* 82115730h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82115730h case    1:*/		return 0x82115734;
		  /* 82115734h */ case    2:  		/* mr R3, R27 */
		/* 82115734h case    2:*/		regs.R3 = regs.R27;
		/* 82115734h case    2:*/		return 0x82115738;
		  /* 82115738h */ case    3:  		/* bl -541688 */
		/* 82115738h case    3:*/		regs.LR = 0x8211573C; return 0x82091340;
		/* 82115738h case    3:*/		return 0x8211573C;
		  /* 8211573Ch */ case    4:  		/* lwz R11, <#[R31 + 8]> */
		/* 8211573Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8211573Ch case    4:*/		return 0x82115740;
		  /* 82115740h */ case    5:  		/* mr R8, R14 */
		/* 82115740h case    5:*/		regs.R8 = regs.R14;
		/* 82115740h case    5:*/		return 0x82115744;
		  /* 82115744h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82115744h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82115744h case    6:*/		return 0x82115748;
		  /* 82115748h */ case    7:  		/* bc 4, CR6_GT, 84 */
		/* 82115748h case    7:*/		if ( !regs.CR[6].gt ) { return 0x8211579C;  }
		/* 82115748h case    7:*/		return 0x8211574C;
		  /* 8211574Ch */ case    8:  		/* mr R9, R14 */
		/* 8211574Ch case    8:*/		regs.R9 = regs.R14;
		/* 8211574Ch case    8:*/		return 0x82115750;
		  /* 82115750h */ case    9:  		/* lwz R11, <#[R31 + 20]> */
		/* 82115750h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82115750h case    9:*/		return 0x82115754;
		  /* 82115754h */ case   10:  		/* lwz R10, <#[R31 + 136]> */
		/* 82115754h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000088) );
		/* 82115754h case   10:*/		return 0x82115758;
		  /* 82115758h */ case   11:  		/* lwzx R11, <#[R9 + R11]> */
		/* 82115758h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82115758h case   11:*/		return 0x8211575C;
		  /* 8211575Ch */ case   12:  		/* lwz R7, <#[R11 + 4]> */
		/* 8211575Ch case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 8211575Ch case   12:*/		return 0x82115760;
		  /* 82115760h */ case   13:  		/* cmplw CR6, R10, R7 */
		/* 82115760h case   13:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 82115760h case   13:*/		return 0x82115764;
		  /* 82115764h */ case   14:  		/* bc 4, CR6_EQ, 36 */
		/* 82115764h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82115788;  }
		/* 82115764h case   14:*/		return 0x82115768;
		  /* 82115768h */ case   15:  		/* lwz R10, <#[R11 + 12]> */
		/* 82115768h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82115768h case   15:*/		return 0x8211576C;
		  /* 8211576Ch */ case   16:  		/* lwz R11, <#[R11 + 16]> */
		/* 8211576Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 8211576Ch case   16:*/		return 0x82115770;
		  /* 82115770h */ case   17:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82115770h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82115770h case   17:*/		return 0x82115774;
		  /* 82115774h */ case   18:  		/* lwzx R7, <#[R10 + R27]> */
		/* 82115774h case   18:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 82115774h case   18:*/		return 0x82115778;
		  /* 82115778h */ case   19:  		/* cmplw CR6, R7, R11 */
		/* 82115778h case   19:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 82115778h case   19:*/		return 0x8211577C;
		  /* 8211577Ch */ case   20:  		/* bc 12, CR6_GT, 12 */
		/* 8211577Ch case   20:*/		if ( regs.CR[6].gt ) { return 0x82115788;  }
		/* 8211577Ch case   20:*/		return 0x82115780;
		  /* 82115780h */ case   21:  		/* addi R11, R11, 1 */
		/* 82115780h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82115780h case   21:*/		return 0x82115784;
		  /* 82115784h */ case   22:  		/* stwx R11, <#[R10 + R27]> */
		/* 82115784h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 82115784h case   22:*/		return 0x82115788;
	}
	return 0x82115788;
} // Block from 8211572Ch-82115788h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82115788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82115788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82115788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82115788);
		  /* 82115788h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82115788h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82115788h case    0:*/		return 0x8211578C;
		  /* 8211578Ch */ case    1:  		/* addi R8, R8, 1 */
		/* 8211578Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8211578Ch case    1:*/		return 0x82115790;
		  /* 82115790h */ case    2:  		/* addi R9, R9, 4 */
		/* 82115790h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82115790h case    2:*/		return 0x82115794;
		  /* 82115794h */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 82115794h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 82115794h case    3:*/		return 0x82115798;
		  /* 82115798h */ case    4:  		/* bc 12, CR6_LT, -72 */
		/* 82115798h case    4:*/		if ( regs.CR[6].lt ) { return 0x82115750;  }
		/* 82115798h case    4:*/		return 0x8211579C;
	}
	return 0x8211579C;
} // Block from 82115788h-8211579Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8211579Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8211579C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8211579C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8211579C);
		  /* 8211579Ch */ case    0:  		/* lwz R17, <#[R31 + 12]> */
		/* 8211579Ch case    0:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R31 + 0x0000000C) );
		/* 8211579Ch case    0:*/		return 0x821157A0;
		  /* 821157A0h */ case    1:  		/* stw R14, <#[R1 + 96]> */
		/* 821157A0h case    1:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000060) );
		/* 821157A0h case    1:*/		return 0x821157A4;
		  /* 821157A4h */ case    2:  		/* cmplwi CR6, R17, 0 */
		/* 821157A4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 821157A4h case    2:*/		return 0x821157A8;
		  /* 821157A8h */ case    3:  		/* bc 12, CR6_EQ, 1612 */
		/* 821157A8h case    3:*/		if ( regs.CR[6].eq ) { return 0x82115DF4;  }
		/* 821157A8h case    3:*/		return 0x821157AC;
		  /* 821157ACh */ case    4:  		/* lis R11, -32256 */
		/* 821157ACh case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821157ACh case    4:*/		return 0x821157B0;
		  /* 821157B0h */ case    5:  		/* lis R10, -32256 */
		/* 821157B0h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 821157B0h case    5:*/		return 0x821157B4;
		  /* 821157B4h */ case    6:  		/* mr R16, R14 */
		/* 821157B4h case    6:*/		regs.R16 = regs.R14;
		/* 821157B4h case    6:*/		return 0x821157B8;
		  /* 821157B8h */ case    7:  		/* lfd FR30, <#[R11 + 1848]> */
		/* 821157B8h case    7:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R11 + 0x00000738) );
		/* 821157B8h case    7:*/		return 0x821157BC;
		  /* 821157BCh */ case    8:  		/* lfd FR31, <#[R10 + 1808]> */
		/* 821157BCh case    8:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R10 + 0x00000710) );
		/* 821157BCh case    8:*/		return 0x821157C0;
		  /* 821157C0h */ case    9:  		/* lwz R11, <#[R31 + 24]> */
		/* 821157C0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 821157C0h case    9:*/		return 0x821157C4;
		  /* 821157C4h */ case   10:  		/* lwzx R29, <#[R11 + R16]> */
		/* 821157C4h case   10:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R16 + 0x00000000) );
		/* 821157C4h case   10:*/		return 0x821157C8;
		  /* 821157C8h */ case   11:  		/* lwz R11, <#[R29]> */
		/* 821157C8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821157C8h case   11:*/		return 0x821157CC;
		  /* 821157CCh */ case   12:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 821157CCh case   12:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 821157CCh case   12:*/		return 0x821157D0;
		  /* 821157D0h */ case   13:  		/* bc 12, CR0_EQ, 1512 */
		/* 821157D0h case   13:*/		if ( regs.CR[0].eq ) { return 0x82115DB8;  }
		/* 821157D0h case   13:*/		return 0x821157D4;
		  /* 821157D4h */ case   14:  		/* addi R5, R1, 92 */
		/* 821157D4h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x5C);
		/* 821157D4h case   14:*/		return 0x821157D8;
		  /* 821157D8h */ case   15:  		/* li R4, 0 */
		/* 821157D8h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821157D8h case   15:*/		return 0x821157DC;
		  /* 821157DCh */ case   16:  		/* mr R3, R29 */
		/* 821157DCh case   16:*/		regs.R3 = regs.R29;
		/* 821157DCh case   16:*/		return 0x821157E0;
		  /* 821157E0h */ case   17:  		/* li R28, 1 */
		/* 821157E0h case   17:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 821157E0h case   17:*/		return 0x821157E4;
		  /* 821157E4h */ case   18:  		/* mr R30, R14 */
		/* 821157E4h case   18:*/		regs.R30 = regs.R14;
		/* 821157E4h case   18:*/		return 0x821157E8;
		  /* 821157E8h */ case   19:  		/* bl -104656 */
		/* 821157E8h case   19:*/		regs.LR = 0x821157EC; return 0x820FBF18;
		/* 821157E8h case   19:*/		return 0x821157EC;
		  /* 821157ECh */ case   20:  		/* cmplwi CR0, R3, 0 */
		/* 821157ECh case   20:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 821157ECh case   20:*/		return 0x821157F0;
		  /* 821157F0h */ case   21:  		/* bc 12, CR0_EQ, 1660 */
		/* 821157F0h case   21:*/		if ( regs.CR[0].eq ) { return 0x82115E6C;  }
		/* 821157F0h case   21:*/		return 0x821157F4;
		  /* 821157F4h */ case   22:  		/* mr R5, R3 */
		/* 821157F4h case   22:*/		regs.R5 = regs.R3;
		/* 821157F4h case   22:*/		return 0x821157F8;
		  /* 821157F8h */ case   23:  		/* lwz R4, <#[R1 + 92]> */
		/* 821157F8h case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000005C) );
		/* 821157F8h case   23:*/		return 0x821157FC;
		  /* 821157FCh */ case   24:  		/* mr R10, R15 */
		/* 821157FCh case   24:*/		regs.R10 = regs.R15;
		/* 821157FCh case   24:*/		return 0x82115800;
		  /* 82115800h */ case   25:  		/* mr R9, R17 */
		/* 82115800h case   25:*/		regs.R9 = regs.R17;
		/* 82115800h case   25:*/		return 0x82115804;
		  /* 82115804h */ case   26:  		/* mr R8, R29 */
		/* 82115804h case   26:*/		regs.R8 = regs.R29;
		/* 82115804h case   26:*/		return 0x82115808;
		  /* 82115808h */ case   27:  		/* addi R7, R1, 80 */
		/* 82115808h case   27:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 82115808h case   27:*/		return 0x8211580C;
		  /* 8211580Ch */ case   28:  		/* mr R6, R27 */
		/* 8211580Ch case   28:*/		regs.R6 = regs.R27;
		/* 8211580Ch case   28:*/		return 0x82115810;
		  /* 82115810h */ case   29:  		/* mr R3, R31 */
		/* 82115810h case   29:*/		regs.R3 = regs.R31;
		/* 82115810h case   29:*/		return 0x82115814;
		  /* 82115814h */ case   30:  		/* bl -14140 */
		/* 82115814h case   30:*/		regs.LR = 0x82115818; return 0x821120D8;
		/* 82115814h case   30:*/		return 0x82115818;
		  /* 82115818h */ case   31:  		/* subfic R11, R3, 0 */
		/* 82115818h case   31:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R3,0x0);
		/* 82115818h case   31:*/		return 0x8211581C;
		  /* 8211581Ch */ case   32:  		/* addi R30, R30, 1 */
		/* 8211581Ch case   32:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8211581Ch case   32:*/		return 0x82115820;
		  /* 82115820h */ case   33:  		/* subfe R11, R11, R11 */
		/* 82115820h case   33:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82115820h case   33:*/		return 0x82115824;
		  /* 82115824h */ case   34:  		/* addi R5, R1, 92 */
		/* 82115824h case   34:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x5C);
		/* 82115824h case   34:*/		return 0x82115828;
		  /* 82115828h */ case   35:  		/* mr R4, R30 */
		/* 82115828h case   35:*/		regs.R4 = regs.R30;
		/* 82115828h case   35:*/		return 0x8211582C;
		  /* 8211582Ch */ case   36:  		/* mr R3, R29 */
		/* 8211582Ch case   36:*/		regs.R3 = regs.R29;
		/* 8211582Ch case   36:*/		return 0x82115830;
		  /* 82115830h */ case   37:  		/* and R28, R11, R28 */
		/* 82115830h case   37:*/		cpu::op::and<0>(regs,&regs.R28,regs.R11,regs.R28);
		/* 82115830h case   37:*/		return 0x82115834;
		  /* 82115834h */ case   38:  		/* bl -104732 */
		/* 82115834h case   38:*/		regs.LR = 0x82115838; return 0x820FBF18;
		/* 82115834h case   38:*/		return 0x82115838;
		  /* 82115838h */ case   39:  		/* cmplwi CR0, R3, 0 */
		/* 82115838h case   39:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82115838h case   39:*/		return 0x8211583C;
		  /* 8211583Ch */ case   40:  		/* bc 4, CR0_EQ, -72 */
		/* 8211583Ch case   40:*/		if ( !regs.CR[0].eq ) { return 0x821157F4;  }
		/* 8211583Ch case   40:*/		return 0x82115840;
		  /* 82115840h */ case   41:  		/* cmpwi CR6, R28, 0 */
		/* 82115840h case   41:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 82115840h case   41:*/		return 0x82115844;
		  /* 82115844h */ case   42:  		/* bc 4, CR6_EQ, 1576 */
		/* 82115844h case   42:*/		if ( !regs.CR[6].eq ) { return 0x82115E6C;  }
		/* 82115844h case   42:*/		return 0x82115848;
		  /* 82115848h */ case   43:  		/* mr R3, R29 */
		/* 82115848h case   43:*/		regs.R3 = regs.R29;
		/* 82115848h case   43:*/		return 0x8211584C;
		  /* 8211584Ch */ case   44:  		/* bl -104668 */
		/* 8211584Ch case   44:*/		regs.LR = 0x82115850; return 0x820FBF70;
		/* 8211584Ch case   44:*/		return 0x82115850;
		  /* 82115850h */ case   45:  		/* cmpwi CR0, R3, 0 */
		/* 82115850h case   45:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82115850h case   45:*/		return 0x82115854;
		  /* 82115854h */ case   46:  		/* bc 4, CR0_EQ, 1560 */
		/* 82115854h case   46:*/		if ( !regs.CR[0].eq ) { return 0x82115E6C;  }
		/* 82115854h case   46:*/		return 0x82115858;
		  /* 82115858h */ case   47:  		/* li R5, 0 */
		/* 82115858h case   47:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82115858h case   47:*/		return 0x8211585C;
		  /* 8211585Ch */ case   48:  		/* li R4, 0 */
		/* 8211585Ch case   48:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8211585Ch case   48:*/		return 0x82115860;
		  /* 82115860h */ case   49:  		/* mr R3, R29 */
		/* 82115860h case   49:*/		regs.R3 = regs.R29;
		/* 82115860h case   49:*/		return 0x82115864;
		  /* 82115864h */ case   50:  		/* mr R20, R14 */
		/* 82115864h case   50:*/		regs.R20 = regs.R14;
		/* 82115864h case   50:*/		return 0x82115868;
		  /* 82115868h */ case   51:  		/* bl -104784 */
		/* 82115868h case   51:*/		regs.LR = 0x8211586C; return 0x820FBF18;
		/* 82115868h case   51:*/		return 0x8211586C;
		  /* 8211586Ch */ case   52:  		/* or. R26, R3, R3 */
		/* 8211586Ch case   52:*/		cpu::op::or<1>(regs,&regs.R26,regs.R3,regs.R3);
		/* 8211586Ch case   52:*/		return 0x82115870;
		  /* 82115870h */ case   53:  		/* bc 12, CR0_EQ, 20 */
		/* 82115870h case   53:*/		if ( regs.CR[0].eq ) { return 0x82115884;  }
		/* 82115870h case   53:*/		return 0x82115874;
		  /* 82115874h */ case   54:  		/* lwz R11, <#[R29 + 4]> */
		/* 82115874h case   54:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82115874h case   54:*/		return 0x82115878;
		  /* 82115878h */ case   55:  		/* twi 6, R26, 0 */
		/* 82115878h case   55:*/		cpu::op::tw<6>(regs, 0x82115878, regs.R26, 0x00000000);
		/* 82115878h case   55:*/		return 0x8211587C;
		  /* 8211587Ch */ case   56:  		/* divwu R22, R11, R26 */
		/* 8211587Ch case   56:*/		cpu::op::divwu<0>(regs,&regs.R22,regs.R11,regs.R26);
		/* 8211587Ch case   56:*/		return 0x82115880;
		  /* 82115880h */ case   57:  		/* b 8 */
		/* 82115880h case   57:*/		return 0x82115888;
		/* 82115880h case   57:*/		return 0x82115884;
	}
	return 0x82115884;
} // Block from 8211579Ch-82115884h (58 instructions)

