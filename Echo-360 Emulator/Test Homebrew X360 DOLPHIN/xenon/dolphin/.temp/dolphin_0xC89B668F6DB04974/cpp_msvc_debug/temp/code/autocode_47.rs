#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 8224B964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B964);
		  /* 8224B964h */ case    0:  		/* stw R11, <#[R31 + 12]> */
		/* 8224B964h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224B964h case    0:*/		return 0x8224B968;
		  /* 8224B968h */ case    1:  		/* mr R3, R31 */
		/* 8224B968h case    1:*/		regs.R3 = regs.R31;
		/* 8224B968h case    1:*/		return 0x8224B96C;
		  /* 8224B96Ch */ case    2:  		/* stw R29, <#[R31 + 16]> */
		/* 8224B96Ch case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000010) );
		/* 8224B96Ch case    2:*/		return 0x8224B970;
		  /* 8224B970h */ case    3:  		/* stw R29, <#[R31 + 20]> */
		/* 8224B970h case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000014) );
		/* 8224B970h case    3:*/		return 0x8224B974;
		  /* 8224B974h */ case    4:  		/* stw R29, <#[R31 + 24]> */
		/* 8224B974h case    4:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000018) );
		/* 8224B974h case    4:*/		return 0x8224B978;
		  /* 8224B978h */ case    5:  		/* bl -2960 */
		/* 8224B978h case    5:*/		regs.LR = 0x8224B97C; return 0x8224ADE8;
		/* 8224B978h case    5:*/		return 0x8224B97C;
		  /* 8224B97Ch */ case    6:  		/* mr R3, R31 */
		/* 8224B97Ch case    6:*/		regs.R3 = regs.R31;
		/* 8224B97Ch case    6:*/		return 0x8224B980;
		  /* 8224B980h */ case    7:  		/* addi R1, R1, 112 */
		/* 8224B980h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8224B980h case    7:*/		return 0x8224B984;
		  /* 8224B984h */ case    8:  		/* b -1812184 */
		/* 8224B984h case    8:*/		return 0x820912AC;
		/* 8224B984h case    8:*/		return 0x8224B988;
	}
	return 0x8224B988;
} // Block from 8224B964h-8224B988h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224B988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B988);
		  /* 8224B988h */ case    0:  		/* mfspr R12, LR */
		/* 8224B988h case    0:*/		regs.R12 = regs.LR;
		/* 8224B988h case    0:*/		return 0x8224B98C;
		  /* 8224B98Ch */ case    1:  		/* bl -1812272 */
		/* 8224B98Ch case    1:*/		regs.LR = 0x8224B990; return 0x8209125C;
		/* 8224B98Ch case    1:*/		return 0x8224B990;
		  /* 8224B990h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8224B990h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8224B990h case    2:*/		return 0x8224B994;
		  /* 8224B994h */ case    3:  		/* mr R29, R4 */
		/* 8224B994h case    3:*/		regs.R29 = regs.R4;
		/* 8224B994h case    3:*/		return 0x8224B998;
		  /* 8224B998h */ case    4:  		/* li R30, 0 */
		/* 8224B998h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8224B998h case    4:*/		return 0x8224B99C;
		  /* 8224B99Ch */ case    5:  		/* addi R31, R3, 8 */
		/* 8224B99Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x8);
		/* 8224B99Ch case    5:*/		return 0x8224B9A0;
	}
	return 0x8224B9A0;
} // Block from 8224B988h-8224B9A0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224B9A0h
// Function '?CompareDestination@SchedNode@XGRAPHICS@@CAHPAX0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B9A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B9A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B9A0);
		  /* 8224B9A0h */ case    0:  		/* lwz R3, <#[R31]> */
		/* 8224B9A0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8224B9A0h case    0:*/		return 0x8224B9A4;
		  /* 8224B9A4h */ case    1:  		/* mr R4, R29 */
		/* 8224B9A4h case    1:*/		regs.R4 = regs.R29;
		/* 8224B9A4h case    1:*/		return 0x8224B9A8;
		  /* 8224B9A8h */ case    2:  		/* lwz R11, <#[R3]> */
		/* 8224B9A8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224B9A8h case    2:*/		return 0x8224B9AC;
		  /* 8224B9ACh */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 8224B9ACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8224B9ACh case    3:*/		return 0x8224B9B0;
		  /* 8224B9B0h */ case    4:  		/* mtspr CTR, R11 */
		/* 8224B9B0h case    4:*/		regs.CTR = regs.R11;
		/* 8224B9B0h case    4:*/		return 0x8224B9B4;
		  /* 8224B9B4h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 8224B9B4h case    5:*/		if ( 1 ) { regs.LR = 0x8224B9B8; return (uint32)regs.CTR; }
		/* 8224B9B4h case    5:*/		return 0x8224B9B8;
		  /* 8224B9B8h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224B9B8h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224B9B8h case    6:*/		return 0x8224B9BC;
		  /* 8224B9BCh */ case    7:  		/* bc 12, CR0_EQ, 32 */
		/* 8224B9BCh case    7:*/		if ( regs.CR[0].eq ) { return 0x8224B9DC;  }
		/* 8224B9BCh case    7:*/		return 0x8224B9C0;
		  /* 8224B9C0h */ case    8:  		/* addi R30, R30, 1 */
		/* 8224B9C0h case    8:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8224B9C0h case    8:*/		return 0x8224B9C4;
		  /* 8224B9C4h */ case    9:  		/* addi R31, R31, 4 */
		/* 8224B9C4h case    9:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8224B9C4h case    9:*/		return 0x8224B9C8;
		  /* 8224B9C8h */ case   10:  		/* cmpwi CR6, R30, 2 */
		/* 8224B9C8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000002);
		/* 8224B9C8h case   10:*/		return 0x8224B9CC;
		  /* 8224B9CCh */ case   11:  		/* bc 12, CR6_LT, -44 */
		/* 8224B9CCh case   11:*/		if ( regs.CR[6].lt ) { return 0x8224B9A0;  }
		/* 8224B9CCh case   11:*/		return 0x8224B9D0;
	}
	return 0x8224B9D0;
} // Block from 8224B9A0h-8224B9D0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224B9D0h
// Function '?HashByDestination@SchedNode@XGRAPHICS@@CAHPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B9D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B9D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B9D0);
		  /* 8224B9D0h */ case    0:  		/* li R3, 1 */
		/* 8224B9D0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8224B9D0h case    0:*/		return 0x8224B9D4;
		  /* 8224B9D4h */ case    1:  		/* addi R1, R1, 112 */
		/* 8224B9D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8224B9D4h case    1:*/		return 0x8224B9D8;
		  /* 8224B9D8h */ case    2:  		/* b -1812268 */
		/* 8224B9D8h case    2:*/		return 0x820912AC;
		/* 8224B9D8h case    2:*/		return 0x8224B9DC;
	}
	return 0x8224B9DC;
} // Block from 8224B9D0h-8224B9DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224B9DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B9DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B9DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B9DC);
		  /* 8224B9DCh */ case    0:  		/* li R3, 0 */
		/* 8224B9DCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224B9DCh case    0:*/		return 0x8224B9E0;
		  /* 8224B9E0h */ case    1:  		/* b -12 */
		/* 8224B9E0h case    1:*/		return 0x8224B9D4;
		/* 8224B9E0h case    1:*/		return 0x8224B9E4;
		  /* 8224B9E4h */ case    2:  		/* nop */
		/* 8224B9E4h case    2:*/		cpu::op::nop();
		/* 8224B9E4h case    2:*/		return 0x8224B9E8;
	}
	return 0x8224B9E8;
} // Block from 8224B9DCh-8224B9E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224B9E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B9E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B9E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B9E8);
		  /* 8224B9E8h */ case    0:  		/* mfspr R12, LR */
		/* 8224B9E8h case    0:*/		regs.R12 = regs.LR;
		/* 8224B9E8h case    0:*/		return 0x8224B9EC;
		  /* 8224B9ECh */ case    1:  		/* bl -1812368 */
		/* 8224B9ECh case    1:*/		regs.LR = 0x8224B9F0; return 0x8209125C;
		/* 8224B9ECh case    1:*/		return 0x8224B9F0;
		  /* 8224B9F0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8224B9F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8224B9F0h case    2:*/		return 0x8224B9F4;
		  /* 8224B9F4h */ case    3:  		/* mr R29, R4 */
		/* 8224B9F4h case    3:*/		regs.R29 = regs.R4;
		/* 8224B9F4h case    3:*/		return 0x8224B9F8;
		  /* 8224B9F8h */ case    4:  		/* addi R30, R3, 4 */
		/* 8224B9F8h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x4);
		/* 8224B9F8h case    4:*/		return 0x8224B9FC;
		  /* 8224B9FCh */ case    5:  		/* li R31, 2 */
		/* 8224B9FCh case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x2);
		/* 8224B9FCh case    5:*/		return 0x8224BA00;
		  /* 8224BA00h */ case    6:  		/* lwzu R3, <#[R30 + 4]> */
		/* 8224BA00h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8224BA00h case    6:*/		return 0x8224BA04;
		  /* 8224BA04h */ case    7:  		/* mr R4, R29 */
		/* 8224BA04h case    7:*/		regs.R4 = regs.R29;
		/* 8224BA04h case    7:*/		return 0x8224BA08;
		  /* 8224BA08h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 8224BA08h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224BA08h case    8:*/		return 0x8224BA0C;
		  /* 8224BA0Ch */ case    9:  		/* lwz R11, <#[R11 + 8]> */
		/* 8224BA0Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8224BA0Ch case    9:*/		return 0x8224BA10;
		  /* 8224BA10h */ case   10:  		/* mtspr CTR, R11 */
		/* 8224BA10h case   10:*/		regs.CTR = regs.R11;
		/* 8224BA10h case   10:*/		return 0x8224BA14;
		  /* 8224BA14h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 8224BA14h case   11:*/		if ( 1 ) { regs.LR = 0x8224BA18; return (uint32)regs.CTR; }
		/* 8224BA14h case   11:*/		return 0x8224BA18;
		  /* 8224BA18h */ case   12:  		/* addic. R31, R31, -1 */
		/* 8224BA18h case   12:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 8224BA18h case   12:*/		return 0x8224BA1C;
		  /* 8224BA1Ch */ case   13:  		/* bc 4, CR0_EQ, -28 */
		/* 8224BA1Ch case   13:*/		if ( !regs.CR[0].eq ) { return 0x8224BA00;  }
		/* 8224BA1Ch case   13:*/		return 0x8224BA20;
		  /* 8224BA20h */ case   14:  		/* addi R1, R1, 112 */
		/* 8224BA20h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8224BA20h case   14:*/		return 0x8224BA24;
		  /* 8224BA24h */ case   15:  		/* b -1812344 */
		/* 8224BA24h case   15:*/		return 0x820912AC;
		/* 8224BA24h case   15:*/		return 0x8224BA28;
	}
	return 0x8224BA28;
} // Block from 8224B9E8h-8224BA28h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8224BA28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BA28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BA28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BA28);
		  /* 8224BA28h */ case    0:  		/* mfspr R12, LR */
		/* 8224BA28h case    0:*/		regs.R12 = regs.LR;
		/* 8224BA28h case    0:*/		return 0x8224BA2C;
		  /* 8224BA2Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8224BA2Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224BA2Ch case    1:*/		return 0x8224BA30;
		  /* 8224BA30h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8224BA30h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8224BA30h case    2:*/		return 0x8224BA34;
		  /* 8224BA34h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8224BA34h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224BA34h case    3:*/		return 0x8224BA38;
		  /* 8224BA38h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8224BA38h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8224BA38h case    4:*/		return 0x8224BA3C;
		  /* 8224BA3Ch */ case    5:  		/* li R31, 0 */
		/* 8224BA3Ch case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8224BA3Ch case    5:*/		return 0x8224BA40;
		  /* 8224BA40h */ case    6:  		/* addi R30, R3, 8 */
		/* 8224BA40h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x8);
		/* 8224BA40h case    6:*/		return 0x8224BA44;
		  /* 8224BA44h */ case    7:  		/* lwz R3, <#[R30]> */
		/* 8224BA44h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 8224BA44h case    7:*/		return 0x8224BA48;
		  /* 8224BA48h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 8224BA48h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224BA48h case    8:*/		return 0x8224BA4C;
		  /* 8224BA4Ch */ case    9:  		/* lwz R11, <#[R11 + 16]> */
		/* 8224BA4Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 8224BA4Ch case    9:*/		return 0x8224BA50;
		  /* 8224BA50h */ case   10:  		/* mtspr CTR, R11 */
		/* 8224BA50h case   10:*/		regs.CTR = regs.R11;
		/* 8224BA50h case   10:*/		return 0x8224BA54;
		  /* 8224BA54h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 8224BA54h case   11:*/		if ( 1 ) { regs.LR = 0x8224BA58; return (uint32)regs.CTR; }
		/* 8224BA54h case   11:*/		return 0x8224BA58;
	}
	return 0x8224BA58;
} // Block from 8224BA28h-8224BA58h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224BA58h
// Function '?AssignSlot@ParallelGroup@XGRAPHICS@@QAAXPAVSchedNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BA58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BA58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BA58);
		  /* 8224BA58h */ case    0:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224BA58h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224BA58h case    0:*/		return 0x8224BA5C;
		  /* 8224BA5Ch */ case    1:  		/* bc 4, CR0_EQ, 48 */
		/* 8224BA5Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x8224BA8C;  }
		/* 8224BA5Ch case    1:*/		return 0x8224BA60;
		  /* 8224BA60h */ case    2:  		/* addi R31, R31, 1 */
		/* 8224BA60h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8224BA60h case    2:*/		return 0x8224BA64;
		  /* 8224BA64h */ case    3:  		/* addi R30, R30, 4 */
		/* 8224BA64h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8224BA64h case    3:*/		return 0x8224BA68;
		  /* 8224BA68h */ case    4:  		/* cmpwi CR6, R31, 2 */
		/* 8224BA68h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000002);
		/* 8224BA68h case    4:*/		return 0x8224BA6C;
		  /* 8224BA6Ch */ case    5:  		/* bc 12, CR6_LT, -40 */
		/* 8224BA6Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x8224BA44;  }
		/* 8224BA6Ch case    5:*/		return 0x8224BA70;
		  /* 8224BA70h */ case    6:  		/* li R3, 0 */
		/* 8224BA70h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224BA70h case    6:*/		return 0x8224BA74;
		  /* 8224BA74h */ case    7:  		/* addi R1, R1, 112 */
		/* 8224BA74h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8224BA74h case    7:*/		return 0x8224BA78;
		  /* 8224BA78h */ case    8:  		/* lwz R12, <#[R1 - 8]> */
		/* 8224BA78h case    8:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224BA78h case    8:*/		return 0x8224BA7C;
		  /* 8224BA7Ch */ case    9:  		/* mtspr LR, R12 */
		/* 8224BA7Ch case    9:*/		regs.LR = regs.R12;
		/* 8224BA7Ch case    9:*/		return 0x8224BA80;
		  /* 8224BA80h */ case   10:  		/* ld R30, <#[R1 - 24]> */
		/* 8224BA80h case   10:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8224BA80h case   10:*/		return 0x8224BA84;
		  /* 8224BA84h */ case   11:  		/* ld R31, <#[R1 - 16]> */
		/* 8224BA84h case   11:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224BA84h case   11:*/		return 0x8224BA88;
		  /* 8224BA88h */ case   12:  		/* bclr 20, CR0_LT */
		/* 8224BA88h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224BA88h case   12:*/		return 0x8224BA8C;
	}
	return 0x8224BA8C;
} // Block from 8224BA58h-8224BA8Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224BA8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BA8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BA8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BA8C);
		  /* 8224BA8Ch */ case    0:  		/* li R3, 1 */
		/* 8224BA8Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8224BA8Ch case    0:*/		return 0x8224BA90;
		  /* 8224BA90h */ case    1:  		/* b -28 */
		/* 8224BA90h case    1:*/		return 0x8224BA74;
		/* 8224BA90h case    1:*/		return 0x8224BA94;
		  /* 8224BA94h */ case    2:  		/* nop */
		/* 8224BA94h case    2:*/		cpu::op::nop();
		/* 8224BA94h case    2:*/		return 0x8224BA98;
	}
	return 0x8224BA98;
} // Block from 8224BA8Ch-8224BA98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224BA98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BA98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BA98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BA98);
		  /* 8224BA98h */ case    0:  		/* mfspr R12, LR */
		/* 8224BA98h case    0:*/		regs.R12 = regs.LR;
		/* 8224BA98h case    0:*/		return 0x8224BA9C;
		  /* 8224BA9Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8224BA9Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224BA9Ch case    1:*/		return 0x8224BAA0;
		  /* 8224BAA0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8224BAA0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8224BAA0h case    2:*/		return 0x8224BAA4;
		  /* 8224BAA4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8224BAA4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224BAA4h case    3:*/		return 0x8224BAA8;
		  /* 8224BAA8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8224BAA8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8224BAA8h case    4:*/		return 0x8224BAAC;
		  /* 8224BAACh */ case    5:  		/* li R31, 0 */
		/* 8224BAACh case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8224BAACh case    5:*/		return 0x8224BAB0;
		  /* 8224BAB0h */ case    6:  		/* addi R30, R3, 8 */
		/* 8224BAB0h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x8);
		/* 8224BAB0h case    6:*/		return 0x8224BAB4;
		  /* 8224BAB4h */ case    7:  		/* lwz R3, <#[R30]> */
		/* 8224BAB4h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 8224BAB4h case    7:*/		return 0x8224BAB8;
		  /* 8224BAB8h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 8224BAB8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224BAB8h case    8:*/		return 0x8224BABC;
		  /* 8224BABCh */ case    9:  		/* lwz R11, <#[R11 + 20]> */
		/* 8224BABCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8224BABCh case    9:*/		return 0x8224BAC0;
		  /* 8224BAC0h */ case   10:  		/* mtspr CTR, R11 */
		/* 8224BAC0h case   10:*/		regs.CTR = regs.R11;
		/* 8224BAC0h case   10:*/		return 0x8224BAC4;
		  /* 8224BAC4h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 8224BAC4h case   11:*/		if ( 1 ) { regs.LR = 0x8224BAC8; return (uint32)regs.CTR; }
		/* 8224BAC4h case   11:*/		return 0x8224BAC8;
		  /* 8224BAC8h */ case   12:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224BAC8h case   12:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224BAC8h case   12:*/		return 0x8224BACC;
		  /* 8224BACCh */ case   13:  		/* bc 12, CR0_EQ, 48 */
		/* 8224BACCh case   13:*/		if ( regs.CR[0].eq ) { return 0x8224BAFC;  }
		/* 8224BACCh case   13:*/		return 0x8224BAD0;
		  /* 8224BAD0h */ case   14:  		/* addi R31, R31, 1 */
		/* 8224BAD0h case   14:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8224BAD0h case   14:*/		return 0x8224BAD4;
		  /* 8224BAD4h */ case   15:  		/* addi R30, R30, 4 */
		/* 8224BAD4h case   15:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8224BAD4h case   15:*/		return 0x8224BAD8;
		  /* 8224BAD8h */ case   16:  		/* cmpwi CR6, R31, 2 */
		/* 8224BAD8h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000002);
		/* 8224BAD8h case   16:*/		return 0x8224BADC;
		  /* 8224BADCh */ case   17:  		/* bc 12, CR6_LT, -40 */
		/* 8224BADCh case   17:*/		if ( regs.CR[6].lt ) { return 0x8224BAB4;  }
		/* 8224BADCh case   17:*/		return 0x8224BAE0;
		  /* 8224BAE0h */ case   18:  		/* li R3, 1 */
		/* 8224BAE0h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8224BAE0h case   18:*/		return 0x8224BAE4;
		  /* 8224BAE4h */ case   19:  		/* addi R1, R1, 112 */
		/* 8224BAE4h case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8224BAE4h case   19:*/		return 0x8224BAE8;
		  /* 8224BAE8h */ case   20:  		/* lwz R12, <#[R1 - 8]> */
		/* 8224BAE8h case   20:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224BAE8h case   20:*/		return 0x8224BAEC;
		  /* 8224BAECh */ case   21:  		/* mtspr LR, R12 */
		/* 8224BAECh case   21:*/		regs.LR = regs.R12;
		/* 8224BAECh case   21:*/		return 0x8224BAF0;
		  /* 8224BAF0h */ case   22:  		/* ld R30, <#[R1 - 24]> */
		/* 8224BAF0h case   22:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8224BAF0h case   22:*/		return 0x8224BAF4;
		  /* 8224BAF4h */ case   23:  		/* ld R31, <#[R1 - 16]> */
		/* 8224BAF4h case   23:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224BAF4h case   23:*/		return 0x8224BAF8;
		  /* 8224BAF8h */ case   24:  		/* bclr 20, CR0_LT */
		/* 8224BAF8h case   24:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224BAF8h case   24:*/		return 0x8224BAFC;
	}
	return 0x8224BAFC;
} // Block from 8224BA98h-8224BAFCh (25 instructions)

//////////////////////////////////////////////////////
// Block at 8224BAFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BAFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BAFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BAFC);
		  /* 8224BAFCh */ case    0:  		/* li R3, 0 */
		/* 8224BAFCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224BAFCh case    0:*/		return 0x8224BB00;
		  /* 8224BB00h */ case    1:  		/* b -28 */
		/* 8224BB00h case    1:*/		return 0x8224BAE4;
		/* 8224BB00h case    1:*/		return 0x8224BB04;
		  /* 8224BB04h */ case    2:  		/* nop */
		/* 8224BB04h case    2:*/		cpu::op::nop();
		/* 8224BB04h case    2:*/		return 0x8224BB08;
	}
	return 0x8224BB08;
} // Block from 8224BAFCh-8224BB08h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224BB08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BB08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BB08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BB08);
		  /* 8224BB08h */ case    0:  		/* mfspr R12, LR */
		/* 8224BB08h case    0:*/		regs.R12 = regs.LR;
		/* 8224BB08h case    0:*/		return 0x8224BB0C;
		  /* 8224BB0Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8224BB0Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224BB0Ch case    1:*/		return 0x8224BB10;
		  /* 8224BB10h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8224BB10h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8224BB10h case    2:*/		return 0x8224BB14;
		  /* 8224BB14h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8224BB14h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224BB14h case    3:*/		return 0x8224BB18;
		  /* 8224BB18h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8224BB18h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8224BB18h case    4:*/		return 0x8224BB1C;
		  /* 8224BB1Ch */ case    5:  		/* li R31, 0 */
		/* 8224BB1Ch case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8224BB1Ch case    5:*/		return 0x8224BB20;
		  /* 8224BB20h */ case    6:  		/* addi R30, R3, 8 */
		/* 8224BB20h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x8);
		/* 8224BB20h case    6:*/		return 0x8224BB24;
		  /* 8224BB24h */ case    7:  		/* lwz R3, <#[R30]> */
		/* 8224BB24h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 8224BB24h case    7:*/		return 0x8224BB28;
		  /* 8224BB28h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 8224BB28h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224BB28h case    8:*/		return 0x8224BB2C;
		  /* 8224BB2Ch */ case    9:  		/* lwz R11, <#[R11 + 28]> */
		/* 8224BB2Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8224BB2Ch case    9:*/		return 0x8224BB30;
		  /* 8224BB30h */ case   10:  		/* mtspr CTR, R11 */
		/* 8224BB30h case   10:*/		regs.CTR = regs.R11;
		/* 8224BB30h case   10:*/		return 0x8224BB34;
		  /* 8224BB34h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 8224BB34h case   11:*/		if ( 1 ) { regs.LR = 0x8224BB38; return (uint32)regs.CTR; }
		/* 8224BB34h case   11:*/		return 0x8224BB38;
		  /* 8224BB38h */ case   12:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224BB38h case   12:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224BB38h case   12:*/		return 0x8224BB3C;
		  /* 8224BB3Ch */ case   13:  		/* bc 12, CR0_EQ, 48 */
		/* 8224BB3Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x8224BB6C;  }
		/* 8224BB3Ch case   13:*/		return 0x8224BB40;
		  /* 8224BB40h */ case   14:  		/* addi R31, R31, 1 */
		/* 8224BB40h case   14:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8224BB40h case   14:*/		return 0x8224BB44;
		  /* 8224BB44h */ case   15:  		/* addi R30, R30, 4 */
		/* 8224BB44h case   15:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8224BB44h case   15:*/		return 0x8224BB48;
		  /* 8224BB48h */ case   16:  		/* cmpwi CR6, R31, 2 */
		/* 8224BB48h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000002);
		/* 8224BB48h case   16:*/		return 0x8224BB4C;
		  /* 8224BB4Ch */ case   17:  		/* bc 12, CR6_LT, -40 */
		/* 8224BB4Ch case   17:*/		if ( regs.CR[6].lt ) { return 0x8224BB24;  }
		/* 8224BB4Ch case   17:*/		return 0x8224BB50;
		  /* 8224BB50h */ case   18:  		/* li R3, 1 */
		/* 8224BB50h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8224BB50h case   18:*/		return 0x8224BB54;
		  /* 8224BB54h */ case   19:  		/* addi R1, R1, 112 */
		/* 8224BB54h case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8224BB54h case   19:*/		return 0x8224BB58;
		  /* 8224BB58h */ case   20:  		/* lwz R12, <#[R1 - 8]> */
		/* 8224BB58h case   20:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224BB58h case   20:*/		return 0x8224BB5C;
		  /* 8224BB5Ch */ case   21:  		/* mtspr LR, R12 */
		/* 8224BB5Ch case   21:*/		regs.LR = regs.R12;
		/* 8224BB5Ch case   21:*/		return 0x8224BB60;
	}
	return 0x8224BB60;
} // Block from 8224BB08h-8224BB60h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8224BB60h
// Function '?Preprocess@Scheduler@XGRAPHICS@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BB60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BB60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BB60);
		  /* 8224BB60h */ case    0:  		/* ld R30, <#[R1 - 24]> */
		/* 8224BB60h case    0:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8224BB60h case    0:*/		return 0x8224BB64;
		  /* 8224BB64h */ case    1:  		/* ld R31, <#[R1 - 16]> */
		/* 8224BB64h case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224BB64h case    1:*/		return 0x8224BB68;
		  /* 8224BB68h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8224BB68h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224BB68h case    2:*/		return 0x8224BB6C;
	}
	return 0x8224BB6C;
} // Block from 8224BB60h-8224BB6Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224BB6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BB6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BB6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BB6C);
		  /* 8224BB6Ch */ case    0:  		/* li R3, 0 */
		/* 8224BB6Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224BB6Ch case    0:*/		return 0x8224BB70;
		  /* 8224BB70h */ case    1:  		/* b -28 */
		/* 8224BB70h case    1:*/		return 0x8224BB54;
		/* 8224BB70h case    1:*/		return 0x8224BB74;
		  /* 8224BB74h */ case    2:  		/* nop */
		/* 8224BB74h case    2:*/		cpu::op::nop();
		/* 8224BB74h case    2:*/		return 0x8224BB78;
	}
	return 0x8224BB78;
} // Block from 8224BB6Ch-8224BB78h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224BB78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BB78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BB78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BB78);
		  /* 8224BB78h */ case    0:  		/* mfspr R12, LR */
		/* 8224BB78h case    0:*/		regs.R12 = regs.LR;
		/* 8224BB78h case    0:*/		return 0x8224BB7C;
		  /* 8224BB7Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8224BB7Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224BB7Ch case    1:*/		return 0x8224BB80;
		  /* 8224BB80h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8224BB80h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8224BB80h case    2:*/		return 0x8224BB84;
		  /* 8224BB84h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8224BB84h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224BB84h case    3:*/		return 0x8224BB88;
		  /* 8224BB88h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8224BB88h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8224BB88h case    4:*/		return 0x8224BB8C;
		  /* 8224BB8Ch */ case    5:  		/* li R31, 0 */
		/* 8224BB8Ch case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8224BB8Ch case    5:*/		return 0x8224BB90;
		  /* 8224BB90h */ case    6:  		/* addi R30, R3, 8 */
		/* 8224BB90h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x8);
		/* 8224BB90h case    6:*/		return 0x8224BB94;
		  /* 8224BB94h */ case    7:  		/* lwz R3, <#[R30]> */
		/* 8224BB94h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 8224BB94h case    7:*/		return 0x8224BB98;
		  /* 8224BB98h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 8224BB98h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224BB98h case    8:*/		return 0x8224BB9C;
		  /* 8224BB9Ch */ case    9:  		/* lwz R11, <#[R11 + 24]> */
		/* 8224BB9Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8224BB9Ch case    9:*/		return 0x8224BBA0;
		  /* 8224BBA0h */ case   10:  		/* mtspr CTR, R11 */
		/* 8224BBA0h case   10:*/		regs.CTR = regs.R11;
		/* 8224BBA0h case   10:*/		return 0x8224BBA4;
		  /* 8224BBA4h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 8224BBA4h case   11:*/		if ( 1 ) { regs.LR = 0x8224BBA8; return (uint32)regs.CTR; }
		/* 8224BBA4h case   11:*/		return 0x8224BBA8;
		  /* 8224BBA8h */ case   12:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224BBA8h case   12:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224BBA8h case   12:*/		return 0x8224BBAC;
		  /* 8224BBACh */ case   13:  		/* bc 12, CR0_EQ, 48 */
		/* 8224BBACh case   13:*/		if ( regs.CR[0].eq ) { return 0x8224BBDC;  }
		/* 8224BBACh case   13:*/		return 0x8224BBB0;
		  /* 8224BBB0h */ case   14:  		/* addi R31, R31, 1 */
		/* 8224BBB0h case   14:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8224BBB0h case   14:*/		return 0x8224BBB4;
		  /* 8224BBB4h */ case   15:  		/* addi R30, R30, 4 */
		/* 8224BBB4h case   15:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8224BBB4h case   15:*/		return 0x8224BBB8;
		  /* 8224BBB8h */ case   16:  		/* cmpwi CR6, R31, 2 */
		/* 8224BBB8h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000002);
		/* 8224BBB8h case   16:*/		return 0x8224BBBC;
		  /* 8224BBBCh */ case   17:  		/* bc 12, CR6_LT, -40 */
		/* 8224BBBCh case   17:*/		if ( regs.CR[6].lt ) { return 0x8224BB94;  }
		/* 8224BBBCh case   17:*/		return 0x8224BBC0;
		  /* 8224BBC0h */ case   18:  		/* li R3, 1 */
		/* 8224BBC0h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8224BBC0h case   18:*/		return 0x8224BBC4;
		  /* 8224BBC4h */ case   19:  		/* addi R1, R1, 112 */
		/* 8224BBC4h case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8224BBC4h case   19:*/		return 0x8224BBC8;
		  /* 8224BBC8h */ case   20:  		/* lwz R12, <#[R1 - 8]> */
		/* 8224BBC8h case   20:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224BBC8h case   20:*/		return 0x8224BBCC;
		  /* 8224BBCCh */ case   21:  		/* mtspr LR, R12 */
		/* 8224BBCCh case   21:*/		regs.LR = regs.R12;
		/* 8224BBCCh case   21:*/		return 0x8224BBD0;
		  /* 8224BBD0h */ case   22:  		/* ld R30, <#[R1 - 24]> */
		/* 8224BBD0h case   22:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8224BBD0h case   22:*/		return 0x8224BBD4;
		  /* 8224BBD4h */ case   23:  		/* ld R31, <#[R1 - 16]> */
		/* 8224BBD4h case   23:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224BBD4h case   23:*/		return 0x8224BBD8;
		  /* 8224BBD8h */ case   24:  		/* bclr 20, CR0_LT */
		/* 8224BBD8h case   24:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224BBD8h case   24:*/		return 0x8224BBDC;
	}
	return 0x8224BBDC;
} // Block from 8224BB78h-8224BBDCh (25 instructions)

//////////////////////////////////////////////////////
// Block at 8224BBDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BBDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BBDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BBDC);
		  /* 8224BBDCh */ case    0:  		/* li R3, 0 */
		/* 8224BBDCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224BBDCh case    0:*/		return 0x8224BBE0;
		  /* 8224BBE0h */ case    1:  		/* b -28 */
		/* 8224BBE0h case    1:*/		return 0x8224BBC4;
		/* 8224BBE0h case    1:*/		return 0x8224BBE4;
		  /* 8224BBE4h */ case    2:  		/* nop */
		/* 8224BBE4h case    2:*/		cpu::op::nop();
		/* 8224BBE4h case    2:*/		return 0x8224BBE8;
	}
	return 0x8224BBE8;
} // Block from 8224BBDCh-8224BBE8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224BBE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BBE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BBE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BBE8);
		  /* 8224BBE8h */ case    0:  		/* mfspr R12, LR */
		/* 8224BBE8h case    0:*/		regs.R12 = regs.LR;
		/* 8224BBE8h case    0:*/		return 0x8224BBEC;
		  /* 8224BBECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8224BBECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224BBECh case    1:*/		return 0x8224BBF0;
		  /* 8224BBF0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8224BBF0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224BBF0h case    2:*/		return 0x8224BBF4;
		  /* 8224BBF4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8224BBF4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8224BBF4h case    3:*/		return 0x8224BBF8;
		  /* 8224BBF8h */ case    4:  		/* lis R11, -32252 */
		/* 8224BBF8h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224BBF8h case    4:*/		return 0x8224BBFC;
		  /* 8224BBFCh */ case    5:  		/* mr R31, R3 */
		/* 8224BBFCh case    5:*/		regs.R31 = regs.R3;
		/* 8224BBFCh case    5:*/		return 0x8224BC00;
		  /* 8224BC00h */ case    6:  		/* addi R11, R11, 14380 */
		/* 8224BC00h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x382C);
		/* 8224BC00h case    6:*/		return 0x8224BC04;
		  /* 8224BC04h */ case    7:  		/* rlwinm. R10, R4, 0, 31, 31 */
		/* 8224BC04h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R4);
		/* 8224BC04h case    7:*/		return 0x8224BC08;
		  /* 8224BC08h */ case    8:  		/* stw R11, <#[R3]> */
		/* 8224BC08h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224BC08h case    8:*/		return 0x8224BC0C;
		  /* 8224BC0Ch */ case    9:  		/* bc 12, CR0_EQ, 16 */
		/* 8224BC0Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x8224BC1C;  }
		/* 8224BC0Ch case    9:*/		return 0x8224BC10;
		  /* 8224BC10h */ case   10:  		/* addi R4, R3, -4 */
		/* 8224BC10h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0xFFFFFFFC);
		/* 8224BC10h case   10:*/		return 0x8224BC14;
		  /* 8224BC14h */ case   11:  		/* lwz R3, <#[R3 - 4]> */
		/* 8224BC14h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0xFFFFFFFC) );
		/* 8224BC14h case   11:*/		return 0x8224BC18;
		  /* 8224BC18h */ case   12:  		/* bl -194008 */
		/* 8224BC18h case   12:*/		regs.LR = 0x8224BC1C; return 0x8221C640;
		/* 8224BC18h case   12:*/		return 0x8224BC1C;
	}
	return 0x8224BC1C;
} // Block from 8224BBE8h-8224BC1Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224BC1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BC1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BC1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BC1C);
		  /* 8224BC1Ch */ case    0:  		/* mr R3, R31 */
		/* 8224BC1Ch case    0:*/		regs.R3 = regs.R31;
		/* 8224BC1Ch case    0:*/		return 0x8224BC20;
		  /* 8224BC20h */ case    1:  		/* addi R1, R1, 96 */
		/* 8224BC20h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8224BC20h case    1:*/		return 0x8224BC24;
		  /* 8224BC24h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 8224BC24h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224BC24h case    2:*/		return 0x8224BC28;
		  /* 8224BC28h */ case    3:  		/* mtspr LR, R12 */
		/* 8224BC28h case    3:*/		regs.LR = regs.R12;
		/* 8224BC28h case    3:*/		return 0x8224BC2C;
		  /* 8224BC2Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8224BC2Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224BC2Ch case    4:*/		return 0x8224BC30;
		  /* 8224BC30h */ case    5:  		/* bclr 20, CR0_LT */
		/* 8224BC30h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224BC30h case    5:*/		return 0x8224BC34;
	}
	return 0x8224BC34;
} // Block from 8224BC1Ch-8224BC34h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224BC34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BC34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BC34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BC34);
		  /* 8224BC34h */ case    0:  		/* nop */
		/* 8224BC34h case    0:*/		cpu::op::nop();
		/* 8224BC34h case    0:*/		return 0x8224BC38;
	}
	return 0x8224BC38;
} // Block from 8224BC34h-8224BC38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224BC38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BC38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BC38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BC38);
		  /* 8224BC38h */ case    0:  		/* mfspr R12, LR */
		/* 8224BC38h case    0:*/		regs.R12 = regs.LR;
		/* 8224BC38h case    0:*/		return 0x8224BC3C;
		  /* 8224BC3Ch */ case    1:  		/* bl -1812964 */
		/* 8224BC3Ch case    1:*/		regs.LR = 0x8224BC40; return 0x82091258;
		/* 8224BC3Ch case    1:*/		return 0x8224BC40;
		  /* 8224BC40h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8224BC40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8224BC40h case    2:*/		return 0x8224BC44;
		  /* 8224BC44h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 8224BC44h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224BC44h case    3:*/		return 0x8224BC48;
		  /* 8224BC48h */ case    4:  		/* mr R31, R3 */
		/* 8224BC48h case    4:*/		regs.R31 = regs.R3;
		/* 8224BC48h case    4:*/		return 0x8224BC4C;
		  /* 8224BC4Ch */ case    5:  		/* mr R30, R4 */
		/* 8224BC4Ch case    5:*/		regs.R30 = regs.R4;
		/* 8224BC4Ch case    5:*/		return 0x8224BC50;
		  /* 8224BC50h */ case    6:  		/* lwz R11, <#[R11 + 68]> */
		/* 8224BC50h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000044) );
		/* 8224BC50h case    6:*/		return 0x8224BC54;
		  /* 8224BC54h */ case    7:  		/* mtspr CTR, R11 */
		/* 8224BC54h case    7:*/		regs.CTR = regs.R11;
		/* 8224BC54h case    7:*/		return 0x8224BC58;
		  /* 8224BC58h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 8224BC58h case    8:*/		if ( 1 ) { regs.LR = 0x8224BC5C; return (uint32)regs.CTR; }
		/* 8224BC58h case    8:*/		return 0x8224BC5C;
		  /* 8224BC5Ch */ case    9:  		/* lis R11, -32253 */
		/* 8224BC5Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8224BC5Ch case    9:*/		return 0x8224BC60;
		  /* 8224BC60h */ case   10:  		/* lis R10, -32252 */
		/* 8224BC60h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224BC60h case   10:*/		return 0x8224BC64;
		  /* 8224BC64h */ case   11:  		/* rlwinm. R9, R3, 0, 24, 31 */
		/* 8224BC64h case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R3);
		/* 8224BC64h case   11:*/		return 0x8224BC68;
		  /* 8224BC68h */ case   12:  		/* addi R29, R11, 27460 */
		/* 8224BC68h case   12:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x6B44);
		/* 8224BC68h case   12:*/		return 0x8224BC6C;
		  /* 8224BC6Ch */ case   13:  		/* addi R28, R10, 14208 */
		/* 8224BC6Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R10,0x3780);
		/* 8224BC6Ch case   13:*/		return 0x8224BC70;
		  /* 8224BC70h */ case   14:  		/* bc 4, CR0_EQ, 32 */
		/* 8224BC70h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8224BC90;  }
		/* 8224BC70h case   14:*/		return 0x8224BC74;
		  /* 8224BC74h */ case   15:  		/* lis R11, -32252 */
		/* 8224BC74h case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224BC74h case   15:*/		return 0x8224BC78;
		  /* 8224BC78h */ case   16:  		/* mr R6, R28 */
		/* 8224BC78h case   16:*/		regs.R6 = regs.R28;
		/* 8224BC78h case   16:*/		return 0x8224BC7C;
		  /* 8224BC7Ch */ case   17:  		/* addi R5, R11, 14848 */
		/* 8224BC7Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3A00);
		/* 8224BC7Ch case   17:*/		return 0x8224BC80;
		  /* 8224BC80h */ case   18:  		/* mr R4, R29 */
		/* 8224BC80h case   18:*/		regs.R4 = regs.R29;
		/* 8224BC80h case   18:*/		return 0x8224BC84;
		  /* 8224BC84h */ case   19:  		/* li R7, 213 */
		/* 8224BC84h case   19:*/		cpu::op::li<0>(regs,&regs.R7,0xD5);
		/* 8224BC84h case   19:*/		return 0x8224BC88;
		  /* 8224BC88h */ case   20:  		/* li R3, 0 */
		/* 8224BC88h case   20:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224BC88h case   20:*/		return 0x8224BC8C;
		  /* 8224BC8Ch */ case   21:  		/* bl -999556 */
		/* 8224BC8Ch case   21:*/		regs.LR = 0x8224BC90; return 0x82157C08;
		/* 8224BC8Ch case   21:*/		return 0x8224BC90;
	}
	return 0x8224BC90;
} // Block from 8224BC38h-8224BC90h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8224BC90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BC90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BC90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BC90);
		  /* 8224BC90h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8224BC90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8224BC90h case    0:*/		return 0x8224BC94;
		  /* 8224BC94h */ case    1:  		/* mr R3, R30 */
		/* 8224BC94h case    1:*/		regs.R3 = regs.R30;
		/* 8224BC94h case    1:*/		return 0x8224BC98;
		  /* 8224BC98h */ case    2:  		/* lwz R11, <#[R11 + 68]> */
		/* 8224BC98h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000044) );
		/* 8224BC98h case    2:*/		return 0x8224BC9C;
		  /* 8224BC9Ch */ case    3:  		/* mtspr CTR, R11 */
		/* 8224BC9Ch case    3:*/		regs.CTR = regs.R11;
		/* 8224BC9Ch case    3:*/		return 0x8224BCA0;
		  /* 8224BCA0h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8224BCA0h case    4:*/		if ( 1 ) { regs.LR = 0x8224BCA4; return (uint32)regs.CTR; }
		/* 8224BCA0h case    4:*/		return 0x8224BCA4;
		  /* 8224BCA4h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224BCA4h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224BCA4h case    5:*/		return 0x8224BCA8;
		  /* 8224BCA8h */ case    6:  		/* bc 4, CR0_EQ, 32 */
		/* 8224BCA8h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8224BCC8;  }
		/* 8224BCA8h case    6:*/		return 0x8224BCAC;
		  /* 8224BCACh */ case    7:  		/* lis R11, -32252 */
		/* 8224BCACh case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224BCACh case    7:*/		return 0x8224BCB0;
		  /* 8224BCB0h */ case    8:  		/* mr R6, R28 */
		/* 8224BCB0h case    8:*/		regs.R6 = regs.R28;
		/* 8224BCB0h case    8:*/		return 0x8224BCB4;
		  /* 8224BCB4h */ case    9:  		/* addi R5, R11, 14828 */
		/* 8224BCB4h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x39EC);
		/* 8224BCB4h case    9:*/		return 0x8224BCB8;
		  /* 8224BCB8h */ case   10:  		/* mr R4, R29 */
		/* 8224BCB8h case   10:*/		regs.R4 = regs.R29;
		/* 8224BCB8h case   10:*/		return 0x8224BCBC;
		  /* 8224BCBCh */ case   11:  		/* li R7, 214 */
		/* 8224BCBCh case   11:*/		cpu::op::li<0>(regs,&regs.R7,0xD6);
		/* 8224BCBCh case   11:*/		return 0x8224BCC0;
		  /* 8224BCC0h */ case   12:  		/* li R3, 0 */
		/* 8224BCC0h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224BCC0h case   12:*/		return 0x8224BCC4;
		  /* 8224BCC4h */ case   13:  		/* bl -999612 */
		/* 8224BCC4h case   13:*/		regs.LR = 0x8224BCC8; return 0x82157C08;
		/* 8224BCC4h case   13:*/		return 0x8224BCC8;
	}
	return 0x8224BCC8;
} // Block from 8224BC90h-8224BCC8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224BCC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BCC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BCC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BCC8);
		  /* 8224BCC8h */ case    0:  		/* mr R3, R31 */
		/* 8224BCC8h case    0:*/		regs.R3 = regs.R31;
		/* 8224BCC8h case    0:*/		return 0x8224BCCC;
		  /* 8224BCCCh */ case    1:  		/* bl 44596 */
		/* 8224BCCCh case    1:*/		regs.LR = 0x8224BCD0; return 0x82256B00;
		/* 8224BCCCh case    1:*/		return 0x8224BCD0;
		  /* 8224BCD0h */ case    2:  		/* mr R29, R3 */
		/* 8224BCD0h case    2:*/		regs.R29 = regs.R3;
		/* 8224BCD0h case    2:*/		return 0x8224BCD4;
		  /* 8224BCD4h */ case    3:  		/* mr R3, R30 */
		/* 8224BCD4h case    3:*/		regs.R3 = regs.R30;
		/* 8224BCD4h case    3:*/		return 0x8224BCD8;
		  /* 8224BCD8h */ case    4:  		/* bl 44584 */
		/* 8224BCD8h case    4:*/		regs.LR = 0x8224BCDC; return 0x82256B00;
		/* 8224BCD8h case    4:*/		return 0x8224BCDC;
		  /* 8224BCDCh */ case    5:  		/* lwz R11, <#[R31 + 168]> */
		/* 8224BCDCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000A8) );
		/* 8224BCDCh case    5:*/		return 0x8224BCE0;
		  /* 8224BCE0h */ case    6:  		/* lwz R10, <#[R30 + 168]> */
		/* 8224BCE0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x000000A8) );
		/* 8224BCE0h case    6:*/		return 0x8224BCE4;
		  /* 8224BCE4h */ case    7:  		/* cmpw CR6, R11, R10 */
		/* 8224BCE4h case    7:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224BCE4h case    7:*/		return 0x8224BCE8;
		  /* 8224BCE8h */ case    8:  		/* bc 4, CR6_EQ, 32 */
		/* 8224BCE8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8224BD08;  }
		/* 8224BCE8h case    8:*/		return 0x8224BCEC;
		  /* 8224BCECh */ case    9:  		/* cmplwi CR6, R29, 0 */
		/* 8224BCECh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8224BCECh case    9:*/		return 0x8224BCF0;
		  /* 8224BCF0h */ case   10:  		/* bc 12, CR6_EQ, 24 */
		/* 8224BCF0h case   10:*/		if ( regs.CR[6].eq ) { return 0x8224BD08;  }
		/* 8224BCF0h case   10:*/		return 0x8224BCF4;
		  /* 8224BCF4h */ case   11:  		/* cmplwi CR6, R3, 0 */
		/* 8224BCF4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8224BCF4h case   11:*/		return 0x8224BCF8;
		  /* 8224BCF8h */ case   12:  		/* bc 12, CR6_EQ, 16 */
		/* 8224BCF8h case   12:*/		if ( regs.CR[6].eq ) { return 0x8224BD08;  }
		/* 8224BCF8h case   12:*/		return 0x8224BCFC;
		  /* 8224BCFCh */ case   13:  		/* cmplw CR6, R29, R3 */
		/* 8224BCFCh case   13:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R3);
		/* 8224BCFCh case   13:*/		return 0x8224BD00;
		  /* 8224BD00h */ case   14:  		/* li R11, 1 */
		/* 8224BD00h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224BD00h case   14:*/		return 0x8224BD04;
		  /* 8224BD04h */ case   15:  		/* bc 12, CR6_EQ, 8 */
		/* 8224BD04h case   15:*/		if ( regs.CR[6].eq ) { return 0x8224BD0C;  }
		/* 8224BD04h case   15:*/		return 0x8224BD08;
	}
	return 0x8224BD08;
} // Block from 8224BCC8h-8224BD08h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8224BD08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BD08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BD08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BD08);
		  /* 8224BD08h */ case    0:  		/* li R11, 0 */
		/* 8224BD08h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224BD08h case    0:*/		return 0x8224BD0C;
	}
	return 0x8224BD0C;
} // Block from 8224BD08h-8224BD0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224BD0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BD0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BD0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BD0C);
		  /* 8224BD0Ch */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 8224BD0Ch case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 8224BD0Ch case    0:*/		return 0x8224BD10;
		  /* 8224BD10h */ case    1:  		/* addi R1, R1, 128 */
		/* 8224BD10h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8224BD10h case    1:*/		return 0x8224BD14;
		  /* 8224BD14h */ case    2:  		/* b -1813100 */
		/* 8224BD14h case    2:*/		return 0x820912A8;
		/* 8224BD14h case    2:*/		return 0x8224BD18;
	}
	return 0x8224BD18;
} // Block from 8224BD0Ch-8224BD18h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224BD18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BD18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BD18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BD18);
		  /* 8224BD18h */ case    0:  		/* mfspr R12, LR */
		/* 8224BD18h case    0:*/		regs.R12 = regs.LR;
		/* 8224BD18h case    0:*/		return 0x8224BD1C;
		  /* 8224BD1Ch */ case    1:  		/* bl -1813216 */
		/* 8224BD1Ch case    1:*/		regs.LR = 0x8224BD20; return 0x8209123C;
		/* 8224BD1Ch case    1:*/		return 0x8224BD20;
		  /* 8224BD20h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 8224BD20h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 8224BD20h case    2:*/		return 0x8224BD24;
		  /* 8224BD24h */ case    3:  		/* mr R27, R3 */
		/* 8224BD24h case    3:*/		regs.R27 = regs.R3;
		/* 8224BD24h case    3:*/		return 0x8224BD28;
		  /* 8224BD28h */ case    4:  		/* lwz R3, <#[R4 + 40]> */
		/* 8224BD28h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x00000028) );
		/* 8224BD28h case    4:*/		return 0x8224BD2C;
		  /* 8224BD2Ch */ case    5:  		/* mr R29, R4 */
		/* 8224BD2Ch case    5:*/		regs.R29 = regs.R4;
		/* 8224BD2Ch case    5:*/		return 0x8224BD30;
		  /* 8224BD30h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 8224BD30h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224BD30h case    6:*/		return 0x8224BD34;
		  /* 8224BD34h */ case    7:  		/* lwz R11, <#[R11 + 56]> */
		/* 8224BD34h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000038) );
		/* 8224BD34h case    7:*/		return 0x8224BD38;
		  /* 8224BD38h */ case    8:  		/* mtspr CTR, R11 */
		/* 8224BD38h case    8:*/		regs.CTR = regs.R11;
		/* 8224BD38h case    8:*/		return 0x8224BD3C;
		  /* 8224BD3Ch */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 8224BD3Ch case    9:*/		if ( 1 ) { regs.LR = 0x8224BD40; return (uint32)regs.CTR; }
		/* 8224BD3Ch case    9:*/		return 0x8224BD40;
		  /* 8224BD40h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224BD40h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224BD40h case   10:*/		return 0x8224BD44;
		  /* 8224BD44h */ case   11:  		/* bc 12, CR0_EQ, 12 */
		/* 8224BD44h case   11:*/		if ( regs.CR[0].eq ) { return 0x8224BD50;  }
		/* 8224BD44h case   11:*/		return 0x8224BD48;
		  /* 8224BD48h */ case   12:  		/* lwz R11, <#[R29 + 28]> */
		/* 8224BD48h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000001C) );
		/* 8224BD48h case   12:*/		return 0x8224BD4C;
		  /* 8224BD4Ch */ case   13:  		/* stw R11, <#[R27 + 8]> */
		/* 8224BD4Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8224BD4Ch case   13:*/		return 0x8224BD50;
	}
	return 0x8224BD50;
} // Block from 8224BD18h-8224BD50h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224BD50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BD50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BD50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BD50);
		  /* 8224BD50h */ case    0:  		/* lwz R3, <#[R29 + 40]> */
		/* 8224BD50h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000028) );
		/* 8224BD50h case    0:*/		return 0x8224BD54;
		  /* 8224BD54h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 8224BD54h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224BD54h case    1:*/		return 0x8224BD58;
		  /* 8224BD58h */ case    2:  		/* lwz R11, <#[R11 + 24]> */
		/* 8224BD58h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8224BD58h case    2:*/		return 0x8224BD5C;
		  /* 8224BD5Ch */ case    3:  		/* mtspr CTR, R11 */
		/* 8224BD5Ch case    3:*/		regs.CTR = regs.R11;
		/* 8224BD5Ch case    3:*/		return 0x8224BD60;
		  /* 8224BD60h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8224BD60h case    4:*/		if ( 1 ) { regs.LR = 0x8224BD64; return (uint32)regs.CTR; }
		/* 8224BD60h case    4:*/		return 0x8224BD64;
		  /* 8224BD64h */ case    5:  		/* lis R11, -32253 */
		/* 8224BD64h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8224BD64h case    5:*/		return 0x8224BD68;
		  /* 8224BD68h */ case    6:  		/* lis R10, -32252 */
		/* 8224BD68h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224BD68h case    6:*/		return 0x8224BD6C;
		  /* 8224BD6Ch */ case    7:  		/* rlwinm. R9, R3, 0, 24, 31 */
		/* 8224BD6Ch case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R3);
		/* 8224BD6Ch case    7:*/		return 0x8224BD70;
		  /* 8224BD70h */ case    8:  		/* addi R22, R11, 27460 */
		/* 8224BD70h case    8:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R11,0x6B44);
		/* 8224BD70h case    8:*/		return 0x8224BD74;
		  /* 8224BD74h */ case    9:  		/* addi R21, R10, 14208 */
		/* 8224BD74h case    9:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R10,0x3780);
		/* 8224BD74h case    9:*/		return 0x8224BD78;
		  /* 8224BD78h */ case   10:  		/* bc 12, CR0_EQ, 104 */
		/* 8224BD78h case   10:*/		if ( regs.CR[0].eq ) { return 0x8224BDE0;  }
		/* 8224BD78h case   10:*/		return 0x8224BD7C;
		  /* 8224BD7Ch */ case   11:  		/* lwz R11, <#[R27 + 4]> */
		/* 8224BD7Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 8224BD7Ch case   11:*/		return 0x8224BD80;
		  /* 8224BD80h */ case   12:  		/* cmpwi CR6, R11, 1 */
		/* 8224BD80h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 8224BD80h case   12:*/		return 0x8224BD84;
		  /* 8224BD84h */ case   13:  		/* bc 4, CR6_EQ, 32 */
		/* 8224BD84h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8224BDA4;  }
		/* 8224BD84h case   13:*/		return 0x8224BD88;
		  /* 8224BD88h */ case   14:  		/* lwz R11, <#[R29 + 40]> */
		/* 8224BD88h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000028) );
		/* 8224BD88h case   14:*/		return 0x8224BD8C;
		  /* 8224BD8Ch */ case   15:  		/* lwz R10, <#[R11 + 228]> */
		/* 8224BD8Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 8224BD8Ch case   15:*/		return 0x8224BD90;
		  /* 8224BD90h */ case   16:  		/* ori R10, R10, 4096 */
		/* 8224BD90h case   16:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1000);
		/* 8224BD90h case   16:*/		return 0x8224BD94;
		  /* 8224BD94h */ case   17:  		/* stw R10, <#[R11 + 228]> */
		/* 8224BD94h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 8224BD94h case   17:*/		return 0x8224BD98;
		  /* 8224BD98h */ case   18:  		/* lwz R11, <#[R29 + 28]> */
		/* 8224BD98h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000001C) );
		/* 8224BD98h case   18:*/		return 0x8224BD9C;
		  /* 8224BD9Ch */ case   19:  		/* stw R11, <#[R27 + 8]> */
		/* 8224BD9Ch case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8224BD9Ch case   19:*/		return 0x8224BDA0;
		  /* 8224BDA0h */ case   20:  		/* b 40 */
		/* 8224BDA0h case   20:*/		return 0x8224BDC8;
		/* 8224BDA0h case   20:*/		return 0x8224BDA4;
	}
	return 0x8224BDA4;
} // Block from 8224BD50h-8224BDA4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8224BDA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BDA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BDA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BDA4);
		  /* 8224BDA4h */ case    0:  		/* cmpwi CR6, R11, 3 */
		/* 8224BDA4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8224BDA4h case    0:*/		return 0x8224BDA8;
		  /* 8224BDA8h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 8224BDA8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8224BDC8;  }
		/* 8224BDA8h case    1:*/		return 0x8224BDAC;
		  /* 8224BDACh */ case    2:  		/* lis R11, -32252 */
		/* 8224BDACh case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224BDACh case    2:*/		return 0x8224BDB0;
		  /* 8224BDB0h */ case    3:  		/* mr R6, R21 */
		/* 8224BDB0h case    3:*/		regs.R6 = regs.R21;
		/* 8224BDB0h case    3:*/		return 0x8224BDB4;
		  /* 8224BDB4h */ case    4:  		/* addi R5, R11, 14028 */
		/* 8224BDB4h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x36CC);
		/* 8224BDB4h case    4:*/		return 0x8224BDB8;
		  /* 8224BDB8h */ case    5:  		/* mr R4, R22 */
		/* 8224BDB8h case    5:*/		regs.R4 = regs.R22;
		/* 8224BDB8h case    5:*/		return 0x8224BDBC;
		  /* 8224BDBCh */ case    6:  		/* li R7, 350 */
		/* 8224BDBCh case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x15E);
		/* 8224BDBCh case    6:*/		return 0x8224BDC0;
		  /* 8224BDC0h */ case    7:  		/* li R3, 0 */
		/* 8224BDC0h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224BDC0h case    7:*/		return 0x8224BDC4;
		  /* 8224BDC4h */ case    8:  		/* bl -999868 */
		/* 8224BDC4h case    8:*/		regs.LR = 0x8224BDC8; return 0x82157C08;
		/* 8224BDC4h case    8:*/		return 0x8224BDC8;
	}
	return 0x8224BDC8;
} // Block from 8224BDA4h-8224BDC8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224BDC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BDC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BDC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BDC8);
		  /* 8224BDC8h */ case    0:  		/* lwz R3, <#[R29 + 40]> */
		/* 8224BDC8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000028) );
		/* 8224BDC8h case    0:*/		return 0x8224BDCC;
		  /* 8224BDCCh */ case    1:  		/* bl 110220 */
		/* 8224BDCCh case    1:*/		regs.LR = 0x8224BDD0; return 0x82266C58;
		/* 8224BDCCh case    1:*/		return 0x8224BDD0;
		  /* 8224BDD0h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224BDD0h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224BDD0h case    2:*/		return 0x8224BDD4;
		  /* 8224BDD4h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 8224BDD4h case    3:*/		if ( regs.CR[0].eq ) { return 0x8224BDE0;  }
		/* 8224BDD4h case    3:*/		return 0x8224BDD8;
		  /* 8224BDD8h */ case    4:  		/* lwz R11, <#[R29 + 28]> */
		/* 8224BDD8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000001C) );
		/* 8224BDD8h case    4:*/		return 0x8224BDDC;
		  /* 8224BDDCh */ case    5:  		/* stw R11, <#[R27 + 12]> */
		/* 8224BDDCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 8224BDDCh case    5:*/		return 0x8224BDE0;
	}
	return 0x8224BDE0;
} // Block from 8224BDC8h-8224BDE0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224BDE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BDE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BDE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BDE0);
		  /* 8224BDE0h */ case    0:  		/* lwz R11, <#[R29 + 52]> */
		/* 8224BDE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000034) );
		/* 8224BDE0h case    0:*/		return 0x8224BDE4;
		  /* 8224BDE4h */ case    1:  		/* li R30, 0 */
		/* 8224BDE4h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8224BDE4h case    1:*/		return 0x8224BDE8;
		  /* 8224BDE8h */ case    2:  		/* lwz R23, <#[R11 + 4]> */
		/* 8224BDE8h case    2:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R11 + 0x00000004) );
		/* 8224BDE8h case    2:*/		return 0x8224BDEC;
		  /* 8224BDECh */ case    3:  		/* cmpwi CR6, R23, 0 */
		/* 8224BDECh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 8224BDECh case    3:*/		return 0x8224BDF0;
		  /* 8224BDF0h */ case    4:  		/* bc 4, CR6_GT, 360 */
		/* 8224BDF0h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8224BF58;  }
		/* 8224BDF0h case    4:*/		return 0x8224BDF4;
		  /* 8224BDF4h */ case    5:  		/* lis R11, -32252 */
		/* 8224BDF4h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224BDF4h case    5:*/		return 0x8224BDF8;
		  /* 8224BDF8h */ case    6:  		/* lis R10, -32252 */
		/* 8224BDF8h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224BDF8h case    6:*/		return 0x8224BDFC;
		  /* 8224BDFCh */ case    7:  		/* lis R9, -32252 */
		/* 8224BDFCh case    7:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 8224BDFCh case    7:*/		return 0x8224BE00;
		  /* 8224BE00h */ case    8:  		/* li R28, 0 */
		/* 8224BE00h case    8:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8224BE00h case    8:*/		return 0x8224BE04;
		  /* 8224BE04h */ case    9:  		/* addi R26, R11, 14916 */
		/* 8224BE04h case    9:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x3A44);
		/* 8224BE04h case    9:*/		return 0x8224BE08;
		  /* 8224BE08h */ case   10:  		/* addi R25, R10, 14868 */
		/* 8224BE08h case   10:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R10,0x3A14);
		/* 8224BE08h case   10:*/		return 0x8224BE0C;
		  /* 8224BE0Ch */ case   11:  		/* addi R24, R9, 14192 */
		/* 8224BE0Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R9,0x3770);
		/* 8224BE0Ch case   11:*/		return 0x8224BE10;
		  /* 8224BE10h */ case   12:  		/* lwz R3, <#[R29 + 52]> */
		/* 8224BE10h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000034) );
		/* 8224BE10h case   12:*/		return 0x8224BE14;
		  /* 8224BE14h */ case   13:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224BE14h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224BE14h case   13:*/		return 0x8224BE18;
		  /* 8224BE18h */ case   14:  		/* cmplw CR6, R30, R11 */
		/* 8224BE18h case   14:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8224BE18h case   14:*/		return 0x8224BE1C;
		  /* 8224BE1Ch */ case   15:  		/* bc 4, CR6_LT, 16 */
		/* 8224BE1Ch case   15:*/		if ( !regs.CR[6].lt ) { return 0x8224BE2C;  }
		/* 8224BE1Ch case   15:*/		return 0x8224BE20;
		  /* 8224BE20h */ case   16:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224BE20h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224BE20h case   16:*/		return 0x8224BE24;
		  /* 8224BE24h */ case   17:  		/* add R3, R11, R28 */
		/* 8224BE24h case   17:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R28);
		/* 8224BE24h case   17:*/		return 0x8224BE28;
		  /* 8224BE28h */ case   18:  		/* b 12 */
		/* 8224BE28h case   18:*/		return 0x8224BE34;
		/* 8224BE28h case   18:*/		return 0x8224BE2C;
	}
	return 0x8224BE2C;
} // Block from 8224BDE0h-8224BE2Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8224BE2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BE2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BE2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BE2C);
		  /* 8224BE2Ch */ case    0:  		/* mr R4, R30 */
		/* 8224BE2Ch case    0:*/		regs.R4 = regs.R30;
		/* 8224BE2Ch case    0:*/		return 0x8224BE30;
		  /* 8224BE30h */ case    1:  		/* bl 31888 */
		/* 8224BE30h case    1:*/		regs.LR = 0x8224BE34; return 0x82253AC0;
		/* 8224BE30h case    1:*/		return 0x8224BE34;
	}
	return 0x8224BE34;
} // Block from 8224BE2Ch-8224BE34h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224BE34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BE34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BE34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BE34);
		  /* 8224BE34h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224BE34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224BE34h case    0:*/		return 0x8224BE38;
		  /* 8224BE38h */ case    1:  		/* lbz R11, <#[R11 + 16]> */
		/* 8224BE38h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 8224BE38h case    1:*/		return 0x8224BE3C;
		  /* 8224BE3Ch */ case    2:  		/* cmplwi CR6, R11, 1 */
		/* 8224BE3Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8224BE3Ch case    2:*/		return 0x8224BE40;
		  /* 8224BE40h */ case    3:  		/* bc 4, CR6_EQ, 264 */
		/* 8224BE40h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8224BF48;  }
		/* 8224BE40h case    3:*/		return 0x8224BE44;
		  /* 8224BE44h */ case    4:  		/* lwz R3, <#[R29 + 52]> */
		/* 8224BE44h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000034) );
		/* 8224BE44h case    4:*/		return 0x8224BE48;
		  /* 8224BE48h */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224BE48h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224BE48h case    5:*/		return 0x8224BE4C;
		  /* 8224BE4Ch */ case    6:  		/* cmplw CR6, R30, R11 */
		/* 8224BE4Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8224BE4Ch case    6:*/		return 0x8224BE50;
		  /* 8224BE50h */ case    7:  		/* bc 4, CR6_LT, 16 */
		/* 8224BE50h case    7:*/		if ( !regs.CR[6].lt ) { return 0x8224BE60;  }
		/* 8224BE50h case    7:*/		return 0x8224BE54;
		  /* 8224BE54h */ case    8:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224BE54h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224BE54h case    8:*/		return 0x8224BE58;
		  /* 8224BE58h */ case    9:  		/* add R3, R11, R28 */
		/* 8224BE58h case    9:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R28);
		/* 8224BE58h case    9:*/		return 0x8224BE5C;
		  /* 8224BE5Ch */ case   10:  		/* b 12 */
		/* 8224BE5Ch case   10:*/		return 0x8224BE68;
		/* 8224BE5Ch case   10:*/		return 0x8224BE60;
	}
	return 0x8224BE60;
} // Block from 8224BE34h-8224BE60h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224BE60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BE60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BE60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BE60);
		  /* 8224BE60h */ case    0:  		/* mr R4, R30 */
		/* 8224BE60h case    0:*/		regs.R4 = regs.R30;
		/* 8224BE60h case    0:*/		return 0x8224BE64;
		  /* 8224BE64h */ case    1:  		/* bl 31836 */
		/* 8224BE64h case    1:*/		regs.LR = 0x8224BE68; return 0x82253AC0;
		/* 8224BE64h case    1:*/		return 0x8224BE68;
	}
	return 0x8224BE68;
} // Block from 8224BE60h-8224BE68h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224BE68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BE68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BE68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BE68);
		  /* 8224BE68h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224BE68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224BE68h case    0:*/		return 0x8224BE6C;
		  /* 8224BE6Ch */ case    1:  		/* lwz R10, <#[R27 + 8]> */
		/* 8224BE6Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000008) );
		/* 8224BE6Ch case    1:*/		return 0x8224BE70;
		  /* 8224BE70h */ case    2:  		/* lwz R31, <#[R11]> */
		/* 8224BE70h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 8224BE70h case    2:*/		return 0x8224BE74;
		  /* 8224BE74h */ case    3:  		/* lwz R11, <#[R31 + 28]> */
		/* 8224BE74h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 8224BE74h case    3:*/		return 0x8224BE78;
		  /* 8224BE78h */ case    4:  		/* cmpw CR6, R11, R10 */
		/* 8224BE78h case    4:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224BE78h case    4:*/		return 0x8224BE7C;
		  /* 8224BE7Ch */ case    5:  		/* bc 12, CR6_LT, 204 */
		/* 8224BE7Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x8224BF48;  }
		/* 8224BE7Ch case    5:*/		return 0x8224BE80;
		  /* 8224BE80h */ case    6:  		/* lwz R11, <#[R27 + 4]> */
		/* 8224BE80h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 8224BE80h case    6:*/		return 0x8224BE84;
		  /* 8224BE84h */ case    7:  		/* cmpwi CR6, R11, 3 */
		/* 8224BE84h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8224BE84h case    7:*/		return 0x8224BE88;
		  /* 8224BE88h */ case    8:  		/* bc 12, CR6_EQ, 36 */
		/* 8224BE88h case    8:*/		if ( regs.CR[6].eq ) { return 0x8224BEAC;  }
		/* 8224BE88h case    8:*/		return 0x8224BE8C;
		  /* 8224BE8Ch */ case    9:  		/* cmpwi CR6, R11, 2 */
		/* 8224BE8Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 8224BE8Ch case    9:*/		return 0x8224BE90;
		  /* 8224BE90h */ case   10:  		/* bc 12, CR6_EQ, 28 */
		/* 8224BE90h case   10:*/		if ( regs.CR[6].eq ) { return 0x8224BEAC;  }
		/* 8224BE90h case   10:*/		return 0x8224BE94;
		  /* 8224BE94h */ case   11:  		/* lwz R11, <#[R29 + 40]> */
		/* 8224BE94h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000028) );
		/* 8224BE94h case   11:*/		return 0x8224BE98;
		  /* 8224BE98h */ case   12:  		/* lwz R10, <#[R11 + 228]> */
		/* 8224BE98h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 8224BE98h case   12:*/		return 0x8224BE9C;
		  /* 8224BE9Ch */ case   13:  		/* ori R10, R10, 4096 */
		/* 8224BE9Ch case   13:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1000);
		/* 8224BE9Ch case   13:*/		return 0x8224BEA0;
		  /* 8224BEA0h */ case   14:  		/* stw R10, <#[R11 + 228]> */
		/* 8224BEA0h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 8224BEA0h case   14:*/		return 0x8224BEA4;
		  /* 8224BEA4h */ case   15:  		/* lwz R11, <#[R29 + 28]> */
		/* 8224BEA4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000001C) );
		/* 8224BEA4h case   15:*/		return 0x8224BEA8;
		  /* 8224BEA8h */ case   16:  		/* b 156 */
		/* 8224BEA8h case   16:*/		return 0x8224BF44;
		/* 8224BEA8h case   16:*/		return 0x8224BEAC;
	}
	return 0x8224BEAC;
} // Block from 8224BE68h-8224BEACh (17 instructions)

//////////////////////////////////////////////////////
// Block at 8224BEACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BEAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BEAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BEAC);
		  /* 8224BEACh */ case    0:  		/* lwz R11, <#[R27]> */
		/* 8224BEACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8224BEACh case    0:*/		return 0x8224BEB0;
		  /* 8224BEB0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8224BEB0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224BEB0h case    1:*/		return 0x8224BEB4;
		  /* 8224BEB4h */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 8224BEB4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224BED0;  }
		/* 8224BEB4h case    2:*/		return 0x8224BEB8;
		  /* 8224BEB8h */ case    3:  		/* mr R6, R21 */
		/* 8224BEB8h case    3:*/		regs.R6 = regs.R21;
		/* 8224BEB8h case    3:*/		return 0x8224BEBC;
		  /* 8224BEBCh */ case    4:  		/* mr R5, R24 */
		/* 8224BEBCh case    4:*/		regs.R5 = regs.R24;
		/* 8224BEBCh case    4:*/		return 0x8224BEC0;
		  /* 8224BEC0h */ case    5:  		/* mr R4, R22 */
		/* 8224BEC0h case    5:*/		regs.R4 = regs.R22;
		/* 8224BEC0h case    5:*/		return 0x8224BEC4;
		  /* 8224BEC4h */ case    6:  		/* li R7, 363 */
		/* 8224BEC4h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x16B);
		/* 8224BEC4h case    6:*/		return 0x8224BEC8;
		  /* 8224BEC8h */ case    7:  		/* li R3, 0 */
		/* 8224BEC8h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224BEC8h case    7:*/		return 0x8224BECC;
		  /* 8224BECCh */ case    8:  		/* bl -1000132 */
		/* 8224BECCh case    8:*/		regs.LR = 0x8224BED0; return 0x82157C08;
		/* 8224BECCh case    8:*/		return 0x8224BED0;
	}
	return 0x8224BED0;
} // Block from 8224BEACh-8224BED0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224BED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BED0);
		  /* 8224BED0h */ case    0:  		/* lwz R11, <#[R27]> */
		/* 8224BED0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8224BED0h case    0:*/		return 0x8224BED4;
		  /* 8224BED4h */ case    1:  		/* lwz R10, <#[R31 + 28]> */
		/* 8224BED4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 8224BED4h case    1:*/		return 0x8224BED8;
		  /* 8224BED8h */ case    2:  		/* lwz R11, <#[R11 + 28]> */
		/* 8224BED8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8224BED8h case    2:*/		return 0x8224BEDC;
		  /* 8224BEDCh */ case    3:  		/* cmpw CR6, R11, R10 */
		/* 8224BEDCh case    3:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224BEDCh case    3:*/		return 0x8224BEE0;
		  /* 8224BEE0h */ case    4:  		/* bc 12, CR6_GT, 28 */
		/* 8224BEE0h case    4:*/		if ( regs.CR[6].gt ) { return 0x8224BEFC;  }
		/* 8224BEE0h case    4:*/		return 0x8224BEE4;
		  /* 8224BEE4h */ case    5:  		/* mr R6, R21 */
		/* 8224BEE4h case    5:*/		regs.R6 = regs.R21;
		/* 8224BEE4h case    5:*/		return 0x8224BEE8;
		  /* 8224BEE8h */ case    6:  		/* mr R5, R25 */
		/* 8224BEE8h case    6:*/		regs.R5 = regs.R25;
		/* 8224BEE8h case    6:*/		return 0x8224BEEC;
		  /* 8224BEECh */ case    7:  		/* mr R4, R22 */
		/* 8224BEECh case    7:*/		regs.R4 = regs.R22;
		/* 8224BEECh case    7:*/		return 0x8224BEF0;
		  /* 8224BEF0h */ case    8:  		/* li R7, 364 */
		/* 8224BEF0h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x16C);
		/* 8224BEF0h case    8:*/		return 0x8224BEF4;
		  /* 8224BEF4h */ case    9:  		/* li R3, 0 */
		/* 8224BEF4h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224BEF4h case    9:*/		return 0x8224BEF8;
		  /* 8224BEF8h */ case   10:  		/* bl -1000176 */
		/* 8224BEF8h case   10:*/		regs.LR = 0x8224BEFC; return 0x82157C08;
		/* 8224BEF8h case   10:*/		return 0x8224BEFC;
	}
	return 0x8224BEFC;
} // Block from 8224BED0h-8224BEFCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224BEFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BEFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BEFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BEFC);
		  /* 8224BEFCh */ case    0:  		/* lwz R11, <#[R27]> */
		/* 8224BEFCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8224BEFCh case    0:*/		return 0x8224BF00;
		  /* 8224BF00h */ case    1:  		/* lwz R10, <#[R27 + 8]> */
		/* 8224BF00h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000008) );
		/* 8224BF00h case    1:*/		return 0x8224BF04;
		  /* 8224BF04h */ case    2:  		/* lwz R11, <#[R11 + 28]> */
		/* 8224BF04h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8224BF04h case    2:*/		return 0x8224BF08;
		  /* 8224BF08h */ case    3:  		/* cmpw CR6, R11, R10 */
		/* 8224BF08h case    3:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224BF08h case    3:*/		return 0x8224BF0C;
		  /* 8224BF0Ch */ case    4:  		/* bc 12, CR6_GT, 28 */
		/* 8224BF0Ch case    4:*/		if ( regs.CR[6].gt ) { return 0x8224BF28;  }
		/* 8224BF0Ch case    4:*/		return 0x8224BF10;
		  /* 8224BF10h */ case    5:  		/* mr R6, R21 */
		/* 8224BF10h case    5:*/		regs.R6 = regs.R21;
		/* 8224BF10h case    5:*/		return 0x8224BF14;
		  /* 8224BF14h */ case    6:  		/* mr R5, R26 */
		/* 8224BF14h case    6:*/		regs.R5 = regs.R26;
		/* 8224BF14h case    6:*/		return 0x8224BF18;
		  /* 8224BF18h */ case    7:  		/* mr R4, R22 */
		/* 8224BF18h case    7:*/		regs.R4 = regs.R22;
		/* 8224BF18h case    7:*/		return 0x8224BF1C;
		  /* 8224BF1Ch */ case    8:  		/* li R7, 365 */
		/* 8224BF1Ch case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x16D);
		/* 8224BF1Ch case    8:*/		return 0x8224BF20;
		  /* 8224BF20h */ case    9:  		/* li R3, 0 */
		/* 8224BF20h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224BF20h case    9:*/		return 0x8224BF24;
		  /* 8224BF24h */ case   10:  		/* bl -1000220 */
		/* 8224BF24h case   10:*/		regs.LR = 0x8224BF28; return 0x82157C08;
		/* 8224BF24h case   10:*/		return 0x8224BF28;
	}
	return 0x8224BF28;
} // Block from 8224BEFCh-8224BF28h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224BF28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BF28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BF28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BF28);
		  /* 8224BF28h */ case    0:  		/* lwz R11, <#[R27]> */
		/* 8224BF28h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8224BF28h case    0:*/		return 0x8224BF2C;
		  /* 8224BF2Ch */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8224BF2Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8224BF2Ch case    1:*/		return 0x8224BF30;
		  /* 8224BF30h */ case    2:  		/* lwz R10, <#[R11 + 228]> */
		/* 8224BF30h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 8224BF30h case    2:*/		return 0x8224BF34;
		  /* 8224BF34h */ case    3:  		/* ori R10, R10, 4096 */
		/* 8224BF34h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1000);
		/* 8224BF34h case    3:*/		return 0x8224BF38;
		  /* 8224BF38h */ case    4:  		/* stw R10, <#[R11 + 228]> */
		/* 8224BF38h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 8224BF38h case    4:*/		return 0x8224BF3C;
		  /* 8224BF3Ch */ case    5:  		/* lwz R11, <#[R27]> */
		/* 8224BF3Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8224BF3Ch case    5:*/		return 0x8224BF40;
		  /* 8224BF40h */ case    6:  		/* lwz R11, <#[R11 + 28]> */
		/* 8224BF40h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8224BF40h case    6:*/		return 0x8224BF44;
	}
	return 0x8224BF44;
} // Block from 8224BF28h-8224BF44h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224BF44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BF44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BF44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BF44);
		  /* 8224BF44h */ case    0:  		/* stw R11, <#[R27 + 8]> */
		/* 8224BF44h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8224BF44h case    0:*/		return 0x8224BF48;
	}
	return 0x8224BF48;
} // Block from 8224BF44h-8224BF48h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224BF48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BF48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BF48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BF48);
		  /* 8224BF48h */ case    0:  		/* addi R30, R30, 1 */
		/* 8224BF48h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8224BF48h case    0:*/		return 0x8224BF4C;
		  /* 8224BF4Ch */ case    1:  		/* addi R28, R28, 4 */
		/* 8224BF4Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 8224BF4Ch case    1:*/		return 0x8224BF50;
		  /* 8224BF50h */ case    2:  		/* cmpw CR6, R30, R23 */
		/* 8224BF50h case    2:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R23);
		/* 8224BF50h case    2:*/		return 0x8224BF54;
		  /* 8224BF54h */ case    3:  		/* bc 12, CR6_LT, -324 */
		/* 8224BF54h case    3:*/		if ( regs.CR[6].lt ) { return 0x8224BE10;  }
		/* 8224BF54h case    3:*/		return 0x8224BF58;
	}
	return 0x8224BF58;
} // Block from 8224BF48h-8224BF58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224BF58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BF58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BF58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BF58);
		  /* 8224BF58h */ case    0:  		/* addi R1, R1, 176 */
		/* 8224BF58h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 8224BF58h case    0:*/		return 0x8224BF5C;
		  /* 8224BF5Ch */ case    1:  		/* b -1813712 */
		/* 8224BF5Ch case    1:*/		return 0x8209128C;
		/* 8224BF5Ch case    1:*/		return 0x8224BF60;
	}
	return 0x8224BF60;
} // Block from 8224BF58h-8224BF60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224BF60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BF60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BF60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BF60);
		  /* 8224BF60h */ case    0:  		/* mfspr R12, LR */
		/* 8224BF60h case    0:*/		regs.R12 = regs.LR;
		/* 8224BF60h case    0:*/		return 0x8224BF64;
		  /* 8224BF64h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8224BF64h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224BF64h case    1:*/		return 0x8224BF68;
		  /* 8224BF68h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8224BF68h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224BF68h case    2:*/		return 0x8224BF6C;
		  /* 8224BF6Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8224BF6Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8224BF6Ch case    3:*/		return 0x8224BF70;
		  /* 8224BF70h */ case    4:  		/* lis R11, -32252 */
		/* 8224BF70h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224BF70h case    4:*/		return 0x8224BF74;
		  /* 8224BF74h */ case    5:  		/* mr R31, R3 */
		/* 8224BF74h case    5:*/		regs.R31 = regs.R3;
		/* 8224BF74h case    5:*/		return 0x8224BF78;
		  /* 8224BF78h */ case    6:  		/* addi R11, R11, 14380 */
		/* 8224BF78h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x382C);
		/* 8224BF78h case    6:*/		return 0x8224BF7C;
		  /* 8224BF7Ch */ case    7:  		/* rlwinm. R10, R4, 0, 31, 31 */
		/* 8224BF7Ch case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R4);
		/* 8224BF7Ch case    7:*/		return 0x8224BF80;
		  /* 8224BF80h */ case    8:  		/* stw R11, <#[R3 + 20]> */
		/* 8224BF80h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 8224BF80h case    8:*/		return 0x8224BF84;
		  /* 8224BF84h */ case    9:  		/* stw R11, <#[R3 + 8]> */
		/* 8224BF84h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224BF84h case    9:*/		return 0x8224BF88;
	}
	return 0x8224BF88;
} // Block from 8224BF60h-8224BF88h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224BF88h
// Function '?AddToReadyList@Scheduler@XGRAPHICS@@AAAXPAVSchedNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BF88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BF88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BF88);
		  /* 8224BF88h */ case    0:  		/* bc 12, CR0_EQ, 24 */
		/* 8224BF88h case    0:*/		if ( regs.CR[0].eq ) { return 0x8224BFA0;  }
		/* 8224BF88h case    0:*/		return 0x8224BF8C;
		  /* 8224BF8Ch */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8224BF8Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8224BF8Ch case    1:*/		return 0x8224BF90;
		  /* 8224BF90h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8224BF90h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224BFA0;  }
		/* 8224BF90h case    2:*/		return 0x8224BF94;
		  /* 8224BF94h */ case    3:  		/* addi R4, R3, -4 */
		/* 8224BF94h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0xFFFFFFFC);
		/* 8224BF94h case    3:*/		return 0x8224BF98;
		  /* 8224BF98h */ case    4:  		/* lwz R3, <#[R3 - 4]> */
		/* 8224BF98h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0xFFFFFFFC) );
		/* 8224BF98h case    4:*/		return 0x8224BF9C;
		  /* 8224BF9Ch */ case    5:  		/* bl -194908 */
		/* 8224BF9Ch case    5:*/		regs.LR = 0x8224BFA0; return 0x8221C640;
		/* 8224BF9Ch case    5:*/		return 0x8224BFA0;
	}
	return 0x8224BFA0;
} // Block from 8224BF88h-8224BFA0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224BFA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BFA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BFA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BFA0);
		  /* 8224BFA0h */ case    0:  		/* mr R3, R31 */
		/* 8224BFA0h case    0:*/		regs.R3 = regs.R31;
		/* 8224BFA0h case    0:*/		return 0x8224BFA4;
		  /* 8224BFA4h */ case    1:  		/* addi R1, R1, 96 */
		/* 8224BFA4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8224BFA4h case    1:*/		return 0x8224BFA8;
		  /* 8224BFA8h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 8224BFA8h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224BFA8h case    2:*/		return 0x8224BFAC;
		  /* 8224BFACh */ case    3:  		/* mtspr LR, R12 */
		/* 8224BFACh case    3:*/		regs.LR = regs.R12;
		/* 8224BFACh case    3:*/		return 0x8224BFB0;
		  /* 8224BFB0h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8224BFB0h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224BFB0h case    4:*/		return 0x8224BFB4;
		  /* 8224BFB4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 8224BFB4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224BFB4h case    5:*/		return 0x8224BFB8;
	}
	return 0x8224BFB8;
} // Block from 8224BFA0h-8224BFB8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224BFB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BFB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BFB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BFB8);
		  /* 8224BFB8h */ case    0:  		/* mfspr R12, LR */
		/* 8224BFB8h case    0:*/		regs.R12 = regs.LR;
		/* 8224BFB8h case    0:*/		return 0x8224BFBC;
		  /* 8224BFBCh */ case    1:  		/* bl -1813868 */
		/* 8224BFBCh case    1:*/		regs.LR = 0x8224BFC0; return 0x82091250;
		/* 8224BFBCh case    1:*/		return 0x8224BFC0;
		  /* 8224BFC0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8224BFC0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8224BFC0h case    2:*/		return 0x8224BFC4;
		  /* 8224BFC4h */ case    3:  		/* mr R26, R3 */
		/* 8224BFC4h case    3:*/		regs.R26 = regs.R3;
		/* 8224BFC4h case    3:*/		return 0x8224BFC8;
		  /* 8224BFC8h */ case    4:  		/* lwz R3, <#[R3]> */
		/* 8224BFC8h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 8224BFC8h case    4:*/		return 0x8224BFCC;
		  /* 8224BFCCh */ case    5:  		/* lwz R11, <#[R3 + 2136]> */
		/* 8224BFCCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000858) );
		/* 8224BFCCh case    5:*/		return 0x8224BFD0;
		  /* 8224BFD0h */ case    6:  		/* rlwinm. R11, R11, 22, 31, 31 */
		/* 8224BFD0h case    6:*/		cpu::op::rlwinm<1,22,31,31>(regs,&regs.R11,regs.R11);
		/* 8224BFD0h case    6:*/		return 0x8224BFD4;
		  /* 8224BFD4h */ case    7:  		/* bc 4, CR0_EQ, 80 */
		/* 8224BFD4h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8224C024;  }
		/* 8224BFD4h case    7:*/		return 0x8224BFD8;
		  /* 8224BFD8h */ case    8:  		/* lwz R11, <#[R26 + 4]> */
		/* 8224BFD8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 8224BFD8h case    8:*/		return 0x8224BFDC;
		  /* 8224BFDCh */ case    9:  		/* lwz R9, <#[R11 + 136]> */
		/* 8224BFDCh case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000088) );
		/* 8224BFDCh case    9:*/		return 0x8224BFE0;
		  /* 8224BFE0h */ case   10:  		/* b 52 */
		/* 8224BFE0h case   10:*/		return 0x8224C014;
		/* 8224BFE0h case   10:*/		return 0x8224BFE4;
		  /* 8224BFE4h */ case   11:  		/* lwz R11, <#[R9 + 28]> */
		/* 8224BFE4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000001C) );
		/* 8224BFE4h case   11:*/		return 0x8224BFE8;
		  /* 8224BFE8h */ case   12:  		/* b 28 */
		/* 8224BFE8h case   12:*/		return 0x8224C004;
		/* 8224BFE8h case   12:*/		return 0x8224BFEC;
		  /* 8224BFECh */ case   13:  		/* lwz R10, <#[R11 + 228]> */
		/* 8224BFECh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 8224BFECh case   13:*/		return 0x8224BFF0;
	}
	return 0x8224BFF0;
} // Block from 8224BFB8h-8224BFF0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224BFF0h
// Function '?IsInstReady@Scheduler@XGRAPHICS@@AAA_NPAVSchedNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224BFF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224BFF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224BFF0);
		  /* 8224BFF0h */ case    0:  		/* rlwinm. R8, R10, 0, 31, 31 */
		/* 8224BFF0h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R8,regs.R10);
		/* 8224BFF0h case    0:*/		return 0x8224BFF4;
		  /* 8224BFF4h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8224BFF4h case    1:*/		if ( regs.CR[0].eq ) { return 0x8224C000;  }
		/* 8224BFF4h case    1:*/		return 0x8224BFF8;
		  /* 8224BFF8h */ case    2:  		/* ori R10, R10, 32 */
		/* 8224BFF8h case    2:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x20);
		/* 8224BFF8h case    2:*/		return 0x8224BFFC;
		  /* 8224BFFCh */ case    3:  		/* stw R10, <#[R11 + 228]> */
		/* 8224BFFCh case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 8224BFFCh case    3:*/		return 0x8224C000;
	}
	return 0x8224C000;
} // Block from 8224BFF0h-8224C000h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224C000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C000);
		  /* 8224C000h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 8224C000h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8224C000h case    0:*/		return 0x8224C004;
	}
	return 0x8224C004;
} // Block from 8224C000h-8224C004h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224C004h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C004( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C004) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C004);
		  /* 8224C004h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 8224C004h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8224C004h case    0:*/		return 0x8224C008;
		  /* 8224C008h */ case    1:  		/* cmpwi CR6, R10, 0 */
		/* 8224C008h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8224C008h case    1:*/		return 0x8224C00C;
		  /* 8224C00Ch */ case    2:  		/* bc 4, CR6_EQ, -32 */
		/* 8224C00Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224BFEC;  }
		/* 8224C00Ch case    2:*/		return 0x8224C010;
		  /* 8224C010h */ case    3:  		/* lwz R9, <#[R9 + 8]> */
		/* 8224C010h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 8224C010h case    3:*/		return 0x8224C014;
	}
	return 0x8224C014;
} // Block from 8224C004h-8224C014h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224C014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C014);
		  /* 8224C014h */ case    0:  		/* lwz R11, <#[R9 + 8]> */
		/* 8224C014h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 8224C014h case    0:*/		return 0x8224C018;
		  /* 8224C018h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224C018h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224C018h case    1:*/		return 0x8224C01C;
		  /* 8224C01Ch */ case    2:  		/* bc 4, CR6_EQ, -56 */
		/* 8224C01Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224BFE4;  }
		/* 8224C01Ch case    2:*/		return 0x8224C020;
		  /* 8224C020h */ case    3:  		/* b 704 */
		/* 8224C020h case    3:*/		return 0x8224C2E0;
		/* 8224C020h case    3:*/		return 0x8224C024;
	}
	return 0x8224C024;
} // Block from 8224C014h-8224C024h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224C024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C024);
		  /* 8224C024h */ case    0:  		/* lwz R11, <#[R3 + 1376]> */
		/* 8224C024h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000560) );
		/* 8224C024h case    0:*/		return 0x8224C028;
		  /* 8224C028h */ case    1:  		/* addi R31, R11, 1 */
		/* 8224C028h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x1);
		/* 8224C028h case    1:*/		return 0x8224C02C;
		  /* 8224C02Ch */ case    2:  		/* rlwinm R4, R31, 2, 0, 29 */
		/* 8224C02Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R31);
		/* 8224C02Ch case    2:*/		return 0x8224C030;
		  /* 8224C030h */ case    3:  		/* bl -193632 */
		/* 8224C030h case    3:*/		regs.LR = 0x8224C034; return 0x8221CBD0;
		/* 8224C030h case    3:*/		return 0x8224C034;
		  /* 8224C034h */ case    4:  		/* mr R29, R3 */
		/* 8224C034h case    4:*/		regs.R29 = regs.R3;
		/* 8224C034h case    4:*/		return 0x8224C038;
		  /* 8224C038h */ case    5:  		/* li R11, 0 */
		/* 8224C038h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224C038h case    5:*/		return 0x8224C03C;
		  /* 8224C03Ch */ case    6:  		/* cmpwi CR6, R31, 0 */
		/* 8224C03Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 8224C03Ch case    6:*/		return 0x8224C040;
		  /* 8224C040h */ case    7:  		/* bc 4, CR6_GT, 24 */
		/* 8224C040h case    7:*/		if ( !regs.CR[6].gt ) { return 0x8224C058;  }
		/* 8224C040h case    7:*/		return 0x8224C044;
		  /* 8224C044h */ case    8:  		/* addi R10, R3, -4 */
		/* 8224C044h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0xFFFFFFFC);
		/* 8224C044h case    8:*/		return 0x8224C048;
		  /* 8224C048h */ case    9:  		/* mtspr CTR, R31 */
		/* 8224C048h case    9:*/		regs.CTR = regs.R31;
		/* 8224C048h case    9:*/		return 0x8224C04C;
		  /* 8224C04Ch */ case   10:  		/* stwu R11, <#[R10 + 4]> */
		/* 8224C04Ch case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8224C04Ch case   10:*/		return 0x8224C050;
		  /* 8224C050h */ case   11:  		/* addi R11, R11, 1 */
		/* 8224C050h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224C050h case   11:*/		return 0x8224C054;
		  /* 8224C054h */ case   12:  		/* bc 16, CR0_LT, -8 */
		/* 8224C054h case   12:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8224C04C;  }
		/* 8224C054h case   12:*/		return 0x8224C058;
	}
	return 0x8224C058;
} // Block from 8224C024h-8224C058h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224C058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C058);
		  /* 8224C058h */ case    0:  		/* lwz R11, <#[R26 + 4]> */
		/* 8224C058h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 8224C058h case    0:*/		return 0x8224C05C;
		  /* 8224C05Ch */ case    1:  		/* lwz R27, <#[R11 + 136]> */
		/* 8224C05Ch case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000088) );
		/* 8224C05Ch case    1:*/		return 0x8224C060;
		  /* 8224C060h */ case    2:  		/* b 456 */
		/* 8224C060h case    2:*/		return 0x8224C228;
		/* 8224C060h case    2:*/		return 0x8224C064;
		  /* 8224C064h */ case    3:  		/* lwz R31, <#[R27 + 28]> */
		/* 8224C064h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R27 + 0x0000001C) );
		/* 8224C064h case    3:*/		return 0x8224C068;
		  /* 8224C068h */ case    4:  		/* b 432 */
		/* 8224C068h case    4:*/		return 0x8224C218;
		/* 8224C068h case    4:*/		return 0x8224C06C;
		  /* 8224C06Ch */ case    5:  		/* lwz R11, <#[R31 + 228]> */
		/* 8224C06Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8224C06Ch case    5:*/		return 0x8224C070;
		  /* 8224C070h */ case    6:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8224C070h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8224C070h case    6:*/		return 0x8224C074;
		  /* 8224C074h */ case    7:  		/* bc 12, CR0_EQ, 416 */
		/* 8224C074h case    7:*/		if ( regs.CR[0].eq ) { return 0x8224C214;  }
		/* 8224C074h case    7:*/		return 0x8224C078;
		  /* 8224C078h */ case    8:  		/* lwz R11, <#[R31]> */
		/* 8224C078h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224C078h case    8:*/		return 0x8224C07C;
		  /* 8224C07Ch */ case    9:  		/* mr R3, R31 */
		/* 8224C07Ch case    9:*/		regs.R3 = regs.R31;
		/* 8224C07Ch case    9:*/		return 0x8224C080;
		  /* 8224C080h */ case   10:  		/* lwz R11, <#[R11 + 44]> */
		/* 8224C080h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 8224C080h case   10:*/		return 0x8224C084;
		  /* 8224C084h */ case   11:  		/* mtspr CTR, R11 */
		/* 8224C084h case   11:*/		regs.CTR = regs.R11;
		/* 8224C084h case   11:*/		return 0x8224C088;
		  /* 8224C088h */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 8224C088h case   12:*/		if ( 1 ) { regs.LR = 0x8224C08C; return (uint32)regs.CTR; }
		/* 8224C088h case   12:*/		return 0x8224C08C;
		  /* 8224C08Ch */ case   13:  		/* cmplwi CR0, R3, 0 */
		/* 8224C08Ch case   13:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8224C08Ch case   13:*/		return 0x8224C090;
		  /* 8224C090h */ case   14:  		/* bc 12, CR0_EQ, 124 */
		/* 8224C090h case   14:*/		if ( regs.CR[0].eq ) { return 0x8224C10C;  }
		/* 8224C090h case   14:*/		return 0x8224C094;
		  /* 8224C094h */ case   15:  		/* lwz R11, <#[R31 + 224]> */
		/* 8224C094h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E0) );
		/* 8224C094h case   15:*/		return 0x8224C098;
		  /* 8224C098h */ case   16:  		/* mr R4, R29 */
		/* 8224C098h case   16:*/		regs.R4 = regs.R29;
		/* 8224C098h case   16:*/		return 0x8224C09C;
		  /* 8224C09Ch */ case   17:  		/* addi R3, R11, 1 */
		/* 8224C09Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1);
		/* 8224C09Ch case   17:*/		return 0x8224C0A0;
		  /* 8224C0A0h */ case   18:  		/* bl 109976 */
		/* 8224C0A0h case   18:*/		regs.LR = 0x8224C0A4; return 0x82266E38;
		/* 8224C0A0h case   18:*/		return 0x8224C0A4;
		  /* 8224C0A4h */ case   19:  		/* mr R4, R3 */
		/* 8224C0A4h case   19:*/		regs.R4 = regs.R3;
		/* 8224C0A4h case   19:*/		return 0x8224C0A8;
		  /* 8224C0A8h */ case   20:  		/* li R3, 0 */
		/* 8224C0A8h case   20:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224C0A8h case   20:*/		return 0x8224C0AC;
		  /* 8224C0ACh */ case   21:  		/* mr R5, R29 */
		/* 8224C0ACh case   21:*/		regs.R5 = regs.R29;
		/* 8224C0ACh case   21:*/		return 0x8224C0B0;
		  /* 8224C0B0h */ case   22:  		/* bl 110056 */
		/* 8224C0B0h case   22:*/		regs.LR = 0x8224C0B4; return 0x82266E98;
		/* 8224C0B0h case   22:*/		return 0x8224C0B4;
		  /* 8224C0B4h */ case   23:  		/* lwz R11, <#[R31 + 228]> */
		/* 8224C0B4h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8224C0B4h case   23:*/		return 0x8224C0B8;
		  /* 8224C0B8h */ case   24:  		/* lwz R10, <#[R31 + 20]> */
		/* 8224C0B8h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 8224C0B8h case   24:*/		return 0x8224C0BC;
		  /* 8224C0BCh */ case   25:  		/* li R30, 1 */
		/* 8224C0BCh case   25:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 8224C0BCh case   25:*/		return 0x8224C0C0;
		  /* 8224C0C0h */ case   26:  		/* ori R11, R11, 32 */
		/* 8224C0C0h case   26:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 8224C0C0h case   26:*/		return 0x8224C0C4;
		  /* 8224C0C4h */ case   27:  		/* cmpwi CR6, R10, 1 */
		/* 8224C0C4h case   27:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 8224C0C4h case   27:*/		return 0x8224C0C8;
		  /* 8224C0C8h */ case   28:  		/* stw R11, <#[R31 + 228]> */
		/* 8224C0C8h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8224C0C8h case   28:*/		return 0x8224C0CC;
		  /* 8224C0CCh */ case   29:  		/* bc 12, CR6_LT, 204 */
		/* 8224C0CCh case   29:*/		if ( regs.CR[6].lt ) { return 0x8224C198;  }
		/* 8224C0CCh case   29:*/		return 0x8224C0D0;
		  /* 8224C0D0h */ case   30:  		/* addi R28, R31, 232 */
		/* 8224C0D0h case   30:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0xE8);
		/* 8224C0D0h case   30:*/		return 0x8224C0D4;
		  /* 8224C0D4h */ case   31:  		/* lwzu R11, <#[R28 + 4]> */
		/* 8224C0D4h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		regs.R28 = (uint32)(regs.R28 + 0x00000004);
		/* 8224C0D4h case   31:*/		return 0x8224C0D8;
		  /* 8224C0D8h */ case   32:  		/* mr R4, R29 */
		/* 8224C0D8h case   32:*/		regs.R4 = regs.R29;
		/* 8224C0D8h case   32:*/		return 0x8224C0DC;
		  /* 8224C0DCh */ case   33:  		/* lwz R11, <#[R11 + 224]> */
		/* 8224C0DCh case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000E0) );
		/* 8224C0DCh case   33:*/		return 0x8224C0E0;
		  /* 8224C0E0h */ case   34:  		/* addi R3, R11, 1 */
		/* 8224C0E0h case   34:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1);
		/* 8224C0E0h case   34:*/		return 0x8224C0E4;
		  /* 8224C0E4h */ case   35:  		/* bl 109908 */
		/* 8224C0E4h case   35:*/		regs.LR = 0x8224C0E8; return 0x82266E38;
		/* 8224C0E4h case   35:*/		return 0x8224C0E8;
		  /* 8224C0E8h */ case   36:  		/* mr R4, R3 */
		/* 8224C0E8h case   36:*/		regs.R4 = regs.R3;
		/* 8224C0E8h case   36:*/		return 0x8224C0EC;
		  /* 8224C0ECh */ case   37:  		/* li R3, 0 */
		/* 8224C0ECh case   37:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224C0ECh case   37:*/		return 0x8224C0F0;
		  /* 8224C0F0h */ case   38:  		/* mr R5, R29 */
		/* 8224C0F0h case   38:*/		regs.R5 = regs.R29;
		/* 8224C0F0h case   38:*/		return 0x8224C0F4;
		  /* 8224C0F4h */ case   39:  		/* bl 109988 */
		/* 8224C0F4h case   39:*/		regs.LR = 0x8224C0F8; return 0x82266E98;
		/* 8224C0F4h case   39:*/		return 0x8224C0F8;
		  /* 8224C0F8h */ case   40:  		/* lwz R11, <#[R31 + 20]> */
		/* 8224C0F8h case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8224C0F8h case   40:*/		return 0x8224C0FC;
		  /* 8224C0FCh */ case   41:  		/* addi R30, R30, 1 */
		/* 8224C0FCh case   41:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8224C0FCh case   41:*/		return 0x8224C100;
		  /* 8224C100h */ case   42:  		/* cmpw CR6, R30, R11 */
		/* 8224C100h case   42:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R11);
		/* 8224C100h case   42:*/		return 0x8224C104;
		  /* 8224C104h */ case   43:  		/* bc 4, CR6_GT, -48 */
		/* 8224C104h case   43:*/		if ( !regs.CR[6].gt ) { return 0x8224C0D4;  }
		/* 8224C104h case   43:*/		return 0x8224C108;
		  /* 8224C108h */ case   44:  		/* b 144 */
		/* 8224C108h case   44:*/		return 0x8224C198;
		/* 8224C108h case   44:*/		return 0x8224C10C;
	}
	return 0x8224C10C;
} // Block from 8224C058h-8224C10Ch (45 instructions)

//////////////////////////////////////////////////////
// Block at 8224C10Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C10C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C10C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C10C);
		  /* 8224C10Ch */ case    0:  		/* lwz R11, <#[R31 + 24]> */
		/* 8224C10Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8224C10Ch case    0:*/		return 0x8224C110;
		  /* 8224C110h */ case    1:  		/* cmpwi CR6, R11, 50 */
		/* 8224C110h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000032);
		/* 8224C110h case    1:*/		return 0x8224C114;
		  /* 8224C114h */ case    2:  		/* bc 4, CR6_EQ, 40 */
		/* 8224C114h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224C13C;  }
		/* 8224C114h case    2:*/		return 0x8224C118;
		  /* 8224C118h */ case    3:  		/* lwz R11, <#[R31 + 224]> */
		/* 8224C118h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E0) );
		/* 8224C118h case    3:*/		return 0x8224C11C;
		  /* 8224C11Ch */ case    4:  		/* mr R4, R29 */
		/* 8224C11Ch case    4:*/		regs.R4 = regs.R29;
		/* 8224C11Ch case    4:*/		return 0x8224C120;
		  /* 8224C120h */ case    5:  		/* addi R3, R11, 1 */
		/* 8224C120h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1);
		/* 8224C120h case    5:*/		return 0x8224C124;
		  /* 8224C124h */ case    6:  		/* bl 109844 */
		/* 8224C124h case    6:*/		regs.LR = 0x8224C128; return 0x82266E38;
		/* 8224C124h case    6:*/		return 0x8224C128;
		  /* 8224C128h */ case    7:  		/* mr R4, R3 */
		/* 8224C128h case    7:*/		regs.R4 = regs.R3;
		/* 8224C128h case    7:*/		return 0x8224C12C;
		  /* 8224C12Ch */ case    8:  		/* li R3, 0 */
		/* 8224C12Ch case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224C12Ch case    8:*/		return 0x8224C130;
		  /* 8224C130h */ case    9:  		/* mr R5, R29 */
		/* 8224C130h case    9:*/		regs.R5 = regs.R29;
		/* 8224C130h case    9:*/		return 0x8224C134;
		  /* 8224C134h */ case   10:  		/* bl 109924 */
		/* 8224C134h case   10:*/		regs.LR = 0x8224C138; return 0x82266E98;
		/* 8224C134h case   10:*/		return 0x8224C138;
	}
	return 0x8224C138;
} // Block from 8224C10Ch-8224C138h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224C138h
// Function '?AddToHoldOrReadyList@Scheduler@XGRAPHICS@@AAAXPAVSchedNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C138);
		  /* 8224C138h */ case    0:  		/* b 96 */
		/* 8224C138h case    0:*/		return 0x8224C198;
		/* 8224C138h case    0:*/		return 0x8224C13C;
	}
	return 0x8224C13C;
} // Block from 8224C138h-8224C13Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224C13Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C13C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C13C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C13C);
		  /* 8224C13Ch */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 8224C13Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8224C13Ch case    0:*/		return 0x8224C140;
		  /* 8224C140h */ case    1:  		/* li R28, 1 */
		/* 8224C140h case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 8224C140h case    1:*/		return 0x8224C144;
		  /* 8224C144h */ case    2:  		/* cmpwi CR6, R11, 1 */
		/* 8224C144h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 8224C144h case    2:*/		return 0x8224C148;
		  /* 8224C148h */ case    3:  		/* bc 12, CR6_LT, 80 */
		/* 8224C148h case    3:*/		if ( regs.CR[6].lt ) { return 0x8224C198;  }
		/* 8224C148h case    3:*/		return 0x8224C14C;
		  /* 8224C14Ch */ case    4:  		/* addi R30, R31, 236 */
		/* 8224C14Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0xEC);
		/* 8224C14Ch case    4:*/		return 0x8224C150;
		  /* 8224C150h */ case    5:  		/* lwz R11, <#[R30]> */
		/* 8224C150h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8224C150h case    5:*/		return 0x8224C154;
		  /* 8224C154h */ case    6:  		/* lwz R10, <#[R31 + 948]> */
		/* 8224C154h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000003B4) );
		/* 8224C154h case    6:*/		return 0x8224C158;
		  /* 8224C158h */ case    7:  		/* lwz R9, <#[R11 + 948]> */
		/* 8224C158h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x000003B4) );
		/* 8224C158h case    7:*/		return 0x8224C15C;
		  /* 8224C15Ch */ case    8:  		/* cmpw CR6, R9, R10 */
		/* 8224C15Ch case    8:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R10);
		/* 8224C15Ch case    8:*/		return 0x8224C160;
		  /* 8224C160h */ case    9:  		/* bc 12, CR6_EQ, 36 */
		/* 8224C160h case    9:*/		if ( regs.CR[6].eq ) { return 0x8224C184;  }
		/* 8224C160h case    9:*/		return 0x8224C164;
		  /* 8224C164h */ case   10:  		/* lwz R11, <#[R11 + 224]> */
		/* 8224C164h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000E0) );
		/* 8224C164h case   10:*/		return 0x8224C168;
		  /* 8224C168h */ case   11:  		/* mr R4, R29 */
		/* 8224C168h case   11:*/		regs.R4 = regs.R29;
		/* 8224C168h case   11:*/		return 0x8224C16C;
		  /* 8224C16Ch */ case   12:  		/* addi R3, R11, 1 */
		/* 8224C16Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1);
		/* 8224C16Ch case   12:*/		return 0x8224C170;
		  /* 8224C170h */ case   13:  		/* bl 109768 */
		/* 8224C170h case   13:*/		regs.LR = 0x8224C174; return 0x82266E38;
		/* 8224C170h case   13:*/		return 0x8224C174;
		  /* 8224C174h */ case   14:  		/* mr R4, R3 */
		/* 8224C174h case   14:*/		regs.R4 = regs.R3;
		/* 8224C174h case   14:*/		return 0x8224C178;
		  /* 8224C178h */ case   15:  		/* li R3, 0 */
		/* 8224C178h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224C178h case   15:*/		return 0x8224C17C;
		  /* 8224C17Ch */ case   16:  		/* mr R5, R29 */
		/* 8224C17Ch case   16:*/		regs.R5 = regs.R29;
		/* 8224C17Ch case   16:*/		return 0x8224C180;
		  /* 8224C180h */ case   17:  		/* bl 109848 */
		/* 8224C180h case   17:*/		regs.LR = 0x8224C184; return 0x82266E98;
		/* 8224C180h case   17:*/		return 0x8224C184;
	}
	return 0x8224C184;
} // Block from 8224C13Ch-8224C184h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8224C184h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C184( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C184) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C184);
		  /* 8224C184h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 8224C184h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8224C184h case    0:*/		return 0x8224C188;
		  /* 8224C188h */ case    1:  		/* addi R28, R28, 1 */
		/* 8224C188h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8224C188h case    1:*/		return 0x8224C18C;
		  /* 8224C18Ch */ case    2:  		/* addi R30, R30, 4 */
		/* 8224C18Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8224C18Ch case    2:*/		return 0x8224C190;
		  /* 8224C190h */ case    3:  		/* cmpw CR6, R28, R11 */
		/* 8224C190h case    3:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R11);
		/* 8224C190h case    3:*/		return 0x8224C194;
		  /* 8224C194h */ case    4:  		/* bc 4, CR6_GT, -68 */
		/* 8224C194h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8224C150;  }
		/* 8224C194h case    4:*/		return 0x8224C198;
	}
	return 0x8224C198;
} // Block from 8224C184h-8224C198h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224C198h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C198);
		  /* 8224C198h */ case    0:  		/* lwz R11, <#[R31 + 228]> */
		/* 8224C198h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8224C198h case    0:*/		return 0x8224C19C;
		  /* 8224C19Ch */ case    1:  		/* mr R3, R31 */
		/* 8224C19Ch case    1:*/		regs.R3 = regs.R31;
		/* 8224C19Ch case    1:*/		return 0x8224C1A0;
		  /* 8224C1A0h */ case    2:  		/* rlwinm. R11, R11, 23, 31, 31 */
		/* 8224C1A0h case    2:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R11,regs.R11);
		/* 8224C1A0h case    2:*/		return 0x8224C1A4;
		  /* 8224C1A4h */ case    3:  		/* bc 12, CR0_EQ, 28 */
		/* 8224C1A4h case    3:*/		if ( regs.CR[0].eq ) { return 0x8224C1C0;  }
		/* 8224C1A4h case    3:*/		return 0x8224C1A8;
		  /* 8224C1A8h */ case    4:  		/* lwz R30, <#[R31 + 224]> */
		/* 8224C1A8h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x000000E0) );
		/* 8224C1A8h case    4:*/		return 0x8224C1AC;
		  /* 8224C1ACh */ case    5:  		/* bl -91124 */
		/* 8224C1ACh case    5:*/		regs.LR = 0x8224C1B0; return 0x82235DB8;
		/* 8224C1ACh case    5:*/		return 0x8224C1B0;
		  /* 8224C1B0h */ case    6:  		/* mr R11, R3 */
		/* 8224C1B0h case    6:*/		regs.R11 = regs.R3;
		/* 8224C1B0h case    6:*/		return 0x8224C1B4;
		  /* 8224C1B4h */ case    7:  		/* addi R3, R30, 1 */
		/* 8224C1B4h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x1);
		/* 8224C1B4h case    7:*/		return 0x8224C1B8;
		  /* 8224C1B8h */ case    8:  		/* lwz R28, <#[R11 + 224]> */
		/* 8224C1B8h case    8:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x000000E0) );
		/* 8224C1B8h case    8:*/		return 0x8224C1BC;
		  /* 8224C1BCh */ case    9:  		/* b 32 */
		/* 8224C1BCh case    9:*/		return 0x8224C1DC;
		/* 8224C1BCh case    9:*/		return 0x8224C1C0;
	}
	return 0x8224C1C0;
} // Block from 8224C198h-8224C1C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224C1C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C1C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C1C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C1C0);
		  /* 8224C1C0h */ case    0:  		/* bl -43720 */
		/* 8224C1C0h case    0:*/		regs.LR = 0x8224C1C4; return 0x822416F8;
		/* 8224C1C0h case    0:*/		return 0x8224C1C4;
		  /* 8224C1C4h */ case    1:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224C1C4h case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224C1C4h case    1:*/		return 0x8224C1C8;
		  /* 8224C1C8h */ case    2:  		/* bc 12, CR0_EQ, 76 */
		/* 8224C1C8h case    2:*/		if ( regs.CR[0].eq ) { return 0x8224C214;  }
		/* 8224C1C8h case    2:*/		return 0x8224C1CC;
		  /* 8224C1CCh */ case    3:  		/* lwz R10, <#[R31 + 236]> */
		/* 8224C1CCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000EC) );
		/* 8224C1CCh case    3:*/		return 0x8224C1D0;
		  /* 8224C1D0h */ case    4:  		/* lwz R11, <#[R31 + 224]> */
		/* 8224C1D0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E0) );
		/* 8224C1D0h case    4:*/		return 0x8224C1D4;
		  /* 8224C1D4h */ case    5:  		/* addi R3, R11, 1 */
		/* 8224C1D4h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1);
		/* 8224C1D4h case    5:*/		return 0x8224C1D8;
		  /* 8224C1D8h */ case    6:  		/* lwz R28, <#[R10 + 224]> */
		/* 8224C1D8h case    6:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + 0x000000E0) );
		/* 8224C1D8h case    6:*/		return 0x8224C1DC;
	}
	return 0x8224C1DC;
} // Block from 8224C1C0h-8224C1DCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224C1DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C1DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C1DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C1DC);
		  /* 8224C1DCh */ case    0:  		/* mr R4, R29 */
		/* 8224C1DCh case    0:*/		regs.R4 = regs.R29;
		/* 8224C1DCh case    0:*/		return 0x8224C1E0;
	}
	return 0x8224C1E0;
} // Block from 8224C1DCh-8224C1E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224C1E0h
// Function '?SelectReadyPartialWrite@Scheduler@XGRAPHICS@@AAAPAVSchedNode@2@AA_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C1E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C1E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C1E0);
		  /* 8224C1E0h */ case    0:  		/* bl 109656 */
		/* 8224C1E0h case    0:*/		regs.LR = 0x8224C1E4; return 0x82266E38;
		/* 8224C1E0h case    0:*/		return 0x8224C1E4;
		  /* 8224C1E4h */ case    1:  		/* mr R30, R3 */
		/* 8224C1E4h case    1:*/		regs.R30 = regs.R3;
		/* 8224C1E4h case    1:*/		return 0x8224C1E8;
		  /* 8224C1E8h */ case    2:  		/* mr R4, R29 */
		/* 8224C1E8h case    2:*/		regs.R4 = regs.R29;
		/* 8224C1E8h case    2:*/		return 0x8224C1EC;
		  /* 8224C1ECh */ case    3:  		/* addi R3, R28, 1 */
		/* 8224C1ECh case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R28,0x1);
		/* 8224C1ECh case    3:*/		return 0x8224C1F0;
		  /* 8224C1F0h */ case    4:  		/* bl 109640 */
		/* 8224C1F0h case    4:*/		regs.LR = 0x8224C1F4; return 0x82266E38;
		/* 8224C1F0h case    4:*/		return 0x8224C1F4;
		  /* 8224C1F4h */ case    5:  		/* mr R4, R3 */
		/* 8224C1F4h case    5:*/		regs.R4 = regs.R3;
		/* 8224C1F4h case    5:*/		return 0x8224C1F8;
		  /* 8224C1F8h */ case    6:  		/* cmpw CR6, R30, R3 */
		/* 8224C1F8h case    6:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R3);
		/* 8224C1F8h case    6:*/		return 0x8224C1FC;
		  /* 8224C1FCh */ case    7:  		/* bc 12, CR6_LT, 12 */
		/* 8224C1FCh case    7:*/		if ( regs.CR[6].lt ) { return 0x8224C208;  }
		/* 8224C1FCh case    7:*/		return 0x8224C200;
		  /* 8224C200h */ case    8:  		/* mr R4, R30 */
		/* 8224C200h case    8:*/		regs.R4 = regs.R30;
		/* 8224C200h case    8:*/		return 0x8224C204;
		  /* 8224C204h */ case    9:  		/* bc 4, CR6_LT, 8 */
		/* 8224C204h case    9:*/		if ( !regs.CR[6].lt ) { return 0x8224C20C;  }
		/* 8224C204h case    9:*/		return 0x8224C208;
	}
	return 0x8224C208;
} // Block from 8224C1E0h-8224C208h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224C208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C208);
		  /* 8224C208h */ case    0:  		/* mr R3, R30 */
		/* 8224C208h case    0:*/		regs.R3 = regs.R30;
		/* 8224C208h case    0:*/		return 0x8224C20C;
	}
	return 0x8224C20C;
} // Block from 8224C208h-8224C20Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224C20Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C20C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C20C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C20C);
		  /* 8224C20Ch */ case    0:  		/* mr R5, R29 */
		/* 8224C20Ch case    0:*/		regs.R5 = regs.R29;
		/* 8224C20Ch case    0:*/		return 0x8224C210;
		  /* 8224C210h */ case    1:  		/* bl 109704 */
		/* 8224C210h case    1:*/		regs.LR = 0x8224C214; return 0x82266E98;
		/* 8224C210h case    1:*/		return 0x8224C214;
	}
	return 0x8224C214;
} // Block from 8224C20Ch-8224C214h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224C214h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C214( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C214) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C214);
		  /* 8224C214h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 8224C214h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 8224C214h case    0:*/		return 0x8224C218;
	}
	return 0x8224C218;
} // Block from 8224C214h-8224C218h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224C218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C218);
		  /* 8224C218h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8224C218h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8224C218h case    0:*/		return 0x8224C21C;
		  /* 8224C21Ch */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224C21Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224C21Ch case    1:*/		return 0x8224C220;
		  /* 8224C220h */ case    2:  		/* bc 4, CR6_EQ, -436 */
		/* 8224C220h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224C06C;  }
		/* 8224C220h case    2:*/		return 0x8224C224;
		  /* 8224C224h */ case    3:  		/* lwz R27, <#[R27 + 8]> */
		/* 8224C224h case    3:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R27 + 0x00000008) );
		/* 8224C224h case    3:*/		return 0x8224C228;
	}
	return 0x8224C228;
} // Block from 8224C218h-8224C228h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224C228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C228);
		  /* 8224C228h */ case    0:  		/* lwz R11, <#[R27 + 8]> */
		/* 8224C228h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8224C228h case    0:*/		return 0x8224C22C;
		  /* 8224C22Ch */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224C22Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224C22Ch case    1:*/		return 0x8224C230;
		  /* 8224C230h */ case    2:  		/* bc 4, CR6_EQ, -460 */
		/* 8224C230h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224C064;  }
		/* 8224C230h case    2:*/		return 0x8224C234;
		  /* 8224C234h */ case    3:  		/* lwz R11, <#[R26 + 4]> */
		/* 8224C234h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 8224C234h case    3:*/		return 0x8224C238;
		  /* 8224C238h */ case    4:  		/* li R27, 0 */
		/* 8224C238h case    4:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8224C238h case    4:*/		return 0x8224C23C;
		  /* 8224C23Ch */ case    5:  		/* li R28, 0 */
		/* 8224C23Ch case    5:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8224C23Ch case    5:*/		return 0x8224C240;
		  /* 8224C240h */ case    6:  		/* lwz R30, <#[R11 + 136]> */
		/* 8224C240h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000088) );
		/* 8224C240h case    6:*/		return 0x8224C244;
		  /* 8224C244h */ case    7:  		/* b 96 */
		/* 8224C244h case    7:*/		return 0x8224C2A4;
		/* 8224C244h case    7:*/		return 0x8224C248;
		  /* 8224C248h */ case    8:  		/* lwz R31, <#[R30 + 28]> */
		/* 8224C248h case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x0000001C) );
		/* 8224C248h case    8:*/		return 0x8224C24C;
		  /* 8224C24Ch */ case    9:  		/* b 72 */
		/* 8224C24Ch case    9:*/		return 0x8224C294;
		/* 8224C24Ch case    9:*/		return 0x8224C250;
		  /* 8224C250h */ case   10:  		/* lwz R11, <#[R31 + 228]> */
		/* 8224C250h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8224C250h case   10:*/		return 0x8224C254;
		  /* 8224C254h */ case   11:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8224C254h case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8224C254h case   11:*/		return 0x8224C258;
		  /* 8224C258h */ case   12:  		/* bc 12, CR0_EQ, 56 */
		/* 8224C258h case   12:*/		if ( regs.CR[0].eq ) { return 0x8224C290;  }
		/* 8224C258h case   12:*/		return 0x8224C25C;
		  /* 8224C25Ch */ case   13:  		/* lwz R11, <#[R31 + 224]> */
		/* 8224C25Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E0) );
		/* 8224C25Ch case   13:*/		return 0x8224C260;
		  /* 8224C260h */ case   14:  		/* mr R4, R29 */
		/* 8224C260h case   14:*/		regs.R4 = regs.R29;
		/* 8224C260h case   14:*/		return 0x8224C264;
		  /* 8224C264h */ case   15:  		/* addi R3, R11, 1 */
		/* 8224C264h case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1);
		/* 8224C264h case   15:*/		return 0x8224C268;
		  /* 8224C268h */ case   16:  		/* bl 109520 */
		/* 8224C268h case   16:*/		regs.LR = 0x8224C26C; return 0x82266E38;
		/* 8224C268h case   16:*/		return 0x8224C26C;
		  /* 8224C26Ch */ case   17:  		/* lwz R11, <#[R31 + 228]> */
		/* 8224C26Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8224C26Ch case   17:*/		return 0x8224C270;
		  /* 8224C270h */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 8224C270h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8224C270h case   18:*/		return 0x8224C274;
		  /* 8224C274h */ case   19:  		/* bc 4, CR0_EQ, 16 */
		/* 8224C274h case   19:*/		if ( !regs.CR[0].eq ) { return 0x8224C284;  }
		/* 8224C274h case   19:*/		return 0x8224C278;
		  /* 8224C278h */ case   20:  		/* addi R28, R28, 1 */
		/* 8224C278h case   20:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8224C278h case   20:*/		return 0x8224C27C;
		  /* 8224C27Ch */ case   21:  		/* ori R11, R11, 32 */
		/* 8224C27Ch case   21:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 8224C27Ch case   21:*/		return 0x8224C280;
		  /* 8224C280h */ case   22:  		/* b 8 */
		/* 8224C280h case   22:*/		return 0x8224C288;
		/* 8224C280h case   22:*/		return 0x8224C284;
	}
	return 0x8224C284;
} // Block from 8224C228h-8224C284h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8224C284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C284);
		  /* 8224C284h */ case    0:  		/* rlwinm R11, R11, 0, 27, 25 */
		/* 8224C284h case    0:*/		cpu::op::rlwinm<0,0,27,25>(regs,&regs.R11,regs.R11);
		/* 8224C284h case    0:*/		return 0x8224C288;
	}
	return 0x8224C288;
} // Block from 8224C284h-8224C288h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224C288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C288);
		  /* 8224C288h */ case    0:  		/* stw R11, <#[R31 + 228]> */
		/* 8224C288h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8224C288h case    0:*/		return 0x8224C28C;
		  /* 8224C28Ch */ case    1:  		/* addi R27, R27, 1 */
		/* 8224C28Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8224C28Ch case    1:*/		return 0x8224C290;
	}
	return 0x8224C290;
} // Block from 8224C288h-8224C290h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224C290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C290);
		  /* 8224C290h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 8224C290h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 8224C290h case    0:*/		return 0x8224C294;
	}
	return 0x8224C294;
} // Block from 8224C290h-8224C294h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224C294h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C294( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C294) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C294);
		  /* 8224C294h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8224C294h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8224C294h case    0:*/		return 0x8224C298;
		  /* 8224C298h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224C298h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224C298h case    1:*/		return 0x8224C29C;
		  /* 8224C29Ch */ case    2:  		/* bc 4, CR6_EQ, -76 */
		/* 8224C29Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224C250;  }
		/* 8224C29Ch case    2:*/		return 0x8224C2A0;
		  /* 8224C2A0h */ case    3:  		/* lwz R30, <#[R30 + 8]> */
		/* 8224C2A0h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 8224C2A0h case    3:*/		return 0x8224C2A4;
	}
	return 0x8224C2A4;
} // Block from 8224C294h-8224C2A4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224C2A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C2A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C2A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C2A4);
		  /* 8224C2A4h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 8224C2A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8224C2A4h case    0:*/		return 0x8224C2A8;
		  /* 8224C2A8h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224C2A8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224C2A8h case    1:*/		return 0x8224C2AC;
		  /* 8224C2ACh */ case    2:  		/* bc 4, CR6_EQ, -100 */
		/* 8224C2ACh case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224C248;  }
		/* 8224C2ACh case    2:*/		return 0x8224C2B0;
		  /* 8224C2B0h */ case    3:  		/* lis R11, -32252 */
		/* 8224C2B0h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224C2B0h case    3:*/		return 0x8224C2B4;
		  /* 8224C2B4h */ case    4:  		/* lwz R3, <#[R26]> */
		/* 8224C2B4h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x00000000) );
		/* 8224C2B4h case    4:*/		return 0x8224C2B8;
		  /* 8224C2B8h */ case    5:  		/* mr R6, R27 */
		/* 8224C2B8h case    5:*/		regs.R6 = regs.R27;
		/* 8224C2B8h case    5:*/		return 0x8224C2BC;
		  /* 8224C2BCh */ case    6:  		/* addi R4, R11, 14960 */
		/* 8224C2BCh case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x3A70);
		/* 8224C2BCh case    6:*/		return 0x8224C2C0;
		  /* 8224C2C0h */ case    7:  		/* mr R5, R28 */
		/* 8224C2C0h case    7:*/		regs.R5 = regs.R28;
		/* 8224C2C0h case    7:*/		return 0x8224C2C4;
		  /* 8224C2C4h */ case    8:  		/* bl -192260 */
		/* 8224C2C4h case    8:*/		regs.LR = 0x8224C2C8; return 0x8221D3C0;
		/* 8224C2C4h case    8:*/		return 0x8224C2C8;
		  /* 8224C2C8h */ case    9:  		/* lwz R11, <#[R26]> */
		/* 8224C2C8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8224C2C8h case    9:*/		return 0x8224C2CC;
		  /* 8224C2CCh */ case   10:  		/* mr R4, R29 */
		/* 8224C2CCh case   10:*/		regs.R4 = regs.R29;
		/* 8224C2CCh case   10:*/		return 0x8224C2D0;
		  /* 8224C2D0h */ case   11:  		/* lwz R10, <#[R11 + 1436]> */
		/* 8224C2D0h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000059C) );
		/* 8224C2D0h case   11:*/		return 0x8224C2D4;
		  /* 8224C2D4h */ case   12:  		/* lwz R3, <#[R11 + 1444]> */
		/* 8224C2D4h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005A4) );
		/* 8224C2D4h case   12:*/		return 0x8224C2D8;
		  /* 8224C2D8h */ case   13:  		/* mtspr CTR, R10 */
		/* 8224C2D8h case   13:*/		regs.CTR = regs.R10;
		/* 8224C2D8h case   13:*/		return 0x8224C2DC;
		  /* 8224C2DCh */ case   14:  		/* bcctrl 20, CR0_LT */
		/* 8224C2DCh case   14:*/		if ( 1 ) { regs.LR = 0x8224C2E0; return (uint32)regs.CTR; }
		/* 8224C2DCh case   14:*/		return 0x8224C2E0;
	}
	return 0x8224C2E0;
} // Block from 8224C2A4h-8224C2E0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8224C2E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C2E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C2E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C2E0);
		  /* 8224C2E0h */ case    0:  		/* addi R1, R1, 144 */
		/* 8224C2E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8224C2E0h case    0:*/		return 0x8224C2E4;
		  /* 8224C2E4h */ case    1:  		/* b -1814596 */
		/* 8224C2E4h case    1:*/		return 0x820912A0;
		/* 8224C2E4h case    1:*/		return 0x8224C2E8;
	}
	return 0x8224C2E8;
} // Block from 8224C2E0h-8224C2E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224C2E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C2E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C2E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C2E8);
		  /* 8224C2E8h */ case    0:  		/* mfspr R12, LR */
		/* 8224C2E8h case    0:*/		regs.R12 = regs.LR;
		/* 8224C2E8h case    0:*/		return 0x8224C2EC;
		  /* 8224C2ECh */ case    1:  		/* bl -1814696 */
		/* 8224C2ECh case    1:*/		regs.LR = 0x8224C2F0; return 0x82091244;
		/* 8224C2ECh case    1:*/		return 0x8224C2F0;
		  /* 8224C2F0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 8224C2F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 8224C2F0h case    2:*/		return 0x8224C2F4;
		  /* 8224C2F4h */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224C2F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224C2F4h case    3:*/		return 0x8224C2F8;
		  /* 8224C2F8h */ case    4:  		/* mr R23, R3 */
		/* 8224C2F8h case    4:*/		regs.R23 = regs.R3;
		/* 8224C2F8h case    4:*/		return 0x8224C2FC;
		  /* 8224C2FCh */ case    5:  		/* li R24, 1 */
		/* 8224C2FCh case    5:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 8224C2FCh case    5:*/		return 0x8224C300;
		  /* 8224C300h */ case    6:  		/* lwz R10, <#[R11 + 12]> */
		/* 8224C300h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8224C300h case    6:*/		return 0x8224C304;
		  /* 8224C304h */ case    7:  		/* lwz R31, <#[R11 + 136]> */
		/* 8224C304h case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000088) );
		/* 8224C304h case    7:*/		return 0x8224C308;
		  /* 8224C308h */ case    8:  		/* lwz R11, <#[R10 + 1360]> */
		/* 8224C308h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000550) );
		/* 8224C308h case    8:*/		return 0x8224C30C;
		  /* 8224C30Ch */ case    9:  		/* lwz R10, <#[R31 + 8]> */
		/* 8224C30Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8224C30Ch case    9:*/		return 0x8224C310;
		  /* 8224C310h */ case   10:  		/* cmpwi CR6, R10, 0 */
		/* 8224C310h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8224C310h case   10:*/		return 0x8224C314;
		  /* 8224C314h */ case   11:  		/* lwz R25, <#[R11 + 4]> */
		/* 8224C314h case   11:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R11 + 0x00000004) );
		/* 8224C314h case   11:*/		return 0x8224C318;
		  /* 8224C318h */ case   12:  		/* bc 12, CR6_EQ, 308 */
		/* 8224C318h case   12:*/		if ( regs.CR[6].eq ) { return 0x8224C44C;  }
		/* 8224C318h case   12:*/		return 0x8224C31C;
		  /* 8224C31Ch */ case   13:  		/* lwz R11, <#[R23]> */
		/* 8224C31Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8224C31Ch case   13:*/		return 0x8224C320;
		  /* 8224C320h */ case   14:  		/* mr R3, R25 */
		/* 8224C320h case   14:*/		regs.R3 = regs.R25;
		/* 8224C320h case   14:*/		return 0x8224C324;
		  /* 8224C324h */ case   15:  		/* lwz R4, <#[R11 + 1456]> */
		/* 8224C324h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224C324h case   15:*/		return 0x8224C328;
		  /* 8224C328h */ case   16:  		/* bl -88552 */
		/* 8224C328h case   16:*/		regs.LR = 0x8224C32C; return 0x82236940;
		/* 8224C328h case   16:*/		return 0x8224C32C;
		  /* 8224C32Ch */ case   17:  		/* stw R3, <#[R31 + 104]> */
		/* 8224C32Ch case   17:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000068) );
		/* 8224C32Ch case   17:*/		return 0x8224C330;
	}
	return 0x8224C330;
} // Block from 8224C2E8h-8224C330h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8224C330h
// Function '?DefIsLocalTemp@IRInst@XGRAPHICS@@QBA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C330);
		  /* 8224C330h */ case    0:  		/* mr R3, R25 */
		/* 8224C330h case    0:*/		regs.R3 = regs.R25;
		/* 8224C330h case    0:*/		return 0x8224C334;
		  /* 8224C334h */ case    1:  		/* lwz R11, <#[R23]> */
		/* 8224C334h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8224C334h case    1:*/		return 0x8224C338;
		  /* 8224C338h */ case    2:  		/* lwz R4, <#[R11 + 1456]> */
		/* 8224C338h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224C338h case    2:*/		return 0x8224C33C;
		  /* 8224C33Ch */ case    3:  		/* bl -88572 */
		/* 8224C33Ch case    3:*/		regs.LR = 0x8224C340; return 0x82236940;
		/* 8224C33Ch case    3:*/		return 0x8224C340;
		  /* 8224C340h */ case    4:  		/* lwz R29, <#[R31 + 28]> */
		/* 8224C340h case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x0000001C) );
		/* 8224C340h case    4:*/		return 0x8224C344;
		  /* 8224C344h */ case    5:  		/* stw R3, <#[R31 + 100]> */
		/* 8224C344h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000064) );
		/* 8224C344h case    5:*/		return 0x8224C348;
		  /* 8224C348h */ case    6:  		/* b 232 */
		/* 8224C348h case    6:*/		return 0x8224C430;
		/* 8224C348h case    6:*/		return 0x8224C34C;
		  /* 8224C34Ch */ case    7:  		/* lwz R11, <#[R29 + 228]> */
		/* 8224C34Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000000E4) );
		/* 8224C34Ch case    7:*/		return 0x8224C350;
		  /* 8224C350h */ case    8:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8224C350h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8224C350h case    8:*/		return 0x8224C354;
		  /* 8224C354h */ case    9:  		/* bc 12, CR0_EQ, 216 */
		/* 8224C354h case    9:*/		if ( regs.CR[0].eq ) { return 0x8224C42C;  }
		/* 8224C354h case    9:*/		return 0x8224C358;
		  /* 8224C358h */ case   10:  		/* lwz R11, <#[R29 + 20]> */
		/* 8224C358h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000014) );
		/* 8224C358h case   10:*/		return 0x8224C35C;
		  /* 8224C35Ch */ case   11:  		/* mr R27, R24 */
		/* 8224C35Ch case   11:*/		regs.R27 = regs.R24;
		/* 8224C35Ch case   11:*/		return 0x8224C360;
		  /* 8224C360h */ case   12:  		/* cmpwi CR6, R11, 1 */
		/* 8224C360h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 8224C360h case   12:*/		return 0x8224C364;
		  /* 8224C364h */ case   13:  		/* bc 12, CR6_LT, 200 */
		/* 8224C364h case   13:*/		if ( regs.CR[6].lt ) { return 0x8224C42C;  }
		/* 8224C364h case   13:*/		return 0x8224C368;
		  /* 8224C368h */ case   14:  		/* li R28, 0 */
		/* 8224C368h case   14:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8224C368h case   14:*/		return 0x8224C36C;
		  /* 8224C36Ch */ case   15:  		/* addi R26, R29, 236 */
		/* 8224C36Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R29,0xEC);
		/* 8224C36Ch case   15:*/		return 0x8224C370;
		  /* 8224C370h */ case   16:  		/* lwz R30, <#[R26]> */
		/* 8224C370h case   16:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x00000000) );
		/* 8224C370h case   16:*/		return 0x8224C374;
		  /* 8224C374h */ case   17:  		/* lwz R11, <#[R30 + 228]> */
		/* 8224C374h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000E4) );
		/* 8224C374h case   17:*/		return 0x8224C378;
		  /* 8224C378h */ case   18:  		/* rlwinm. R11, R11, 26, 31, 31 */
		/* 8224C378h case   18:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R11,regs.R11);
		/* 8224C378h case   18:*/		return 0x8224C37C;
		  /* 8224C37Ch */ case   19:  		/* bc 12, CR0_EQ, 152 */
		/* 8224C37Ch case   19:*/		if ( regs.CR[0].eq ) { return 0x8224C414;  }
		/* 8224C37Ch case   19:*/		return 0x8224C380;
		  /* 8224C380h */ case   20:  		/* lwz R11, <#[R29]> */
		/* 8224C380h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8224C380h case   20:*/		return 0x8224C384;
		  /* 8224C384h */ case   21:  		/* mr R3, R29 */
		/* 8224C384h case   21:*/		regs.R3 = regs.R29;
		/* 8224C384h case   21:*/		return 0x8224C388;
		  /* 8224C388h */ case   22:  		/* lwz R11, <#[R11 + 44]> */
		/* 8224C388h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 8224C388h case   22:*/		return 0x8224C38C;
		  /* 8224C38Ch */ case   23:  		/* mtspr CTR, R11 */
		/* 8224C38Ch case   23:*/		regs.CTR = regs.R11;
		/* 8224C38Ch case   23:*/		return 0x8224C390;
		  /* 8224C390h */ case   24:  		/* bcctrl 20, CR0_LT */
		/* 8224C390h case   24:*/		if ( 1 ) { regs.LR = 0x8224C394; return (uint32)regs.CTR; }
		/* 8224C390h case   24:*/		return 0x8224C394;
		  /* 8224C394h */ case   25:  		/* cmplwi CR0, R3, 0 */
		/* 8224C394h case   25:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8224C394h case   25:*/		return 0x8224C398;
	}
	return 0x8224C398;
} // Block from 8224C330h-8224C398h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8224C398h
// Function 'XShaderPDBBuilder_AddRef'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C398);
		  /* 8224C398h */ case    0:  		/* bc 12, CR0_EQ, 84 */
		/* 8224C398h case    0:*/		if ( regs.CR[0].eq ) { return 0x8224C3EC;  }
		/* 8224C398h case    0:*/		return 0x8224C39C;
		  /* 8224C39Ch */ case    1:  		/* lwz R11, <#[R31 + 60]> */
		/* 8224C39Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 8224C39Ch case    1:*/		return 0x8224C3A0;
		  /* 8224C3A0h */ case    2:  		/* addi R10, R27, -1 */
		/* 8224C3A0h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0xFFFFFFFF);
		/* 8224C3A0h case    2:*/		return 0x8224C3A4;
		  /* 8224C3A4h */ case    3:  		/* lwz R9, <#[R11 + 4]> */
		/* 8224C3A4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8224C3A4h case    3:*/		return 0x8224C3A8;
	}
	return 0x8224C3A8;
} // Block from 8224C398h-8224C3A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224C3A8h
// Function '?ZeroState@ResourceModel@XGRAPHICS@@UAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C3A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C3A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C3A8);
		  /* 8224C3A8h */ case    0:  		/* cmplw CR6, R10, R9 */
		/* 8224C3A8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8224C3A8h case    0:*/		return 0x8224C3AC;
		  /* 8224C3ACh */ case    1:  		/* bc 4, CR6_LT, 16 */
		/* 8224C3ACh case    1:*/		if ( !regs.CR[6].lt ) { return 0x8224C3BC;  }
		/* 8224C3ACh case    1:*/		return 0x8224C3B0;
		  /* 8224C3B0h */ case    2:  		/* lwz R11, <#[R11 + 8]> */
		/* 8224C3B0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8224C3B0h case    2:*/		return 0x8224C3B4;
		  /* 8224C3B4h */ case    3:  		/* add R11, R11, R28 */
		/* 8224C3B4h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 8224C3B4h case    3:*/		return 0x8224C3B8;
	}
	return 0x8224C3B8;
} // Block from 8224C3A8h-8224C3B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224C3B8h
// Function '?AdvanceCycle@R400SlotModel@XGRAPHICS@@UAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C3B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C3B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C3B8);
		  /* 8224C3B8h */ case    0:  		/* b 8 */
		/* 8224C3B8h case    0:*/		return 0x8224C3C0;
		/* 8224C3B8h case    0:*/		return 0x8224C3BC;
	}
	return 0x8224C3BC;
} // Block from 8224C3B8h-8224C3BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224C3BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C3BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C3BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C3BC);
		  /* 8224C3BCh */ case    0:  		/* li R11, 0 */
		/* 8224C3BCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224C3BCh case    0:*/		return 0x8224C3C0;
	}
	return 0x8224C3C0;
} // Block from 8224C3BCh-8224C3C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224C3C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C3C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C3C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C3C0);
		  /* 8224C3C0h */ case    0:  		/* lwz R10, <#[R30 + 56]> */
		/* 8224C3C0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000038) );
		/* 8224C3C0h case    0:*/		return 0x8224C3C4;
		  /* 8224C3C4h */ case    1:  		/* lwz R9, <#[R11]> */
		/* 8224C3C4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8224C3C4h case    1:*/		return 0x8224C3C8;
		  /* 8224C3C8h */ case    2:  		/* rlwinm R11, R10, 27, 5, 31 */
		/* 8224C3C8h case    2:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R10);
		/* 8224C3C8h case    2:*/		return 0x8224C3CC;
		  /* 8224C3CCh */ case    3:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 8224C3CCh case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 8224C3CCh case    3:*/		return 0x8224C3D0;
		  /* 8224C3D0h */ case    4:  		/* addi R8, R11, 2 */
		/* 8224C3D0h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x2);
		/* 8224C3D0h case    4:*/		return 0x8224C3D4;
		  /* 8224C3D4h */ case    5:  		/* slw R7, R24, R10 */
		/* 8224C3D4h case    5:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R24,regs.R10);
		/* 8224C3D4h case    5:*/		return 0x8224C3D8;
	}
	return 0x8224C3D8;
} // Block from 8224C3C0h-8224C3D8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224C3D8h
// Function '?FullState@R400SlotModel@XGRAPHICS@@UAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C3D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C3D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C3D8);
		  /* 8224C3D8h */ case    0:  		/* lwz R11, <#[R9 + 100]> */
		/* 8224C3D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000064) );
		/* 8224C3D8h case    0:*/		return 0x8224C3DC;
		  /* 8224C3DCh */ case    1:  		/* rlwinm R10, R8, 2, 0, 29 */
		/* 8224C3DCh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R8);
		/* 8224C3DCh case    1:*/		return 0x8224C3E0;
		  /* 8224C3E0h */ case    2:  		/* lwzx R9, <#[R10 + R11]> */
		/* 8224C3E0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8224C3E0h case    2:*/		return 0x8224C3E4;
		  /* 8224C3E4h */ case    3:  		/* or R9, R7, R9 */
		/* 8224C3E4h case    3:*/		cpu::op::or<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 8224C3E4h case    3:*/		return 0x8224C3E8;
		  /* 8224C3E8h */ case    4:  		/* b 40 */
		/* 8224C3E8h case    4:*/		return 0x8224C410;
		/* 8224C3E8h case    4:*/		return 0x8224C3EC;
	}
	return 0x8224C3EC;
} // Block from 8224C3D8h-8224C3ECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224C3ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C3EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C3EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C3EC);
		  /* 8224C3ECh */ case    0:  		/* lwz R9, <#[R30 + 56]> */
		/* 8224C3ECh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000038) );
		/* 8224C3ECh case    0:*/		return 0x8224C3F0;
	}
	return 0x8224C3F0;
} // Block from 8224C3ECh-8224C3F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224C3F0h
// Function '?HasRoomForVector@R400SlotModel@XGRAPHICS@@UAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C3F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C3F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C3F0);
		  /* 8224C3F0h */ case    0:  		/* lwz R11, <#[R31 + 100]> */
		/* 8224C3F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000064) );
		/* 8224C3F0h case    0:*/		return 0x8224C3F4;
		  /* 8224C3F4h */ case    1:  		/* rlwinm R10, R9, 27, 5, 31 */
		/* 8224C3F4h case    1:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R9);
		/* 8224C3F4h case    1:*/		return 0x8224C3F8;
		  /* 8224C3F8h */ case    2:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8224C3F8h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8224C3F8h case    2:*/		return 0x8224C3FC;
		  /* 8224C3FCh */ case    3:  		/* addi R10, R10, 2 */
		/* 8224C3FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 8224C3FCh case    3:*/		return 0x8224C400;
		  /* 8224C400h */ case    4:  		/* slw R9, R24, R9 */
		/* 8224C400h case    4:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R24,regs.R9);
		/* 8224C400h case    4:*/		return 0x8224C404;
		  /* 8224C404h */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8224C404h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8224C404h case    5:*/		return 0x8224C408;
		  /* 8224C408h */ case    6:  		/* lwzx R8, <#[R10 + R11]> */
		/* 8224C408h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8224C408h case    6:*/		return 0x8224C40C;
		  /* 8224C40Ch */ case    7:  		/* or R9, R9, R8 */
		/* 8224C40Ch case    7:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8224C40Ch case    7:*/		return 0x8224C410;
	}
	return 0x8224C410;
} // Block from 8224C3F0h-8224C410h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224C410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C410);
		  /* 8224C410h */ case    0:  		/* stwx R9, <#[R10 + R11]> */
		/* 8224C410h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8224C410h case    0:*/		return 0x8224C414;
	}
	return 0x8224C414;
} // Block from 8224C410h-8224C414h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224C414h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C414);
		  /* 8224C414h */ case    0:  		/* lwz R11, <#[R29 + 20]> */
		/* 8224C414h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000014) );
		/* 8224C414h case    0:*/		return 0x8224C418;
	}
	return 0x8224C418;
} // Block from 8224C414h-8224C418h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224C418h
// Function '?HasRoomForScalar@R400SlotModel@XGRAPHICS@@UAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C418);
		  /* 8224C418h */ case    0:  		/* addi R27, R27, 1 */
		/* 8224C418h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8224C418h case    0:*/		return 0x8224C41C;
		  /* 8224C41Ch */ case    1:  		/* addi R26, R26, 4 */
		/* 8224C41Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 8224C41Ch case    1:*/		return 0x8224C420;
		  /* 8224C420h */ case    2:  		/* addi R28, R28, 4 */
		/* 8224C420h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 8224C420h case    2:*/		return 0x8224C424;
		  /* 8224C424h */ case    3:  		/* cmpw CR6, R27, R11 */
		/* 8224C424h case    3:*/		cpu::op::cmpw<6>(regs,regs.R27,regs.R11);
		/* 8224C424h case    3:*/		return 0x8224C428;
		  /* 8224C428h */ case    4:  		/* bc 4, CR6_GT, -184 */
		/* 8224C428h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8224C370;  }
		/* 8224C428h case    4:*/		return 0x8224C42C;
	}
	return 0x8224C42C;
} // Block from 8224C418h-8224C42Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224C42Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C42C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C42C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C42C);
		  /* 8224C42Ch */ case    0:  		/* lwz R29, <#[R29 + 8]> */
		/* 8224C42Ch case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000008) );
		/* 8224C42Ch case    0:*/		return 0x8224C430;
	}
	return 0x8224C430;
} // Block from 8224C42Ch-8224C430h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224C430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C430);
		  /* 8224C430h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 8224C430h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8224C430h case    0:*/		return 0x8224C434;
		  /* 8224C434h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224C434h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224C434h case    1:*/		return 0x8224C438;
		  /* 8224C438h */ case    2:  		/* bc 4, CR6_EQ, -236 */
		/* 8224C438h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224C34C;  }
		/* 8224C438h case    2:*/		return 0x8224C43C;
		  /* 8224C43Ch */ case    3:  		/* lwz R31, <#[R31 + 8]> */
		/* 8224C43Ch case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 8224C43Ch case    3:*/		return 0x8224C440;
	}
	return 0x8224C440;
} // Block from 8224C430h-8224C440h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224C440h
// Function '??0R400SchedModel@XGRAPHICS@@QAA@PBVArena@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C440);
		  /* 8224C440h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8224C440h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8224C440h case    0:*/		return 0x8224C444;
		  /* 8224C444h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224C444h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224C444h case    1:*/		return 0x8224C448;
		  /* 8224C448h */ case    2:  		/* bc 4, CR6_EQ, -300 */
		/* 8224C448h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224C31C;  }
		/* 8224C448h case    2:*/		return 0x8224C44C;
	}
	return 0x8224C44C;
} // Block from 8224C440h-8224C44Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224C44Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C44C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C44C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C44C);
		  /* 8224C44Ch */ case    0:  		/* lwz R3, <#[R23 + 4]> */
		/* 8224C44Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000004) );
		/* 8224C44Ch case    0:*/		return 0x8224C450;
		  /* 8224C450h */ case    1:  		/* bl -76432 */
		/* 8224C450h case    1:*/		regs.LR = 0x8224C454; return 0x822399C0;
		/* 8224C450h case    1:*/		return 0x8224C454;
		  /* 8224C454h */ case    2:  		/* mr R27, R3 */
		/* 8224C454h case    2:*/		regs.R27 = regs.R3;
		/* 8224C454h case    2:*/		return 0x8224C458;
		  /* 8224C458h */ case    3:  		/* lwz R11, <#[R23 + 4]> */
		/* 8224C458h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 8224C458h case    3:*/		return 0x8224C45C;
		  /* 8224C45Ch */ case    4:  		/* li R29, 0 */
		/* 8224C45Ch case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8224C45Ch case    4:*/		return 0x8224C460;
		  /* 8224C460h */ case    5:  		/* mr R30, R24 */
		/* 8224C460h case    5:*/		regs.R30 = regs.R24;
		/* 8224C460h case    5:*/		return 0x8224C464;
		  /* 8224C464h */ case    6:  		/* addi R3, R11, 128 */
		/* 8224C464h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x80);
		/* 8224C464h case    6:*/		return 0x8224C468;
		  /* 8224C468h */ case    7:  		/* bl 29688 */
		/* 8224C468h case    7:*/		regs.LR = 0x8224C46C; return 0x82253860;
		/* 8224C468h case    7:*/		return 0x8224C46C;
		  /* 8224C46Ch */ case    8:  		/* cmpwi CR6, R3, 1 */
		/* 8224C46Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8224C46Ch case    8:*/		return 0x8224C470;
		  /* 8224C470h */ case    9:  		/* bc 12, CR6_LT, 464 */
		/* 8224C470h case    9:*/		if ( regs.CR[6].lt ) { return 0x8224C640;  }
		/* 8224C470h case    9:*/		return 0x8224C474;
		  /* 8224C474h */ case   10:  		/* addi R28, R27, 4 */
		/* 8224C474h case   10:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R27,0x4);
		/* 8224C474h case   10:*/		return 0x8224C478;
		  /* 8224C478h */ case   11:  		/* lwz R31, <#[R28]> */
		/* 8224C478h case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x00000000) );
		/* 8224C478h case   11:*/		return 0x8224C47C;
		  /* 8224C47Ch */ case   12:  		/* mr R3, R31 */
		/* 8224C47Ch case   12:*/		regs.R3 = regs.R31;
		/* 8224C47Ch case   12:*/		return 0x8224C480;
		  /* 8224C480h */ case   13:  		/* lwz R11, <#[R31]> */
		/* 8224C480h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224C480h case   13:*/		return 0x8224C484;
		  /* 8224C484h */ case   14:  		/* lwz R11, <#[R11 + 8]> */
		/* 8224C484h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8224C484h case   14:*/		return 0x8224C488;
		  /* 8224C488h */ case   15:  		/* mtspr CTR, R11 */
		/* 8224C488h case   15:*/		regs.CTR = regs.R11;
		/* 8224C488h case   15:*/		return 0x8224C48C;
		  /* 8224C48Ch */ case   16:  		/* bcctrl 20, CR0_LT */
		/* 8224C48Ch case   16:*/		if ( 1 ) { regs.LR = 0x8224C490; return (uint32)regs.CTR; }
		/* 8224C48Ch case   16:*/		return 0x8224C490;
		  /* 8224C490h */ case   17:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224C490h case   17:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224C490h case   17:*/		return 0x8224C494;
		  /* 8224C494h */ case   18:  		/* bc 4, CR0_EQ, 400 */
		/* 8224C494h case   18:*/		if ( !regs.CR[0].eq ) { return 0x8224C624;  }
		/* 8224C494h case   18:*/		return 0x8224C498;
		  /* 8224C498h */ case   19:  		/* lwz R10, <#[R31 + 104]> */
		/* 8224C498h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000068) );
		/* 8224C498h case   19:*/		return 0x8224C49C;
		  /* 8224C49Ch */ case   20:  		/* li R11, 0 */
		/* 8224C49Ch case   20:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224C49Ch case   20:*/		return 0x8224C4A0;
		  /* 8224C4A0h */ case   21:  		/* lwz R9, <#[R10]> */
		/* 8224C4A0h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8224C4A0h case   21:*/		return 0x8224C4A4;
		  /* 8224C4A4h */ case   22:  		/* cmplwi CR6, R9, 0 */
		/* 8224C4A4h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8224C4A4h case   22:*/		return 0x8224C4A8;
		  /* 8224C4A8h */ case   23:  		/* bc 4, CR6_GT, 32 */
		/* 8224C4A8h case   23:*/		if ( !regs.CR[6].gt ) { return 0x8224C4C8;  }
		/* 8224C4A8h case   23:*/		return 0x8224C4AC;
		  /* 8224C4ACh */ case   24:  		/* addi R9, R10, 4 */
		/* 8224C4ACh case   24:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 8224C4ACh case   24:*/		return 0x8224C4B0;
		  /* 8224C4B0h */ case   25:  		/* li R8, 0 */
		/* 8224C4B0h case   25:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8224C4B0h case   25:*/		return 0x8224C4B4;
		  /* 8224C4B4h */ case   26:  		/* addi R11, R11, 1 */
		/* 8224C4B4h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224C4B4h case   26:*/		return 0x8224C4B8;
		  /* 8224C4B8h */ case   27:  		/* stwu R8, <#[R9 + 4]> */
		/* 8224C4B8h case   27:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 8224C4B8h case   27:*/		return 0x8224C4BC;
		  /* 8224C4BCh */ case   28:  		/* lwz R8, <#[R10]> */
		/* 8224C4BCh case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8224C4BCh case   28:*/		return 0x8224C4C0;
		  /* 8224C4C0h */ case   29:  		/* cmplw CR6, R11, R8 */
		/* 8224C4C0h case   29:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8224C4C0h case   29:*/		return 0x8224C4C4;
		  /* 8224C4C4h */ case   30:  		/* bc 12, CR6_LT, -20 */
		/* 8224C4C4h case   30:*/		if ( regs.CR[6].lt ) { return 0x8224C4B0;  }
		/* 8224C4C4h case   30:*/		return 0x8224C4C8;
	}
	return 0x8224C4C8;
} // Block from 8224C44Ch-8224C4C8h (31 instructions)

//////////////////////////////////////////////////////
// Block at 8224C4C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C4C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C4C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C4C8);
		  /* 8224C4C8h */ case    0:  		/* mr R6, R24 */
		/* 8224C4C8h case    0:*/		regs.R6 = regs.R24;
		/* 8224C4C8h case    0:*/		return 0x8224C4CC;
		  /* 8224C4CCh */ case    1:  		/* li R7, 0 */
		/* 8224C4CCh case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8224C4CCh case    1:*/		return 0x8224C4D0;
		  /* 8224C4D0h */ case    2:  		/* li R5, 0 */
		/* 8224C4D0h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8224C4D0h case    2:*/		return 0x8224C4D4;
		  /* 8224C4D4h */ case    3:  		/* mr R4, R24 */
		/* 8224C4D4h case    3:*/		regs.R4 = regs.R24;
		/* 8224C4D4h case    3:*/		return 0x8224C4D8;
		  /* 8224C4D8h */ case    4:  		/* lwz R11, <#[R31 + 56]> */
		/* 8224C4D8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 8224C4D8h case    4:*/		return 0x8224C4DC;
		  /* 8224C4DCh */ case    5:  		/* lwz R10, <#[R11 + 4]> */
		/* 8224C4DCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8224C4DCh case    5:*/		return 0x8224C4E0;
		  /* 8224C4E0h */ case    6:  		/* cmplw CR6, R4, R10 */
		/* 8224C4E0h case    6:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 8224C4E0h case    6:*/		return 0x8224C4E4;
		  /* 8224C4E4h */ case    7:  		/* bc 4, CR6_GT, 12 */
		/* 8224C4E4h case    7:*/		if ( !regs.CR[6].gt ) { return 0x8224C4F0;  }
		/* 8224C4E4h case    7:*/		return 0x8224C4E8;
		  /* 8224C4E8h */ case    8:  		/* li R11, 0 */
		/* 8224C4E8h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224C4E8h case    8:*/		return 0x8224C4EC;
		  /* 8224C4ECh */ case    9:  		/* b 16 */
		/* 8224C4ECh case    9:*/		return 0x8224C4FC;
		/* 8224C4ECh case    9:*/		return 0x8224C4F0;
	}
	return 0x8224C4F0;
} // Block from 8224C4C8h-8224C4F0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224C4F0h
// Function '?Check@R400SchedModel@XGRAPHICS@@UAA_NPBVIRInst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C4F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C4F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C4F0);
		  /* 8224C4F0h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 8224C4F0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8224C4F0h case    0:*/		return 0x8224C4F4;
		  /* 8224C4F4h */ case    1:  		/* mr R11, R24 */
		/* 8224C4F4h case    1:*/		regs.R11 = regs.R24;
		/* 8224C4F4h case    1:*/		return 0x8224C4F8;
		  /* 8224C4F8h */ case    2:  		/* lwzx R7, <#[R10 + R5]> */
		/* 8224C4F8h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 8224C4F8h case    2:*/		return 0x8224C4FC;
	}
	return 0x8224C4FC;
} // Block from 8224C4F0h-8224C4FCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224C4FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C4FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C4FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C4FC);
		  /* 8224C4FCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8224C4FCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8224C4FCh case    0:*/		return 0x8224C500;
		  /* 8224C500h */ case    1:  		/* li R9, 0 */
		/* 8224C500h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8224C500h case    1:*/		return 0x8224C504;
		  /* 8224C504h */ case    2:  		/* bc 12, CR0_EQ, 148 */
		/* 8224C504h case    2:*/		if ( regs.CR[0].eq ) { return 0x8224C598;  }
		/* 8224C504h case    2:*/		return 0x8224C508;
		  /* 8224C508h */ case    3:  		/* lwz R8, <#[R7 + 100]> */
		/* 8224C508h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + 0x00000064) );
		/* 8224C508h case    3:*/		return 0x8224C50C;
		  /* 8224C50Ch */ case    4:  		/* rlwinm. R11, R6, 0, 24, 31 */
		/* 8224C50Ch case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R6);
		/* 8224C50Ch case    4:*/		return 0x8224C510;
		  /* 8224C510h */ case    5:  		/* bc 12, CR0_EQ, 64 */
		/* 8224C510h case    5:*/		if ( regs.CR[0].eq ) { return 0x8224C550;  }
		/* 8224C510h case    5:*/		return 0x8224C514;
		  /* 8224C514h */ case    6:  		/* lwz R11, <#[R31 + 104]> */
		/* 8224C514h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 8224C514h case    6:*/		return 0x8224C518;
		  /* 8224C518h */ case    7:  		/* lwz R10, <#[R11]> */
		/* 8224C518h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8224C518h case    7:*/		return 0x8224C51C;
		  /* 8224C51Ch */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 8224C51Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8224C51Ch case    8:*/		return 0x8224C520;
		  /* 8224C520h */ case    9:  		/* bc 4, CR6_GT, 40 */
		/* 8224C520h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8224C548;  }
		/* 8224C520h case    9:*/		return 0x8224C524;
		  /* 8224C524h */ case   10:  		/* addi R10, R11, 8 */
		/* 8224C524h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x8);
		/* 8224C524h case   10:*/		return 0x8224C528;
		  /* 8224C528h */ case   11:  		/* subf R8, R11, R8 */
		/* 8224C528h case   11:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R11,regs.R8);
		/* 8224C528h case   11:*/		return 0x8224C52C;
		  /* 8224C52Ch */ case   12:  		/* lwzx R6, <#[R8 + R10]> */
		/* 8224C52Ch case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 8224C52Ch case   12:*/		return 0x8224C530;
		  /* 8224C530h */ case   13:  		/* addi R9, R9, 1 */
		/* 8224C530h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8224C530h case   13:*/		return 0x8224C534;
		  /* 8224C534h */ case   14:  		/* stw R6, <#[R10]> */
		/* 8224C534h case   14:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 8224C534h case   14:*/		return 0x8224C538;
		  /* 8224C538h */ case   15:  		/* addi R10, R10, 4 */
		/* 8224C538h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8224C538h case   15:*/		return 0x8224C53C;
		  /* 8224C53Ch */ case   16:  		/* lwz R6, <#[R11]> */
		/* 8224C53Ch case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8224C53Ch case   16:*/		return 0x8224C540;
		  /* 8224C540h */ case   17:  		/* cmplw CR6, R9, R6 */
		/* 8224C540h case   17:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 8224C540h case   17:*/		return 0x8224C544;
		  /* 8224C544h */ case   18:  		/* bc 12, CR6_LT, -24 */
		/* 8224C544h case   18:*/		if ( regs.CR[6].lt ) { return 0x8224C52C;  }
		/* 8224C544h case   18:*/		return 0x8224C548;
	}
	return 0x8224C548;
} // Block from 8224C4FCh-8224C548h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8224C548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C548);
		  /* 8224C548h */ case    0:  		/* li R6, 0 */
		/* 8224C548h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8224C548h case    0:*/		return 0x8224C54C;
		  /* 8224C54Ch */ case    1:  		/* b 64 */
		/* 8224C54Ch case    1:*/		return 0x8224C58C;
		/* 8224C54Ch case    1:*/		return 0x8224C550;
	}
	return 0x8224C550;
} // Block from 8224C548h-8224C550h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224C550h
// Function '?Apply@R400SchedModel@XGRAPHICS@@UAAXPBVIRInst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C550);
		  /* 8224C550h */ case    0:  		/* lwz R10, <#[R31 + 104]> */
		/* 8224C550h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000068) );
		/* 8224C550h case    0:*/		return 0x8224C554;
		  /* 8224C554h */ case    1:  		/* lwz R11, <#[R10]> */
		/* 8224C554h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8224C554h case    1:*/		return 0x8224C558;
		  /* 8224C558h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8224C558h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224C558h case    2:*/		return 0x8224C55C;
		  /* 8224C55Ch */ case    3:  		/* bc 4, CR6_GT, 48 */
		/* 8224C55Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x8224C58C;  }
		/* 8224C55Ch case    3:*/		return 0x8224C560;
		  /* 8224C560h */ case    4:  		/* addi R11, R10, 8 */
		/* 8224C560h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 8224C560h case    4:*/		return 0x8224C564;
		  /* 8224C564h */ case    5:  		/* subf R8, R10, R8 */
		/* 8224C564h case    5:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R10,regs.R8);
		/* 8224C564h case    5:*/		return 0x8224C568;
		  /* 8224C568h */ case    6:  		/* lwzx R3, <#[R8 + R11]> */
		/* 8224C568h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8224C568h case    6:*/		return 0x8224C56C;
		  /* 8224C56Ch */ case    7:  		/* addi R9, R9, 1 */
		/* 8224C56Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8224C56Ch case    7:*/		return 0x8224C570;
		  /* 8224C570h */ case    8:  		/* lwz R26, <#[R11]> */
		/* 8224C570h case    8:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x00000000) );
		/* 8224C570h case    8:*/		return 0x8224C574;
		  /* 8224C574h */ case    9:  		/* or R3, R3, R26 */
		/* 8224C574h case    9:*/		cpu::op::or<0>(regs,&regs.R3,regs.R3,regs.R26);
		/* 8224C574h case    9:*/		return 0x8224C578;
		  /* 8224C578h */ case   10:  		/* stw R3, <#[R11]> */
		/* 8224C578h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 8224C578h case   10:*/		return 0x8224C57C;
		  /* 8224C57Ch */ case   11:  		/* addi R11, R11, 4 */
		/* 8224C57Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8224C57Ch case   11:*/		return 0x8224C580;
		  /* 8224C580h */ case   12:  		/* lwz R3, <#[R10]> */
		/* 8224C580h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x00000000) );
		/* 8224C580h case   12:*/		return 0x8224C584;
		  /* 8224C584h */ case   13:  		/* cmplw CR6, R9, R3 */
		/* 8224C584h case   13:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R3);
		/* 8224C584h case   13:*/		return 0x8224C588;
		  /* 8224C588h */ case   14:  		/* bc 12, CR6_LT, -32 */
		/* 8224C588h case   14:*/		if ( regs.CR[6].lt ) { return 0x8224C568;  }
		/* 8224C588h case   14:*/		return 0x8224C58C;
	}
	return 0x8224C58C;
} // Block from 8224C550h-8224C58Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8224C58Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C58C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C58C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C58C);
		  /* 8224C58Ch */ case    0:  		/* addi R4, R4, 1 */
		/* 8224C58Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 8224C58Ch case    0:*/		return 0x8224C590;
	}
	return 0x8224C590;
} // Block from 8224C58Ch-8224C590h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224C590h
// Function '?FullState@R400SchedModel@XGRAPHICS@@UAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C590( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C590) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C590);
		  /* 8224C590h */ case    0:  		/* addi R5, R5, 4 */
		/* 8224C590h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 8224C590h case    0:*/		return 0x8224C594;
		  /* 8224C594h */ case    1:  		/* b -188 */
		/* 8224C594h case    1:*/		return 0x8224C4D8;
		/* 8224C594h case    1:*/		return 0x8224C598;
	}
	return 0x8224C598;
} // Block from 8224C590h-8224C598h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224C598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C598);
		  /* 8224C598h */ case    0:  		/* lwz R10, <#[R31 + 100]> */
		/* 8224C598h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000064) );
		/* 8224C598h case    0:*/		return 0x8224C59C;
		  /* 8224C59Ch */ case    1:  		/* lwz R8, <#[R10]> */
		/* 8224C59Ch case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8224C59Ch case    1:*/		return 0x8224C5A0;
		  /* 8224C5A0h */ case    2:  		/* cmplwi CR6, R8, 0 */
		/* 8224C5A0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8224C5A0h case    2:*/		return 0x8224C5A4;
		  /* 8224C5A4h */ case    3:  		/* bc 12, CR6_EQ, 48 */
		/* 8224C5A4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8224C5D4;  }
		/* 8224C5A4h case    3:*/		return 0x8224C5A8;
		  /* 8224C5A8h */ case    4:  		/* lwz R7, <#[R31 + 104]> */
		/* 8224C5A8h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000068) );
		/* 8224C5A8h case    4:*/		return 0x8224C5AC;
		  /* 8224C5ACh */ case    5:  		/* li R11, 8 */
		/* 8224C5ACh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x8);
		/* 8224C5ACh case    5:*/		return 0x8224C5B0;
		  /* 8224C5B0h */ case    6:  		/* lwzx R6, <#[R10 + R11]> */
		/* 8224C5B0h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8224C5B0h case    6:*/		return 0x8224C5B4;
		  /* 8224C5B4h */ case    7:  		/* lwzx R5, <#[R7 + R11]> */
		/* 8224C5B4h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 8224C5B4h case    7:*/		return 0x8224C5B8;
		  /* 8224C5B8h */ case    8:  		/* or R5, R5, R6 */
		/* 8224C5B8h case    8:*/		cpu::op::or<0>(regs,&regs.R5,regs.R5,regs.R6);
		/* 8224C5B8h case    8:*/		return 0x8224C5BC;
		  /* 8224C5BCh */ case    9:  		/* cmplw CR6, R5, R6 */
		/* 8224C5BCh case    9:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R6);
		/* 8224C5BCh case    9:*/		return 0x8224C5C0;
		  /* 8224C5C0h */ case   10:  		/* bc 4, CR6_EQ, 144 */
		/* 8224C5C0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8224C650;  }
		/* 8224C5C0h case   10:*/		return 0x8224C5C4;
		  /* 8224C5C4h */ case   11:  		/* addi R9, R9, 1 */
		/* 8224C5C4h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8224C5C4h case   11:*/		return 0x8224C5C8;
		  /* 8224C5C8h */ case   12:  		/* addi R11, R11, 4 */
		/* 8224C5C8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8224C5C8h case   12:*/		return 0x8224C5CC;
		  /* 8224C5CCh */ case   13:  		/* cmplw CR6, R9, R8 */
		/* 8224C5CCh case   13:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 8224C5CCh case   13:*/		return 0x8224C5D0;
		  /* 8224C5D0h */ case   14:  		/* bc 12, CR6_LT, -32 */
		/* 8224C5D0h case   14:*/		if ( regs.CR[6].lt ) { return 0x8224C5B0;  }
		/* 8224C5D0h case   14:*/		return 0x8224C5D4;
	}
	return 0x8224C5D4;
} // Block from 8224C598h-8224C5D4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8224C5D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C5D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C5D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C5D4);
		  /* 8224C5D4h */ case    0:  		/* mr R11, R24 */
		/* 8224C5D4h case    0:*/		regs.R11 = regs.R24;
		/* 8224C5D4h case    0:*/		return 0x8224C5D8;
		  /* 8224C5D8h */ case    1:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8224C5D8h case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8224C5D8h case    1:*/		return 0x8224C5DC;
		  /* 8224C5DCh */ case    2:  		/* bc 4, CR0_EQ, 72 */
		/* 8224C5DCh case    2:*/		if ( !regs.CR[0].eq ) { return 0x8224C624;  }
		/* 8224C5DCh case    2:*/		return 0x8224C5E0;
		  /* 8224C5E0h */ case    3:  		/* lwz R11, <#[R10]> */
		/* 8224C5E0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8224C5E0h case    3:*/		return 0x8224C5E4;
		  /* 8224C5E4h */ case    4:  		/* mr R29, R24 */
		/* 8224C5E4h case    4:*/		regs.R29 = regs.R24;
		/* 8224C5E4h case    4:*/		return 0x8224C5E8;
		  /* 8224C5E8h */ case    5:  		/* lwz R8, <#[R31 + 104]> */
		/* 8224C5E8h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000068) );
		/* 8224C5E8h case    5:*/		return 0x8224C5EC;
		  /* 8224C5ECh */ case    6:  		/* li R9, 0 */
		/* 8224C5ECh case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8224C5ECh case    6:*/		return 0x8224C5F0;
		  /* 8224C5F0h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8224C5F0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224C5F0h case    7:*/		return 0x8224C5F4;
		  /* 8224C5F4h */ case    8:  		/* bc 4, CR6_GT, 48 */
		/* 8224C5F4h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8224C624;  }
		/* 8224C5F4h case    8:*/		return 0x8224C5F8;
		  /* 8224C5F8h */ case    9:  		/* addi R11, R10, 8 */
		/* 8224C5F8h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 8224C5F8h case    9:*/		return 0x8224C5FC;
		  /* 8224C5FCh */ case   10:  		/* subf R8, R10, R8 */
		/* 8224C5FCh case   10:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R10,regs.R8);
		/* 8224C5FCh case   10:*/		return 0x8224C600;
	}
	return 0x8224C600;
} // Block from 8224C5D4h-8224C600h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224C600h
// Function '?ZeroState@R400SchedModel@XGRAPHICS@@UAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C600);
		  /* 8224C600h */ case    0:  		/* lwzx R7, <#[R8 + R11]> */
		/* 8224C600h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8224C600h case    0:*/		return 0x8224C604;
		  /* 8224C604h */ case    1:  		/* addi R9, R9, 1 */
		/* 8224C604h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8224C604h case    1:*/		return 0x8224C608;
		  /* 8224C608h */ case    2:  		/* lwz R6, <#[R11]> */
		/* 8224C608h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8224C608h case    2:*/		return 0x8224C60C;
		  /* 8224C60Ch */ case    3:  		/* or R7, R7, R6 */
		/* 8224C60Ch case    3:*/		cpu::op::or<0>(regs,&regs.R7,regs.R7,regs.R6);
		/* 8224C60Ch case    3:*/		return 0x8224C610;
		  /* 8224C610h */ case    4:  		/* stw R7, <#[R11]> */
		/* 8224C610h case    4:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8224C610h case    4:*/		return 0x8224C614;
		  /* 8224C614h */ case    5:  		/* addi R11, R11, 4 */
		/* 8224C614h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8224C614h case    5:*/		return 0x8224C618;
		  /* 8224C618h */ case    6:  		/* lwz R7, <#[R10]> */
		/* 8224C618h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 8224C618h case    6:*/		return 0x8224C61C;
		  /* 8224C61Ch */ case    7:  		/* cmplw CR6, R9, R7 */
		/* 8224C61Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 8224C61Ch case    7:*/		return 0x8224C620;
		  /* 8224C620h */ case    8:  		/* bc 12, CR6_LT, -32 */
		/* 8224C620h case    8:*/		if ( regs.CR[6].lt ) { return 0x8224C600;  }
		/* 8224C620h case    8:*/		return 0x8224C624;
	}
	return 0x8224C624;
} // Block from 8224C600h-8224C624h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224C624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C624);
		  /* 8224C624h */ case    0:  		/* lwz R11, <#[R23 + 4]> */
		/* 8224C624h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 8224C624h case    0:*/		return 0x8224C628;
		  /* 8224C628h */ case    1:  		/* addi R30, R30, 1 */
		/* 8224C628h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8224C628h case    1:*/		return 0x8224C62C;
		  /* 8224C62Ch */ case    2:  		/* addi R28, R28, 4 */
		/* 8224C62Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 8224C62Ch case    2:*/		return 0x8224C630;
		  /* 8224C630h */ case    3:  		/* addi R3, R11, 128 */
		/* 8224C630h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x80);
		/* 8224C630h case    3:*/		return 0x8224C634;
		  /* 8224C634h */ case    4:  		/* bl 29228 */
		/* 8224C634h case    4:*/		regs.LR = 0x8224C638; return 0x82253860;
		/* 8224C634h case    4:*/		return 0x8224C638;
		  /* 8224C638h */ case    5:  		/* cmpw CR6, R30, R3 */
		/* 8224C638h case    5:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R3);
		/* 8224C638h case    5:*/		return 0x8224C63C;
		  /* 8224C63Ch */ case    6:  		/* bc 4, CR6_GT, -452 */
		/* 8224C63Ch case    6:*/		if ( !regs.CR[6].gt ) { return 0x8224C478;  }
		/* 8224C63Ch case    6:*/		return 0x8224C640;
	}
	return 0x8224C640;
} // Block from 8224C624h-8224C640h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224C640h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C640);
		  /* 8224C640h */ case    0:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 8224C640h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 8224C640h case    0:*/		return 0x8224C644;
		  /* 8224C644h */ case    1:  		/* bc 4, CR0_EQ, -492 */
		/* 8224C644h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8224C458;  }
		/* 8224C644h case    1:*/		return 0x8224C648;
		  /* 8224C648h */ case    2:  		/* addi R1, R1, 160 */
		/* 8224C648h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 8224C648h case    2:*/		return 0x8224C64C;
		  /* 8224C64Ch */ case    3:  		/* b -1815480 */
		/* 8224C64Ch case    3:*/		return 0x82091294;
		/* 8224C64Ch case    3:*/		return 0x8224C650;
	}
	return 0x8224C650;
} // Block from 8224C640h-8224C650h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224C650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C650);
		  /* 8224C650h */ case    0:  		/* li R11, 0 */
		/* 8224C650h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224C650h case    0:*/		return 0x8224C654;
		  /* 8224C654h */ case    1:  		/* b -124 */
		/* 8224C654h case    1:*/		return 0x8224C5D8;
		/* 8224C654h case    1:*/		return 0x8224C658;
	}
	return 0x8224C658;
} // Block from 8224C650h-8224C658h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224C658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C658);
		  /* 8224C658h */ case    0:  		/* mfspr R12, LR */
		/* 8224C658h case    0:*/		regs.R12 = regs.LR;
		/* 8224C658h case    0:*/		return 0x8224C65C;
		  /* 8224C65Ch */ case    1:  		/* bl -1815560 */
		/* 8224C65Ch case    1:*/		regs.LR = 0x8224C660; return 0x82091254;
		/* 8224C65Ch case    1:*/		return 0x8224C660;
		  /* 8224C660h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8224C660h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8224C660h case    2:*/		return 0x8224C664;
		  /* 8224C664h */ case    3:  		/* mr R29, R3 */
		/* 8224C664h case    3:*/		regs.R29 = regs.R3;
		/* 8224C664h case    3:*/		return 0x8224C668;
		  /* 8224C668h */ case    4:  		/* lwz R3, <#[R3 + 20]> */
		/* 8224C668h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000014) );
		/* 8224C668h case    4:*/		return 0x8224C66C;
		  /* 8224C66Ch */ case    5:  		/* li R31, 0 */
		/* 8224C66Ch case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8224C66Ch case    5:*/		return 0x8224C670;
	}
	return 0x8224C670;
} // Block from 8224C658h-8224C670h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224C670h
// Function '?HasRoomForVector@R400SchedModel@XGRAPHICS@@UAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C670);
		  /* 8224C670h */ case    0:  		/* mr R27, R4 */
		/* 8224C670h case    0:*/		regs.R27 = regs.R4;
		/* 8224C670h case    0:*/		return 0x8224C674;
		  /* 8224C674h */ case    1:  		/* mr R30, R31 */
		/* 8224C674h case    1:*/		regs.R30 = regs.R31;
		/* 8224C674h case    1:*/		return 0x8224C678;
		  /* 8224C678h */ case    2:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224C678h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224C678h case    2:*/		return 0x8224C67C;
		  /* 8224C67Ch */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8224C67Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224C67Ch case    3:*/		return 0x8224C680;
		  /* 8224C680h */ case    4:  		/* bc 4, CR6_GT, 80 */
		/* 8224C680h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8224C6D0;  }
		/* 8224C680h case    4:*/		return 0x8224C684;
		  /* 8224C684h */ case    5:  		/* mr R28, R31 */
		/* 8224C684h case    5:*/		regs.R28 = regs.R31;
		/* 8224C684h case    5:*/		return 0x8224C688;
		  /* 8224C688h */ case    6:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224C688h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224C688h case    6:*/		return 0x8224C68C;
		  /* 8224C68Ch */ case    7:  		/* cmplw CR6, R30, R11 */
		/* 8224C68Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8224C68Ch case    7:*/		return 0x8224C690;
		  /* 8224C690h */ case    8:  		/* bc 4, CR6_LT, 16 */
		/* 8224C690h case    8:*/		if ( !regs.CR[6].lt ) { return 0x8224C6A0;  }
		/* 8224C690h case    8:*/		return 0x8224C694;
		  /* 8224C694h */ case    9:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224C694h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224C694h case    9:*/		return 0x8224C698;
		  /* 8224C698h */ case   10:  		/* add R3, R11, R28 */
		/* 8224C698h case   10:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R28);
		/* 8224C698h case   10:*/		return 0x8224C69C;
		  /* 8224C69Ch */ case   11:  		/* b 12 */
		/* 8224C69Ch case   11:*/		return 0x8224C6A8;
		/* 8224C69Ch case   11:*/		return 0x8224C6A0;
	}
	return 0x8224C6A0;
} // Block from 8224C670h-8224C6A0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224C6A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C6A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C6A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C6A0);
		  /* 8224C6A0h */ case    0:  		/* mr R4, R30 */
		/* 8224C6A0h case    0:*/		regs.R4 = regs.R30;
		/* 8224C6A0h case    0:*/		return 0x8224C6A4;
		  /* 8224C6A4h */ case    1:  		/* bl 29724 */
		/* 8224C6A4h case    1:*/		regs.LR = 0x8224C6A8; return 0x82253AC0;
		/* 8224C6A4h case    1:*/		return 0x8224C6A8;
	}
	return 0x8224C6A8;
} // Block from 8224C6A0h-8224C6A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224C6A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C6A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C6A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C6A8);
		  /* 8224C6A8h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224C6A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224C6A8h case    0:*/		return 0x8224C6AC;
		  /* 8224C6ACh */ case    1:  		/* lwz R3, <#[R29 + 20]> */
		/* 8224C6ACh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000014) );
		/* 8224C6ACh case    1:*/		return 0x8224C6B0;
		  /* 8224C6B0h */ case    2:  		/* lwz R11, <#[R11 + 40]> */
		/* 8224C6B0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8224C6B0h case    2:*/		return 0x8224C6B4;
		  /* 8224C6B4h */ case    3:  		/* cmplw CR6, R11, R27 */
		/* 8224C6B4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 8224C6B4h case    3:*/		return 0x8224C6B8;
		  /* 8224C6B8h */ case    4:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224C6B8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224C6B8h case    4:*/		return 0x8224C6BC;
		  /* 8224C6BCh */ case    5:  		/* bc 12, CR6_EQ, 156 */
		/* 8224C6BCh case    5:*/		if ( regs.CR[6].eq ) { return 0x8224C758;  }
		/* 8224C6BCh case    5:*/		return 0x8224C6C0;
		  /* 8224C6C0h */ case    6:  		/* addi R30, R30, 1 */
		/* 8224C6C0h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8224C6C0h case    6:*/		return 0x8224C6C4;
		  /* 8224C6C4h */ case    7:  		/* addi R28, R28, 4 */
		/* 8224C6C4h case    7:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 8224C6C4h case    7:*/		return 0x8224C6C8;
		  /* 8224C6C8h */ case    8:  		/* cmplw CR6, R30, R11 */
		/* 8224C6C8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8224C6C8h case    8:*/		return 0x8224C6CC;
		  /* 8224C6CCh */ case    9:  		/* bc 12, CR6_LT, -68 */
		/* 8224C6CCh case    9:*/		if ( regs.CR[6].lt ) { return 0x8224C688;  }
		/* 8224C6CCh case    9:*/		return 0x8224C6D0;
	}
	return 0x8224C6D0;
} // Block from 8224C6A8h-8224C6D0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224C6D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C6D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C6D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C6D0);
		  /* 8224C6D0h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8224C6D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8224C6D0h case    0:*/		return 0x8224C6D4;
		  /* 8224C6D4h */ case    1:  		/* li R4, 72 */
		/* 8224C6D4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x48);
		/* 8224C6D4h case    1:*/		return 0x8224C6D8;
		  /* 8224C6D8h */ case    2:  		/* lwz R30, <#[R11 + 1456]> */
		/* 8224C6D8h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224C6D8h case    2:*/		return 0x8224C6DC;
		  /* 8224C6DCh */ case    3:  		/* mr R3, R30 */
		/* 8224C6DCh case    3:*/		regs.R3 = regs.R30;
		/* 8224C6DCh case    3:*/		return 0x8224C6E0;
	}
	return 0x8224C6E0;
} // Block from 8224C6D0h-8224C6E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224C6E0h
// Function '?HasRoomForScalar@R400SchedModel@XGRAPHICS@@UAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C6E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C6E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C6E0);
		  /* 8224C6E0h */ case    0:  		/* bl -197160 */
		/* 8224C6E0h case    0:*/		regs.LR = 0x8224C6E4; return 0x8221C4B8;
		/* 8224C6E0h case    0:*/		return 0x8224C6E4;
		  /* 8224C6E4h */ case    1:  		/* addic. R11, R3, 4 */
		/* 8224C6E4h case    1:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R3,0x4);
		/* 8224C6E4h case    1:*/		return 0x8224C6E8;
		  /* 8224C6E8h */ case    2:  		/* stw R30, <#[R3]> */
		/* 8224C6E8h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224C6E8h case    2:*/		return 0x8224C6EC;
		  /* 8224C6ECh */ case    3:  		/* bc 12, CR0_EQ, 148 */
		/* 8224C6ECh case    3:*/		if ( regs.CR[0].eq ) { return 0x8224C780;  }
		/* 8224C6ECh case    3:*/		return 0x8224C6F0;
		  /* 8224C6F0h */ case    4:  		/* lwz R10, <#[R29 + 20]> */
		/* 8224C6F0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000014) );
		/* 8224C6F0h case    4:*/		return 0x8224C6F4;
		  /* 8224C6F4h */ case    5:  		/* lis R9, -32256 */
		/* 8224C6F4h case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 8224C6F4h case    5:*/		return 0x8224C6F8;
		  /* 8224C6F8h */ case    6:  		/* lis R8, -32252 */
		/* 8224C6F8h case    6:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8204);
		/* 8224C6F8h case    6:*/		return 0x8224C6FC;
		  /* 8224C6FCh */ case    7:  		/* li R7, -1 */
		/* 8224C6FCh case    7:*/		cpu::op::li<0>(regs,&regs.R7,0xFFFFFFFF);
		/* 8224C6FCh case    7:*/		return 0x8224C700;
		  /* 8224C700h */ case    8:  		/* addi R8, R8, 14380 */
		/* 8224C700h case    8:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x382C);
		/* 8224C700h case    8:*/		return 0x8224C704;
		  /* 8224C704h */ case    9:  		/* mr R28, R11 */
		/* 8224C704h case    9:*/		regs.R28 = regs.R11;
		/* 8224C704h case    9:*/		return 0x8224C708;
		  /* 8224C708h */ case   10:  		/* lwz R10, <#[R10 + 4]> */
		/* 8224C708h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8224C708h case   10:*/		return 0x8224C70C;
		  /* 8224C70Ch */ case   11:  		/* lfs FR0, <#[R9 + 1816]> */
		/* 8224C70Ch case   11:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000718) );
		/* 8224C70Ch case   11:*/		return 0x8224C710;
		  /* 8224C710h */ case   12:  		/* stfs FR0, <#[R11 + 16]> */
		/* 8224C710h case   12:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000010) );
		/* 8224C710h case   12:*/		return 0x8224C714;
		  /* 8224C714h */ case   13:  		/* stw R31, <#[R11 + 4]> */
		/* 8224C714h case   13:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 8224C714h case   13:*/		return 0x8224C718;
		  /* 8224C718h */ case   14:  		/* stw R31, <#[R11 + 8]> */
		/* 8224C718h case   14:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000008) );
		/* 8224C718h case   14:*/		return 0x8224C71C;
		  /* 8224C71Ch */ case   15:  		/* stw R8, <#[R11]> */
		/* 8224C71Ch case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8224C71Ch case   15:*/		return 0x8224C720;
		  /* 8224C720h */ case   16:  		/* stw R7, <#[R11 + 28]> */
		/* 8224C720h case   16:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x0000001C) );
		/* 8224C720h case   16:*/		return 0x8224C724;
		  /* 8224C724h */ case   17:  		/* stw R31, <#[R11 + 32]> */
		/* 8224C724h case   17:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000020) );
		/* 8224C724h case   17:*/		return 0x8224C728;
		  /* 8224C728h */ case   18:  		/* stw R31, <#[R11 + 36]> */
		/* 8224C728h case   18:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000024) );
		/* 8224C728h case   18:*/		return 0x8224C72C;
		  /* 8224C72Ch */ case   19:  		/* stw R27, <#[R11 + 40]> */
		/* 8224C72Ch case   19:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000028) );
		/* 8224C72Ch case   19:*/		return 0x8224C730;
		  /* 8224C730h */ case   20:  		/* stw R10, <#[R11 + 44]> */
		/* 8224C730h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000002C) );
		/* 8224C730h case   20:*/		return 0x8224C734;
		  /* 8224C734h */ case   21:  		/* stw R31, <#[R11 + 48]> */
		/* 8224C734h case   21:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000030) );
		/* 8224C734h case   21:*/		return 0x8224C738;
		  /* 8224C738h */ case   22:  		/* stw R31, <#[R11 + 52]> */
		/* 8224C738h case   22:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000034) );
		/* 8224C738h case   22:*/		return 0x8224C73C;
		  /* 8224C73Ch */ case   23:  		/* stb R31, <#[R11 + 56]> */
		/* 8224C73Ch case   23:*/		cpu::mem::store8( regs, regs.R31, (uint32)(regs.R11 + 0x00000038) );
		/* 8224C73Ch case   23:*/		return 0x8224C740;
		  /* 8224C740h */ case   24:  		/* stw R31, <#[R11 + 60]> */
		/* 8224C740h case   24:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x0000003C) );
		/* 8224C740h case   24:*/		return 0x8224C744;
		  /* 8224C744h */ case   25:  		/* stw R31, <#[R11 + 64]> */
		/* 8224C744h case   25:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000040) );
		/* 8224C744h case   25:*/		return 0x8224C748;
		  /* 8224C748h */ case   26:  		/* stw R31, <#[R11 + 12]> */
		/* 8224C748h case   26:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x0000000C) );
		/* 8224C748h case   26:*/		return 0x8224C74C;
		  /* 8224C74Ch */ case   27:  		/* stw R31, <#[R11 + 20]> */
		/* 8224C74Ch case   27:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000014) );
		/* 8224C74Ch case   27:*/		return 0x8224C750;
	}
	return 0x8224C750;
} // Block from 8224C6E0h-8224C750h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8224C750h
// Function '?EquivalentMovBase@XGRAPHICS@@YA_NPBVIRInst@1@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C750);
		  /* 8224C750h */ case    0:  		/* stw R31, <#[R11 + 24]> */
		/* 8224C750h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000018) );
		/* 8224C750h case    0:*/		return 0x8224C754;
		  /* 8224C754h */ case    1:  		/* b 48 */
		/* 8224C754h case    1:*/		return 0x8224C784;
		/* 8224C754h case    1:*/		return 0x8224C758;
	}
	return 0x8224C758;
} // Block from 8224C750h-8224C758h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224C758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C758);
		  /* 8224C758h */ case    0:  		/* cmplw CR6, R30, R11 */
		/* 8224C758h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8224C758h case    0:*/		return 0x8224C75C;
		  /* 8224C75Ch */ case    1:  		/* bc 4, CR6_LT, 20 */
		/* 8224C75Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x8224C770;  }
		/* 8224C75Ch case    1:*/		return 0x8224C760;
		  /* 8224C760h */ case    2:  		/* lwz R10, <#[R3 + 8]> */
		/* 8224C760h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 8224C760h case    2:*/		return 0x8224C764;
		  /* 8224C764h */ case    3:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 8224C764h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 8224C764h case    3:*/		return 0x8224C768;
		  /* 8224C768h */ case    4:  		/* add R3, R10, R11 */
		/* 8224C768h case    4:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8224C768h case    4:*/		return 0x8224C76C;
		  /* 8224C76Ch */ case    5:  		/* b 12 */
		/* 8224C76Ch case    5:*/		return 0x8224C778;
		/* 8224C76Ch case    5:*/		return 0x8224C770;
	}
	return 0x8224C770;
} // Block from 8224C758h-8224C770h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224C770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C770);
		  /* 8224C770h */ case    0:  		/* mr R4, R30 */
		/* 8224C770h case    0:*/		regs.R4 = regs.R30;
		/* 8224C770h case    0:*/		return 0x8224C774;
		  /* 8224C774h */ case    1:  		/* bl 29516 */
		/* 8224C774h case    1:*/		regs.LR = 0x8224C778; return 0x82253AC0;
		/* 8224C774h case    1:*/		return 0x8224C778;
	}
	return 0x8224C778;
} // Block from 8224C770h-8224C778h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224C778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C778);
		  /* 8224C778h */ case    0:  		/* lwz R3, <#[R3]> */
		/* 8224C778h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 8224C778h case    0:*/		return 0x8224C77C;
		  /* 8224C77Ch */ case    1:  		/* b 152 */
		/* 8224C77Ch case    1:*/		return 0x8224C814;
		/* 8224C77Ch case    1:*/		return 0x8224C780;
	}
	return 0x8224C780;
} // Block from 8224C778h-8224C780h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224C780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C780);
		  /* 8224C780h */ case    0:  		/* mr R28, R31 */
		/* 8224C780h case    0:*/		regs.R28 = regs.R31;
		/* 8224C780h case    0:*/		return 0x8224C784;
	}
	return 0x8224C784;
} // Block from 8224C780h-8224C784h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224C784h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C784( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C784) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C784);
		  /* 8224C784h */ case    0:  		/* stb R31, <#[R28 + 56]> */
		/* 8224C784h case    0:*/		cpu::mem::store8( regs, regs.R31, (uint32)(regs.R28 + 0x00000038) );
		/* 8224C784h case    0:*/		return 0x8224C788;
		  /* 8224C788h */ case    1:  		/* li R4, 20 */
		/* 8224C788h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 8224C788h case    1:*/		return 0x8224C78C;
		  /* 8224C78Ch */ case    2:  		/* lwz R11, <#[R29]> */
		/* 8224C78Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8224C78Ch case    2:*/		return 0x8224C790;
		  /* 8224C790h */ case    3:  		/* lwz R27, <#[R11 + 1456]> */
		/* 8224C790h case    3:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224C790h case    3:*/		return 0x8224C794;
		  /* 8224C794h */ case    4:  		/* mr R3, R27 */
		/* 8224C794h case    4:*/		regs.R3 = regs.R27;
		/* 8224C794h case    4:*/		return 0x8224C798;
		  /* 8224C798h */ case    5:  		/* bl -197344 */
		/* 8224C798h case    5:*/		regs.LR = 0x8224C79C; return 0x8221C4B8;
		/* 8224C798h case    5:*/		return 0x8224C79C;
		  /* 8224C79Ch */ case    6:  		/* addic. R30, R3, 4 */
		/* 8224C79Ch case    6:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 8224C79Ch case    6:*/		return 0x8224C7A0;
		  /* 8224C7A0h */ case    7:  		/* stw R27, <#[R3]> */
		/* 8224C7A0h case    7:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 8224C7A0h case    7:*/		return 0x8224C7A4;
		  /* 8224C7A4h */ case    8:  		/* bc 12, CR0_EQ, 24 */
		/* 8224C7A4h case    8:*/		if ( regs.CR[0].eq ) { return 0x8224C7BC;  }
		/* 8224C7A4h case    8:*/		return 0x8224C7A8;
		  /* 8224C7A8h */ case    9:  		/* lwz R11, <#[R29]> */
		/* 8224C7A8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8224C7A8h case    9:*/		return 0x8224C7AC;
		  /* 8224C7ACh */ case   10:  		/* mr R3, R30 */
		/* 8224C7ACh case   10:*/		regs.R3 = regs.R30;
		/* 8224C7ACh case   10:*/		return 0x8224C7B0;
		  /* 8224C7B0h */ case   11:  		/* lwz R4, <#[R11 + 1456]> */
		/* 8224C7B0h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224C7B0h case   11:*/		return 0x8224C7B4;
		  /* 8224C7B4h */ case   12:  		/* bl -92756 */
		/* 8224C7B4h case   12:*/		regs.LR = 0x8224C7B8; return 0x82235D60;
		/* 8224C7B4h case   12:*/		return 0x8224C7B8;
		  /* 8224C7B8h */ case   13:  		/* b 8 */
		/* 8224C7B8h case   13:*/		return 0x8224C7C0;
		/* 8224C7B8h case   13:*/		return 0x8224C7BC;
	}
	return 0x8224C7BC;
} // Block from 8224C784h-8224C7BCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224C7BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C7BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C7BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C7BC);
		  /* 8224C7BCh */ case    0:  		/* mr R30, R31 */
		/* 8224C7BCh case    0:*/		regs.R30 = regs.R31;
		/* 8224C7BCh case    0:*/		return 0x8224C7C0;
	}
	return 0x8224C7C0;
} // Block from 8224C7BCh-8224C7C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224C7C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C7C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C7C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C7C0);
		  /* 8224C7C0h */ case    0:  		/* stw R30, <#[R28 + 52]> */
		/* 8224C7C0h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R28 + 0x00000034) );
		/* 8224C7C0h case    0:*/		return 0x8224C7C4;
		  /* 8224C7C4h */ case    1:  		/* li R4, 20 */
		/* 8224C7C4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 8224C7C4h case    1:*/		return 0x8224C7C8;
		  /* 8224C7C8h */ case    2:  		/* lwz R11, <#[R29]> */
		/* 8224C7C8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8224C7C8h case    2:*/		return 0x8224C7CC;
		  /* 8224C7CCh */ case    3:  		/* lwz R27, <#[R11 + 1456]> */
		/* 8224C7CCh case    3:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224C7CCh case    3:*/		return 0x8224C7D0;
		  /* 8224C7D0h */ case    4:  		/* mr R3, R27 */
		/* 8224C7D0h case    4:*/		regs.R3 = regs.R27;
		/* 8224C7D0h case    4:*/		return 0x8224C7D4;
		  /* 8224C7D4h */ case    5:  		/* bl -197404 */
		/* 8224C7D4h case    5:*/		regs.LR = 0x8224C7D8; return 0x8221C4B8;
		/* 8224C7D4h case    5:*/		return 0x8224C7D8;
		  /* 8224C7D8h */ case    6:  		/* addic. R30, R3, 4 */
		/* 8224C7D8h case    6:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 8224C7D8h case    6:*/		return 0x8224C7DC;
		  /* 8224C7DCh */ case    7:  		/* stw R27, <#[R3]> */
		/* 8224C7DCh case    7:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 8224C7DCh case    7:*/		return 0x8224C7E0;
		  /* 8224C7E0h */ case    8:  		/* bc 12, CR0_EQ, 24 */
		/* 8224C7E0h case    8:*/		if ( regs.CR[0].eq ) { return 0x8224C7F8;  }
		/* 8224C7E0h case    8:*/		return 0x8224C7E4;
		  /* 8224C7E4h */ case    9:  		/* lwz R11, <#[R29]> */
		/* 8224C7E4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8224C7E4h case    9:*/		return 0x8224C7E8;
		  /* 8224C7E8h */ case   10:  		/* mr R3, R30 */
		/* 8224C7E8h case   10:*/		regs.R3 = regs.R30;
		/* 8224C7E8h case   10:*/		return 0x8224C7EC;
		  /* 8224C7ECh */ case   11:  		/* lwz R4, <#[R11 + 1456]> */
		/* 8224C7ECh case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224C7ECh case   11:*/		return 0x8224C7F0;
		  /* 8224C7F0h */ case   12:  		/* bl -92816 */
		/* 8224C7F0h case   12:*/		regs.LR = 0x8224C7F4; return 0x82235D60;
		/* 8224C7F0h case   12:*/		return 0x8224C7F4;
		  /* 8224C7F4h */ case   13:  		/* mr R31, R30 */
		/* 8224C7F4h case   13:*/		regs.R31 = regs.R30;
		/* 8224C7F4h case   13:*/		return 0x8224C7F8;
	}
	return 0x8224C7F8;
} // Block from 8224C7C0h-8224C7F8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224C7F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C7F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C7F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C7F8);
		  /* 8224C7F8h */ case    0:  		/* stw R31, <#[R28 + 48]> */
		/* 8224C7F8h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R28 + 0x00000030) );
		/* 8224C7F8h case    0:*/		return 0x8224C7FC;
		  /* 8224C7FCh */ case    1:  		/* lwz R3, <#[R29 + 20]> */
		/* 8224C7FCh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000014) );
		/* 8224C7FCh case    1:*/		return 0x8224C800;
		  /* 8224C800h */ case    2:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224C800h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224C800h case    2:*/		return 0x8224C804;
		  /* 8224C804h */ case    3:  		/* bl 29372 */
		/* 8224C804h case    3:*/		regs.LR = 0x8224C808; return 0x82253AC0;
		/* 8224C804h case    3:*/		return 0x8224C808;
		  /* 8224C808h */ case    4:  		/* mr R11, R3 */
		/* 8224C808h case    4:*/		regs.R11 = regs.R3;
		/* 8224C808h case    4:*/		return 0x8224C80C;
		  /* 8224C80Ch */ case    5:  		/* mr R3, R28 */
		/* 8224C80Ch case    5:*/		regs.R3 = regs.R28;
		/* 8224C80Ch case    5:*/		return 0x8224C810;
		  /* 8224C810h */ case    6:  		/* stw R28, <#[R11]> */
		/* 8224C810h case    6:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 8224C810h case    6:*/		return 0x8224C814;
	}
	return 0x8224C814;
} // Block from 8224C7F8h-8224C814h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224C814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C814);
		  /* 8224C814h */ case    0:  		/* addi R1, R1, 128 */
		/* 8224C814h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8224C814h case    0:*/		return 0x8224C818;
		  /* 8224C818h */ case    1:  		/* b -1815924 */
		/* 8224C818h case    1:*/		return 0x820912A4;
		/* 8224C818h case    1:*/		return 0x8224C81C;
		  /* 8224C81Ch */ case    2:  		/* nop */
		/* 8224C81Ch case    2:*/		cpu::op::nop();
		/* 8224C81Ch case    2:*/		return 0x8224C820;
	}
	return 0x8224C820;
} // Block from 8224C814h-8224C820h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224C820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C820);
		  /* 8224C820h */ case    0:  		/* mfspr R12, LR */
		/* 8224C820h case    0:*/		regs.R12 = regs.LR;
		/* 8224C820h case    0:*/		return 0x8224C824;
		  /* 8224C824h */ case    1:  		/* bl -1816068 */
		/* 8224C824h case    1:*/		regs.LR = 0x8224C828; return 0x82091220;
		/* 8224C824h case    1:*/		return 0x8224C828;
		  /* 8224C828h */ case    2:  		/* stfd FR31, <#[R1 - 160]> */
		/* 8224C828h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8224C828h case    2:*/		return 0x8224C82C;
		  /* 8224C82Ch */ case    3:  		/* stwu R1, <#[R1 - 320]> */
		/* 8224C82Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEC0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEC0);
		/* 8224C82Ch case    3:*/		return 0x8224C830;
	}
	return 0x8224C830;
} // Block from 8224C820h-8224C830h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224C830h
// Function '?Apply@R400ThreadModel@XGRAPHICS@@QAAXPAVSchedNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C830);
		  /* 8224C830h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224C830h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224C830h case    0:*/		return 0x8224C834;
		  /* 8224C834h */ case    1:  		/* mr R23, R3 */
		/* 8224C834h case    1:*/		regs.R23 = regs.R3;
		/* 8224C834h case    1:*/		return 0x8224C838;
		  /* 8224C838h */ case    2:  		/* lis R10, 32767 */
		/* 8224C838h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0x7FFF);
		/* 8224C838h case    2:*/		return 0x8224C83C;
		  /* 8224C83Ch */ case    3:  		/* li R15, 0 */
		/* 8224C83Ch case    3:*/		cpu::op::li<0>(regs,&regs.R15,0x0);
		/* 8224C83Ch case    3:*/		return 0x8224C840;
		  /* 8224C840h */ case    4:  		/* ori R10, R10, 65535 */
		/* 8224C840h case    4:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0xFFFF);
		/* 8224C840h case    4:*/		return 0x8224C844;
		  /* 8224C844h */ case    5:  		/* addi R3, R1, 128 */
		/* 8224C844h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 8224C844h case    5:*/		return 0x8224C848;
		  /* 8224C848h */ case    6:  		/* stb R15, <#[R1 + 80]> */
		/* 8224C848h case    6:*/		cpu::mem::store8( regs, regs.R15, (uint32)(regs.R1 + 0x00000050) );
		/* 8224C848h case    6:*/		return 0x8224C84C;
		  /* 8224C84Ch */ case    7:  		/* lwz R11, <#[R11 + 2136]> */
		/* 8224C84Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000858) );
		/* 8224C84Ch case    7:*/		return 0x8224C850;
		  /* 8224C850h */ case    8:  		/* mr R29, R15 */
		/* 8224C850h case    8:*/		regs.R29 = regs.R15;
		/* 8224C850h case    8:*/		return 0x8224C854;
		  /* 8224C854h */ case    9:  		/* stw R4, <#[R23 + 16]> */
		/* 8224C854h case    9:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R23 + 0x00000010) );
		/* 8224C854h case    9:*/		return 0x8224C858;
		  /* 8224C858h */ case   10:  		/* rlwinm R11, R11, 23, 31, 31 */
		/* 8224C858h case   10:*/		cpu::op::rlwinm<0,23,31,31>(regs,&regs.R11,regs.R11);
		/* 8224C858h case   10:*/		return 0x8224C85C;
		  /* 8224C85Ch */ case   11:  		/* stw R15, <#[R1 + 92]> */
		/* 8224C85Ch case   11:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x0000005C) );
		/* 8224C85Ch case   11:*/		return 0x8224C860;
		  /* 8224C860h */ case   12:  		/* subfic R11, R11, 0 */
		/* 8224C860h case   12:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 8224C860h case   12:*/		return 0x8224C864;
		  /* 8224C864h */ case   13:  		/* subfe R11, R11, R11 */
		/* 8224C864h case   13:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8224C864h case   13:*/		return 0x8224C868;
		  /* 8224C868h */ case   14:  		/* and R11, R11, R10 */
		/* 8224C868h case   14:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8224C868h case   14:*/		return 0x8224C86C;
		  /* 8224C86Ch */ case   15:  		/* stw R11, <#[R1 + 112]> */
		/* 8224C86Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 8224C86Ch case   15:*/		return 0x8224C870;
		  /* 8224C870h */ case   16:  		/* bl 28600 */
		/* 8224C870h case   16:*/		regs.LR = 0x8224C874; return 0x82253828;
		/* 8224C870h case   16:*/		return 0x8224C874;
		  /* 8224C874h */ case   17:  		/* lis R11, -32253 */
		/* 8224C874h case   17:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8224C874h case   17:*/		return 0x8224C878;
		  /* 8224C878h */ case   18:  		/* lis R10, -32252 */
		/* 8224C878h case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224C878h case   18:*/		return 0x8224C87C;
		  /* 8224C87Ch */ case   19:  		/* addi R30, R11, 27460 */
		/* 8224C87Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x6B44);
		/* 8224C87Ch case   19:*/		return 0x8224C880;
		  /* 8224C880h */ case   20:  		/* addi R31, R10, 14208 */
		/* 8224C880h case   20:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R10,0x3780);
		/* 8224C880h case   20:*/		return 0x8224C884;
		  /* 8224C884h */ case   21:  		/* stw R30, <#[R1 + 88]> */
		/* 8224C884h case   21:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000058) );
		/* 8224C884h case   21:*/		return 0x8224C888;
		  /* 8224C888h */ case   22:  		/* stw R31, <#[R1 + 84]> */
		/* 8224C888h case   22:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 8224C888h case   22:*/		return 0x8224C88C;
		  /* 8224C88Ch */ case   23:  		/* lwz R11, <#[R23 + 16]> */
		/* 8224C88Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000010) );
		/* 8224C88Ch case   23:*/		return 0x8224C890;
		  /* 8224C890h */ case   24:  		/* lwz R26, <#[R11 + 28]> */
		/* 8224C890h case   24:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x0000001C) );
		/* 8224C890h case   24:*/		return 0x8224C894;
		  /* 8224C894h */ case   25:  		/* lwz R11, <#[R26 + 8]> */
		/* 8224C894h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 8224C894h case   25:*/		return 0x8224C898;
		  /* 8224C898h */ case   26:  		/* cmpwi CR6, R11, 0 */
		/* 8224C898h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224C898h case   26:*/		return 0x8224C89C;
		  /* 8224C89Ch */ case   27:  		/* bc 12, CR6_EQ, 1972 */
		/* 8224C89Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x8224D050;  }
		/* 8224C89Ch case   27:*/		return 0x8224C8A0;
		  /* 8224C8A0h */ case   28:  		/* lis R8, -32256 */
		/* 8224C8A0h case   28:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 8224C8A0h case   28:*/		return 0x8224C8A4;
		  /* 8224C8A4h */ case   29:  		/* lis R10, -32251 */
		/* 8224C8A4h case   29:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8224C8A4h case   29:*/		return 0x8224C8A8;
		  /* 8224C8A8h */ case   30:  		/* lis R4, -32252 */
		/* 8224C8A8h case   30:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8204);
		/* 8224C8A8h case   30:*/		return 0x8224C8AC;
		  /* 8224C8ACh */ case   31:  		/* lis R3, -32252 */
		/* 8224C8ACh case   31:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8204);
		/* 8224C8ACh case   31:*/		return 0x8224C8B0;
		  /* 8224C8B0h */ case   32:  		/* lis R11, -32252 */
		/* 8224C8B0h case   32:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224C8B0h case   32:*/		return 0x8224C8B4;
		  /* 8224C8B4h */ case   33:  		/* lfs FR31, <#[R8 + 1816]> */
		/* 8224C8B4h case   33:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R8 + 0x00000718) );
		/* 8224C8B4h case   33:*/		return 0x8224C8B8;
		  /* 8224C8B8h */ case   34:  		/* lis R9, -32252 */
		/* 8224C8B8h case   34:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 8224C8B8h case   34:*/		return 0x8224C8BC;
		  /* 8224C8BCh */ case   35:  		/* lis R8, -32252 */
		/* 8224C8BCh case   35:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8204);
		/* 8224C8BCh case   35:*/		return 0x8224C8C0;
		  /* 8224C8C0h */ case   36:  		/* lis R7, -32252 */
		/* 8224C8C0h case   36:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8204);
		/* 8224C8C0h case   36:*/		return 0x8224C8C4;
		  /* 8224C8C4h */ case   37:  		/* lis R6, -32252 */
		/* 8224C8C4h case   37:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8204);
		/* 8224C8C4h case   37:*/		return 0x8224C8C8;
		  /* 8224C8C8h */ case   38:  		/* lis R5, -32252 */
		/* 8224C8C8h case   38:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8204);
		/* 8224C8C8h case   38:*/		return 0x8224C8CC;
		  /* 8224C8CCh */ case   39:  		/* addi R10, R10, -19064 */
		/* 8224C8CCh case   39:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFB588);
		/* 8224C8CCh case   39:*/		return 0x8224C8D0;
		  /* 8224C8D0h */ case   40:  		/* addi R4, R4, 15280 */
		/* 8224C8D0h case   40:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x3BB0);
		/* 8224C8D0h case   40:*/		return 0x8224C8D4;
		  /* 8224C8D4h */ case   41:  		/* addi R3, R3, 15256 */
		/* 8224C8D4h case   41:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x3B98);
		/* 8224C8D4h case   41:*/		return 0x8224C8D8;
		  /* 8224C8D8h */ case   42:  		/* stw R10, <#[R1 + 100]> */
		/* 8224C8D8h case   42:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000064) );
		/* 8224C8D8h case   42:*/		return 0x8224C8DC;
		  /* 8224C8DCh */ case   43:  		/* addi R20, R11, 14380 */
		/* 8224C8DCh case   43:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R11,0x382C);
		/* 8224C8DCh case   43:*/		return 0x8224C8E0;
		  /* 8224C8E0h */ case   44:  		/* stw R4, <#[R1 + 104]> */
		/* 8224C8E0h case   44:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x00000068) );
		/* 8224C8E0h case   44:*/		return 0x8224C8E4;
		  /* 8224C8E4h */ case   45:  		/* addi R19, R9, 15228 */
		/* 8224C8E4h case   45:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R9,0x3B7C);
		/* 8224C8E4h case   45:*/		return 0x8224C8E8;
		  /* 8224C8E8h */ case   46:  		/* stw R3, <#[R1 + 96]> */
		/* 8224C8E8h case   46:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 8224C8E8h case   46:*/		return 0x8224C8EC;
		  /* 8224C8ECh */ case   47:  		/* addi R18, R8, 15192 */
		/* 8224C8ECh case   47:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R8,0x3B58);
		/* 8224C8ECh case   47:*/		return 0x8224C8F0;
		  /* 8224C8F0h */ case   48:  		/* addi R17, R7, 15184 */
		/* 8224C8F0h case   48:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R7,0x3B50);
		/* 8224C8F0h case   48:*/		return 0x8224C8F4;
		  /* 8224C8F4h */ case   49:  		/* addi R16, R6, 15156 */
		/* 8224C8F4h case   49:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R6,0x3B34);
		/* 8224C8F4h case   49:*/		return 0x8224C8F8;
		  /* 8224C8F8h */ case   50:  		/* addi R14, R5, 15120 */
		/* 8224C8F8h case   50:*/		cpu::op::addi<0>(regs,&regs.R14,regs.R5,0x3B10);
		/* 8224C8F8h case   50:*/		return 0x8224C8FC;
		  /* 8224C8FCh */ case   51:  		/* lwz R11, <#[R26 + 228]> */
		/* 8224C8FCh case   51:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x000000E4) );
		/* 8224C8FCh case   51:*/		return 0x8224C900;
		  /* 8224C900h */ case   52:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8224C900h case   52:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8224C900h case   52:*/		return 0x8224C904;
		  /* 8224C904h */ case   53:  		/* bc 12, CR0_EQ, 1852 */
		/* 8224C904h case   53:*/		if ( regs.CR[0].eq ) { return 0x8224D040;  }
		/* 8224C904h case   53:*/		return 0x8224C908;
		  /* 8224C908h */ case   54:  		/* rlwinm R11, R11, 0, 20, 18 */
		/* 8224C908h case   54:*/		cpu::op::rlwinm<0,0,20,18>(regs,&regs.R11,regs.R11);
		/* 8224C908h case   54:*/		return 0x8224C90C;
		  /* 8224C90Ch */ case   55:  		/* lwz R10, <#[R26]> */
		/* 8224C90Ch case   55:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 8224C90Ch case   55:*/		return 0x8224C910;
		  /* 8224C910h */ case   56:  		/* mr R3, R26 */
		/* 8224C910h case   56:*/		regs.R3 = regs.R26;
		/* 8224C910h case   56:*/		return 0x8224C914;
		  /* 8224C914h */ case   57:  		/* stw R11, <#[R26 + 228]> */
		/* 8224C914h case   57:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x000000E4) );
		/* 8224C914h case   57:*/		return 0x8224C918;
		  /* 8224C918h */ case   58:  		/* lwz R11, <#[R10 + 36]> */
		/* 8224C918h case   58:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000024) );
		/* 8224C918h case   58:*/		return 0x8224C91C;
		  /* 8224C91Ch */ case   59:  		/* mtspr CTR, R11 */
		/* 8224C91Ch case   59:*/		regs.CTR = regs.R11;
		/* 8224C91Ch case   59:*/		return 0x8224C920;
		  /* 8224C920h */ case   60:  		/* bcctrl 20, CR0_LT */
		/* 8224C920h case   60:*/		if ( 1 ) { regs.LR = 0x8224C924; return (uint32)regs.CTR; }
		/* 8224C920h case   60:*/		return 0x8224C924;
		  /* 8224C924h */ case   61:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224C924h case   61:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224C924h case   61:*/		return 0x8224C928;
		  /* 8224C928h */ case   62:  		/* bc 4, CR0_EQ, 1816 */
		/* 8224C928h case   62:*/		if ( !regs.CR[0].eq ) { return 0x8224D040;  }
		/* 8224C928h case   62:*/		return 0x8224C92C;
		  /* 8224C92Ch */ case   63:  		/* lwz R11, <#[R26]> */
		/* 8224C92Ch case   63:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8224C92Ch case   63:*/		return 0x8224C930;
		  /* 8224C930h */ case   64:  		/* mr R3, R26 */
		/* 8224C930h case   64:*/		regs.R3 = regs.R26;
		/* 8224C930h case   64:*/		return 0x8224C934;
		  /* 8224C934h */ case   65:  		/* lwz R11, <#[R11 + 40]> */
		/* 8224C934h case   65:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8224C934h case   65:*/		return 0x8224C938;
		  /* 8224C938h */ case   66:  		/* mtspr CTR, R11 */
		/* 8224C938h case   66:*/		regs.CTR = regs.R11;
		/* 8224C938h case   66:*/		return 0x8224C93C;
		  /* 8224C93Ch */ case   67:  		/* bcctrl 20, CR0_LT */
		/* 8224C93Ch case   67:*/		if ( 1 ) { regs.LR = 0x8224C940; return (uint32)regs.CTR; }
		/* 8224C93Ch case   67:*/		return 0x8224C940;
		  /* 8224C940h */ case   68:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224C940h case   68:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224C940h case   68:*/		return 0x8224C944;
		  /* 8224C944h */ case   69:  		/* bc 4, CR0_EQ, 1788 */
		/* 8224C944h case   69:*/		if ( !regs.CR[0].eq ) { return 0x8224D040;  }
		/* 8224C944h case   69:*/		return 0x8224C948;
		  /* 8224C948h */ case   70:  		/* lwz R11, <#[R26]> */
		/* 8224C948h case   70:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8224C948h case   70:*/		return 0x8224C94C;
		  /* 8224C94Ch */ case   71:  		/* mr R3, R26 */
		/* 8224C94Ch case   71:*/		regs.R3 = regs.R26;
		/* 8224C94Ch case   71:*/		return 0x8224C950;
		  /* 8224C950h */ case   72:  		/* lwz R11, <#[R11 + 44]> */
		/* 8224C950h case   72:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 8224C950h case   72:*/		return 0x8224C954;
		  /* 8224C954h */ case   73:  		/* mtspr CTR, R11 */
		/* 8224C954h case   73:*/		regs.CTR = regs.R11;
		/* 8224C954h case   73:*/		return 0x8224C958;
		  /* 8224C958h */ case   74:  		/* bcctrl 20, CR0_LT */
		/* 8224C958h case   74:*/		if ( 1 ) { regs.LR = 0x8224C95C; return (uint32)regs.CTR; }
		/* 8224C958h case   74:*/		return 0x8224C95C;
		  /* 8224C95Ch */ case   75:  		/* cmplwi CR0, R3, 0 */
		/* 8224C95Ch case   75:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8224C95Ch case   75:*/		return 0x8224C960;
		  /* 8224C960h */ case   76:  		/* mr R3, R26 */
		/* 8224C960h case   76:*/		regs.R3 = regs.R26;
		/* 8224C960h case   76:*/		return 0x8224C964;
		  /* 8224C964h */ case   77:  		/* bc 12, CR0_EQ, 152 */
		/* 8224C964h case   77:*/		if ( regs.CR[0].eq ) { return 0x8224C9FC;  }
		/* 8224C964h case   77:*/		return 0x8224C968;
		  /* 8224C968h */ case   78:  		/* bl -4512 */
		/* 8224C968h case   78:*/		regs.LR = 0x8224C96C; return 0x8224B7C8;
		/* 8224C968h case   78:*/		return 0x8224C96C;
		  /* 8224C96Ch */ case   79:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224C96Ch case   79:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224C96Ch case   79:*/		return 0x8224C970;
		  /* 8224C970h */ case   80:  		/* bc 12, CR0_EQ, 28 */
		/* 8224C970h case   80:*/		if ( regs.CR[0].eq ) { return 0x8224C98C;  }
		/* 8224C970h case   80:*/		return 0x8224C974;
		  /* 8224C974h */ case   81:  		/* mr R6, R31 */
		/* 8224C974h case   81:*/		regs.R6 = regs.R31;
		/* 8224C974h case   81:*/		return 0x8224C978;
		  /* 8224C978h */ case   82:  		/* lwz R5, <#[R1 + 96]> */
		/* 8224C978h case   82:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000060) );
		/* 8224C978h case   82:*/		return 0x8224C97C;
		  /* 8224C97Ch */ case   83:  		/* mr R4, R30 */
		/* 8224C97Ch case   83:*/		regs.R4 = regs.R30;
		/* 8224C97Ch case   83:*/		return 0x8224C980;
		  /* 8224C980h */ case   84:  		/* li R7, 882 */
		/* 8224C980h case   84:*/		cpu::op::li<0>(regs,&regs.R7,0x372);
		/* 8224C980h case   84:*/		return 0x8224C984;
		  /* 8224C984h */ case   85:  		/* li R3, 0 */
		/* 8224C984h case   85:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224C984h case   85:*/		return 0x8224C988;
		  /* 8224C988h */ case   86:  		/* bl -1002880 */
		/* 8224C988h case   86:*/		regs.LR = 0x8224C98C; return 0x82157C08;
		/* 8224C988h case   86:*/		return 0x8224C98C;
	}
	return 0x8224C98C;
} // Block from 8224C830h-8224C98Ch (87 instructions)

//////////////////////////////////////////////////////
// Block at 8224C98Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C98C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C98C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C98C);
		  /* 8224C98Ch */ case    0:  		/* lwz R11, <#[R26 + 16]> */
		/* 8224C98Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 8224C98Ch case    0:*/		return 0x8224C990;
		  /* 8224C990h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224C990h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224C990h case    1:*/		return 0x8224C994;
		  /* 8224C994h */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 8224C994h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224C9C4;  }
		/* 8224C994h case    2:*/		return 0x8224C998;
		  /* 8224C998h */ case    3:  		/* lwz R11, <#[R26 + 228]> */
		/* 8224C998h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x000000E4) );
		/* 8224C998h case    3:*/		return 0x8224C99C;
		  /* 8224C99Ch */ case    4:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 8224C99Ch case    4:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 8224C99Ch case    4:*/		return 0x8224C9A0;
		  /* 8224C9A0h */ case    5:  		/* bc 4, CR0_EQ, 36 */
		/* 8224C9A0h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8224C9C4;  }
		/* 8224C9A0h case    5:*/		return 0x8224C9A4;
		  /* 8224C9A4h */ case    6:  		/* lwz R11, <#[R26 + 80]> */
		/* 8224C9A4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000050) );
		/* 8224C9A4h case    6:*/		return 0x8224C9A8;
		  /* 8224C9A8h */ case    7:  		/* lwz R10, <#[R1 + 100]> */
		/* 8224C9A8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000064) );
		/* 8224C9A8h case    7:*/		return 0x8224C9AC;
		  /* 8224C9ACh */ case    8:  		/* mulli R11, R11, 12 */
		/* 8224C9ACh case    8:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8224C9ACh case    8:*/		return 0x8224C9B0;
		  /* 8224C9B0h */ case    9:  		/* addi R10, R10, 4 */
		/* 8224C9B0h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8224C9B0h case    9:*/		return 0x8224C9B4;
		  /* 8224C9B4h */ case   10:  		/* lbzx R11, <#[R11 + R10]> */
		/* 8224C9B4h case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8224C9B4h case   10:*/		return 0x8224C9B8;
		  /* 8224C9B8h */ case   11:  		/* cmplwi CR0, R11, 0 */
		/* 8224C9B8h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224C9B8h case   11:*/		return 0x8224C9BC;
		  /* 8224C9BCh */ case   12:  		/* li R11, 1 */
		/* 8224C9BCh case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224C9BCh case   12:*/		return 0x8224C9C0;
		  /* 8224C9C0h */ case   13:  		/* bc 4, CR0_EQ, 8 */
		/* 8224C9C0h case   13:*/		if ( !regs.CR[0].eq ) { return 0x8224C9C8;  }
		/* 8224C9C0h case   13:*/		return 0x8224C9C4;
	}
	return 0x8224C9C4;
} // Block from 8224C98Ch-8224C9C4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224C9C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C9C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C9C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C9C4);
		  /* 8224C9C4h */ case    0:  		/* mr R11, R15 */
		/* 8224C9C4h case    0:*/		regs.R11 = regs.R15;
		/* 8224C9C4h case    0:*/		return 0x8224C9C8;
	}
	return 0x8224C9C8;
} // Block from 8224C9C4h-8224C9C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224C9C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C9C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C9C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C9C8);
		  /* 8224C9C8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8224C9C8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8224C9C8h case    0:*/		return 0x8224C9CC;
		  /* 8224C9CCh */ case    1:  		/* bc 12, CR0_EQ, 1652 */
		/* 8224C9CCh case    1:*/		if ( regs.CR[0].eq ) { return 0x8224D040;  }
		/* 8224C9CCh case    1:*/		return 0x8224C9D0;
		  /* 8224C9D0h */ case    2:  		/* lwz R11, <#[R26 + 228]> */
		/* 8224C9D0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x000000E4) );
		/* 8224C9D0h case    2:*/		return 0x8224C9D4;
		  /* 8224C9D4h */ case    3:  		/* rlwinm. R11, R11, 26, 31, 31 */
		/* 8224C9D4h case    3:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R11,regs.R11);
		/* 8224C9D4h case    3:*/		return 0x8224C9D8;
		  /* 8224C9D8h */ case    4:  		/* bc 4, CR0_EQ, 1640 */
		/* 8224C9D8h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8224D040;  }
		/* 8224C9D8h case    4:*/		return 0x8224C9DC;
		  /* 8224C9DCh */ case    5:  		/* lwz R10, <#[R23]> */
		/* 8224C9DCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000000) );
		/* 8224C9DCh case    5:*/		return 0x8224C9E0;
		  /* 8224C9E0h */ case    6:  		/* lwz R9, <#[R26 + 80]> */
		/* 8224C9E0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000050) );
		/* 8224C9E0h case    6:*/		return 0x8224C9E4;
		  /* 8224C9E4h */ case    7:  		/* lwz R11, <#[R10 + 1524]> */
		/* 8224C9E4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005F4) );
		/* 8224C9E4h case    7:*/		return 0x8224C9E8;
		  /* 8224C9E8h */ case    8:  		/* addi R11, R11, 1 */
		/* 8224C9E8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224C9E8h case    8:*/		return 0x8224C9EC;
		  /* 8224C9ECh */ case    9:  		/* stw R11, <#[R10 + 1524]> */
		/* 8224C9ECh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x000005F4) );
		/* 8224C9ECh case    9:*/		return 0x8224C9F0;
		  /* 8224C9F0h */ case   10:  		/* stw R11, <#[R26 + 56]> */
		/* 8224C9F0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000038) );
		/* 8224C9F0h case   10:*/		return 0x8224C9F4;
		  /* 8224C9F4h */ case   11:  		/* stw R9, <#[R26 + 80]> */
		/* 8224C9F4h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R26 + 0x00000050) );
		/* 8224C9F4h case   11:*/		return 0x8224C9F8;
		  /* 8224C9F8h */ case   12:  		/* b 1608 */
		/* 8224C9F8h case   12:*/		return 0x8224D040;
		/* 8224C9F8h case   12:*/		return 0x8224C9FC;
	}
	return 0x8224C9FC;
} // Block from 8224C9C8h-8224C9FCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224C9FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224C9FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224C9FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224C9FC);
		  /* 8224C9FCh */ case    0:  		/* bl 107044 */
		/* 8224C9FCh case    0:*/		regs.LR = 0x8224CA00; return 0x82266C20;
		/* 8224C9FCh case    0:*/		return 0x8224CA00;
		  /* 8224CA00h */ case    1:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224CA00h case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224CA00h case    1:*/		return 0x8224CA04;
		  /* 8224CA04h */ case    2:  		/* bc 4, CR0_EQ, 36 */
		/* 8224CA04h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8224CA28;  }
		/* 8224CA04h case    2:*/		return 0x8224CA08;
		  /* 8224CA08h */ case    3:  		/* mr R3, R26 */
		/* 8224CA08h case    3:*/		regs.R3 = regs.R26;
		/* 8224CA08h case    3:*/		return 0x8224CA0C;
		  /* 8224CA0Ch */ case    4:  		/* bl 107236 */
		/* 8224CA0Ch case    4:*/		regs.LR = 0x8224CA10; return 0x82266CF0;
		/* 8224CA0Ch case    4:*/		return 0x8224CA10;
		  /* 8224CA10h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224CA10h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224CA10h case    5:*/		return 0x8224CA14;
		  /* 8224CA14h */ case    6:  		/* bc 4, CR0_EQ, 20 */
		/* 8224CA14h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8224CA28;  }
		/* 8224CA14h case    6:*/		return 0x8224CA18;
		  /* 8224CA18h */ case    7:  		/* mr R3, R26 */
		/* 8224CA18h case    7:*/		regs.R3 = regs.R26;
		/* 8224CA18h case    7:*/		return 0x8224CA1C;
		  /* 8224CA1Ch */ case    8:  		/* bl 107164 */
		/* 8224CA1Ch case    8:*/		regs.LR = 0x8224CA20; return 0x82266CB8;
		/* 8224CA1Ch case    8:*/		return 0x8224CA20;
		  /* 8224CA20h */ case    9:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224CA20h case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224CA20h case    9:*/		return 0x8224CA24;
		  /* 8224CA24h */ case   10:  		/* bc 12, CR0_EQ, 12 */
		/* 8224CA24h case   10:*/		if ( regs.CR[0].eq ) { return 0x8224CA30;  }
		/* 8224CA24h case   10:*/		return 0x8224CA28;
	}
	return 0x8224CA28;
} // Block from 8224C9FCh-8224CA28h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224CA28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CA28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CA28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CA28);
		  /* 8224CA28h */ case    0:  		/* li R11, 1 */
		/* 8224CA28h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224CA28h case    0:*/		return 0x8224CA2C;
		  /* 8224CA2Ch */ case    1:  		/* stb R11, <#[R1 + 80]> */
		/* 8224CA2Ch case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8224CA2Ch case    1:*/		return 0x8224CA30;
	}
	return 0x8224CA30;
} // Block from 8224CA28h-8224CA30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224CA30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CA30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CA30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CA30);
		  /* 8224CA30h */ case    0:  		/* stw R29, <#[R26 + 892]> */
		/* 8224CA30h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R26 + 0x0000037C) );
		/* 8224CA30h case    0:*/		return 0x8224CA34;
		  /* 8224CA34h */ case    1:  		/* li R4, 72 */
		/* 8224CA34h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x48);
		/* 8224CA34h case    1:*/		return 0x8224CA38;
		  /* 8224CA38h */ case    2:  		/* lwz R11, <#[R23]> */
		/* 8224CA38h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8224CA38h case    2:*/		return 0x8224CA3C;
		  /* 8224CA3Ch */ case    3:  		/* lwz R31, <#[R11 + 1456]> */
		/* 8224CA3Ch case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224CA3Ch case    3:*/		return 0x8224CA40;
		  /* 8224CA40h */ case    4:  		/* mr R3, R31 */
		/* 8224CA40h case    4:*/		regs.R3 = regs.R31;
		/* 8224CA40h case    4:*/		return 0x8224CA44;
		  /* 8224CA44h */ case    5:  		/* bl -198028 */
		/* 8224CA44h case    5:*/		regs.LR = 0x8224CA48; return 0x8221C4B8;
		/* 8224CA44h case    5:*/		return 0x8224CA48;
		  /* 8224CA48h */ case    6:  		/* addic. R11, R3, 4 */
		/* 8224CA48h case    6:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R3,0x4);
		/* 8224CA48h case    6:*/		return 0x8224CA4C;
		  /* 8224CA4Ch */ case    7:  		/* stw R31, <#[R3]> */
		/* 8224CA4Ch case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 8224CA4Ch case    7:*/		return 0x8224CA50;
		  /* 8224CA50h */ case    8:  		/* bc 12, CR0_EQ, 84 */
		/* 8224CA50h case    8:*/		if ( regs.CR[0].eq ) { return 0x8224CAA4;  }
		/* 8224CA50h case    8:*/		return 0x8224CA54;
		  /* 8224CA54h */ case    9:  		/* li R10, -1 */
		/* 8224CA54h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8224CA54h case    9:*/		return 0x8224CA58;
		  /* 8224CA58h */ case   10:  		/* stfs FR31, <#[R11 + 16]> */
		/* 8224CA58h case   10:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R11 + 0x00000010) );
		/* 8224CA58h case   10:*/		return 0x8224CA5C;
		  /* 8224CA5Ch */ case   11:  		/* stw R26, <#[R11 + 40]> */
		/* 8224CA5Ch case   11:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000028) );
		/* 8224CA5Ch case   11:*/		return 0x8224CA60;
		  /* 8224CA60h */ case   12:  		/* mr R24, R11 */
		/* 8224CA60h case   12:*/		regs.R24 = regs.R11;
		/* 8224CA60h case   12:*/		return 0x8224CA64;
		  /* 8224CA64h */ case   13:  		/* stw R15, <#[R11 + 4]> */
		/* 8224CA64h case   13:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R11 + 0x00000004) );
		/* 8224CA64h case   13:*/		return 0x8224CA68;
		  /* 8224CA68h */ case   14:  		/* stw R15, <#[R11 + 8]> */
		/* 8224CA68h case   14:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R11 + 0x00000008) );
		/* 8224CA68h case   14:*/		return 0x8224CA6C;
		  /* 8224CA6Ch */ case   15:  		/* stw R20, <#[R11]> */
		/* 8224CA6Ch case   15:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R11 + 0x00000000) );
		/* 8224CA6Ch case   15:*/		return 0x8224CA70;
		  /* 8224CA70h */ case   16:  		/* stw R10, <#[R11 + 28]> */
		/* 8224CA70h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000001C) );
		/* 8224CA70h case   16:*/		return 0x8224CA74;
		  /* 8224CA74h */ case   17:  		/* stw R15, <#[R11 + 32]> */
		/* 8224CA74h case   17:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R11 + 0x00000020) );
		/* 8224CA74h case   17:*/		return 0x8224CA78;
	}
	return 0x8224CA78;
} // Block from 8224CA30h-8224CA78h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8224CA78h
// Function '??_GParallelGroup@XGRAPHICS@@QAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CA78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CA78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CA78);
		  /* 8224CA78h */ case    0:  		/* stw R15, <#[R11 + 36]> */
		/* 8224CA78h case    0:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R11 + 0x00000024) );
		/* 8224CA78h case    0:*/		return 0x8224CA7C;
		  /* 8224CA7Ch */ case    1:  		/* stw R29, <#[R11 + 44]> */
		/* 8224CA7Ch case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x0000002C) );
		/* 8224CA7Ch case    1:*/		return 0x8224CA80;
		  /* 8224CA80h */ case    2:  		/* stw R15, <#[R11 + 48]> */
		/* 8224CA80h case    2:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R11 + 0x00000030) );
		/* 8224CA80h case    2:*/		return 0x8224CA84;
		  /* 8224CA84h */ case    3:  		/* stw R15, <#[R11 + 52]> */
		/* 8224CA84h case    3:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R11 + 0x00000034) );
		/* 8224CA84h case    3:*/		return 0x8224CA88;
		  /* 8224CA88h */ case    4:  		/* stb R15, <#[R11 + 56]> */
		/* 8224CA88h case    4:*/		cpu::mem::store8( regs, regs.R15, (uint32)(regs.R11 + 0x00000038) );
		/* 8224CA88h case    4:*/		return 0x8224CA8C;
		  /* 8224CA8Ch */ case    5:  		/* stw R15, <#[R11 + 60]> */
		/* 8224CA8Ch case    5:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R11 + 0x0000003C) );
		/* 8224CA8Ch case    5:*/		return 0x8224CA90;
		  /* 8224CA90h */ case    6:  		/* stw R15, <#[R11 + 64]> */
		/* 8224CA90h case    6:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R11 + 0x00000040) );
		/* 8224CA90h case    6:*/		return 0x8224CA94;
		  /* 8224CA94h */ case    7:  		/* stw R15, <#[R11 + 12]> */
		/* 8224CA94h case    7:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R11 + 0x0000000C) );
		/* 8224CA94h case    7:*/		return 0x8224CA98;
		  /* 8224CA98h */ case    8:  		/* stw R15, <#[R11 + 20]> */
		/* 8224CA98h case    8:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R11 + 0x00000014) );
		/* 8224CA98h case    8:*/		return 0x8224CA9C;
		  /* 8224CA9Ch */ case    9:  		/* stw R15, <#[R11 + 24]> */
		/* 8224CA9Ch case    9:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R11 + 0x00000018) );
		/* 8224CA9Ch case    9:*/		return 0x8224CAA0;
		  /* 8224CAA0h */ case   10:  		/* b 8 */
		/* 8224CAA0h case   10:*/		return 0x8224CAA8;
		/* 8224CAA0h case   10:*/		return 0x8224CAA4;
	}
	return 0x8224CAA4;
} // Block from 8224CA78h-8224CAA4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224CAA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CAA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CAA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CAA4);
		  /* 8224CAA4h */ case    0:  		/* mr R24, R15 */
		/* 8224CAA4h case    0:*/		regs.R24 = regs.R15;
		/* 8224CAA4h case    0:*/		return 0x8224CAA8;
	}
	return 0x8224CAA8;
} // Block from 8224CAA4h-8224CAA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224CAA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CAA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CAA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CAA8);
		  /* 8224CAA8h */ case    0:  		/* mr R3, R26 */
		/* 8224CAA8h case    0:*/		regs.R3 = regs.R26;
		/* 8224CAA8h case    0:*/		return 0x8224CAAC;
		  /* 8224CAACh */ case    1:  		/* bl -4836 */
		/* 8224CAACh case    1:*/		regs.LR = 0x8224CAB0; return 0x8224B7C8;
		/* 8224CAACh case    1:*/		return 0x8224CAB0;
		  /* 8224CAB0h */ case    2:  		/* stb R3, <#[R24 + 56]> */
		/* 8224CAB0h case    2:*/		cpu::mem::store8( regs, regs.R3, (uint32)(regs.R24 + 0x00000038) );
		/* 8224CAB0h case    2:*/		return 0x8224CAB4;
		  /* 8224CAB4h */ case    3:  		/* li R4, 20 */
		/* 8224CAB4h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 8224CAB4h case    3:*/		return 0x8224CAB8;
		  /* 8224CAB8h */ case    4:  		/* lwz R11, <#[R23]> */
		/* 8224CAB8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8224CAB8h case    4:*/		return 0x8224CABC;
		  /* 8224CABCh */ case    5:  		/* lwz R28, <#[R11 + 1456]> */
		/* 8224CABCh case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224CABCh case    5:*/		return 0x8224CAC0;
		  /* 8224CAC0h */ case    6:  		/* mr R3, R28 */
		/* 8224CAC0h case    6:*/		regs.R3 = regs.R28;
		/* 8224CAC0h case    6:*/		return 0x8224CAC4;
		  /* 8224CAC4h */ case    7:  		/* bl -198156 */
		/* 8224CAC4h case    7:*/		regs.LR = 0x8224CAC8; return 0x8221C4B8;
		/* 8224CAC4h case    7:*/		return 0x8224CAC8;
		  /* 8224CAC8h */ case    8:  		/* addic. R31, R3, 4 */
		/* 8224CAC8h case    8:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R3,0x4);
		/* 8224CAC8h case    8:*/		return 0x8224CACC;
		  /* 8224CACCh */ case    9:  		/* stw R28, <#[R3]> */
		/* 8224CACCh case    9:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 8224CACCh case    9:*/		return 0x8224CAD0;
	}
	return 0x8224CAD0;
} // Block from 8224CAA8h-8224CAD0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224CAD0h
// Function '?MarkGlobalDefs@Scheduler@XGRAPHICS@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CAD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CAD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CAD0);
		  /* 8224CAD0h */ case    0:  		/* bc 12, CR0_EQ, 24 */
		/* 8224CAD0h case    0:*/		if ( regs.CR[0].eq ) { return 0x8224CAE8;  }
		/* 8224CAD0h case    0:*/		return 0x8224CAD4;
		  /* 8224CAD4h */ case    1:  		/* lwz R11, <#[R23]> */
		/* 8224CAD4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8224CAD4h case    1:*/		return 0x8224CAD8;
		  /* 8224CAD8h */ case    2:  		/* mr R3, R31 */
		/* 8224CAD8h case    2:*/		regs.R3 = regs.R31;
		/* 8224CAD8h case    2:*/		return 0x8224CADC;
		  /* 8224CADCh */ case    3:  		/* lwz R4, <#[R11 + 1456]> */
		/* 8224CADCh case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224CADCh case    3:*/		return 0x8224CAE0;
		  /* 8224CAE0h */ case    4:  		/* bl -93568 */
		/* 8224CAE0h case    4:*/		regs.LR = 0x8224CAE4; return 0x82235D60;
		/* 8224CAE0h case    4:*/		return 0x8224CAE4;
		  /* 8224CAE4h */ case    5:  		/* b 8 */
		/* 8224CAE4h case    5:*/		return 0x8224CAEC;
		/* 8224CAE4h case    5:*/		return 0x8224CAE8;
	}
	return 0x8224CAE8;
} // Block from 8224CAD0h-8224CAE8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224CAE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CAE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CAE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CAE8);
		  /* 8224CAE8h */ case    0:  		/* mr R31, R15 */
		/* 8224CAE8h case    0:*/		regs.R31 = regs.R15;
		/* 8224CAE8h case    0:*/		return 0x8224CAEC;
	}
	return 0x8224CAEC;
} // Block from 8224CAE8h-8224CAECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224CAECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CAEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CAEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CAEC);
		  /* 8224CAECh */ case    0:  		/* stw R31, <#[R24 + 52]> */
		/* 8224CAECh case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R24 + 0x00000034) );
		/* 8224CAECh case    0:*/		return 0x8224CAF0;
		  /* 8224CAF0h */ case    1:  		/* li R4, 20 */
		/* 8224CAF0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 8224CAF0h case    1:*/		return 0x8224CAF4;
		  /* 8224CAF4h */ case    2:  		/* lwz R11, <#[R23]> */
		/* 8224CAF4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8224CAF4h case    2:*/		return 0x8224CAF8;
		  /* 8224CAF8h */ case    3:  		/* lwz R28, <#[R11 + 1456]> */
		/* 8224CAF8h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224CAF8h case    3:*/		return 0x8224CAFC;
		  /* 8224CAFCh */ case    4:  		/* mr R3, R28 */
		/* 8224CAFCh case    4:*/		regs.R3 = regs.R28;
		/* 8224CAFCh case    4:*/		return 0x8224CB00;
		  /* 8224CB00h */ case    5:  		/* bl -198216 */
		/* 8224CB00h case    5:*/		regs.LR = 0x8224CB04; return 0x8221C4B8;
		/* 8224CB00h case    5:*/		return 0x8224CB04;
		  /* 8224CB04h */ case    6:  		/* addic. R31, R3, 4 */
		/* 8224CB04h case    6:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R3,0x4);
		/* 8224CB04h case    6:*/		return 0x8224CB08;
		  /* 8224CB08h */ case    7:  		/* stw R28, <#[R3]> */
		/* 8224CB08h case    7:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 8224CB08h case    7:*/		return 0x8224CB0C;
		  /* 8224CB0Ch */ case    8:  		/* bc 12, CR0_EQ, 24 */
		/* 8224CB0Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x8224CB24;  }
		/* 8224CB0Ch case    8:*/		return 0x8224CB10;
		  /* 8224CB10h */ case    9:  		/* lwz R11, <#[R23]> */
		/* 8224CB10h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8224CB10h case    9:*/		return 0x8224CB14;
		  /* 8224CB14h */ case   10:  		/* mr R3, R31 */
		/* 8224CB14h case   10:*/		regs.R3 = regs.R31;
		/* 8224CB14h case   10:*/		return 0x8224CB18;
		  /* 8224CB18h */ case   11:  		/* lwz R4, <#[R11 + 1456]> */
		/* 8224CB18h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224CB18h case   11:*/		return 0x8224CB1C;
		  /* 8224CB1Ch */ case   12:  		/* bl -93628 */
		/* 8224CB1Ch case   12:*/		regs.LR = 0x8224CB20; return 0x82235D60;
		/* 8224CB1Ch case   12:*/		return 0x8224CB20;
		  /* 8224CB20h */ case   13:  		/* b 8 */
		/* 8224CB20h case   13:*/		return 0x8224CB28;
		/* 8224CB20h case   13:*/		return 0x8224CB24;
	}
	return 0x8224CB24;
} // Block from 8224CAECh-8224CB24h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224CB24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CB24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CB24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CB24);
		  /* 8224CB24h */ case    0:  		/* mr R31, R15 */
		/* 8224CB24h case    0:*/		regs.R31 = regs.R15;
		/* 8224CB24h case    0:*/		return 0x8224CB28;
	}
	return 0x8224CB28;
} // Block from 8224CB24h-8224CB28h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224CB28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CB28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CB28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CB28);
		  /* 8224CB28h */ case    0:  		/* stw R31, <#[R24 + 48]> */
		/* 8224CB28h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R24 + 0x00000030) );
		/* 8224CB28h case    0:*/		return 0x8224CB2C;
		  /* 8224CB2Ch */ case    1:  		/* li R25, 1 */
		/* 8224CB2Ch case    1:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 8224CB2Ch case    1:*/		return 0x8224CB30;
		  /* 8224CB30h */ case    2:  		/* lwz R11, <#[R26 + 20]> */
		/* 8224CB30h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 8224CB30h case    2:*/		return 0x8224CB34;
		  /* 8224CB34h */ case    3:  		/* cmpwi CR6, R11, 1 */
		/* 8224CB34h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 8224CB34h case    3:*/		return 0x8224CB38;
		  /* 8224CB38h */ case    4:  		/* bc 12, CR6_LT, 804 */
		/* 8224CB38h case    4:*/		if ( regs.CR[6].lt ) { return 0x8224CE5C;  }
		/* 8224CB38h case    4:*/		return 0x8224CB3C;
		  /* 8224CB3Ch */ case    5:  		/* addi R21, R26, 236 */
		/* 8224CB3Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R26,0xEC);
		/* 8224CB3Ch case    5:*/		return 0x8224CB40;
		  /* 8224CB40h */ case    6:  		/* mr R22, R21 */
		/* 8224CB40h case    6:*/		regs.R22 = regs.R21;
		/* 8224CB40h case    6:*/		return 0x8224CB44;
		  /* 8224CB44h */ case    7:  		/* lwz R11, <#[R22]> */
		/* 8224CB44h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 8224CB44h case    7:*/		return 0x8224CB48;
		  /* 8224CB48h */ case    8:  		/* cmpwi CR6, R11, 0 */
		/* 8224CB48h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224CB48h case    8:*/		return 0x8224CB4C;
		  /* 8224CB4Ch */ case    9:  		/* bc 4, CR6_EQ, 28 */
		/* 8224CB4Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x8224CB68;  }
		/* 8224CB4Ch case    9:*/		return 0x8224CB50;
		  /* 8224CB50h */ case   10:  		/* mr R4, R30 */
		/* 8224CB50h case   10:*/		regs.R4 = regs.R30;
		/* 8224CB50h case   10:*/		return 0x8224CB54;
		  /* 8224CB54h */ case   11:  		/* lwz R6, <#[R1 + 84]> */
		/* 8224CB54h case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 8224CB54h case   11:*/		return 0x8224CB58;
		  /* 8224CB58h */ case   12:  		/* li R7, 905 */
		/* 8224CB58h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x389);
		/* 8224CB58h case   12:*/		return 0x8224CB5C;
		  /* 8224CB5Ch */ case   13:  		/* lwz R5, <#[R1 + 104]> */
		/* 8224CB5Ch case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000068) );
		/* 8224CB5Ch case   13:*/		return 0x8224CB60;
		  /* 8224CB60h */ case   14:  		/* li R3, 0 */
		/* 8224CB60h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224CB60h case   14:*/		return 0x8224CB64;
		  /* 8224CB64h */ case   15:  		/* bl -1003356 */
		/* 8224CB64h case   15:*/		regs.LR = 0x8224CB68; return 0x82157C08;
		/* 8224CB64h case   15:*/		return 0x8224CB68;
	}
	return 0x8224CB68;
} // Block from 8224CB28h-8224CB68h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8224CB68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CB68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CB68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CB68);
		  /* 8224CB68h */ case    0:  		/* lwz R27, <#[R22]> */
		/* 8224CB68h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R22 + 0x00000000) );
		/* 8224CB68h case    0:*/		return 0x8224CB6C;
		  /* 8224CB6Ch */ case    1:  		/* mr R3, R27 */
		/* 8224CB6Ch case    1:*/		regs.R3 = regs.R27;
		/* 8224CB6Ch case    1:*/		return 0x8224CB70;
		  /* 8224CB70h */ case    2:  		/* lwz R11, <#[R27]> */
		/* 8224CB70h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8224CB70h case    2:*/		return 0x8224CB74;
		  /* 8224CB74h */ case    3:  		/* lwz R11, <#[R11 + 44]> */
		/* 8224CB74h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 8224CB74h case    3:*/		return 0x8224CB78;
		  /* 8224CB78h */ case    4:  		/* mtspr CTR, R11 */
		/* 8224CB78h case    4:*/		regs.CTR = regs.R11;
		/* 8224CB78h case    4:*/		return 0x8224CB7C;
		  /* 8224CB7Ch */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 8224CB7Ch case    5:*/		if ( 1 ) { regs.LR = 0x8224CB80; return (uint32)regs.CTR; }
		/* 8224CB7Ch case    5:*/		return 0x8224CB80;
		  /* 8224CB80h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 8224CB80h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8224CB80h case    6:*/		return 0x8224CB84;
		  /* 8224CB84h */ case    7:  		/* bc 4, CR0_EQ, 136 */
		/* 8224CB84h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8224CC0C;  }
		/* 8224CB84h case    7:*/		return 0x8224CB88;
		  /* 8224CB88h */ case    8:  		/* lwz R11, <#[R27 + 948]> */
		/* 8224CB88h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x000003B4) );
		/* 8224CB88h case    8:*/		return 0x8224CB8C;
		  /* 8224CB8Ch */ case    9:  		/* lwz R10, <#[R23 + 16]> */
		/* 8224CB8Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000010) );
		/* 8224CB8Ch case    9:*/		return 0x8224CB90;
		  /* 8224CB90h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 8224CB90h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8224CB90h case   10:*/		return 0x8224CB94;
		  /* 8224CB94h */ case   11:  		/* bc 4, CR6_EQ, 120 */
		/* 8224CB94h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8224CC0C;  }
		/* 8224CB94h case   11:*/		return 0x8224CB98;
		  /* 8224CB98h */ case   12:  		/* lwz R11, <#[R27 + 892]> */
		/* 8224CB98h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000037C) );
		/* 8224CB98h case   12:*/		return 0x8224CB9C;
		  /* 8224CB9Ch */ case   13:  		/* cmpw CR6, R11, R29 */
		/* 8224CB9Ch case   13:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R29);
		/* 8224CB9Ch case   13:*/		return 0x8224CBA0;
		  /* 8224CBA0h */ case   14:  		/* bc 12, CR6_LT, 24 */
		/* 8224CBA0h case   14:*/		if ( regs.CR[6].lt ) { return 0x8224CBB8;  }
		/* 8224CBA0h case   14:*/		return 0x8224CBA4;
		  /* 8224CBA4h */ case   15:  		/* mr R5, R14 */
		/* 8224CBA4h case   15:*/		regs.R5 = regs.R14;
		/* 8224CBA4h case   15:*/		return 0x8224CBA8;
		  /* 8224CBA8h */ case   16:  		/* lwz R6, <#[R1 + 84]> */
		/* 8224CBA8h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 8224CBA8h case   16:*/		return 0x8224CBAC;
		  /* 8224CBACh */ case   17:  		/* mr R4, R30 */
		/* 8224CBACh case   17:*/		regs.R4 = regs.R30;
		/* 8224CBACh case   17:*/		return 0x8224CBB0;
		  /* 8224CBB0h */ case   18:  		/* li R7, 914 */
		/* 8224CBB0h case   18:*/		cpu::op::li<0>(regs,&regs.R7,0x392);
		/* 8224CBB0h case   18:*/		return 0x8224CBB4;
		  /* 8224CBB4h */ case   19:  		/* bl -1003436 */
		/* 8224CBB4h case   19:*/		regs.LR = 0x8224CBB8; return 0x82157C08;
		/* 8224CBB4h case   19:*/		return 0x8224CBB8;
	}
	return 0x8224CBB8;
} // Block from 8224CB68h-8224CBB8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8224CBB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CBB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CBB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CBB8);
		  /* 8224CBB8h */ case    0:  		/* lwz R3, <#[R23 + 24]> */
		/* 8224CBB8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000018) );
		/* 8224CBB8h case    0:*/		return 0x8224CBBC;
		  /* 8224CBBCh */ case    1:  		/* lwz R4, <#[R27 + 892]> */
		/* 8224CBBCh case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x0000037C) );
		/* 8224CBBCh case    1:*/		return 0x8224CBC0;
		  /* 8224CBC0h */ case    2:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224CBC0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224CBC0h case    2:*/		return 0x8224CBC4;
		  /* 8224CBC4h */ case    3:  		/* cmplw CR6, R4, R11 */
		/* 8224CBC4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 8224CBC4h case    3:*/		return 0x8224CBC8;
		  /* 8224CBC8h */ case    4:  		/* bc 4, CR6_LT, 20 */
		/* 8224CBC8h case    4:*/		if ( !regs.CR[6].lt ) { return 0x8224CBDC;  }
		/* 8224CBC8h case    4:*/		return 0x8224CBCC;
		  /* 8224CBCCh */ case    5:  		/* lwz R10, <#[R3 + 8]> */
		/* 8224CBCCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 8224CBCCh case    5:*/		return 0x8224CBD0;
		  /* 8224CBD0h */ case    6:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 8224CBD0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 8224CBD0h case    6:*/		return 0x8224CBD4;
		  /* 8224CBD4h */ case    7:  		/* add R3, R10, R11 */
		/* 8224CBD4h case    7:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8224CBD4h case    7:*/		return 0x8224CBD8;
		  /* 8224CBD8h */ case    8:  		/* b 8 */
		/* 8224CBD8h case    8:*/		return 0x8224CBE0;
		/* 8224CBD8h case    8:*/		return 0x8224CBDC;
	}
	return 0x8224CBDC;
} // Block from 8224CBB8h-8224CBDCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224CBDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CBDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CBDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CBDC);
		  /* 8224CBDCh */ case    0:  		/* bl 28388 */
		/* 8224CBDCh case    0:*/		regs.LR = 0x8224CBE0; return 0x82253AC0;
		/* 8224CBDCh case    0:*/		return 0x8224CBE0;
	}
	return 0x8224CBE0;
} // Block from 8224CBDCh-8224CBE0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224CBE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CBE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CBE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CBE0);
		  /* 8224CBE0h */ case    0:  		/* lwz R28, <#[R3]> */
		/* 8224CBE0h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 8224CBE0h case    0:*/		return 0x8224CBE4;
		  /* 8224CBE4h */ case    1:  		/* lwz R11, <#[R28 + 40]> */
		/* 8224CBE4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000028) );
		/* 8224CBE4h case    1:*/		return 0x8224CBE8;
		  /* 8224CBE8h */ case    2:  		/* cmplw CR6, R11, R27 */
		/* 8224CBE8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 8224CBE8h case    2:*/		return 0x8224CBEC;
		  /* 8224CBECh */ case    3:  		/* bc 12, CR6_EQ, 48 */
		/* 8224CBECh case    3:*/		if ( regs.CR[6].eq ) { return 0x8224CC1C;  }
		/* 8224CBECh case    3:*/		return 0x8224CBF0;
		  /* 8224CBF0h */ case    4:  		/* mr R5, R16 */
		/* 8224CBF0h case    4:*/		regs.R5 = regs.R16;
		/* 8224CBF0h case    4:*/		return 0x8224CBF4;
		  /* 8224CBF4h */ case    5:  		/* lwz R6, <#[R1 + 84]> */
		/* 8224CBF4h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 8224CBF4h case    5:*/		return 0x8224CBF8;
		  /* 8224CBF8h */ case    6:  		/* mr R4, R30 */
		/* 8224CBF8h case    6:*/		regs.R4 = regs.R30;
		/* 8224CBF8h case    6:*/		return 0x8224CBFC;
		  /* 8224CBFCh */ case    7:  		/* li R7, 916 */
		/* 8224CBFCh case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x394);
		/* 8224CBFCh case    7:*/		return 0x8224CC00;
		  /* 8224CC00h */ case    8:  		/* li R3, 0 */
		/* 8224CC00h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224CC00h case    8:*/		return 0x8224CC04;
		  /* 8224CC04h */ case    9:  		/* bl -1003516 */
		/* 8224CC04h case    9:*/		regs.LR = 0x8224CC08; return 0x82157C08;
		/* 8224CC04h case    9:*/		return 0x8224CC08;
		  /* 8224CC08h */ case   10:  		/* b 20 */
		/* 8224CC08h case   10:*/		return 0x8224CC1C;
		/* 8224CC08h case   10:*/		return 0x8224CC0C;
	}
	return 0x8224CC0C;
} // Block from 8224CBE0h-8224CC0Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224CC0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CC0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CC0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CC0C);
		  /* 8224CC0Ch */ case    0:  		/* mr R4, R27 */
		/* 8224CC0Ch case    0:*/		regs.R4 = regs.R27;
		/* 8224CC0Ch case    0:*/		return 0x8224CC10;
		  /* 8224CC10h */ case    1:  		/* mr R3, R23 */
		/* 8224CC10h case    1:*/		regs.R3 = regs.R23;
		/* 8224CC10h case    1:*/		return 0x8224CC14;
		  /* 8224CC14h */ case    2:  		/* bl -1468 */
		/* 8224CC14h case    2:*/		regs.LR = 0x8224CC18; return 0x8224C658;
		/* 8224CC14h case    2:*/		return 0x8224CC18;
		  /* 8224CC18h */ case    3:  		/* mr R28, R3 */
		/* 8224CC18h case    3:*/		regs.R28 = regs.R3;
		/* 8224CC18h case    3:*/		return 0x8224CC1C;
	}
	return 0x8224CC1C;
} // Block from 8224CC0Ch-8224CC1Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224CC1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CC1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CC1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CC1C);
		  /* 8224CC1Ch */ case    0:  		/* lwz R11, <#[R23]> */
		/* 8224CC1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8224CC1Ch case    0:*/		return 0x8224CC20;
		  /* 8224CC20h */ case    1:  		/* li R4, 24 */
		/* 8224CC20h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 8224CC20h case    1:*/		return 0x8224CC24;
		  /* 8224CC24h */ case    2:  		/* lwz R11, <#[R11 + 1456]> */
		/* 8224CC24h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224CC24h case    2:*/		return 0x8224CC28;
		  /* 8224CC28h */ case    3:  		/* mr R3, R11 */
		/* 8224CC28h case    3:*/		regs.R3 = regs.R11;
		/* 8224CC28h case    3:*/		return 0x8224CC2C;
		  /* 8224CC2Ch */ case    4:  		/* stw R11, <#[R1 + 108]> */
		/* 8224CC2Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 8224CC2Ch case    4:*/		return 0x8224CC30;
		  /* 8224CC30h */ case    5:  		/* bl -198520 */
		/* 8224CC30h case    5:*/		regs.LR = 0x8224CC34; return 0x8221C4B8;
		/* 8224CC30h case    5:*/		return 0x8224CC34;
		  /* 8224CC34h */ case    6:  		/* lwz R11, <#[R1 + 108]> */
		/* 8224CC34h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 8224CC34h case    6:*/		return 0x8224CC38;
		  /* 8224CC38h */ case    7:  		/* addi R31, R3, 4 */
		/* 8224CC38h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x4);
		/* 8224CC38h case    7:*/		return 0x8224CC3C;
		  /* 8224CC3Ch */ case    8:  		/* li R7, 0 */
		/* 8224CC3Ch case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8224CC3Ch case    8:*/		return 0x8224CC40;
		  /* 8224CC40h */ case    9:  		/* mr R6, R25 */
		/* 8224CC40h case    9:*/		regs.R6 = regs.R25;
		/* 8224CC40h case    9:*/		return 0x8224CC44;
		  /* 8224CC44h */ case   10:  		/* li R5, 0 */
		/* 8224CC44h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8224CC44h case   10:*/		return 0x8224CC48;
		  /* 8224CC48h */ case   11:  		/* mr R4, R26 */
		/* 8224CC48h case   11:*/		regs.R4 = regs.R26;
		/* 8224CC48h case   11:*/		return 0x8224CC4C;
		  /* 8224CC4Ch */ case   12:  		/* stw R11, <#[R3]> */
		/* 8224CC4Ch case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224CC4Ch case   12:*/		return 0x8224CC50;
		  /* 8224CC50h */ case   13:  		/* stw R28, <#[R3 + 4]> */
		/* 8224CC50h case   13:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000004) );
		/* 8224CC50h case   13:*/		return 0x8224CC54;
		  /* 8224CC54h */ case   14:  		/* mr R3, R27 */
		/* 8224CC54h case   14:*/		regs.R3 = regs.R27;
		/* 8224CC54h case   14:*/		return 0x8224CC58;
		  /* 8224CC58h */ case   15:  		/* stw R24, <#[R31 + 4]> */
		/* 8224CC58h case   15:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000004) );
		/* 8224CC58h case   15:*/		return 0x8224CC5C;
		  /* 8224CC5Ch */ case   16:  		/* stw R15, <#[R31 + 8]> */
		/* 8224CC5Ch case   16:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R31 + 0x00000008) );
		/* 8224CC5Ch case   16:*/		return 0x8224CC60;
		  /* 8224CC60h */ case   17:  		/* bl 106704 */
		/* 8224CC60h case   17:*/		regs.LR = 0x8224CC64; return 0x82266D30;
		/* 8224CC60h case   17:*/		return 0x8224CC64;
		  /* 8224CC64h */ case   18:  		/* stw R3, <#[R31 + 12]> */
		/* 8224CC64h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224CC64h case   18:*/		return 0x8224CC68;
		  /* 8224CC68h */ case   19:  		/* lwz R11, <#[R26]> */
		/* 8224CC68h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8224CC68h case   19:*/		return 0x8224CC6C;
		  /* 8224CC6Ch */ case   20:  		/* mr R3, R26 */
		/* 8224CC6Ch case   20:*/		regs.R3 = regs.R26;
		/* 8224CC6Ch case   20:*/		return 0x8224CC70;
		  /* 8224CC70h */ case   21:  		/* lwz R11, <#[R11 + 52]> */
		/* 8224CC70h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 8224CC70h case   21:*/		return 0x8224CC74;
		  /* 8224CC74h */ case   22:  		/* mtspr CTR, R11 */
		/* 8224CC74h case   22:*/		regs.CTR = regs.R11;
		/* 8224CC74h case   22:*/		return 0x8224CC78;
		  /* 8224CC78h */ case   23:  		/* bcctrl 20, CR0_LT */
		/* 8224CC78h case   23:*/		if ( 1 ) { regs.LR = 0x8224CC7C; return (uint32)regs.CTR; }
		/* 8224CC78h case   23:*/		return 0x8224CC7C;
		  /* 8224CC7Ch */ case   24:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224CC7Ch case   24:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224CC7Ch case   24:*/		return 0x8224CC80;
		  /* 8224CC80h */ case   25:  		/* bc 4, CR0_EQ, 88 */
		/* 8224CC80h case   25:*/		if ( !regs.CR[0].eq ) { return 0x8224CCD8;  }
		/* 8224CC80h case   25:*/		return 0x8224CC84;
		  /* 8224CC84h */ case   26:  		/* lwz R11, <#[R26]> */
		/* 8224CC84h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8224CC84h case   26:*/		return 0x8224CC88;
		  /* 8224CC88h */ case   27:  		/* mr R3, R26 */
		/* 8224CC88h case   27:*/		regs.R3 = regs.R26;
		/* 8224CC88h case   27:*/		return 0x8224CC8C;
		  /* 8224CC8Ch */ case   28:  		/* lwz R11, <#[R11 + 4]> */
		/* 8224CC8Ch case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8224CC8Ch case   28:*/		return 0x8224CC90;
		  /* 8224CC90h */ case   29:  		/* mtspr CTR, R11 */
		/* 8224CC90h case   29:*/		regs.CTR = regs.R11;
		/* 8224CC90h case   29:*/		return 0x8224CC94;
		  /* 8224CC94h */ case   30:  		/* bcctrl 20, CR0_LT */
		/* 8224CC94h case   30:*/		if ( 1 ) { regs.LR = 0x8224CC98; return (uint32)regs.CTR; }
		/* 8224CC94h case   30:*/		return 0x8224CC98;
		  /* 8224CC98h */ case   31:  		/* cmpw CR6, R25, R3 */
		/* 8224CC98h case   31:*/		cpu::op::cmpw<6>(regs,regs.R25,regs.R3);
		/* 8224CC98h case   31:*/		return 0x8224CC9C;
		  /* 8224CC9Ch */ case   32:  		/* bc 12, CR6_GT, 60 */
		/* 8224CC9Ch case   32:*/		if ( regs.CR[6].gt ) { return 0x8224CCD8;  }
		/* 8224CC9Ch case   32:*/		return 0x8224CCA0;
		  /* 8224CCA0h */ case   33:  		/* lwz R11, <#[R27]> */
		/* 8224CCA0h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8224CCA0h case   33:*/		return 0x8224CCA4;
		  /* 8224CCA4h */ case   34:  		/* mr R3, R27 */
		/* 8224CCA4h case   34:*/		regs.R3 = regs.R27;
		/* 8224CCA4h case   34:*/		return 0x8224CCA8;
		  /* 8224CCA8h */ case   35:  		/* mr R30, R27 */
		/* 8224CCA8h case   35:*/		regs.R30 = regs.R27;
		/* 8224CCA8h case   35:*/		return 0x8224CCAC;
		  /* 8224CCACh */ case   36:  		/* lwz R11, <#[R11 + 72]> */
		/* 8224CCACh case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 8224CCACh case   36:*/		return 0x8224CCB0;
		  /* 8224CCB0h */ case   37:  		/* mtspr CTR, R11 */
		/* 8224CCB0h case   37:*/		regs.CTR = regs.R11;
		/* 8224CCB0h case   37:*/		return 0x8224CCB4;
		  /* 8224CCB4h */ case   38:  		/* bcctrl 20, CR0_LT */
		/* 8224CCB4h case   38:*/		if ( 1 ) { regs.LR = 0x8224CCB8; return (uint32)regs.CTR; }
		/* 8224CCB4h case   38:*/		return 0x8224CCB8;
		  /* 8224CCB8h */ case   39:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224CCB8h case   39:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224CCB8h case   39:*/		return 0x8224CCBC;
		  /* 8224CCBCh */ case   40:  		/* bc 12, CR0_EQ, 8 */
		/* 8224CCBCh case   40:*/		if ( regs.CR[0].eq ) { return 0x8224CCC4;  }
		/* 8224CCBCh case   40:*/		return 0x8224CCC0;
		  /* 8224CCC0h */ case   41:  		/* lwz R30, <#[R27 + 236]> */
		/* 8224CCC0h case   41:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x000000EC) );
		/* 8224CCC0h case   41:*/		return 0x8224CCC4;
	}
	return 0x8224CCC4;
} // Block from 8224CC1Ch-8224CCC4h (42 instructions)

//////////////////////////////////////////////////////
// Block at 8224CCC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CCC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CCC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CCC4);
		  /* 8224CCC4h */ case    0:  		/* mr R3, R30 */
		/* 8224CCC4h case    0:*/		regs.R3 = regs.R30;
		/* 8224CCC4h case    0:*/		return 0x8224CCC8;
		  /* 8224CCC8h */ case    1:  		/* bl 106384 */
		/* 8224CCC8h case    1:*/		regs.LR = 0x8224CCCC; return 0x82266C58;
		/* 8224CCC8h case    1:*/		return 0x8224CCCC;
		  /* 8224CCCCh */ case    2:  		/* lwz R30, <#[R1 + 88]> */
		/* 8224CCCCh case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000058) );
		/* 8224CCCCh case    2:*/		return 0x8224CCD0;
		  /* 8224CCD0h */ case    3:  		/* stb R3, <#[R31 + 16]> */
		/* 8224CCD0h case    3:*/		cpu::mem::store8( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8224CCD0h case    3:*/		return 0x8224CCD4;
		  /* 8224CCD4h */ case    4:  		/* b 8 */
		/* 8224CCD4h case    4:*/		return 0x8224CCDC;
		/* 8224CCD4h case    4:*/		return 0x8224CCD8;
	}
	return 0x8224CCD8;
} // Block from 8224CCC4h-8224CCD8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224CCD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CCD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CCD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CCD8);
		  /* 8224CCD8h */ case    0:  		/* stb R15, <#[R31 + 16]> */
		/* 8224CCD8h case    0:*/		cpu::mem::store8( regs, regs.R15, (uint32)(regs.R31 + 0x00000010) );
		/* 8224CCD8h case    0:*/		return 0x8224CCDC;
	}
	return 0x8224CCDC;
} // Block from 8224CCD8h-8224CCDCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224CCDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CCDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CCDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CCDC);
		  /* 8224CCDCh */ case    0:  		/* lwz R3, <#[R28 + 48]> */
		/* 8224CCDCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000030) );
		/* 8224CCDCh case    0:*/		return 0x8224CCE0;
		  /* 8224CCE0h */ case    1:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224CCE0h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224CCE0h case    1:*/		return 0x8224CCE4;
		  /* 8224CCE4h */ case    2:  		/* bl 28124 */
		/* 8224CCE4h case    2:*/		regs.LR = 0x8224CCE8; return 0x82253AC0;
		/* 8224CCE4h case    2:*/		return 0x8224CCE8;
		  /* 8224CCE8h */ case    3:  		/* stw R31, <#[R3]> */
		/* 8224CCE8h case    3:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 8224CCE8h case    3:*/		return 0x8224CCEC;
		  /* 8224CCECh */ case    4:  		/* lwz R3, <#[R24 + 52]> */
		/* 8224CCECh case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000034) );
		/* 8224CCECh case    4:*/		return 0x8224CCF0;
		  /* 8224CCF0h */ case    5:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224CCF0h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224CCF0h case    5:*/		return 0x8224CCF4;
		  /* 8224CCF4h */ case    6:  		/* bl 28108 */
		/* 8224CCF4h case    6:*/		regs.LR = 0x8224CCF8; return 0x82253AC0;
		/* 8224CCF4h case    6:*/		return 0x8224CCF8;
		  /* 8224CCF8h */ case    7:  		/* mr R11, R3 */
		/* 8224CCF8h case    7:*/		regs.R11 = regs.R3;
		/* 8224CCF8h case    7:*/		return 0x8224CCFC;
		  /* 8224CCFCh */ case    8:  		/* mr R3, R26 */
		/* 8224CCFCh case    8:*/		regs.R3 = regs.R26;
		/* 8224CCFCh case    8:*/		return 0x8224CD00;
		  /* 8224CD00h */ case    9:  		/* stw R31, <#[R11]> */
		/* 8224CD00h case    9:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 8224CD00h case    9:*/		return 0x8224CD04;
		  /* 8224CD04h */ case   10:  		/* lwz R11, <#[R26]> */
		/* 8224CD04h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8224CD04h case   10:*/		return 0x8224CD08;
		  /* 8224CD08h */ case   11:  		/* lwz R11, <#[R11 + 72]> */
		/* 8224CD08h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 8224CD08h case   11:*/		return 0x8224CD0C;
		  /* 8224CD0Ch */ case   12:  		/* mtspr CTR, R11 */
		/* 8224CD0Ch case   12:*/		regs.CTR = regs.R11;
		/* 8224CD0Ch case   12:*/		return 0x8224CD10;
		  /* 8224CD10h */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 8224CD10h case   13:*/		if ( 1 ) { regs.LR = 0x8224CD14; return (uint32)regs.CTR; }
		/* 8224CD10h case   13:*/		return 0x8224CD14;
		  /* 8224CD14h */ case   14:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224CD14h case   14:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224CD14h case   14:*/		return 0x8224CD18;
		  /* 8224CD18h */ case   15:  		/* bc 12, CR0_EQ, 304 */
		/* 8224CD18h case   15:*/		if ( regs.CR[0].eq ) { return 0x8224CE48;  }
		/* 8224CD18h case   15:*/		return 0x8224CD1C;
		  /* 8224CD1Ch */ case   16:  		/* lwz R11, <#[R26 + 228]> */
		/* 8224CD1Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x000000E4) );
		/* 8224CD1Ch case   16:*/		return 0x8224CD20;
		  /* 8224CD20h */ case   17:  		/* rlwinm. R11, R11, 23, 31, 31 */
		/* 8224CD20h case   17:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R11,regs.R11);
		/* 8224CD20h case   17:*/		return 0x8224CD24;
		  /* 8224CD24h */ case   18:  		/* bc 12, CR0_EQ, 292 */
		/* 8224CD24h case   18:*/		if ( regs.CR[0].eq ) { return 0x8224CE48;  }
		/* 8224CD24h case   18:*/		return 0x8224CD28;
		  /* 8224CD28h */ case   19:  		/* lwz R11, <#[R26 + 20]> */
		/* 8224CD28h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 8224CD28h case   19:*/		return 0x8224CD2C;
		  /* 8224CD2Ch */ case   20:  		/* cmpw CR6, R25, R11 */
		/* 8224CD2Ch case   20:*/		cpu::op::cmpw<6>(regs,regs.R25,regs.R11);
		/* 8224CD2Ch case   20:*/		return 0x8224CD30;
		  /* 8224CD30h */ case   21:  		/* bc 4, CR6_EQ, 280 */
		/* 8224CD30h case   21:*/		if ( !regs.CR[6].eq ) { return 0x8224CE48;  }
		/* 8224CD30h case   21:*/		return 0x8224CD34;
		  /* 8224CD34h */ case   22:  		/* cmpwi CR6, R25, 1 */
		/* 8224CD34h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000001);
		/* 8224CD34h case   22:*/		return 0x8224CD38;
		  /* 8224CD38h */ case   23:  		/* bc 12, CR6_GT, 28 */
		/* 8224CD38h case   23:*/		if ( regs.CR[6].gt ) { return 0x8224CD54;  }
		/* 8224CD38h case   23:*/		return 0x8224CD3C;
		  /* 8224CD3Ch */ case   24:  		/* mr R5, R17 */
		/* 8224CD3Ch case   24:*/		regs.R5 = regs.R17;
		/* 8224CD3Ch case   24:*/		return 0x8224CD40;
		  /* 8224CD40h */ case   25:  		/* lwz R6, <#[R1 + 84]> */
		/* 8224CD40h case   25:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 8224CD40h case   25:*/		return 0x8224CD44;
		  /* 8224CD44h */ case   26:  		/* mr R4, R30 */
		/* 8224CD44h case   26:*/		regs.R4 = regs.R30;
		/* 8224CD44h case   26:*/		return 0x8224CD48;
		  /* 8224CD48h */ case   27:  		/* li R7, 944 */
		/* 8224CD48h case   27:*/		cpu::op::li<0>(regs,&regs.R7,0x3B0);
		/* 8224CD48h case   27:*/		return 0x8224CD4C;
		  /* 8224CD4Ch */ case   28:  		/* li R3, 0 */
		/* 8224CD4Ch case   28:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224CD4Ch case   28:*/		return 0x8224CD50;
		  /* 8224CD50h */ case   29:  		/* bl -1003848 */
		/* 8224CD50h case   29:*/		regs.LR = 0x8224CD54; return 0x82157C08;
		/* 8224CD50h case   29:*/		return 0x8224CD54;
	}
	return 0x8224CD54;
} // Block from 8224CCDCh-8224CD54h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8224CD54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CD54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CD54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CD54);
		  /* 8224CD54h */ case    0:  		/* lwz R30, <#[R21]> */
		/* 8224CD54h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R21 + 0x00000000) );
		/* 8224CD54h case    0:*/		return 0x8224CD58;
		  /* 8224CD58h */ case    1:  		/* lwz R11, <#[R30 + 892]> */
		/* 8224CD58h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000037C) );
		/* 8224CD58h case    1:*/		return 0x8224CD5C;
		  /* 8224CD5Ch */ case    2:  		/* cmpw CR6, R11, R29 */
		/* 8224CD5Ch case    2:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R29);
		/* 8224CD5Ch case    2:*/		return 0x8224CD60;
		  /* 8224CD60h */ case    3:  		/* bc 12, CR6_LT, 28 */
		/* 8224CD60h case    3:*/		if ( regs.CR[6].lt ) { return 0x8224CD7C;  }
		/* 8224CD60h case    3:*/		return 0x8224CD64;
		  /* 8224CD64h */ case    4:  		/* mr R5, R18 */
		/* 8224CD64h case    4:*/		regs.R5 = regs.R18;
		/* 8224CD64h case    4:*/		return 0x8224CD68;
		  /* 8224CD68h */ case    5:  		/* lwz R6, <#[R1 + 84]> */
		/* 8224CD68h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 8224CD68h case    5:*/		return 0x8224CD6C;
		  /* 8224CD6Ch */ case    6:  		/* li R7, 947 */
		/* 8224CD6Ch case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x3B3);
		/* 8224CD6Ch case    6:*/		return 0x8224CD70;
		  /* 8224CD70h */ case    7:  		/* lwz R4, <#[R1 + 88]> */
		/* 8224CD70h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000058) );
		/* 8224CD70h case    7:*/		return 0x8224CD74;
		  /* 8224CD74h */ case    8:  		/* li R3, 0 */
		/* 8224CD74h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224CD74h case    8:*/		return 0x8224CD78;
		  /* 8224CD78h */ case    9:  		/* bl -1003888 */
		/* 8224CD78h case    9:*/		regs.LR = 0x8224CD7C; return 0x82157C08;
		/* 8224CD78h case    9:*/		return 0x8224CD7C;
	}
	return 0x8224CD7C;
} // Block from 8224CD54h-8224CD7Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224CD7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CD7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CD7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CD7C);
		  /* 8224CD7Ch */ case    0:  		/* lwz R3, <#[R23 + 24]> */
		/* 8224CD7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000018) );
		/* 8224CD7Ch case    0:*/		return 0x8224CD80;
		  /* 8224CD80h */ case    1:  		/* lwz R4, <#[R30 + 892]> */
		/* 8224CD80h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000037C) );
		/* 8224CD80h case    1:*/		return 0x8224CD84;
		  /* 8224CD84h */ case    2:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224CD84h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224CD84h case    2:*/		return 0x8224CD88;
		  /* 8224CD88h */ case    3:  		/* cmplw CR6, R4, R11 */
		/* 8224CD88h case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 8224CD88h case    3:*/		return 0x8224CD8C;
		  /* 8224CD8Ch */ case    4:  		/* bc 4, CR6_LT, 20 */
		/* 8224CD8Ch case    4:*/		if ( !regs.CR[6].lt ) { return 0x8224CDA0;  }
		/* 8224CD8Ch case    4:*/		return 0x8224CD90;
		  /* 8224CD90h */ case    5:  		/* lwz R10, <#[R3 + 8]> */
		/* 8224CD90h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 8224CD90h case    5:*/		return 0x8224CD94;
		  /* 8224CD94h */ case    6:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 8224CD94h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 8224CD94h case    6:*/		return 0x8224CD98;
		  /* 8224CD98h */ case    7:  		/* add R3, R10, R11 */
		/* 8224CD98h case    7:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8224CD98h case    7:*/		return 0x8224CD9C;
		  /* 8224CD9Ch */ case    8:  		/* b 8 */
		/* 8224CD9Ch case    8:*/		return 0x8224CDA4;
		/* 8224CD9Ch case    8:*/		return 0x8224CDA0;
	}
	return 0x8224CDA0;
} // Block from 8224CD7Ch-8224CDA0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224CDA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CDA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CDA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CDA0);
		  /* 8224CDA0h */ case    0:  		/* bl 27936 */
		/* 8224CDA0h case    0:*/		regs.LR = 0x8224CDA4; return 0x82253AC0;
		/* 8224CDA0h case    0:*/		return 0x8224CDA4;
	}
	return 0x8224CDA4;
} // Block from 8224CDA0h-8224CDA4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224CDA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CDA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CDA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CDA4);
		  /* 8224CDA4h */ case    0:  		/* lwz R29, <#[R3]> */
		/* 8224CDA4h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 8224CDA4h case    0:*/		return 0x8224CDA8;
		  /* 8224CDA8h */ case    1:  		/* lwz R11, <#[R29 + 40]> */
		/* 8224CDA8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000028) );
		/* 8224CDA8h case    1:*/		return 0x8224CDAC;
		  /* 8224CDACh */ case    2:  		/* cmplw CR6, R11, R30 */
		/* 8224CDACh case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 8224CDACh case    2:*/		return 0x8224CDB0;
		  /* 8224CDB0h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 8224CDB0h case    3:*/		if ( regs.CR[6].eq ) { return 0x8224CDCC;  }
		/* 8224CDB0h case    3:*/		return 0x8224CDB4;
		  /* 8224CDB4h */ case    4:  		/* mr R5, R19 */
		/* 8224CDB4h case    4:*/		regs.R5 = regs.R19;
		/* 8224CDB4h case    4:*/		return 0x8224CDB8;
		  /* 8224CDB8h */ case    5:  		/* lwz R6, <#[R1 + 84]> */
		/* 8224CDB8h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 8224CDB8h case    5:*/		return 0x8224CDBC;
		  /* 8224CDBCh */ case    6:  		/* li R7, 949 */
		/* 8224CDBCh case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x3B5);
		/* 8224CDBCh case    6:*/		return 0x8224CDC0;
		  /* 8224CDC0h */ case    7:  		/* lwz R4, <#[R1 + 88]> */
		/* 8224CDC0h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000058) );
		/* 8224CDC0h case    7:*/		return 0x8224CDC4;
		  /* 8224CDC4h */ case    8:  		/* li R3, 0 */
		/* 8224CDC4h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224CDC4h case    8:*/		return 0x8224CDC8;
		  /* 8224CDC8h */ case    9:  		/* bl -1003968 */
		/* 8224CDC8h case    9:*/		regs.LR = 0x8224CDCC; return 0x82157C08;
		/* 8224CDC8h case    9:*/		return 0x8224CDCC;
	}
	return 0x8224CDCC;
} // Block from 8224CDA4h-8224CDCCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224CDCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CDCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CDCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CDCC);
		  /* 8224CDCCh */ case    0:  		/* lwz R11, <#[R23]> */
		/* 8224CDCCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8224CDCCh case    0:*/		return 0x8224CDD0;
		  /* 8224CDD0h */ case    1:  		/* li R4, 24 */
		/* 8224CDD0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 8224CDD0h case    1:*/		return 0x8224CDD4;
		  /* 8224CDD4h */ case    2:  		/* lwz R11, <#[R11 + 1456]> */
		/* 8224CDD4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224CDD4h case    2:*/		return 0x8224CDD8;
		  /* 8224CDD8h */ case    3:  		/* mr R3, R11 */
		/* 8224CDD8h case    3:*/		regs.R3 = regs.R11;
		/* 8224CDD8h case    3:*/		return 0x8224CDDC;
		  /* 8224CDDCh */ case    4:  		/* stw R11, <#[R1 + 108]> */
		/* 8224CDDCh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 8224CDDCh case    4:*/		return 0x8224CDE0;
		  /* 8224CDE0h */ case    5:  		/* bl -198952 */
		/* 8224CDE0h case    5:*/		regs.LR = 0x8224CDE4; return 0x8221C4B8;
		/* 8224CDE0h case    5:*/		return 0x8224CDE4;
		  /* 8224CDE4h */ case    6:  		/* lwz R10, <#[R1 + 108]> */
		/* 8224CDE4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000006C) );
		/* 8224CDE4h case    6:*/		return 0x8224CDE8;
		  /* 8224CDE8h */ case    7:  		/* mr R31, R3 */
		/* 8224CDE8h case    7:*/		regs.R31 = regs.R3;
		/* 8224CDE8h case    7:*/		return 0x8224CDEC;
		  /* 8224CDECh */ case    8:  		/* li R11, 4 */
		/* 8224CDECh case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 8224CDECh case    8:*/		return 0x8224CDF0;
		  /* 8224CDF0h */ case    9:  		/* mr R4, R30 */
		/* 8224CDF0h case    9:*/		regs.R4 = regs.R30;
		/* 8224CDF0h case    9:*/		return 0x8224CDF4;
		  /* 8224CDF4h */ case   10:  		/* li R7, 4 */
		/* 8224CDF4h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 8224CDF4h case   10:*/		return 0x8224CDF8;
		  /* 8224CDF8h */ case   11:  		/* li R6, 0 */
		/* 8224CDF8h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8224CDF8h case   11:*/		return 0x8224CDFC;
		  /* 8224CDFCh */ case   12:  		/* stw R10, <#[R3]> */
		/* 8224CDFCh case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8224CDFCh case   12:*/		return 0x8224CE00;
	}
	return 0x8224CE00;
} // Block from 8224CDCCh-8224CE00h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224CE00h
// Function '?BuildPhysicalLiveness@Scheduler@XGRAPHICS@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CE00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CE00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CE00);
		  /* 8224CE00h */ case    0:  		/* li R5, 0 */
		/* 8224CE00h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8224CE00h case    0:*/		return 0x8224CE04;
		  /* 8224CE04h */ case    1:  		/* stw R28, <#[R3 + 4]> */
		/* 8224CE04h case    1:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000004) );
		/* 8224CE04h case    1:*/		return 0x8224CE08;
		  /* 8224CE08h */ case    2:  		/* mr R3, R27 */
		/* 8224CE08h case    2:*/		regs.R3 = regs.R27;
		/* 8224CE08h case    2:*/		return 0x8224CE0C;
		  /* 8224CE0Ch */ case    3:  		/* stw R29, <#[R31 + 8]> */
		/* 8224CE0Ch case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000008) );
		/* 8224CE0Ch case    3:*/		return 0x8224CE10;
		  /* 8224CE10h */ case    4:  		/* addi R30, R31, 4 */
		/* 8224CE10h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x4);
		/* 8224CE10h case    4:*/		return 0x8224CE14;
		  /* 8224CE14h */ case    5:  		/* stw R11, <#[R31 + 12]> */
		/* 8224CE14h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224CE14h case    5:*/		return 0x8224CE18;
		  /* 8224CE18h */ case    6:  		/* bl 106264 */
		/* 8224CE18h case    6:*/		regs.LR = 0x8224CE1C; return 0x82266D30;
		/* 8224CE18h case    6:*/		return 0x8224CE1C;
		  /* 8224CE1Ch */ case    7:  		/* stw R3, <#[R31 + 16]> */
		/* 8224CE1Ch case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8224CE1Ch case    7:*/		return 0x8224CE20;
		  /* 8224CE20h */ case    8:  		/* lwz R3, <#[R28 + 48]> */
		/* 8224CE20h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000030) );
		/* 8224CE20h case    8:*/		return 0x8224CE24;
		  /* 8224CE24h */ case    9:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224CE24h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224CE24h case    9:*/		return 0x8224CE28;
		  /* 8224CE28h */ case   10:  		/* bl 27800 */
		/* 8224CE28h case   10:*/		regs.LR = 0x8224CE2C; return 0x82253AC0;
		/* 8224CE28h case   10:*/		return 0x8224CE2C;
		  /* 8224CE2Ch */ case   11:  		/* stw R30, <#[R3]> */
		/* 8224CE2Ch case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224CE2Ch case   11:*/		return 0x8224CE30;
		  /* 8224CE30h */ case   12:  		/* lwz R3, <#[R29 + 52]> */
		/* 8224CE30h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000034) );
		/* 8224CE30h case   12:*/		return 0x8224CE34;
		  /* 8224CE34h */ case   13:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224CE34h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224CE34h case   13:*/		return 0x8224CE38;
		  /* 8224CE38h */ case   14:  		/* bl 27784 */
		/* 8224CE38h case   14:*/		regs.LR = 0x8224CE3C; return 0x82253AC0;
		/* 8224CE38h case   14:*/		return 0x8224CE3C;
		  /* 8224CE3Ch */ case   15:  		/* stw R30, <#[R3]> */
		/* 8224CE3Ch case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224CE3Ch case   15:*/		return 0x8224CE40;
		  /* 8224CE40h */ case   16:  		/* lwz R29, <#[R1 + 92]> */
		/* 8224CE40h case   16:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x0000005C) );
		/* 8224CE40h case   16:*/		return 0x8224CE44;
		  /* 8224CE44h */ case   17:  		/* lwz R30, <#[R1 + 88]> */
		/* 8224CE44h case   17:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000058) );
		/* 8224CE44h case   17:*/		return 0x8224CE48;
	}
	return 0x8224CE48;
} // Block from 8224CE00h-8224CE48h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8224CE48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CE48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CE48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CE48);
		  /* 8224CE48h */ case    0:  		/* lwz R11, <#[R26 + 20]> */
		/* 8224CE48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 8224CE48h case    0:*/		return 0x8224CE4C;
		  /* 8224CE4Ch */ case    1:  		/* addi R25, R25, 1 */
		/* 8224CE4Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 8224CE4Ch case    1:*/		return 0x8224CE50;
		  /* 8224CE50h */ case    2:  		/* addi R22, R22, 4 */
		/* 8224CE50h case    2:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x4);
		/* 8224CE50h case    2:*/		return 0x8224CE54;
		  /* 8224CE54h */ case    3:  		/* cmpw CR6, R25, R11 */
		/* 8224CE54h case    3:*/		cpu::op::cmpw<6>(regs,regs.R25,regs.R11);
		/* 8224CE54h case    3:*/		return 0x8224CE58;
		  /* 8224CE58h */ case    4:  		/* bc 4, CR6_GT, -788 */
		/* 8224CE58h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8224CB44;  }
		/* 8224CE58h case    4:*/		return 0x8224CE5C;
	}
	return 0x8224CE5C;
} // Block from 8224CE48h-8224CE5Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224CE5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CE5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CE5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CE5C);
		  /* 8224CE5Ch */ case    0:  		/* lwz R11, <#[R26]> */
		/* 8224CE5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8224CE5Ch case    0:*/		return 0x8224CE60;
		  /* 8224CE60h */ case    1:  		/* mr R3, R26 */
		/* 8224CE60h case    1:*/		regs.R3 = regs.R26;
		/* 8224CE60h case    1:*/		return 0x8224CE64;
		  /* 8224CE64h */ case    2:  		/* lwz R11, <#[R11 + 56]> */
		/* 8224CE64h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000038) );
		/* 8224CE64h case    2:*/		return 0x8224CE68;
		  /* 8224CE68h */ case    3:  		/* mtspr CTR, R11 */
		/* 8224CE68h case    3:*/		regs.CTR = regs.R11;
		/* 8224CE68h case    3:*/		return 0x8224CE6C;
		  /* 8224CE6Ch */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8224CE6Ch case    4:*/		if ( 1 ) { regs.LR = 0x8224CE70; return (uint32)regs.CTR; }
		/* 8224CE6Ch case    4:*/		return 0x8224CE70;
		  /* 8224CE70h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224CE70h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224CE70h case    5:*/		return 0x8224CE74;
		  /* 8224CE74h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 8224CE74h case    6:*/		if ( regs.CR[0].eq ) { return 0x8224CE84;  }
		/* 8224CE74h case    6:*/		return 0x8224CE78;
		  /* 8224CE78h */ case    7:  		/* mr R4, R24 */
		/* 8224CE78h case    7:*/		regs.R4 = regs.R24;
		/* 8224CE78h case    7:*/		return 0x8224CE7C;
		  /* 8224CE7Ch */ case    8:  		/* addi R3, R1, 128 */
		/* 8224CE7Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 8224CE7Ch case    8:*/		return 0x8224CE80;
		  /* 8224CE80h */ case    9:  		/* bl 27144 */
		/* 8224CE80h case    9:*/		regs.LR = 0x8224CE84; return 0x82253888;
		/* 8224CE80h case    9:*/		return 0x8224CE84;
	}
	return 0x8224CE84;
} // Block from 8224CE5Ch-8224CE84h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224CE84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CE84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CE84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CE84);
		  /* 8224CE84h */ case    0:  		/* lwz R11, <#[R1 + 112]> */
		/* 8224CE84h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 8224CE84h case    0:*/		return 0x8224CE88;
		  /* 8224CE88h */ case    1:  		/* cmpw CR6, R29, R11 */
		/* 8224CE88h case    1:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R11);
		/* 8224CE88h case    1:*/		return 0x8224CE8C;
		  /* 8224CE8Ch */ case    2:  		/* bc 4, CR6_EQ, 200 */
		/* 8224CE8Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224CF54;  }
		/* 8224CE8Ch case    2:*/		return 0x8224CE90;
		  /* 8224CE90h */ case    3:  		/* addic. R28, R29, -1 */
		/* 8224CE90h case    3:*/		cpu::op::addic<1>(regs,&regs.R28,regs.R29,0xFFFFFFFF);
		/* 8224CE90h case    3:*/		return 0x8224CE94;
		  /* 8224CE94h */ case    4:  		/* bc 12, CR0_LT, 388 */
		/* 8224CE94h case    4:*/		if ( regs.CR[0].lt ) { return 0x8224D018;  }
		/* 8224CE94h case    4:*/		return 0x8224CE98;
		  /* 8224CE98h */ case    5:  		/* rlwinm R27, R28, 2, 0, 29 */
		/* 8224CE98h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R28);
		/* 8224CE98h case    5:*/		return 0x8224CE9C;
		  /* 8224CE9Ch */ case    6:  		/* lwz R3, <#[R23 + 24]> */
		/* 8224CE9Ch case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000018) );
		/* 8224CE9Ch case    6:*/		return 0x8224CEA0;
		  /* 8224CEA0h */ case    7:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224CEA0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224CEA0h case    7:*/		return 0x8224CEA4;
		  /* 8224CEA4h */ case    8:  		/* cmplw CR6, R28, R11 */
		/* 8224CEA4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 8224CEA4h case    8:*/		return 0x8224CEA8;
		  /* 8224CEA8h */ case    9:  		/* bc 4, CR6_LT, 16 */
		/* 8224CEA8h case    9:*/		if ( !regs.CR[6].lt ) { return 0x8224CEB8;  }
		/* 8224CEA8h case    9:*/		return 0x8224CEAC;
		  /* 8224CEACh */ case   10:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224CEACh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224CEACh case   10:*/		return 0x8224CEB0;
		  /* 8224CEB0h */ case   11:  		/* add R3, R11, R27 */
		/* 8224CEB0h case   11:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R27);
		/* 8224CEB0h case   11:*/		return 0x8224CEB4;
		  /* 8224CEB4h */ case   12:  		/* b 12 */
		/* 8224CEB4h case   12:*/		return 0x8224CEC0;
		/* 8224CEB4h case   12:*/		return 0x8224CEB8;
	}
	return 0x8224CEB8;
} // Block from 8224CE84h-8224CEB8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224CEB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CEB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CEB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CEB8);
		  /* 8224CEB8h */ case    0:  		/* mr R4, R28 */
		/* 8224CEB8h case    0:*/		regs.R4 = regs.R28;
		/* 8224CEB8h case    0:*/		return 0x8224CEBC;
		  /* 8224CEBCh */ case    1:  		/* bl 27652 */
		/* 8224CEBCh case    1:*/		regs.LR = 0x8224CEC0; return 0x82253AC0;
		/* 8224CEBCh case    1:*/		return 0x8224CEC0;
	}
	return 0x8224CEC0;
} // Block from 8224CEB8h-8224CEC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224CEC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CEC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CEC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CEC0);
		  /* 8224CEC0h */ case    0:  		/* lwz R29, <#[R3]> */
		/* 8224CEC0h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 8224CEC0h case    0:*/		return 0x8224CEC4;
		  /* 8224CEC4h */ case    1:  		/* lwz R30, <#[R29 + 40]> */
		/* 8224CEC4h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000028) );
		/* 8224CEC4h case    1:*/		return 0x8224CEC8;
		  /* 8224CEC8h */ case    2:  		/* lwz R11, <#[R30 + 228]> */
		/* 8224CEC8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000E4) );
		/* 8224CEC8h case    2:*/		return 0x8224CECC;
		  /* 8224CECCh */ case    3:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 8224CECCh case    3:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 8224CECCh case    3:*/		return 0x8224CED0;
		  /* 8224CED0h */ case    4:  		/* bc 4, CR0_EQ, 116 */
		/* 8224CED0h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8224CF44;  }
		/* 8224CED0h case    4:*/		return 0x8224CED4;
		  /* 8224CED4h */ case    5:  		/* lwz R11, <#[R23]> */
		/* 8224CED4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8224CED4h case    5:*/		return 0x8224CED8;
		  /* 8224CED8h */ case    6:  		/* li R4, 24 */
		/* 8224CED8h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 8224CED8h case    6:*/		return 0x8224CEDC;
		  /* 8224CEDCh */ case    7:  		/* lwz R25, <#[R11 + 1456]> */
		/* 8224CEDCh case    7:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224CEDCh case    7:*/		return 0x8224CEE0;
		  /* 8224CEE0h */ case    8:  		/* mr R3, R25 */
		/* 8224CEE0h case    8:*/		regs.R3 = regs.R25;
		/* 8224CEE0h case    8:*/		return 0x8224CEE4;
		  /* 8224CEE4h */ case    9:  		/* bl -199212 */
		/* 8224CEE4h case    9:*/		regs.LR = 0x8224CEE8; return 0x8221C4B8;
		/* 8224CEE4h case    9:*/		return 0x8224CEE8;
		  /* 8224CEE8h */ case   10:  		/* mr R31, R3 */
		/* 8224CEE8h case   10:*/		regs.R31 = regs.R3;
		/* 8224CEE8h case   10:*/		return 0x8224CEEC;
		  /* 8224CEECh */ case   11:  		/* li R11, 1 */
		/* 8224CEECh case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224CEECh case   11:*/		return 0x8224CEF0;
		  /* 8224CEF0h */ case   12:  		/* mr R3, R30 */
		/* 8224CEF0h case   12:*/		regs.R3 = regs.R30;
		/* 8224CEF0h case   12:*/		return 0x8224CEF4;
		  /* 8224CEF4h */ case   13:  		/* li R7, 1 */
		/* 8224CEF4h case   13:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8224CEF4h case   13:*/		return 0x8224CEF8;
		  /* 8224CEF8h */ case   14:  		/* li R6, 0 */
		/* 8224CEF8h case   14:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8224CEF8h case   14:*/		return 0x8224CEFC;
		  /* 8224CEFCh */ case   15:  		/* stw R25, <#[R31]> */
		/* 8224CEFCh case   15:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x00000000) );
		/* 8224CEFCh case   15:*/		return 0x8224CF00;
		  /* 8224CF00h */ case   16:  		/* li R5, 0 */
		/* 8224CF00h case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8224CF00h case   16:*/		return 0x8224CF04;
		  /* 8224CF04h */ case   17:  		/* stw R29, <#[R31 + 4]> */
		/* 8224CF04h case   17:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000004) );
		/* 8224CF04h case   17:*/		return 0x8224CF08;
		  /* 8224CF08h */ case   18:  		/* mr R4, R26 */
		/* 8224CF08h case   18:*/		regs.R4 = regs.R26;
		/* 8224CF08h case   18:*/		return 0x8224CF0C;
		  /* 8224CF0Ch */ case   19:  		/* stw R24, <#[R31 + 8]> */
		/* 8224CF0Ch case   19:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000008) );
		/* 8224CF0Ch case   19:*/		return 0x8224CF10;
		  /* 8224CF10h */ case   20:  		/* addi R30, R31, 4 */
		/* 8224CF10h case   20:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x4);
		/* 8224CF10h case   20:*/		return 0x8224CF14;
		  /* 8224CF14h */ case   21:  		/* stw R11, <#[R31 + 12]> */
		/* 8224CF14h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224CF14h case   21:*/		return 0x8224CF18;
		  /* 8224CF18h */ case   22:  		/* bl 106008 */
		/* 8224CF18h case   22:*/		regs.LR = 0x8224CF1C; return 0x82266D30;
		/* 8224CF18h case   22:*/		return 0x8224CF1C;
		  /* 8224CF1Ch */ case   23:  		/* stw R3, <#[R31 + 16]> */
		/* 8224CF1Ch case   23:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8224CF1Ch case   23:*/		return 0x8224CF20;
		  /* 8224CF20h */ case   24:  		/* stb R15, <#[R31 + 20]> */
		/* 8224CF20h case   24:*/		cpu::mem::store8( regs, regs.R15, (uint32)(regs.R31 + 0x00000014) );
		/* 8224CF20h case   24:*/		return 0x8224CF24;
		  /* 8224CF24h */ case   25:  		/* lwz R3, <#[R29 + 48]> */
		/* 8224CF24h case   25:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000030) );
		/* 8224CF24h case   25:*/		return 0x8224CF28;
		  /* 8224CF28h */ case   26:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224CF28h case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224CF28h case   26:*/		return 0x8224CF2C;
		  /* 8224CF2Ch */ case   27:  		/* bl 27540 */
		/* 8224CF2Ch case   27:*/		regs.LR = 0x8224CF30; return 0x82253AC0;
		/* 8224CF2Ch case   27:*/		return 0x8224CF30;
		  /* 8224CF30h */ case   28:  		/* stw R30, <#[R3]> */
		/* 8224CF30h case   28:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224CF30h case   28:*/		return 0x8224CF34;
		  /* 8224CF34h */ case   29:  		/* lwz R3, <#[R24 + 52]> */
		/* 8224CF34h case   29:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000034) );
		/* 8224CF34h case   29:*/		return 0x8224CF38;
		  /* 8224CF38h */ case   30:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224CF38h case   30:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224CF38h case   30:*/		return 0x8224CF3C;
		  /* 8224CF3Ch */ case   31:  		/* bl 27524 */
		/* 8224CF3Ch case   31:*/		regs.LR = 0x8224CF40; return 0x82253AC0;
		/* 8224CF3Ch case   31:*/		return 0x8224CF40;
		  /* 8224CF40h */ case   32:  		/* stw R30, <#[R3]> */
		/* 8224CF40h case   32:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224CF40h case   32:*/		return 0x8224CF44;
	}
	return 0x8224CF44;
} // Block from 8224CEC0h-8224CF44h (33 instructions)

//////////////////////////////////////////////////////
// Block at 8224CF44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CF44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CF44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CF44);
		  /* 8224CF44h */ case    0:  		/* addic. R28, R28, -1 */
		/* 8224CF44h case    0:*/		cpu::op::addic<1>(regs,&regs.R28,regs.R28,0xFFFFFFFF);
		/* 8224CF44h case    0:*/		return 0x8224CF48;
		  /* 8224CF48h */ case    1:  		/* addi R27, R27, -4 */
		/* 8224CF48h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0xFFFFFFFC);
		/* 8224CF48h case    1:*/		return 0x8224CF4C;
		  /* 8224CF4Ch */ case    2:  		/* bc 4, CR0_LT, -176 */
		/* 8224CF4Ch case    2:*/		if ( !regs.CR[0].lt ) { return 0x8224CE9C;  }
		/* 8224CF4Ch case    2:*/		return 0x8224CF50;
		  /* 8224CF50h */ case    3:  		/* b 200 */
		/* 8224CF50h case    3:*/		return 0x8224D018;
		/* 8224CF50h case    3:*/		return 0x8224CF54;
	}
	return 0x8224CF54;
} // Block from 8224CF44h-8224CF54h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224CF54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CF54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CF54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CF54);
		  /* 8224CF54h */ case    0:  		/* bc 4, CR6_GT, 196 */
		/* 8224CF54h case    0:*/		if ( !regs.CR[6].gt ) { return 0x8224D018;  }
		/* 8224CF54h case    0:*/		return 0x8224CF58;
		  /* 8224CF58h */ case    1:  		/* lwz R3, <#[R23 + 24]> */
		/* 8224CF58h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000018) );
		/* 8224CF58h case    1:*/		return 0x8224CF5C;
		  /* 8224CF5Ch */ case    2:  		/* lwz R11, <#[R1 + 92]> */
		/* 8224CF5Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8224CF5Ch case    2:*/		return 0x8224CF60;
		  /* 8224CF60h */ case    3:  		/* addi R4, R11, -1 */
		/* 8224CF60h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFF);
		/* 8224CF60h case    3:*/		return 0x8224CF64;
		  /* 8224CF64h */ case    4:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224CF64h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224CF64h case    4:*/		return 0x8224CF68;
		  /* 8224CF68h */ case    5:  		/* cmplw CR6, R4, R11 */
		/* 8224CF68h case    5:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 8224CF68h case    5:*/		return 0x8224CF6C;
		  /* 8224CF6Ch */ case    6:  		/* bc 4, CR6_LT, 20 */
		/* 8224CF6Ch case    6:*/		if ( !regs.CR[6].lt ) { return 0x8224CF80;  }
		/* 8224CF6Ch case    6:*/		return 0x8224CF70;
		  /* 8224CF70h */ case    7:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224CF70h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224CF70h case    7:*/		return 0x8224CF74;
		  /* 8224CF74h */ case    8:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 8224CF74h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 8224CF74h case    8:*/		return 0x8224CF78;
		  /* 8224CF78h */ case    9:  		/* add R3, R10, R11 */
		/* 8224CF78h case    9:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8224CF78h case    9:*/		return 0x8224CF7C;
		  /* 8224CF7Ch */ case   10:  		/* b 8 */
		/* 8224CF7Ch case   10:*/		return 0x8224CF84;
		/* 8224CF7Ch case   10:*/		return 0x8224CF80;
	}
	return 0x8224CF80;
} // Block from 8224CF54h-8224CF80h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224CF80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CF80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CF80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CF80);
		  /* 8224CF80h */ case    0:  		/* bl 27456 */
		/* 8224CF80h case    0:*/		regs.LR = 0x8224CF84; return 0x82253AC0;
		/* 8224CF80h case    0:*/		return 0x8224CF84;
	}
	return 0x8224CF84;
} // Block from 8224CF80h-8224CF84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224CF84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224CF84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224CF84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224CF84);
		  /* 8224CF84h */ case    0:  		/* lwz R29, <#[R3]> */
		/* 8224CF84h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 8224CF84h case    0:*/		return 0x8224CF88;
		  /* 8224CF88h */ case    1:  		/* lwz R30, <#[R29 + 40]> */
		/* 8224CF88h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000028) );
		/* 8224CF88h case    1:*/		return 0x8224CF8C;
		  /* 8224CF8Ch */ case    2:  		/* mr R3, R30 */
		/* 8224CF8Ch case    2:*/		regs.R3 = regs.R30;
		/* 8224CF8Ch case    2:*/		return 0x8224CF90;
		  /* 8224CF90h */ case    3:  		/* lwz R11, <#[R30]> */
		/* 8224CF90h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8224CF90h case    3:*/		return 0x8224CF94;
		  /* 8224CF94h */ case    4:  		/* lwz R11, <#[R11 + 56]> */
		/* 8224CF94h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000038) );
		/* 8224CF94h case    4:*/		return 0x8224CF98;
		  /* 8224CF98h */ case    5:  		/* mtspr CTR, R11 */
		/* 8224CF98h case    5:*/		regs.CTR = regs.R11;
		/* 8224CF98h case    5:*/		return 0x8224CF9C;
		  /* 8224CF9Ch */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 8224CF9Ch case    6:*/		if ( 1 ) { regs.LR = 0x8224CFA0; return (uint32)regs.CTR; }
		/* 8224CF9Ch case    6:*/		return 0x8224CFA0;
		  /* 8224CFA0h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224CFA0h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224CFA0h case    7:*/		return 0x8224CFA4;
		  /* 8224CFA4h */ case    8:  		/* bc 4, CR0_EQ, 116 */
		/* 8224CFA4h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8224D018;  }
		/* 8224CFA4h case    8:*/		return 0x8224CFA8;
		  /* 8224CFA8h */ case    9:  		/* lwz R11, <#[R23]> */
		/* 8224CFA8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8224CFA8h case    9:*/		return 0x8224CFAC;
		  /* 8224CFACh */ case   10:  		/* li R4, 24 */
		/* 8224CFACh case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 8224CFACh case   10:*/		return 0x8224CFB0;
		  /* 8224CFB0h */ case   11:  		/* lwz R28, <#[R11 + 1456]> */
		/* 8224CFB0h case   11:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224CFB0h case   11:*/		return 0x8224CFB4;
		  /* 8224CFB4h */ case   12:  		/* mr R3, R28 */
		/* 8224CFB4h case   12:*/		regs.R3 = regs.R28;
		/* 8224CFB4h case   12:*/		return 0x8224CFB8;
		  /* 8224CFB8h */ case   13:  		/* bl -199424 */
		/* 8224CFB8h case   13:*/		regs.LR = 0x8224CFBC; return 0x8221C4B8;
		/* 8224CFB8h case   13:*/		return 0x8224CFBC;
		  /* 8224CFBCh */ case   14:  		/* mr R31, R3 */
		/* 8224CFBCh case   14:*/		regs.R31 = regs.R3;
		/* 8224CFBCh case   14:*/		return 0x8224CFC0;
		  /* 8224CFC0h */ case   15:  		/* li R11, 1 */
		/* 8224CFC0h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224CFC0h case   15:*/		return 0x8224CFC4;
		  /* 8224CFC4h */ case   16:  		/* mr R3, R30 */
		/* 8224CFC4h case   16:*/		regs.R3 = regs.R30;
		/* 8224CFC4h case   16:*/		return 0x8224CFC8;
		  /* 8224CFC8h */ case   17:  		/* li R7, 1 */
		/* 8224CFC8h case   17:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8224CFC8h case   17:*/		return 0x8224CFCC;
		  /* 8224CFCCh */ case   18:  		/* li R6, 0 */
		/* 8224CFCCh case   18:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8224CFCCh case   18:*/		return 0x8224CFD0;
		  /* 8224CFD0h */ case   19:  		/* stw R28, <#[R31]> */
		/* 8224CFD0h case   19:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 8224CFD0h case   19:*/		return 0x8224CFD4;
		  /* 8224CFD4h */ case   20:  		/* li R5, 0 */
		/* 8224CFD4h case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8224CFD4h case   20:*/		return 0x8224CFD8;
		  /* 8224CFD8h */ case   21:  		/* stw R29, <#[R31 + 4]> */
		/* 8224CFD8h case   21:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000004) );
		/* 8224CFD8h case   21:*/		return 0x8224CFDC;
		  /* 8224CFDCh */ case   22:  		/* mr R4, R26 */
		/* 8224CFDCh case   22:*/		regs.R4 = regs.R26;
		/* 8224CFDCh case   22:*/		return 0x8224CFE0;
		  /* 8224CFE0h */ case   23:  		/* stw R24, <#[R31 + 8]> */
		/* 8224CFE0h case   23:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000008) );
		/* 8224CFE0h case   23:*/		return 0x8224CFE4;
		  /* 8224CFE4h */ case   24:  		/* addi R30, R31, 4 */
		/* 8224CFE4h case   24:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x4);
		/* 8224CFE4h case   24:*/		return 0x8224CFE8;
		  /* 8224CFE8h */ case   25:  		/* stw R11, <#[R31 + 12]> */
		/* 8224CFE8h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224CFE8h case   25:*/		return 0x8224CFEC;
		  /* 8224CFECh */ case   26:  		/* bl 105796 */
		/* 8224CFECh case   26:*/		regs.LR = 0x8224CFF0; return 0x82266D30;
		/* 8224CFECh case   26:*/		return 0x8224CFF0;
		  /* 8224CFF0h */ case   27:  		/* stw R3, <#[R31 + 16]> */
		/* 8224CFF0h case   27:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8224CFF0h case   27:*/		return 0x8224CFF4;
		  /* 8224CFF4h */ case   28:  		/* stb R15, <#[R31 + 20]> */
		/* 8224CFF4h case   28:*/		cpu::mem::store8( regs, regs.R15, (uint32)(regs.R31 + 0x00000014) );
		/* 8224CFF4h case   28:*/		return 0x8224CFF8;
		  /* 8224CFF8h */ case   29:  		/* lwz R3, <#[R29 + 48]> */
		/* 8224CFF8h case   29:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000030) );
		/* 8224CFF8h case   29:*/		return 0x8224CFFC;
		  /* 8224CFFCh */ case   30:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224CFFCh case   30:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224CFFCh case   30:*/		return 0x8224D000;
		  /* 8224D000h */ case   31:  		/* bl 27328 */
		/* 8224D000h case   31:*/		regs.LR = 0x8224D004; return 0x82253AC0;
		/* 8224D000h case   31:*/		return 0x8224D004;
		  /* 8224D004h */ case   32:  		/* stw R30, <#[R3]> */
		/* 8224D004h case   32:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D004h case   32:*/		return 0x8224D008;
		  /* 8224D008h */ case   33:  		/* lwz R3, <#[R24 + 52]> */
		/* 8224D008h case   33:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000034) );
		/* 8224D008h case   33:*/		return 0x8224D00C;
		  /* 8224D00Ch */ case   34:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224D00Ch case   34:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D00Ch case   34:*/		return 0x8224D010;
		  /* 8224D010h */ case   35:  		/* bl 27312 */
		/* 8224D010h case   35:*/		regs.LR = 0x8224D014; return 0x82253AC0;
		/* 8224D010h case   35:*/		return 0x8224D014;
		  /* 8224D014h */ case   36:  		/* stw R30, <#[R3]> */
		/* 8224D014h case   36:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D014h case   36:*/		return 0x8224D018;
	}
	return 0x8224D018;
} // Block from 8224CF84h-8224D018h (37 instructions)

//////////////////////////////////////////////////////
// Block at 8224D018h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D018);
		  /* 8224D018h */ case    0:  		/* lwz R3, <#[R23 + 24]> */
		/* 8224D018h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000018) );
		/* 8224D018h case    0:*/		return 0x8224D01C;
		  /* 8224D01Ch */ case    1:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224D01Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D01Ch case    1:*/		return 0x8224D020;
		  /* 8224D020h */ case    2:  		/* bl 27296 */
		/* 8224D020h case    2:*/		regs.LR = 0x8224D024; return 0x82253AC0;
		/* 8224D020h case    2:*/		return 0x8224D024;
		  /* 8224D024h */ case    3:  		/* lwz R11, <#[R1 + 92]> */
		/* 8224D024h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8224D024h case    3:*/		return 0x8224D028;
		  /* 8224D028h */ case    4:  		/* lwz R30, <#[R1 + 88]> */
		/* 8224D028h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000058) );
		/* 8224D028h case    4:*/		return 0x8224D02C;
		  /* 8224D02Ch */ case    5:  		/* addi R11, R11, 1 */
		/* 8224D02Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224D02Ch case    5:*/		return 0x8224D030;
		  /* 8224D030h */ case    6:  		/* lwz R31, <#[R1 + 84]> */
		/* 8224D030h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 8224D030h case    6:*/		return 0x8224D034;
		  /* 8224D034h */ case    7:  		/* stw R24, <#[R3]> */
		/* 8224D034h case    7:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D034h case    7:*/		return 0x8224D038;
		  /* 8224D038h */ case    8:  		/* stw R11, <#[R1 + 92]> */
		/* 8224D038h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8224D038h case    8:*/		return 0x8224D03C;
		  /* 8224D03Ch */ case    9:  		/* rlwinm R29, R11, 0, 0, 31 */
		/* 8224D03Ch case    9:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R29,regs.R11);
		/* 8224D03Ch case    9:*/		return 0x8224D040;
	}
	return 0x8224D040;
} // Block from 8224D018h-8224D040h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224D040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D040);
		  /* 8224D040h */ case    0:  		/* lwz R26, <#[R26 + 8]> */
		/* 8224D040h case    0:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R26 + 0x00000008) );
		/* 8224D040h case    0:*/		return 0x8224D044;
		  /* 8224D044h */ case    1:  		/* lwz R11, <#[R26 + 8]> */
		/* 8224D044h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 8224D044h case    1:*/		return 0x8224D048;
		  /* 8224D048h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 8224D048h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224D048h case    2:*/		return 0x8224D04C;
		  /* 8224D04Ch */ case    3:  		/* bc 4, CR6_EQ, -1872 */
		/* 8224D04Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8224C8FC;  }
		/* 8224D04Ch case    3:*/		return 0x8224D050;
	}
	return 0x8224D050;
} // Block from 8224D040h-8224D050h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224D050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D050);
		  /* 8224D050h */ case    0:  		/* lwz R11, <#[R23 + 24]> */
		/* 8224D050h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000018) );
		/* 8224D050h case    0:*/		return 0x8224D054;
		  /* 8224D054h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8224D054h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8224D054h case    1:*/		return 0x8224D058;
		  /* 8224D058h */ case    2:  		/* cmplw CR6, R29, R11 */
		/* 8224D058h case    2:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8224D058h case    2:*/		return 0x8224D05C;
		  /* 8224D05Ch */ case    3:  		/* bc 12, CR6_EQ, 32 */
		/* 8224D05Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8224D07C;  }
		/* 8224D05Ch case    3:*/		return 0x8224D060;
		  /* 8224D060h */ case    4:  		/* lis R11, -32252 */
		/* 8224D060h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224D060h case    4:*/		return 0x8224D064;
		  /* 8224D064h */ case    5:  		/* mr R6, R31 */
		/* 8224D064h case    5:*/		regs.R6 = regs.R31;
		/* 8224D064h case    5:*/		return 0x8224D068;
		  /* 8224D068h */ case    6:  		/* addi R5, R11, 15084 */
		/* 8224D068h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3AEC);
		/* 8224D068h case    6:*/		return 0x8224D06C;
		  /* 8224D06Ch */ case    7:  		/* mr R4, R30 */
		/* 8224D06Ch case    7:*/		regs.R4 = regs.R30;
		/* 8224D06Ch case    7:*/		return 0x8224D070;
		  /* 8224D070h */ case    8:  		/* li R7, 1010 */
		/* 8224D070h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x3F2);
		/* 8224D070h case    8:*/		return 0x8224D074;
		  /* 8224D074h */ case    9:  		/* li R3, 0 */
		/* 8224D074h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224D074h case    9:*/		return 0x8224D078;
		  /* 8224D078h */ case   10:  		/* bl -1004656 */
		/* 8224D078h case   10:*/		regs.LR = 0x8224D07C; return 0x82157C08;
		/* 8224D078h case   10:*/		return 0x8224D07C;
	}
	return 0x8224D07C;
} // Block from 8224D050h-8224D07Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224D07Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D07C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D07C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D07C);
		  /* 8224D07Ch */ case    0:  		/* lbz R11, <#[R1 + 80]> */
		/* 8224D07Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8224D07Ch case    0:*/		return 0x8224D080;
		  /* 8224D080h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 8224D080h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224D080h case    1:*/		return 0x8224D084;
		  /* 8224D084h */ case    2:  		/* bc 12, CR0_EQ, 1560 */
		/* 8224D084h case    2:*/		if ( regs.CR[0].eq ) { return 0x8224D69C;  }
		/* 8224D084h case    2:*/		return 0x8224D088;
		  /* 8224D088h */ case    3:  		/* lwz R11, <#[R23]> */
		/* 8224D088h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8224D088h case    3:*/		return 0x8224D08C;
		  /* 8224D08Ch */ case    4:  		/* li R4, 28 */
		/* 8224D08Ch case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1C);
		/* 8224D08Ch case    4:*/		return 0x8224D090;
		  /* 8224D090h */ case    5:  		/* lwz R30, <#[R11 + 1456]> */
		/* 8224D090h case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224D090h case    5:*/		return 0x8224D094;
		  /* 8224D094h */ case    6:  		/* mr R3, R30 */
		/* 8224D094h case    6:*/		regs.R3 = regs.R30;
		/* 8224D094h case    6:*/		return 0x8224D098;
		  /* 8224D098h */ case    7:  		/* bl -199648 */
		/* 8224D098h case    7:*/		regs.LR = 0x8224D09C; return 0x8221C4B8;
		/* 8224D098h case    7:*/		return 0x8224D09C;
		  /* 8224D09Ch */ case    8:  		/* addic. R31, R3, 4 */
		/* 8224D09Ch case    8:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R3,0x4);
		/* 8224D09Ch case    8:*/		return 0x8224D0A0;
		  /* 8224D0A0h */ case    9:  		/* stw R30, <#[R3]> */
		/* 8224D0A0h case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D0A0h case    9:*/		return 0x8224D0A4;
		  /* 8224D0A4h */ case   10:  		/* bc 12, CR0_EQ, 48 */
		/* 8224D0A4h case   10:*/		if ( regs.CR[0].eq ) { return 0x8224D0D4;  }
		/* 8224D0A4h case   10:*/		return 0x8224D0A8;
		  /* 8224D0A8h */ case   11:  		/* lwz R11, <#[R23]> */
		/* 8224D0A8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8224D0A8h case   11:*/		return 0x8224D0AC;
		  /* 8224D0ACh */ case   12:  		/* lis R10, -32219 */
		/* 8224D0ACh case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8225);
		/* 8224D0ACh case   12:*/		return 0x8224D0B0;
		  /* 8224D0B0h */ case   13:  		/* lis R9, -32219 */
		/* 8224D0B0h case   13:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8225);
		/* 8224D0B0h case   13:*/		return 0x8224D0B4;
		  /* 8224D0B4h */ case   14:  		/* li R7, 16 */
		/* 8224D0B4h case   14:*/		cpu::op::li<0>(regs,&regs.R7,0x10);
		/* 8224D0B4h case   14:*/		return 0x8224D0B8;
		  /* 8224D0B8h */ case   15:  		/* addi R6, R10, -20888 */
		/* 8224D0B8h case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFAE68);
		/* 8224D0B8h case   15:*/		return 0x8224D0BC;
		  /* 8224D0BCh */ case   16:  		/* addi R5, R9, -20936 */
		/* 8224D0BCh case   16:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R9,0xFFFFAE38);
		/* 8224D0BCh case   16:*/		return 0x8224D0C0;
		  /* 8224D0C0h */ case   17:  		/* mr R3, R31 */
		/* 8224D0C0h case   17:*/		regs.R3 = regs.R31;
		/* 8224D0C0h case   17:*/		return 0x8224D0C4;
		  /* 8224D0C4h */ case   18:  		/* lwz R4, <#[R11 + 1456]> */
		/* 8224D0C4h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224D0C4h case   18:*/		return 0x8224D0C8;
		  /* 8224D0C8h */ case   19:  		/* bl -33576 */
		/* 8224D0C8h case   19:*/		regs.LR = 0x8224D0CC; return 0x82244DA0;
		/* 8224D0C8h case   19:*/		return 0x8224D0CC;
		  /* 8224D0CCh */ case   20:  		/* mr R20, R31 */
		/* 8224D0CCh case   20:*/		regs.R20 = regs.R31;
		/* 8224D0CCh case   20:*/		return 0x8224D0D0;
		  /* 8224D0D0h */ case   21:  		/* b 8 */
		/* 8224D0D0h case   21:*/		return 0x8224D0D8;
		/* 8224D0D0h case   21:*/		return 0x8224D0D4;
	}
	return 0x8224D0D4;
} // Block from 8224D07Ch-8224D0D4h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8224D0D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D0D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D0D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D0D4);
		  /* 8224D0D4h */ case    0:  		/* mr R20, R15 */
		/* 8224D0D4h case    0:*/		regs.R20 = regs.R15;
		/* 8224D0D4h case    0:*/		return 0x8224D0D8;
	}
	return 0x8224D0D8;
} // Block from 8224D0D4h-8224D0D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224D0D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D0D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D0D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D0D8);
		  /* 8224D0D8h */ case    0:  		/* addic. R19, R29, -1 */
		/* 8224D0D8h case    0:*/		cpu::op::addic<1>(regs,&regs.R19,regs.R29,0xFFFFFFFF);
		/* 8224D0D8h case    0:*/		return 0x8224D0DC;
		  /* 8224D0DCh */ case    1:  		/* mr R21, R15 */
		/* 8224D0DCh case    1:*/		regs.R21 = regs.R15;
		/* 8224D0DCh case    1:*/		return 0x8224D0E0;
		  /* 8224D0E0h */ case    2:  		/* mr R22, R15 */
		/* 8224D0E0h case    2:*/		regs.R22 = regs.R15;
		/* 8224D0E0h case    2:*/		return 0x8224D0E4;
		  /* 8224D0E4h */ case    3:  		/* bc 12, CR0_LT, 1436 */
		/* 8224D0E4h case    3:*/		if ( regs.CR[0].lt ) { return 0x8224D680;  }
		/* 8224D0E4h case    3:*/		return 0x8224D0E8;
		  /* 8224D0E8h */ case    4:  		/* lis R11, -32252 */
		/* 8224D0E8h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224D0E8h case    4:*/		return 0x8224D0EC;
		  /* 8224D0ECh */ case    5:  		/* lis R10, -32252 */
		/* 8224D0ECh case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224D0ECh case    5:*/		return 0x8224D0F0;
		  /* 8224D0F0h */ case    6:  		/* rlwinm R16, R19, 2, 0, 29 */
		/* 8224D0F0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R16,regs.R19);
		/* 8224D0F0h case    6:*/		return 0x8224D0F4;
		  /* 8224D0F4h */ case    7:  		/* li R24, 3 */
		/* 8224D0F4h case    7:*/		cpu::op::li<0>(regs,&regs.R24,0x3);
		/* 8224D0F4h case    7:*/		return 0x8224D0F8;
		  /* 8224D0F8h */ case    8:  		/* addi R18, R11, 15056 */
		/* 8224D0F8h case    8:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R11,0x3AD0);
		/* 8224D0F8h case    8:*/		return 0x8224D0FC;
		  /* 8224D0FCh */ case    9:  		/* addi R17, R10, 15020 */
		/* 8224D0FCh case    9:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R10,0x3AAC);
		/* 8224D0FCh case    9:*/		return 0x8224D100;
		  /* 8224D100h */ case   10:  		/* b 8 */
		/* 8224D100h case   10:*/		return 0x8224D108;
		/* 8224D100h case   10:*/		return 0x8224D104;
		  /* 8224D104h */ case   11:  		/* lwz R29, <#[R1 + 92]> */
		/* 8224D104h case   11:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x0000005C) );
		/* 8224D104h case   11:*/		return 0x8224D108;
	}
	return 0x8224D108;
} // Block from 8224D0D8h-8224D108h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224D108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D108);
		  /* 8224D108h */ case    0:  		/* lwz R3, <#[R23 + 24]> */
		/* 8224D108h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000018) );
		/* 8224D108h case    0:*/		return 0x8224D10C;
		  /* 8224D10Ch */ case    1:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224D10Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D10Ch case    1:*/		return 0x8224D110;
		  /* 8224D110h */ case    2:  		/* cmplw CR6, R19, R11 */
		/* 8224D110h case    2:*/		cpu::op::cmplw<6>(regs,regs.R19,regs.R11);
		/* 8224D110h case    2:*/		return 0x8224D114;
		  /* 8224D114h */ case    3:  		/* bc 4, CR6_LT, 16 */
		/* 8224D114h case    3:*/		if ( !regs.CR[6].lt ) { return 0x8224D124;  }
		/* 8224D114h case    3:*/		return 0x8224D118;
		  /* 8224D118h */ case    4:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224D118h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224D118h case    4:*/		return 0x8224D11C;
		  /* 8224D11Ch */ case    5:  		/* add R3, R11, R16 */
		/* 8224D11Ch case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R16);
		/* 8224D11Ch case    5:*/		return 0x8224D120;
		  /* 8224D120h */ case    6:  		/* b 12 */
		/* 8224D120h case    6:*/		return 0x8224D12C;
		/* 8224D120h case    6:*/		return 0x8224D124;
	}
	return 0x8224D124;
} // Block from 8224D108h-8224D124h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224D124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D124);
		  /* 8224D124h */ case    0:  		/* mr R4, R19 */
		/* 8224D124h case    0:*/		regs.R4 = regs.R19;
		/* 8224D124h case    0:*/		return 0x8224D128;
		  /* 8224D128h */ case    1:  		/* bl 27032 */
		/* 8224D128h case    1:*/		regs.LR = 0x8224D12C; return 0x82253AC0;
		/* 8224D128h case    1:*/		return 0x8224D12C;
	}
	return 0x8224D12C;
} // Block from 8224D124h-8224D12Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224D12Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D12C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D12C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D12C);
		  /* 8224D12Ch */ case    0:  		/* lwz R30, <#[R3]> */
		/* 8224D12Ch case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D12Ch case    0:*/		return 0x8224D130;
		  /* 8224D130h */ case    1:  		/* lwz R26, <#[R30 + 40]> */
		/* 8224D130h case    1:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R30 + 0x00000028) );
		/* 8224D130h case    1:*/		return 0x8224D134;
		  /* 8224D134h */ case    2:  		/* mr R3, R26 */
		/* 8224D134h case    2:*/		regs.R3 = regs.R26;
		/* 8224D134h case    2:*/		return 0x8224D138;
		  /* 8224D138h */ case    3:  		/* bl 105192 */
		/* 8224D138h case    3:*/		regs.LR = 0x8224D13C; return 0x82266C20;
		/* 8224D138h case    3:*/		return 0x8224D13C;
		  /* 8224D13Ch */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224D13Ch case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224D13Ch case    4:*/		return 0x8224D140;
		  /* 8224D140h */ case    5:  		/* bc 12, CR0_EQ, 280 */
		/* 8224D140h case    5:*/		if ( regs.CR[0].eq ) { return 0x8224D258;  }
		/* 8224D140h case    5:*/		return 0x8224D144;
		  /* 8224D144h */ case    6:  		/* mr R4, R26 */
		/* 8224D144h case    6:*/		regs.R4 = regs.R26;
		/* 8224D144h case    6:*/		return 0x8224D148;
		  /* 8224D148h */ case    7:  		/* mr R3, R20 */
		/* 8224D148h case    7:*/		regs.R3 = regs.R20;
		/* 8224D148h case    7:*/		return 0x8224D14C;
		  /* 8224D14Ch */ case    8:  		/* bl 27692 */
		/* 8224D14Ch case    8:*/		regs.LR = 0x8224D150; return 0x82253D78;
		/* 8224D14Ch case    8:*/		return 0x8224D150;
		  /* 8224D150h */ case    9:  		/* or. R27, R3, R3 */
		/* 8224D150h case    9:*/		cpu::op::or<1>(regs,&regs.R27,regs.R3,regs.R3);
		/* 8224D150h case    9:*/		return 0x8224D154;
		  /* 8224D154h */ case   10:  		/* bc 12, CR0_EQ, 248 */
		/* 8224D154h case   10:*/		if ( regs.CR[0].eq ) { return 0x8224D24C;  }
		/* 8224D154h case   10:*/		return 0x8224D158;
		  /* 8224D158h */ case   11:  		/* lwz R11, <#[R27 + 892]> */
		/* 8224D158h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000037C) );
		/* 8224D158h case   11:*/		return 0x8224D15C;
		  /* 8224D15Ch */ case   12:  		/* cmpw CR6, R11, R29 */
		/* 8224D15Ch case   12:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R29);
		/* 8224D15Ch case   12:*/		return 0x8224D160;
		  /* 8224D160h */ case   13:  		/* bc 12, CR6_LT, 28 */
		/* 8224D160h case   13:*/		if ( regs.CR[6].lt ) { return 0x8224D17C;  }
		/* 8224D160h case   13:*/		return 0x8224D164;
		  /* 8224D164h */ case   14:  		/* mr R5, R17 */
		/* 8224D164h case   14:*/		regs.R5 = regs.R17;
		/* 8224D164h case   14:*/		return 0x8224D168;
		  /* 8224D168h */ case   15:  		/* lwz R6, <#[R1 + 84]> */
		/* 8224D168h case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 8224D168h case   15:*/		return 0x8224D16C;
		  /* 8224D16Ch */ case   16:  		/* li R7, 1060 */
		/* 8224D16Ch case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x424);
		/* 8224D16Ch case   16:*/		return 0x8224D170;
	}
	return 0x8224D170;
} // Block from 8224D12Ch-8224D170h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8224D170h
// Function '?FindOrCreateInputDefNode@Scheduler@XGRAPHICS@@AAAPAVSchedNode@2@PAVIRInst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D170);
		  /* 8224D170h */ case    0:  		/* lwz R4, <#[R1 + 88]> */
		/* 8224D170h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000058) );
		/* 8224D170h case    0:*/		return 0x8224D174;
		  /* 8224D174h */ case    1:  		/* li R3, 0 */
		/* 8224D174h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224D174h case    1:*/		return 0x8224D178;
		  /* 8224D178h */ case    2:  		/* bl -1004912 */
		/* 8224D178h case    2:*/		regs.LR = 0x8224D17C; return 0x82157C08;
		/* 8224D178h case    2:*/		return 0x8224D17C;
	}
	return 0x8224D17C;
} // Block from 8224D170h-8224D17Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224D17Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D17C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D17C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D17C);
		  /* 8224D17Ch */ case    0:  		/* lwz R3, <#[R23 + 24]> */
		/* 8224D17Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000018) );
		/* 8224D17Ch case    0:*/		return 0x8224D180;
		  /* 8224D180h */ case    1:  		/* lwz R4, <#[R27 + 892]> */
		/* 8224D180h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x0000037C) );
		/* 8224D180h case    1:*/		return 0x8224D184;
		  /* 8224D184h */ case    2:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224D184h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D184h case    2:*/		return 0x8224D188;
		  /* 8224D188h */ case    3:  		/* cmplw CR6, R4, R11 */
		/* 8224D188h case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 8224D188h case    3:*/		return 0x8224D18C;
		  /* 8224D18Ch */ case    4:  		/* bc 4, CR6_LT, 20 */
		/* 8224D18Ch case    4:*/		if ( !regs.CR[6].lt ) { return 0x8224D1A0;  }
		/* 8224D18Ch case    4:*/		return 0x8224D190;
		  /* 8224D190h */ case    5:  		/* lwz R10, <#[R3 + 8]> */
		/* 8224D190h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 8224D190h case    5:*/		return 0x8224D194;
		  /* 8224D194h */ case    6:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 8224D194h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 8224D194h case    6:*/		return 0x8224D198;
		  /* 8224D198h */ case    7:  		/* add R3, R10, R11 */
		/* 8224D198h case    7:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8224D198h case    7:*/		return 0x8224D19C;
		  /* 8224D19Ch */ case    8:  		/* b 8 */
		/* 8224D19Ch case    8:*/		return 0x8224D1A4;
		/* 8224D19Ch case    8:*/		return 0x8224D1A0;
	}
	return 0x8224D1A0;
} // Block from 8224D17Ch-8224D1A0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224D1A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D1A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D1A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D1A0);
		  /* 8224D1A0h */ case    0:  		/* bl 26912 */
		/* 8224D1A0h case    0:*/		regs.LR = 0x8224D1A4; return 0x82253AC0;
		/* 8224D1A0h case    0:*/		return 0x8224D1A4;
	}
	return 0x8224D1A4;
} // Block from 8224D1A0h-8224D1A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224D1A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D1A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D1A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D1A4);
		  /* 8224D1A4h */ case    0:  		/* lwz R28, <#[R3]> */
		/* 8224D1A4h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D1A4h case    0:*/		return 0x8224D1A8;
		  /* 8224D1A8h */ case    1:  		/* lwz R11, <#[R28 + 40]> */
		/* 8224D1A8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000028) );
		/* 8224D1A8h case    1:*/		return 0x8224D1AC;
		  /* 8224D1ACh */ case    2:  		/* cmplw CR6, R11, R27 */
		/* 8224D1ACh case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 8224D1ACh case    2:*/		return 0x8224D1B0;
		  /* 8224D1B0h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 8224D1B0h case    3:*/		if ( regs.CR[6].eq ) { return 0x8224D1CC;  }
		/* 8224D1B0h case    3:*/		return 0x8224D1B4;
		  /* 8224D1B4h */ case    4:  		/* mr R5, R18 */
		/* 8224D1B4h case    4:*/		regs.R5 = regs.R18;
		/* 8224D1B4h case    4:*/		return 0x8224D1B8;
		  /* 8224D1B8h */ case    5:  		/* lwz R6, <#[R1 + 84]> */
		/* 8224D1B8h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 8224D1B8h case    5:*/		return 0x8224D1BC;
		  /* 8224D1BCh */ case    6:  		/* li R7, 1062 */
		/* 8224D1BCh case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x426);
		/* 8224D1BCh case    6:*/		return 0x8224D1C0;
		  /* 8224D1C0h */ case    7:  		/* lwz R4, <#[R1 + 88]> */
		/* 8224D1C0h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000058) );
		/* 8224D1C0h case    7:*/		return 0x8224D1C4;
		  /* 8224D1C4h */ case    8:  		/* li R3, 0 */
		/* 8224D1C4h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224D1C4h case    8:*/		return 0x8224D1C8;
		  /* 8224D1C8h */ case    9:  		/* bl -1004992 */
		/* 8224D1C8h case    9:*/		regs.LR = 0x8224D1CC; return 0x82157C08;
		/* 8224D1C8h case    9:*/		return 0x8224D1CC;
	}
	return 0x8224D1CC;
} // Block from 8224D1A4h-8224D1CCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224D1CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D1CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D1CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D1CC);
		  /* 8224D1CCh */ case    0:  		/* lwz R11, <#[R23]> */
		/* 8224D1CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8224D1CCh case    0:*/		return 0x8224D1D0;
		  /* 8224D1D0h */ case    1:  		/* li R4, 24 */
		/* 8224D1D0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 8224D1D0h case    1:*/		return 0x8224D1D4;
		  /* 8224D1D4h */ case    2:  		/* lwz R29, <#[R11 + 1456]> */
		/* 8224D1D4h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224D1D4h case    2:*/		return 0x8224D1D8;
		  /* 8224D1D8h */ case    3:  		/* mr R3, R29 */
		/* 8224D1D8h case    3:*/		regs.R3 = regs.R29;
		/* 8224D1D8h case    3:*/		return 0x8224D1DC;
		  /* 8224D1DCh */ case    4:  		/* bl -199972 */
		/* 8224D1DCh case    4:*/		regs.LR = 0x8224D1E0; return 0x8221C4B8;
		/* 8224D1DCh case    4:*/		return 0x8224D1E0;
		  /* 8224D1E0h */ case    5:  		/* mr R31, R3 */
		/* 8224D1E0h case    5:*/		regs.R31 = regs.R3;
		/* 8224D1E0h case    5:*/		return 0x8224D1E4;
		  /* 8224D1E4h */ case    6:  		/* li R11, 1 */
		/* 8224D1E4h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224D1E4h case    6:*/		return 0x8224D1E8;
		  /* 8224D1E8h */ case    7:  		/* stw R29, <#[R3]> */
		/* 8224D1E8h case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D1E8h case    7:*/		return 0x8224D1EC;
		  /* 8224D1ECh */ case    8:  		/* stw R30, <#[R3 + 4]> */
		/* 8224D1ECh case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D1ECh case    8:*/		return 0x8224D1F0;
		  /* 8224D1F0h */ case    9:  		/* li R7, 1 */
		/* 8224D1F0h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8224D1F0h case    9:*/		return 0x8224D1F4;
		  /* 8224D1F4h */ case   10:  		/* li R6, 0 */
		/* 8224D1F4h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8224D1F4h case   10:*/		return 0x8224D1F8;
		  /* 8224D1F8h */ case   11:  		/* li R5, 0 */
		/* 8224D1F8h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8224D1F8h case   11:*/		return 0x8224D1FC;
		  /* 8224D1FCh */ case   12:  		/* stw R28, <#[R31 + 8]> */
		/* 8224D1FCh case   12:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000008) );
		/* 8224D1FCh case   12:*/		return 0x8224D200;
		  /* 8224D200h */ case   13:  		/* mr R4, R27 */
		/* 8224D200h case   13:*/		regs.R4 = regs.R27;
		/* 8224D200h case   13:*/		return 0x8224D204;
		  /* 8224D204h */ case   14:  		/* stw R11, <#[R31 + 12]> */
		/* 8224D204h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224D204h case   14:*/		return 0x8224D208;
		  /* 8224D208h */ case   15:  		/* mr R3, R26 */
		/* 8224D208h case   15:*/		regs.R3 = regs.R26;
		/* 8224D208h case   15:*/		return 0x8224D20C;
		  /* 8224D20Ch */ case   16:  		/* addi R29, R31, 4 */
		/* 8224D20Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x4);
		/* 8224D20Ch case   16:*/		return 0x8224D210;
		  /* 8224D210h */ case   17:  		/* bl 105248 */
		/* 8224D210h case   17:*/		regs.LR = 0x8224D214; return 0x82266D30;
		/* 8224D210h case   17:*/		return 0x8224D214;
		  /* 8224D214h */ case   18:  		/* stw R3, <#[R31 + 16]> */
		/* 8224D214h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8224D214h case   18:*/		return 0x8224D218;
		  /* 8224D218h */ case   19:  		/* stb R15, <#[R31 + 20]> */
		/* 8224D218h case   19:*/		cpu::mem::store8( regs, regs.R15, (uint32)(regs.R31 + 0x00000014) );
		/* 8224D218h case   19:*/		return 0x8224D21C;
		  /* 8224D21Ch */ case   20:  		/* lwz R3, <#[R30 + 48]> */
		/* 8224D21Ch case   20:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 8224D21Ch case   20:*/		return 0x8224D220;
		  /* 8224D220h */ case   21:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224D220h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D220h case   21:*/		return 0x8224D224;
		  /* 8224D224h */ case   22:  		/* bl 26780 */
		/* 8224D224h case   22:*/		regs.LR = 0x8224D228; return 0x82253AC0;
		/* 8224D224h case   22:*/		return 0x8224D228;
		  /* 8224D228h */ case   23:  		/* stw R29, <#[R3]> */
		/* 8224D228h case   23:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D228h case   23:*/		return 0x8224D22C;
		  /* 8224D22Ch */ case   24:  		/* lwz R3, <#[R28 + 52]> */
		/* 8224D22Ch case   24:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000034) );
		/* 8224D22Ch case   24:*/		return 0x8224D230;
		  /* 8224D230h */ case   25:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224D230h case   25:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D230h case   25:*/		return 0x8224D234;
		  /* 8224D234h */ case   26:  		/* bl 26764 */
		/* 8224D234h case   26:*/		regs.LR = 0x8224D238; return 0x82253AC0;
		/* 8224D234h case   26:*/		return 0x8224D238;
		  /* 8224D238h */ case   27:  		/* mr R11, R3 */
		/* 8224D238h case   27:*/		regs.R11 = regs.R3;
		/* 8224D238h case   27:*/		return 0x8224D23C;
		  /* 8224D23Ch */ case   28:  		/* mr R4, R27 */
		/* 8224D23Ch case   28:*/		regs.R4 = regs.R27;
		/* 8224D23Ch case   28:*/		return 0x8224D240;
		  /* 8224D240h */ case   29:  		/* mr R3, R20 */
		/* 8224D240h case   29:*/		regs.R3 = regs.R20;
		/* 8224D240h case   29:*/		return 0x8224D244;
		  /* 8224D244h */ case   30:  		/* stw R29, <#[R11]> */
		/* 8224D244h case   30:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 8224D244h case   30:*/		return 0x8224D248;
		  /* 8224D248h */ case   31:  		/* bl 27824 */
		/* 8224D248h case   31:*/		regs.LR = 0x8224D24C; return 0x82253EF8;
		/* 8224D248h case   31:*/		return 0x8224D24C;
	}
	return 0x8224D24C;
} // Block from 8224D1CCh-8224D24Ch (32 instructions)

//////////////////////////////////////////////////////
// Block at 8224D24Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D24C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D24C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D24C);
		  /* 8224D24Ch */ case    0:  		/* mr R4, R26 */
		/* 8224D24Ch case    0:*/		regs.R4 = regs.R26;
		/* 8224D24Ch case    0:*/		return 0x8224D250;
		  /* 8224D250h */ case    1:  		/* mr R3, R20 */
		/* 8224D250h case    1:*/		regs.R3 = regs.R20;
		/* 8224D250h case    1:*/		return 0x8224D254;
		  /* 8224D254h */ case    2:  		/* bl 27620 */
		/* 8224D254h case    2:*/		regs.LR = 0x8224D258; return 0x82253E38;
		/* 8224D254h case    2:*/		return 0x8224D258;
	}
	return 0x8224D258;
} // Block from 8224D24Ch-8224D258h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224D258h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D258);
		  /* 8224D258h */ case    0:  		/* mr R3, R26 */
		/* 8224D258h case    0:*/		regs.R3 = regs.R26;
		/* 8224D258h case    0:*/		return 0x8224D25C;
		  /* 8224D25Ch */ case    1:  		/* bl 105052 */
		/* 8224D25Ch case    1:*/		regs.LR = 0x8224D260; return 0x82266CB8;
		/* 8224D25Ch case    1:*/		return 0x8224D260;
		  /* 8224D260h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224D260h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224D260h case    2:*/		return 0x8224D264;
		  /* 8224D264h */ case    3:  		/* bc 12, CR0_EQ, 124 */
		/* 8224D264h case    3:*/		if ( regs.CR[0].eq ) { return 0x8224D2E0;  }
		/* 8224D264h case    3:*/		return 0x8224D268;
		  /* 8224D268h */ case    4:  		/* cmplwi CR6, R21, 0 */
		/* 8224D268h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 8224D268h case    4:*/		return 0x8224D26C;
		  /* 8224D26Ch */ case    5:  		/* bc 12, CR6_EQ, 112 */
		/* 8224D26Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x8224D2DC;  }
		/* 8224D26Ch case    5:*/		return 0x8224D270;
		  /* 8224D270h */ case    6:  		/* lwz R11, <#[R23]> */
		/* 8224D270h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8224D270h case    6:*/		return 0x8224D274;
		  /* 8224D274h */ case    7:  		/* li R4, 24 */
		/* 8224D274h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 8224D274h case    7:*/		return 0x8224D278;
		  /* 8224D278h */ case    8:  		/* lwz R29, <#[R11 + 1456]> */
		/* 8224D278h case    8:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224D278h case    8:*/		return 0x8224D27C;
		  /* 8224D27Ch */ case    9:  		/* mr R3, R29 */
		/* 8224D27Ch case    9:*/		regs.R3 = regs.R29;
		/* 8224D27Ch case    9:*/		return 0x8224D280;
		  /* 8224D280h */ case   10:  		/* bl -200136 */
		/* 8224D280h case   10:*/		regs.LR = 0x8224D284; return 0x8221C4B8;
		/* 8224D280h case   10:*/		return 0x8224D284;
		  /* 8224D284h */ case   11:  		/* mr R31, R3 */
		/* 8224D284h case   11:*/		regs.R31 = regs.R3;
		/* 8224D284h case   11:*/		return 0x8224D288;
		  /* 8224D288h */ case   12:  		/* li R7, 3 */
		/* 8224D288h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 8224D288h case   12:*/		return 0x8224D28C;
		  /* 8224D28Ch */ case   13:  		/* li R6, 0 */
		/* 8224D28Ch case   13:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8224D28Ch case   13:*/		return 0x8224D290;
		  /* 8224D290h */ case   14:  		/* li R5, 0 */
		/* 8224D290h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8224D290h case   14:*/		return 0x8224D294;
		  /* 8224D294h */ case   15:  		/* mr R3, R26 */
		/* 8224D294h case   15:*/		regs.R3 = regs.R26;
		/* 8224D294h case   15:*/		return 0x8224D298;
		  /* 8224D298h */ case   16:  		/* stw R29, <#[R31]> */
		/* 8224D298h case   16:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000000) );
		/* 8224D298h case   16:*/		return 0x8224D29C;
		  /* 8224D29Ch */ case   17:  		/* addi R29, R31, 4 */
		/* 8224D29Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x4);
		/* 8224D29Ch case   17:*/		return 0x8224D2A0;
		  /* 8224D2A0h */ case   18:  		/* stw R30, <#[R31 + 4]> */
		/* 8224D2A0h case   18:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 8224D2A0h case   18:*/		return 0x8224D2A4;
		  /* 8224D2A4h */ case   19:  		/* stw R21, <#[R31 + 8]> */
		/* 8224D2A4h case   19:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R31 + 0x00000008) );
		/* 8224D2A4h case   19:*/		return 0x8224D2A8;
		  /* 8224D2A8h */ case   20:  		/* stw R24, <#[R31 + 12]> */
		/* 8224D2A8h case   20:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224D2A8h case   20:*/		return 0x8224D2AC;
		  /* 8224D2ACh */ case   21:  		/* lwz R4, <#[R21 + 40]> */
		/* 8224D2ACh case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R21 + 0x00000028) );
		/* 8224D2ACh case   21:*/		return 0x8224D2B0;
		  /* 8224D2B0h */ case   22:  		/* bl 105088 */
		/* 8224D2B0h case   22:*/		regs.LR = 0x8224D2B4; return 0x82266D30;
		/* 8224D2B0h case   22:*/		return 0x8224D2B4;
		  /* 8224D2B4h */ case   23:  		/* stw R3, <#[R31 + 16]> */
		/* 8224D2B4h case   23:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8224D2B4h case   23:*/		return 0x8224D2B8;
		  /* 8224D2B8h */ case   24:  		/* stb R15, <#[R31 + 20]> */
		/* 8224D2B8h case   24:*/		cpu::mem::store8( regs, regs.R15, (uint32)(regs.R31 + 0x00000014) );
		/* 8224D2B8h case   24:*/		return 0x8224D2BC;
		  /* 8224D2BCh */ case   25:  		/* lwz R3, <#[R30 + 48]> */
		/* 8224D2BCh case   25:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 8224D2BCh case   25:*/		return 0x8224D2C0;
		  /* 8224D2C0h */ case   26:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224D2C0h case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D2C0h case   26:*/		return 0x8224D2C4;
		  /* 8224D2C4h */ case   27:  		/* bl 26620 */
		/* 8224D2C4h case   27:*/		regs.LR = 0x8224D2C8; return 0x82253AC0;
		/* 8224D2C4h case   27:*/		return 0x8224D2C8;
		  /* 8224D2C8h */ case   28:  		/* stw R29, <#[R3]> */
		/* 8224D2C8h case   28:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D2C8h case   28:*/		return 0x8224D2CC;
		  /* 8224D2CCh */ case   29:  		/* lwz R3, <#[R21 + 52]> */
		/* 8224D2CCh case   29:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R21 + 0x00000034) );
		/* 8224D2CCh case   29:*/		return 0x8224D2D0;
		  /* 8224D2D0h */ case   30:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224D2D0h case   30:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D2D0h case   30:*/		return 0x8224D2D4;
		  /* 8224D2D4h */ case   31:  		/* bl 26604 */
		/* 8224D2D4h case   31:*/		regs.LR = 0x8224D2D8; return 0x82253AC0;
		/* 8224D2D4h case   31:*/		return 0x8224D2D8;
		  /* 8224D2D8h */ case   32:  		/* stw R29, <#[R3]> */
		/* 8224D2D8h case   32:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D2D8h case   32:*/		return 0x8224D2DC;
	}
	return 0x8224D2DC;
} // Block from 8224D258h-8224D2DCh (33 instructions)

//////////////////////////////////////////////////////
// Block at 8224D2DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D2DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D2DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D2DC);
		  /* 8224D2DCh */ case    0:  		/* mr R21, R30 */
		/* 8224D2DCh case    0:*/		regs.R21 = regs.R30;
		/* 8224D2DCh case    0:*/		return 0x8224D2E0;
	}
	return 0x8224D2E0;
} // Block from 8224D2DCh-8224D2E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224D2E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D2E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D2E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D2E0);
		  /* 8224D2E0h */ case    0:  		/* mr R3, R26 */
		/* 8224D2E0h case    0:*/		regs.R3 = regs.R26;
		/* 8224D2E0h case    0:*/		return 0x8224D2E4;
		  /* 8224D2E4h */ case    1:  		/* bl 104972 */
		/* 8224D2E4h case    1:*/		regs.LR = 0x8224D2E8; return 0x82266CF0;
		/* 8224D2E4h case    1:*/		return 0x8224D2E8;
		  /* 8224D2E8h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224D2E8h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224D2E8h case    2:*/		return 0x8224D2EC;
		  /* 8224D2ECh */ case    3:  		/* bc 12, CR0_EQ, 124 */
		/* 8224D2ECh case    3:*/		if ( regs.CR[0].eq ) { return 0x8224D368;  }
		/* 8224D2ECh case    3:*/		return 0x8224D2F0;
		  /* 8224D2F0h */ case    4:  		/* cmplwi CR6, R22, 0 */
		/* 8224D2F0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 8224D2F0h case    4:*/		return 0x8224D2F4;
		  /* 8224D2F4h */ case    5:  		/* bc 12, CR6_EQ, 112 */
		/* 8224D2F4h case    5:*/		if ( regs.CR[6].eq ) { return 0x8224D364;  }
		/* 8224D2F4h case    5:*/		return 0x8224D2F8;
		  /* 8224D2F8h */ case    6:  		/* lwz R11, <#[R23]> */
		/* 8224D2F8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8224D2F8h case    6:*/		return 0x8224D2FC;
		  /* 8224D2FCh */ case    7:  		/* li R4, 24 */
		/* 8224D2FCh case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 8224D2FCh case    7:*/		return 0x8224D300;
		  /* 8224D300h */ case    8:  		/* lwz R29, <#[R11 + 1456]> */
		/* 8224D300h case    8:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224D300h case    8:*/		return 0x8224D304;
		  /* 8224D304h */ case    9:  		/* mr R3, R29 */
		/* 8224D304h case    9:*/		regs.R3 = regs.R29;
		/* 8224D304h case    9:*/		return 0x8224D308;
		  /* 8224D308h */ case   10:  		/* bl -200272 */
		/* 8224D308h case   10:*/		regs.LR = 0x8224D30C; return 0x8221C4B8;
		/* 8224D308h case   10:*/		return 0x8224D30C;
		  /* 8224D30Ch */ case   11:  		/* mr R31, R3 */
		/* 8224D30Ch case   11:*/		regs.R31 = regs.R3;
		/* 8224D30Ch case   11:*/		return 0x8224D310;
		  /* 8224D310h */ case   12:  		/* li R7, 3 */
		/* 8224D310h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 8224D310h case   12:*/		return 0x8224D314;
		  /* 8224D314h */ case   13:  		/* li R6, 0 */
		/* 8224D314h case   13:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8224D314h case   13:*/		return 0x8224D318;
		  /* 8224D318h */ case   14:  		/* li R5, 0 */
		/* 8224D318h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8224D318h case   14:*/		return 0x8224D31C;
		  /* 8224D31Ch */ case   15:  		/* mr R3, R26 */
		/* 8224D31Ch case   15:*/		regs.R3 = regs.R26;
		/* 8224D31Ch case   15:*/		return 0x8224D320;
		  /* 8224D320h */ case   16:  		/* stw R29, <#[R31]> */
		/* 8224D320h case   16:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000000) );
		/* 8224D320h case   16:*/		return 0x8224D324;
		  /* 8224D324h */ case   17:  		/* addi R29, R31, 4 */
		/* 8224D324h case   17:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x4);
		/* 8224D324h case   17:*/		return 0x8224D328;
		  /* 8224D328h */ case   18:  		/* stw R30, <#[R31 + 4]> */
		/* 8224D328h case   18:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 8224D328h case   18:*/		return 0x8224D32C;
		  /* 8224D32Ch */ case   19:  		/* stw R22, <#[R31 + 8]> */
		/* 8224D32Ch case   19:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000008) );
		/* 8224D32Ch case   19:*/		return 0x8224D330;
		  /* 8224D330h */ case   20:  		/* stw R24, <#[R31 + 12]> */
		/* 8224D330h case   20:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224D330h case   20:*/		return 0x8224D334;
		  /* 8224D334h */ case   21:  		/* lwz R4, <#[R22 + 40]> */
		/* 8224D334h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R22 + 0x00000028) );
		/* 8224D334h case   21:*/		return 0x8224D338;
	}
	return 0x8224D338;
} // Block from 8224D2E0h-8224D338h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8224D338h
// Function '?BuildGraph@Scheduler@XGRAPHICS@@AAAXPAVBlock@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D338);
		  /* 8224D338h */ case    0:  		/* bl 104952 */
		/* 8224D338h case    0:*/		regs.LR = 0x8224D33C; return 0x82266D30;
		/* 8224D338h case    0:*/		return 0x8224D33C;
		  /* 8224D33Ch */ case    1:  		/* stw R3, <#[R31 + 16]> */
		/* 8224D33Ch case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8224D33Ch case    1:*/		return 0x8224D340;
		  /* 8224D340h */ case    2:  		/* stb R15, <#[R31 + 20]> */
		/* 8224D340h case    2:*/		cpu::mem::store8( regs, regs.R15, (uint32)(regs.R31 + 0x00000014) );
		/* 8224D340h case    2:*/		return 0x8224D344;
		  /* 8224D344h */ case    3:  		/* lwz R3, <#[R30 + 48]> */
		/* 8224D344h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 8224D344h case    3:*/		return 0x8224D348;
		  /* 8224D348h */ case    4:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224D348h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D348h case    4:*/		return 0x8224D34C;
		  /* 8224D34Ch */ case    5:  		/* bl 26484 */
		/* 8224D34Ch case    5:*/		regs.LR = 0x8224D350; return 0x82253AC0;
		/* 8224D34Ch case    5:*/		return 0x8224D350;
		  /* 8224D350h */ case    6:  		/* stw R29, <#[R3]> */
		/* 8224D350h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D350h case    6:*/		return 0x8224D354;
		  /* 8224D354h */ case    7:  		/* lwz R3, <#[R22 + 52]> */
		/* 8224D354h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000034) );
		/* 8224D354h case    7:*/		return 0x8224D358;
		  /* 8224D358h */ case    8:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224D358h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D358h case    8:*/		return 0x8224D35C;
		  /* 8224D35Ch */ case    9:  		/* bl 26468 */
		/* 8224D35Ch case    9:*/		regs.LR = 0x8224D360; return 0x82253AC0;
		/* 8224D35Ch case    9:*/		return 0x8224D360;
		  /* 8224D360h */ case   10:  		/* stw R29, <#[R3]> */
		/* 8224D360h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D360h case   10:*/		return 0x8224D364;
	}
	return 0x8224D364;
} // Block from 8224D338h-8224D364h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224D364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D364);
		  /* 8224D364h */ case    0:  		/* mr R22, R30 */
		/* 8224D364h case    0:*/		regs.R22 = regs.R30;
		/* 8224D364h case    0:*/		return 0x8224D368;
	}
	return 0x8224D368;
} // Block from 8224D364h-8224D368h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224D368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D368);
		  /* 8224D368h */ case    0:  		/* lwz R11, <#[R26 + 20]> */
		/* 8224D368h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 8224D368h case    0:*/		return 0x8224D36C;
		  /* 8224D36Ch */ case    1:  		/* li R27, 1 */
		/* 8224D36Ch case    1:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 8224D36Ch case    1:*/		return 0x8224D370;
		  /* 8224D370h */ case    2:  		/* cmpwi CR6, R11, 1 */
		/* 8224D370h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 8224D370h case    2:*/		return 0x8224D374;
		  /* 8224D374h */ case    3:  		/* bc 12, CR6_LT, 304 */
		/* 8224D374h case    3:*/		if ( regs.CR[6].lt ) { return 0x8224D4A4;  }
		/* 8224D374h case    3:*/		return 0x8224D378;
		  /* 8224D378h */ case    4:  		/* addi R25, R26, 236 */
		/* 8224D378h case    4:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R26,0xEC);
		/* 8224D378h case    4:*/		return 0x8224D37C;
		  /* 8224D37Ch */ case    5:  		/* lwz R3, <#[R25]> */
		/* 8224D37Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R25 + 0x00000000) );
		/* 8224D37Ch case    5:*/		return 0x8224D380;
		  /* 8224D380h */ case    6:  		/* bl 104608 */
		/* 8224D380h case    6:*/		regs.LR = 0x8224D384; return 0x82266C20;
		/* 8224D380h case    6:*/		return 0x8224D384;
		  /* 8224D384h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224D384h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224D384h case    7:*/		return 0x8224D388;
		  /* 8224D388h */ case    8:  		/* bc 12, CR0_EQ, 264 */
		/* 8224D388h case    8:*/		if ( regs.CR[0].eq ) { return 0x8224D490;  }
		/* 8224D388h case    8:*/		return 0x8224D38C;
		  /* 8224D38Ch */ case    9:  		/* mr R3, R20 */
		/* 8224D38Ch case    9:*/		regs.R3 = regs.R20;
		/* 8224D38Ch case    9:*/		return 0x8224D390;
		  /* 8224D390h */ case   10:  		/* lwz R4, <#[R25]> */
		/* 8224D390h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R25 + 0x00000000) );
		/* 8224D390h case   10:*/		return 0x8224D394;
		  /* 8224D394h */ case   11:  		/* bl 27108 */
		/* 8224D394h case   11:*/		regs.LR = 0x8224D398; return 0x82253D78;
		/* 8224D394h case   11:*/		return 0x8224D398;
		  /* 8224D398h */ case   12:  		/* or. R29, R3, R3 */
		/* 8224D398h case   12:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 8224D398h case   12:*/		return 0x8224D39C;
		  /* 8224D39Ch */ case   13:  		/* bc 12, CR0_EQ, 244 */
		/* 8224D39Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x8224D490;  }
		/* 8224D39Ch case   13:*/		return 0x8224D3A0;
		  /* 8224D3A0h */ case   14:  		/* cmplw CR6, R29, R26 */
		/* 8224D3A0h case   14:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R26);
		/* 8224D3A0h case   14:*/		return 0x8224D3A4;
		  /* 8224D3A4h */ case   15:  		/* bc 12, CR6_EQ, 236 */
		/* 8224D3A4h case   15:*/		if ( regs.CR[6].eq ) { return 0x8224D490;  }
		/* 8224D3A4h case   15:*/		return 0x8224D3A8;
		  /* 8224D3A8h */ case   16:  		/* lwz R11, <#[R29 + 892]> */
		/* 8224D3A8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000037C) );
		/* 8224D3A8h case   16:*/		return 0x8224D3AC;
		  /* 8224D3ACh */ case   17:  		/* lwz R10, <#[R1 + 92]> */
		/* 8224D3ACh case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 8224D3ACh case   17:*/		return 0x8224D3B0;
		  /* 8224D3B0h */ case   18:  		/* cmpw CR6, R11, R10 */
		/* 8224D3B0h case   18:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224D3B0h case   18:*/		return 0x8224D3B4;
		  /* 8224D3B4h */ case   19:  		/* bc 12, CR6_LT, 28 */
		/* 8224D3B4h case   19:*/		if ( regs.CR[6].lt ) { return 0x8224D3D0;  }
		/* 8224D3B4h case   19:*/		return 0x8224D3B8;
		  /* 8224D3B8h */ case   20:  		/* mr R5, R17 */
		/* 8224D3B8h case   20:*/		regs.R5 = regs.R17;
		/* 8224D3B8h case   20:*/		return 0x8224D3BC;
		  /* 8224D3BCh */ case   21:  		/* lwz R6, <#[R1 + 84]> */
		/* 8224D3BCh case   21:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 8224D3BCh case   21:*/		return 0x8224D3C0;
		  /* 8224D3C0h */ case   22:  		/* li R7, 1116 */
		/* 8224D3C0h case   22:*/		cpu::op::li<0>(regs,&regs.R7,0x45C);
		/* 8224D3C0h case   22:*/		return 0x8224D3C4;
		  /* 8224D3C4h */ case   23:  		/* lwz R4, <#[R1 + 88]> */
		/* 8224D3C4h case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000058) );
		/* 8224D3C4h case   23:*/		return 0x8224D3C8;
		  /* 8224D3C8h */ case   24:  		/* li R3, 0 */
		/* 8224D3C8h case   24:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224D3C8h case   24:*/		return 0x8224D3CC;
		  /* 8224D3CCh */ case   25:  		/* bl -1005508 */
		/* 8224D3CCh case   25:*/		regs.LR = 0x8224D3D0; return 0x82157C08;
		/* 8224D3CCh case   25:*/		return 0x8224D3D0;
	}
	return 0x8224D3D0;
} // Block from 8224D368h-8224D3D0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8224D3D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D3D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D3D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D3D0);
		  /* 8224D3D0h */ case    0:  		/* lwz R3, <#[R23 + 24]> */
		/* 8224D3D0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000018) );
		/* 8224D3D0h case    0:*/		return 0x8224D3D4;
		  /* 8224D3D4h */ case    1:  		/* lwz R4, <#[R29 + 892]> */
		/* 8224D3D4h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x0000037C) );
		/* 8224D3D4h case    1:*/		return 0x8224D3D8;
		  /* 8224D3D8h */ case    2:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224D3D8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D3D8h case    2:*/		return 0x8224D3DC;
		  /* 8224D3DCh */ case    3:  		/* cmplw CR6, R4, R11 */
		/* 8224D3DCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 8224D3DCh case    3:*/		return 0x8224D3E0;
		  /* 8224D3E0h */ case    4:  		/* bc 4, CR6_LT, 20 */
		/* 8224D3E0h case    4:*/		if ( !regs.CR[6].lt ) { return 0x8224D3F4;  }
		/* 8224D3E0h case    4:*/		return 0x8224D3E4;
		  /* 8224D3E4h */ case    5:  		/* lwz R10, <#[R3 + 8]> */
		/* 8224D3E4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 8224D3E4h case    5:*/		return 0x8224D3E8;
		  /* 8224D3E8h */ case    6:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 8224D3E8h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 8224D3E8h case    6:*/		return 0x8224D3EC;
		  /* 8224D3ECh */ case    7:  		/* add R3, R10, R11 */
		/* 8224D3ECh case    7:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8224D3ECh case    7:*/		return 0x8224D3F0;
		  /* 8224D3F0h */ case    8:  		/* b 8 */
		/* 8224D3F0h case    8:*/		return 0x8224D3F8;
		/* 8224D3F0h case    8:*/		return 0x8224D3F4;
	}
	return 0x8224D3F4;
} // Block from 8224D3D0h-8224D3F4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224D3F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D3F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D3F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D3F4);
		  /* 8224D3F4h */ case    0:  		/* bl 26316 */
		/* 8224D3F4h case    0:*/		regs.LR = 0x8224D3F8; return 0x82253AC0;
		/* 8224D3F4h case    0:*/		return 0x8224D3F8;
	}
	return 0x8224D3F8;
} // Block from 8224D3F4h-8224D3F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224D3F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D3F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D3F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D3F8);
		  /* 8224D3F8h */ case    0:  		/* lwz R28, <#[R3]> */
		/* 8224D3F8h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D3F8h case    0:*/		return 0x8224D3FC;
		  /* 8224D3FCh */ case    1:  		/* lwz R11, <#[R28 + 40]> */
		/* 8224D3FCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000028) );
		/* 8224D3FCh case    1:*/		return 0x8224D400;
		  /* 8224D400h */ case    2:  		/* cmplw CR6, R11, R29 */
		/* 8224D400h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 8224D400h case    2:*/		return 0x8224D404;
		  /* 8224D404h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 8224D404h case    3:*/		if ( regs.CR[6].eq ) { return 0x8224D420;  }
		/* 8224D404h case    3:*/		return 0x8224D408;
		  /* 8224D408h */ case    4:  		/* mr R5, R18 */
		/* 8224D408h case    4:*/		regs.R5 = regs.R18;
		/* 8224D408h case    4:*/		return 0x8224D40C;
		  /* 8224D40Ch */ case    5:  		/* lwz R6, <#[R1 + 84]> */
		/* 8224D40Ch case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 8224D40Ch case    5:*/		return 0x8224D410;
		  /* 8224D410h */ case    6:  		/* li R7, 1118 */
		/* 8224D410h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x45E);
		/* 8224D410h case    6:*/		return 0x8224D414;
		  /* 8224D414h */ case    7:  		/* lwz R4, <#[R1 + 88]> */
		/* 8224D414h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000058) );
		/* 8224D414h case    7:*/		return 0x8224D418;
		  /* 8224D418h */ case    8:  		/* li R3, 0 */
		/* 8224D418h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224D418h case    8:*/		return 0x8224D41C;
		  /* 8224D41Ch */ case    9:  		/* bl -1005588 */
		/* 8224D41Ch case    9:*/		regs.LR = 0x8224D420; return 0x82157C08;
		/* 8224D41Ch case    9:*/		return 0x8224D420;
	}
	return 0x8224D420;
} // Block from 8224D3F8h-8224D420h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224D420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D420);
		  /* 8224D420h */ case    0:  		/* lwz R11, <#[R23]> */
		/* 8224D420h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8224D420h case    0:*/		return 0x8224D424;
		  /* 8224D424h */ case    1:  		/* li R4, 24 */
		/* 8224D424h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 8224D424h case    1:*/		return 0x8224D428;
		  /* 8224D428h */ case    2:  		/* lwz R14, <#[R11 + 1456]> */
		/* 8224D428h case    2:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224D428h case    2:*/		return 0x8224D42C;
		  /* 8224D42Ch */ case    3:  		/* mr R3, R14 */
		/* 8224D42Ch case    3:*/		regs.R3 = regs.R14;
		/* 8224D42Ch case    3:*/		return 0x8224D430;
		  /* 8224D430h */ case    4:  		/* bl -200568 */
		/* 8224D430h case    4:*/		regs.LR = 0x8224D434; return 0x8221C4B8;
		/* 8224D430h case    4:*/		return 0x8224D434;
		  /* 8224D434h */ case    5:  		/* mr R31, R3 */
		/* 8224D434h case    5:*/		regs.R31 = regs.R3;
		/* 8224D434h case    5:*/		return 0x8224D438;
		  /* 8224D438h */ case    6:  		/* li R11, 2 */
		/* 8224D438h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8224D438h case    6:*/		return 0x8224D43C;
		  /* 8224D43Ch */ case    7:  		/* stw R14, <#[R3]> */
		/* 8224D43Ch case    7:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D43Ch case    7:*/		return 0x8224D440;
		  /* 8224D440h */ case    8:  		/* stw R30, <#[R3 + 4]> */
		/* 8224D440h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D440h case    8:*/		return 0x8224D444;
		  /* 8224D444h */ case    9:  		/* mr R4, R29 */
		/* 8224D444h case    9:*/		regs.R4 = regs.R29;
		/* 8224D444h case    9:*/		return 0x8224D448;
		  /* 8224D448h */ case   10:  		/* li R7, 2 */
		/* 8224D448h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 8224D448h case   10:*/		return 0x8224D44C;
		  /* 8224D44Ch */ case   11:  		/* li R6, 0 */
		/* 8224D44Ch case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8224D44Ch case   11:*/		return 0x8224D450;
		  /* 8224D450h */ case   12:  		/* stw R28, <#[R31 + 8]> */
		/* 8224D450h case   12:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000008) );
		/* 8224D450h case   12:*/		return 0x8224D454;
		  /* 8224D454h */ case   13:  		/* mr R5, R27 */
		/* 8224D454h case   13:*/		regs.R5 = regs.R27;
		/* 8224D454h case   13:*/		return 0x8224D458;
		  /* 8224D458h */ case   14:  		/* stw R11, <#[R31 + 12]> */
		/* 8224D458h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224D458h case   14:*/		return 0x8224D45C;
		  /* 8224D45Ch */ case   15:  		/* mr R3, R26 */
		/* 8224D45Ch case   15:*/		regs.R3 = regs.R26;
		/* 8224D45Ch case   15:*/		return 0x8224D460;
		  /* 8224D460h */ case   16:  		/* addi R29, R31, 4 */
		/* 8224D460h case   16:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x4);
		/* 8224D460h case   16:*/		return 0x8224D464;
		  /* 8224D464h */ case   17:  		/* bl 104652 */
		/* 8224D464h case   17:*/		regs.LR = 0x8224D468; return 0x82266D30;
		/* 8224D464h case   17:*/		return 0x8224D468;
		  /* 8224D468h */ case   18:  		/* stw R3, <#[R31 + 16]> */
		/* 8224D468h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8224D468h case   18:*/		return 0x8224D46C;
		  /* 8224D46Ch */ case   19:  		/* stb R15, <#[R31 + 20]> */
		/* 8224D46Ch case   19:*/		cpu::mem::store8( regs, regs.R15, (uint32)(regs.R31 + 0x00000014) );
		/* 8224D46Ch case   19:*/		return 0x8224D470;
		  /* 8224D470h */ case   20:  		/* lwz R3, <#[R30 + 48]> */
		/* 8224D470h case   20:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 8224D470h case   20:*/		return 0x8224D474;
		  /* 8224D474h */ case   21:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224D474h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D474h case   21:*/		return 0x8224D478;
		  /* 8224D478h */ case   22:  		/* bl 26184 */
		/* 8224D478h case   22:*/		regs.LR = 0x8224D47C; return 0x82253AC0;
		/* 8224D478h case   22:*/		return 0x8224D47C;
		  /* 8224D47Ch */ case   23:  		/* stw R29, <#[R3]> */
		/* 8224D47Ch case   23:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D47Ch case   23:*/		return 0x8224D480;
		  /* 8224D480h */ case   24:  		/* lwz R3, <#[R28 + 52]> */
		/* 8224D480h case   24:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000034) );
		/* 8224D480h case   24:*/		return 0x8224D484;
		  /* 8224D484h */ case   25:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224D484h case   25:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D484h case   25:*/		return 0x8224D488;
		  /* 8224D488h */ case   26:  		/* bl 26168 */
		/* 8224D488h case   26:*/		regs.LR = 0x8224D48C; return 0x82253AC0;
		/* 8224D488h case   26:*/		return 0x8224D48C;
		  /* 8224D48Ch */ case   27:  		/* stw R29, <#[R3]> */
		/* 8224D48Ch case   27:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D48Ch case   27:*/		return 0x8224D490;
	}
	return 0x8224D490;
} // Block from 8224D420h-8224D490h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8224D490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D490);
		  /* 8224D490h */ case    0:  		/* lwz R11, <#[R26 + 20]> */
		/* 8224D490h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 8224D490h case    0:*/		return 0x8224D494;
		  /* 8224D494h */ case    1:  		/* addi R27, R27, 1 */
		/* 8224D494h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8224D494h case    1:*/		return 0x8224D498;
		  /* 8224D498h */ case    2:  		/* addi R25, R25, 4 */
		/* 8224D498h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 8224D498h case    2:*/		return 0x8224D49C;
		  /* 8224D49Ch */ case    3:  		/* cmpw CR6, R27, R11 */
		/* 8224D49Ch case    3:*/		cpu::op::cmpw<6>(regs,regs.R27,regs.R11);
		/* 8224D49Ch case    3:*/		return 0x8224D4A0;
		  /* 8224D4A0h */ case    4:  		/* bc 4, CR6_GT, -292 */
		/* 8224D4A0h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8224D37C;  }
		/* 8224D4A0h case    4:*/		return 0x8224D4A4;
	}
	return 0x8224D4A4;
} // Block from 8224D490h-8224D4A4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224D4A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D4A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D4A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D4A4);
		  /* 8224D4A4h */ case    0:  		/* lwz R11, <#[R26]> */
		/* 8224D4A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8224D4A4h case    0:*/		return 0x8224D4A8;
		  /* 8224D4A8h */ case    1:  		/* mr R3, R26 */
		/* 8224D4A8h case    1:*/		regs.R3 = regs.R26;
		/* 8224D4A8h case    1:*/		return 0x8224D4AC;
		  /* 8224D4ACh */ case    2:  		/* lwz R11, <#[R11 + 24]> */
		/* 8224D4ACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8224D4ACh case    2:*/		return 0x8224D4B0;
		  /* 8224D4B0h */ case    3:  		/* mtspr CTR, R11 */
		/* 8224D4B0h case    3:*/		regs.CTR = regs.R11;
		/* 8224D4B0h case    3:*/		return 0x8224D4B4;
		  /* 8224D4B4h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8224D4B4h case    4:*/		if ( 1 ) { regs.LR = 0x8224D4B8; return (uint32)regs.CTR; }
		/* 8224D4B4h case    4:*/		return 0x8224D4B8;
		  /* 8224D4B8h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224D4B8h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224D4B8h case    5:*/		return 0x8224D4BC;
		  /* 8224D4BCh */ case    6:  		/* bc 12, CR0_EQ, 120 */
		/* 8224D4BCh case    6:*/		if ( regs.CR[0].eq ) { return 0x8224D534;  }
		/* 8224D4BCh case    6:*/		return 0x8224D4C0;
		  /* 8224D4C0h */ case    7:  		/* cmplwi CR6, R22, 0 */
		/* 8224D4C0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 8224D4C0h case    7:*/		return 0x8224D4C4;
		  /* 8224D4C4h */ case    8:  		/* bc 12, CR6_EQ, 112 */
		/* 8224D4C4h case    8:*/		if ( regs.CR[6].eq ) { return 0x8224D534;  }
		/* 8224D4C4h case    8:*/		return 0x8224D4C8;
		  /* 8224D4C8h */ case    9:  		/* lwz R11, <#[R23]> */
		/* 8224D4C8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8224D4C8h case    9:*/		return 0x8224D4CC;
		  /* 8224D4CCh */ case   10:  		/* li R4, 24 */
		/* 8224D4CCh case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 8224D4CCh case   10:*/		return 0x8224D4D0;
		  /* 8224D4D0h */ case   11:  		/* lwz R29, <#[R11 + 1456]> */
		/* 8224D4D0h case   11:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224D4D0h case   11:*/		return 0x8224D4D4;
		  /* 8224D4D4h */ case   12:  		/* mr R3, R29 */
		/* 8224D4D4h case   12:*/		regs.R3 = regs.R29;
		/* 8224D4D4h case   12:*/		return 0x8224D4D8;
		  /* 8224D4D8h */ case   13:  		/* bl -200736 */
		/* 8224D4D8h case   13:*/		regs.LR = 0x8224D4DC; return 0x8221C4B8;
		/* 8224D4D8h case   13:*/		return 0x8224D4DC;
		  /* 8224D4DCh */ case   14:  		/* mr R31, R3 */
		/* 8224D4DCh case   14:*/		regs.R31 = regs.R3;
		/* 8224D4DCh case   14:*/		return 0x8224D4E0;
		  /* 8224D4E0h */ case   15:  		/* li R7, 3 */
		/* 8224D4E0h case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 8224D4E0h case   15:*/		return 0x8224D4E4;
		  /* 8224D4E4h */ case   16:  		/* li R6, 0 */
		/* 8224D4E4h case   16:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8224D4E4h case   16:*/		return 0x8224D4E8;
		  /* 8224D4E8h */ case   17:  		/* li R5, 0 */
		/* 8224D4E8h case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8224D4E8h case   17:*/		return 0x8224D4EC;
		  /* 8224D4ECh */ case   18:  		/* mr R3, R26 */
		/* 8224D4ECh case   18:*/		regs.R3 = regs.R26;
		/* 8224D4ECh case   18:*/		return 0x8224D4F0;
		  /* 8224D4F0h */ case   19:  		/* stw R29, <#[R31]> */
		/* 8224D4F0h case   19:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000000) );
		/* 8224D4F0h case   19:*/		return 0x8224D4F4;
		  /* 8224D4F4h */ case   20:  		/* addi R29, R31, 4 */
		/* 8224D4F4h case   20:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x4);
		/* 8224D4F4h case   20:*/		return 0x8224D4F8;
		  /* 8224D4F8h */ case   21:  		/* stw R24, <#[R31 + 12]> */
		/* 8224D4F8h case   21:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224D4F8h case   21:*/		return 0x8224D4FC;
		  /* 8224D4FCh */ case   22:  		/* stw R30, <#[R31 + 4]> */
		/* 8224D4FCh case   22:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 8224D4FCh case   22:*/		return 0x8224D500;
		  /* 8224D500h */ case   23:  		/* stw R22, <#[R31 + 8]> */
		/* 8224D500h case   23:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000008) );
		/* 8224D500h case   23:*/		return 0x8224D504;
		  /* 8224D504h */ case   24:  		/* lwz R4, <#[R22 + 40]> */
		/* 8224D504h case   24:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R22 + 0x00000028) );
		/* 8224D504h case   24:*/		return 0x8224D508;
		  /* 8224D508h */ case   25:  		/* bl 104488 */
		/* 8224D508h case   25:*/		regs.LR = 0x8224D50C; return 0x82266D30;
		/* 8224D508h case   25:*/		return 0x8224D50C;
		  /* 8224D50Ch */ case   26:  		/* stw R3, <#[R31 + 16]> */
		/* 8224D50Ch case   26:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8224D50Ch case   26:*/		return 0x8224D510;
		  /* 8224D510h */ case   27:  		/* stb R15, <#[R31 + 20]> */
		/* 8224D510h case   27:*/		cpu::mem::store8( regs, regs.R15, (uint32)(regs.R31 + 0x00000014) );
		/* 8224D510h case   27:*/		return 0x8224D514;
		  /* 8224D514h */ case   28:  		/* lwz R3, <#[R30 + 48]> */
		/* 8224D514h case   28:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 8224D514h case   28:*/		return 0x8224D518;
		  /* 8224D518h */ case   29:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224D518h case   29:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D518h case   29:*/		return 0x8224D51C;
		  /* 8224D51Ch */ case   30:  		/* bl 26020 */
		/* 8224D51Ch case   30:*/		regs.LR = 0x8224D520; return 0x82253AC0;
		/* 8224D51Ch case   30:*/		return 0x8224D520;
		  /* 8224D520h */ case   31:  		/* stw R29, <#[R3]> */
		/* 8224D520h case   31:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D520h case   31:*/		return 0x8224D524;
		  /* 8224D524h */ case   32:  		/* lwz R3, <#[R22 + 52]> */
		/* 8224D524h case   32:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000034) );
		/* 8224D524h case   32:*/		return 0x8224D528;
		  /* 8224D528h */ case   33:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224D528h case   33:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D528h case   33:*/		return 0x8224D52C;
		  /* 8224D52Ch */ case   34:  		/* bl 26004 */
		/* 8224D52Ch case   34:*/		regs.LR = 0x8224D530; return 0x82253AC0;
		/* 8224D52Ch case   34:*/		return 0x8224D530;
		  /* 8224D530h */ case   35:  		/* stw R29, <#[R3]> */
		/* 8224D530h case   35:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D530h case   35:*/		return 0x8224D534;
	}
	return 0x8224D534;
} // Block from 8224D4A4h-8224D534h (36 instructions)

//////////////////////////////////////////////////////
// Block at 8224D534h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D534( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D534) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D534);
		  /* 8224D534h */ case    0:  		/* lwz R11, <#[R26]> */
		/* 8224D534h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8224D534h case    0:*/		return 0x8224D538;
		  /* 8224D538h */ case    1:  		/* mr R3, R26 */
		/* 8224D538h case    1:*/		regs.R3 = regs.R26;
		/* 8224D538h case    1:*/		return 0x8224D53C;
		  /* 8224D53Ch */ case    2:  		/* lwz R11, <#[R11 + 20]> */
		/* 8224D53Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8224D53Ch case    2:*/		return 0x8224D540;
		  /* 8224D540h */ case    3:  		/* mtspr CTR, R11 */
		/* 8224D540h case    3:*/		regs.CTR = regs.R11;
		/* 8224D540h case    3:*/		return 0x8224D544;
		  /* 8224D544h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8224D544h case    4:*/		if ( 1 ) { regs.LR = 0x8224D548; return (uint32)regs.CTR; }
		/* 8224D544h case    4:*/		return 0x8224D548;
		  /* 8224D548h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224D548h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224D548h case    5:*/		return 0x8224D54C;
		  /* 8224D54Ch */ case    6:  		/* bc 12, CR0_EQ, 120 */
		/* 8224D54Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x8224D5C4;  }
		/* 8224D54Ch case    6:*/		return 0x8224D550;
		  /* 8224D550h */ case    7:  		/* cmplwi CR6, R21, 0 */
		/* 8224D550h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 8224D550h case    7:*/		return 0x8224D554;
		  /* 8224D554h */ case    8:  		/* bc 12, CR6_EQ, 112 */
		/* 8224D554h case    8:*/		if ( regs.CR[6].eq ) { return 0x8224D5C4;  }
		/* 8224D554h case    8:*/		return 0x8224D558;
		  /* 8224D558h */ case    9:  		/* lwz R11, <#[R23]> */
		/* 8224D558h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8224D558h case    9:*/		return 0x8224D55C;
		  /* 8224D55Ch */ case   10:  		/* li R4, 24 */
		/* 8224D55Ch case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 8224D55Ch case   10:*/		return 0x8224D560;
		  /* 8224D560h */ case   11:  		/* lwz R29, <#[R11 + 1456]> */
		/* 8224D560h case   11:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224D560h case   11:*/		return 0x8224D564;
		  /* 8224D564h */ case   12:  		/* mr R3, R29 */
		/* 8224D564h case   12:*/		regs.R3 = regs.R29;
		/* 8224D564h case   12:*/		return 0x8224D568;
		  /* 8224D568h */ case   13:  		/* bl -200880 */
		/* 8224D568h case   13:*/		regs.LR = 0x8224D56C; return 0x8221C4B8;
		/* 8224D568h case   13:*/		return 0x8224D56C;
		  /* 8224D56Ch */ case   14:  		/* mr R31, R3 */
		/* 8224D56Ch case   14:*/		regs.R31 = regs.R3;
		/* 8224D56Ch case   14:*/		return 0x8224D570;
		  /* 8224D570h */ case   15:  		/* li R7, 3 */
		/* 8224D570h case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 8224D570h case   15:*/		return 0x8224D574;
		  /* 8224D574h */ case   16:  		/* li R6, 0 */
		/* 8224D574h case   16:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8224D574h case   16:*/		return 0x8224D578;
		  /* 8224D578h */ case   17:  		/* li R5, 0 */
		/* 8224D578h case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8224D578h case   17:*/		return 0x8224D57C;
		  /* 8224D57Ch */ case   18:  		/* mr R3, R26 */
		/* 8224D57Ch case   18:*/		regs.R3 = regs.R26;
		/* 8224D57Ch case   18:*/		return 0x8224D580;
		  /* 8224D580h */ case   19:  		/* stw R29, <#[R31]> */
		/* 8224D580h case   19:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000000) );
		/* 8224D580h case   19:*/		return 0x8224D584;
		  /* 8224D584h */ case   20:  		/* addi R29, R31, 4 */
		/* 8224D584h case   20:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x4);
		/* 8224D584h case   20:*/		return 0x8224D588;
		  /* 8224D588h */ case   21:  		/* stw R30, <#[R31 + 4]> */
		/* 8224D588h case   21:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 8224D588h case   21:*/		return 0x8224D58C;
		  /* 8224D58Ch */ case   22:  		/* stw R21, <#[R31 + 8]> */
		/* 8224D58Ch case   22:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R31 + 0x00000008) );
		/* 8224D58Ch case   22:*/		return 0x8224D590;
		  /* 8224D590h */ case   23:  		/* stw R24, <#[R31 + 12]> */
		/* 8224D590h case   23:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224D590h case   23:*/		return 0x8224D594;
		  /* 8224D594h */ case   24:  		/* lwz R4, <#[R21 + 40]> */
		/* 8224D594h case   24:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R21 + 0x00000028) );
		/* 8224D594h case   24:*/		return 0x8224D598;
		  /* 8224D598h */ case   25:  		/* bl 104344 */
		/* 8224D598h case   25:*/		regs.LR = 0x8224D59C; return 0x82266D30;
		/* 8224D598h case   25:*/		return 0x8224D59C;
		  /* 8224D59Ch */ case   26:  		/* stw R3, <#[R31 + 16]> */
		/* 8224D59Ch case   26:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8224D59Ch case   26:*/		return 0x8224D5A0;
		  /* 8224D5A0h */ case   27:  		/* stb R15, <#[R31 + 20]> */
		/* 8224D5A0h case   27:*/		cpu::mem::store8( regs, regs.R15, (uint32)(regs.R31 + 0x00000014) );
		/* 8224D5A0h case   27:*/		return 0x8224D5A4;
		  /* 8224D5A4h */ case   28:  		/* lwz R3, <#[R30 + 48]> */
		/* 8224D5A4h case   28:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 8224D5A4h case   28:*/		return 0x8224D5A8;
		  /* 8224D5A8h */ case   29:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224D5A8h case   29:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D5A8h case   29:*/		return 0x8224D5AC;
		  /* 8224D5ACh */ case   30:  		/* bl 25876 */
		/* 8224D5ACh case   30:*/		regs.LR = 0x8224D5B0; return 0x82253AC0;
		/* 8224D5ACh case   30:*/		return 0x8224D5B0;
		  /* 8224D5B0h */ case   31:  		/* stw R29, <#[R3]> */
		/* 8224D5B0h case   31:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D5B0h case   31:*/		return 0x8224D5B4;
		  /* 8224D5B4h */ case   32:  		/* lwz R3, <#[R21 + 52]> */
		/* 8224D5B4h case   32:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R21 + 0x00000034) );
		/* 8224D5B4h case   32:*/		return 0x8224D5B8;
		  /* 8224D5B8h */ case   33:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224D5B8h case   33:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D5B8h case   33:*/		return 0x8224D5BC;
		  /* 8224D5BCh */ case   34:  		/* bl 25860 */
		/* 8224D5BCh case   34:*/		regs.LR = 0x8224D5C0; return 0x82253AC0;
		/* 8224D5BCh case   34:*/		return 0x8224D5C0;
		  /* 8224D5C0h */ case   35:  		/* stw R29, <#[R3]> */
		/* 8224D5C0h case   35:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D5C0h case   35:*/		return 0x8224D5C4;
	}
	return 0x8224D5C4;
} // Block from 8224D534h-8224D5C4h (36 instructions)

//////////////////////////////////////////////////////
// Block at 8224D5C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D5C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D5C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D5C4);
		  /* 8224D5C4h */ case    0:  		/* mr R3, R26 */
		/* 8224D5C4h case    0:*/		regs.R3 = regs.R26;
		/* 8224D5C4h case    0:*/		return 0x8224D5C8;
		  /* 8224D5C8h */ case    1:  		/* bl 104080 */
		/* 8224D5C8h case    1:*/		regs.LR = 0x8224D5CC; return 0x82266C58;
		/* 8224D5C8h case    1:*/		return 0x8224D5CC;
		  /* 8224D5CCh */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224D5CCh case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224D5CCh case    2:*/		return 0x8224D5D0;
		  /* 8224D5D0h */ case    3:  		/* bc 12, CR0_EQ, 164 */
		/* 8224D5D0h case    3:*/		if ( regs.CR[0].eq ) { return 0x8224D674;  }
		/* 8224D5D0h case    3:*/		return 0x8224D5D4;
		  /* 8224D5D4h */ case    4:  		/* addi R3, R1, 128 */
		/* 8224D5D4h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 8224D5D4h case    4:*/		return 0x8224D5D8;
		  /* 8224D5D8h */ case    5:  		/* bl 25000 */
		/* 8224D5D8h case    5:*/		regs.LR = 0x8224D5DC; return 0x82253780;
		/* 8224D5D8h case    5:*/		return 0x8224D5DC;
		  /* 8224D5DCh */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224D5DCh case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224D5DCh case    6:*/		return 0x8224D5E0;
		  /* 8224D5E0h */ case    7:  		/* bc 4, CR0_EQ, 148 */
		/* 8224D5E0h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8224D674;  }
		/* 8224D5E0h case    7:*/		return 0x8224D5E4;
		  /* 8224D5E4h */ case    8:  		/* lwz R29, <#[R1 + 136]> */
		/* 8224D5E4h case    8:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000088) );
		/* 8224D5E4h case    8:*/		return 0x8224D5E8;
		  /* 8224D5E8h */ case    9:  		/* addi R28, R29, 8 */
		/* 8224D5E8h case    9:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R29,0x8);
		/* 8224D5E8h case    9:*/		return 0x8224D5EC;
		  /* 8224D5ECh */ case   10:  		/* lwz R11, <#[R28]> */
		/* 8224D5ECh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8224D5ECh case   10:*/		return 0x8224D5F0;
		  /* 8224D5F0h */ case   11:  		/* b 124 */
		/* 8224D5F0h case   11:*/		return 0x8224D66C;
		/* 8224D5F0h case   11:*/		return 0x8224D5F4;
		  /* 8224D5F4h */ case   12:  		/* lwz R11, <#[R23]> */
		/* 8224D5F4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8224D5F4h case   12:*/		return 0x8224D5F8;
		  /* 8224D5F8h */ case   13:  		/* li R4, 24 */
		/* 8224D5F8h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 8224D5F8h case   13:*/		return 0x8224D5FC;
		  /* 8224D5FCh */ case   14:  		/* lwz R27, <#[R11 + 1456]> */
		/* 8224D5FCh case   14:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224D5FCh case   14:*/		return 0x8224D600;
		  /* 8224D600h */ case   15:  		/* mr R3, R27 */
		/* 8224D600h case   15:*/		regs.R3 = regs.R27;
		/* 8224D600h case   15:*/		return 0x8224D604;
		  /* 8224D604h */ case   16:  		/* bl -201036 */
		/* 8224D604h case   16:*/		regs.LR = 0x8224D608; return 0x8221C4B8;
		/* 8224D604h case   16:*/		return 0x8224D608;
		  /* 8224D608h */ case   17:  		/* mr R31, R3 */
		/* 8224D608h case   17:*/		regs.R31 = regs.R3;
		/* 8224D608h case   17:*/		return 0x8224D60C;
		  /* 8224D60Ch */ case   18:  		/* li R7, 3 */
		/* 8224D60Ch case   18:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 8224D60Ch case   18:*/		return 0x8224D610;
		  /* 8224D610h */ case   19:  		/* li R6, 0 */
		/* 8224D610h case   19:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8224D610h case   19:*/		return 0x8224D614;
		  /* 8224D614h */ case   20:  		/* li R5, 0 */
		/* 8224D614h case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8224D614h case   20:*/		return 0x8224D618;
		  /* 8224D618h */ case   21:  		/* mr R3, R26 */
		/* 8224D618h case   21:*/		regs.R3 = regs.R26;
		/* 8224D618h case   21:*/		return 0x8224D61C;
		  /* 8224D61Ch */ case   22:  		/* stw R27, <#[R31]> */
		/* 8224D61Ch case   22:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000000) );
		/* 8224D61Ch case   22:*/		return 0x8224D620;
		  /* 8224D620h */ case   23:  		/* addi R27, R31, 4 */
		/* 8224D620h case   23:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R31,0x4);
		/* 8224D620h case   23:*/		return 0x8224D624;
		  /* 8224D624h */ case   24:  		/* stw R30, <#[R31 + 4]> */
		/* 8224D624h case   24:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 8224D624h case   24:*/		return 0x8224D628;
		  /* 8224D628h */ case   25:  		/* stw R29, <#[R31 + 8]> */
		/* 8224D628h case   25:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000008) );
		/* 8224D628h case   25:*/		return 0x8224D62C;
		  /* 8224D62Ch */ case   26:  		/* stw R24, <#[R31 + 12]> */
		/* 8224D62Ch case   26:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224D62Ch case   26:*/		return 0x8224D630;
		  /* 8224D630h */ case   27:  		/* lwz R4, <#[R29 + 40]> */
		/* 8224D630h case   27:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000028) );
		/* 8224D630h case   27:*/		return 0x8224D634;
		  /* 8224D634h */ case   28:  		/* bl 104188 */
		/* 8224D634h case   28:*/		regs.LR = 0x8224D638; return 0x82266D30;
		/* 8224D634h case   28:*/		return 0x8224D638;
		  /* 8224D638h */ case   29:  		/* stw R3, <#[R31 + 16]> */
		/* 8224D638h case   29:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8224D638h case   29:*/		return 0x8224D63C;
		  /* 8224D63Ch */ case   30:  		/* stb R15, <#[R31 + 20]> */
		/* 8224D63Ch case   30:*/		cpu::mem::store8( regs, regs.R15, (uint32)(regs.R31 + 0x00000014) );
		/* 8224D63Ch case   30:*/		return 0x8224D640;
		  /* 8224D640h */ case   31:  		/* lwz R3, <#[R30 + 48]> */
		/* 8224D640h case   31:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 8224D640h case   31:*/		return 0x8224D644;
		  /* 8224D644h */ case   32:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224D644h case   32:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D644h case   32:*/		return 0x8224D648;
		  /* 8224D648h */ case   33:  		/* bl 25720 */
		/* 8224D648h case   33:*/		regs.LR = 0x8224D64C; return 0x82253AC0;
		/* 8224D648h case   33:*/		return 0x8224D64C;
		  /* 8224D64Ch */ case   34:  		/* stw R27, <#[R3]> */
		/* 8224D64Ch case   34:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D64Ch case   34:*/		return 0x8224D650;
		  /* 8224D650h */ case   35:  		/* lwz R3, <#[R29 + 52]> */
		/* 8224D650h case   35:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000034) );
		/* 8224D650h case   35:*/		return 0x8224D654;
		  /* 8224D654h */ case   36:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224D654h case   36:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D654h case   36:*/		return 0x8224D658;
		  /* 8224D658h */ case   37:  		/* bl 25704 */
		/* 8224D658h case   37:*/		regs.LR = 0x8224D65C; return 0x82253AC0;
		/* 8224D658h case   37:*/		return 0x8224D65C;
		  /* 8224D65Ch */ case   38:  		/* stw R27, <#[R3]> */
		/* 8224D65Ch case   38:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D65Ch case   38:*/		return 0x8224D660;
		  /* 8224D660h */ case   39:  		/* lwz R29, <#[R28]> */
		/* 8224D660h case   39:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R28 + 0x00000000) );
		/* 8224D660h case   39:*/		return 0x8224D664;
		  /* 8224D664h */ case   40:  		/* addi R28, R29, 8 */
		/* 8224D664h case   40:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R29,0x8);
		/* 8224D664h case   40:*/		return 0x8224D668;
		  /* 8224D668h */ case   41:  		/* lwz R11, <#[R29 + 8]> */
		/* 8224D668h case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8224D668h case   41:*/		return 0x8224D66C;
	}
	return 0x8224D66C;
} // Block from 8224D5C4h-8224D66Ch (42 instructions)

//////////////////////////////////////////////////////
// Block at 8224D66Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D66C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D66C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D66C);
		  /* 8224D66Ch */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 8224D66Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224D66Ch case    0:*/		return 0x8224D670;
		  /* 8224D670h */ case    1:  		/* bc 4, CR6_EQ, -124 */
		/* 8224D670h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8224D5F4;  }
		/* 8224D670h case    1:*/		return 0x8224D674;
	}
	return 0x8224D674;
} // Block from 8224D66Ch-8224D674h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224D674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D674);
		  /* 8224D674h */ case    0:  		/* addic. R19, R19, -1 */
		/* 8224D674h case    0:*/		cpu::op::addic<1>(regs,&regs.R19,regs.R19,0xFFFFFFFF);
		/* 8224D674h case    0:*/		return 0x8224D678;
		  /* 8224D678h */ case    1:  		/* addi R16, R16, -4 */
		/* 8224D678h case    1:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R16,0xFFFFFFFC);
		/* 8224D678h case    1:*/		return 0x8224D67C;
		  /* 8224D67Ch */ case    2:  		/* bc 4, CR0_LT, -1400 */
		/* 8224D67Ch case    2:*/		if ( !regs.CR[0].lt ) { return 0x8224D104;  }
		/* 8224D67Ch case    2:*/		return 0x8224D680;
	}
	return 0x8224D680;
} // Block from 8224D674h-8224D680h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224D680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D680);
		  /* 8224D680h */ case    0:  		/* cmplwi CR6, R20, 0 */
		/* 8224D680h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 8224D680h case    0:*/		return 0x8224D684;
		  /* 8224D684h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 8224D684h case    1:*/		if ( regs.CR[6].eq ) { return 0x8224D69C;  }
		/* 8224D684h case    1:*/		return 0x8224D688;
		  /* 8224D688h */ case    2:  		/* mr R3, R20 */
		/* 8224D688h case    2:*/		regs.R3 = regs.R20;
		/* 8224D688h case    2:*/		return 0x8224D68C;
		  /* 8224D68Ch */ case    3:  		/* bl 26964 */
		/* 8224D68Ch case    3:*/		regs.LR = 0x8224D690; return 0x82253FE0;
		/* 8224D68Ch case    3:*/		return 0x8224D690;
		  /* 8224D690h */ case    4:  		/* addi R4, R20, -4 */
		/* 8224D690h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R20,0xFFFFFFFC);
		/* 8224D690h case    4:*/		return 0x8224D694;
		  /* 8224D694h */ case    5:  		/* lwz R3, <#[R20 - 4]> */
		/* 8224D694h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R20 + 0xFFFFFFFC) );
		/* 8224D694h case    5:*/		return 0x8224D698;
		  /* 8224D698h */ case    6:  		/* bl -200792 */
		/* 8224D698h case    6:*/		regs.LR = 0x8224D69C; return 0x8221C640;
		/* 8224D698h case    6:*/		return 0x8224D69C;
	}
	return 0x8224D69C;
} // Block from 8224D680h-8224D69Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224D69Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D69C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D69C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D69C);
		  /* 8224D69Ch */ case    0:  		/* addi R1, R1, 320 */
		/* 8224D69Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x140);
		/* 8224D69Ch case    0:*/		return 0x8224D6A0;
		  /* 8224D6A0h */ case    1:  		/* lfd FR31, <#[R1 - 160]> */
		/* 8224D6A0h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8224D6A0h case    1:*/		return 0x8224D6A4;
		  /* 8224D6A4h */ case    2:  		/* b -1819700 */
		/* 8224D6A4h case    2:*/		return 0x82091270;
		/* 8224D6A4h case    2:*/		return 0x8224D6A8;
	}
	return 0x8224D6A8;
} // Block from 8224D69Ch-8224D6A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224D6A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D6A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D6A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D6A8);
		  /* 8224D6A8h */ case    0:  		/* mfspr R12, LR */
		/* 8224D6A8h case    0:*/		regs.R12 = regs.LR;
		/* 8224D6A8h case    0:*/		return 0x8224D6AC;
		  /* 8224D6ACh */ case    1:  		/* bl -1819752 */
		/* 8224D6ACh case    1:*/		regs.LR = 0x8224D6B0; return 0x82091244;
		/* 8224D6ACh case    1:*/		return 0x8224D6B0;
		  /* 8224D6B0h */ case    2:  		/* stfd FR31, <#[R1 - 88]> */
		/* 8224D6B0h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA8) );
		/* 8224D6B0h case    2:*/		return 0x8224D6B4;
		  /* 8224D6B4h */ case    3:  		/* stwu R1, <#[R1 - 176]> */
		/* 8224D6B4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 8224D6B4h case    3:*/		return 0x8224D6B8;
		  /* 8224D6B8h */ case    4:  		/* lwz R11, <#[R3 + 24]> */
		/* 8224D6B8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 8224D6B8h case    4:*/		return 0x8224D6BC;
		  /* 8224D6BCh */ case    5:  		/* li R10, 0 */
		/* 8224D6BCh case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8224D6BCh case    5:*/		return 0x8224D6C0;
		  /* 8224D6C0h */ case    6:  		/* mr R24, R3 */
		/* 8224D6C0h case    6:*/		regs.R24 = regs.R3;
		/* 8224D6C0h case    6:*/		return 0x8224D6C4;
		  /* 8224D6C4h */ case    7:  		/* stw R10, <#[R3 + 108]> */
		/* 8224D6C4h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x0000006C) );
		/* 8224D6C4h case    7:*/		return 0x8224D6C8;
		  /* 8224D6C8h */ case    8:  		/* lwz R23, <#[R11 + 4]> */
		/* 8224D6C8h case    8:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R11 + 0x00000004) );
		/* 8224D6C8h case    8:*/		return 0x8224D6CC;
		  /* 8224D6CCh */ case    9:  		/* addic. R26, R23, -1 */
		/* 8224D6CCh case    9:*/		cpu::op::addic<1>(regs,&regs.R26,regs.R23,0xFFFFFFFF);
		/* 8224D6CCh case    9:*/		return 0x8224D6D0;
		  /* 8224D6D0h */ case   10:  		/* bc 12, CR0_LT, 468 */
		/* 8224D6D0h case   10:*/		if ( regs.CR[0].lt ) { return 0x8224D8A4;  }
		/* 8224D6D0h case   10:*/		return 0x8224D6D4;
		  /* 8224D6D4h */ case   11:  		/* rlwinm R25, R26, 2, 0, 29 */
		/* 8224D6D4h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R25,regs.R26);
		/* 8224D6D4h case   11:*/		return 0x8224D6D8;
		  /* 8224D6D8h */ case   12:  		/* lwz R3, <#[R24 + 24]> */
		/* 8224D6D8h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000018) );
		/* 8224D6D8h case   12:*/		return 0x8224D6DC;
		  /* 8224D6DCh */ case   13:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224D6DCh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D6DCh case   13:*/		return 0x8224D6E0;
		  /* 8224D6E0h */ case   14:  		/* cmplw CR6, R26, R11 */
		/* 8224D6E0h case   14:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 8224D6E0h case   14:*/		return 0x8224D6E4;
		  /* 8224D6E4h */ case   15:  		/* bc 4, CR6_LT, 16 */
		/* 8224D6E4h case   15:*/		if ( !regs.CR[6].lt ) { return 0x8224D6F4;  }
		/* 8224D6E4h case   15:*/		return 0x8224D6E8;
		  /* 8224D6E8h */ case   16:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224D6E8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224D6E8h case   16:*/		return 0x8224D6EC;
		  /* 8224D6ECh */ case   17:  		/* add R3, R11, R25 */
		/* 8224D6ECh case   17:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R25);
		/* 8224D6ECh case   17:*/		return 0x8224D6F0;
		  /* 8224D6F0h */ case   18:  		/* b 12 */
		/* 8224D6F0h case   18:*/		return 0x8224D6FC;
		/* 8224D6F0h case   18:*/		return 0x8224D6F4;
	}
	return 0x8224D6F4;
} // Block from 8224D6A8h-8224D6F4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8224D6F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D6F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D6F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D6F4);
		  /* 8224D6F4h */ case    0:  		/* mr R4, R26 */
		/* 8224D6F4h case    0:*/		regs.R4 = regs.R26;
		/* 8224D6F4h case    0:*/		return 0x8224D6F8;
		  /* 8224D6F8h */ case    1:  		/* bl 25544 */
		/* 8224D6F8h case    1:*/		regs.LR = 0x8224D6FC; return 0x82253AC0;
		/* 8224D6F8h case    1:*/		return 0x8224D6FC;
	}
	return 0x8224D6FC;
} // Block from 8224D6F4h-8224D6FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224D6FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D6FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D6FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D6FC);
		  /* 8224D6FCh */ case    0:  		/* lwz R30, <#[R3]> */
		/* 8224D6FCh case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D6FCh case    0:*/		return 0x8224D700;
		  /* 8224D700h */ case    1:  		/* li R29, 0 */
		/* 8224D700h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8224D700h case    1:*/		return 0x8224D704;
		  /* 8224D704h */ case    2:  		/* lwz R11, <#[R30 + 48]> */
		/* 8224D704h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 8224D704h case    2:*/		return 0x8224D708;
		  /* 8224D708h */ case    3:  		/* lwz R27, <#[R11 + 4]> */
		/* 8224D708h case    3:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000004) );
		/* 8224D708h case    3:*/		return 0x8224D70C;
		  /* 8224D70Ch */ case    4:  		/* cmpwi CR6, R27, 0 */
		/* 8224D70Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 8224D70Ch case    4:*/		return 0x8224D710;
		  /* 8224D710h */ case    5:  		/* bc 4, CR6_GT, 196 */
		/* 8224D710h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8224D7D4;  }
		/* 8224D710h case    5:*/		return 0x8224D714;
		  /* 8224D714h */ case    6:  		/* li R28, 0 */
		/* 8224D714h case    6:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8224D714h case    6:*/		return 0x8224D718;
		  /* 8224D718h */ case    7:  		/* lwz R3, <#[R30 + 48]> */
		/* 8224D718h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 8224D718h case    7:*/		return 0x8224D71C;
		  /* 8224D71Ch */ case    8:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224D71Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D71Ch case    8:*/		return 0x8224D720;
		  /* 8224D720h */ case    9:  		/* cmplw CR6, R29, R11 */
		/* 8224D720h case    9:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8224D720h case    9:*/		return 0x8224D724;
		  /* 8224D724h */ case   10:  		/* bc 4, CR6_LT, 16 */
		/* 8224D724h case   10:*/		if ( !regs.CR[6].lt ) { return 0x8224D734;  }
		/* 8224D724h case   10:*/		return 0x8224D728;
		  /* 8224D728h */ case   11:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224D728h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224D728h case   11:*/		return 0x8224D72C;
		  /* 8224D72Ch */ case   12:  		/* add R3, R11, R28 */
		/* 8224D72Ch case   12:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R28);
		/* 8224D72Ch case   12:*/		return 0x8224D730;
		  /* 8224D730h */ case   13:  		/* b 12 */
		/* 8224D730h case   13:*/		return 0x8224D73C;
		/* 8224D730h case   13:*/		return 0x8224D734;
	}
	return 0x8224D734;
} // Block from 8224D6FCh-8224D734h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224D734h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D734( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D734) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D734);
		  /* 8224D734h */ case    0:  		/* mr R4, R29 */
		/* 8224D734h case    0:*/		regs.R4 = regs.R29;
		/* 8224D734h case    0:*/		return 0x8224D738;
		  /* 8224D738h */ case    1:  		/* bl 25480 */
		/* 8224D738h case    1:*/		regs.LR = 0x8224D73C; return 0x82253AC0;
		/* 8224D738h case    1:*/		return 0x8224D73C;
	}
	return 0x8224D73C;
} // Block from 8224D734h-8224D73Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224D73Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D73C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D73C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D73C);
		  /* 8224D73Ch */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224D73Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D73Ch case    0:*/		return 0x8224D740;
		  /* 8224D740h */ case    1:  		/* lwz R31, <#[R11 + 4]> */
		/* 8224D740h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 8224D740h case    1:*/		return 0x8224D744;
		  /* 8224D744h */ case    2:  		/* lwz R11, <#[R31 + 36]> */
		/* 8224D744h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 8224D744h case    2:*/		return 0x8224D748;
		  /* 8224D748h */ case    3:  		/* addi R11, R11, 1 */
		/* 8224D748h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224D748h case    3:*/		return 0x8224D74C;
		  /* 8224D74Ch */ case    4:  		/* stw R11, <#[R31 + 36]> */
		/* 8224D74Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 8224D74Ch case    4:*/		return 0x8224D750;
		  /* 8224D750h */ case    5:  		/* lwz R3, <#[R30 + 48]> */
		/* 8224D750h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 8224D750h case    5:*/		return 0x8224D754;
		  /* 8224D754h */ case    6:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224D754h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D754h case    6:*/		return 0x8224D758;
		  /* 8224D758h */ case    7:  		/* cmplw CR6, R29, R11 */
		/* 8224D758h case    7:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8224D758h case    7:*/		return 0x8224D75C;
		  /* 8224D75Ch */ case    8:  		/* bc 4, CR6_LT, 16 */
		/* 8224D75Ch case    8:*/		if ( !regs.CR[6].lt ) { return 0x8224D76C;  }
		/* 8224D75Ch case    8:*/		return 0x8224D760;
		  /* 8224D760h */ case    9:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224D760h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224D760h case    9:*/		return 0x8224D764;
		  /* 8224D764h */ case   10:  		/* add R3, R11, R28 */
		/* 8224D764h case   10:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R28);
		/* 8224D764h case   10:*/		return 0x8224D768;
		  /* 8224D768h */ case   11:  		/* b 12 */
		/* 8224D768h case   11:*/		return 0x8224D774;
		/* 8224D768h case   11:*/		return 0x8224D76C;
	}
	return 0x8224D76C;
} // Block from 8224D73Ch-8224D76Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224D76Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D76C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D76C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D76C);
		  /* 8224D76Ch */ case    0:  		/* mr R4, R29 */
		/* 8224D76Ch case    0:*/		regs.R4 = regs.R29;
		/* 8224D76Ch case    0:*/		return 0x8224D770;
		  /* 8224D770h */ case    1:  		/* bl 25424 */
		/* 8224D770h case    1:*/		regs.LR = 0x8224D774; return 0x82253AC0;
		/* 8224D770h case    1:*/		return 0x8224D774;
	}
	return 0x8224D774;
} // Block from 8224D76Ch-8224D774h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224D774h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D774( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D774) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D774);
		  /* 8224D774h */ case    0:  		/* lwz R9, <#[R3]> */
		/* 8224D774h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D774h case    0:*/		return 0x8224D778;
		  /* 8224D778h */ case    1:  		/* lwz R10, <#[R31 + 20]> */
		/* 8224D778h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 8224D778h case    1:*/		return 0x8224D77C;
		  /* 8224D77Ch */ case    2:  		/* lwz R11, <#[R30 + 20]> */
		/* 8224D77Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 8224D77Ch case    2:*/		return 0x8224D780;
		  /* 8224D780h */ case    3:  		/* lwz R9, <#[R9 + 12]> */
		/* 8224D780h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000000C) );
		/* 8224D780h case    3:*/		return 0x8224D784;
		  /* 8224D784h */ case    4:  		/* add R10, R10, R9 */
		/* 8224D784h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8224D784h case    4:*/		return 0x8224D788;
		  /* 8224D788h */ case    5:  		/* cmpw CR6, R11, R10 */
		/* 8224D788h case    5:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224D788h case    5:*/		return 0x8224D78C;
		  /* 8224D78Ch */ case    6:  		/* bc 4, CR6_LT, 8 */
		/* 8224D78Ch case    6:*/		if ( !regs.CR[6].lt ) { return 0x8224D794;  }
		/* 8224D78Ch case    6:*/		return 0x8224D790;
		  /* 8224D790h */ case    7:  		/* mr R11, R10 */
		/* 8224D790h case    7:*/		regs.R11 = regs.R10;
		/* 8224D790h case    7:*/		return 0x8224D794;
	}
	return 0x8224D794;
} // Block from 8224D774h-8224D794h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224D794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D794);
		  /* 8224D794h */ case    0:  		/* stw R11, <#[R30 + 20]> */
		/* 8224D794h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 8224D794h case    0:*/		return 0x8224D798;
		  /* 8224D798h */ case    1:  		/* lwz R3, <#[R31 + 40]> */
		/* 8224D798h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000028) );
		/* 8224D798h case    1:*/		return 0x8224D79C;
		  /* 8224D79Ch */ case    2:  		/* bl 103612 */
		/* 8224D79Ch case    2:*/		regs.LR = 0x8224D7A0; return 0x82266C58;
		/* 8224D79Ch case    2:*/		return 0x8224D7A0;
		  /* 8224D7A0h */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224D7A0h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224D7A0h case    3:*/		return 0x8224D7A4;
		  /* 8224D7A4h */ case    4:  		/* lwz R10, <#[R31 + 12]> */
		/* 8224D7A4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224D7A4h case    4:*/		return 0x8224D7A8;
		  /* 8224D7A8h */ case    5:  		/* lwz R11, <#[R30 + 12]> */
		/* 8224D7A8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8224D7A8h case    5:*/		return 0x8224D7AC;
		  /* 8224D7ACh */ case    6:  		/* bc 12, CR0_EQ, 8 */
		/* 8224D7ACh case    6:*/		if ( regs.CR[0].eq ) { return 0x8224D7B4;  }
		/* 8224D7ACh case    6:*/		return 0x8224D7B0;
		  /* 8224D7B0h */ case    7:  		/* addi R10, R10, 1 */
		/* 8224D7B0h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8224D7B0h case    7:*/		return 0x8224D7B4;
	}
	return 0x8224D7B4;
} // Block from 8224D794h-8224D7B4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224D7B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D7B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D7B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D7B4);
		  /* 8224D7B4h */ case    0:  		/* cmpw CR6, R11, R10 */
		/* 8224D7B4h case    0:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224D7B4h case    0:*/		return 0x8224D7B8;
		  /* 8224D7B8h */ case    1:  		/* bc 4, CR6_LT, 8 */
		/* 8224D7B8h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8224D7C0;  }
		/* 8224D7B8h case    1:*/		return 0x8224D7BC;
		  /* 8224D7BCh */ case    2:  		/* mr R11, R10 */
		/* 8224D7BCh case    2:*/		regs.R11 = regs.R10;
		/* 8224D7BCh case    2:*/		return 0x8224D7C0;
	}
	return 0x8224D7C0;
} // Block from 8224D7B4h-8224D7C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224D7C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D7C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D7C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D7C0);
		  /* 8224D7C0h */ case    0:  		/* addi R29, R29, 1 */
		/* 8224D7C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8224D7C0h case    0:*/		return 0x8224D7C4;
		  /* 8224D7C4h */ case    1:  		/* stw R11, <#[R30 + 12]> */
		/* 8224D7C4h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8224D7C4h case    1:*/		return 0x8224D7C8;
		  /* 8224D7C8h */ case    2:  		/* addi R28, R28, 4 */
		/* 8224D7C8h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 8224D7C8h case    2:*/		return 0x8224D7CC;
		  /* 8224D7CCh */ case    3:  		/* cmpw CR6, R29, R27 */
		/* 8224D7CCh case    3:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R27);
		/* 8224D7CCh case    3:*/		return 0x8224D7D0;
		  /* 8224D7D0h */ case    4:  		/* bc 12, CR6_LT, -184 */
		/* 8224D7D0h case    4:*/		if ( regs.CR[6].lt ) { return 0x8224D718;  }
		/* 8224D7D0h case    4:*/		return 0x8224D7D4;
	}
	return 0x8224D7D4;
} // Block from 8224D7C0h-8224D7D4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224D7D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D7D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D7D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D7D4);
		  /* 8224D7D4h */ case    0:  		/* lwz R4, <#[R30 + 40]> */
		/* 8224D7D4h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000028) );
		/* 8224D7D4h case    0:*/		return 0x8224D7D8;
		  /* 8224D7D8h */ case    1:  		/* lwz R3, <#[R24 + 8]> */
		/* 8224D7D8h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000008) );
		/* 8224D7D8h case    1:*/		return 0x8224D7DC;
		  /* 8224D7DCh */ case    2:  		/* bl 103236 */
		/* 8224D7DCh case    2:*/		regs.LR = 0x8224D7E0; return 0x82266B20;
		/* 8224D7DCh case    2:*/		return 0x8224D7E0;
		  /* 8224D7E0h */ case    3:  		/* lwz R11, <#[R24 + 8]> */
		/* 8224D7E0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 8224D7E0h case    3:*/		return 0x8224D7E4;
		  /* 8224D7E4h */ case    4:  		/* lwz R10, <#[R11 + 16]> */
		/* 8224D7E4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 8224D7E4h case    4:*/		return 0x8224D7E8;
		  /* 8224D7E8h */ case    5:  		/* lwz R9, <#[R11 + 20]> */
		/* 8224D7E8h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 8224D7E8h case    5:*/		return 0x8224D7EC;
		  /* 8224D7ECh */ case    6:  		/* cmpw CR6, R10, R9 */
		/* 8224D7ECh case    6:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R9);
		/* 8224D7ECh case    6:*/		return 0x8224D7F0;
		  /* 8224D7F0h */ case    7:  		/* bc 4, CR6_GT, 12 */
		/* 8224D7F0h case    7:*/		if ( !regs.CR[6].gt ) { return 0x8224D7FC;  }
		/* 8224D7F0h case    7:*/		return 0x8224D7F4;
		  /* 8224D7F4h */ case    8:  		/* lwz R11, <#[R11 + 24]> */
		/* 8224D7F4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8224D7F4h case    8:*/		return 0x8224D7F8;
		  /* 8224D7F8h */ case    9:  		/* b 20 */
		/* 8224D7F8h case    9:*/		return 0x8224D80C;
		/* 8224D7F8h case    9:*/		return 0x8224D7FC;
	}
	return 0x8224D7FC;
} // Block from 8224D7D4h-8224D7FCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224D7FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D7FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D7FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D7FC);
		  /* 8224D7FCh */ case    0:  		/* add R9, R9, R10 */
		/* 8224D7FCh case    0:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 8224D7FCh case    0:*/		return 0x8224D800;
		  /* 8224D800h */ case    1:  		/* lwz R10, <#[R11 + 24]> */
		/* 8224D800h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 8224D800h case    1:*/		return 0x8224D804;
		  /* 8224D804h */ case    2:  		/* srawi R11, R9, 1 */
		/* 8224D804h case    2:*/		cpu::op::srawi<0,1>(regs,&regs.R11,regs.R9);
		/* 8224D804h case    2:*/		return 0x8224D808;
		  /* 8224D808h */ case    3:  		/* addze R11, R11 */
		/* 8224D808h case    3:*/		cpu::op::addze<0>(regs,&regs.R11,regs.R11);
		/* 8224D808h case    3:*/		return 0x8224D80C;
	}
	return 0x8224D80C;
} // Block from 8224D7FCh-8224D80Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224D80Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D80C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D80C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D80C);
		  /* 8224D80Ch */ case    0:  		/* add R11, R11, R10 */
		/* 8224D80Ch case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8224D80Ch case    0:*/		return 0x8224D810;
		  /* 8224D810h */ case    1:  		/* lwz R10, <#[R30 + 52]> */
		/* 8224D810h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000034) );
		/* 8224D810h case    1:*/		return 0x8224D814;
		  /* 8224D814h */ case    2:  		/* li R31, 0 */
		/* 8224D814h case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8224D814h case    2:*/		return 0x8224D818;
		  /* 8224D818h */ case    3:  		/* stw R11, <#[R30 + 24]> */
		/* 8224D818h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 8224D818h case    3:*/		return 0x8224D81C;
		  /* 8224D81Ch */ case    4:  		/* lwz R28, <#[R10 + 4]> */
		/* 8224D81Ch case    4:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + 0x00000004) );
		/* 8224D81Ch case    4:*/		return 0x8224D820;
		  /* 8224D820h */ case    5:  		/* cmpwi CR6, R28, 0 */
		/* 8224D820h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 8224D820h case    5:*/		return 0x8224D824;
		  /* 8224D824h */ case    6:  		/* bc 4, CR6_GT, 92 */
		/* 8224D824h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8224D880;  }
		/* 8224D824h case    6:*/		return 0x8224D828;
		  /* 8224D828h */ case    7:  		/* li R29, 0 */
		/* 8224D828h case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8224D828h case    7:*/		return 0x8224D82C;
		  /* 8224D82Ch */ case    8:  		/* lwz R3, <#[R30 + 52]> */
		/* 8224D82Ch case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000034) );
		/* 8224D82Ch case    8:*/		return 0x8224D830;
		  /* 8224D830h */ case    9:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224D830h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D830h case    9:*/		return 0x8224D834;
		  /* 8224D834h */ case   10:  		/* cmplw CR6, R31, R11 */
		/* 8224D834h case   10:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8224D834h case   10:*/		return 0x8224D838;
		  /* 8224D838h */ case   11:  		/* bc 4, CR6_LT, 16 */
		/* 8224D838h case   11:*/		if ( !regs.CR[6].lt ) { return 0x8224D848;  }
		/* 8224D838h case   11:*/		return 0x8224D83C;
		  /* 8224D83Ch */ case   12:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224D83Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224D83Ch case   12:*/		return 0x8224D840;
		  /* 8224D840h */ case   13:  		/* add R3, R11, R29 */
		/* 8224D840h case   13:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 8224D840h case   13:*/		return 0x8224D844;
		  /* 8224D844h */ case   14:  		/* b 12 */
		/* 8224D844h case   14:*/		return 0x8224D850;
		/* 8224D844h case   14:*/		return 0x8224D848;
	}
	return 0x8224D848;
} // Block from 8224D80Ch-8224D848h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8224D848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D848);
		  /* 8224D848h */ case    0:  		/* mr R4, R31 */
		/* 8224D848h case    0:*/		regs.R4 = regs.R31;
		/* 8224D848h case    0:*/		return 0x8224D84C;
		  /* 8224D84Ch */ case    1:  		/* bl 25204 */
		/* 8224D84Ch case    1:*/		regs.LR = 0x8224D850; return 0x82253AC0;
		/* 8224D84Ch case    1:*/		return 0x8224D850;
	}
	return 0x8224D850;
} // Block from 8224D848h-8224D850h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224D850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D850);
		  /* 8224D850h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224D850h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D850h case    0:*/		return 0x8224D854;
		  /* 8224D854h */ case    1:  		/* lwz R10, <#[R11 + 8]> */
		/* 8224D854h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8224D854h case    1:*/		return 0x8224D858;
		  /* 8224D858h */ case    2:  		/* cmpwi CR6, R10, 0 */
		/* 8224D858h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8224D858h case    2:*/		return 0x8224D85C;
		  /* 8224D85Ch */ case    3:  		/* bc 4, CR6_EQ, 20 */
		/* 8224D85Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8224D870;  }
		/* 8224D85Ch case    3:*/		return 0x8224D860;
		  /* 8224D860h */ case    4:  		/* lwz R10, <#[R11]> */
		/* 8224D860h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8224D860h case    4:*/		return 0x8224D864;
		  /* 8224D864h */ case    5:  		/* lwz R11, <#[R10 + 60]> */
		/* 8224D864h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000003C) );
		/* 8224D864h case    5:*/		return 0x8224D868;
		  /* 8224D868h */ case    6:  		/* addi R11, R11, 1 */
		/* 8224D868h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224D868h case    6:*/		return 0x8224D86C;
		  /* 8224D86Ch */ case    7:  		/* stw R11, <#[R10 + 60]> */
		/* 8224D86Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x0000003C) );
		/* 8224D86Ch case    7:*/		return 0x8224D870;
	}
	return 0x8224D870;
} // Block from 8224D850h-8224D870h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224D870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D870);
		  /* 8224D870h */ case    0:  		/* addi R31, R31, 1 */
		/* 8224D870h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8224D870h case    0:*/		return 0x8224D874;
		  /* 8224D874h */ case    1:  		/* addi R29, R29, 4 */
		/* 8224D874h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8224D874h case    1:*/		return 0x8224D878;
		  /* 8224D878h */ case    2:  		/* cmpw CR6, R31, R28 */
		/* 8224D878h case    2:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R28);
		/* 8224D878h case    2:*/		return 0x8224D87C;
		  /* 8224D87Ch */ case    3:  		/* bc 12, CR6_LT, -80 */
		/* 8224D87Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8224D82C;  }
		/* 8224D87Ch case    3:*/		return 0x8224D880;
	}
	return 0x8224D880;
} // Block from 8224D870h-8224D880h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224D880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D880);
		  /* 8224D880h */ case    0:  		/* lwz R11, <#[R24 + 108]> */
		/* 8224D880h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000006C) );
		/* 8224D880h case    0:*/		return 0x8224D884;
		  /* 8224D884h */ case    1:  		/* lwz R10, <#[R30 + 20]> */
		/* 8224D884h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000014) );
		/* 8224D884h case    1:*/		return 0x8224D888;
		  /* 8224D888h */ case    2:  		/* cmpw CR6, R11, R10 */
		/* 8224D888h case    2:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224D888h case    2:*/		return 0x8224D88C;
		  /* 8224D88Ch */ case    3:  		/* bc 4, CR6_LT, 8 */
		/* 8224D88Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x8224D894;  }
		/* 8224D88Ch case    3:*/		return 0x8224D890;
		  /* 8224D890h */ case    4:  		/* mr R11, R10 */
		/* 8224D890h case    4:*/		regs.R11 = regs.R10;
		/* 8224D890h case    4:*/		return 0x8224D894;
	}
	return 0x8224D894;
} // Block from 8224D880h-8224D894h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224D894h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D894( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D894) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D894);
		  /* 8224D894h */ case    0:  		/* addic. R26, R26, -1 */
		/* 8224D894h case    0:*/		cpu::op::addic<1>(regs,&regs.R26,regs.R26,0xFFFFFFFF);
		/* 8224D894h case    0:*/		return 0x8224D898;
		  /* 8224D898h */ case    1:  		/* stw R11, <#[R24 + 108]> */
		/* 8224D898h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x0000006C) );
		/* 8224D898h case    1:*/		return 0x8224D89C;
		  /* 8224D89Ch */ case    2:  		/* addi R25, R25, -4 */
		/* 8224D89Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0xFFFFFFFC);
		/* 8224D89Ch case    2:*/		return 0x8224D8A0;
		  /* 8224D8A0h */ case    3:  		/* bc 4, CR0_LT, -456 */
		/* 8224D8A0h case    3:*/		if ( !regs.CR[0].lt ) { return 0x8224D6D8;  }
		/* 8224D8A0h case    3:*/		return 0x8224D8A4;
	}
	return 0x8224D8A4;
} // Block from 8224D894h-8224D8A4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224D8A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D8A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D8A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D8A4);
		  /* 8224D8A4h */ case    0:  		/* li R27, 0 */
		/* 8224D8A4h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8224D8A4h case    0:*/		return 0x8224D8A8;
		  /* 8224D8A8h */ case    1:  		/* cmpwi CR6, R23, 0 */
		/* 8224D8A8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 8224D8A8h case    1:*/		return 0x8224D8AC;
		  /* 8224D8ACh */ case    2:  		/* bc 4, CR6_GT, 244 */
		/* 8224D8ACh case    2:*/		if ( !regs.CR[6].gt ) { return 0x8224D9A0;  }
		/* 8224D8ACh case    2:*/		return 0x8224D8B0;
		  /* 8224D8B0h */ case    3:  		/* lis R11, -32256 */
		/* 8224D8B0h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8224D8B0h case    3:*/		return 0x8224D8B4;
		  /* 8224D8B4h */ case    4:  		/* li R26, 0 */
		/* 8224D8B4h case    4:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8224D8B4h case    4:*/		return 0x8224D8B8;
		  /* 8224D8B8h */ case    5:  		/* lfd FR31, <#[R11 + 1848]> */
		/* 8224D8B8h case    5:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000738) );
		/* 8224D8B8h case    5:*/		return 0x8224D8BC;
		  /* 8224D8BCh */ case    6:  		/* lwz R3, <#[R24 + 24]> */
		/* 8224D8BCh case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000018) );
		/* 8224D8BCh case    6:*/		return 0x8224D8C0;
		  /* 8224D8C0h */ case    7:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224D8C0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D8C0h case    7:*/		return 0x8224D8C4;
		  /* 8224D8C4h */ case    8:  		/* cmplw CR6, R27, R11 */
		/* 8224D8C4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 8224D8C4h case    8:*/		return 0x8224D8C8;
		  /* 8224D8C8h */ case    9:  		/* bc 4, CR6_LT, 16 */
		/* 8224D8C8h case    9:*/		if ( !regs.CR[6].lt ) { return 0x8224D8D8;  }
		/* 8224D8C8h case    9:*/		return 0x8224D8CC;
		  /* 8224D8CCh */ case   10:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224D8CCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224D8CCh case   10:*/		return 0x8224D8D0;
		  /* 8224D8D0h */ case   11:  		/* add R3, R11, R26 */
		/* 8224D8D0h case   11:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 8224D8D0h case   11:*/		return 0x8224D8D4;
		  /* 8224D8D4h */ case   12:  		/* b 12 */
		/* 8224D8D4h case   12:*/		return 0x8224D8E0;
		/* 8224D8D4h case   12:*/		return 0x8224D8D8;
	}
	return 0x8224D8D8;
} // Block from 8224D8A4h-8224D8D8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224D8D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D8D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D8D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D8D8);
		  /* 8224D8D8h */ case    0:  		/* mr R4, R27 */
		/* 8224D8D8h case    0:*/		regs.R4 = regs.R27;
		/* 8224D8D8h case    0:*/		return 0x8224D8DC;
		  /* 8224D8DCh */ case    1:  		/* bl 25060 */
		/* 8224D8DCh case    1:*/		regs.LR = 0x8224D8E0; return 0x82253AC0;
		/* 8224D8DCh case    1:*/		return 0x8224D8E0;
	}
	return 0x8224D8E0;
} // Block from 8224D8D8h-8224D8E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224D8E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D8E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D8E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D8E0);
		  /* 8224D8E0h */ case    0:  		/* lwz R30, <#[R3]> */
		/* 8224D8E0h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D8E0h case    0:*/		return 0x8224D8E4;
		  /* 8224D8E4h */ case    1:  		/* li R31, 0 */
		/* 8224D8E4h case    1:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8224D8E4h case    1:*/		return 0x8224D8E8;
		  /* 8224D8E8h */ case    2:  		/* lwz R11, <#[R30 + 52]> */
		/* 8224D8E8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000034) );
		/* 8224D8E8h case    2:*/		return 0x8224D8EC;
		  /* 8224D8ECh */ case    3:  		/* lwz R28, <#[R11 + 4]> */
		/* 8224D8ECh case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000004) );
		/* 8224D8ECh case    3:*/		return 0x8224D8F0;
		  /* 8224D8F0h */ case    4:  		/* cmpwi CR6, R28, 0 */
		/* 8224D8F0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 8224D8F0h case    4:*/		return 0x8224D8F4;
		  /* 8224D8F4h */ case    5:  		/* bc 4, CR6_GT, 128 */
		/* 8224D8F4h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8224D974;  }
		/* 8224D8F4h case    5:*/		return 0x8224D8F8;
		  /* 8224D8F8h */ case    6:  		/* li R29, 0 */
		/* 8224D8F8h case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8224D8F8h case    6:*/		return 0x8224D8FC;
		  /* 8224D8FCh */ case    7:  		/* lwz R3, <#[R30 + 52]> */
		/* 8224D8FCh case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000034) );
		/* 8224D8FCh case    7:*/		return 0x8224D900;
		  /* 8224D900h */ case    8:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224D900h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224D900h case    8:*/		return 0x8224D904;
		  /* 8224D904h */ case    9:  		/* cmplw CR6, R31, R11 */
		/* 8224D904h case    9:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8224D904h case    9:*/		return 0x8224D908;
		  /* 8224D908h */ case   10:  		/* bc 4, CR6_LT, 16 */
		/* 8224D908h case   10:*/		if ( !regs.CR[6].lt ) { return 0x8224D918;  }
		/* 8224D908h case   10:*/		return 0x8224D90C;
		  /* 8224D90Ch */ case   11:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224D90Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224D90Ch case   11:*/		return 0x8224D910;
		  /* 8224D910h */ case   12:  		/* add R3, R11, R29 */
		/* 8224D910h case   12:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 8224D910h case   12:*/		return 0x8224D914;
		  /* 8224D914h */ case   13:  		/* b 12 */
		/* 8224D914h case   13:*/		return 0x8224D920;
		/* 8224D914h case   13:*/		return 0x8224D918;
	}
	return 0x8224D918;
} // Block from 8224D8E0h-8224D918h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224D918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D918);
		  /* 8224D918h */ case    0:  		/* mr R4, R31 */
		/* 8224D918h case    0:*/		regs.R4 = regs.R31;
		/* 8224D918h case    0:*/		return 0x8224D91C;
		  /* 8224D91Ch */ case    1:  		/* bl 24996 */
		/* 8224D91Ch case    1:*/		regs.LR = 0x8224D920; return 0x82253AC0;
		/* 8224D91Ch case    1:*/		return 0x8224D920;
	}
	return 0x8224D920;
} // Block from 8224D918h-8224D920h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224D920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D920);
		  /* 8224D920h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224D920h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224D920h case    0:*/		return 0x8224D924;
		  /* 8224D924h */ case    1:  		/* lwz R10, <#[R11 + 8]> */
		/* 8224D924h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8224D924h case    1:*/		return 0x8224D928;
		  /* 8224D928h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 8224D928h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8224D928h case    2:*/		return 0x8224D92C;
		  /* 8224D92Ch */ case    3:  		/* cmpwi CR6, R10, 0 */
		/* 8224D92Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8224D92Ch case    3:*/		return 0x8224D930;
		  /* 8224D930h */ case    4:  		/* bc 4, CR6_EQ, 52 */
		/* 8224D930h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8224D964;  }
		/* 8224D930h case    4:*/		return 0x8224D934;
		  /* 8224D934h */ case    5:  		/* lwz R11, <#[R11 + 60]> */
		/* 8224D934h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000003C) );
		/* 8224D934h case    5:*/		return 0x8224D938;
		  /* 8224D938h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 8224D938h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224D938h case    6:*/		return 0x8224D93C;
		  /* 8224D93Ch */ case    7:  		/* bc 4, CR6_GT, 40 */
		/* 8224D93Ch case    7:*/		if ( !regs.CR[6].gt ) { return 0x8224D964;  }
		/* 8224D93Ch case    7:*/		return 0x8224D940;
		  /* 8224D940h */ case    8:  		/* extsw R11, R11 */
		/* 8224D940h case    8:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 8224D940h case    8:*/		return 0x8224D944;
		  /* 8224D944h */ case    9:  		/* lfs FR0, <#[R30 + 16]> */
		/* 8224D944h case    9:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000010) );
		/* 8224D944h case    9:*/		return 0x8224D948;
		  /* 8224D948h */ case   10:  		/* std R11, <#[R1 + 80]> */
		/* 8224D948h case   10:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8224D948h case   10:*/		return 0x8224D94C;
		  /* 8224D94Ch */ case   11:  		/* lfd FR13, <#[R1 + 80]> */
		/* 8224D94Ch case   11:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 8224D94Ch case   11:*/		return 0x8224D950;
		  /* 8224D950h */ case   12:  		/* fcfid FR13, FR13 */
		/* 8224D950h case   12:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 8224D950h case   12:*/		return 0x8224D954;
		  /* 8224D954h */ case   13:  		/* fdiv FR13, FR31, FR13 */
		/* 8224D954h case   13:*/		cpu::op::fdiv<0>(regs,&regs.FR13,regs.FR31,regs.FR13);
		/* 8224D954h case   13:*/		return 0x8224D958;
		  /* 8224D958h */ case   14:  		/* frsp FR13, FR13 */
		/* 8224D958h case   14:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 8224D958h case   14:*/		return 0x8224D95C;
		  /* 8224D95Ch */ case   15:  		/* fadds FR0, FR13, FR0 */
		/* 8224D95Ch case   15:*/		cpu::op::fadds<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 8224D95Ch case   15:*/		return 0x8224D960;
		  /* 8224D960h */ case   16:  		/* stfs FR0, <#[R30 + 16]> */
		/* 8224D960h case   16:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R30 + 0x00000010) );
		/* 8224D960h case   16:*/		return 0x8224D964;
	}
	return 0x8224D964;
} // Block from 8224D920h-8224D964h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8224D964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D964);
		  /* 8224D964h */ case    0:  		/* addi R31, R31, 1 */
		/* 8224D964h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8224D964h case    0:*/		return 0x8224D968;
		  /* 8224D968h */ case    1:  		/* addi R29, R29, 4 */
		/* 8224D968h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8224D968h case    1:*/		return 0x8224D96C;
		  /* 8224D96Ch */ case    2:  		/* cmpw CR6, R31, R28 */
		/* 8224D96Ch case    2:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R28);
		/* 8224D96Ch case    2:*/		return 0x8224D970;
		  /* 8224D970h */ case    3:  		/* bc 12, CR6_LT, -116 */
		/* 8224D970h case    3:*/		if ( regs.CR[6].lt ) { return 0x8224D8FC;  }
		/* 8224D970h case    3:*/		return 0x8224D974;
	}
	return 0x8224D974;
} // Block from 8224D964h-8224D974h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224D974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D974);
		  /* 8224D974h */ case    0:  		/* lwz R11, <#[R30 + 60]> */
		/* 8224D974h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000003C) );
		/* 8224D974h case    0:*/		return 0x8224D978;
		  /* 8224D978h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224D978h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224D978h case    1:*/		return 0x8224D97C;
		  /* 8224D97Ch */ case    2:  		/* bc 4, CR6_GT, 20 */
		/* 8224D97Ch case    2:*/		if ( !regs.CR[6].gt ) { return 0x8224D990;  }
		/* 8224D97Ch case    2:*/		return 0x8224D980;
		  /* 8224D980h */ case    3:  		/* lfs FR0, <#[R30 + 16]> */
		/* 8224D980h case    3:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000010) );
		/* 8224D980h case    3:*/		return 0x8224D984;
		  /* 8224D984h */ case    4:  		/* fsub FR0, FR0, FR31 */
		/* 8224D984h case    4:*/		cpu::op::fsub<0>(regs,&regs.FR0,regs.FR0,regs.FR31);
		/* 8224D984h case    4:*/		return 0x8224D988;
		  /* 8224D988h */ case    5:  		/* frsp FR0, FR0 */
		/* 8224D988h case    5:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 8224D988h case    5:*/		return 0x8224D98C;
		  /* 8224D98Ch */ case    6:  		/* stfs FR0, <#[R30 + 16]> */
		/* 8224D98Ch case    6:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R30 + 0x00000010) );
		/* 8224D98Ch case    6:*/		return 0x8224D990;
	}
	return 0x8224D990;
} // Block from 8224D974h-8224D990h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224D990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D990);
		  /* 8224D990h */ case    0:  		/* addi R27, R27, 1 */
		/* 8224D990h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8224D990h case    0:*/		return 0x8224D994;
		  /* 8224D994h */ case    1:  		/* addi R26, R26, 4 */
		/* 8224D994h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 8224D994h case    1:*/		return 0x8224D998;
		  /* 8224D998h */ case    2:  		/* cmpw CR6, R27, R23 */
		/* 8224D998h case    2:*/		cpu::op::cmpw<6>(regs,regs.R27,regs.R23);
		/* 8224D998h case    2:*/		return 0x8224D99C;
		  /* 8224D99Ch */ case    3:  		/* bc 12, CR6_LT, -224 */
		/* 8224D99Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8224D8BC;  }
		/* 8224D99Ch case    3:*/		return 0x8224D9A0;
	}
	return 0x8224D9A0;
} // Block from 8224D990h-8224D9A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224D9A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D9A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D9A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D9A0);
		  /* 8224D9A0h */ case    0:  		/* addi R1, R1, 176 */
		/* 8224D9A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 8224D9A0h case    0:*/		return 0x8224D9A4;
		  /* 8224D9A4h */ case    1:  		/* lfd FR31, <#[R1 - 88]> */
		/* 8224D9A4h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA8) );
		/* 8224D9A4h case    1:*/		return 0x8224D9A8;
		  /* 8224D9A8h */ case    2:  		/* b -1820436 */
		/* 8224D9A8h case    2:*/		return 0x82091294;
		/* 8224D9A8h case    2:*/		return 0x8224D9AC;
		  /* 8224D9ACh */ case    3:  		/* nop */
		/* 8224D9ACh case    3:*/		cpu::op::nop();
		/* 8224D9ACh case    3:*/		return 0x8224D9B0;
	}
	return 0x8224D9B0;
} // Block from 8224D9A0h-8224D9B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224D9B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D9B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D9B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D9B0);
		  /* 8224D9B0h */ case    0:  		/* mfspr R12, LR */
		/* 8224D9B0h case    0:*/		regs.R12 = regs.LR;
		/* 8224D9B0h case    0:*/		return 0x8224D9B4;
		  /* 8224D9B4h */ case    1:  		/* bl -1820516 */
		/* 8224D9B4h case    1:*/		regs.LR = 0x8224D9B8; return 0x82091250;
		/* 8224D9B4h case    1:*/		return 0x8224D9B8;
		  /* 8224D9B8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8224D9B8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8224D9B8h case    2:*/		return 0x8224D9BC;
		  /* 8224D9BCh */ case    3:  		/* lwz R9, <#[R4 + 28]> */
		/* 8224D9BCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x0000001C) );
		/* 8224D9BCh case    3:*/		return 0x8224D9C0;
		  /* 8224D9C0h */ case    4:  		/* lis R11, -32253 */
		/* 8224D9C0h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8224D9C0h case    4:*/		return 0x8224D9C4;
		  /* 8224D9C4h */ case    5:  		/* lis R10, -32252 */
		/* 8224D9C4h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224D9C4h case    5:*/		return 0x8224D9C8;
		  /* 8224D9C8h */ case    6:  		/* mr R26, R3 */
		/* 8224D9C8h case    6:*/		regs.R26 = regs.R3;
		/* 8224D9C8h case    6:*/		return 0x8224D9CC;
		  /* 8224D9CCh */ case    7:  		/* mr R29, R4 */
		/* 8224D9CCh case    7:*/		regs.R29 = regs.R4;
		/* 8224D9CCh case    7:*/		return 0x8224D9D0;
		  /* 8224D9D0h */ case    8:  		/* addi R31, R11, 27460 */
		/* 8224D9D0h case    8:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x6B44);
		/* 8224D9D0h case    8:*/		return 0x8224D9D4;
		  /* 8224D9D4h */ case    9:  		/* addi R30, R10, 14208 */
		/* 8224D9D4h case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R10,0x3780);
		/* 8224D9D4h case    9:*/		return 0x8224D9D8;
		  /* 8224D9D8h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 8224D9D8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 8224D9D8h case   10:*/		return 0x8224D9DC;
		  /* 8224D9DCh */ case   11:  		/* bc 4, CR6_LT, 32 */
		/* 8224D9DCh case   11:*/		if ( !regs.CR[6].lt ) { return 0x8224D9FC;  }
		/* 8224D9DCh case   11:*/		return 0x8224D9E0;
		  /* 8224D9E0h */ case   12:  		/* lis R11, -32252 */
		/* 8224D9E0h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224D9E0h case   12:*/		return 0x8224D9E4;
		  /* 8224D9E4h */ case   13:  		/* mr R6, R30 */
		/* 8224D9E4h case   13:*/		regs.R6 = regs.R30;
		/* 8224D9E4h case   13:*/		return 0x8224D9E8;
		  /* 8224D9E8h */ case   14:  		/* addi R5, R11, 15300 */
		/* 8224D9E8h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3BC4);
		/* 8224D9E8h case   14:*/		return 0x8224D9EC;
		  /* 8224D9ECh */ case   15:  		/* mr R4, R31 */
		/* 8224D9ECh case   15:*/		regs.R4 = regs.R31;
		/* 8224D9ECh case   15:*/		return 0x8224D9F0;
		  /* 8224D9F0h */ case   16:  		/* li R7, 1432 */
		/* 8224D9F0h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x598);
		/* 8224D9F0h case   16:*/		return 0x8224D9F4;
		  /* 8224D9F4h */ case   17:  		/* li R3, 0 */
		/* 8224D9F4h case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224D9F4h case   17:*/		return 0x8224D9F8;
		  /* 8224D9F8h */ case   18:  		/* bl -1007088 */
		/* 8224D9F8h case   18:*/		regs.LR = 0x8224D9FC; return 0x82157C08;
		/* 8224D9F8h case   18:*/		return 0x8224D9FC;
	}
	return 0x8224D9FC;
} // Block from 8224D9B0h-8224D9FCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 8224D9FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224D9FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224D9FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224D9FC);
		  /* 8224D9FCh */ case    0:  		/* lwz R11, <#[R29 + 36]> */
		/* 8224D9FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000024) );
		/* 8224D9FCh case    0:*/		return 0x8224DA00;
		  /* 8224DA00h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224DA00h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224DA00h case    1:*/		return 0x8224DA04;
		  /* 8224DA04h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 8224DA04h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224DA24;  }
		/* 8224DA04h case    2:*/		return 0x8224DA08;
		  /* 8224DA08h */ case    3:  		/* lis R11, -32252 */
		/* 8224DA08h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224DA08h case    3:*/		return 0x8224DA0C;
		  /* 8224DA0Ch */ case    4:  		/* mr R6, R30 */
		/* 8224DA0Ch case    4:*/		regs.R6 = regs.R30;
		/* 8224DA0Ch case    4:*/		return 0x8224DA10;
		  /* 8224DA10h */ case    5:  		/* addi R5, R11, 14684 */
		/* 8224DA10h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x395C);
		/* 8224DA10h case    5:*/		return 0x8224DA14;
		  /* 8224DA14h */ case    6:  		/* mr R4, R31 */
		/* 8224DA14h case    6:*/		regs.R4 = regs.R31;
		/* 8224DA14h case    6:*/		return 0x8224DA18;
		  /* 8224DA18h */ case    7:  		/* li R7, 1433 */
		/* 8224DA18h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x599);
		/* 8224DA18h case    7:*/		return 0x8224DA1C;
		  /* 8224DA1Ch */ case    8:  		/* li R3, 0 */
		/* 8224DA1Ch case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224DA1Ch case    8:*/		return 0x8224DA20;
		  /* 8224DA20h */ case    9:  		/* bl -1007128 */
		/* 8224DA20h case    9:*/		regs.LR = 0x8224DA24; return 0x82157C08;
		/* 8224DA20h case    9:*/		return 0x8224DA24;
	}
	return 0x8224DA24;
} // Block from 8224D9FCh-8224DA24h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224DA24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DA24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DA24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DA24);
		  /* 8224DA24h */ case    0:  		/* lwz R11, <#[R29 + 48]> */
		/* 8224DA24h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 8224DA24h case    0:*/		return 0x8224DA28;
		  /* 8224DA28h */ case    1:  		/* li R30, 0 */
		/* 8224DA28h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8224DA28h case    1:*/		return 0x8224DA2C;
		  /* 8224DA2Ch */ case    2:  		/* lwz R27, <#[R11 + 4]> */
		/* 8224DA2Ch case    2:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000004) );
		/* 8224DA2Ch case    2:*/		return 0x8224DA30;
		  /* 8224DA30h */ case    3:  		/* cmpwi CR6, R27, 0 */
		/* 8224DA30h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 8224DA30h case    3:*/		return 0x8224DA34;
		  /* 8224DA34h */ case    4:  		/* bc 4, CR6_GT, 224 */
		/* 8224DA34h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8224DB14;  }
		/* 8224DA34h case    4:*/		return 0x8224DA38;
		  /* 8224DA38h */ case    5:  		/* li R28, 0 */
		/* 8224DA38h case    5:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8224DA38h case    5:*/		return 0x8224DA3C;
		  /* 8224DA3Ch */ case    6:  		/* lwz R3, <#[R29 + 48]> */
		/* 8224DA3Ch case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000030) );
		/* 8224DA3Ch case    6:*/		return 0x8224DA40;
		  /* 8224DA40h */ case    7:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224DA40h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224DA40h case    7:*/		return 0x8224DA44;
		  /* 8224DA44h */ case    8:  		/* cmplw CR6, R30, R11 */
		/* 8224DA44h case    8:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8224DA44h case    8:*/		return 0x8224DA48;
		  /* 8224DA48h */ case    9:  		/* bc 4, CR6_LT, 16 */
		/* 8224DA48h case    9:*/		if ( !regs.CR[6].lt ) { return 0x8224DA58;  }
		/* 8224DA48h case    9:*/		return 0x8224DA4C;
		  /* 8224DA4Ch */ case   10:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224DA4Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224DA4Ch case   10:*/		return 0x8224DA50;
		  /* 8224DA50h */ case   11:  		/* add R3, R11, R28 */
		/* 8224DA50h case   11:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R28);
		/* 8224DA50h case   11:*/		return 0x8224DA54;
		  /* 8224DA54h */ case   12:  		/* b 12 */
		/* 8224DA54h case   12:*/		return 0x8224DA60;
		/* 8224DA54h case   12:*/		return 0x8224DA58;
	}
	return 0x8224DA58;
} // Block from 8224DA24h-8224DA58h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224DA58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DA58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DA58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DA58);
		  /* 8224DA58h */ case    0:  		/* mr R4, R30 */
		/* 8224DA58h case    0:*/		regs.R4 = regs.R30;
		/* 8224DA58h case    0:*/		return 0x8224DA5C;
		  /* 8224DA5Ch */ case    1:  		/* bl 24676 */
		/* 8224DA5Ch case    1:*/		regs.LR = 0x8224DA60; return 0x82253AC0;
		/* 8224DA5Ch case    1:*/		return 0x8224DA60;
	}
	return 0x8224DA60;
} // Block from 8224DA58h-8224DA60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224DA60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DA60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DA60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DA60);
		  /* 8224DA60h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224DA60h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224DA60h case    0:*/		return 0x8224DA64;
		  /* 8224DA64h */ case    1:  		/* lwz R31, <#[R11 + 4]> */
		/* 8224DA64h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 8224DA64h case    1:*/		return 0x8224DA68;
		  /* 8224DA68h */ case    2:  		/* lwz R11, <#[R31 + 36]> */
		/* 8224DA68h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 8224DA68h case    2:*/		return 0x8224DA6C;
		  /* 8224DA6Ch */ case    3:  		/* addi R11, R11, -1 */
		/* 8224DA6Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8224DA6Ch case    3:*/		return 0x8224DA70;
		  /* 8224DA70h */ case    4:  		/* stw R11, <#[R31 + 36]> */
		/* 8224DA70h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 8224DA70h case    4:*/		return 0x8224DA74;
		  /* 8224DA74h */ case    5:  		/* lwz R3, <#[R29 + 48]> */
		/* 8224DA74h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000030) );
		/* 8224DA74h case    5:*/		return 0x8224DA78;
		  /* 8224DA78h */ case    6:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224DA78h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224DA78h case    6:*/		return 0x8224DA7C;
		  /* 8224DA7Ch */ case    7:  		/* cmplw CR6, R30, R11 */
		/* 8224DA7Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8224DA7Ch case    7:*/		return 0x8224DA80;
		  /* 8224DA80h */ case    8:  		/* bc 4, CR6_LT, 16 */
		/* 8224DA80h case    8:*/		if ( !regs.CR[6].lt ) { return 0x8224DA90;  }
		/* 8224DA80h case    8:*/		return 0x8224DA84;
		  /* 8224DA84h */ case    9:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224DA84h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224DA84h case    9:*/		return 0x8224DA88;
		  /* 8224DA88h */ case   10:  		/* add R3, R11, R28 */
		/* 8224DA88h case   10:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R28);
		/* 8224DA88h case   10:*/		return 0x8224DA8C;
		  /* 8224DA8Ch */ case   11:  		/* b 12 */
		/* 8224DA8Ch case   11:*/		return 0x8224DA98;
		/* 8224DA8Ch case   11:*/		return 0x8224DA90;
	}
	return 0x8224DA90;
} // Block from 8224DA60h-8224DA90h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224DA90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DA90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DA90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DA90);
		  /* 8224DA90h */ case    0:  		/* mr R4, R30 */
		/* 8224DA90h case    0:*/		regs.R4 = regs.R30;
		/* 8224DA90h case    0:*/		return 0x8224DA94;
		  /* 8224DA94h */ case    1:  		/* bl 24620 */
		/* 8224DA94h case    1:*/		regs.LR = 0x8224DA98; return 0x82253AC0;
		/* 8224DA94h case    1:*/		return 0x8224DA98;
	}
	return 0x8224DA98;
} // Block from 8224DA90h-8224DA98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224DA98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DA98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DA98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DA98);
		  /* 8224DA98h */ case    0:  		/* lwz R10, <#[R3]> */
		/* 8224DA98h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8224DA98h case    0:*/		return 0x8224DA9C;
		  /* 8224DA9Ch */ case    1:  		/* lwz R9, <#[R29 + 28]> */
		/* 8224DA9Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x0000001C) );
		/* 8224DA9Ch case    1:*/		return 0x8224DAA0;
		  /* 8224DAA0h */ case    2:  		/* lwz R11, <#[R31 + 32]> */
		/* 8224DAA0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8224DAA0h case    2:*/		return 0x8224DAA4;
		  /* 8224DAA4h */ case    3:  		/* lwz R10, <#[R10 + 12]> */
		/* 8224DAA4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 8224DAA4h case    3:*/		return 0x8224DAA8;
		  /* 8224DAA8h */ case    4:  		/* add R10, R10, R9 */
		/* 8224DAA8h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8224DAA8h case    4:*/		return 0x8224DAAC;
		  /* 8224DAACh */ case    5:  		/* cmpw CR6, R11, R10 */
		/* 8224DAACh case    5:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224DAACh case    5:*/		return 0x8224DAB0;
		  /* 8224DAB0h */ case    6:  		/* bc 4, CR6_LT, 56 */
		/* 8224DAB0h case    6:*/		if ( !regs.CR[6].lt ) { return 0x8224DAE8;  }
		/* 8224DAB0h case    6:*/		return 0x8224DAB4;
		  /* 8224DAB4h */ case    7:  		/* lwz R3, <#[R29 + 48]> */
		/* 8224DAB4h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000030) );
		/* 8224DAB4h case    7:*/		return 0x8224DAB8;
		  /* 8224DAB8h */ case    8:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224DAB8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224DAB8h case    8:*/		return 0x8224DABC;
		  /* 8224DABCh */ case    9:  		/* cmplw CR6, R30, R11 */
		/* 8224DABCh case    9:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8224DABCh case    9:*/		return 0x8224DAC0;
		  /* 8224DAC0h */ case   10:  		/* bc 4, CR6_LT, 16 */
		/* 8224DAC0h case   10:*/		if ( !regs.CR[6].lt ) { return 0x8224DAD0;  }
		/* 8224DAC0h case   10:*/		return 0x8224DAC4;
		  /* 8224DAC4h */ case   11:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224DAC4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224DAC4h case   11:*/		return 0x8224DAC8;
		  /* 8224DAC8h */ case   12:  		/* add R3, R11, R28 */
		/* 8224DAC8h case   12:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R28);
		/* 8224DAC8h case   12:*/		return 0x8224DACC;
		  /* 8224DACCh */ case   13:  		/* b 12 */
		/* 8224DACCh case   13:*/		return 0x8224DAD8;
		/* 8224DACCh case   13:*/		return 0x8224DAD0;
	}
	return 0x8224DAD0;
} // Block from 8224DA98h-8224DAD0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224DAD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DAD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DAD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DAD0);
		  /* 8224DAD0h */ case    0:  		/* mr R4, R30 */
		/* 8224DAD0h case    0:*/		regs.R4 = regs.R30;
		/* 8224DAD0h case    0:*/		return 0x8224DAD4;
		  /* 8224DAD4h */ case    1:  		/* bl 24556 */
		/* 8224DAD4h case    1:*/		regs.LR = 0x8224DAD8; return 0x82253AC0;
		/* 8224DAD4h case    1:*/		return 0x8224DAD8;
	}
	return 0x8224DAD8;
} // Block from 8224DAD0h-8224DAD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224DAD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DAD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DAD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DAD8);
		  /* 8224DAD8h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224DAD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224DAD8h case    0:*/		return 0x8224DADC;
		  /* 8224DADCh */ case    1:  		/* lwz R10, <#[R29 + 28]> */
		/* 8224DADCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000001C) );
		/* 8224DADCh case    1:*/		return 0x8224DAE0;
		  /* 8224DAE0h */ case    2:  		/* lwz R11, <#[R11 + 12]> */
		/* 8224DAE0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8224DAE0h case    2:*/		return 0x8224DAE4;
		  /* 8224DAE4h */ case    3:  		/* add R11, R11, R10 */
		/* 8224DAE4h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8224DAE4h case    3:*/		return 0x8224DAE8;
	}
	return 0x8224DAE8;
} // Block from 8224DAD8h-8224DAE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224DAE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DAE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DAE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DAE8);
		  /* 8224DAE8h */ case    0:  		/* lwz R10, <#[R31 + 36]> */
		/* 8224DAE8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000024) );
		/* 8224DAE8h case    0:*/		return 0x8224DAEC;
		  /* 8224DAECh */ case    1:  		/* stw R11, <#[R31 + 32]> */
		/* 8224DAECh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8224DAECh case    1:*/		return 0x8224DAF0;
		  /* 8224DAF0h */ case    2:  		/* cmpwi CR6, R10, 0 */
		/* 8224DAF0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8224DAF0h case    2:*/		return 0x8224DAF4;
		  /* 8224DAF4h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 8224DAF4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8224DB04;  }
		/* 8224DAF4h case    3:*/		return 0x8224DAF8;
		  /* 8224DAF8h */ case    4:  		/* mr R4, R31 */
		/* 8224DAF8h case    4:*/		regs.R4 = regs.R31;
		/* 8224DAF8h case    4:*/		return 0x8224DAFC;
		  /* 8224DAFCh */ case    5:  		/* mr R3, R26 */
		/* 8224DAFCh case    5:*/		regs.R3 = regs.R26;
		/* 8224DAFCh case    5:*/		return 0x8224DB00;
		  /* 8224DB00h */ case    6:  		/* bl -9520 */
		/* 8224DB00h case    6:*/		regs.LR = 0x8224DB04; return 0x8224B5D0;
		/* 8224DB00h case    6:*/		return 0x8224DB04;
	}
	return 0x8224DB04;
} // Block from 8224DAE8h-8224DB04h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224DB04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DB04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DB04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DB04);
		  /* 8224DB04h */ case    0:  		/* addi R30, R30, 1 */
		/* 8224DB04h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8224DB04h case    0:*/		return 0x8224DB08;
		  /* 8224DB08h */ case    1:  		/* addi R28, R28, 4 */
		/* 8224DB08h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 8224DB08h case    1:*/		return 0x8224DB0C;
		  /* 8224DB0Ch */ case    2:  		/* cmpw CR6, R30, R27 */
		/* 8224DB0Ch case    2:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R27);
		/* 8224DB0Ch case    2:*/		return 0x8224DB10;
		  /* 8224DB10h */ case    3:  		/* bc 12, CR6_LT, -212 */
		/* 8224DB10h case    3:*/		if ( regs.CR[6].lt ) { return 0x8224DA3C;  }
		/* 8224DB10h case    3:*/		return 0x8224DB14;
	}
	return 0x8224DB14;
} // Block from 8224DB04h-8224DB14h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224DB14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DB14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DB14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DB14);
		  /* 8224DB14h */ case    0:  		/* addi R1, R1, 144 */
		/* 8224DB14h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8224DB14h case    0:*/		return 0x8224DB18;
		  /* 8224DB18h */ case    1:  		/* b -1820792 */
		/* 8224DB18h case    1:*/		return 0x820912A0;
		/* 8224DB18h case    1:*/		return 0x8224DB1C;
		  /* 8224DB1Ch */ case    2:  		/* nop */
		/* 8224DB1Ch case    2:*/		cpu::op::nop();
		/* 8224DB1Ch case    2:*/		return 0x8224DB20;
	}
	return 0x8224DB20;
} // Block from 8224DB14h-8224DB20h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224DB20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DB20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DB20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DB20);
		  /* 8224DB20h */ case    0:  		/* mfspr R12, LR */
		/* 8224DB20h case    0:*/		regs.R12 = regs.LR;
		/* 8224DB20h case    0:*/		return 0x8224DB24;
		  /* 8224DB24h */ case    1:  		/* bl -1820876 */
		/* 8224DB24h case    1:*/		regs.LR = 0x8224DB28; return 0x82091258;
		/* 8224DB24h case    1:*/		return 0x8224DB28;
		  /* 8224DB28h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8224DB28h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8224DB28h case    2:*/		return 0x8224DB2C;
		  /* 8224DB2Ch */ case    3:  		/* mr R31, R3 */
		/* 8224DB2Ch case    3:*/		regs.R31 = regs.R3;
		/* 8224DB2Ch case    3:*/		return 0x8224DB30;
		  /* 8224DB30h */ case    4:  		/* lwz R3, <#[R3 + 8]> */
		/* 8224DB30h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000008) );
		/* 8224DB30h case    4:*/		return 0x8224DB34;
		  /* 8224DB34h */ case    5:  		/* lwz R11, <#[R3]> */
		/* 8224DB34h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224DB34h case    5:*/		return 0x8224DB38;
		  /* 8224DB38h */ case    6:  		/* lwz R11, <#[R11 + 12]> */
		/* 8224DB38h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8224DB38h case    6:*/		return 0x8224DB3C;
		  /* 8224DB3Ch */ case    7:  		/* mtspr CTR, R11 */
		/* 8224DB3Ch case    7:*/		regs.CTR = regs.R11;
		/* 8224DB3Ch case    7:*/		return 0x8224DB40;
		  /* 8224DB40h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 8224DB40h case    8:*/		if ( 1 ) { regs.LR = 0x8224DB44; return (uint32)regs.CTR; }
		/* 8224DB40h case    8:*/		return 0x8224DB44;
		  /* 8224DB44h */ case    9:  		/* lwz R11, <#[R31 + 28]> */
		/* 8224DB44h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 8224DB44h case    9:*/		return 0x8224DB48;
		  /* 8224DB48h */ case   10:  		/* lwz R10, <#[R31 + 24]> */
		/* 8224DB48h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 8224DB48h case   10:*/		return 0x8224DB4C;
		  /* 8224DB4Ch */ case   11:  		/* addi R11, R11, 1 */
		/* 8224DB4Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224DB4Ch case   11:*/		return 0x8224DB50;
		  /* 8224DB50h */ case   12:  		/* stw R11, <#[R31 + 28]> */
		/* 8224DB50h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 8224DB50h case   12:*/		return 0x8224DB54;
		  /* 8224DB54h */ case   13:  		/* lwz R10, <#[R10 + 4]> */
		/* 8224DB54h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8224DB54h case   13:*/		return 0x8224DB58;
		  /* 8224DB58h */ case   14:  		/* rlwinm R10, R10, 1, 0, 30 */
		/* 8224DB58h case   14:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R10);
		/* 8224DB58h case   14:*/		return 0x8224DB5C;
		  /* 8224DB5Ch */ case   15:  		/* cmpw CR6, R11, R10 */
		/* 8224DB5Ch case   15:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224DB5Ch case   15:*/		return 0x8224DB60;
		  /* 8224DB60h */ case   16:  		/* bc 4, CR6_GT, 40 */
		/* 8224DB60h case   16:*/		if ( !regs.CR[6].gt ) { return 0x8224DB88;  }
		/* 8224DB60h case   16:*/		return 0x8224DB64;
		  /* 8224DB64h */ case   17:  		/* lis R11, -32252 */
		/* 8224DB64h case   17:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224DB64h case   17:*/		return 0x8224DB68;
		  /* 8224DB68h */ case   18:  		/* lis R10, -32252 */
		/* 8224DB68h case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224DB68h case   18:*/		return 0x8224DB6C;
		  /* 8224DB6Ch */ case   19:  		/* lis R9, -32253 */
		/* 8224DB6Ch case   19:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8224DB6Ch case   19:*/		return 0x8224DB70;
		  /* 8224DB70h */ case   20:  		/* addi R6, R11, 14208 */
		/* 8224DB70h case   20:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x3780);
		/* 8224DB70h case   20:*/		return 0x8224DB74;
		  /* 8224DB74h */ case   21:  		/* addi R5, R10, 15324 */
		/* 8224DB74h case   21:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x3BDC);
		/* 8224DB74h case   21:*/		return 0x8224DB78;
		  /* 8224DB78h */ case   22:  		/* addi R4, R9, 27460 */
		/* 8224DB78h case   22:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8224DB78h case   22:*/		return 0x8224DB7C;
		  /* 8224DB7Ch */ case   23:  		/* li R7, 1739 */
		/* 8224DB7Ch case   23:*/		cpu::op::li<0>(regs,&regs.R7,0x6CB);
		/* 8224DB7Ch case   23:*/		return 0x8224DB80;
		  /* 8224DB80h */ case   24:  		/* li R3, 0 */
		/* 8224DB80h case   24:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224DB80h case   24:*/		return 0x8224DB84;
		  /* 8224DB84h */ case   25:  		/* bl -1007484 */
		/* 8224DB84h case   25:*/		regs.LR = 0x8224DB88; return 0x82157C08;
		/* 8224DB84h case   25:*/		return 0x8224DB88;
	}
	return 0x8224DB88;
} // Block from 8224DB20h-8224DB88h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8224DB88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DB88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DB88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DB88);
		  /* 8224DB88h */ case    0:  		/* lwz R11, <#[R31 + 24]> */
		/* 8224DB88h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8224DB88h case    0:*/		return 0x8224DB8C;
		  /* 8224DB8Ch */ case    1:  		/* lwz R10, <#[R31 + 28]> */
		/* 8224DB8Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 8224DB8Ch case    1:*/		return 0x8224DB90;
		  /* 8224DB90h */ case    2:  		/* lwz R11, <#[R11 + 4]> */
		/* 8224DB90h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8224DB90h case    2:*/		return 0x8224DB94;
		  /* 8224DB94h */ case    3:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 8224DB94h case    3:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 8224DB94h case    3:*/		return 0x8224DB98;
		  /* 8224DB98h */ case    4:  		/* cmpw CR6, R10, R11 */
		/* 8224DB98h case    4:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 8224DB98h case    4:*/		return 0x8224DB9C;
		  /* 8224DB9Ch */ case    5:  		/* bc 4, CR6_GT, 12 */
		/* 8224DB9Ch case    5:*/		if ( !regs.CR[6].gt ) { return 0x8224DBA8;  }
		/* 8224DB9Ch case    5:*/		return 0x8224DBA0;
		  /* 8224DBA0h */ case    6:  		/* li R11, 13 */
		/* 8224DBA0h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0xD);
		/* 8224DBA0h case    6:*/		return 0x8224DBA4;
		  /* 8224DBA4h */ case    7:  		/* stb R11, <#[R0]> */
		/* 8224DBA4h case    7:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R0 + 0x00000000) );
		/* 8224DBA4h case    7:*/		return 0x8224DBA8;
	}
	return 0x8224DBA8;
} // Block from 8224DB88h-8224DBA8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224DBA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DBA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DBA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DBA8);
		  /* 8224DBA8h */ case    0:  		/* lwz R11, <#[R31 + 44]> */
		/* 8224DBA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 8224DBA8h case    0:*/		return 0x8224DBAC;
		  /* 8224DBACh */ case    1:  		/* li R28, 0 */
		/* 8224DBACh case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8224DBACh case    1:*/		return 0x8224DBB0;
		  /* 8224DBB0h */ case    2:  		/* lwz R10, <#[R11 + 8]> */
		/* 8224DBB0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8224DBB0h case    2:*/		return 0x8224DBB4;
		  /* 8224DBB4h */ case    3:  		/* b 28 */
		/* 8224DBB4h case    3:*/		return 0x8224DBD0;
		/* 8224DBB4h case    3:*/		return 0x8224DBB8;
		  /* 8224DBB8h */ case    4:  		/* lwz R11, <#[R11 + 20]> */
		/* 8224DBB8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8224DBB8h case    4:*/		return 0x8224DBBC;
		  /* 8224DBBCh */ case    5:  		/* cmpw CR6, R28, R11 */
		/* 8224DBBCh case    5:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R11);
		/* 8224DBBCh case    5:*/		return 0x8224DBC0;
		  /* 8224DBC0h */ case    6:  		/* bc 4, CR6_LT, 8 */
		/* 8224DBC0h case    6:*/		if ( !regs.CR[6].lt ) { return 0x8224DBC8;  }
		/* 8224DBC0h case    6:*/		return 0x8224DBC4;
		  /* 8224DBC4h */ case    7:  		/* mr R28, R11 */
		/* 8224DBC4h case    7:*/		regs.R28 = regs.R11;
		/* 8224DBC4h case    7:*/		return 0x8224DBC8;
	}
	return 0x8224DBC8;
} // Block from 8224DBA8h-8224DBC8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224DBC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DBC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DBC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DBC8);
		  /* 8224DBC8h */ case    0:  		/* mr R11, R10 */
		/* 8224DBC8h case    0:*/		regs.R11 = regs.R10;
		/* 8224DBC8h case    0:*/		return 0x8224DBCC;
		  /* 8224DBCCh */ case    1:  		/* lwz R10, <#[R10 + 8]> */
		/* 8224DBCCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8224DBCCh case    1:*/		return 0x8224DBD0;
	}
	return 0x8224DBD0;
} // Block from 8224DBC8h-8224DBD0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224DBD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DBD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DBD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DBD0);
		  /* 8224DBD0h */ case    0:  		/* cmpwi CR6, R10, 0 */
		/* 8224DBD0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8224DBD0h case    0:*/		return 0x8224DBD4;
		  /* 8224DBD4h */ case    1:  		/* bc 4, CR6_EQ, -28 */
		/* 8224DBD4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8224DBB8;  }
		/* 8224DBD4h case    1:*/		return 0x8224DBD8;
		  /* 8224DBD8h */ case    2:  		/* lwz R30, <#[R31 + 92]> */
		/* 8224DBD8h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000005C) );
		/* 8224DBD8h case    2:*/		return 0x8224DBDC;
		  /* 8224DBDCh */ case    3:  		/* lwz R29, <#[R30 + 8]> */
		/* 8224DBDCh case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000008) );
		/* 8224DBDCh case    3:*/		return 0x8224DBE0;
		  /* 8224DBE0h */ case    4:  		/* b 48 */
		/* 8224DBE0h case    4:*/		return 0x8224DC10;
		/* 8224DBE0h case    4:*/		return 0x8224DBE4;
		  /* 8224DBE4h */ case    5:  		/* lwz R11, <#[R30 + 20]> */
		/* 8224DBE4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 8224DBE4h case    5:*/		return 0x8224DBE8;
		  /* 8224DBE8h */ case    6:  		/* cmpw CR6, R28, R11 */
		/* 8224DBE8h case    6:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R11);
		/* 8224DBE8h case    6:*/		return 0x8224DBEC;
		  /* 8224DBECh */ case    7:  		/* bc 4, CR6_LT, 8 */
		/* 8224DBECh case    7:*/		if ( !regs.CR[6].lt ) { return 0x8224DBF4;  }
		/* 8224DBECh case    7:*/		return 0x8224DBF0;
		  /* 8224DBF0h */ case    8:  		/* mr R28, R11 */
		/* 8224DBF0h case    8:*/		regs.R28 = regs.R11;
		/* 8224DBF0h case    8:*/		return 0x8224DBF4;
	}
	return 0x8224DBF4;
} // Block from 8224DBD0h-8224DBF4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224DBF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DBF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DBF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DBF4);
		  /* 8224DBF4h */ case    0:  		/* mr R3, R30 */
		/* 8224DBF4h case    0:*/		regs.R3 = regs.R30;
		/* 8224DBF4h case    0:*/		return 0x8224DBF8;
		  /* 8224DBF8h */ case    1:  		/* bl 23568 */
		/* 8224DBF8h case    1:*/		regs.LR = 0x8224DBFC; return 0x82253808;
		/* 8224DBF8h case    1:*/		return 0x8224DBFC;
		  /* 8224DBFCh */ case    2:  		/* mr R4, R30 */
		/* 8224DBFCh case    2:*/		regs.R4 = regs.R30;
		/* 8224DBFCh case    2:*/		return 0x8224DC00;
		  /* 8224DC00h */ case    3:  		/* mr R3, R31 */
		/* 8224DC00h case    3:*/		regs.R3 = regs.R31;
		/* 8224DC00h case    3:*/		return 0x8224DC04;
		  /* 8224DC04h */ case    4:  		/* bl -10212 */
		/* 8224DC04h case    4:*/		regs.LR = 0x8224DC08; return 0x8224B420;
		/* 8224DC04h case    4:*/		return 0x8224DC08;
		  /* 8224DC08h */ case    5:  		/* mr R30, R29 */
		/* 8224DC08h case    5:*/		regs.R30 = regs.R29;
		/* 8224DC08h case    5:*/		return 0x8224DC0C;
		  /* 8224DC0Ch */ case    6:  		/* lwz R29, <#[R29 + 8]> */
		/* 8224DC0Ch case    6:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000008) );
		/* 8224DC0Ch case    6:*/		return 0x8224DC10;
	}
	return 0x8224DC10;
} // Block from 8224DBF4h-8224DC10h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224DC10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DC10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DC10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DC10);
		  /* 8224DC10h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 8224DC10h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8224DC10h case    0:*/		return 0x8224DC14;
		  /* 8224DC14h */ case    1:  		/* bc 4, CR6_EQ, -48 */
		/* 8224DC14h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8224DBE4;  }
		/* 8224DC14h case    1:*/		return 0x8224DC18;
		  /* 8224DC18h */ case    2:  		/* lwz R30, <#[R31 + 68]> */
		/* 8224DC18h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000044) );
		/* 8224DC18h case    2:*/		return 0x8224DC1C;
		  /* 8224DC1Ch */ case    3:  		/* stw R28, <#[R31 + 108]> */
		/* 8224DC1Ch case    3:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x0000006C) );
		/* 8224DC1Ch case    3:*/		return 0x8224DC20;
		  /* 8224DC20h */ case    4:  		/* lwz R29, <#[R30 + 8]> */
		/* 8224DC20h case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000008) );
		/* 8224DC20h case    4:*/		return 0x8224DC24;
		  /* 8224DC24h */ case    5:  		/* b 68 */
		/* 8224DC24h case    5:*/		return 0x8224DC68;
		/* 8224DC24h case    5:*/		return 0x8224DC28;
		  /* 8224DC28h */ case    6:  		/* lwz R11, <#[R30 + 20]> */
		/* 8224DC28h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 8224DC28h case    6:*/		return 0x8224DC2C;
		  /* 8224DC2Ch */ case    7:  		/* cmpw CR6, R28, R11 */
		/* 8224DC2Ch case    7:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R11);
		/* 8224DC2Ch case    7:*/		return 0x8224DC30;
		  /* 8224DC30h */ case    8:  		/* bc 4, CR6_LT, 8 */
		/* 8224DC30h case    8:*/		if ( !regs.CR[6].lt ) { return 0x8224DC38;  }
		/* 8224DC30h case    8:*/		return 0x8224DC34;
		  /* 8224DC34h */ case    9:  		/* mr R28, R11 */
		/* 8224DC34h case    9:*/		regs.R28 = regs.R11;
		/* 8224DC34h case    9:*/		return 0x8224DC38;
	}
	return 0x8224DC38;
} // Block from 8224DC10h-8224DC38h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224DC38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DC38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DC38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DC38);
		  /* 8224DC38h */ case    0:  		/* mr R4, R30 */
		/* 8224DC38h case    0:*/		regs.R4 = regs.R30;
		/* 8224DC38h case    0:*/		return 0x8224DC3C;
		  /* 8224DC3Ch */ case    1:  		/* mr R3, R31 */
		/* 8224DC3Ch case    1:*/		regs.R3 = regs.R31;
		/* 8224DC3Ch case    1:*/		return 0x8224DC40;
		  /* 8224DC40h */ case    2:  		/* bl -10168 */
		/* 8224DC40h case    2:*/		regs.LR = 0x8224DC44; return 0x8224B488;
		/* 8224DC40h case    2:*/		return 0x8224DC44;
		  /* 8224DC44h */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224DC44h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224DC44h case    3:*/		return 0x8224DC48;
		  /* 8224DC48h */ case    4:  		/* bc 12, CR0_EQ, 24 */
		/* 8224DC48h case    4:*/		if ( regs.CR[0].eq ) { return 0x8224DC60;  }
		/* 8224DC48h case    4:*/		return 0x8224DC4C;
		  /* 8224DC4Ch */ case    5:  		/* mr R3, R30 */
		/* 8224DC4Ch case    5:*/		regs.R3 = regs.R30;
		/* 8224DC4Ch case    5:*/		return 0x8224DC50;
		  /* 8224DC50h */ case    6:  		/* bl 23480 */
		/* 8224DC50h case    6:*/		regs.LR = 0x8224DC54; return 0x82253808;
		/* 8224DC50h case    6:*/		return 0x8224DC54;
		  /* 8224DC54h */ case    7:  		/* mr R4, R30 */
		/* 8224DC54h case    7:*/		regs.R4 = regs.R30;
		/* 8224DC54h case    7:*/		return 0x8224DC58;
		  /* 8224DC58h */ case    8:  		/* mr R3, R31 */
		/* 8224DC58h case    8:*/		regs.R3 = regs.R31;
		/* 8224DC58h case    8:*/		return 0x8224DC5C;
		  /* 8224DC5Ch */ case    9:  		/* bl -10300 */
		/* 8224DC5Ch case    9:*/		regs.LR = 0x8224DC60; return 0x8224B420;
		/* 8224DC5Ch case    9:*/		return 0x8224DC60;
	}
	return 0x8224DC60;
} // Block from 8224DC38h-8224DC60h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224DC60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DC60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DC60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DC60);
		  /* 8224DC60h */ case    0:  		/* mr R30, R29 */
		/* 8224DC60h case    0:*/		regs.R30 = regs.R29;
		/* 8224DC60h case    0:*/		return 0x8224DC64;
		  /* 8224DC64h */ case    1:  		/* lwz R29, <#[R29 + 8]> */
		/* 8224DC64h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000008) );
		/* 8224DC64h case    1:*/		return 0x8224DC68;
	}
	return 0x8224DC68;
} // Block from 8224DC60h-8224DC68h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224DC68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DC68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DC68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DC68);
		  /* 8224DC68h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 8224DC68h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8224DC68h case    0:*/		return 0x8224DC6C;
		  /* 8224DC6Ch */ case    1:  		/* bc 4, CR6_EQ, -68 */
		/* 8224DC6Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8224DC28;  }
		/* 8224DC6Ch case    1:*/		return 0x8224DC70;
		  /* 8224DC70h */ case    2:  		/* stw R28, <#[R31 + 108]> */
		/* 8224DC70h case    2:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x0000006C) );
		/* 8224DC70h case    2:*/		return 0x8224DC74;
		  /* 8224DC74h */ case    3:  		/* addi R1, R1, 128 */
		/* 8224DC74h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8224DC74h case    3:*/		return 0x8224DC78;
		  /* 8224DC78h */ case    4:  		/* b -1821136 */
		/* 8224DC78h case    4:*/		return 0x820912A8;
		/* 8224DC78h case    4:*/		return 0x8224DC7C;
		  /* 8224DC7Ch */ case    5:  		/* nop */
		/* 8224DC7Ch case    5:*/		cpu::op::nop();
		/* 8224DC7Ch case    5:*/		return 0x8224DC80;
	}
	return 0x8224DC80;
} // Block from 8224DC68h-8224DC80h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224DC80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DC80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DC80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DC80);
		  /* 8224DC80h */ case    0:  		/* mfspr R12, LR */
		/* 8224DC80h case    0:*/		regs.R12 = regs.LR;
		/* 8224DC80h case    0:*/		return 0x8224DC84;
		  /* 8224DC84h */ case    1:  		/* bl -1821256 */
		/* 8224DC84h case    1:*/		regs.LR = 0x8224DC88; return 0x8209123C;
		/* 8224DC84h case    1:*/		return 0x8224DC88;
		  /* 8224DC88h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 8224DC88h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 8224DC88h case    2:*/		return 0x8224DC8C;
		  /* 8224DC8Ch */ case    3:  		/* lwz R9, <#[R4 + 52]> */
		/* 8224DC8Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000034) );
		/* 8224DC8Ch case    3:*/		return 0x8224DC90;
		  /* 8224DC90h */ case    4:  		/* lis R11, -32253 */
		/* 8224DC90h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8224DC90h case    4:*/		return 0x8224DC94;
		  /* 8224DC94h */ case    5:  		/* lis R10, -32252 */
		/* 8224DC94h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224DC94h case    5:*/		return 0x8224DC98;
		  /* 8224DC98h */ case    6:  		/* mr R22, R3 */
		/* 8224DC98h case    6:*/		regs.R22 = regs.R3;
		/* 8224DC98h case    6:*/		return 0x8224DC9C;
		  /* 8224DC9Ch */ case    7:  		/* mr R28, R4 */
		/* 8224DC9Ch case    7:*/		regs.R28 = regs.R4;
		/* 8224DC9Ch case    7:*/		return 0x8224DCA0;
		  /* 8224DCA0h */ case    8:  		/* li R21, 1 */
		/* 8224DCA0h case    8:*/		cpu::op::li<0>(regs,&regs.R21,0x1);
		/* 8224DCA0h case    8:*/		return 0x8224DCA4;
		  /* 8224DCA4h */ case    9:  		/* lwz R26, <#[R9 + 4]> */
		/* 8224DCA4h case    9:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R9 + 0x00000004) );
		/* 8224DCA4h case    9:*/		return 0x8224DCA8;
		  /* 8224DCA8h */ case   10:  		/* li R29, 0 */
		/* 8224DCA8h case   10:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8224DCA8h case   10:*/		return 0x8224DCAC;
		  /* 8224DCACh */ case   11:  		/* addi R24, R11, 27460 */
		/* 8224DCACh case   11:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x6B44);
		/* 8224DCACh case   11:*/		return 0x8224DCB0;
		  /* 8224DCB0h */ case   12:  		/* addi R23, R10, 14208 */
		/* 8224DCB0h case   12:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R10,0x3780);
		/* 8224DCB0h case   12:*/		return 0x8224DCB4;
		  /* 8224DCB4h */ case   13:  		/* cmpwi CR6, R26, 0 */
		/* 8224DCB4h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 8224DCB4h case   13:*/		return 0x8224DCB8;
		  /* 8224DCB8h */ case   14:  		/* bc 4, CR6_GT, 244 */
		/* 8224DCB8h case   14:*/		if ( !regs.CR[6].gt ) { return 0x8224DDAC;  }
		/* 8224DCB8h case   14:*/		return 0x8224DCBC;
		  /* 8224DCBCh */ case   15:  		/* lis R11, -32252 */
		/* 8224DCBCh case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224DCBCh case   15:*/		return 0x8224DCC0;
		  /* 8224DCC0h */ case   16:  		/* li R27, 0 */
		/* 8224DCC0h case   16:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8224DCC0h case   16:*/		return 0x8224DCC4;
		  /* 8224DCC4h */ case   17:  		/* addi R25, R11, 15380 */
		/* 8224DCC4h case   17:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R11,0x3C14);
		/* 8224DCC4h case   17:*/		return 0x8224DCC8;
		  /* 8224DCC8h */ case   18:  		/* lwz R3, <#[R28 + 52]> */
		/* 8224DCC8h case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000034) );
		/* 8224DCC8h case   18:*/		return 0x8224DCCC;
		  /* 8224DCCCh */ case   19:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224DCCCh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224DCCCh case   19:*/		return 0x8224DCD0;
		  /* 8224DCD0h */ case   20:  		/* cmplw CR6, R29, R11 */
		/* 8224DCD0h case   20:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8224DCD0h case   20:*/		return 0x8224DCD4;
		  /* 8224DCD4h */ case   21:  		/* bc 4, CR6_LT, 16 */
		/* 8224DCD4h case   21:*/		if ( !regs.CR[6].lt ) { return 0x8224DCE4;  }
		/* 8224DCD4h case   21:*/		return 0x8224DCD8;
		  /* 8224DCD8h */ case   22:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224DCD8h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224DCD8h case   22:*/		return 0x8224DCDC;
		  /* 8224DCDCh */ case   23:  		/* add R3, R11, R27 */
		/* 8224DCDCh case   23:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R27);
		/* 8224DCDCh case   23:*/		return 0x8224DCE0;
		  /* 8224DCE0h */ case   24:  		/* b 12 */
		/* 8224DCE0h case   24:*/		return 0x8224DCEC;
		/* 8224DCE0h case   24:*/		return 0x8224DCE4;
	}
	return 0x8224DCE4;
} // Block from 8224DC80h-8224DCE4h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8224DCE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DCE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DCE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DCE4);
		  /* 8224DCE4h */ case    0:  		/* mr R4, R29 */
		/* 8224DCE4h case    0:*/		regs.R4 = regs.R29;
		/* 8224DCE4h case    0:*/		return 0x8224DCE8;
		  /* 8224DCE8h */ case    1:  		/* bl 24024 */
		/* 8224DCE8h case    1:*/		regs.LR = 0x8224DCEC; return 0x82253AC0;
		/* 8224DCE8h case    1:*/		return 0x8224DCEC;
	}
	return 0x8224DCEC;
} // Block from 8224DCE4h-8224DCECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224DCECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DCEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DCEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DCEC);
		  /* 8224DCECh */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224DCECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224DCECh case    0:*/		return 0x8224DCF0;
		  /* 8224DCF0h */ case    1:  		/* lwz R11, <#[R11 + 8]> */
		/* 8224DCF0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8224DCF0h case    1:*/		return 0x8224DCF4;
		  /* 8224DCF4h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 8224DCF4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224DCF4h case    2:*/		return 0x8224DCF8;
		  /* 8224DCF8h */ case    3:  		/* bc 4, CR6_EQ, 164 */
		/* 8224DCF8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8224DD9C;  }
		/* 8224DCF8h case    3:*/		return 0x8224DCFC;
		  /* 8224DCFCh */ case    4:  		/* lwz R3, <#[R28 + 52]> */
		/* 8224DCFCh case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000034) );
		/* 8224DCFCh case    4:*/		return 0x8224DD00;
		  /* 8224DD00h */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224DD00h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224DD00h case    5:*/		return 0x8224DD04;
		  /* 8224DD04h */ case    6:  		/* cmplw CR6, R29, R11 */
		/* 8224DD04h case    6:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8224DD04h case    6:*/		return 0x8224DD08;
		  /* 8224DD08h */ case    7:  		/* bc 4, CR6_LT, 16 */
		/* 8224DD08h case    7:*/		if ( !regs.CR[6].lt ) { return 0x8224DD18;  }
		/* 8224DD08h case    7:*/		return 0x8224DD0C;
		  /* 8224DD0Ch */ case    8:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224DD0Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224DD0Ch case    8:*/		return 0x8224DD10;
		  /* 8224DD10h */ case    9:  		/* add R3, R11, R27 */
		/* 8224DD10h case    9:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R27);
		/* 8224DD10h case    9:*/		return 0x8224DD14;
		  /* 8224DD14h */ case   10:  		/* b 12 */
		/* 8224DD14h case   10:*/		return 0x8224DD20;
		/* 8224DD14h case   10:*/		return 0x8224DD18;
	}
	return 0x8224DD18;
} // Block from 8224DCECh-8224DD18h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224DD18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DD18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DD18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DD18);
		  /* 8224DD18h */ case    0:  		/* mr R4, R29 */
		/* 8224DD18h case    0:*/		regs.R4 = regs.R29;
		/* 8224DD18h case    0:*/		return 0x8224DD1C;
		  /* 8224DD1Ch */ case    1:  		/* bl 23972 */
		/* 8224DD1Ch case    1:*/		regs.LR = 0x8224DD20; return 0x82253AC0;
		/* 8224DD1Ch case    1:*/		return 0x8224DD20;
	}
	return 0x8224DD20;
} // Block from 8224DD18h-8224DD20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224DD20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DD20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DD20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DD20);
		  /* 8224DD20h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224DD20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224DD20h case    0:*/		return 0x8224DD24;
		  /* 8224DD24h */ case    1:  		/* lwz R11, <#[R11]> */
		/* 8224DD24h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8224DD24h case    1:*/		return 0x8224DD28;
		  /* 8224DD28h */ case    2:  		/* lwz R10, <#[R11 + 60]> */
		/* 8224DD28h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000003C) );
		/* 8224DD28h case    2:*/		return 0x8224DD2C;
		  /* 8224DD2Ch */ case    3:  		/* addic. R10, R10, -1 */
		/* 8224DD2Ch case    3:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8224DD2Ch case    3:*/		return 0x8224DD30;
		  /* 8224DD30h */ case    4:  		/* stw R10, <#[R11 + 60]> */
		/* 8224DD30h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000003C) );
		/* 8224DD30h case    4:*/		return 0x8224DD34;
		  /* 8224DD34h */ case    5:  		/* bc 4, CR0_EQ, 104 */
		/* 8224DD34h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8224DD9C;  }
		/* 8224DD34h case    5:*/		return 0x8224DD38;
		  /* 8224DD38h */ case    6:  		/* lwz R11, <#[R11 + 40]> */
		/* 8224DD38h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8224DD38h case    6:*/		return 0x8224DD3C;
		  /* 8224DD3Ch */ case    7:  		/* lwz R10, <#[R11 + 228]> */
		/* 8224DD3Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 8224DD3Ch case    7:*/		return 0x8224DD40;
		  /* 8224DD40h */ case    8:  		/* rlwinm. R10, R10, 26, 31, 31 */
		/* 8224DD40h case    8:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R10,regs.R10);
		/* 8224DD40h case    8:*/		return 0x8224DD44;
		  /* 8224DD44h */ case    9:  		/* bc 12, CR0_EQ, 88 */
		/* 8224DD44h case    9:*/		if ( regs.CR[0].eq ) { return 0x8224DD9C;  }
		/* 8224DD44h case    9:*/		return 0x8224DD48;
		  /* 8224DD48h */ case   10:  		/* lwz R10, <#[R11 + 56]> */
		/* 8224DD48h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000038) );
		/* 8224DD48h case   10:*/		return 0x8224DD4C;
		  /* 8224DD4Ch */ case   11:  		/* lwz R9, <#[R22 + 116]> */
		/* 8224DD4Ch case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R22 + 0x00000074) );
		/* 8224DD4Ch case   11:*/		return 0x8224DD50;
		  /* 8224DD50h */ case   12:  		/* rlwinm R11, R10, 27, 5, 31 */
		/* 8224DD50h case   12:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R10);
		/* 8224DD50h case   12:*/		return 0x8224DD54;
		  /* 8224DD54h */ case   13:  		/* rlwinm R30, R10, 0, 27, 31 */
		/* 8224DD54h case   13:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R30,regs.R10);
		/* 8224DD54h case   13:*/		return 0x8224DD58;
		  /* 8224DD58h */ case   14:  		/* addi R11, R11, 2 */
		/* 8224DD58h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8224DD58h case   14:*/		return 0x8224DD5C;
		  /* 8224DD5Ch */ case   15:  		/* rlwinm R31, R11, 2, 0, 29 */
		/* 8224DD5Ch case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R11);
		/* 8224DD5Ch case   15:*/		return 0x8224DD60;
		  /* 8224DD60h */ case   16:  		/* lwzx R11, <#[R31 + R9]> */
		/* 8224DD60h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R9 + 0x00000000) );
		/* 8224DD60h case   16:*/		return 0x8224DD64;
		  /* 8224DD64h */ case   17:  		/* srw R11, R11, R30 */
		/* 8224DD64h case   17:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8224DD64h case   17:*/		return 0x8224DD68;
		  /* 8224DD68h */ case   18:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8224DD68h case   18:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8224DD68h case   18:*/		return 0x8224DD6C;
		  /* 8224DD6Ch */ case   19:  		/* bc 4, CR0_EQ, 28 */
		/* 8224DD6Ch case   19:*/		if ( !regs.CR[0].eq ) { return 0x8224DD88;  }
		/* 8224DD6Ch case   19:*/		return 0x8224DD70;
		  /* 8224DD70h */ case   20:  		/* mr R6, R23 */
		/* 8224DD70h case   20:*/		regs.R6 = regs.R23;
		/* 8224DD70h case   20:*/		return 0x8224DD74;
		  /* 8224DD74h */ case   21:  		/* mr R5, R25 */
		/* 8224DD74h case   21:*/		regs.R5 = regs.R25;
		/* 8224DD74h case   21:*/		return 0x8224DD78;
		  /* 8224DD78h */ case   22:  		/* mr R4, R24 */
		/* 8224DD78h case   22:*/		regs.R4 = regs.R24;
		/* 8224DD78h case   22:*/		return 0x8224DD7C;
		  /* 8224DD7Ch */ case   23:  		/* li R7, 1837 */
		/* 8224DD7Ch case   23:*/		cpu::op::li<0>(regs,&regs.R7,0x72D);
		/* 8224DD7Ch case   23:*/		return 0x8224DD80;
		  /* 8224DD80h */ case   24:  		/* li R3, 0 */
		/* 8224DD80h case   24:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224DD80h case   24:*/		return 0x8224DD84;
		  /* 8224DD84h */ case   25:  		/* bl -1007996 */
		/* 8224DD84h case   25:*/		regs.LR = 0x8224DD88; return 0x82157C08;
		/* 8224DD84h case   25:*/		return 0x8224DD88;
	}
	return 0x8224DD88;
} // Block from 8224DD20h-8224DD88h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8224DD88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DD88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DD88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DD88);
		  /* 8224DD88h */ case    0:  		/* lwz R11, <#[R22 + 116]> */
		/* 8224DD88h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000074) );
		/* 8224DD88h case    0:*/		return 0x8224DD8C;
		  /* 8224DD8Ch */ case    1:  		/* slw R10, R21, R30 */
		/* 8224DD8Ch case    1:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R21,regs.R30);
		/* 8224DD8Ch case    1:*/		return 0x8224DD90;
		  /* 8224DD90h */ case    2:  		/* lwzx R9, <#[R31 + R11]> */
		/* 8224DD90h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8224DD90h case    2:*/		return 0x8224DD94;
		  /* 8224DD94h */ case    3:  		/* andc R10, R9, R10 */
		/* 8224DD94h case    3:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8224DD94h case    3:*/		return 0x8224DD98;
		  /* 8224DD98h */ case    4:  		/* stwx R10, <#[R31 + R11]> */
		/* 8224DD98h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8224DD98h case    4:*/		return 0x8224DD9C;
	}
	return 0x8224DD9C;
} // Block from 8224DD88h-8224DD9Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224DD9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DD9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DD9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DD9C);
		  /* 8224DD9Ch */ case    0:  		/* addi R29, R29, 1 */
		/* 8224DD9Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8224DD9Ch case    0:*/		return 0x8224DDA0;
		  /* 8224DDA0h */ case    1:  		/* addi R27, R27, 4 */
		/* 8224DDA0h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 8224DDA0h case    1:*/		return 0x8224DDA4;
		  /* 8224DDA4h */ case    2:  		/* cmpw CR6, R29, R26 */
		/* 8224DDA4h case    2:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R26);
		/* 8224DDA4h case    2:*/		return 0x8224DDA8;
		  /* 8224DDA8h */ case    3:  		/* bc 12, CR6_LT, -224 */
		/* 8224DDA8h case    3:*/		if ( regs.CR[6].lt ) { return 0x8224DCC8;  }
		/* 8224DDA8h case    3:*/		return 0x8224DDAC;
	}
	return 0x8224DDAC;
} // Block from 8224DD9Ch-8224DDACh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224DDACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DDAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DDAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DDAC);
		  /* 8224DDACh */ case    0:  		/* lwz R11, <#[R22 + 120]> */
		/* 8224DDACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000078) );
		/* 8224DDACh case    0:*/		return 0x8224DDB0;
		  /* 8224DDB0h */ case    1:  		/* b 8 */
		/* 8224DDB0h case    1:*/		return 0x8224DDB8;
		/* 8224DDB0h case    1:*/		return 0x8224DDB4;
		  /* 8224DDB4h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 8224DDB4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8224DDB4h case    2:*/		return 0x8224DDB8;
	}
	return 0x8224DDB8;
} // Block from 8224DDACh-8224DDB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224DDB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DDB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DDB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DDB8);
		  /* 8224DDB8h */ case    0:  		/* addi R11, R11, 64 */
		/* 8224DDB8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x40);
		/* 8224DDB8h case    0:*/		return 0x8224DDBC;
		  /* 8224DDBCh */ case    1:  		/* lwz R10, <#[R11]> */
		/* 8224DDBCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8224DDBCh case    1:*/		return 0x8224DDC0;
		  /* 8224DDC0h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 8224DDC0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8224DDC0h case    2:*/		return 0x8224DDC4;
		  /* 8224DDC4h */ case    3:  		/* bc 4, CR6_EQ, -16 */
		/* 8224DDC4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8224DDB4;  }
		/* 8224DDC4h case    3:*/		return 0x8224DDC8;
		  /* 8224DDC8h */ case    4:  		/* stw R28, <#[R11]> */
		/* 8224DDC8h case    4:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 8224DDC8h case    4:*/		return 0x8224DDCC;
		  /* 8224DDCCh */ case    5:  		/* lwz R4, <#[R28 + 40]> */
		/* 8224DDCCh case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000028) );
		/* 8224DDCCh case    5:*/		return 0x8224DDD0;
		  /* 8224DDD0h */ case    6:  		/* lwz R3, <#[R22 + 8]> */
		/* 8224DDD0h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000008) );
		/* 8224DDD0h case    6:*/		return 0x8224DDD4;
		  /* 8224DDD4h */ case    7:  		/* bl 101836 */
		/* 8224DDD4h case    7:*/		regs.LR = 0x8224DDD8; return 0x82266BA0;
		/* 8224DDD4h case    7:*/		return 0x8224DDD8;
		  /* 8224DDD8h */ case    8:  		/* lwz R11, <#[R22 + 120]> */
		/* 8224DDD8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000078) );
		/* 8224DDD8h case    8:*/		return 0x8224DDDC;
		  /* 8224DDDCh */ case    9:  		/* lwz R11, <#[R11 + 28]> */
		/* 8224DDDCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8224DDDCh case    9:*/		return 0x8224DDE0;
		  /* 8224DDE0h */ case   10:  		/* lwz R10, <#[R28 + 40]> */
		/* 8224DDE0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000028) );
		/* 8224DDE0h case   10:*/		return 0x8224DDE4;
		  /* 8224DDE4h */ case   11:  		/* stw R11, <#[R28 + 32]> */
		/* 8224DDE4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000020) );
		/* 8224DDE4h case   11:*/		return 0x8224DDE8;
		  /* 8224DDE8h */ case   12:  		/* stw R11, <#[R28 + 28]> */
		/* 8224DDE8h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x0000001C) );
		/* 8224DDE8h case   12:*/		return 0x8224DDEC;
		  /* 8224DDECh */ case   13:  		/* lwz R27, <#[R10 + 172]> */
		/* 8224DDECh case   13:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R10 + 0x000000AC) );
		/* 8224DDECh case   13:*/		return 0x8224DDF0;
		  /* 8224DDF0h */ case   14:  		/* cmplwi CR6, R27, 0 */
		/* 8224DDF0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8224DDF0h case   14:*/		return 0x8224DDF4;
		  /* 8224DDF4h */ case   15:  		/* bc 4, CR6_EQ, 32 */
		/* 8224DDF4h case   15:*/		if ( !regs.CR[6].eq ) { return 0x8224DE14;  }
		/* 8224DDF4h case   15:*/		return 0x8224DDF8;
		  /* 8224DDF8h */ case   16:  		/* lis R11, -32252 */
		/* 8224DDF8h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224DDF8h case   16:*/		return 0x8224DDFC;
		  /* 8224DDFCh */ case   17:  		/* mr R6, R23 */
		/* 8224DDFCh case   17:*/		regs.R6 = regs.R23;
		/* 8224DDFCh case   17:*/		return 0x8224DE00;
		  /* 8224DE00h */ case   18:  		/* addi R5, R11, 15368 */
		/* 8224DE00h case   18:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3C08);
		/* 8224DE00h case   18:*/		return 0x8224DE04;
		  /* 8224DE04h */ case   19:  		/* mr R4, R24 */
		/* 8224DE04h case   19:*/		regs.R4 = regs.R24;
		/* 8224DE04h case   19:*/		return 0x8224DE08;
		  /* 8224DE08h */ case   20:  		/* li R7, 1854 */
		/* 8224DE08h case   20:*/		cpu::op::li<0>(regs,&regs.R7,0x73E);
		/* 8224DE08h case   20:*/		return 0x8224DE0C;
		  /* 8224DE0Ch */ case   21:  		/* li R3, 0 */
		/* 8224DE0Ch case   21:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224DE0Ch case   21:*/		return 0x8224DE10;
		  /* 8224DE10h */ case   22:  		/* bl -1008136 */
		/* 8224DE10h case   22:*/		regs.LR = 0x8224DE14; return 0x82157C08;
		/* 8224DE10h case   22:*/		return 0x8224DE14;
	}
	return 0x8224DE14;
} // Block from 8224DDB8h-8224DE14h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8224DE14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DE14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DE14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DE14);
		  /* 8224DE14h */ case    0:  		/* lwz R11, <#[R22 + 120]> */
		/* 8224DE14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000078) );
		/* 8224DE14h case    0:*/		return 0x8224DE18;
		  /* 8224DE18h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8224DE18h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8224DE18h case    1:*/		return 0x8224DE1C;
		  /* 8224DE1Ch */ case    2:  		/* lwz R10, <#[R11 + 172]> */
		/* 8224DE1Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000AC) );
		/* 8224DE1Ch case    2:*/		return 0x8224DE20;
		  /* 8224DE20h */ case    3:  		/* lwz R11, <#[R10 + 56]> */
		/* 8224DE20h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000038) );
		/* 8224DE20h case    3:*/		return 0x8224DE24;
		  /* 8224DE24h */ case    4:  		/* lwz R9, <#[R10 + 80]> */
		/* 8224DE24h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000050) );
		/* 8224DE24h case    4:*/		return 0x8224DE28;
		  /* 8224DE28h */ case    5:  		/* stw R11, <#[R27 + 56]> */
		/* 8224DE28h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000038) );
		/* 8224DE28h case    5:*/		return 0x8224DE2C;
		  /* 8224DE2Ch */ case    6:  		/* stw R9, <#[R27 + 80]> */
		/* 8224DE2Ch case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R27 + 0x00000050) );
		/* 8224DE2Ch case    6:*/		return 0x8224DE30;
		  /* 8224DE30h */ case    7:  		/* lwz R10, <#[R10 + 228]> */
		/* 8224DE30h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x000000E4) );
		/* 8224DE30h case    7:*/		return 0x8224DE34;
		  /* 8224DE34h */ case    8:  		/* rlwinm. R10, R10, 26, 31, 31 */
		/* 8224DE34h case    8:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R10,regs.R10);
		/* 8224DE34h case    8:*/		return 0x8224DE38;
		  /* 8224DE38h */ case    9:  		/* bc 12, CR0_EQ, 52 */
		/* 8224DE38h case    9:*/		if ( regs.CR[0].eq ) { return 0x8224DE6C;  }
		/* 8224DE38h case    9:*/		return 0x8224DE3C;
		  /* 8224DE3Ch */ case   10:  		/* rlwinm R9, R11, 27, 5, 31 */
		/* 8224DE3Ch case   10:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R9,regs.R11);
		/* 8224DE3Ch case   10:*/		return 0x8224DE40;
		  /* 8224DE40h */ case   11:  		/* lwz R10, <#[R22 + 116]> */
		/* 8224DE40h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000074) );
		/* 8224DE40h case   11:*/		return 0x8224DE44;
		  /* 8224DE44h */ case   12:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8224DE44h case   12:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8224DE44h case   12:*/		return 0x8224DE48;
		  /* 8224DE48h */ case   13:  		/* addi R9, R9, 2 */
		/* 8224DE48h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x2);
		/* 8224DE48h case   13:*/		return 0x8224DE4C;
		  /* 8224DE4Ch */ case   14:  		/* slw R8, R21, R11 */
		/* 8224DE4Ch case   14:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R21,regs.R11);
		/* 8224DE4Ch case   14:*/		return 0x8224DE50;
		  /* 8224DE50h */ case   15:  		/* rlwinm R11, R9, 2, 0, 29 */
		/* 8224DE50h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R9);
		/* 8224DE50h case   15:*/		return 0x8224DE54;
		  /* 8224DE54h */ case   16:  		/* lwzx R9, <#[R11 + R10]> */
		/* 8224DE54h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8224DE54h case   16:*/		return 0x8224DE58;
		  /* 8224DE58h */ case   17:  		/* or R9, R8, R9 */
		/* 8224DE58h case   17:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8224DE58h case   17:*/		return 0x8224DE5C;
		  /* 8224DE5Ch */ case   18:  		/* stwx R9, <#[R11 + R10]> */
		/* 8224DE5Ch case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8224DE5Ch case   18:*/		return 0x8224DE60;
		  /* 8224DE60h */ case   19:  		/* lwz R11, <#[R27 + 228]> */
		/* 8224DE60h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x000000E4) );
		/* 8224DE60h case   19:*/		return 0x8224DE64;
		  /* 8224DE64h */ case   20:  		/* ori R11, R11, 64 */
		/* 8224DE64h case   20:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 8224DE64h case   20:*/		return 0x8224DE68;
		  /* 8224DE68h */ case   21:  		/* stw R11, <#[R27 + 228]> */
		/* 8224DE68h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x000000E4) );
		/* 8224DE68h case   21:*/		return 0x8224DE6C;
	}
	return 0x8224DE6C;
} // Block from 8224DE14h-8224DE6Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 8224DE6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DE6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DE6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DE6C);
		  /* 8224DE6Ch */ case    0:  		/* lwz R11, <#[R28 + 48]> */
		/* 8224DE6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000030) );
		/* 8224DE6Ch case    0:*/		return 0x8224DE70;
		  /* 8224DE70h */ case    1:  		/* li R30, 0 */
		/* 8224DE70h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8224DE70h case    1:*/		return 0x8224DE74;
		  /* 8224DE74h */ case    2:  		/* lwz R26, <#[R11 + 4]> */
		/* 8224DE74h case    2:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x00000004) );
		/* 8224DE74h case    2:*/		return 0x8224DE78;
		  /* 8224DE78h */ case    3:  		/* cmpwi CR6, R26, 0 */
		/* 8224DE78h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 8224DE78h case    3:*/		return 0x8224DE7C;
		  /* 8224DE7Ch */ case    4:  		/* bc 4, CR6_GT, 296 */
		/* 8224DE7Ch case    4:*/		if ( !regs.CR[6].gt ) { return 0x8224DFA4;  }
		/* 8224DE7Ch case    4:*/		return 0x8224DE80;
		  /* 8224DE80h */ case    5:  		/* li R29, 0 */
		/* 8224DE80h case    5:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8224DE80h case    5:*/		return 0x8224DE84;
		  /* 8224DE84h */ case    6:  		/* lwz R3, <#[R28 + 48]> */
		/* 8224DE84h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000030) );
		/* 8224DE84h case    6:*/		return 0x8224DE88;
		  /* 8224DE88h */ case    7:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224DE88h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224DE88h case    7:*/		return 0x8224DE8C;
		  /* 8224DE8Ch */ case    8:  		/* cmplw CR6, R30, R11 */
		/* 8224DE8Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8224DE8Ch case    8:*/		return 0x8224DE90;
		  /* 8224DE90h */ case    9:  		/* bc 4, CR6_LT, 16 */
		/* 8224DE90h case    9:*/		if ( !regs.CR[6].lt ) { return 0x8224DEA0;  }
		/* 8224DE90h case    9:*/		return 0x8224DE94;
		  /* 8224DE94h */ case   10:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224DE94h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224DE94h case   10:*/		return 0x8224DE98;
		  /* 8224DE98h */ case   11:  		/* add R3, R11, R29 */
		/* 8224DE98h case   11:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 8224DE98h case   11:*/		return 0x8224DE9C;
		  /* 8224DE9Ch */ case   12:  		/* b 12 */
		/* 8224DE9Ch case   12:*/		return 0x8224DEA8;
		/* 8224DE9Ch case   12:*/		return 0x8224DEA0;
	}
	return 0x8224DEA0;
} // Block from 8224DE6Ch-8224DEA0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224DEA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DEA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DEA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DEA0);
		  /* 8224DEA0h */ case    0:  		/* mr R4, R30 */
		/* 8224DEA0h case    0:*/		regs.R4 = regs.R30;
		/* 8224DEA0h case    0:*/		return 0x8224DEA4;
		  /* 8224DEA4h */ case    1:  		/* bl 23580 */
		/* 8224DEA4h case    1:*/		regs.LR = 0x8224DEA8; return 0x82253AC0;
		/* 8224DEA4h case    1:*/		return 0x8224DEA8;
	}
	return 0x8224DEA8;
} // Block from 8224DEA0h-8224DEA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224DEA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DEA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DEA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DEA8);
		  /* 8224DEA8h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224DEA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224DEA8h case    0:*/		return 0x8224DEAC;
		  /* 8224DEACh */ case    1:  		/* lwz R31, <#[R11 + 4]> */
		/* 8224DEACh case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 8224DEACh case    1:*/		return 0x8224DEB0;
		  /* 8224DEB0h */ case    2:  		/* lwz R11, <#[R31 + 36]> */
		/* 8224DEB0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 8224DEB0h case    2:*/		return 0x8224DEB4;
		  /* 8224DEB4h */ case    3:  		/* addi R11, R11, -1 */
		/* 8224DEB4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8224DEB4h case    3:*/		return 0x8224DEB8;
		  /* 8224DEB8h */ case    4:  		/* stw R11, <#[R31 + 36]> */
		/* 8224DEB8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 8224DEB8h case    4:*/		return 0x8224DEBC;
		  /* 8224DEBCh */ case    5:  		/* lwz R3, <#[R28 + 48]> */
		/* 8224DEBCh case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000030) );
		/* 8224DEBCh case    5:*/		return 0x8224DEC0;
		  /* 8224DEC0h */ case    6:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224DEC0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224DEC0h case    6:*/		return 0x8224DEC4;
		  /* 8224DEC4h */ case    7:  		/* cmplw CR6, R30, R11 */
		/* 8224DEC4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8224DEC4h case    7:*/		return 0x8224DEC8;
		  /* 8224DEC8h */ case    8:  		/* bc 4, CR6_LT, 16 */
		/* 8224DEC8h case    8:*/		if ( !regs.CR[6].lt ) { return 0x8224DED8;  }
		/* 8224DEC8h case    8:*/		return 0x8224DECC;
		  /* 8224DECCh */ case    9:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224DECCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224DECCh case    9:*/		return 0x8224DED0;
		  /* 8224DED0h */ case   10:  		/* add R3, R11, R29 */
		/* 8224DED0h case   10:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 8224DED0h case   10:*/		return 0x8224DED4;
		  /* 8224DED4h */ case   11:  		/* b 12 */
		/* 8224DED4h case   11:*/		return 0x8224DEE0;
		/* 8224DED4h case   11:*/		return 0x8224DED8;
	}
	return 0x8224DED8;
} // Block from 8224DEA8h-8224DED8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224DED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DED8);
		  /* 8224DED8h */ case    0:  		/* mr R4, R30 */
		/* 8224DED8h case    0:*/		regs.R4 = regs.R30;
		/* 8224DED8h case    0:*/		return 0x8224DEDC;
		  /* 8224DEDCh */ case    1:  		/* bl 23524 */
		/* 8224DEDCh case    1:*/		regs.LR = 0x8224DEE0; return 0x82253AC0;
		/* 8224DEDCh case    1:*/		return 0x8224DEE0;
	}
	return 0x8224DEE0;
} // Block from 8224DED8h-8224DEE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224DEE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DEE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DEE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DEE0);
		  /* 8224DEE0h */ case    0:  		/* lwz R10, <#[R3]> */
		/* 8224DEE0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8224DEE0h case    0:*/		return 0x8224DEE4;
		  /* 8224DEE4h */ case    1:  		/* lwz R9, <#[R28 + 28]> */
		/* 8224DEE4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x0000001C) );
		/* 8224DEE4h case    1:*/		return 0x8224DEE8;
		  /* 8224DEE8h */ case    2:  		/* lwz R11, <#[R31 + 32]> */
		/* 8224DEE8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8224DEE8h case    2:*/		return 0x8224DEEC;
		  /* 8224DEECh */ case    3:  		/* lwz R10, <#[R10 + 12]> */
		/* 8224DEECh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 8224DEECh case    3:*/		return 0x8224DEF0;
		  /* 8224DEF0h */ case    4:  		/* add R10, R10, R9 */
		/* 8224DEF0h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8224DEF0h case    4:*/		return 0x8224DEF4;
		  /* 8224DEF4h */ case    5:  		/* cmpw CR6, R11, R10 */
		/* 8224DEF4h case    5:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224DEF4h case    5:*/		return 0x8224DEF8;
		  /* 8224DEF8h */ case    6:  		/* bc 4, CR6_LT, 56 */
		/* 8224DEF8h case    6:*/		if ( !regs.CR[6].lt ) { return 0x8224DF30;  }
		/* 8224DEF8h case    6:*/		return 0x8224DEFC;
		  /* 8224DEFCh */ case    7:  		/* lwz R3, <#[R28 + 48]> */
		/* 8224DEFCh case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000030) );
		/* 8224DEFCh case    7:*/		return 0x8224DF00;
		  /* 8224DF00h */ case    8:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224DF00h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224DF00h case    8:*/		return 0x8224DF04;
		  /* 8224DF04h */ case    9:  		/* cmplw CR6, R30, R11 */
		/* 8224DF04h case    9:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8224DF04h case    9:*/		return 0x8224DF08;
		  /* 8224DF08h */ case   10:  		/* bc 4, CR6_LT, 16 */
		/* 8224DF08h case   10:*/		if ( !regs.CR[6].lt ) { return 0x8224DF18;  }
		/* 8224DF08h case   10:*/		return 0x8224DF0C;
		  /* 8224DF0Ch */ case   11:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224DF0Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224DF0Ch case   11:*/		return 0x8224DF10;
		  /* 8224DF10h */ case   12:  		/* add R3, R11, R29 */
		/* 8224DF10h case   12:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 8224DF10h case   12:*/		return 0x8224DF14;
		  /* 8224DF14h */ case   13:  		/* b 12 */
		/* 8224DF14h case   13:*/		return 0x8224DF20;
		/* 8224DF14h case   13:*/		return 0x8224DF18;
	}
	return 0x8224DF18;
} // Block from 8224DEE0h-8224DF18h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224DF18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DF18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DF18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DF18);
		  /* 8224DF18h */ case    0:  		/* mr R4, R30 */
		/* 8224DF18h case    0:*/		regs.R4 = regs.R30;
		/* 8224DF18h case    0:*/		return 0x8224DF1C;
		  /* 8224DF1Ch */ case    1:  		/* bl 23460 */
		/* 8224DF1Ch case    1:*/		regs.LR = 0x8224DF20; return 0x82253AC0;
		/* 8224DF1Ch case    1:*/		return 0x8224DF20;
	}
	return 0x8224DF20;
} // Block from 8224DF18h-8224DF20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224DF20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DF20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DF20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DF20);
		  /* 8224DF20h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224DF20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224DF20h case    0:*/		return 0x8224DF24;
		  /* 8224DF24h */ case    1:  		/* lwz R10, <#[R28 + 28]> */
		/* 8224DF24h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000001C) );
		/* 8224DF24h case    1:*/		return 0x8224DF28;
		  /* 8224DF28h */ case    2:  		/* lwz R11, <#[R11 + 12]> */
		/* 8224DF28h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8224DF28h case    2:*/		return 0x8224DF2C;
		  /* 8224DF2Ch */ case    3:  		/* add R11, R11, R10 */
		/* 8224DF2Ch case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8224DF2Ch case    3:*/		return 0x8224DF30;
	}
	return 0x8224DF30;
} // Block from 8224DF20h-8224DF30h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224DF30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DF30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DF30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DF30);
		  /* 8224DF30h */ case    0:  		/* lwz R10, <#[R31 + 36]> */
		/* 8224DF30h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000024) );
		/* 8224DF30h case    0:*/		return 0x8224DF34;
		  /* 8224DF34h */ case    1:  		/* stw R11, <#[R31 + 32]> */
		/* 8224DF34h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8224DF34h case    1:*/		return 0x8224DF38;
		  /* 8224DF38h */ case    2:  		/* cmpwi CR6, R10, 0 */
		/* 8224DF38h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8224DF38h case    2:*/		return 0x8224DF3C;
		  /* 8224DF3Ch */ case    3:  		/* bc 4, CR6_EQ, 88 */
		/* 8224DF3Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8224DF94;  }
		/* 8224DF3Ch case    3:*/		return 0x8224DF40;
		  /* 8224DF40h */ case    4:  		/* lwz R11, <#[R31 + 40]> */
		/* 8224DF40h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8224DF40h case    4:*/		return 0x8224DF44;
		  /* 8224DF44h */ case    5:  		/* cmplw CR6, R11, R27 */
		/* 8224DF44h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 8224DF44h case    5:*/		return 0x8224DF48;
		  /* 8224DF48h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8224DF48h case    6:*/		if ( regs.CR[6].eq ) { return 0x8224DF5C;  }
		/* 8224DF48h case    6:*/		return 0x8224DF4C;
		  /* 8224DF4Ch */ case    7:  		/* mr R4, R31 */
		/* 8224DF4Ch case    7:*/		regs.R4 = regs.R31;
		/* 8224DF4Ch case    7:*/		return 0x8224DF50;
		  /* 8224DF50h */ case    8:  		/* mr R3, R22 */
		/* 8224DF50h case    8:*/		regs.R3 = regs.R22;
		/* 8224DF50h case    8:*/		return 0x8224DF54;
		  /* 8224DF54h */ case    9:  		/* bl -10628 */
		/* 8224DF54h case    9:*/		regs.LR = 0x8224DF58; return 0x8224B5D0;
		/* 8224DF54h case    9:*/		return 0x8224DF58;
		  /* 8224DF58h */ case   10:  		/* b 60 */
		/* 8224DF58h case   10:*/		return 0x8224DF94;
		/* 8224DF58h case   10:*/		return 0x8224DF5C;
	}
	return 0x8224DF5C;
} // Block from 8224DF30h-8224DF5Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224DF5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DF5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DF5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DF5C);
		  /* 8224DF5Ch */ case    0:  		/* lwz R11, <#[R28 + 60]> */
		/* 8224DF5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000003C) );
		/* 8224DF5Ch case    0:*/		return 0x8224DF60;
		  /* 8224DF60h */ case    1:  		/* addi R11, R11, -1 */
		/* 8224DF60h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8224DF60h case    1:*/		return 0x8224DF64;
		  /* 8224DF64h */ case    2:  		/* stw R11, <#[R28 + 60]> */
		/* 8224DF64h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x0000003C) );
		/* 8224DF64h case    2:*/		return 0x8224DF68;
		  /* 8224DF68h */ case    3:  		/* lwz R4, <#[R31 + 40]> */
		/* 8224DF68h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000028) );
		/* 8224DF68h case    3:*/		return 0x8224DF6C;
		  /* 8224DF6Ch */ case    4:  		/* lwz R3, <#[R22 + 8]> */
		/* 8224DF6Ch case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000008) );
		/* 8224DF6Ch case    4:*/		return 0x8224DF70;
		  /* 8224DF70h */ case    5:  		/* bl 101424 */
		/* 8224DF70h case    5:*/		regs.LR = 0x8224DF74; return 0x82266BA0;
		/* 8224DF70h case    5:*/		return 0x8224DF74;
		  /* 8224DF74h */ case    6:  		/* lwz R11, <#[R22 + 120]> */
		/* 8224DF74h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000078) );
		/* 8224DF74h case    6:*/		return 0x8224DF78;
		  /* 8224DF78h */ case    7:  		/* lwz R11, <#[R11 + 28]> */
		/* 8224DF78h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8224DF78h case    7:*/		return 0x8224DF7C;
		  /* 8224DF7Ch */ case    8:  		/* mr R4, R31 */
		/* 8224DF7Ch case    8:*/		regs.R4 = regs.R31;
		/* 8224DF7Ch case    8:*/		return 0x8224DF80;
		  /* 8224DF80h */ case    9:  		/* mr R3, R22 */
		/* 8224DF80h case    9:*/		regs.R3 = regs.R22;
		/* 8224DF80h case    9:*/		return 0x8224DF84;
		  /* 8224DF84h */ case   10:  		/* addi R11, R11, 1 */
		/* 8224DF84h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224DF84h case   10:*/		return 0x8224DF88;
		  /* 8224DF88h */ case   11:  		/* stw R11, <#[R31 + 32]> */
		/* 8224DF88h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8224DF88h case   11:*/		return 0x8224DF8C;
		  /* 8224DF8Ch */ case   12:  		/* stw R11, <#[R31 + 28]> */
		/* 8224DF8Ch case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 8224DF8Ch case   12:*/		return 0x8224DF90;
		  /* 8224DF90h */ case   13:  		/* bl -1504 */
		/* 8224DF90h case   13:*/		regs.LR = 0x8224DF94; return 0x8224D9B0;
		/* 8224DF90h case   13:*/		return 0x8224DF94;
	}
	return 0x8224DF94;
} // Block from 8224DF5Ch-8224DF94h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224DF94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DF94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DF94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DF94);
		  /* 8224DF94h */ case    0:  		/* addi R30, R30, 1 */
		/* 8224DF94h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8224DF94h case    0:*/		return 0x8224DF98;
		  /* 8224DF98h */ case    1:  		/* addi R29, R29, 4 */
		/* 8224DF98h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8224DF98h case    1:*/		return 0x8224DF9C;
		  /* 8224DF9Ch */ case    2:  		/* cmpw CR6, R30, R26 */
		/* 8224DF9Ch case    2:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R26);
		/* 8224DF9Ch case    2:*/		return 0x8224DFA0;
		  /* 8224DFA0h */ case    3:  		/* bc 12, CR6_LT, -284 */
		/* 8224DFA0h case    3:*/		if ( regs.CR[6].lt ) { return 0x8224DE84;  }
		/* 8224DFA0h case    3:*/		return 0x8224DFA4;
	}
	return 0x8224DFA4;
} // Block from 8224DF94h-8224DFA4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224DFA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DFA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DFA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DFA4);
		  /* 8224DFA4h */ case    0:  		/* addi R1, R1, 176 */
		/* 8224DFA4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 8224DFA4h case    0:*/		return 0x8224DFA8;
		  /* 8224DFA8h */ case    1:  		/* b -1821980 */
		/* 8224DFA8h case    1:*/		return 0x8209128C;
		/* 8224DFA8h case    1:*/		return 0x8224DFAC;
		  /* 8224DFACh */ case    2:  		/* nop */
		/* 8224DFACh case    2:*/		cpu::op::nop();
		/* 8224DFACh case    2:*/		return 0x8224DFB0;
	}
	return 0x8224DFB0;
} // Block from 8224DFA4h-8224DFB0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224DFB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224DFB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224DFB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224DFB0);
		  /* 8224DFB0h */ case    0:  		/* mfspr R12, LR */
		/* 8224DFB0h case    0:*/		regs.R12 = regs.LR;
		/* 8224DFB0h case    0:*/		return 0x8224DFB4;
		  /* 8224DFB4h */ case    1:  		/* bl -1822072 */
		/* 8224DFB4h case    1:*/		regs.LR = 0x8224DFB8; return 0x8209123C;
		/* 8224DFB4h case    1:*/		return 0x8224DFB8;
		  /* 8224DFB8h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 8224DFB8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 8224DFB8h case    2:*/		return 0x8224DFBC;
		  /* 8224DFBCh */ case    3:  		/* lwz R9, <#[R4 + 52]> */
		/* 8224DFBCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000034) );
		/* 8224DFBCh case    3:*/		return 0x8224DFC0;
		  /* 8224DFC0h */ case    4:  		/* lis R11, -32253 */
		/* 8224DFC0h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8224DFC0h case    4:*/		return 0x8224DFC4;
		  /* 8224DFC4h */ case    5:  		/* lis R10, -32252 */
		/* 8224DFC4h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224DFC4h case    5:*/		return 0x8224DFC8;
		  /* 8224DFC8h */ case    6:  		/* mr R28, R3 */
		/* 8224DFC8h case    6:*/		regs.R28 = regs.R3;
		/* 8224DFC8h case    6:*/		return 0x8224DFCC;
		  /* 8224DFCCh */ case    7:  		/* mr R27, R4 */
		/* 8224DFCCh case    7:*/		regs.R27 = regs.R4;
		/* 8224DFCCh case    7:*/		return 0x8224DFD0;
		  /* 8224DFD0h */ case    8:  		/* li R21, 1 */
		/* 8224DFD0h case    8:*/		cpu::op::li<0>(regs,&regs.R21,0x1);
		/* 8224DFD0h case    8:*/		return 0x8224DFD4;
		  /* 8224DFD4h */ case    9:  		/* lwz R25, <#[R9 + 4]> */
		/* 8224DFD4h case    9:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R9 + 0x00000004) );
		/* 8224DFD4h case    9:*/		return 0x8224DFD8;
		  /* 8224DFD8h */ case   10:  		/* li R29, 0 */
		/* 8224DFD8h case   10:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8224DFD8h case   10:*/		return 0x8224DFDC;
		  /* 8224DFDCh */ case   11:  		/* addi R23, R11, 27460 */
		/* 8224DFDCh case   11:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R11,0x6B44);
		/* 8224DFDCh case   11:*/		return 0x8224DFE0;
		  /* 8224DFE0h */ case   12:  		/* addi R22, R10, 14208 */
		/* 8224DFE0h case   12:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R10,0x3780);
		/* 8224DFE0h case   12:*/		return 0x8224DFE4;
		  /* 8224DFE4h */ case   13:  		/* cmpwi CR6, R25, 0 */
		/* 8224DFE4h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 8224DFE4h case   13:*/		return 0x8224DFE8;
		  /* 8224DFE8h */ case   14:  		/* bc 4, CR6_GT, 244 */
		/* 8224DFE8h case   14:*/		if ( !regs.CR[6].gt ) { return 0x8224E0DC;  }
		/* 8224DFE8h case   14:*/		return 0x8224DFEC;
		  /* 8224DFECh */ case   15:  		/* lis R11, -32252 */
		/* 8224DFECh case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224DFECh case   15:*/		return 0x8224DFF0;
		  /* 8224DFF0h */ case   16:  		/* li R26, 0 */
		/* 8224DFF0h case   16:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8224DFF0h case   16:*/		return 0x8224DFF4;
		  /* 8224DFF4h */ case   17:  		/* addi R24, R11, 15380 */
		/* 8224DFF4h case   17:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x3C14);
		/* 8224DFF4h case   17:*/		return 0x8224DFF8;
		  /* 8224DFF8h */ case   18:  		/* lwz R3, <#[R27 + 52]> */
		/* 8224DFF8h case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x00000034) );
		/* 8224DFF8h case   18:*/		return 0x8224DFFC;
		  /* 8224DFFCh */ case   19:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224DFFCh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224DFFCh case   19:*/		return 0x8224E000;
		  /* 8224E000h */ case   20:  		/* cmplw CR6, R29, R11 */
		/* 8224E000h case   20:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8224E000h case   20:*/		return 0x8224E004;
		  /* 8224E004h */ case   21:  		/* bc 4, CR6_LT, 16 */
		/* 8224E004h case   21:*/		if ( !regs.CR[6].lt ) { return 0x8224E014;  }
		/* 8224E004h case   21:*/		return 0x8224E008;
		  /* 8224E008h */ case   22:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224E008h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224E008h case   22:*/		return 0x8224E00C;
		  /* 8224E00Ch */ case   23:  		/* add R3, R11, R26 */
		/* 8224E00Ch case   23:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 8224E00Ch case   23:*/		return 0x8224E010;
		  /* 8224E010h */ case   24:  		/* b 12 */
		/* 8224E010h case   24:*/		return 0x8224E01C;
		/* 8224E010h case   24:*/		return 0x8224E014;
	}
	return 0x8224E014;
} // Block from 8224DFB0h-8224E014h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8224E014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E014);
		  /* 8224E014h */ case    0:  		/* mr R4, R29 */
		/* 8224E014h case    0:*/		regs.R4 = regs.R29;
		/* 8224E014h case    0:*/		return 0x8224E018;
		  /* 8224E018h */ case    1:  		/* bl 23208 */
		/* 8224E018h case    1:*/		regs.LR = 0x8224E01C; return 0x82253AC0;
		/* 8224E018h case    1:*/		return 0x8224E01C;
	}
	return 0x8224E01C;
} // Block from 8224E014h-8224E01Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224E01Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E01C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E01C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E01C);
		  /* 8224E01Ch */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224E01Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224E01Ch case    0:*/		return 0x8224E020;
		  /* 8224E020h */ case    1:  		/* lwz R11, <#[R11 + 8]> */
		/* 8224E020h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8224E020h case    1:*/		return 0x8224E024;
		  /* 8224E024h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 8224E024h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224E024h case    2:*/		return 0x8224E028;
		  /* 8224E028h */ case    3:  		/* bc 4, CR6_EQ, 164 */
		/* 8224E028h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8224E0CC;  }
		/* 8224E028h case    3:*/		return 0x8224E02C;
		  /* 8224E02Ch */ case    4:  		/* lwz R3, <#[R27 + 52]> */
		/* 8224E02Ch case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x00000034) );
		/* 8224E02Ch case    4:*/		return 0x8224E030;
		  /* 8224E030h */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224E030h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224E030h case    5:*/		return 0x8224E034;
		  /* 8224E034h */ case    6:  		/* cmplw CR6, R29, R11 */
		/* 8224E034h case    6:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8224E034h case    6:*/		return 0x8224E038;
		  /* 8224E038h */ case    7:  		/* bc 4, CR6_LT, 16 */
		/* 8224E038h case    7:*/		if ( !regs.CR[6].lt ) { return 0x8224E048;  }
		/* 8224E038h case    7:*/		return 0x8224E03C;
		  /* 8224E03Ch */ case    8:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224E03Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224E03Ch case    8:*/		return 0x8224E040;
		  /* 8224E040h */ case    9:  		/* add R3, R11, R26 */
		/* 8224E040h case    9:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 8224E040h case    9:*/		return 0x8224E044;
		  /* 8224E044h */ case   10:  		/* b 12 */
		/* 8224E044h case   10:*/		return 0x8224E050;
		/* 8224E044h case   10:*/		return 0x8224E048;
	}
	return 0x8224E048;
} // Block from 8224E01Ch-8224E048h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224E048h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E048( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E048) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E048);
		  /* 8224E048h */ case    0:  		/* mr R4, R29 */
		/* 8224E048h case    0:*/		regs.R4 = regs.R29;
		/* 8224E048h case    0:*/		return 0x8224E04C;
		  /* 8224E04Ch */ case    1:  		/* bl 23156 */
		/* 8224E04Ch case    1:*/		regs.LR = 0x8224E050; return 0x82253AC0;
		/* 8224E04Ch case    1:*/		return 0x8224E050;
	}
	return 0x8224E050;
} // Block from 8224E048h-8224E050h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224E050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E050);
		  /* 8224E050h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224E050h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224E050h case    0:*/		return 0x8224E054;
		  /* 8224E054h */ case    1:  		/* lwz R11, <#[R11]> */
		/* 8224E054h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8224E054h case    1:*/		return 0x8224E058;
		  /* 8224E058h */ case    2:  		/* lwz R10, <#[R11 + 60]> */
		/* 8224E058h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000003C) );
		/* 8224E058h case    2:*/		return 0x8224E05C;
		  /* 8224E05Ch */ case    3:  		/* addic. R10, R10, -1 */
		/* 8224E05Ch case    3:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8224E05Ch case    3:*/		return 0x8224E060;
		  /* 8224E060h */ case    4:  		/* stw R10, <#[R11 + 60]> */
		/* 8224E060h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000003C) );
		/* 8224E060h case    4:*/		return 0x8224E064;
		  /* 8224E064h */ case    5:  		/* bc 4, CR0_EQ, 104 */
		/* 8224E064h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8224E0CC;  }
		/* 8224E064h case    5:*/		return 0x8224E068;
		  /* 8224E068h */ case    6:  		/* lwz R11, <#[R11 + 40]> */
		/* 8224E068h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8224E068h case    6:*/		return 0x8224E06C;
		  /* 8224E06Ch */ case    7:  		/* lwz R10, <#[R11 + 228]> */
		/* 8224E06Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 8224E06Ch case    7:*/		return 0x8224E070;
		  /* 8224E070h */ case    8:  		/* rlwinm. R10, R10, 26, 31, 31 */
		/* 8224E070h case    8:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R10,regs.R10);
		/* 8224E070h case    8:*/		return 0x8224E074;
		  /* 8224E074h */ case    9:  		/* bc 12, CR0_EQ, 88 */
		/* 8224E074h case    9:*/		if ( regs.CR[0].eq ) { return 0x8224E0CC;  }
		/* 8224E074h case    9:*/		return 0x8224E078;
		  /* 8224E078h */ case   10:  		/* lwz R10, <#[R11 + 56]> */
		/* 8224E078h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000038) );
		/* 8224E078h case   10:*/		return 0x8224E07C;
		  /* 8224E07Ch */ case   11:  		/* lwz R9, <#[R28 + 116]> */
		/* 8224E07Ch case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000074) );
		/* 8224E07Ch case   11:*/		return 0x8224E080;
		  /* 8224E080h */ case   12:  		/* rlwinm R11, R10, 27, 5, 31 */
		/* 8224E080h case   12:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R10);
		/* 8224E080h case   12:*/		return 0x8224E084;
		  /* 8224E084h */ case   13:  		/* rlwinm R30, R10, 0, 27, 31 */
		/* 8224E084h case   13:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R30,regs.R10);
		/* 8224E084h case   13:*/		return 0x8224E088;
		  /* 8224E088h */ case   14:  		/* addi R11, R11, 2 */
		/* 8224E088h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8224E088h case   14:*/		return 0x8224E08C;
		  /* 8224E08Ch */ case   15:  		/* rlwinm R31, R11, 2, 0, 29 */
		/* 8224E08Ch case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R11);
		/* 8224E08Ch case   15:*/		return 0x8224E090;
		  /* 8224E090h */ case   16:  		/* lwzx R11, <#[R31 + R9]> */
		/* 8224E090h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R9 + 0x00000000) );
		/* 8224E090h case   16:*/		return 0x8224E094;
		  /* 8224E094h */ case   17:  		/* srw R11, R11, R30 */
		/* 8224E094h case   17:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8224E094h case   17:*/		return 0x8224E098;
		  /* 8224E098h */ case   18:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8224E098h case   18:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8224E098h case   18:*/		return 0x8224E09C;
		  /* 8224E09Ch */ case   19:  		/* bc 4, CR0_EQ, 28 */
		/* 8224E09Ch case   19:*/		if ( !regs.CR[0].eq ) { return 0x8224E0B8;  }
		/* 8224E09Ch case   19:*/		return 0x8224E0A0;
		  /* 8224E0A0h */ case   20:  		/* mr R6, R22 */
		/* 8224E0A0h case   20:*/		regs.R6 = regs.R22;
		/* 8224E0A0h case   20:*/		return 0x8224E0A4;
		  /* 8224E0A4h */ case   21:  		/* mr R5, R24 */
		/* 8224E0A4h case   21:*/		regs.R5 = regs.R24;
		/* 8224E0A4h case   21:*/		return 0x8224E0A8;
		  /* 8224E0A8h */ case   22:  		/* mr R4, R23 */
		/* 8224E0A8h case   22:*/		regs.R4 = regs.R23;
		/* 8224E0A8h case   22:*/		return 0x8224E0AC;
		  /* 8224E0ACh */ case   23:  		/* li R7, 1904 */
		/* 8224E0ACh case   23:*/		cpu::op::li<0>(regs,&regs.R7,0x770);
		/* 8224E0ACh case   23:*/		return 0x8224E0B0;
		  /* 8224E0B0h */ case   24:  		/* li R3, 0 */
		/* 8224E0B0h case   24:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224E0B0h case   24:*/		return 0x8224E0B4;
		  /* 8224E0B4h */ case   25:  		/* bl -1008812 */
		/* 8224E0B4h case   25:*/		regs.LR = 0x8224E0B8; return 0x82157C08;
		/* 8224E0B4h case   25:*/		return 0x8224E0B8;
	}
	return 0x8224E0B8;
} // Block from 8224E050h-8224E0B8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8224E0B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E0B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E0B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E0B8);
		  /* 8224E0B8h */ case    0:  		/* lwz R11, <#[R28 + 116]> */
		/* 8224E0B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000074) );
		/* 8224E0B8h case    0:*/		return 0x8224E0BC;
		  /* 8224E0BCh */ case    1:  		/* slw R10, R21, R30 */
		/* 8224E0BCh case    1:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R21,regs.R30);
		/* 8224E0BCh case    1:*/		return 0x8224E0C0;
		  /* 8224E0C0h */ case    2:  		/* lwzx R9, <#[R31 + R11]> */
		/* 8224E0C0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8224E0C0h case    2:*/		return 0x8224E0C4;
		  /* 8224E0C4h */ case    3:  		/* andc R10, R9, R10 */
		/* 8224E0C4h case    3:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8224E0C4h case    3:*/		return 0x8224E0C8;
		  /* 8224E0C8h */ case    4:  		/* stwx R10, <#[R31 + R11]> */
		/* 8224E0C8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8224E0C8h case    4:*/		return 0x8224E0CC;
	}
	return 0x8224E0CC;
} // Block from 8224E0B8h-8224E0CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224E0CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E0CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E0CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E0CC);
		  /* 8224E0CCh */ case    0:  		/* addi R29, R29, 1 */
		/* 8224E0CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8224E0CCh case    0:*/		return 0x8224E0D0;
		  /* 8224E0D0h */ case    1:  		/* addi R26, R26, 4 */
		/* 8224E0D0h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 8224E0D0h case    1:*/		return 0x8224E0D4;
		  /* 8224E0D4h */ case    2:  		/* cmpw CR6, R29, R25 */
		/* 8224E0D4h case    2:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R25);
		/* 8224E0D4h case    2:*/		return 0x8224E0D8;
		  /* 8224E0D8h */ case    3:  		/* bc 12, CR6_LT, -224 */
		/* 8224E0D8h case    3:*/		if ( regs.CR[6].lt ) { return 0x8224DFF8;  }
		/* 8224E0D8h case    3:*/		return 0x8224E0DC;
	}
	return 0x8224E0DC;
} // Block from 8224E0CCh-8224E0DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224E0DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E0DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E0DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E0DC);
		  /* 8224E0DCh */ case    0:  		/* lwz R30, <#[R27 + 40]> */
		/* 8224E0DCh case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x00000028) );
		/* 8224E0DCh case    0:*/		return 0x8224E0E0;
		  /* 8224E0E0h */ case    1:  		/* lwz R11, <#[R30 + 228]> */
		/* 8224E0E0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000E4) );
		/* 8224E0E0h case    1:*/		return 0x8224E0E4;
		  /* 8224E0E4h */ case    2:  		/* rlwinm. R11, R11, 23, 31, 31 */
		/* 8224E0E4h case    2:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R11,regs.R11);
		/* 8224E0E4h case    2:*/		return 0x8224E0E8;
		  /* 8224E0E8h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 8224E0E8h case    3:*/		if ( regs.CR[0].eq ) { return 0x8224E0F8;  }
		/* 8224E0E8h case    3:*/		return 0x8224E0EC;
		  /* 8224E0ECh */ case    4:  		/* lwz R11, <#[R28 + 132]> */
		/* 8224E0ECh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000084) );
		/* 8224E0ECh case    4:*/		return 0x8224E0F0;
		  /* 8224E0F0h */ case    5:  		/* addi R11, R11, 1 */
		/* 8224E0F0h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224E0F0h case    5:*/		return 0x8224E0F4;
		  /* 8224E0F4h */ case    6:  		/* stw R11, <#[R28 + 132]> */
		/* 8224E0F4h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000084) );
		/* 8224E0F4h case    6:*/		return 0x8224E0F8;
	}
	return 0x8224E0F8;
} // Block from 8224E0DCh-8224E0F8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224E0F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E0F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E0F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E0F8);
		  /* 8224E0F8h */ case    0:  		/* lbz R11, <#[R27 + 56]> */
		/* 8224E0F8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000038) );
		/* 8224E0F8h case    0:*/		return 0x8224E0FC;
		  /* 8224E0FCh */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 8224E0FCh case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224E0FCh case    1:*/		return 0x8224E100;
		  /* 8224E100h */ case    2:  		/* bc 12, CR0_EQ, 272 */
		/* 8224E100h case    2:*/		if ( regs.CR[0].eq ) { return 0x8224E210;  }
		/* 8224E100h case    2:*/		return 0x8224E104;
		  /* 8224E104h */ case    3:  		/* lwz R11, <#[R27 + 60]> */
		/* 8224E104h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000003C) );
		/* 8224E104h case    3:*/		return 0x8224E108;
		  /* 8224E108h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 8224E108h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224E108h case    4:*/		return 0x8224E10C;
		  /* 8224E10Ch */ case    5:  		/* bc 4, CR6_GT, 260 */
		/* 8224E10Ch case    5:*/		if ( !regs.CR[6].gt ) { return 0x8224E210;  }
		/* 8224E10Ch case    5:*/		return 0x8224E110;
		  /* 8224E110h */ case    6:  		/* lwz R11, <#[R30 + 228]> */
		/* 8224E110h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000E4) );
		/* 8224E110h case    6:*/		return 0x8224E114;
		  /* 8224E114h */ case    7:  		/* rlwinm. R11, R11, 23, 31, 31 */
		/* 8224E114h case    7:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R11,regs.R11);
		/* 8224E114h case    7:*/		return 0x8224E118;
		  /* 8224E118h */ case    8:  		/* bc 12, CR0_EQ, 96 */
		/* 8224E118h case    8:*/		if ( regs.CR[0].eq ) { return 0x8224E178;  }
		/* 8224E118h case    8:*/		return 0x8224E11C;
		  /* 8224E11Ch */ case    9:  		/* mr R3, R30 */
		/* 8224E11Ch case    9:*/		regs.R3 = regs.R30;
		/* 8224E11Ch case    9:*/		return 0x8224E120;
		  /* 8224E120h */ case   10:  		/* bl -99176 */
		/* 8224E120h case   10:*/		regs.LR = 0x8224E124; return 0x82235DB8;
		/* 8224E120h case   10:*/		return 0x8224E124;
		  /* 8224E124h */ case   11:  		/* lwz R11, <#[R3 + 228]> */
		/* 8224E124h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 8224E124h case   11:*/		return 0x8224E128;
		  /* 8224E128h */ case   12:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 8224E128h case   12:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8224E128h case   12:*/		return 0x8224E12C;
		  /* 8224E12Ch */ case   13:  		/* bc 4, CR0_EQ, 76 */
		/* 8224E12Ch case   13:*/		if ( !regs.CR[0].eq ) { return 0x8224E178;  }
		/* 8224E12Ch case   13:*/		return 0x8224E130;
		  /* 8224E130h */ case   14:  		/* lwz R31, <#[R3 + 56]> */
		/* 8224E130h case   14:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000038) );
		/* 8224E130h case   14:*/		return 0x8224E134;
		  /* 8224E134h */ case   15:  		/* lwz R10, <#[R28 + 116]> */
		/* 8224E134h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000074) );
		/* 8224E134h case   15:*/		return 0x8224E138;
		  /* 8224E138h */ case   16:  		/* rlwinm R11, R31, 27, 5, 31 */
		/* 8224E138h case   16:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R31);
		/* 8224E138h case   16:*/		return 0x8224E13C;
		  /* 8224E13Ch */ case   17:  		/* rlwinm R9, R31, 0, 27, 31 */
		/* 8224E13Ch case   17:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R31);
		/* 8224E13Ch case   17:*/		return 0x8224E140;
		  /* 8224E140h */ case   18:  		/* addi R11, R11, 2 */
		/* 8224E140h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8224E140h case   18:*/		return 0x8224E144;
		  /* 8224E144h */ case   19:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8224E144h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8224E144h case   19:*/		return 0x8224E148;
		  /* 8224E148h */ case   20:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8224E148h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8224E148h case   20:*/		return 0x8224E14C;
		  /* 8224E14Ch */ case   21:  		/* srw R11, R11, R9 */
		/* 8224E14Ch case   21:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8224E14Ch case   21:*/		return 0x8224E150;
		  /* 8224E150h */ case   22:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8224E150h case   22:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8224E150h case   22:*/		return 0x8224E154;
		  /* 8224E154h */ case   23:  		/* bc 12, CR0_EQ, 48 */
		/* 8224E154h case   23:*/		if ( regs.CR[0].eq ) { return 0x8224E184;  }
		/* 8224E154h case   23:*/		return 0x8224E158;
		  /* 8224E158h */ case   24:  		/* lis R11, -32252 */
		/* 8224E158h case   24:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224E158h case   24:*/		return 0x8224E15C;
		  /* 8224E15Ch */ case   25:  		/* mr R6, R22 */
		/* 8224E15Ch case   25:*/		regs.R6 = regs.R22;
		/* 8224E15Ch case   25:*/		return 0x8224E160;
		  /* 8224E160h */ case   26:  		/* addi R5, R11, 15472 */
		/* 8224E160h case   26:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3C70);
		/* 8224E160h case   26:*/		return 0x8224E164;
		  /* 8224E164h */ case   27:  		/* mr R4, R23 */
		/* 8224E164h case   27:*/		regs.R4 = regs.R23;
		/* 8224E164h case   27:*/		return 0x8224E168;
		  /* 8224E168h */ case   28:  		/* li R7, 1922 */
		/* 8224E168h case   28:*/		cpu::op::li<0>(regs,&regs.R7,0x782);
		/* 8224E168h case   28:*/		return 0x8224E16C;
		  /* 8224E16Ch */ case   29:  		/* li R3, 0 */
		/* 8224E16Ch case   29:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224E16Ch case   29:*/		return 0x8224E170;
		  /* 8224E170h */ case   30:  		/* bl -1009000 */
		/* 8224E170h case   30:*/		regs.LR = 0x8224E174; return 0x82157C08;
		/* 8224E170h case   30:*/		return 0x8224E174;
		  /* 8224E174h */ case   31:  		/* b 16 */
		/* 8224E174h case   31:*/		return 0x8224E184;
		/* 8224E174h case   31:*/		return 0x8224E178;
	}
	return 0x8224E178;
} // Block from 8224E0F8h-8224E178h (32 instructions)

//////////////////////////////////////////////////////
// Block at 8224E178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E178);
		  /* 8224E178h */ case    0:  		/* lwz R3, <#[R28 + 116]> */
		/* 8224E178h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000074) );
		/* 8224E178h case    0:*/		return 0x8224E17C;
		  /* 8224E17Ch */ case    1:  		/* bl -13300 */
		/* 8224E17Ch case    1:*/		regs.LR = 0x8224E180; return 0x8224AD88;
		/* 8224E17Ch case    1:*/		return 0x8224E180;
		  /* 8224E180h */ case    2:  		/* mr R31, R3 */
		/* 8224E180h case    2:*/		regs.R31 = regs.R3;
		/* 8224E180h case    2:*/		return 0x8224E184;
	}
	return 0x8224E184;
} // Block from 8224E178h-8224E184h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224E184h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E184( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E184) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E184);
		  /* 8224E184h */ case    0:  		/* cmpwi CR6, R31, 0 */
		/* 8224E184h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 8224E184h case    0:*/		return 0x8224E188;
		  /* 8224E188h */ case    1:  		/* bc 12, CR6_LT, 28 */
		/* 8224E188h case    1:*/		if ( regs.CR[6].lt ) { return 0x8224E1A4;  }
		/* 8224E188h case    1:*/		return 0x8224E18C;
		  /* 8224E18Ch */ case    2:  		/* lwz R11, <#[R28 + 4]> */
		/* 8224E18Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8224E18Ch case    2:*/		return 0x8224E190;
		  /* 8224E190h */ case    3:  		/* lwz R11, <#[R11 + 12]> */
		/* 8224E190h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8224E190h case    3:*/		return 0x8224E194;
		  /* 8224E194h */ case    4:  		/* lwz R11, <#[R11 + 1360]> */
		/* 8224E194h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000550) );
		/* 8224E194h case    4:*/		return 0x8224E198;
		  /* 8224E198h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 8224E198h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8224E198h case    5:*/		return 0x8224E19C;
		  /* 8224E19Ch */ case    6:  		/* cmpw CR6, R31, R11 */
		/* 8224E19Ch case    6:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R11);
		/* 8224E19Ch case    6:*/		return 0x8224E1A0;
		  /* 8224E1A0h */ case    7:  		/* bc 12, CR6_LT, 32 */
		/* 8224E1A0h case    7:*/		if ( regs.CR[6].lt ) { return 0x8224E1C0;  }
		/* 8224E1A0h case    7:*/		return 0x8224E1A4;
	}
	return 0x8224E1A4;
} // Block from 8224E184h-8224E1A4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224E1A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E1A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E1A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E1A4);
		  /* 8224E1A4h */ case    0:  		/* lis R11, -32252 */
		/* 8224E1A4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224E1A4h case    0:*/		return 0x8224E1A8;
		  /* 8224E1A8h */ case    1:  		/* mr R6, R22 */
		/* 8224E1A8h case    1:*/		regs.R6 = regs.R22;
		/* 8224E1A8h case    1:*/		return 0x8224E1AC;
		  /* 8224E1ACh */ case    2:  		/* addi R5, R11, 15408 */
		/* 8224E1ACh case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3C30);
		/* 8224E1ACh case    2:*/		return 0x8224E1B0;
		  /* 8224E1B0h */ case    3:  		/* mr R4, R23 */
		/* 8224E1B0h case    3:*/		regs.R4 = regs.R23;
		/* 8224E1B0h case    3:*/		return 0x8224E1B4;
		  /* 8224E1B4h */ case    4:  		/* li R7, 1927 */
		/* 8224E1B4h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x787);
		/* 8224E1B4h case    4:*/		return 0x8224E1B8;
		  /* 8224E1B8h */ case    5:  		/* li R3, 0 */
		/* 8224E1B8h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224E1B8h case    5:*/		return 0x8224E1BC;
		  /* 8224E1BCh */ case    6:  		/* bl -1009076 */
		/* 8224E1BCh case    6:*/		regs.LR = 0x8224E1C0; return 0x82157C08;
		/* 8224E1BCh case    6:*/		return 0x8224E1C0;
	}
	return 0x8224E1C0;
} // Block from 8224E1A4h-8224E1C0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224E1C0h
// Function '?ComputeNumbers@Scheduler@XGRAPHICS@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E1C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E1C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E1C0);
		  /* 8224E1C0h */ case    0:  		/* rlwinm R10, R31, 27, 5, 31 */
		/* 8224E1C0h case    0:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R31);
		/* 8224E1C0h case    0:*/		return 0x8224E1C4;
		  /* 8224E1C4h */ case    1:  		/* lwz R11, <#[R28 + 116]> */
		/* 8224E1C4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000074) );
		/* 8224E1C4h case    1:*/		return 0x8224E1C8;
		  /* 8224E1C8h */ case    2:  		/* rlwinm R9, R31, 0, 27, 31 */
		/* 8224E1C8h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R31);
		/* 8224E1C8h case    2:*/		return 0x8224E1CC;
		  /* 8224E1CCh */ case    3:  		/* addi R10, R10, 2 */
		/* 8224E1CCh case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 8224E1CCh case    3:*/		return 0x8224E1D0;
		  /* 8224E1D0h */ case    4:  		/* slw R9, R21, R9 */
		/* 8224E1D0h case    4:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R21,regs.R9);
		/* 8224E1D0h case    4:*/		return 0x8224E1D4;
		  /* 8224E1D4h */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8224E1D4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8224E1D4h case    5:*/		return 0x8224E1D8;
		  /* 8224E1D8h */ case    6:  		/* lwzx R8, <#[R10 + R11]> */
		/* 8224E1D8h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8224E1D8h case    6:*/		return 0x8224E1DC;
		  /* 8224E1DCh */ case    7:  		/* or R9, R9, R8 */
		/* 8224E1DCh case    7:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8224E1DCh case    7:*/		return 0x8224E1E0;
		  /* 8224E1E0h */ case    8:  		/* stwx R9, <#[R10 + R11]> */
		/* 8224E1E0h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8224E1E0h case    8:*/		return 0x8224E1E4;
		  /* 8224E1E4h */ case    9:  		/* lwz R11, <#[R30 + 80]> */
		/* 8224E1E4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000050) );
		/* 8224E1E4h case    9:*/		return 0x8224E1E8;
		  /* 8224E1E8h */ case   10:  		/* lwz R10, <#[R30 + 228]> */
		/* 8224E1E8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x000000E4) );
		/* 8224E1E8h case   10:*/		return 0x8224E1EC;
		  /* 8224E1ECh */ case   11:  		/* ori R10, R10, 64 */
		/* 8224E1ECh case   11:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x40);
		/* 8224E1ECh case   11:*/		return 0x8224E1F0;
		  /* 8224E1F0h */ case   12:  		/* stw R31, <#[R30 + 56]> */
		/* 8224E1F0h case   12:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000038) );
		/* 8224E1F0h case   12:*/		return 0x8224E1F4;
		  /* 8224E1F4h */ case   13:  		/* stw R11, <#[R30 + 80]> */
		/* 8224E1F4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000050) );
		/* 8224E1F4h case   13:*/		return 0x8224E1F8;
		  /* 8224E1F8h */ case   14:  		/* stw R10, <#[R30 + 228]> */
		/* 8224E1F8h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x000000E4) );
		/* 8224E1F8h case   14:*/		return 0x8224E1FC;
		  /* 8224E1FCh */ case   15:  		/* lwz R11, <#[R28 + 128]> */
		/* 8224E1FCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000080) );
		/* 8224E1FCh case   15:*/		return 0x8224E200;
		  /* 8224E200h */ case   16:  		/* cmpw CR6, R31, R11 */
		/* 8224E200h case   16:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R11);
		/* 8224E200h case   16:*/		return 0x8224E204;
		  /* 8224E204h */ case   17:  		/* bc 4, CR6_GT, 168 */
		/* 8224E204h case   17:*/		if ( !regs.CR[6].gt ) { return 0x8224E2AC;  }
		/* 8224E204h case   17:*/		return 0x8224E208;
		  /* 8224E208h */ case   18:  		/* stw R31, <#[R28 + 128]> */
		/* 8224E208h case   18:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R28 + 0x00000080) );
		/* 8224E208h case   18:*/		return 0x8224E20C;
		  /* 8224E20Ch */ case   19:  		/* b 160 */
		/* 8224E20Ch case   19:*/		return 0x8224E2AC;
		/* 8224E20Ch case   19:*/		return 0x8224E210;
	}
	return 0x8224E210;
} // Block from 8224E1C0h-8224E210h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8224E210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E210);
		  /* 8224E210h */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 8224E210h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8224E210h case    0:*/		return 0x8224E214;
		  /* 8224E214h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224E214h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224E214h case    1:*/		return 0x8224E218;
		  /* 8224E218h */ case    2:  		/* bc 12, CR6_EQ, 52 */
		/* 8224E218h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224E24C;  }
		/* 8224E218h case    2:*/		return 0x8224E21C;
		  /* 8224E21Ch */ case    3:  		/* lwz R11, <#[R30 + 228]> */
		/* 8224E21Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000E4) );
		/* 8224E21Ch case    3:*/		return 0x8224E220;
		  /* 8224E220h */ case    4:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 8224E220h case    4:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 8224E220h case    4:*/		return 0x8224E224;
		  /* 8224E224h */ case    5:  		/* bc 4, CR0_EQ, 40 */
		/* 8224E224h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8224E24C;  }
		/* 8224E224h case    5:*/		return 0x8224E228;
		  /* 8224E228h */ case    6:  		/* lis R11, -32251 */
		/* 8224E228h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8224E228h case    6:*/		return 0x8224E22C;
		  /* 8224E22Ch */ case    7:  		/* lwz R10, <#[R30 + 80]> */
		/* 8224E22Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000050) );
		/* 8224E22Ch case    7:*/		return 0x8224E230;
		  /* 8224E230h */ case    8:  		/* addi R11, R11, -19064 */
		/* 8224E230h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFB588);
		/* 8224E230h case    8:*/		return 0x8224E234;
		  /* 8224E234h */ case    9:  		/* mulli R10, R10, 12 */
		/* 8224E234h case    9:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0xC);
		/* 8224E234h case    9:*/		return 0x8224E238;
		  /* 8224E238h */ case   10:  		/* addi R11, R11, 4 */
		/* 8224E238h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8224E238h case   10:*/		return 0x8224E23C;
		  /* 8224E23Ch */ case   11:  		/* lbzx R11, <#[R10 + R11]> */
		/* 8224E23Ch case   11:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8224E23Ch case   11:*/		return 0x8224E240;
		  /* 8224E240h */ case   12:  		/* cmplwi CR0, R11, 0 */
		/* 8224E240h case   12:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224E240h case   12:*/		return 0x8224E244;
		  /* 8224E244h */ case   13:  		/* mr R11, R21 */
		/* 8224E244h case   13:*/		regs.R11 = regs.R21;
		/* 8224E244h case   13:*/		return 0x8224E248;
		  /* 8224E248h */ case   14:  		/* bc 4, CR0_EQ, 8 */
		/* 8224E248h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8224E250;  }
		/* 8224E248h case   14:*/		return 0x8224E24C;
	}
	return 0x8224E24C;
} // Block from 8224E210h-8224E24Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8224E24Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E24C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E24C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E24C);
		  /* 8224E24Ch */ case    0:  		/* li R11, 0 */
		/* 8224E24Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224E24Ch case    0:*/		return 0x8224E250;
	}
	return 0x8224E250;
} // Block from 8224E24Ch-8224E250h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224E250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E250);
		  /* 8224E250h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8224E250h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8224E250h case    0:*/		return 0x8224E254;
		  /* 8224E254h */ case    1:  		/* bc 12, CR0_EQ, 88 */
		/* 8224E254h case    1:*/		if ( regs.CR[0].eq ) { return 0x8224E2AC;  }
		/* 8224E254h case    1:*/		return 0x8224E258;
		  /* 8224E258h */ case    2:  		/* lwz R11, <#[R30 + 228]> */
		/* 8224E258h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000E4) );
		/* 8224E258h case    2:*/		return 0x8224E25C;
		  /* 8224E25Ch */ case    3:  		/* rlwinm. R11, R11, 26, 31, 31 */
		/* 8224E25Ch case    3:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R11,regs.R11);
		/* 8224E25Ch case    3:*/		return 0x8224E260;
		  /* 8224E260h */ case    4:  		/* bc 4, CR0_EQ, 36 */
		/* 8224E260h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8224E284;  }
		/* 8224E260h case    4:*/		return 0x8224E264;
		  /* 8224E264h */ case    5:  		/* lwz R10, <#[R28]> */
		/* 8224E264h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 8224E264h case    5:*/		return 0x8224E268;
		  /* 8224E268h */ case    6:  		/* lwz R9, <#[R30 + 80]> */
		/* 8224E268h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000050) );
		/* 8224E268h case    6:*/		return 0x8224E26C;
		  /* 8224E26Ch */ case    7:  		/* lwz R11, <#[R10 + 1524]> */
		/* 8224E26Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005F4) );
		/* 8224E26Ch case    7:*/		return 0x8224E270;
		  /* 8224E270h */ case    8:  		/* addi R11, R11, 1 */
		/* 8224E270h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224E270h case    8:*/		return 0x8224E274;
		  /* 8224E274h */ case    9:  		/* stw R11, <#[R10 + 1524]> */
		/* 8224E274h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x000005F4) );
		/* 8224E274h case    9:*/		return 0x8224E278;
		  /* 8224E278h */ case   10:  		/* stw R11, <#[R30 + 56]> */
		/* 8224E278h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000038) );
		/* 8224E278h case   10:*/		return 0x8224E27C;
		  /* 8224E27Ch */ case   11:  		/* stw R9, <#[R30 + 80]> */
		/* 8224E27Ch case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000050) );
		/* 8224E27Ch case   11:*/		return 0x8224E280;
		  /* 8224E280h */ case   12:  		/* b 44 */
		/* 8224E280h case   12:*/		return 0x8224E2AC;
		/* 8224E280h case   12:*/		return 0x8224E284;
	}
	return 0x8224E284;
} // Block from 8224E250h-8224E284h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224E284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E284);
		  /* 8224E284h */ case    0:  		/* lwz R9, <#[R30 + 56]> */
		/* 8224E284h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000038) );
		/* 8224E284h case    0:*/		return 0x8224E288;
		  /* 8224E288h */ case    1:  		/* lwz R10, <#[R28 + 116]> */
		/* 8224E288h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000074) );
		/* 8224E288h case    1:*/		return 0x8224E28C;
		  /* 8224E28Ch */ case    2:  		/* rlwinm R11, R9, 27, 5, 31 */
		/* 8224E28Ch case    2:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R9);
		/* 8224E28Ch case    2:*/		return 0x8224E290;
		  /* 8224E290h */ case    3:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8224E290h case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8224E290h case    3:*/		return 0x8224E294;
		  /* 8224E294h */ case    4:  		/* addi R11, R11, 2 */
		/* 8224E294h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8224E294h case    4:*/		return 0x8224E298;
		  /* 8224E298h */ case    5:  		/* slw R9, R21, R9 */
		/* 8224E298h case    5:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R21,regs.R9);
		/* 8224E298h case    5:*/		return 0x8224E29C;
		  /* 8224E29Ch */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8224E29Ch case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8224E29Ch case    6:*/		return 0x8224E2A0;
		  /* 8224E2A0h */ case    7:  		/* lwzx R8, <#[R11 + R10]> */
		/* 8224E2A0h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8224E2A0h case    7:*/		return 0x8224E2A4;
		  /* 8224E2A4h */ case    8:  		/* or R9, R9, R8 */
		/* 8224E2A4h case    8:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8224E2A4h case    8:*/		return 0x8224E2A8;
		  /* 8224E2A8h */ case    9:  		/* stwx R9, <#[R11 + R10]> */
		/* 8224E2A8h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8224E2A8h case    9:*/		return 0x8224E2AC;
	}
	return 0x8224E2AC;
} // Block from 8224E284h-8224E2ACh (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224E2ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E2AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E2AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E2AC);
		  /* 8224E2ACh */ case    0:  		/* addi R1, R1, 176 */
		/* 8224E2ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 8224E2ACh case    0:*/		return 0x8224E2B0;
		  /* 8224E2B0h */ case    1:  		/* b -1822756 */
		/* 8224E2B0h case    1:*/		return 0x8209128C;
		/* 8224E2B0h case    1:*/		return 0x8224E2B4;
		  /* 8224E2B4h */ case    2:  		/* nop */
		/* 8224E2B4h case    2:*/		cpu::op::nop();
		/* 8224E2B4h case    2:*/		return 0x8224E2B8;
	}
	return 0x8224E2B8;
} // Block from 8224E2ACh-8224E2B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224E2B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E2B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E2B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E2B8);
		  /* 8224E2B8h */ case    0:  		/* mfspr R12, LR */
		/* 8224E2B8h case    0:*/		regs.R12 = regs.LR;
		/* 8224E2B8h case    0:*/		return 0x8224E2BC;
		  /* 8224E2BCh */ case    1:  		/* bl -1822856 */
		/* 8224E2BCh case    1:*/		regs.LR = 0x8224E2C0; return 0x82091234;
		/* 8224E2BCh case    1:*/		return 0x8224E2C0;
		  /* 8224E2C0h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 8224E2C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 8224E2C0h case    2:*/		return 0x8224E2C4;
		  /* 8224E2C4h */ case    3:  		/* mr R20, R3 */
		/* 8224E2C4h case    3:*/		regs.R20 = regs.R3;
		/* 8224E2C4h case    3:*/		return 0x8224E2C8;
		  /* 8224E2C8h */ case    4:  		/* addi R3, R3, 36 */
		/* 8224E2C8h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x24);
		/* 8224E2C8h case    4:*/		return 0x8224E2CC;
		  /* 8224E2CCh */ case    5:  		/* bl 21684 */
		/* 8224E2CCh case    5:*/		regs.LR = 0x8224E2D0; return 0x82253780;
		/* 8224E2CCh case    5:*/		return 0x8224E2D0;
		  /* 8224E2D0h */ case    6:  		/* lis R11, -32253 */
		/* 8224E2D0h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8224E2D0h case    6:*/		return 0x8224E2D4;
		  /* 8224E2D4h */ case    7:  		/* lis R10, -32252 */
		/* 8224E2D4h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224E2D4h case    7:*/		return 0x8224E2D8;
		  /* 8224E2D8h */ case    8:  		/* rlwinm. R9, R3, 0, 24, 31 */
		/* 8224E2D8h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R3);
		/* 8224E2D8h case    8:*/		return 0x8224E2DC;
		  /* 8224E2DCh */ case    9:  		/* addi R25, R11, 27460 */
		/* 8224E2DCh case    9:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R11,0x6B44);
		/* 8224E2DCh case    9:*/		return 0x8224E2E0;
		  /* 8224E2E0h */ case   10:  		/* addi R24, R10, 14208 */
		/* 8224E2E0h case   10:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R10,0x3780);
		/* 8224E2E0h case   10:*/		return 0x8224E2E4;
		  /* 8224E2E4h */ case   11:  		/* bc 4, CR0_EQ, 32 */
		/* 8224E2E4h case   11:*/		if ( !regs.CR[0].eq ) { return 0x8224E304;  }
		/* 8224E2E4h case   11:*/		return 0x8224E2E8;
		  /* 8224E2E8h */ case   12:  		/* lis R11, -32252 */
		/* 8224E2E8h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224E2E8h case   12:*/		return 0x8224E2EC;
		  /* 8224E2ECh */ case   13:  		/* mr R6, R24 */
		/* 8224E2ECh case   13:*/		regs.R6 = regs.R24;
		/* 8224E2ECh case   13:*/		return 0x8224E2F0;
		  /* 8224E2F0h */ case   14:  		/* addi R5, R11, 15544 */
		/* 8224E2F0h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3CB8);
		/* 8224E2F0h case   14:*/		return 0x8224E2F4;
		  /* 8224E2F4h */ case   15:  		/* mr R4, R25 */
		/* 8224E2F4h case   15:*/		regs.R4 = regs.R25;
		/* 8224E2F4h case   15:*/		return 0x8224E2F8;
		  /* 8224E2F8h */ case   16:  		/* li R7, 1333 */
		/* 8224E2F8h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x535);
		/* 8224E2F8h case   16:*/		return 0x8224E2FC;
		  /* 8224E2FCh */ case   17:  		/* li R3, 0 */
		/* 8224E2FCh case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224E2FCh case   17:*/		return 0x8224E300;
		  /* 8224E300h */ case   18:  		/* bl -1009400 */
		/* 8224E300h case   18:*/		regs.LR = 0x8224E304; return 0x82157C08;
		/* 8224E300h case   18:*/		return 0x8224E304;
	}
	return 0x8224E304;
} // Block from 8224E2B8h-8224E304h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8224E304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E304);
		  /* 8224E304h */ case    0:  		/* addi R3, R20, 60 */
		/* 8224E304h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R20,0x3C);
		/* 8224E304h case    0:*/		return 0x8224E308;
		  /* 8224E308h */ case    1:  		/* bl 21624 */
		/* 8224E308h case    1:*/		regs.LR = 0x8224E30C; return 0x82253780;
		/* 8224E308h case    1:*/		return 0x8224E30C;
		  /* 8224E30Ch */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224E30Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224E30Ch case    2:*/		return 0x8224E310;
		  /* 8224E310h */ case    3:  		/* bc 4, CR0_EQ, 32 */
		/* 8224E310h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8224E330;  }
		/* 8224E310h case    3:*/		return 0x8224E314;
		  /* 8224E314h */ case    4:  		/* lis R11, -32252 */
		/* 8224E314h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224E314h case    4:*/		return 0x8224E318;
		  /* 8224E318h */ case    5:  		/* mr R6, R24 */
		/* 8224E318h case    5:*/		regs.R6 = regs.R24;
		/* 8224E318h case    5:*/		return 0x8224E31C;
		  /* 8224E31Ch */ case    6:  		/* addi R5, R11, 15524 */
		/* 8224E31Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3CA4);
		/* 8224E31Ch case    6:*/		return 0x8224E320;
		  /* 8224E320h */ case    7:  		/* mr R4, R25 */
		/* 8224E320h case    7:*/		regs.R4 = regs.R25;
		/* 8224E320h case    7:*/		return 0x8224E324;
		  /* 8224E324h */ case    8:  		/* li R7, 1334 */
		/* 8224E324h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x536);
		/* 8224E324h case    8:*/		return 0x8224E328;
		  /* 8224E328h */ case    9:  		/* li R3, 0 */
		/* 8224E328h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224E328h case    9:*/		return 0x8224E32C;
		  /* 8224E32Ch */ case   10:  		/* bl -1009444 */
		/* 8224E32Ch case   10:*/		regs.LR = 0x8224E330; return 0x82157C08;
		/* 8224E32Ch case   10:*/		return 0x8224E330;
	}
	return 0x8224E330;
} // Block from 8224E304h-8224E330h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224E330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E330);
		  /* 8224E330h */ case    0:  		/* addi R3, R20, 84 */
		/* 8224E330h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R20,0x54);
		/* 8224E330h case    0:*/		return 0x8224E334;
		  /* 8224E334h */ case    1:  		/* bl 21580 */
		/* 8224E334h case    1:*/		regs.LR = 0x8224E338; return 0x82253780;
		/* 8224E334h case    1:*/		return 0x8224E338;
		  /* 8224E338h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224E338h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224E338h case    2:*/		return 0x8224E33C;
		  /* 8224E33Ch */ case    3:  		/* bc 4, CR0_EQ, 32 */
		/* 8224E33Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8224E35C;  }
		/* 8224E33Ch case    3:*/		return 0x8224E340;
		  /* 8224E340h */ case    4:  		/* lis R11, -32252 */
		/* 8224E340h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224E340h case    4:*/		return 0x8224E344;
		  /* 8224E344h */ case    5:  		/* mr R6, R24 */
		/* 8224E344h case    5:*/		regs.R6 = regs.R24;
		/* 8224E344h case    5:*/		return 0x8224E348;
		  /* 8224E348h */ case    6:  		/* addi R5, R11, 15500 */
		/* 8224E348h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3C8C);
		/* 8224E348h case    6:*/		return 0x8224E34C;
		  /* 8224E34Ch */ case    7:  		/* mr R4, R25 */
		/* 8224E34Ch case    7:*/		regs.R4 = regs.R25;
		/* 8224E34Ch case    7:*/		return 0x8224E350;
		  /* 8224E350h */ case    8:  		/* li R7, 1335 */
		/* 8224E350h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x537);
		/* 8224E350h case    8:*/		return 0x8224E354;
		  /* 8224E354h */ case    9:  		/* li R3, 0 */
		/* 8224E354h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224E354h case    9:*/		return 0x8224E358;
		  /* 8224E358h */ case   10:  		/* bl -1009488 */
		/* 8224E358h case   10:*/		regs.LR = 0x8224E35C; return 0x82157C08;
		/* 8224E358h case   10:*/		return 0x8224E35C;
	}
	return 0x8224E35C;
} // Block from 8224E330h-8224E35Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224E35Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E35C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E35C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E35C);
		  /* 8224E35Ch */ case    0:  		/* lwz R11, <#[R20 + 24]> */
		/* 8224E35Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000018) );
		/* 8224E35Ch case    0:*/		return 0x8224E360;
		  /* 8224E360h */ case    1:  		/* li R19, 0 */
		/* 8224E360h case    1:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 8224E360h case    1:*/		return 0x8224E364;
		  /* 8224E364h */ case    2:  		/* mr R27, R19 */
		/* 8224E364h case    2:*/		regs.R27 = regs.R19;
		/* 8224E364h case    2:*/		return 0x8224E368;
		  /* 8224E368h */ case    3:  		/* lwz R21, <#[R11 + 4]> */
		/* 8224E368h case    3:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R11 + 0x00000004) );
		/* 8224E368h case    3:*/		return 0x8224E36C;
		  /* 8224E36Ch */ case    4:  		/* cmpwi CR6, R21, 0 */
		/* 8224E36Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 8224E36Ch case    4:*/		return 0x8224E370;
		  /* 8224E370h */ case    5:  		/* bc 4, CR6_GT, 324 */
		/* 8224E370h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8224E4B4;  }
		/* 8224E370h case    5:*/		return 0x8224E374;
		  /* 8224E374h */ case    6:  		/* lis R10, -32252 */
		/* 8224E374h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224E374h case    6:*/		return 0x8224E378;
		  /* 8224E378h */ case    7:  		/* lis R11, -32252 */
		/* 8224E378h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224E378h case    7:*/		return 0x8224E37C;
		  /* 8224E37Ch */ case    8:  		/* mr R26, R19 */
		/* 8224E37Ch case    8:*/		regs.R26 = regs.R19;
		/* 8224E37Ch case    8:*/		return 0x8224E380;
		  /* 8224E380h */ case    9:  		/* addi R23, R10, 15300 */
		/* 8224E380h case    9:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R10,0x3BC4);
		/* 8224E380h case    9:*/		return 0x8224E384;
		  /* 8224E384h */ case   10:  		/* addi R22, R11, 14684 */
		/* 8224E384h case   10:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R11,0x395C);
		/* 8224E384h case   10:*/		return 0x8224E388;
		  /* 8224E388h */ case   11:  		/* lwz R3, <#[R20 + 24]> */
		/* 8224E388h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R20 + 0x00000018) );
		/* 8224E388h case   11:*/		return 0x8224E38C;
		  /* 8224E38Ch */ case   12:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224E38Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224E38Ch case   12:*/		return 0x8224E390;
		  /* 8224E390h */ case   13:  		/* cmplw CR6, R27, R11 */
		/* 8224E390h case   13:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 8224E390h case   13:*/		return 0x8224E394;
		  /* 8224E394h */ case   14:  		/* bc 4, CR6_LT, 16 */
		/* 8224E394h case   14:*/		if ( !regs.CR[6].lt ) { return 0x8224E3A4;  }
		/* 8224E394h case   14:*/		return 0x8224E398;
		  /* 8224E398h */ case   15:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224E398h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224E398h case   15:*/		return 0x8224E39C;
		  /* 8224E39Ch */ case   16:  		/* add R3, R11, R26 */
		/* 8224E39Ch case   16:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 8224E39Ch case   16:*/		return 0x8224E3A0;
		  /* 8224E3A0h */ case   17:  		/* b 12 */
		/* 8224E3A0h case   17:*/		return 0x8224E3AC;
		/* 8224E3A0h case   17:*/		return 0x8224E3A4;
	}
	return 0x8224E3A4;
} // Block from 8224E35Ch-8224E3A4h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8224E3A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E3A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E3A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E3A4);
		  /* 8224E3A4h */ case    0:  		/* mr R4, R27 */
		/* 8224E3A4h case    0:*/		regs.R4 = regs.R27;
		/* 8224E3A4h case    0:*/		return 0x8224E3A8;
		  /* 8224E3A8h */ case    1:  		/* bl 22296 */
		/* 8224E3A8h case    1:*/		regs.LR = 0x8224E3AC; return 0x82253AC0;
		/* 8224E3A8h case    1:*/		return 0x8224E3AC;
	}
	return 0x8224E3AC;
} // Block from 8224E3A4h-8224E3ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224E3ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E3AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E3AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E3AC);
		  /* 8224E3ACh */ case    0:  		/* lwz R30, <#[R3]> */
		/* 8224E3ACh case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224E3ACh case    0:*/		return 0x8224E3B0;
		  /* 8224E3B0h */ case    1:  		/* lwz R11, <#[R30 + 40]> */
		/* 8224E3B0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 8224E3B0h case    1:*/		return 0x8224E3B4;
		  /* 8224E3B4h */ case    2:  		/* stw R19, <#[R11 + 892]> */
		/* 8224E3B4h case    2:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x0000037C) );
		/* 8224E3B4h case    2:*/		return 0x8224E3B8;
		  /* 8224E3B8h */ case    3:  		/* lwz R11, <#[R30 + 36]> */
		/* 8224E3B8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 8224E3B8h case    3:*/		return 0x8224E3BC;
		  /* 8224E3BCh */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 8224E3BCh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224E3BCh case    4:*/		return 0x8224E3C0;
		  /* 8224E3C0h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 8224E3C0h case    5:*/		if ( regs.CR[6].eq ) { return 0x8224E3DC;  }
		/* 8224E3C0h case    5:*/		return 0x8224E3C4;
		  /* 8224E3C4h */ case    6:  		/* mr R6, R24 */
		/* 8224E3C4h case    6:*/		regs.R6 = regs.R24;
		/* 8224E3C4h case    6:*/		return 0x8224E3C8;
		  /* 8224E3C8h */ case    7:  		/* mr R5, R22 */
		/* 8224E3C8h case    7:*/		regs.R5 = regs.R22;
		/* 8224E3C8h case    7:*/		return 0x8224E3CC;
		  /* 8224E3CCh */ case    8:  		/* mr R4, R25 */
		/* 8224E3CCh case    8:*/		regs.R4 = regs.R25;
		/* 8224E3CCh case    8:*/		return 0x8224E3D0;
		  /* 8224E3D0h */ case    9:  		/* li R7, 1342 */
		/* 8224E3D0h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x53E);
		/* 8224E3D0h case    9:*/		return 0x8224E3D4;
		  /* 8224E3D4h */ case   10:  		/* li R3, 0 */
		/* 8224E3D4h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224E3D4h case   10:*/		return 0x8224E3D8;
		  /* 8224E3D8h */ case   11:  		/* bl -1009616 */
		/* 8224E3D8h case   11:*/		regs.LR = 0x8224E3DC; return 0x82157C08;
		/* 8224E3D8h case   11:*/		return 0x8224E3DC;
	}
	return 0x8224E3DC;
} // Block from 8224E3ACh-8224E3DCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224E3DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E3DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E3DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E3DC);
		  /* 8224E3DCh */ case    0:  		/* lwz R11, <#[R30 + 28]> */
		/* 8224E3DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 8224E3DCh case    0:*/		return 0x8224E3E0;
		  /* 8224E3E0h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224E3E0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224E3E0h case    1:*/		return 0x8224E3E4;
		  /* 8224E3E4h */ case    2:  		/* bc 4, CR6_LT, 28 */
		/* 8224E3E4h case    2:*/		if ( !regs.CR[6].lt ) { return 0x8224E400;  }
		/* 8224E3E4h case    2:*/		return 0x8224E3E8;
		  /* 8224E3E8h */ case    3:  		/* mr R6, R24 */
		/* 8224E3E8h case    3:*/		regs.R6 = regs.R24;
		/* 8224E3E8h case    3:*/		return 0x8224E3EC;
		  /* 8224E3ECh */ case    4:  		/* mr R5, R23 */
		/* 8224E3ECh case    4:*/		regs.R5 = regs.R23;
		/* 8224E3ECh case    4:*/		return 0x8224E3F0;
		  /* 8224E3F0h */ case    5:  		/* mr R4, R25 */
		/* 8224E3F0h case    5:*/		regs.R4 = regs.R25;
		/* 8224E3F0h case    5:*/		return 0x8224E3F4;
		  /* 8224E3F4h */ case    6:  		/* li R7, 1343 */
		/* 8224E3F4h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x53F);
		/* 8224E3F4h case    6:*/		return 0x8224E3F8;
		  /* 8224E3F8h */ case    7:  		/* li R3, 0 */
		/* 8224E3F8h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224E3F8h case    7:*/		return 0x8224E3FC;
		  /* 8224E3FCh */ case    8:  		/* bl -1009652 */
		/* 8224E3FCh case    8:*/		regs.LR = 0x8224E400; return 0x82157C08;
		/* 8224E3FCh case    8:*/		return 0x8224E400;
	}
	return 0x8224E400;
} // Block from 8224E3DCh-8224E400h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224E400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E400);
		  /* 8224E400h */ case    0:  		/* lwz R11, <#[R30 + 48]> */
		/* 8224E400h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 8224E400h case    0:*/		return 0x8224E404;
		  /* 8224E404h */ case    1:  		/* mr R31, R19 */
		/* 8224E404h case    1:*/		regs.R31 = regs.R19;
		/* 8224E404h case    1:*/		return 0x8224E408;
		  /* 8224E408h */ case    2:  		/* lwz R28, <#[R11 + 4]> */
		/* 8224E408h case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000004) );
		/* 8224E408h case    2:*/		return 0x8224E40C;
		  /* 8224E40Ch */ case    3:  		/* cmpwi CR6, R28, 0 */
		/* 8224E40Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 8224E40Ch case    3:*/		return 0x8224E410;
		  /* 8224E410h */ case    4:  		/* bc 4, CR6_GT, 84 */
		/* 8224E410h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8224E464;  }
		/* 8224E410h case    4:*/		return 0x8224E414;
		  /* 8224E414h */ case    5:  		/* mr R29, R19 */
		/* 8224E414h case    5:*/		regs.R29 = regs.R19;
		/* 8224E414h case    5:*/		return 0x8224E418;
		  /* 8224E418h */ case    6:  		/* lwz R3, <#[R30 + 48]> */
		/* 8224E418h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 8224E418h case    6:*/		return 0x8224E41C;
		  /* 8224E41Ch */ case    7:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224E41Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224E41Ch case    7:*/		return 0x8224E420;
		  /* 8224E420h */ case    8:  		/* cmplw CR6, R31, R11 */
		/* 8224E420h case    8:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8224E420h case    8:*/		return 0x8224E424;
		  /* 8224E424h */ case    9:  		/* bc 4, CR6_LT, 16 */
		/* 8224E424h case    9:*/		if ( !regs.CR[6].lt ) { return 0x8224E434;  }
		/* 8224E424h case    9:*/		return 0x8224E428;
		  /* 8224E428h */ case   10:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224E428h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224E428h case   10:*/		return 0x8224E42C;
		  /* 8224E42Ch */ case   11:  		/* add R3, R11, R29 */
		/* 8224E42Ch case   11:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 8224E42Ch case   11:*/		return 0x8224E430;
		  /* 8224E430h */ case   12:  		/* b 12 */
		/* 8224E430h case   12:*/		return 0x8224E43C;
		/* 8224E430h case   12:*/		return 0x8224E434;
	}
	return 0x8224E434;
} // Block from 8224E400h-8224E434h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224E434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E434);
		  /* 8224E434h */ case    0:  		/* mr R4, R31 */
		/* 8224E434h case    0:*/		regs.R4 = regs.R31;
		/* 8224E434h case    0:*/		return 0x8224E438;
		  /* 8224E438h */ case    1:  		/* bl 22152 */
		/* 8224E438h case    1:*/		regs.LR = 0x8224E43C; return 0x82253AC0;
		/* 8224E438h case    1:*/		return 0x8224E43C;
	}
	return 0x8224E43C;
} // Block from 8224E434h-8224E43Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224E43Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E43C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E43C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E43C);
		  /* 8224E43Ch */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224E43Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224E43Ch case    0:*/		return 0x8224E440;
		  /* 8224E440h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8224E440h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224E440h case    1:*/		return 0x8224E444;
		  /* 8224E444h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8224E444h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224E454;  }
		/* 8224E444h case    2:*/		return 0x8224E448;
		  /* 8224E448h */ case    3:  		/* addi R4, R11, -4 */
		/* 8224E448h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 8224E448h case    3:*/		return 0x8224E44C;
		  /* 8224E44Ch */ case    4:  		/* lwz R3, <#[R11 - 4]> */
		/* 8224E44Ch case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 8224E44Ch case    4:*/		return 0x8224E450;
		  /* 8224E450h */ case    5:  		/* bl -204304 */
		/* 8224E450h case    5:*/		regs.LR = 0x8224E454; return 0x8221C640;
		/* 8224E450h case    5:*/		return 0x8224E454;
	}
	return 0x8224E454;
} // Block from 8224E43Ch-8224E454h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224E454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E454);
		  /* 8224E454h */ case    0:  		/* addi R31, R31, 1 */
		/* 8224E454h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8224E454h case    0:*/		return 0x8224E458;
		  /* 8224E458h */ case    1:  		/* addi R29, R29, 4 */
		/* 8224E458h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8224E458h case    1:*/		return 0x8224E45C;
		  /* 8224E45Ch */ case    2:  		/* cmpw CR6, R31, R28 */
		/* 8224E45Ch case    2:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R28);
		/* 8224E45Ch case    2:*/		return 0x8224E460;
		  /* 8224E460h */ case    3:  		/* bc 12, CR6_LT, -72 */
		/* 8224E460h case    3:*/		if ( regs.CR[6].lt ) { return 0x8224E418;  }
		/* 8224E460h case    3:*/		return 0x8224E464;
	}
	return 0x8224E464;
} // Block from 8224E454h-8224E464h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224E464h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E464);
		  /* 8224E464h */ case    0:  		/* lwz R3, <#[R30 + 48]> */
		/* 8224E464h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 8224E464h case    0:*/		return 0x8224E468;
		  /* 8224E468h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8224E468h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8224E468h case    1:*/		return 0x8224E46C;
		  /* 8224E46Ch */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8224E46Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8224E478;  }
		/* 8224E46Ch case    2:*/		return 0x8224E470;
		  /* 8224E470h */ case    3:  		/* li R4, 1 */
		/* 8224E470h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224E470h case    3:*/		return 0x8224E474;
		  /* 8224E474h */ case    4:  		/* bl -59612 */
		/* 8224E474h case    4:*/		regs.LR = 0x8224E478; return 0x8223FB98;
		/* 8224E474h case    4:*/		return 0x8224E478;
	}
	return 0x8224E478;
} // Block from 8224E464h-8224E478h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224E478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E478);
		  /* 8224E478h */ case    0:  		/* lwz R3, <#[R30 + 52]> */
		/* 8224E478h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000034) );
		/* 8224E478h case    0:*/		return 0x8224E47C;
		  /* 8224E47Ch */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8224E47Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8224E47Ch case    1:*/		return 0x8224E480;
		  /* 8224E480h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8224E480h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224E48C;  }
		/* 8224E480h case    2:*/		return 0x8224E484;
		  /* 8224E484h */ case    3:  		/* li R4, 1 */
		/* 8224E484h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224E484h case    3:*/		return 0x8224E488;
		  /* 8224E488h */ case    4:  		/* bl -59632 */
		/* 8224E488h case    4:*/		regs.LR = 0x8224E48C; return 0x8223FB98;
		/* 8224E488h case    4:*/		return 0x8224E48C;
	}
	return 0x8224E48C;
} // Block from 8224E478h-8224E48Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224E48Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E48C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E48C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E48C);
		  /* 8224E48Ch */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8224E48Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8224E48Ch case    0:*/		return 0x8224E490;
		  /* 8224E490h */ case    1:  		/* li R4, 1 */
		/* 8224E490h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224E490h case    1:*/		return 0x8224E494;
		  /* 8224E494h */ case    2:  		/* mr R3, R30 */
		/* 8224E494h case    2:*/		regs.R3 = regs.R30;
		/* 8224E494h case    2:*/		return 0x8224E498;
		  /* 8224E498h */ case    3:  		/* lwz R11, <#[R11]> */
		/* 8224E498h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8224E498h case    3:*/		return 0x8224E49C;
		  /* 8224E49Ch */ case    4:  		/* mtspr CTR, R11 */
		/* 8224E49Ch case    4:*/		regs.CTR = regs.R11;
		/* 8224E49Ch case    4:*/		return 0x8224E4A0;
		  /* 8224E4A0h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 8224E4A0h case    5:*/		if ( 1 ) { regs.LR = 0x8224E4A4; return (uint32)regs.CTR; }
		/* 8224E4A0h case    5:*/		return 0x8224E4A4;
		  /* 8224E4A4h */ case    6:  		/* addi R27, R27, 1 */
		/* 8224E4A4h case    6:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8224E4A4h case    6:*/		return 0x8224E4A8;
		  /* 8224E4A8h */ case    7:  		/* addi R26, R26, 4 */
		/* 8224E4A8h case    7:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 8224E4A8h case    7:*/		return 0x8224E4AC;
		  /* 8224E4ACh */ case    8:  		/* cmpw CR6, R27, R21 */
		/* 8224E4ACh case    8:*/		cpu::op::cmpw<6>(regs,regs.R27,regs.R21);
		/* 8224E4ACh case    8:*/		return 0x8224E4B0;
		  /* 8224E4B0h */ case    9:  		/* bc 12, CR6_LT, -296 */
		/* 8224E4B0h case    9:*/		if ( regs.CR[6].lt ) { return 0x8224E388;  }
		/* 8224E4B0h case    9:*/		return 0x8224E4B4;
	}
	return 0x8224E4B4;
} // Block from 8224E48Ch-8224E4B4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224E4B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E4B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E4B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E4B4);
		  /* 8224E4B4h */ case    0:  		/* lwz R11, <#[R20 + 20]> */
		/* 8224E4B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000014) );
		/* 8224E4B4h case    0:*/		return 0x8224E4B8;
		  /* 8224E4B8h */ case    1:  		/* mr R27, R19 */
		/* 8224E4B8h case    1:*/		regs.R27 = regs.R19;
		/* 8224E4B8h case    1:*/		return 0x8224E4BC;
		  /* 8224E4BCh */ case    2:  		/* lwz R25, <#[R11 + 4]> */
		/* 8224E4BCh case    2:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R11 + 0x00000004) );
		/* 8224E4BCh case    2:*/		return 0x8224E4C0;
		  /* 8224E4C0h */ case    3:  		/* cmpwi CR6, R25, 0 */
		/* 8224E4C0h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 8224E4C0h case    3:*/		return 0x8224E4C4;
		  /* 8224E4C4h */ case    4:  		/* bc 4, CR6_GT, 228 */
		/* 8224E4C4h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8224E5A8;  }
		/* 8224E4C4h case    4:*/		return 0x8224E4C8;
	}
	return 0x8224E4C8;
} // Block from 8224E4B4h-8224E4C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224E4C8h
// Function '?EnableDepSuccessors@Scheduler@XGRAPHICS@@AAAXPAVSchedNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E4C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E4C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E4C8);
		  /* 8224E4C8h */ case    0:  		/* mr R26, R19 */
		/* 8224E4C8h case    0:*/		regs.R26 = regs.R19;
		/* 8224E4C8h case    0:*/		return 0x8224E4CC;
		  /* 8224E4CCh */ case    1:  		/* lwz R3, <#[R20 + 20]> */
		/* 8224E4CCh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R20 + 0x00000014) );
		/* 8224E4CCh case    1:*/		return 0x8224E4D0;
		  /* 8224E4D0h */ case    2:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224E4D0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224E4D0h case    2:*/		return 0x8224E4D4;
		  /* 8224E4D4h */ case    3:  		/* cmplw CR6, R27, R11 */
		/* 8224E4D4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 8224E4D4h case    3:*/		return 0x8224E4D8;
		  /* 8224E4D8h */ case    4:  		/* bc 4, CR6_LT, 16 */
		/* 8224E4D8h case    4:*/		if ( !regs.CR[6].lt ) { return 0x8224E4E8;  }
		/* 8224E4D8h case    4:*/		return 0x8224E4DC;
		  /* 8224E4DCh */ case    5:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224E4DCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224E4DCh case    5:*/		return 0x8224E4E0;
		  /* 8224E4E0h */ case    6:  		/* add R3, R11, R26 */
		/* 8224E4E0h case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 8224E4E0h case    6:*/		return 0x8224E4E4;
		  /* 8224E4E4h */ case    7:  		/* b 12 */
		/* 8224E4E4h case    7:*/		return 0x8224E4F0;
		/* 8224E4E4h case    7:*/		return 0x8224E4E8;
	}
	return 0x8224E4E8;
} // Block from 8224E4C8h-8224E4E8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224E4E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E4E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E4E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E4E8);
		  /* 8224E4E8h */ case    0:  		/* mr R4, R27 */
		/* 8224E4E8h case    0:*/		regs.R4 = regs.R27;
		/* 8224E4E8h case    0:*/		return 0x8224E4EC;
		  /* 8224E4ECh */ case    1:  		/* bl 21972 */
		/* 8224E4ECh case    1:*/		regs.LR = 0x8224E4F0; return 0x82253AC0;
		/* 8224E4ECh case    1:*/		return 0x8224E4F0;
	}
	return 0x8224E4F0;
} // Block from 8224E4E8h-8224E4F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224E4F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E4F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E4F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E4F0);
		  /* 8224E4F0h */ case    0:  		/* lwz R30, <#[R3]> */
		/* 8224E4F0h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224E4F0h case    0:*/		return 0x8224E4F4;
		  /* 8224E4F4h */ case    1:  		/* mr R31, R19 */
		/* 8224E4F4h case    1:*/		regs.R31 = regs.R19;
		/* 8224E4F4h case    1:*/		return 0x8224E4F8;
		  /* 8224E4F8h */ case    2:  		/* lwz R11, <#[R30 + 48]> */
		/* 8224E4F8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 8224E4F8h case    2:*/		return 0x8224E4FC;
		  /* 8224E4FCh */ case    3:  		/* lwz R28, <#[R11 + 4]> */
		/* 8224E4FCh case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000004) );
		/* 8224E4FCh case    3:*/		return 0x8224E500;
		  /* 8224E500h */ case    4:  		/* cmpwi CR6, R28, 0 */
		/* 8224E500h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 8224E500h case    4:*/		return 0x8224E504;
		  /* 8224E504h */ case    5:  		/* bc 4, CR6_GT, 84 */
		/* 8224E504h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8224E558;  }
		/* 8224E504h case    5:*/		return 0x8224E508;
		  /* 8224E508h */ case    6:  		/* mr R29, R19 */
		/* 8224E508h case    6:*/		regs.R29 = regs.R19;
		/* 8224E508h case    6:*/		return 0x8224E50C;
		  /* 8224E50Ch */ case    7:  		/* lwz R3, <#[R30 + 48]> */
		/* 8224E50Ch case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 8224E50Ch case    7:*/		return 0x8224E510;
		  /* 8224E510h */ case    8:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224E510h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224E510h case    8:*/		return 0x8224E514;
		  /* 8224E514h */ case    9:  		/* cmplw CR6, R31, R11 */
		/* 8224E514h case    9:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8224E514h case    9:*/		return 0x8224E518;
		  /* 8224E518h */ case   10:  		/* bc 4, CR6_LT, 16 */
		/* 8224E518h case   10:*/		if ( !regs.CR[6].lt ) { return 0x8224E528;  }
		/* 8224E518h case   10:*/		return 0x8224E51C;
		  /* 8224E51Ch */ case   11:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224E51Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224E51Ch case   11:*/		return 0x8224E520;
		  /* 8224E520h */ case   12:  		/* add R3, R11, R29 */
		/* 8224E520h case   12:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 8224E520h case   12:*/		return 0x8224E524;
		  /* 8224E524h */ case   13:  		/* b 12 */
		/* 8224E524h case   13:*/		return 0x8224E530;
		/* 8224E524h case   13:*/		return 0x8224E528;
	}
	return 0x8224E528;
} // Block from 8224E4F0h-8224E528h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224E528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E528);
		  /* 8224E528h */ case    0:  		/* mr R4, R31 */
		/* 8224E528h case    0:*/		regs.R4 = regs.R31;
		/* 8224E528h case    0:*/		return 0x8224E52C;
		  /* 8224E52Ch */ case    1:  		/* bl 21908 */
		/* 8224E52Ch case    1:*/		regs.LR = 0x8224E530; return 0x82253AC0;
		/* 8224E52Ch case    1:*/		return 0x8224E530;
	}
	return 0x8224E530;
} // Block from 8224E528h-8224E530h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224E530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E530);
		  /* 8224E530h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224E530h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224E530h case    0:*/		return 0x8224E534;
		  /* 8224E534h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8224E534h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224E534h case    1:*/		return 0x8224E538;
		  /* 8224E538h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8224E538h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224E548;  }
		/* 8224E538h case    2:*/		return 0x8224E53C;
		  /* 8224E53Ch */ case    3:  		/* addi R4, R11, -4 */
		/* 8224E53Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 8224E53Ch case    3:*/		return 0x8224E540;
		  /* 8224E540h */ case    4:  		/* lwz R3, <#[R11 - 4]> */
		/* 8224E540h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 8224E540h case    4:*/		return 0x8224E544;
		  /* 8224E544h */ case    5:  		/* bl -204548 */
		/* 8224E544h case    5:*/		regs.LR = 0x8224E548; return 0x8221C640;
		/* 8224E544h case    5:*/		return 0x8224E548;
	}
	return 0x8224E548;
} // Block from 8224E530h-8224E548h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224E548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E548);
		  /* 8224E548h */ case    0:  		/* addi R31, R31, 1 */
		/* 8224E548h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8224E548h case    0:*/		return 0x8224E54C;
		  /* 8224E54Ch */ case    1:  		/* addi R29, R29, 4 */
		/* 8224E54Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8224E54Ch case    1:*/		return 0x8224E550;
		  /* 8224E550h */ case    2:  		/* cmpw CR6, R31, R28 */
		/* 8224E550h case    2:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R28);
		/* 8224E550h case    2:*/		return 0x8224E554;
		  /* 8224E554h */ case    3:  		/* bc 12, CR6_LT, -72 */
		/* 8224E554h case    3:*/		if ( regs.CR[6].lt ) { return 0x8224E50C;  }
		/* 8224E554h case    3:*/		return 0x8224E558;
	}
	return 0x8224E558;
} // Block from 8224E548h-8224E558h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224E558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E558);
		  /* 8224E558h */ case    0:  		/* lwz R3, <#[R30 + 48]> */
		/* 8224E558h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 8224E558h case    0:*/		return 0x8224E55C;
		  /* 8224E55Ch */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8224E55Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8224E55Ch case    1:*/		return 0x8224E560;
		  /* 8224E560h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8224E560h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224E56C;  }
		/* 8224E560h case    2:*/		return 0x8224E564;
		  /* 8224E564h */ case    3:  		/* li R4, 1 */
		/* 8224E564h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224E564h case    3:*/		return 0x8224E568;
		  /* 8224E568h */ case    4:  		/* bl -59856 */
		/* 8224E568h case    4:*/		regs.LR = 0x8224E56C; return 0x8223FB98;
		/* 8224E568h case    4:*/		return 0x8224E56C;
	}
	return 0x8224E56C;
} // Block from 8224E558h-8224E56Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224E56Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E56C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E56C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E56C);
		  /* 8224E56Ch */ case    0:  		/* lwz R3, <#[R30 + 52]> */
		/* 8224E56Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000034) );
		/* 8224E56Ch case    0:*/		return 0x8224E570;
		  /* 8224E570h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8224E570h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8224E570h case    1:*/		return 0x8224E574;
		  /* 8224E574h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8224E574h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224E580;  }
		/* 8224E574h case    2:*/		return 0x8224E578;
		  /* 8224E578h */ case    3:  		/* li R4, 1 */
		/* 8224E578h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224E578h case    3:*/		return 0x8224E57C;
		  /* 8224E57Ch */ case    4:  		/* bl -59876 */
		/* 8224E57Ch case    4:*/		regs.LR = 0x8224E580; return 0x8223FB98;
		/* 8224E57Ch case    4:*/		return 0x8224E580;
	}
	return 0x8224E580;
} // Block from 8224E56Ch-8224E580h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224E580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E580);
		  /* 8224E580h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8224E580h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8224E580h case    0:*/		return 0x8224E584;
		  /* 8224E584h */ case    1:  		/* li R4, 1 */
		/* 8224E584h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224E584h case    1:*/		return 0x8224E588;
		  /* 8224E588h */ case    2:  		/* mr R3, R30 */
		/* 8224E588h case    2:*/		regs.R3 = regs.R30;
		/* 8224E588h case    2:*/		return 0x8224E58C;
		  /* 8224E58Ch */ case    3:  		/* lwz R11, <#[R11]> */
		/* 8224E58Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8224E58Ch case    3:*/		return 0x8224E590;
		  /* 8224E590h */ case    4:  		/* mtspr CTR, R11 */
		/* 8224E590h case    4:*/		regs.CTR = regs.R11;
		/* 8224E590h case    4:*/		return 0x8224E594;
		  /* 8224E594h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 8224E594h case    5:*/		if ( 1 ) { regs.LR = 0x8224E598; return (uint32)regs.CTR; }
		/* 8224E594h case    5:*/		return 0x8224E598;
		  /* 8224E598h */ case    6:  		/* addi R27, R27, 1 */
		/* 8224E598h case    6:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8224E598h case    6:*/		return 0x8224E59C;
		  /* 8224E59Ch */ case    7:  		/* addi R26, R26, 4 */
		/* 8224E59Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 8224E59Ch case    7:*/		return 0x8224E5A0;
		  /* 8224E5A0h */ case    8:  		/* cmpw CR6, R27, R25 */
		/* 8224E5A0h case    8:*/		cpu::op::cmpw<6>(regs,regs.R27,regs.R25);
		/* 8224E5A0h case    8:*/		return 0x8224E5A4;
		  /* 8224E5A4h */ case    9:  		/* bc 12, CR6_LT, -216 */
		/* 8224E5A4h case    9:*/		if ( regs.CR[6].lt ) { return 0x8224E4CC;  }
		/* 8224E5A4h case    9:*/		return 0x8224E5A8;
	}
	return 0x8224E5A8;
} // Block from 8224E580h-8224E5A8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224E5A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E5A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E5A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E5A8);
		  /* 8224E5A8h */ case    0:  		/* lwz R11, <#[R20 + 24]> */
		/* 8224E5A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000018) );
		/* 8224E5A8h case    0:*/		return 0x8224E5AC;
		  /* 8224E5ACh */ case    1:  		/* stw R19, <#[R11 + 4]> */
		/* 8224E5ACh case    1:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000004) );
		/* 8224E5ACh case    1:*/		return 0x8224E5B0;
		  /* 8224E5B0h */ case    2:  		/* lwz R11, <#[R20 + 20]> */
		/* 8224E5B0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000014) );
		/* 8224E5B0h case    2:*/		return 0x8224E5B4;
		  /* 8224E5B4h */ case    3:  		/* stw R19, <#[R11 + 4]> */
		/* 8224E5B4h case    3:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000004) );
		/* 8224E5B4h case    3:*/		return 0x8224E5B8;
		  /* 8224E5B8h */ case    4:  		/* addi R1, R1, 192 */
		/* 8224E5B8h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 8224E5B8h case    4:*/		return 0x8224E5BC;
		  /* 8224E5BCh */ case    5:  		/* b -1823544 */
		/* 8224E5BCh case    5:*/		return 0x82091284;
		/* 8224E5BCh case    5:*/		return 0x8224E5C0;
	}
	return 0x8224E5C0;
} // Block from 8224E5A8h-8224E5C0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224E5C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E5C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E5C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E5C0);
		  /* 8224E5C0h */ case    0:  		/* mfspr R12, LR */
		/* 8224E5C0h case    0:*/		regs.R12 = regs.LR;
		/* 8224E5C0h case    0:*/		return 0x8224E5C4;
		  /* 8224E5C4h */ case    1:  		/* bl -1823640 */
		/* 8224E5C4h case    1:*/		regs.LR = 0x8224E5C8; return 0x8209122C;
		/* 8224E5C4h case    1:*/		return 0x8224E5C8;
		  /* 8224E5C8h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 8224E5C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 8224E5C8h case    2:*/		return 0x8224E5CC;
		  /* 8224E5CCh */ case    3:  		/* lwz R26, <#[R3 + 44]> */
		/* 8224E5CCh case    3:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R3 + 0x0000002C) );
		/* 8224E5CCh case    3:*/		return 0x8224E5D0;
		  /* 8224E5D0h */ case    4:  		/* lis R11, -32253 */
		/* 8224E5D0h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8224E5D0h case    4:*/		return 0x8224E5D4;
		  /* 8224E5D4h */ case    5:  		/* lis R10, -32252 */
		/* 8224E5D4h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224E5D4h case    5:*/		return 0x8224E5D8;
		  /* 8224E5D8h */ case    6:  		/* addi R18, R11, 27460 */
		/* 8224E5D8h case    6:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R11,0x6B44);
		/* 8224E5D8h case    6:*/		return 0x8224E5DC;
		  /* 8224E5DCh */ case    7:  		/* mr R24, R3 */
		/* 8224E5DCh case    7:*/		regs.R24 = regs.R3;
		/* 8224E5DCh case    7:*/		return 0x8224E5E0;
		  /* 8224E5E0h */ case    8:  		/* li R19, 0 */
		/* 8224E5E0h case    8:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 8224E5E0h case    8:*/		return 0x8224E5E4;
		  /* 8224E5E4h */ case    9:  		/* lwz R11, <#[R26 + 8]> */
		/* 8224E5E4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 8224E5E4h case    9:*/		return 0x8224E5E8;
		  /* 8224E5E8h */ case   10:  		/* addi R17, R10, 14208 */
		/* 8224E5E8h case   10:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R10,0x3780);
		/* 8224E5E8h case   10:*/		return 0x8224E5EC;
		  /* 8224E5ECh */ case   11:  		/* cmpwi CR6, R11, 0 */
		/* 8224E5ECh case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224E5ECh case   11:*/		return 0x8224E5F0;
		  /* 8224E5F0h */ case   12:  		/* bc 12, CR6_EQ, 808 */
		/* 8224E5F0h case   12:*/		if ( regs.CR[6].eq ) { return 0x8224E918;  }
		/* 8224E5F0h case   12:*/		return 0x8224E5F4;
		  /* 8224E5F4h */ case   13:  		/* lis R11, -32216 */
		/* 8224E5F4h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 8224E5F4h case   13:*/		return 0x8224E5F8;
		  /* 8224E5F8h */ case   14:  		/* lis R10, -32252 */
		/* 8224E5F8h case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224E5F8h case   14:*/		return 0x8224E5FC;
		  /* 8224E5FCh */ case   15:  		/* addi R21, R11, 17992 */
		/* 8224E5FCh case   15:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R11,0x4648);
		/* 8224E5FCh case   15:*/		return 0x8224E600;
		  /* 8224E600h */ case   16:  		/* addi R20, R10, 15696 */
		/* 8224E600h case   16:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R10,0x3D50);
		/* 8224E600h case   16:*/		return 0x8224E604;
		  /* 8224E604h */ case   17:  		/* lwz R31, <#[R26 + 40]> */
		/* 8224E604h case   17:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R26 + 0x00000028) );
		/* 8224E604h case   17:*/		return 0x8224E608;
		  /* 8224E608h */ case   18:  		/* mr R3, R31 */
		/* 8224E608h case   18:*/		regs.R3 = regs.R31;
		/* 8224E608h case   18:*/		return 0x8224E60C;
		  /* 8224E60Ch */ case   19:  		/* lwz R11, <#[R31]> */
		/* 8224E60Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224E60Ch case   19:*/		return 0x8224E610;
		  /* 8224E610h */ case   20:  		/* lwz R11, <#[R11 + 68]> */
		/* 8224E610h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000044) );
		/* 8224E610h case   20:*/		return 0x8224E614;
		  /* 8224E614h */ case   21:  		/* mtspr CTR, R11 */
		/* 8224E614h case   21:*/		regs.CTR = regs.R11;
		/* 8224E614h case   21:*/		return 0x8224E618;
		  /* 8224E618h */ case   22:  		/* bcctrl 20, CR0_LT */
		/* 8224E618h case   22:*/		if ( 1 ) { regs.LR = 0x8224E61C; return (uint32)regs.CTR; }
		/* 8224E618h case   22:*/		return 0x8224E61C;
		  /* 8224E61Ch */ case   23:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224E61Ch case   23:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224E61Ch case   23:*/		return 0x8224E620;
		  /* 8224E620h */ case   24:  		/* bc 12, CR0_EQ, 96 */
		/* 8224E620h case   24:*/		if ( regs.CR[0].eq ) { return 0x8224E680;  }
		/* 8224E620h case   24:*/		return 0x8224E624;
		  /* 8224E624h */ case   25:  		/* lwz R11, <#[R24 + 120]> */
		/* 8224E624h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000078) );
		/* 8224E624h case   25:*/		return 0x8224E628;
		  /* 8224E628h */ case   26:  		/* cmplwi CR6, R11, 0 */
		/* 8224E628h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224E628h case   26:*/		return 0x8224E62C;
		  /* 8224E62Ch */ case   27:  		/* bc 12, CR6_EQ, 84 */
		/* 8224E62Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x8224E680;  }
		/* 8224E62Ch case   27:*/		return 0x8224E630;
		  /* 8224E630h */ case   28:  		/* lwz R10, <#[R24 + 12]> */
		/* 8224E630h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000000C) );
		/* 8224E630h case   28:*/		return 0x8224E634;
		  /* 8224E634h */ case   29:  		/* lwz R9, <#[R11 + 28]> */
		/* 8224E634h case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000001C) );
		/* 8224E634h case   29:*/		return 0x8224E638;
	}
	return 0x8224E638;
} // Block from 8224E5C0h-8224E638h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8224E638h
// Function '?CycleForward@Scheduler@XGRAPHICS@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E638);
		  /* 8224E638h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 8224E638h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8224E638h case    0:*/		return 0x8224E63C;
		  /* 8224E63Ch */ case    1:  		/* cmpw CR6, R9, R10 */
		/* 8224E63Ch case    1:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R10);
		/* 8224E63Ch case    1:*/		return 0x8224E640;
		  /* 8224E640h */ case    2:  		/* bc 12, CR6_LT, 64 */
		/* 8224E640h case    2:*/		if ( regs.CR[6].lt ) { return 0x8224E680;  }
		/* 8224E640h case    2:*/		return 0x8224E644;
		  /* 8224E644h */ case    3:  		/* mr R4, R31 */
		/* 8224E644h case    3:*/		regs.R4 = regs.R31;
		/* 8224E644h case    3:*/		return 0x8224E648;
		  /* 8224E648h */ case    4:  		/* lwz R3, <#[R11 + 40]> */
		/* 8224E648h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000028) );
		/* 8224E648h case    4:*/		return 0x8224E64C;
		  /* 8224E64Ch */ case    5:  		/* bl -10772 */
		/* 8224E64Ch case    5:*/		regs.LR = 0x8224E650; return 0x8224BC38;
		/* 8224E64Ch case    5:*/		return 0x8224E650;
		  /* 8224E650h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224E650h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224E650h case    6:*/		return 0x8224E654;
		  /* 8224E654h */ case    7:  		/* bc 12, CR0_EQ, 44 */
		/* 8224E654h case    7:*/		if ( regs.CR[0].eq ) { return 0x8224E680;  }
		/* 8224E654h case    7:*/		return 0x8224E658;
		  /* 8224E658h */ case    8:  		/* mr R3, R26 */
		/* 8224E658h case    8:*/		regs.R3 = regs.R26;
		/* 8224E658h case    8:*/		return 0x8224E65C;
		  /* 8224E65Ch */ case    9:  		/* bl 20908 */
		/* 8224E65Ch case    9:*/		regs.LR = 0x8224E660; return 0x82253808;
		/* 8224E65Ch case    9:*/		return 0x8224E660;
		  /* 8224E660h */ case   10:  		/* mr R4, R26 */
		/* 8224E660h case   10:*/		regs.R4 = regs.R26;
		/* 8224E660h case   10:*/		return 0x8224E664;
		  /* 8224E664h */ case   11:  		/* mr R3, R24 */
		/* 8224E664h case   11:*/		regs.R3 = regs.R24;
		/* 8224E664h case   11:*/		return 0x8224E668;
		  /* 8224E668h */ case   12:  		/* bl -2536 */
		/* 8224E668h case   12:*/		regs.LR = 0x8224E66C; return 0x8224DC80;
		/* 8224E668h case   12:*/		return 0x8224E66C;
		  /* 8224E66Ch */ case   13:  		/* lwz R4, <#[R24 + 120]> */
		/* 8224E66Ch case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R24 + 0x00000078) );
		/* 8224E66Ch case   13:*/		return 0x8224E670;
		  /* 8224E670h */ case   14:  		/* lwz R3, <#[R24 + 12]> */
		/* 8224E670h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x0000000C) );
		/* 8224E670h case   14:*/		return 0x8224E674;
		  /* 8224E674h */ case   15:  		/* bl -14756 */
		/* 8224E674h case   15:*/		regs.LR = 0x8224E678; return 0x8224ACD0;
		/* 8224E674h case   15:*/		return 0x8224E678;
		  /* 8224E678h */ case   16:  		/* lwz R26, <#[R24 + 44]> */
		/* 8224E678h case   16:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R24 + 0x0000002C) );
		/* 8224E678h case   16:*/		return 0x8224E67C;
		  /* 8224E67Ch */ case   17:  		/* b 656 */
		/* 8224E67Ch case   17:*/		return 0x8224E90C;
		/* 8224E67Ch case   17:*/		return 0x8224E680;
	}
	return 0x8224E680;
} // Block from 8224E638h-8224E680h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8224E680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E680);
		  /* 8224E680h */ case    0:  		/* lwz R11, <#[R26 + 60]> */
		/* 8224E680h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000003C) );
		/* 8224E680h case    0:*/		return 0x8224E684;
		  /* 8224E684h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224E684h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224E684h case    1:*/		return 0x8224E688;
		  /* 8224E688h */ case    2:  		/* bc 4, CR6_GT, 292 */
		/* 8224E688h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8224E7AC;  }
		/* 8224E688h case    2:*/		return 0x8224E68C;
		  /* 8224E68Ch */ case    3:  		/* lwz R11, <#[R31 + 228]> */
		/* 8224E68Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8224E68Ch case    3:*/		return 0x8224E690;
		  /* 8224E690h */ case    4:  		/* rlwinm. R11, R11, 23, 31, 31 */
		/* 8224E690h case    4:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R11,regs.R11);
		/* 8224E690h case    4:*/		return 0x8224E694;
		  /* 8224E694h */ case    5:  		/* bc 12, CR0_EQ, 280 */
		/* 8224E694h case    5:*/		if ( regs.CR[0].eq ) { return 0x8224E7AC;  }
		/* 8224E694h case    5:*/		return 0x8224E698;
		  /* 8224E698h */ case    6:  		/* mr R3, R31 */
		/* 8224E698h case    6:*/		regs.R3 = regs.R31;
		/* 8224E698h case    6:*/		return 0x8224E69C;
		  /* 8224E69Ch */ case    7:  		/* bl -100580 */
		/* 8224E69Ch case    7:*/		regs.LR = 0x8224E6A0; return 0x82235DB8;
		/* 8224E69Ch case    7:*/		return 0x8224E6A0;
		  /* 8224E6A0h */ case    8:  		/* lwz R11, <#[R26 + 52]> */
		/* 8224E6A0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000034) );
		/* 8224E6A0h case    8:*/		return 0x8224E6A4;
		  /* 8224E6A4h */ case    9:  		/* mr R23, R3 */
		/* 8224E6A4h case    9:*/		regs.R23 = regs.R3;
		/* 8224E6A4h case    9:*/		return 0x8224E6A8;
		  /* 8224E6A8h */ case   10:  		/* mr R25, R19 */
		/* 8224E6A8h case   10:*/		regs.R25 = regs.R19;
		/* 8224E6A8h case   10:*/		return 0x8224E6AC;
		  /* 8224E6ACh */ case   11:  		/* mr R22, R19 */
		/* 8224E6ACh case   11:*/		regs.R22 = regs.R19;
		/* 8224E6ACh case   11:*/		return 0x8224E6B0;
		  /* 8224E6B0h */ case   12:  		/* mr R30, R19 */
		/* 8224E6B0h case   12:*/		regs.R30 = regs.R19;
		/* 8224E6B0h case   12:*/		return 0x8224E6B4;
		  /* 8224E6B4h */ case   13:  		/* lwz R27, <#[R11 + 4]> */
		/* 8224E6B4h case   13:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000004) );
		/* 8224E6B4h case   13:*/		return 0x8224E6B8;
		  /* 8224E6B8h */ case   14:  		/* cmpwi CR6, R27, 0 */
		/* 8224E6B8h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 8224E6B8h case   14:*/		return 0x8224E6BC;
		  /* 8224E6BCh */ case   15:  		/* bc 4, CR6_GT, 148 */
		/* 8224E6BCh case   15:*/		if ( !regs.CR[6].gt ) { return 0x8224E750;  }
		/* 8224E6BCh case   15:*/		return 0x8224E6C0;
		  /* 8224E6C0h */ case   16:  		/* mr R28, R19 */
		/* 8224E6C0h case   16:*/		regs.R28 = regs.R19;
		/* 8224E6C0h case   16:*/		return 0x8224E6C4;
		  /* 8224E6C4h */ case   17:  		/* lwz R3, <#[R26 + 52]> */
		/* 8224E6C4h case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x00000034) );
		/* 8224E6C4h case   17:*/		return 0x8224E6C8;
		  /* 8224E6C8h */ case   18:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224E6C8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224E6C8h case   18:*/		return 0x8224E6CC;
		  /* 8224E6CCh */ case   19:  		/* cmplw CR6, R30, R11 */
		/* 8224E6CCh case   19:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8224E6CCh case   19:*/		return 0x8224E6D0;
		  /* 8224E6D0h */ case   20:  		/* bc 4, CR6_LT, 16 */
		/* 8224E6D0h case   20:*/		if ( !regs.CR[6].lt ) { return 0x8224E6E0;  }
		/* 8224E6D0h case   20:*/		return 0x8224E6D4;
		  /* 8224E6D4h */ case   21:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224E6D4h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224E6D4h case   21:*/		return 0x8224E6D8;
		  /* 8224E6D8h */ case   22:  		/* add R3, R11, R28 */
		/* 8224E6D8h case   22:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R28);
		/* 8224E6D8h case   22:*/		return 0x8224E6DC;
		  /* 8224E6DCh */ case   23:  		/* b 12 */
		/* 8224E6DCh case   23:*/		return 0x8224E6E8;
		/* 8224E6DCh case   23:*/		return 0x8224E6E0;
	}
	return 0x8224E6E0;
} // Block from 8224E680h-8224E6E0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8224E6E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E6E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E6E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E6E0);
		  /* 8224E6E0h */ case    0:  		/* mr R4, R30 */
		/* 8224E6E0h case    0:*/		regs.R4 = regs.R30;
		/* 8224E6E0h case    0:*/		return 0x8224E6E4;
		  /* 8224E6E4h */ case    1:  		/* bl 21468 */
		/* 8224E6E4h case    1:*/		regs.LR = 0x8224E6E8; return 0x82253AC0;
		/* 8224E6E4h case    1:*/		return 0x8224E6E8;
	}
	return 0x8224E6E8;
} // Block from 8224E6E0h-8224E6E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224E6E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E6E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E6E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E6E8);
		  /* 8224E6E8h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224E6E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224E6E8h case    0:*/		return 0x8224E6EC;
		  /* 8224E6ECh */ case    1:  		/* lwz R29, <#[R11]> */
		/* 8224E6ECh case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 8224E6ECh case    1:*/		return 0x8224E6F0;
		  /* 8224E6F0h */ case    2:  		/* lwz R11, <#[R29 + 40]> */
		/* 8224E6F0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000028) );
		/* 8224E6F0h case    2:*/		return 0x8224E6F4;
		  /* 8224E6F4h */ case    3:  		/* cmplw CR6, R11, R23 */
		/* 8224E6F4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R23);
		/* 8224E6F4h case    3:*/		return 0x8224E6F8;
		  /* 8224E6F8h */ case    4:  		/* bc 4, CR6_EQ, 64 */
		/* 8224E6F8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8224E738;  }
		/* 8224E6F8h case    4:*/		return 0x8224E6FC;
		  /* 8224E6FCh */ case    5:  		/* lwz R3, <#[R26 + 52]> */
		/* 8224E6FCh case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x00000034) );
		/* 8224E6FCh case    5:*/		return 0x8224E700;
		  /* 8224E700h */ case    6:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224E700h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224E700h case    6:*/		return 0x8224E704;
		  /* 8224E704h */ case    7:  		/* cmplw CR6, R30, R11 */
		/* 8224E704h case    7:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8224E704h case    7:*/		return 0x8224E708;
		  /* 8224E708h */ case    8:  		/* bc 4, CR6_LT, 16 */
		/* 8224E708h case    8:*/		if ( !regs.CR[6].lt ) { return 0x8224E718;  }
		/* 8224E708h case    8:*/		return 0x8224E70C;
		  /* 8224E70Ch */ case    9:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224E70Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224E70Ch case    9:*/		return 0x8224E710;
		  /* 8224E710h */ case   10:  		/* add R3, R11, R28 */
		/* 8224E710h case   10:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R28);
		/* 8224E710h case   10:*/		return 0x8224E714;
		  /* 8224E714h */ case   11:  		/* b 12 */
		/* 8224E714h case   11:*/		return 0x8224E720;
		/* 8224E714h case   11:*/		return 0x8224E718;
	}
	return 0x8224E718;
} // Block from 8224E6E8h-8224E718h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224E718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E718);
		  /* 8224E718h */ case    0:  		/* mr R4, R30 */
		/* 8224E718h case    0:*/		regs.R4 = regs.R30;
		/* 8224E718h case    0:*/		return 0x8224E71C;
		  /* 8224E71Ch */ case    1:  		/* bl 21412 */
		/* 8224E71Ch case    1:*/		regs.LR = 0x8224E720; return 0x82253AC0;
		/* 8224E71Ch case    1:*/		return 0x8224E720;
	}
	return 0x8224E720;
} // Block from 8224E718h-8224E720h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224E720h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E720);
		  /* 8224E720h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224E720h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224E720h case    0:*/		return 0x8224E724;
		  /* 8224E724h */ case    1:  		/* lwz R11, <#[R11 + 8]> */
		/* 8224E724h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8224E724h case    1:*/		return 0x8224E728;
		  /* 8224E728h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 8224E728h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224E728h case    2:*/		return 0x8224E72C;
		  /* 8224E72Ch */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 8224E72Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8224E738;  }
		/* 8224E72Ch case    3:*/		return 0x8224E730;
		  /* 8224E730h */ case    4:  		/* mr R25, R29 */
		/* 8224E730h case    4:*/		regs.R25 = regs.R29;
		/* 8224E730h case    4:*/		return 0x8224E734;
		  /* 8224E734h */ case    5:  		/* addi R22, R22, 1 */
		/* 8224E734h case    5:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 8224E734h case    5:*/		return 0x8224E738;
	}
	return 0x8224E738;
} // Block from 8224E720h-8224E738h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224E738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E738);
		  /* 8224E738h */ case    0:  		/* addi R30, R30, 1 */
		/* 8224E738h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8224E738h case    0:*/		return 0x8224E73C;
		  /* 8224E73Ch */ case    1:  		/* addi R28, R28, 4 */
		/* 8224E73Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 8224E73Ch case    1:*/		return 0x8224E740;
		  /* 8224E740h */ case    2:  		/* cmpw CR6, R30, R27 */
		/* 8224E740h case    2:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R27);
		/* 8224E740h case    2:*/		return 0x8224E744;
		  /* 8224E744h */ case    3:  		/* bc 12, CR6_LT, -128 */
		/* 8224E744h case    3:*/		if ( regs.CR[6].lt ) { return 0x8224E6C4;  }
		/* 8224E744h case    3:*/		return 0x8224E748;
		  /* 8224E748h */ case    4:  		/* cmplwi CR6, R25, 0 */
		/* 8224E748h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 8224E748h case    4:*/		return 0x8224E74C;
		  /* 8224E74Ch */ case    5:  		/* bc 4, CR6_EQ, 28 */
		/* 8224E74Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x8224E768;  }
		/* 8224E74Ch case    5:*/		return 0x8224E750;
	}
	return 0x8224E750;
} // Block from 8224E738h-8224E750h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224E750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E750);
		  /* 8224E750h */ case    0:  		/* mr R6, R17 */
		/* 8224E750h case    0:*/		regs.R6 = regs.R17;
		/* 8224E750h case    0:*/		return 0x8224E754;
		  /* 8224E754h */ case    1:  		/* mr R5, R20 */
		/* 8224E754h case    1:*/		regs.R5 = regs.R20;
		/* 8224E754h case    1:*/		return 0x8224E758;
		  /* 8224E758h */ case    2:  		/* mr R4, R18 */
		/* 8224E758h case    2:*/		regs.R4 = regs.R18;
		/* 8224E758h case    2:*/		return 0x8224E75C;
		  /* 8224E75Ch */ case    3:  		/* li R7, 1496 */
		/* 8224E75Ch case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x5D8);
		/* 8224E75Ch case    3:*/		return 0x8224E760;
		  /* 8224E760h */ case    4:  		/* li R3, 0 */
		/* 8224E760h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224E760h case    4:*/		return 0x8224E764;
		  /* 8224E764h */ case    5:  		/* bl -1010524 */
		/* 8224E764h case    5:*/		regs.LR = 0x8224E768; return 0x82157C08;
		/* 8224E764h case    5:*/		return 0x8224E768;
	}
	return 0x8224E768;
} // Block from 8224E750h-8224E768h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224E768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E768);
		  /* 8224E768h */ case    0:  		/* lwz R11, <#[R23 + 228]> */
		/* 8224E768h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x000000E4) );
		/* 8224E768h case    0:*/		return 0x8224E76C;
		  /* 8224E76Ch */ case    1:  		/* rlwinm. R10, R11, 27, 31, 31 */
		/* 8224E76Ch case    1:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R10,regs.R11);
		/* 8224E76Ch case    1:*/		return 0x8224E770;
		  /* 8224E770h */ case    2:  		/* bc 12, CR0_EQ, 24 */
		/* 8224E770h case    2:*/		if ( regs.CR[0].eq ) { return 0x8224E788;  }
		/* 8224E770h case    2:*/		return 0x8224E774;
		  /* 8224E774h */ case    3:  		/* rlwinm. R11, R11, 26, 31, 31 */
		/* 8224E774h case    3:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R11,regs.R11);
		/* 8224E774h case    3:*/		return 0x8224E778;
		  /* 8224E778h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 8224E778h case    4:*/		if ( regs.CR[0].eq ) { return 0x8224E788;  }
		/* 8224E778h case    4:*/		return 0x8224E77C;
		  /* 8224E77Ch */ case    5:  		/* lbz R11, <#[R26 + 56]> */
		/* 8224E77Ch case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000038) );
		/* 8224E77Ch case    5:*/		return 0x8224E780;
		  /* 8224E780h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 8224E780h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224E780h case    6:*/		return 0x8224E784;
		  /* 8224E784h */ case    7:  		/* bc 4, CR0_EQ, 16 */
		/* 8224E784h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8224E794;  }
		/* 8224E784h case    7:*/		return 0x8224E788;
	}
	return 0x8224E788;
} // Block from 8224E768h-8224E788h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224E788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E788);
		  /* 8224E788h */ case    0:  		/* lwz R11, <#[R25 + 60]> */
		/* 8224E788h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000003C) );
		/* 8224E788h case    0:*/		return 0x8224E78C;
		  /* 8224E78Ch */ case    1:  		/* cmpw CR6, R11, R22 */
		/* 8224E78Ch case    1:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R22);
		/* 8224E78Ch case    1:*/		return 0x8224E790;
		  /* 8224E790h */ case    2:  		/* bc 4, CR6_GT, 28 */
		/* 8224E790h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8224E7AC;  }
		/* 8224E790h case    2:*/		return 0x8224E794;
	}
	return 0x8224E794;
} // Block from 8224E788h-8224E794h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224E794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E794);
		  /* 8224E794h */ case    0:  		/* lwz R11, <#[R25 + 28]> */
		/* 8224E794h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000001C) );
		/* 8224E794h case    0:*/		return 0x8224E798;
	}
	return 0x8224E798;
} // Block from 8224E794h-8224E798h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224E798h
// Function '?CollapseExtraMova@Scheduler@XGRAPHICS@@AAAXPAVSchedNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E798);
		  /* 8224E798h */ case    0:  		/* lwz R10, <#[R24 + 28]> */
		/* 8224E798h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000001C) );
		/* 8224E798h case    0:*/		return 0x8224E79C;
		  /* 8224E79Ch */ case    1:  		/* cmpw CR6, R11, R10 */
		/* 8224E79Ch case    1:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224E79Ch case    1:*/		return 0x8224E7A0;
		  /* 8224E7A0h */ case    2:  		/* bc 4, CR6_LT, 336 */
		/* 8224E7A0h case    2:*/		if ( !regs.CR[6].lt ) { return 0x8224E8F0;  }
		/* 8224E7A0h case    2:*/		return 0x8224E7A4;
		  /* 8224E7A4h */ case    3:  		/* lwz R26, <#[R26 + 8]> */
		/* 8224E7A4h case    3:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R26 + 0x00000008) );
		/* 8224E7A4h case    3:*/		return 0x8224E7A8;
		  /* 8224E7A8h */ case    4:  		/* b 356 */
		/* 8224E7A8h case    4:*/		return 0x8224E90C;
		/* 8224E7A8h case    4:*/		return 0x8224E7AC;
	}
	return 0x8224E7AC;
} // Block from 8224E798h-8224E7ACh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224E7ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E7AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E7AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E7AC);
		  /* 8224E7ACh */ case    0:  		/* lwz R3, <#[R24 + 8]> */
		/* 8224E7ACh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000008) );
		/* 8224E7ACh case    0:*/		return 0x8224E7B0;
		  /* 8224E7B0h */ case    1:  		/* mr R4, R31 */
		/* 8224E7B0h case    1:*/		regs.R4 = regs.R31;
		/* 8224E7B0h case    1:*/		return 0x8224E7B4;
		  /* 8224E7B4h */ case    2:  		/* lwz R11, <#[R3]> */
		/* 8224E7B4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224E7B4h case    2:*/		return 0x8224E7B8;
		  /* 8224E7B8h */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 8224E7B8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8224E7B8h case    3:*/		return 0x8224E7BC;
		  /* 8224E7BCh */ case    4:  		/* mtspr CTR, R11 */
		/* 8224E7BCh case    4:*/		regs.CTR = regs.R11;
		/* 8224E7BCh case    4:*/		return 0x8224E7C0;
		  /* 8224E7C0h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 8224E7C0h case    5:*/		if ( 1 ) { regs.LR = 0x8224E7C4; return (uint32)regs.CTR; }
		/* 8224E7C0h case    5:*/		return 0x8224E7C4;
		  /* 8224E7C4h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224E7C4h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224E7C4h case    6:*/		return 0x8224E7C8;
		  /* 8224E7C8h */ case    7:  		/* bc 12, CR0_EQ, 40 */
		/* 8224E7C8h case    7:*/		if ( regs.CR[0].eq ) { return 0x8224E7F0;  }
		/* 8224E7C8h case    7:*/		return 0x8224E7CC;
		  /* 8224E7CCh */ case    8:  		/* mr R4, R31 */
		/* 8224E7CCh case    8:*/		regs.R4 = regs.R31;
		/* 8224E7CCh case    8:*/		return 0x8224E7D0;
		  /* 8224E7D0h */ case    9:  		/* lwz R3, <#[R24 + 12]> */
		/* 8224E7D0h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x0000000C) );
		/* 8224E7D0h case    9:*/		return 0x8224E7D4;
		  /* 8224E7D4h */ case   10:  		/* bl -16116 */
		/* 8224E7D4h case   10:*/		regs.LR = 0x8224E7D8; return 0x8224A8E0;
		/* 8224E7D4h case   10:*/		return 0x8224E7D8;
		  /* 8224E7D8h */ case   11:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224E7D8h case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224E7D8h case   11:*/		return 0x8224E7DC;
		  /* 8224E7DCh */ case   12:  		/* bc 12, CR0_EQ, 276 */
		/* 8224E7DCh case   12:*/		if ( regs.CR[0].eq ) { return 0x8224E8F0;  }
		/* 8224E7DCh case   12:*/		return 0x8224E7E0;
		  /* 8224E7E0h */ case   13:  		/* mr R3, R26 */
		/* 8224E7E0h case   13:*/		regs.R3 = regs.R26;
		/* 8224E7E0h case   13:*/		return 0x8224E7E4;
		  /* 8224E7E4h */ case   14:  		/* bl 20516 */
		/* 8224E7E4h case   14:*/		regs.LR = 0x8224E7E8; return 0x82253808;
		/* 8224E7E4h case   14:*/		return 0x8224E7E8;
		  /* 8224E7E8h */ case   15:  		/* mr R3, R26 */
		/* 8224E7E8h case   15:*/		regs.R3 = regs.R26;
		/* 8224E7E8h case   15:*/		return 0x8224E7EC;
		  /* 8224E7ECh */ case   16:  		/* b 1644 */
		/* 8224E7ECh case   16:*/		return 0x8224EE58;
		/* 8224E7ECh case   16:*/		return 0x8224E7F0;
	}
	return 0x8224E7F0;
} // Block from 8224E7ACh-8224E7F0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8224E7F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E7F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E7F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E7F0);
		  /* 8224E7F0h */ case    0:  		/* lwz R3, <#[R24 + 8]> */
		/* 8224E7F0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000008) );
		/* 8224E7F0h case    0:*/		return 0x8224E7F4;
		  /* 8224E7F4h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 8224E7F4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224E7F4h case    1:*/		return 0x8224E7F8;
		  /* 8224E7F8h */ case    2:  		/* lwz R11, <#[R11 + 28]> */
		/* 8224E7F8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8224E7F8h case    2:*/		return 0x8224E7FC;
		  /* 8224E7FCh */ case    3:  		/* mtspr CTR, R11 */
		/* 8224E7FCh case    3:*/		regs.CTR = regs.R11;
		/* 8224E7FCh case    3:*/		return 0x8224E800;
		  /* 8224E800h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8224E800h case    4:*/		if ( 1 ) { regs.LR = 0x8224E804; return (uint32)regs.CTR; }
		/* 8224E800h case    4:*/		return 0x8224E804;
		  /* 8224E804h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224E804h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224E804h case    5:*/		return 0x8224E808;
		  /* 8224E808h */ case    6:  		/* bc 12, CR0_EQ, 232 */
		/* 8224E808h case    6:*/		if ( regs.CR[0].eq ) { return 0x8224E8F0;  }
		/* 8224E808h case    6:*/		return 0x8224E80C;
		  /* 8224E80Ch */ case    7:  		/* lwz R11, <#[R31 + 24]> */
		/* 8224E80Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8224E80Ch case    7:*/		return 0x8224E810;
		  /* 8224E810h */ case    8:  		/* mulli R11, R11, 52 */
		/* 8224E810h case    8:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x34);
		/* 8224E810h case    8:*/		return 0x8224E814;
		  /* 8224E814h */ case    9:  		/* lwzx R10, <#[R11 + R21]> */
		/* 8224E814h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R21 + 0x00000000) );
		/* 8224E814h case    9:*/		return 0x8224E818;
		  /* 8224E818h */ case   10:  		/* rlwinm. R10, R10, 30, 31, 31 */
		/* 8224E818h case   10:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R10,regs.R10);
		/* 8224E818h case   10:*/		return 0x8224E81C;
		  /* 8224E81Ch */ case   11:  		/* bc 12, CR0_EQ, 24 */
		/* 8224E81Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x8224E834;  }
		/* 8224E81Ch case   11:*/		return 0x8224E820;
		  /* 8224E820h */ case   12:  		/* addi R10, R21, 4 */
		/* 8224E820h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R21,0x4);
		/* 8224E820h case   12:*/		return 0x8224E824;
		  /* 8224E824h */ case   13:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8224E824h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8224E824h case   13:*/		return 0x8224E828;
		  /* 8224E828h */ case   14:  		/* cmpwi CR6, R11, 0 */
		/* 8224E828h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224E828h case   14:*/		return 0x8224E82C;
		  /* 8224E82Ch */ case   15:  		/* li R11, 1 */
		/* 8224E82Ch case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224E82Ch case   15:*/		return 0x8224E830;
		  /* 8224E830h */ case   16:  		/* bc 4, CR6_EQ, 8 */
		/* 8224E830h case   16:*/		if ( !regs.CR[6].eq ) { return 0x8224E838;  }
		/* 8224E830h case   16:*/		return 0x8224E834;
	}
	return 0x8224E834;
} // Block from 8224E7F0h-8224E834h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8224E834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E834);
		  /* 8224E834h */ case    0:  		/* mr R11, R19 */
		/* 8224E834h case    0:*/		regs.R11 = regs.R19;
		/* 8224E834h case    0:*/		return 0x8224E838;
	}
	return 0x8224E838;
} // Block from 8224E834h-8224E838h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224E838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E838);
		  /* 8224E838h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8224E838h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8224E838h case    0:*/		return 0x8224E83C;
		  /* 8224E83Ch */ case    1:  		/* bc 12, CR0_EQ, 180 */
		/* 8224E83Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8224E8F0;  }
		/* 8224E83Ch case    1:*/		return 0x8224E840;
		  /* 8224E840h */ case    2:  		/* mr R4, R31 */
		/* 8224E840h case    2:*/		regs.R4 = regs.R31;
		/* 8224E840h case    2:*/		return 0x8224E844;
		  /* 8224E844h */ case    3:  		/* lwz R3, <#[R24 + 8]> */
		/* 8224E844h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000008) );
		/* 8224E844h case    3:*/		return 0x8224E848;
		  /* 8224E848h */ case    4:  		/* bl 99160 */
		/* 8224E848h case    4:*/		regs.LR = 0x8224E84C; return 0x82266BA0;
		/* 8224E848h case    4:*/		return 0x8224E84C;
		  /* 8224E84Ch */ case    5:  		/* lwz R11, <#[R31]> */
		/* 8224E84Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224E84Ch case    5:*/		return 0x8224E850;
		  /* 8224E850h */ case    6:  		/* li R5, 0 */
		/* 8224E850h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8224E850h case    6:*/		return 0x8224E854;
		  /* 8224E854h */ case    7:  		/* li R4, 1 */
		/* 8224E854h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224E854h case    7:*/		return 0x8224E858;
		  /* 8224E858h */ case    8:  		/* mr R3, R31 */
		/* 8224E858h case    8:*/		regs.R3 = regs.R31;
		/* 8224E858h case    8:*/		return 0x8224E85C;
		  /* 8224E85Ch */ case    9:  		/* lwz R11, <#[R11 + 80]> */
		/* 8224E85Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 8224E85Ch case    9:*/		return 0x8224E860;
		  /* 8224E860h */ case   10:  		/* mtspr CTR, R11 */
		/* 8224E860h case   10:*/		regs.CTR = regs.R11;
		/* 8224E860h case   10:*/		return 0x8224E864;
		  /* 8224E864h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 8224E864h case   11:*/		if ( 1 ) { regs.LR = 0x8224E868; return (uint32)regs.CTR; }
		/* 8224E864h case   11:*/		return 0x8224E868;
		  /* 8224E868h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 8224E868h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224E868h case   12:*/		return 0x8224E86C;
		  /* 8224E86Ch */ case   13:  		/* mr R30, R3 */
		/* 8224E86Ch case   13:*/		regs.R30 = regs.R3;
		/* 8224E86Ch case   13:*/		return 0x8224E870;
		  /* 8224E870h */ case   14:  		/* li R5, 0 */
		/* 8224E870h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8224E870h case   14:*/		return 0x8224E874;
		  /* 8224E874h */ case   15:  		/* li R4, 2 */
		/* 8224E874h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8224E874h case   15:*/		return 0x8224E878;
		  /* 8224E878h */ case   16:  		/* mr R3, R31 */
		/* 8224E878h case   16:*/		regs.R3 = regs.R31;
		/* 8224E878h case   16:*/		return 0x8224E87C;
		  /* 8224E87Ch */ case   17:  		/* lwz R11, <#[R11 + 80]> */
		/* 8224E87Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 8224E87Ch case   17:*/		return 0x8224E880;
		  /* 8224E880h */ case   18:  		/* mtspr CTR, R11 */
		/* 8224E880h case   18:*/		regs.CTR = regs.R11;
		/* 8224E880h case   18:*/		return 0x8224E884;
		  /* 8224E884h */ case   19:  		/* bcctrl 20, CR0_LT */
		/* 8224E884h case   19:*/		if ( 1 ) { regs.LR = 0x8224E888; return (uint32)regs.CTR; }
		/* 8224E884h case   19:*/		return 0x8224E888;
		  /* 8224E888h */ case   20:  		/* mr R29, R3 */
		/* 8224E888h case   20:*/		regs.R29 = regs.R3;
		/* 8224E888h case   20:*/		return 0x8224E88C;
		  /* 8224E88Ch */ case   21:  		/* mr R3, R31 */
		/* 8224E88Ch case   21:*/		regs.R3 = regs.R31;
		/* 8224E88Ch case   21:*/		return 0x8224E890;
		  /* 8224E890h */ case   22:  		/* bl 33952 */
		/* 8224E890h case   22:*/		regs.LR = 0x8224E894; return 0x82256D30;
		/* 8224E890h case   22:*/		return 0x8224E894;
		  /* 8224E894h */ case   23:  		/* lwz R11, <#[R24 + 8]> */
		/* 8224E894h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 8224E894h case   23:*/		return 0x8224E898;
		  /* 8224E898h */ case   24:  		/* mr R28, R3 */
		/* 8224E898h case   24:*/		regs.R28 = regs.R3;
		/* 8224E898h case   24:*/		return 0x8224E89C;
		  /* 8224E89Ch */ case   25:  		/* mr R3, R11 */
		/* 8224E89Ch case   25:*/		regs.R3 = regs.R11;
		/* 8224E89Ch case   25:*/		return 0x8224E8A0;
		  /* 8224E8A0h */ case   26:  		/* mr R4, R31 */
		/* 8224E8A0h case   26:*/		regs.R4 = regs.R31;
		/* 8224E8A0h case   26:*/		return 0x8224E8A4;
		  /* 8224E8A4h */ case   27:  		/* lwz R10, <#[R11]> */
		/* 8224E8A4h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8224E8A4h case   27:*/		return 0x8224E8A8;
		  /* 8224E8A8h */ case   28:  		/* lwz R11, <#[R10 + 4]> */
		/* 8224E8A8h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8224E8A8h case   28:*/		return 0x8224E8AC;
		  /* 8224E8ACh */ case   29:  		/* mtspr CTR, R11 */
		/* 8224E8ACh case   29:*/		regs.CTR = regs.R11;
		/* 8224E8ACh case   29:*/		return 0x8224E8B0;
		  /* 8224E8B0h */ case   30:  		/* bcctrl 20, CR0_LT */
		/* 8224E8B0h case   30:*/		if ( 1 ) { regs.LR = 0x8224E8B4; return (uint32)regs.CTR; }
		/* 8224E8B0h case   30:*/		return 0x8224E8B4;
		  /* 8224E8B4h */ case   31:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224E8B4h case   31:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224E8B4h case   31:*/		return 0x8224E8B8;
		  /* 8224E8B8h */ case   32:  		/* bc 12, CR0_EQ, 24 */
		/* 8224E8B8h case   32:*/		if ( regs.CR[0].eq ) { return 0x8224E8D0;  }
		/* 8224E8B8h case   32:*/		return 0x8224E8BC;
		  /* 8224E8BCh */ case   33:  		/* mr R4, R31 */
		/* 8224E8BCh case   33:*/		regs.R4 = regs.R31;
		/* 8224E8BCh case   33:*/		return 0x8224E8C0;
		  /* 8224E8C0h */ case   34:  		/* lwz R3, <#[R24 + 12]> */
		/* 8224E8C0h case   34:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x0000000C) );
		/* 8224E8C0h case   34:*/		return 0x8224E8C4;
		  /* 8224E8C4h */ case   35:  		/* bl -16356 */
		/* 8224E8C4h case   35:*/		regs.LR = 0x8224E8C8; return 0x8224A8E0;
		/* 8224E8C4h case   35:*/		return 0x8224E8C8;
		  /* 8224E8C8h */ case   36:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224E8C8h case   36:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224E8C8h case   36:*/		return 0x8224E8CC;
		  /* 8224E8CCh */ case   37:  		/* bc 4, CR0_EQ, 296 */
		/* 8224E8CCh case   37:*/		if ( !regs.CR[0].eq ) { return 0x8224E9F4;  }
		/* 8224E8CCh case   37:*/		return 0x8224E8D0;
	}
	return 0x8224E8D0;
} // Block from 8224E838h-8224E8D0h (38 instructions)

//////////////////////////////////////////////////////
// Block at 8224E8D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E8D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E8D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E8D0);
		  /* 8224E8D0h */ case    0:  		/* mr R6, R28 */
		/* 8224E8D0h case    0:*/		regs.R6 = regs.R28;
		/* 8224E8D0h case    0:*/		return 0x8224E8D4;
		  /* 8224E8D4h */ case    1:  		/* mr R5, R29 */
		/* 8224E8D4h case    1:*/		regs.R5 = regs.R29;
		/* 8224E8D4h case    1:*/		return 0x8224E8D8;
		  /* 8224E8D8h */ case    2:  		/* mr R4, R30 */
		/* 8224E8D8h case    2:*/		regs.R4 = regs.R30;
		/* 8224E8D8h case    2:*/		return 0x8224E8DC;
		  /* 8224E8DCh */ case    3:  		/* mr R3, R31 */
		/* 8224E8DCh case    3:*/		regs.R3 = regs.R31;
		/* 8224E8DCh case    3:*/		return 0x8224E8E0;
		  /* 8224E8E0h */ case    4:  		/* bl 33576 */
		/* 8224E8E0h case    4:*/		regs.LR = 0x8224E8E4; return 0x82256C08;
		/* 8224E8E0h case    4:*/		return 0x8224E8E4;
		  /* 8224E8E4h */ case    5:  		/* mr R4, R31 */
		/* 8224E8E4h case    5:*/		regs.R4 = regs.R31;
		/* 8224E8E4h case    5:*/		return 0x8224E8E8;
		  /* 8224E8E8h */ case    6:  		/* lwz R3, <#[R24 + 8]> */
		/* 8224E8E8h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000008) );
		/* 8224E8E8h case    6:*/		return 0x8224E8EC;
		  /* 8224E8ECh */ case    7:  		/* bl 98868 */
		/* 8224E8ECh case    7:*/		regs.LR = 0x8224E8F0; return 0x82266B20;
		/* 8224E8ECh case    7:*/		return 0x8224E8F0;
	}
	return 0x8224E8F0;
} // Block from 8224E8D0h-8224E8F0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224E8F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E8F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E8F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E8F0);
		  /* 8224E8F0h */ case    0:  		/* mr R31, R26 */
		/* 8224E8F0h case    0:*/		regs.R31 = regs.R26;
		/* 8224E8F0h case    0:*/		return 0x8224E8F4;
		  /* 8224E8F4h */ case    1:  		/* lwz R26, <#[R26 + 8]> */
		/* 8224E8F4h case    1:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R26 + 0x00000008) );
		/* 8224E8F4h case    1:*/		return 0x8224E8F8;
		  /* 8224E8F8h */ case    2:  		/* mr R3, R31 */
		/* 8224E8F8h case    2:*/		regs.R3 = regs.R31;
		/* 8224E8F8h case    2:*/		return 0x8224E8FC;
		  /* 8224E8FCh */ case    3:  		/* bl 20236 */
		/* 8224E8FCh case    3:*/		regs.LR = 0x8224E900; return 0x82253808;
		/* 8224E8FCh case    3:*/		return 0x8224E900;
		  /* 8224E900h */ case    4:  		/* mr R4, R31 */
		/* 8224E900h case    4:*/		regs.R4 = regs.R31;
		/* 8224E900h case    4:*/		return 0x8224E904;
		  /* 8224E904h */ case    5:  		/* addi R3, R24, 84 */
		/* 8224E904h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R24,0x54);
		/* 8224E904h case    5:*/		return 0x8224E908;
		  /* 8224E908h */ case    6:  		/* bl 20352 */
		/* 8224E908h case    6:*/		regs.LR = 0x8224E90C; return 0x82253888;
		/* 8224E908h case    6:*/		return 0x8224E90C;
	}
	return 0x8224E90C;
} // Block from 8224E8F0h-8224E90Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224E90Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E90C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E90C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E90C);
		  /* 8224E90Ch */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 8224E90Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 8224E90Ch case    0:*/		return 0x8224E910;
		  /* 8224E910h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224E910h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224E910h case    1:*/		return 0x8224E914;
		  /* 8224E914h */ case    2:  		/* bc 4, CR6_EQ, -784 */
		/* 8224E914h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224E604;  }
		/* 8224E914h case    2:*/		return 0x8224E918;
	}
	return 0x8224E918;
} // Block from 8224E90Ch-8224E918h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224E918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E918);
		  /* 8224E918h */ case    0:  		/* addi R3, R24, 36 */
		/* 8224E918h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R24,0x24);
		/* 8224E918h case    0:*/		return 0x8224E91C;
		  /* 8224E91Ch */ case    1:  		/* bl 20068 */
		/* 8224E91Ch case    1:*/		regs.LR = 0x8224E920; return 0x82253780;
		/* 8224E91Ch case    1:*/		return 0x8224E920;
		  /* 8224E920h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224E920h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224E920h case    2:*/		return 0x8224E924;
		  /* 8224E924h */ case    3:  		/* bc 4, CR0_EQ, 1328 */
		/* 8224E924h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8224EE54;  }
		/* 8224E924h case    3:*/		return 0x8224E928;
		  /* 8224E928h */ case    4:  		/* addi R4, R1, 80 */
		/* 8224E928h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8224E928h case    4:*/		return 0x8224E92C;
		  /* 8224E92Ch */ case    5:  		/* mr R3, R24 */
		/* 8224E92Ch case    5:*/		regs.R3 = regs.R24;
		/* 8224E92Ch case    5:*/		return 0x8224E930;
		  /* 8224E930h */ case    6:  		/* bl -12984 */
		/* 8224E930h case    6:*/		regs.LR = 0x8224E934; return 0x8224B678;
		/* 8224E930h case    6:*/		return 0x8224E934;
		  /* 8224E934h */ case    7:  		/* or. R23, R3, R3 */
		/* 8224E934h case    7:*/		cpu::op::or<1>(regs,&regs.R23,regs.R3,regs.R3);
		/* 8224E934h case    7:*/		return 0x8224E938;
		  /* 8224E938h */ case    8:  		/* bc 12, CR0_EQ, 1308 */
		/* 8224E938h case    8:*/		if ( regs.CR[0].eq ) { return 0x8224EE54;  }
		/* 8224E938h case    8:*/		return 0x8224E93C;
		  /* 8224E93Ch */ case    9:  		/* mr R3, R23 */
		/* 8224E93Ch case    9:*/		regs.R3 = regs.R23;
		/* 8224E93Ch case    9:*/		return 0x8224E940;
		  /* 8224E940h */ case   10:  		/* bl 20168 */
		/* 8224E940h case   10:*/		regs.LR = 0x8224E944; return 0x82253808;
		/* 8224E940h case   10:*/		return 0x8224E944;
		  /* 8224E944h */ case   11:  		/* lwz R11, <#[R23 + 60]> */
		/* 8224E944h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000003C) );
		/* 8224E944h case   11:*/		return 0x8224E948;
		  /* 8224E948h */ case   12:  		/* cmpwi CR6, R11, 0 */
		/* 8224E948h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224E948h case   12:*/		return 0x8224E94C;
		  /* 8224E94Ch */ case   13:  		/* lwz R22, <#[R23 + 40]> */
		/* 8224E94Ch case   13:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R23 + 0x00000028) );
		/* 8224E94Ch case   13:*/		return 0x8224E950;
		  /* 8224E950h */ case   14:  		/* bc 4, CR6_GT, 16 */
		/* 8224E950h case   14:*/		if ( !regs.CR[6].gt ) { return 0x8224E960;  }
		/* 8224E950h case   14:*/		return 0x8224E954;
		  /* 8224E954h */ case   15:  		/* lwz R11, <#[R22 + 228]> */
		/* 8224E954h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x000000E4) );
		/* 8224E954h case   15:*/		return 0x8224E958;
		  /* 8224E958h */ case   16:  		/* rlwinm. R11, R11, 23, 31, 31 */
		/* 8224E958h case   16:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R11,regs.R11);
		/* 8224E958h case   16:*/		return 0x8224E95C;
		  /* 8224E95Ch */ case   17:  		/* bc 4, CR0_EQ, 32 */
		/* 8224E95Ch case   17:*/		if ( !regs.CR[0].eq ) { return 0x8224E97C;  }
		/* 8224E95Ch case   17:*/		return 0x8224E960;
	}
	return 0x8224E960;
} // Block from 8224E918h-8224E960h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8224E960h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E960);
		  /* 8224E960h */ case    0:  		/* lis R11, -32252 */
		/* 8224E960h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224E960h case    0:*/		return 0x8224E964;
		  /* 8224E964h */ case    1:  		/* mr R6, R17 */
		/* 8224E964h case    1:*/		regs.R6 = regs.R17;
		/* 8224E964h case    1:*/		return 0x8224E968;
		  /* 8224E968h */ case    2:  		/* addi R5, R11, 15636 */
		/* 8224E968h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3D14);
		/* 8224E968h case    2:*/		return 0x8224E96C;
		  /* 8224E96Ch */ case    3:  		/* mr R4, R18 */
		/* 8224E96Ch case    3:*/		regs.R4 = regs.R18;
		/* 8224E96Ch case    3:*/		return 0x8224E970;
		  /* 8224E970h */ case    4:  		/* li R7, 1566 */
		/* 8224E970h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x61E);
		/* 8224E970h case    4:*/		return 0x8224E974;
		  /* 8224E974h */ case    5:  		/* li R3, 0 */
		/* 8224E974h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224E974h case    5:*/		return 0x8224E978;
		  /* 8224E978h */ case    6:  		/* bl -1011056 */
		/* 8224E978h case    6:*/		regs.LR = 0x8224E97C; return 0x82157C08;
		/* 8224E978h case    6:*/		return 0x8224E97C;
	}
	return 0x8224E97C;
} // Block from 8224E960h-8224E97Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224E97Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E97C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E97C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E97C);
		  /* 8224E97Ch */ case    0:  		/* mr R3, R22 */
		/* 8224E97Ch case    0:*/		regs.R3 = regs.R22;
		/* 8224E97Ch case    0:*/		return 0x8224E980;
		  /* 8224E980h */ case    1:  		/* bl -101320 */
		/* 8224E980h case    1:*/		regs.LR = 0x8224E984; return 0x82235DB8;
		/* 8224E980h case    1:*/		return 0x8224E984;
		  /* 8224E984h */ case    2:  		/* lbz R31, <#[R1 + 80]> */
		/* 8224E984h case    2:*/		cpu::mem::load8z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 8224E984h case    2:*/		return 0x8224E988;
		  /* 8224E988h */ case    3:  		/* mr R21, R3 */
		/* 8224E988h case    3:*/		regs.R21 = regs.R3;
		/* 8224E988h case    3:*/		return 0x8224E98C;
		  /* 8224E98Ch */ case    4:  		/* lwz R4, <#[R24]> */
		/* 8224E98Ch case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R24 + 0x00000000) );
		/* 8224E98Ch case    4:*/		return 0x8224E990;
		  /* 8224E990h */ case    5:  		/* cmplwi CR0, R31, 0 */
		/* 8224E990h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 8224E990h case    5:*/		return 0x8224E994;
		  /* 8224E994h */ case    6:  		/* li R3, 102 */
		/* 8224E994h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x66);
		/* 8224E994h case    6:*/		return 0x8224E998;
		  /* 8224E998h */ case    7:  		/* bc 4, CR0_EQ, 8 */
		/* 8224E998h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8224E9A0;  }
		/* 8224E998h case    7:*/		return 0x8224E99C;
		  /* 8224E99Ch */ case    8:  		/* li R3, 49 */
		/* 8224E99Ch case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8224E99Ch case    8:*/		return 0x8224E9A0;
	}
	return 0x8224E9A0;
} // Block from 8224E97Ch-8224E9A0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224E9A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E9A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E9A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E9A0);
		  /* 8224E9A0h */ case    0:  		/* bl 30096 */
		/* 8224E9A0h case    0:*/		regs.LR = 0x8224E9A4; return 0x82255F30;
		/* 8224E9A0h case    0:*/		return 0x8224E9A4;
		  /* 8224E9A4h */ case    1:  		/* lwz R11, <#[R3 + 224]> */
		/* 8224E9A4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000E0) );
		/* 8224E9A4h case    1:*/		return 0x8224E9A8;
		  /* 8224E9A8h */ case    2:  		/* stw R19, <#[R3 + 80]> */
		/* 8224E9A8h case    2:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R3 + 0x00000050) );
		/* 8224E9A8h case    2:*/		return 0x8224E9AC;
		  /* 8224E9ACh */ case    3:  		/* mr R4, R22 */
		/* 8224E9ACh case    3:*/		regs.R4 = regs.R22;
		/* 8224E9ACh case    3:*/		return 0x8224E9B0;
		  /* 8224E9B0h */ case    4:  		/* mr R29, R3 */
		/* 8224E9B0h case    4:*/		regs.R29 = regs.R3;
		/* 8224E9B0h case    4:*/		return 0x8224E9B4;
		  /* 8224E9B4h */ case    5:  		/* stw R11, <#[R3 + 56]> */
		/* 8224E9B4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 8224E9B4h case    5:*/		return 0x8224E9B8;
		  /* 8224E9B8h */ case    6:  		/* bl 29888 */
		/* 8224E9B8h case    6:*/		regs.LR = 0x8224E9BC; return 0x82255E78;
		/* 8224E9B8h case    6:*/		return 0x8224E9BC;
		  /* 8224E9BCh */ case    7:  		/* cmplwi CR6, R31, 0 */
		/* 8224E9BCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8224E9BCh case    7:*/		return 0x8224E9C0;
		  /* 8224E9C0h */ case    8:  		/* bc 12, CR6_EQ, 228 */
		/* 8224E9C0h case    8:*/		if ( regs.CR[6].eq ) { return 0x8224EAA4;  }
		/* 8224E9C0h case    8:*/		return 0x8224E9C4;
		  /* 8224E9C4h */ case    9:  		/* lwz R11, <#[R29]> */
		/* 8224E9C4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8224E9C4h case    9:*/		return 0x8224E9C8;
		  /* 8224E9C8h */ case   10:  		/* li R5, 0 */
		/* 8224E9C8h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8224E9C8h case   10:*/		return 0x8224E9CC;
		  /* 8224E9CCh */ case   11:  		/* li R4, 0 */
		/* 8224E9CCh case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8224E9CCh case   11:*/		return 0x8224E9D0;
		  /* 8224E9D0h */ case   12:  		/* mr R3, R29 */
		/* 8224E9D0h case   12:*/		regs.R3 = regs.R29;
		/* 8224E9D0h case   12:*/		return 0x8224E9D4;
		  /* 8224E9D4h */ case   13:  		/* lwz R11, <#[R11 + 80]> */
		/* 8224E9D4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 8224E9D4h case   13:*/		return 0x8224E9D8;
		  /* 8224E9D8h */ case   14:  		/* mtspr CTR, R11 */
		/* 8224E9D8h case   14:*/		regs.CTR = regs.R11;
		/* 8224E9D8h case   14:*/		return 0x8224E9DC;
		  /* 8224E9DCh */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 8224E9DCh case   15:*/		if ( 1 ) { regs.LR = 0x8224E9E0; return (uint32)regs.CTR; }
		/* 8224E9DCh case   15:*/		return 0x8224E9E0;
		  /* 8224E9E0h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 8224E9E0h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8224E9E0h case   16:*/		return 0x8224E9E4;
		  /* 8224E9E4h */ case   17:  		/* bc 4, CR0_EQ, 32 */
		/* 8224E9E4h case   17:*/		if ( !regs.CR[0].eq ) { return 0x8224EA04;  }
		/* 8224E9E4h case   17:*/		return 0x8224E9E8;
		  /* 8224E9E8h */ case   18:  		/* lis R11, -32252 */
		/* 8224E9E8h case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224E9E8h case   18:*/		return 0x8224E9EC;
		  /* 8224E9ECh */ case   19:  		/* lwz R11, <#[R11 + 13912]> */
		/* 8224E9ECh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00003658) );
		/* 8224E9ECh case   19:*/		return 0x8224E9F0;
		  /* 8224E9F0h */ case   20:  		/* b 172 */
		/* 8224E9F0h case   20:*/		return 0x8224EA9C;
		/* 8224E9F0h case   20:*/		return 0x8224E9F4;
	}
	return 0x8224E9F4;
} // Block from 8224E9A0h-8224E9F4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8224E9F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224E9F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224E9F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224E9F4);
		  /* 8224E9F4h */ case    0:  		/* mr R4, R31 */
		/* 8224E9F4h case    0:*/		regs.R4 = regs.R31;
		/* 8224E9F4h case    0:*/		return 0x8224E9F8;
		  /* 8224E9F8h */ case    1:  		/* lwz R3, <#[R24 + 8]> */
		/* 8224E9F8h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000008) );
		/* 8224E9F8h case    1:*/		return 0x8224E9FC;
		  /* 8224E9FCh */ case    2:  		/* bl 98596 */
		/* 8224E9FCh case    2:*/		regs.LR = 0x8224EA00; return 0x82266B20;
		/* 8224E9FCh case    2:*/		return 0x8224EA00;
		  /* 8224EA00h */ case    3:  		/* b -544 */
		/* 8224EA00h case    3:*/		return 0x8224E7E0;
		/* 8224EA00h case    3:*/		return 0x8224EA04;
	}
	return 0x8224EA04;
} // Block from 8224E9F4h-8224EA04h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224EA04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EA04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EA04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EA04);
		  /* 8224EA04h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8224EA04h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8224EA04h case    0:*/		return 0x8224EA08;
		  /* 8224EA08h */ case    1:  		/* li R5, 1 */
		/* 8224EA08h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8224EA08h case    1:*/		return 0x8224EA0C;
		  /* 8224EA0Ch */ case    2:  		/* li R4, 0 */
		/* 8224EA0Ch case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8224EA0Ch case    2:*/		return 0x8224EA10;
		  /* 8224EA10h */ case    3:  		/* mr R3, R29 */
		/* 8224EA10h case    3:*/		regs.R3 = regs.R29;
		/* 8224EA10h case    3:*/		return 0x8224EA14;
		  /* 8224EA14h */ case    4:  		/* lwz R11, <#[R11 + 80]> */
		/* 8224EA14h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 8224EA14h case    4:*/		return 0x8224EA18;
		  /* 8224EA18h */ case    5:  		/* mtspr CTR, R11 */
		/* 8224EA18h case    5:*/		regs.CTR = regs.R11;
		/* 8224EA18h case    5:*/		return 0x8224EA1C;
		  /* 8224EA1Ch */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 8224EA1Ch case    6:*/		if ( 1 ) { regs.LR = 0x8224EA20; return (uint32)regs.CTR; }
		/* 8224EA1Ch case    6:*/		return 0x8224EA20;
		  /* 8224EA20h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 8224EA20h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8224EA20h case    7:*/		return 0x8224EA24;
		  /* 8224EA24h */ case    8:  		/* bc 4, CR0_EQ, 20 */
		/* 8224EA24h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8224EA38;  }
		/* 8224EA24h case    8:*/		return 0x8224EA28;
		  /* 8224EA28h */ case    9:  		/* lis R11, -32252 */
		/* 8224EA28h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224EA28h case    9:*/		return 0x8224EA2C;
		  /* 8224EA2Ch */ case   10:  		/* addi R11, R11, 13912 */
		/* 8224EA2Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3658);
		/* 8224EA2Ch case   10:*/		return 0x8224EA30;
		  /* 8224EA30h */ case   11:  		/* lwz R11, <#[R11 + 4]> */
		/* 8224EA30h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8224EA30h case   11:*/		return 0x8224EA34;
		  /* 8224EA34h */ case   12:  		/* b 104 */
		/* 8224EA34h case   12:*/		return 0x8224EA9C;
		/* 8224EA34h case   12:*/		return 0x8224EA38;
	}
	return 0x8224EA38;
} // Block from 8224EA04h-8224EA38h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224EA38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EA38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EA38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EA38);
		  /* 8224EA38h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8224EA38h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8224EA38h case    0:*/		return 0x8224EA3C;
		  /* 8224EA3Ch */ case    1:  		/* li R5, 2 */
		/* 8224EA3Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8224EA3Ch case    1:*/		return 0x8224EA40;
		  /* 8224EA40h */ case    2:  		/* li R4, 0 */
		/* 8224EA40h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8224EA40h case    2:*/		return 0x8224EA44;
		  /* 8224EA44h */ case    3:  		/* mr R3, R29 */
		/* 8224EA44h case    3:*/		regs.R3 = regs.R29;
		/* 8224EA44h case    3:*/		return 0x8224EA48;
		  /* 8224EA48h */ case    4:  		/* lwz R11, <#[R11 + 80]> */
		/* 8224EA48h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 8224EA48h case    4:*/		return 0x8224EA4C;
		  /* 8224EA4Ch */ case    5:  		/* mtspr CTR, R11 */
		/* 8224EA4Ch case    5:*/		regs.CTR = regs.R11;
		/* 8224EA4Ch case    5:*/		return 0x8224EA50;
		  /* 8224EA50h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 8224EA50h case    6:*/		if ( 1 ) { regs.LR = 0x8224EA54; return (uint32)regs.CTR; }
		/* 8224EA50h case    6:*/		return 0x8224EA54;
		  /* 8224EA54h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 8224EA54h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8224EA54h case    7:*/		return 0x8224EA58;
		  /* 8224EA58h */ case    8:  		/* bc 4, CR0_EQ, 20 */
		/* 8224EA58h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8224EA6C;  }
		/* 8224EA58h case    8:*/		return 0x8224EA5C;
		  /* 8224EA5Ch */ case    9:  		/* lis R11, -32252 */
		/* 8224EA5Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224EA5Ch case    9:*/		return 0x8224EA60;
		  /* 8224EA60h */ case   10:  		/* addi R11, R11, 13912 */
		/* 8224EA60h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3658);
		/* 8224EA60h case   10:*/		return 0x8224EA64;
		  /* 8224EA64h */ case   11:  		/* lwz R11, <#[R11 + 8]> */
		/* 8224EA64h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8224EA64h case   11:*/		return 0x8224EA68;
		  /* 8224EA68h */ case   12:  		/* b 52 */
		/* 8224EA68h case   12:*/		return 0x8224EA9C;
		/* 8224EA68h case   12:*/		return 0x8224EA6C;
	}
	return 0x8224EA6C;
} // Block from 8224EA38h-8224EA6Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224EA6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EA6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EA6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EA6C);
		  /* 8224EA6Ch */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8224EA6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8224EA6Ch case    0:*/		return 0x8224EA70;
		  /* 8224EA70h */ case    1:  		/* li R5, 3 */
		/* 8224EA70h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 8224EA70h case    1:*/		return 0x8224EA74;
		  /* 8224EA74h */ case    2:  		/* li R4, 0 */
		/* 8224EA74h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8224EA74h case    2:*/		return 0x8224EA78;
		  /* 8224EA78h */ case    3:  		/* mr R3, R29 */
		/* 8224EA78h case    3:*/		regs.R3 = regs.R29;
		/* 8224EA78h case    3:*/		return 0x8224EA7C;
		  /* 8224EA7Ch */ case    4:  		/* lwz R11, <#[R11 + 80]> */
		/* 8224EA7Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 8224EA7Ch case    4:*/		return 0x8224EA80;
		  /* 8224EA80h */ case    5:  		/* mtspr CTR, R11 */
		/* 8224EA80h case    5:*/		regs.CTR = regs.R11;
		/* 8224EA80h case    5:*/		return 0x8224EA84;
		  /* 8224EA84h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 8224EA84h case    6:*/		if ( 1 ) { regs.LR = 0x8224EA88; return (uint32)regs.CTR; }
		/* 8224EA84h case    6:*/		return 0x8224EA88;
		  /* 8224EA88h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 8224EA88h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8224EA88h case    7:*/		return 0x8224EA8C;
		  /* 8224EA8Ch */ case    8:  		/* bc 4, CR0_EQ, 124 */
		/* 8224EA8Ch case    8:*/		if ( !regs.CR[0].eq ) { return 0x8224EB08;  }
		/* 8224EA8Ch case    8:*/		return 0x8224EA90;
		  /* 8224EA90h */ case    9:  		/* lis R11, -32252 */
		/* 8224EA90h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224EA90h case    9:*/		return 0x8224EA94;
		  /* 8224EA94h */ case   10:  		/* addi R11, R11, 13912 */
		/* 8224EA94h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3658);
		/* 8224EA94h case   10:*/		return 0x8224EA98;
		  /* 8224EA98h */ case   11:  		/* lwz R11, <#[R11 + 12]> */
		/* 8224EA98h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8224EA98h case   11:*/		return 0x8224EA9C;
	}
	return 0x8224EA9C;
} // Block from 8224EA6Ch-8224EA9Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224EA9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EA9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EA9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EA9C);
		  /* 8224EA9Ch */ case    0:  		/* stw R11, <#[R29 + 132]> */
		/* 8224EA9Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000084) );
		/* 8224EA9Ch case    0:*/		return 0x8224EAA0;
		  /* 8224EAA0h */ case    1:  		/* b 104 */
		/* 8224EAA0h case    1:*/		return 0x8224EB08;
		/* 8224EAA0h case    1:*/		return 0x8224EAA4;
	}
	return 0x8224EAA4;
} // Block from 8224EA9Ch-8224EAA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224EAA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EAA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EAA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EAA4);
		  /* 8224EAA4h */ case    0:  		/* mr R31, R19 */
		/* 8224EAA4h case    0:*/		regs.R31 = regs.R19;
		/* 8224EAA4h case    0:*/		return 0x8224EAA8;
		  /* 8224EAA8h */ case    1:  		/* lwz R11, <#[R29]> */
		/* 8224EAA8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8224EAA8h case    1:*/		return 0x8224EAAC;
		  /* 8224EAACh */ case    2:  		/* mr R5, R31 */
		/* 8224EAACh case    2:*/		regs.R5 = regs.R31;
		/* 8224EAACh case    2:*/		return 0x8224EAB0;
		  /* 8224EAB0h */ case    3:  		/* li R4, 0 */
		/* 8224EAB0h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8224EAB0h case    3:*/		return 0x8224EAB4;
		  /* 8224EAB4h */ case    4:  		/* mr R3, R29 */
		/* 8224EAB4h case    4:*/		regs.R3 = regs.R29;
		/* 8224EAB4h case    4:*/		return 0x8224EAB8;
		  /* 8224EAB8h */ case    5:  		/* lwz R11, <#[R11 + 80]> */
		/* 8224EAB8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 8224EAB8h case    5:*/		return 0x8224EABC;
		  /* 8224EABCh */ case    6:  		/* mtspr CTR, R11 */
		/* 8224EABCh case    6:*/		regs.CTR = regs.R11;
		/* 8224EABCh case    6:*/		return 0x8224EAC0;
		  /* 8224EAC0h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 8224EAC0h case    7:*/		if ( 1 ) { regs.LR = 0x8224EAC4; return (uint32)regs.CTR; }
		/* 8224EAC0h case    7:*/		return 0x8224EAC4;
		  /* 8224EAC4h */ case    8:  		/* cmpwi CR6, R3, 1 */
		/* 8224EAC4h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8224EAC4h case    8:*/		return 0x8224EAC8;
	}
	return 0x8224EAC8;
} // Block from 8224EAA4h-8224EAC8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224EAC8h
// Function '?AllocateLocalRegister@Scheduler@XGRAPHICS@@AAAXPAVSchedNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EAC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EAC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EAC8);
		  /* 8224EAC8h */ case    0:  		/* bc 4, CR6_EQ, 52 */
		/* 8224EAC8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8224EAFC;  }
		/* 8224EAC8h case    0:*/		return 0x8224EACC;
		  /* 8224EACCh */ case    1:  		/* addi R11, R31, 1 */
		/* 8224EACCh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x1);
		/* 8224EACCh case    1:*/		return 0x8224EAD0;
		  /* 8224EAD0h */ case    2:  		/* lwz R10, <#[R29]> */
		/* 8224EAD0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 8224EAD0h case    2:*/		return 0x8224EAD4;
		  /* 8224EAD4h */ case    3:  		/* mr R5, R31 */
		/* 8224EAD4h case    3:*/		regs.R5 = regs.R31;
		/* 8224EAD4h case    3:*/		return 0x8224EAD8;
		  /* 8224EAD8h */ case    4:  		/* srawi R9, R11, 2 */
		/* 8224EAD8h case    4:*/		cpu::op::srawi<0,2>(regs,&regs.R9,regs.R11);
		/* 8224EAD8h case    4:*/		return 0x8224EADC;
		  /* 8224EADCh */ case    5:  		/* li R4, 1 */
		/* 8224EADCh case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224EADCh case    5:*/		return 0x8224EAE0;
		  /* 8224EAE0h */ case    6:  		/* addze R9, R9 */
		/* 8224EAE0h case    6:*/		cpu::op::addze<0>(regs,&regs.R9,regs.R9);
		/* 8224EAE0h case    6:*/		return 0x8224EAE4;
		  /* 8224EAE4h */ case    7:  		/* lwz R10, <#[R10 + 88]> */
		/* 8224EAE4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000058) );
		/* 8224EAE4h case    7:*/		return 0x8224EAE8;
		  /* 8224EAE8h */ case    8:  		/* mr R3, R29 */
		/* 8224EAE8h case    8:*/		regs.R3 = regs.R29;
		/* 8224EAE8h case    8:*/		return 0x8224EAEC;
		  /* 8224EAECh */ case    9:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8224EAECh case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8224EAECh case    9:*/		return 0x8224EAF0;
		  /* 8224EAF0h */ case   10:  		/* subf R6, R9, R11 */
		/* 8224EAF0h case   10:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R9,regs.R11);
		/* 8224EAF0h case   10:*/		return 0x8224EAF4;
		  /* 8224EAF4h */ case   11:  		/* mtspr CTR, R10 */
		/* 8224EAF4h case   11:*/		regs.CTR = regs.R10;
		/* 8224EAF4h case   11:*/		return 0x8224EAF8;
		  /* 8224EAF8h */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 8224EAF8h case   12:*/		if ( 1 ) { regs.LR = 0x8224EAFC; return (uint32)regs.CTR; }
		/* 8224EAF8h case   12:*/		return 0x8224EAFC;
	}
	return 0x8224EAFC;
} // Block from 8224EAC8h-8224EAFCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224EAFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EAFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EAFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EAFC);
		  /* 8224EAFCh */ case    0:  		/* addi R31, R31, 1 */
		/* 8224EAFCh case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8224EAFCh case    0:*/		return 0x8224EB00;
		  /* 8224EB00h */ case    1:  		/* cmpwi CR6, R31, 4 */
		/* 8224EB00h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000004);
		/* 8224EB00h case    1:*/		return 0x8224EB04;
		  /* 8224EB04h */ case    2:  		/* bc 12, CR6_LT, -92 */
		/* 8224EB04h case    2:*/		if ( regs.CR[6].lt ) { return 0x8224EAA8;  }
		/* 8224EB04h case    2:*/		return 0x8224EB08;
	}
	return 0x8224EB08;
} // Block from 8224EAFCh-8224EB08h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224EB08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EB08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EB08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EB08);
		  /* 8224EB08h */ case    0:  		/* mr R5, R21 */
		/* 8224EB08h case    0:*/		regs.R5 = regs.R21;
		/* 8224EB08h case    0:*/		return 0x8224EB0C;
		  /* 8224EB0Ch */ case    1:  		/* li R4, 1 */
		/* 8224EB0Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224EB0Ch case    1:*/		return 0x8224EB10;
		  /* 8224EB10h */ case    2:  		/* mr R3, R29 */
		/* 8224EB10h case    2:*/		regs.R3 = regs.R29;
		/* 8224EB10h case    2:*/		return 0x8224EB14;
		  /* 8224EB14h */ case    3:  		/* bl -101316 */
		/* 8224EB14h case    3:*/		regs.LR = 0x8224EB18; return 0x82235F50;
		/* 8224EB14h case    3:*/		return 0x8224EB18;
		  /* 8224EB18h */ case    4:  		/* lwz R11, <#[R22 + 228]> */
		/* 8224EB18h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x000000E4) );
		/* 8224EB18h case    4:*/		return 0x8224EB1C;
		  /* 8224EB1Ch */ case    5:  		/* rlwinm. R11, R11, 23, 31, 31 */
		/* 8224EB1Ch case    5:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R11,regs.R11);
		/* 8224EB1Ch case    5:*/		return 0x8224EB20;
		  /* 8224EB20h */ case    6:  		/* lwz R11, <#[R22 + 20]> */
		/* 8224EB20h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000014) );
		/* 8224EB20h case    6:*/		return 0x8224EB24;
		  /* 8224EB24h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 8224EB24h case    7:*/		if ( regs.CR[0].eq ) { return 0x8224EB38;  }
		/* 8224EB24h case    7:*/		return 0x8224EB28;
		  /* 8224EB28h */ case    8:  		/* addi R11, R11, 58 */
		/* 8224EB28h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3A);
		/* 8224EB28h case    8:*/		return 0x8224EB2C;
		  /* 8224EB2Ch */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8224EB2Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8224EB2Ch case    9:*/		return 0x8224EB30;
		  /* 8224EB30h */ case   10:  		/* stwx R29, <#[R11 + R22]> */
		/* 8224EB30h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + regs.R22 + 0x00000000) );
		/* 8224EB30h case   10:*/		return 0x8224EB34;
		  /* 8224EB34h */ case   11:  		/* b 36 */
		/* 8224EB34h case   11:*/		return 0x8224EB58;
		/* 8224EB34h case   11:*/		return 0x8224EB38;
	}
	return 0x8224EB38;
} // Block from 8224EB08h-8224EB38h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224EB38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EB38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EB38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EB38);
		  /* 8224EB38h */ case    0:  		/* addi R11, R11, 1 */
		/* 8224EB38h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224EB38h case    0:*/		return 0x8224EB3C;
		  /* 8224EB3Ch */ case    1:  		/* addi R10, R11, 58 */
		/* 8224EB3Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x3A);
		/* 8224EB3Ch case    1:*/		return 0x8224EB40;
		  /* 8224EB40h */ case    2:  		/* stw R11, <#[R22 + 20]> */
		/* 8224EB40h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R22 + 0x00000014) );
		/* 8224EB40h case    2:*/		return 0x8224EB44;
		  /* 8224EB44h */ case    3:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 8224EB44h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 8224EB44h case    3:*/		return 0x8224EB48;
		  /* 8224EB48h */ case    4:  		/* stwx R29, <#[R11 + R22]> */
		/* 8224EB48h case    4:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + regs.R22 + 0x00000000) );
		/* 8224EB48h case    4:*/		return 0x8224EB4C;
		  /* 8224EB4Ch */ case    5:  		/* lwz R11, <#[R22 + 228]> */
		/* 8224EB4Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x000000E4) );
		/* 8224EB4Ch case    5:*/		return 0x8224EB50;
		  /* 8224EB50h */ case    6:  		/* ori R11, R11, 512 */
		/* 8224EB50h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x200);
		/* 8224EB50h case    6:*/		return 0x8224EB54;
		  /* 8224EB54h */ case    7:  		/* stw R11, <#[R22 + 228]> */
		/* 8224EB54h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R22 + 0x000000E4) );
		/* 8224EB54h case    7:*/		return 0x8224EB58;
	}
	return 0x8224EB58;
} // Block from 8224EB38h-8224EB58h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224EB58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EB58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EB58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EB58);
		  /* 8224EB58h */ case    0:  		/* lwz R11, <#[R24 + 24]> */
		/* 8224EB58h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000018) );
		/* 8224EB58h case    0:*/		return 0x8224EB5C;
		  /* 8224EB5Ch */ case    1:  		/* li R4, 72 */
		/* 8224EB5Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x48);
		/* 8224EB5Ch case    1:*/		return 0x8224EB60;
		  /* 8224EB60h */ case    2:  		/* lwz R31, <#[R11 + 4]> */
		/* 8224EB60h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 8224EB60h case    2:*/		return 0x8224EB64;
		  /* 8224EB64h */ case    3:  		/* stw R31, <#[R29 + 892]> */
		/* 8224EB64h case    3:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R29 + 0x0000037C) );
		/* 8224EB64h case    3:*/		return 0x8224EB68;
		  /* 8224EB68h */ case    4:  		/* lwz R11, <#[R24]> */
		/* 8224EB68h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 8224EB68h case    4:*/		return 0x8224EB6C;
		  /* 8224EB6Ch */ case    5:  		/* lwz R30, <#[R11 + 1456]> */
		/* 8224EB6Ch case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224EB6Ch case    5:*/		return 0x8224EB70;
		  /* 8224EB70h */ case    6:  		/* mr R3, R30 */
		/* 8224EB70h case    6:*/		regs.R3 = regs.R30;
		/* 8224EB70h case    6:*/		return 0x8224EB74;
		  /* 8224EB74h */ case    7:  		/* bl -206524 */
		/* 8224EB74h case    7:*/		regs.LR = 0x8224EB78; return 0x8221C4B8;
		/* 8224EB74h case    7:*/		return 0x8224EB78;
		  /* 8224EB78h */ case    8:  		/* li R28, -1 */
		/* 8224EB78h case    8:*/		cpu::op::li<0>(regs,&regs.R28,0xFFFFFFFF);
		/* 8224EB78h case    8:*/		return 0x8224EB7C;
		  /* 8224EB7Ch */ case    9:  		/* addic. R11, R3, 4 */
		/* 8224EB7Ch case    9:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R3,0x4);
		/* 8224EB7Ch case    9:*/		return 0x8224EB80;
		  /* 8224EB80h */ case   10:  		/* stw R30, <#[R3]> */
		/* 8224EB80h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224EB80h case   10:*/		return 0x8224EB84;
		  /* 8224EB84h */ case   11:  		/* bc 12, CR0_EQ, 96 */
		/* 8224EB84h case   11:*/		if ( regs.CR[0].eq ) { return 0x8224EBE4;  }
		/* 8224EB84h case   11:*/		return 0x8224EB88;
		  /* 8224EB88h */ case   12:  		/* lis R10, -32256 */
		/* 8224EB88h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8224EB88h case   12:*/		return 0x8224EB8C;
		  /* 8224EB8Ch */ case   13:  		/* stw R31, <#[R11 + 44]> */
		/* 8224EB8Ch case   13:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x0000002C) );
		/* 8224EB8Ch case   13:*/		return 0x8224EB90;
		  /* 8224EB90h */ case   14:  		/* lis R9, -32252 */
		/* 8224EB90h case   14:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 8224EB90h case   14:*/		return 0x8224EB94;
		  /* 8224EB94h */ case   15:  		/* stw R29, <#[R11 + 40]> */
		/* 8224EB94h case   15:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000028) );
		/* 8224EB94h case   15:*/		return 0x8224EB98;
		  /* 8224EB98h */ case   16:  		/* stw R19, <#[R11 + 4]> */
		/* 8224EB98h case   16:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000004) );
		/* 8224EB98h case   16:*/		return 0x8224EB9C;
		  /* 8224EB9Ch */ case   17:  		/* mr R31, R11 */
		/* 8224EB9Ch case   17:*/		regs.R31 = regs.R11;
		/* 8224EB9Ch case   17:*/		return 0x8224EBA0;
		  /* 8224EBA0h */ case   18:  		/* addi R9, R9, 14380 */
		/* 8224EBA0h case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x382C);
		/* 8224EBA0h case   18:*/		return 0x8224EBA4;
		  /* 8224EBA4h */ case   19:  		/* stw R19, <#[R11 + 8]> */
		/* 8224EBA4h case   19:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000008) );
		/* 8224EBA4h case   19:*/		return 0x8224EBA8;
		  /* 8224EBA8h */ case   20:  		/* stw R28, <#[R11 + 28]> */
		/* 8224EBA8h case   20:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x0000001C) );
		/* 8224EBA8h case   20:*/		return 0x8224EBAC;
		  /* 8224EBACh */ case   21:  		/* lfs FR0, <#[R10 + 1816]> */
		/* 8224EBACh case   21:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000718) );
		/* 8224EBACh case   21:*/		return 0x8224EBB0;
		  /* 8224EBB0h */ case   22:  		/* stw R9, <#[R11]> */
		/* 8224EBB0h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8224EBB0h case   22:*/		return 0x8224EBB4;
		  /* 8224EBB4h */ case   23:  		/* stfs FR0, <#[R11 + 16]> */
		/* 8224EBB4h case   23:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000010) );
		/* 8224EBB4h case   23:*/		return 0x8224EBB8;
		  /* 8224EBB8h */ case   24:  		/* stw R19, <#[R11 + 32]> */
		/* 8224EBB8h case   24:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000020) );
		/* 8224EBB8h case   24:*/		return 0x8224EBBC;
		  /* 8224EBBCh */ case   25:  		/* stw R19, <#[R11 + 36]> */
		/* 8224EBBCh case   25:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000024) );
		/* 8224EBBCh case   25:*/		return 0x8224EBC0;
		  /* 8224EBC0h */ case   26:  		/* stw R19, <#[R11 + 48]> */
		/* 8224EBC0h case   26:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000030) );
		/* 8224EBC0h case   26:*/		return 0x8224EBC4;
		  /* 8224EBC4h */ case   27:  		/* stw R19, <#[R11 + 52]> */
		/* 8224EBC4h case   27:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000034) );
		/* 8224EBC4h case   27:*/		return 0x8224EBC8;
		  /* 8224EBC8h */ case   28:  		/* stb R19, <#[R11 + 56]> */
		/* 8224EBC8h case   28:*/		cpu::mem::store8( regs, regs.R19, (uint32)(regs.R11 + 0x00000038) );
		/* 8224EBC8h case   28:*/		return 0x8224EBCC;
		  /* 8224EBCCh */ case   29:  		/* stw R19, <#[R11 + 60]> */
		/* 8224EBCCh case   29:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x0000003C) );
		/* 8224EBCCh case   29:*/		return 0x8224EBD0;
		  /* 8224EBD0h */ case   30:  		/* stw R19, <#[R11 + 64]> */
		/* 8224EBD0h case   30:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000040) );
		/* 8224EBD0h case   30:*/		return 0x8224EBD4;
		  /* 8224EBD4h */ case   31:  		/* stw R19, <#[R11 + 12]> */
		/* 8224EBD4h case   31:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x0000000C) );
		/* 8224EBD4h case   31:*/		return 0x8224EBD8;
		  /* 8224EBD8h */ case   32:  		/* stw R19, <#[R11 + 20]> */
		/* 8224EBD8h case   32:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000014) );
		/* 8224EBD8h case   32:*/		return 0x8224EBDC;
		  /* 8224EBDCh */ case   33:  		/* stw R19, <#[R11 + 24]> */
		/* 8224EBDCh case   33:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000018) );
		/* 8224EBDCh case   33:*/		return 0x8224EBE0;
		  /* 8224EBE0h */ case   34:  		/* b 8 */
		/* 8224EBE0h case   34:*/		return 0x8224EBE8;
		/* 8224EBE0h case   34:*/		return 0x8224EBE4;
	}
	return 0x8224EBE4;
} // Block from 8224EB58h-8224EBE4h (35 instructions)

//////////////////////////////////////////////////////
// Block at 8224EBE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EBE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EBE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EBE4);
		  /* 8224EBE4h */ case    0:  		/* mr R31, R19 */
		/* 8224EBE4h case    0:*/		regs.R31 = regs.R19;
		/* 8224EBE4h case    0:*/		return 0x8224EBE8;
	}
	return 0x8224EBE8;
} // Block from 8224EBE4h-8224EBE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224EBE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EBE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EBE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EBE8);
		  /* 8224EBE8h */ case    0:  		/* lwz R11, <#[R29 + 228]> */
		/* 8224EBE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000000E4) );
		/* 8224EBE8h case    0:*/		return 0x8224EBEC;
		  /* 8224EBECh */ case    1:  		/* li R4, 20 */
		/* 8224EBECh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 8224EBECh case    1:*/		return 0x8224EBF0;
		  /* 8224EBF0h */ case    2:  		/* rlwinm R11, R11, 0, 27, 25 */
		/* 8224EBF0h case    2:*/		cpu::op::rlwinm<0,0,27,25>(regs,&regs.R11,regs.R11);
		/* 8224EBF0h case    2:*/		return 0x8224EBF4;
		  /* 8224EBF4h */ case    3:  		/* stw R11, <#[R29 + 228]> */
		/* 8224EBF4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x000000E4) );
		/* 8224EBF4h case    3:*/		return 0x8224EBF8;
		  /* 8224EBF8h */ case    4:  		/* lbz R11, <#[R23 + 56]> */
		/* 8224EBF8h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000038) );
		/* 8224EBF8h case    4:*/		return 0x8224EBFC;
		  /* 8224EBFCh */ case    5:  		/* stb R11, <#[R31 + 56]> */
		/* 8224EBFCh case    5:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 8224EBFCh case    5:*/		return 0x8224EC00;
		  /* 8224EC00h */ case    6:  		/* lwz R11, <#[R24]> */
		/* 8224EC00h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 8224EC00h case    6:*/		return 0x8224EC04;
		  /* 8224EC04h */ case    7:  		/* lwz R27, <#[R11 + 1456]> */
		/* 8224EC04h case    7:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224EC04h case    7:*/		return 0x8224EC08;
		  /* 8224EC08h */ case    8:  		/* mr R3, R27 */
		/* 8224EC08h case    8:*/		regs.R3 = regs.R27;
		/* 8224EC08h case    8:*/		return 0x8224EC0C;
		  /* 8224EC0Ch */ case    9:  		/* bl -206676 */
		/* 8224EC0Ch case    9:*/		regs.LR = 0x8224EC10; return 0x8221C4B8;
		/* 8224EC0Ch case    9:*/		return 0x8224EC10;
		  /* 8224EC10h */ case   10:  		/* addic. R30, R3, 4 */
		/* 8224EC10h case   10:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 8224EC10h case   10:*/		return 0x8224EC14;
		  /* 8224EC14h */ case   11:  		/* stw R27, <#[R3]> */
		/* 8224EC14h case   11:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 8224EC14h case   11:*/		return 0x8224EC18;
		  /* 8224EC18h */ case   12:  		/* bc 12, CR0_EQ, 24 */
		/* 8224EC18h case   12:*/		if ( regs.CR[0].eq ) { return 0x8224EC30;  }
		/* 8224EC18h case   12:*/		return 0x8224EC1C;
		  /* 8224EC1Ch */ case   13:  		/* lwz R11, <#[R24]> */
		/* 8224EC1Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 8224EC1Ch case   13:*/		return 0x8224EC20;
		  /* 8224EC20h */ case   14:  		/* mr R3, R30 */
		/* 8224EC20h case   14:*/		regs.R3 = regs.R30;
		/* 8224EC20h case   14:*/		return 0x8224EC24;
		  /* 8224EC24h */ case   15:  		/* lwz R4, <#[R11 + 1456]> */
		/* 8224EC24h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224EC24h case   15:*/		return 0x8224EC28;
		  /* 8224EC28h */ case   16:  		/* bl -102088 */
		/* 8224EC28h case   16:*/		regs.LR = 0x8224EC2C; return 0x82235D60;
		/* 8224EC28h case   16:*/		return 0x8224EC2C;
		  /* 8224EC2Ch */ case   17:  		/* b 8 */
		/* 8224EC2Ch case   17:*/		return 0x8224EC34;
		/* 8224EC2Ch case   17:*/		return 0x8224EC30;
	}
	return 0x8224EC30;
} // Block from 8224EBE8h-8224EC30h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8224EC30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EC30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EC30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EC30);
		  /* 8224EC30h */ case    0:  		/* mr R30, R19 */
		/* 8224EC30h case    0:*/		regs.R30 = regs.R19;
		/* 8224EC30h case    0:*/		return 0x8224EC34;
	}
	return 0x8224EC34;
} // Block from 8224EC30h-8224EC34h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224EC34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EC34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EC34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EC34);
		  /* 8224EC34h */ case    0:  		/* stw R30, <#[R31 + 52]> */
		/* 8224EC34h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000034) );
		/* 8224EC34h case    0:*/		return 0x8224EC38;
		  /* 8224EC38h */ case    1:  		/* li R4, 20 */
		/* 8224EC38h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 8224EC38h case    1:*/		return 0x8224EC3C;
		  /* 8224EC3Ch */ case    2:  		/* lwz R11, <#[R24]> */
		/* 8224EC3Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 8224EC3Ch case    2:*/		return 0x8224EC40;
		  /* 8224EC40h */ case    3:  		/* lwz R27, <#[R11 + 1456]> */
		/* 8224EC40h case    3:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224EC40h case    3:*/		return 0x8224EC44;
		  /* 8224EC44h */ case    4:  		/* mr R3, R27 */
		/* 8224EC44h case    4:*/		regs.R3 = regs.R27;
		/* 8224EC44h case    4:*/		return 0x8224EC48;
		  /* 8224EC48h */ case    5:  		/* bl -206736 */
		/* 8224EC48h case    5:*/		regs.LR = 0x8224EC4C; return 0x8221C4B8;
		/* 8224EC48h case    5:*/		return 0x8224EC4C;
		  /* 8224EC4Ch */ case    6:  		/* addic. R30, R3, 4 */
		/* 8224EC4Ch case    6:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 8224EC4Ch case    6:*/		return 0x8224EC50;
		  /* 8224EC50h */ case    7:  		/* stw R27, <#[R3]> */
		/* 8224EC50h case    7:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 8224EC50h case    7:*/		return 0x8224EC54;
		  /* 8224EC54h */ case    8:  		/* bc 12, CR0_EQ, 24 */
		/* 8224EC54h case    8:*/		if ( regs.CR[0].eq ) { return 0x8224EC6C;  }
		/* 8224EC54h case    8:*/		return 0x8224EC58;
		  /* 8224EC58h */ case    9:  		/* lwz R11, <#[R24]> */
		/* 8224EC58h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 8224EC58h case    9:*/		return 0x8224EC5C;
		  /* 8224EC5Ch */ case   10:  		/* mr R3, R30 */
		/* 8224EC5Ch case   10:*/		regs.R3 = regs.R30;
		/* 8224EC5Ch case   10:*/		return 0x8224EC60;
		  /* 8224EC60h */ case   11:  		/* lwz R4, <#[R11 + 1456]> */
		/* 8224EC60h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224EC60h case   11:*/		return 0x8224EC64;
		  /* 8224EC64h */ case   12:  		/* bl -102148 */
		/* 8224EC64h case   12:*/		regs.LR = 0x8224EC68; return 0x82235D60;
		/* 8224EC64h case   12:*/		return 0x8224EC68;
		  /* 8224EC68h */ case   13:  		/* b 8 */
		/* 8224EC68h case   13:*/		return 0x8224EC70;
		/* 8224EC68h case   13:*/		return 0x8224EC6C;
	}
	return 0x8224EC6C;
} // Block from 8224EC34h-8224EC6Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224EC6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EC6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EC6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EC6C);
		  /* 8224EC6Ch */ case    0:  		/* mr R30, R19 */
		/* 8224EC6Ch case    0:*/		regs.R30 = regs.R19;
		/* 8224EC6Ch case    0:*/		return 0x8224EC70;
	}
	return 0x8224EC70;
} // Block from 8224EC6Ch-8224EC70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224EC70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EC70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EC70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EC70);
		  /* 8224EC70h */ case    0:  		/* stw R30, <#[R31 + 48]> */
		/* 8224EC70h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000030) );
		/* 8224EC70h case    0:*/		return 0x8224EC74;
		  /* 8224EC74h */ case    1:  		/* stw R28, <#[R31 + 28]> */
		/* 8224EC74h case    1:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x0000001C) );
		/* 8224EC74h case    1:*/		return 0x8224EC78;
		  /* 8224EC78h */ case    2:  		/* stw R19, <#[R31 + 36]> */
		/* 8224EC78h case    2:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R31 + 0x00000024) );
		/* 8224EC78h case    2:*/		return 0x8224EC7C;
		  /* 8224EC7Ch */ case    3:  		/* lwz R11, <#[R24 + 28]> */
		/* 8224EC7Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000001C) );
		/* 8224EC7Ch case    3:*/		return 0x8224EC80;
		  /* 8224EC80h */ case    4:  		/* stw R11, <#[R31 + 32]> */
		/* 8224EC80h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8224EC80h case    4:*/		return 0x8224EC84;
		  /* 8224EC84h */ case    5:  		/* lwz R3, <#[R24 + 24]> */
		/* 8224EC84h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000018) );
		/* 8224EC84h case    5:*/		return 0x8224EC88;
		  /* 8224EC88h */ case    6:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224EC88h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224EC88h case    6:*/		return 0x8224EC8C;
		  /* 8224EC8Ch */ case    7:  		/* bl 20020 */
		/* 8224EC8Ch case    7:*/		regs.LR = 0x8224EC90; return 0x82253AC0;
		/* 8224EC8Ch case    7:*/		return 0x8224EC90;
		  /* 8224EC90h */ case    8:  		/* stw R31, <#[R3]> */
		/* 8224EC90h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 8224EC90h case    8:*/		return 0x8224EC94;
		  /* 8224EC94h */ case    9:  		/* mr R27, R19 */
		/* 8224EC94h case    9:*/		regs.R27 = regs.R19;
		/* 8224EC94h case    9:*/		return 0x8224EC98;
		  /* 8224EC98h */ case   10:  		/* lwz R11, <#[R23 + 52]> */
		/* 8224EC98h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000034) );
		/* 8224EC98h case   10:*/		return 0x8224EC9C;
		  /* 8224EC9Ch */ case   11:  		/* lwz R26, <#[R11 + 4]> */
		/* 8224EC9Ch case   11:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x00000004) );
		/* 8224EC9Ch case   11:*/		return 0x8224ECA0;
		  /* 8224ECA0h */ case   12:  		/* cmpwi CR6, R26, 0 */
		/* 8224ECA0h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 8224ECA0h case   12:*/		return 0x8224ECA4;
		  /* 8224ECA4h */ case   13:  		/* bc 4, CR6_GT, 400 */
		/* 8224ECA4h case   13:*/		if ( !regs.CR[6].gt ) { return 0x8224EE34;  }
		/* 8224ECA4h case   13:*/		return 0x8224ECA8;
		  /* 8224ECA8h */ case   14:  		/* mr R25, R19 */
		/* 8224ECA8h case   14:*/		regs.R25 = regs.R19;
		/* 8224ECA8h case   14:*/		return 0x8224ECAC;
		  /* 8224ECACh */ case   15:  		/* lwz R3, <#[R23 + 52]> */
		/* 8224ECACh case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000034) );
		/* 8224ECACh case   15:*/		return 0x8224ECB0;
		  /* 8224ECB0h */ case   16:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224ECB0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224ECB0h case   16:*/		return 0x8224ECB4;
		  /* 8224ECB4h */ case   17:  		/* cmplw CR6, R27, R11 */
		/* 8224ECB4h case   17:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 8224ECB4h case   17:*/		return 0x8224ECB8;
		  /* 8224ECB8h */ case   18:  		/* bc 4, CR6_LT, 16 */
		/* 8224ECB8h case   18:*/		if ( !regs.CR[6].lt ) { return 0x8224ECC8;  }
		/* 8224ECB8h case   18:*/		return 0x8224ECBC;
		  /* 8224ECBCh */ case   19:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224ECBCh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224ECBCh case   19:*/		return 0x8224ECC0;
		  /* 8224ECC0h */ case   20:  		/* add R3, R11, R25 */
		/* 8224ECC0h case   20:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R25);
		/* 8224ECC0h case   20:*/		return 0x8224ECC4;
		  /* 8224ECC4h */ case   21:  		/* b 12 */
		/* 8224ECC4h case   21:*/		return 0x8224ECD0;
		/* 8224ECC4h case   21:*/		return 0x8224ECC8;
	}
	return 0x8224ECC8;
} // Block from 8224EC70h-8224ECC8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8224ECC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224ECC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224ECC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224ECC8);
		  /* 8224ECC8h */ case    0:  		/* mr R4, R27 */
		/* 8224ECC8h case    0:*/		regs.R4 = regs.R27;
		/* 8224ECC8h case    0:*/		return 0x8224ECCC;
		  /* 8224ECCCh */ case    1:  		/* bl 19956 */
		/* 8224ECCCh case    1:*/		regs.LR = 0x8224ECD0; return 0x82253AC0;
		/* 8224ECCCh case    1:*/		return 0x8224ECD0;
	}
	return 0x8224ECD0;
} // Block from 8224ECC8h-8224ECD0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224ECD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224ECD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224ECD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224ECD0);
		  /* 8224ECD0h */ case    0:  		/* lwz R30, <#[R3]> */
		/* 8224ECD0h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224ECD0h case    0:*/		return 0x8224ECD4;
		  /* 8224ECD4h */ case    1:  		/* lwz R28, <#[R30]> */
		/* 8224ECD4h case    1:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x00000000) );
		/* 8224ECD4h case    1:*/		return 0x8224ECD8;
		  /* 8224ECD8h */ case    2:  		/* lwz R11, <#[R28 + 40]> */
		/* 8224ECD8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000028) );
		/* 8224ECD8h case    2:*/		return 0x8224ECDC;
		  /* 8224ECDCh */ case    3:  		/* cmplw CR6, R11, R21 */
		/* 8224ECDCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R21);
		/* 8224ECDCh case    3:*/		return 0x8224ECE0;
		  /* 8224ECE0h */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 8224ECE0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8224ECF0;  }
		/* 8224ECE0h case    4:*/		return 0x8224ECE4;
		  /* 8224ECE4h */ case    5:  		/* lwz R11, <#[R30 + 8]> */
		/* 8224ECE4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8224ECE4h case    5:*/		return 0x8224ECE8;
		  /* 8224ECE8h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 8224ECE8h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224ECE8h case    6:*/		return 0x8224ECEC;
		  /* 8224ECECh */ case    7:  		/* bc 12, CR6_EQ, 24 */
		/* 8224ECECh case    7:*/		if ( regs.CR[6].eq ) { return 0x8224ED04;  }
		/* 8224ECECh case    7:*/		return 0x8224ECF0;
	}
	return 0x8224ECF0;
} // Block from 8224ECD0h-8224ECF0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224ECF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224ECF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224ECF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224ECF0);
		  /* 8224ECF0h */ case    0:  		/* addi R27, R27, 1 */
		/* 8224ECF0h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8224ECF0h case    0:*/		return 0x8224ECF4;
		  /* 8224ECF4h */ case    1:  		/* addi R25, R25, 4 */
		/* 8224ECF4h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 8224ECF4h case    1:*/		return 0x8224ECF8;
		  /* 8224ECF8h */ case    2:  		/* cmpw CR6, R27, R26 */
		/* 8224ECF8h case    2:*/		cpu::op::cmpw<6>(regs,regs.R27,regs.R26);
		/* 8224ECF8h case    2:*/		return 0x8224ECFC;
		  /* 8224ECFCh */ case    3:  		/* bc 12, CR6_LT, -80 */
		/* 8224ECFCh case    3:*/		if ( regs.CR[6].lt ) { return 0x8224ECAC;  }
		/* 8224ECFCh case    3:*/		return 0x8224ED00;
		  /* 8224ED00h */ case    4:  		/* b 308 */
		/* 8224ED00h case    4:*/		return 0x8224EE34;
		/* 8224ED00h case    4:*/		return 0x8224ED04;
	}
	return 0x8224ED04;
} // Block from 8224ECF0h-8224ED04h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224ED04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224ED04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224ED04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224ED04);
		  /* 8224ED04h */ case    0:  		/* stw R31, <#[R30 + 4]> */
		/* 8224ED04h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000004) );
		/* 8224ED04h case    0:*/		return 0x8224ED08;
		  /* 8224ED08h */ case    1:  		/* li R7, 0 */
		/* 8224ED08h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8224ED08h case    1:*/		return 0x8224ED0C;
		  /* 8224ED0Ch */ case    2:  		/* li R6, 1 */
		/* 8224ED0Ch case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8224ED0Ch case    2:*/		return 0x8224ED10;
		  /* 8224ED10h */ case    3:  		/* li R5, 0 */
		/* 8224ED10h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8224ED10h case    3:*/		return 0x8224ED14;
		  /* 8224ED14h */ case    4:  		/* mr R4, R29 */
		/* 8224ED14h case    4:*/		regs.R4 = regs.R29;
		/* 8224ED14h case    4:*/		return 0x8224ED18;
		  /* 8224ED18h */ case    5:  		/* mr R3, R21 */
		/* 8224ED18h case    5:*/		regs.R3 = regs.R21;
		/* 8224ED18h case    5:*/		return 0x8224ED1C;
		  /* 8224ED1Ch */ case    6:  		/* bl 98324 */
		/* 8224ED1Ch case    6:*/		regs.LR = 0x8224ED20; return 0x82266D30;
		/* 8224ED1Ch case    6:*/		return 0x8224ED20;
		  /* 8224ED20h */ case    7:  		/* stw R3, <#[R30 + 12]> */
		/* 8224ED20h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000000C) );
		/* 8224ED20h case    7:*/		return 0x8224ED24;
		  /* 8224ED24h */ case    8:  		/* lwz R3, <#[R31 + 52]> */
		/* 8224ED24h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000034) );
		/* 8224ED24h case    8:*/		return 0x8224ED28;
		  /* 8224ED28h */ case    9:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224ED28h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224ED28h case    9:*/		return 0x8224ED2C;
		  /* 8224ED2Ch */ case   10:  		/* bl 19860 */
		/* 8224ED2Ch case   10:*/		regs.LR = 0x8224ED30; return 0x82253AC0;
		/* 8224ED2Ch case   10:*/		return 0x8224ED30;
		  /* 8224ED30h */ case   11:  		/* stw R30, <#[R3]> */
		/* 8224ED30h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224ED30h case   11:*/		return 0x8224ED34;
		  /* 8224ED34h */ case   12:  		/* lwz R9, <#[R24 + 28]> */
		/* 8224ED34h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x0000001C) );
		/* 8224ED34h case   12:*/		return 0x8224ED38;
		  /* 8224ED38h */ case   13:  		/* lwz R11, <#[R30 + 12]> */
		/* 8224ED38h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8224ED38h case   13:*/		return 0x8224ED3C;
		  /* 8224ED3Ch */ case   14:  		/* lwz R10, <#[R28 + 28]> */
		/* 8224ED3Ch case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000001C) );
		/* 8224ED3Ch case   14:*/		return 0x8224ED40;
		  /* 8224ED40h */ case   15:  		/* add R11, R10, R11 */
		/* 8224ED40h case   15:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8224ED40h case   15:*/		return 0x8224ED44;
		  /* 8224ED44h */ case   16:  		/* cmpw CR6, R11, R9 */
		/* 8224ED44h case   16:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R9);
		/* 8224ED44h case   16:*/		return 0x8224ED48;
		  /* 8224ED48h */ case   17:  		/* bc 4, CR6_GT, 32 */
		/* 8224ED48h case   17:*/		if ( !regs.CR[6].gt ) { return 0x8224ED68;  }
		/* 8224ED48h case   17:*/		return 0x8224ED4C;
		  /* 8224ED4Ch */ case   18:  		/* lis R11, -32252 */
		/* 8224ED4Ch case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224ED4Ch case   18:*/		return 0x8224ED50;
		  /* 8224ED50h */ case   19:  		/* mr R6, R17 */
		/* 8224ED50h case   19:*/		regs.R6 = regs.R17;
		/* 8224ED50h case   19:*/		return 0x8224ED54;
		  /* 8224ED54h */ case   20:  		/* addi R5, R11, 15588 */
		/* 8224ED54h case   20:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3CE4);
		/* 8224ED54h case   20:*/		return 0x8224ED58;
		  /* 8224ED58h */ case   21:  		/* mr R4, R18 */
		/* 8224ED58h case   21:*/		regs.R4 = regs.R18;
		/* 8224ED58h case   21:*/		return 0x8224ED5C;
		  /* 8224ED5Ch */ case   22:  		/* li R7, 1639 */
		/* 8224ED5Ch case   22:*/		cpu::op::li<0>(regs,&regs.R7,0x667);
		/* 8224ED5Ch case   22:*/		return 0x8224ED60;
		  /* 8224ED60h */ case   23:  		/* li R3, 0 */
		/* 8224ED60h case   23:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224ED60h case   23:*/		return 0x8224ED64;
		  /* 8224ED64h */ case   24:  		/* bl -1012060 */
		/* 8224ED64h case   24:*/		regs.LR = 0x8224ED68; return 0x82157C08;
		/* 8224ED64h case   24:*/		return 0x8224ED68;
	}
	return 0x8224ED68;
} // Block from 8224ED04h-8224ED68h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8224ED68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224ED68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224ED68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224ED68);
		  /* 8224ED68h */ case    0:  		/* lwz R11, <#[R24]> */
		/* 8224ED68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 8224ED68h case    0:*/		return 0x8224ED6C;
		  /* 8224ED6Ch */ case    1:  		/* li R4, 24 */
		/* 8224ED6Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 8224ED6Ch case    1:*/		return 0x8224ED70;
		  /* 8224ED70h */ case    2:  		/* lwz R28, <#[R11 + 1456]> */
		/* 8224ED70h case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224ED70h case    2:*/		return 0x8224ED74;
		  /* 8224ED74h */ case    3:  		/* mr R3, R28 */
		/* 8224ED74h case    3:*/		regs.R3 = regs.R28;
		/* 8224ED74h case    3:*/		return 0x8224ED78;
		  /* 8224ED78h */ case    4:  		/* bl -207040 */
		/* 8224ED78h case    4:*/		regs.LR = 0x8224ED7C; return 0x8221C4B8;
		/* 8224ED78h case    4:*/		return 0x8224ED7C;
		  /* 8224ED7Ch */ case    5:  		/* addi R30, R3, 4 */
		/* 8224ED7Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x4);
		/* 8224ED7Ch case    5:*/		return 0x8224ED80;
		  /* 8224ED80h */ case    6:  		/* stw R28, <#[R3]> */
		/* 8224ED80h case    6:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 8224ED80h case    6:*/		return 0x8224ED84;
		  /* 8224ED84h */ case    7:  		/* li R7, 0 */
		/* 8224ED84h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8224ED84h case    7:*/		return 0x8224ED88;
		  /* 8224ED88h */ case    8:  		/* li R5, 0 */
		/* 8224ED88h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8224ED88h case    8:*/		return 0x8224ED8C;
		  /* 8224ED8Ch */ case    9:  		/* mr R4, R22 */
		/* 8224ED8Ch case    9:*/		regs.R4 = regs.R22;
		/* 8224ED8Ch case    9:*/		return 0x8224ED90;
		  /* 8224ED90h */ case   10:  		/* mr R3, R29 */
		/* 8224ED90h case   10:*/		regs.R3 = regs.R29;
		/* 8224ED90h case   10:*/		return 0x8224ED94;
		  /* 8224ED94h */ case   11:  		/* stw R31, <#[R30]> */
		/* 8224ED94h case   11:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 8224ED94h case   11:*/		return 0x8224ED98;
		  /* 8224ED98h */ case   12:  		/* stw R23, <#[R30 + 4]> */
		/* 8224ED98h case   12:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R30 + 0x00000004) );
		/* 8224ED98h case   12:*/		return 0x8224ED9C;
		  /* 8224ED9Ch */ case   13:  		/* stw R19, <#[R30 + 8]> */
		/* 8224ED9Ch case   13:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R30 + 0x00000008) );
		/* 8224ED9Ch case   13:*/		return 0x8224EDA0;
		  /* 8224EDA0h */ case   14:  		/* lwz R6, <#[R22 + 20]> */
		/* 8224EDA0h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R22 + 0x00000014) );
		/* 8224EDA0h case   14:*/		return 0x8224EDA4;
		  /* 8224EDA4h */ case   15:  		/* bl 98188 */
		/* 8224EDA4h case   15:*/		regs.LR = 0x8224EDA8; return 0x82266D30;
		/* 8224EDA4h case   15:*/		return 0x8224EDA8;
		  /* 8224EDA8h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 8224EDA8h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8224EDA8h case   16:*/		return 0x8224EDAC;
		  /* 8224EDACh */ case   17:  		/* stw R3, <#[R30 + 12]> */
		/* 8224EDACh case   17:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000000C) );
		/* 8224EDACh case   17:*/		return 0x8224EDB0;
		  /* 8224EDB0h */ case   18:  		/* bc 12, CR0_EQ, 32 */
		/* 8224EDB0h case   18:*/		if ( regs.CR[0].eq ) { return 0x8224EDD0;  }
		/* 8224EDB0h case   18:*/		return 0x8224EDB4;
		  /* 8224EDB4h */ case   19:  		/* lis R11, -32252 */
		/* 8224EDB4h case   19:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224EDB4h case   19:*/		return 0x8224EDB8;
		  /* 8224EDB8h */ case   20:  		/* mr R6, R17 */
		/* 8224EDB8h case   20:*/		regs.R6 = regs.R17;
		/* 8224EDB8h case   20:*/		return 0x8224EDBC;
		  /* 8224EDBCh */ case   21:  		/* addi R5, R11, 15568 */
		/* 8224EDBCh case   21:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3CD0);
		/* 8224EDBCh case   21:*/		return 0x8224EDC0;
		  /* 8224EDC0h */ case   22:  		/* mr R4, R18 */
		/* 8224EDC0h case   22:*/		regs.R4 = regs.R18;
		/* 8224EDC0h case   22:*/		return 0x8224EDC4;
		  /* 8224EDC4h */ case   23:  		/* li R7, 1647 */
		/* 8224EDC4h case   23:*/		cpu::op::li<0>(regs,&regs.R7,0x66F);
		/* 8224EDC4h case   23:*/		return 0x8224EDC8;
		  /* 8224EDC8h */ case   24:  		/* li R3, 0 */
		/* 8224EDC8h case   24:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224EDC8h case   24:*/		return 0x8224EDCC;
		  /* 8224EDCCh */ case   25:  		/* bl -1012164 */
		/* 8224EDCCh case   25:*/		regs.LR = 0x8224EDD0; return 0x82157C08;
		/* 8224EDCCh case   25:*/		return 0x8224EDD0;
	}
	return 0x8224EDD0;
} // Block from 8224ED68h-8224EDD0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8224EDD0h
// Function '?CleanGraph@Scheduler@XGRAPHICS@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EDD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EDD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EDD0);
		  /* 8224EDD0h */ case    0:  		/* lwz R3, <#[R31 + 48]> */
		/* 8224EDD0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8224EDD0h case    0:*/		return 0x8224EDD4;
		  /* 8224EDD4h */ case    1:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224EDD4h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224EDD4h case    1:*/		return 0x8224EDD8;
		  /* 8224EDD8h */ case    2:  		/* bl 19688 */
		/* 8224EDD8h case    2:*/		regs.LR = 0x8224EDDC; return 0x82253AC0;
		/* 8224EDD8h case    2:*/		return 0x8224EDDC;
		  /* 8224EDDCh */ case    3:  		/* stw R30, <#[R3]> */
		/* 8224EDDCh case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224EDDCh case    3:*/		return 0x8224EDE0;
		  /* 8224EDE0h */ case    4:  		/* lwz R3, <#[R23 + 52]> */
		/* 8224EDE0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000034) );
		/* 8224EDE0h case    4:*/		return 0x8224EDE4;
		  /* 8224EDE4h */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224EDE4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224EDE4h case    5:*/		return 0x8224EDE8;
		  /* 8224EDE8h */ case    6:  		/* cmplw CR6, R27, R11 */
		/* 8224EDE8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 8224EDE8h case    6:*/		return 0x8224EDEC;
		  /* 8224EDECh */ case    7:  		/* bc 4, CR6_LT, 20 */
		/* 8224EDECh case    7:*/		if ( !regs.CR[6].lt ) { return 0x8224EE00;  }
		/* 8224EDECh case    7:*/		return 0x8224EDF0;
		  /* 8224EDF0h */ case    8:  		/* lwz R10, <#[R3 + 8]> */
		/* 8224EDF0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 8224EDF0h case    8:*/		return 0x8224EDF4;
		  /* 8224EDF4h */ case    9:  		/* rlwinm R11, R27, 2, 0, 29 */
		/* 8224EDF4h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R27);
		/* 8224EDF4h case    9:*/		return 0x8224EDF8;
		  /* 8224EDF8h */ case   10:  		/* add R3, R10, R11 */
		/* 8224EDF8h case   10:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8224EDF8h case   10:*/		return 0x8224EDFC;
		  /* 8224EDFCh */ case   11:  		/* b 12 */
		/* 8224EDFCh case   11:*/		return 0x8224EE08;
		/* 8224EDFCh case   11:*/		return 0x8224EE00;
	}
	return 0x8224EE00;
} // Block from 8224EDD0h-8224EE00h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224EE00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EE00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EE00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EE00);
		  /* 8224EE00h */ case    0:  		/* mr R4, R27 */
		/* 8224EE00h case    0:*/		regs.R4 = regs.R27;
		/* 8224EE00h case    0:*/		return 0x8224EE04;
		  /* 8224EE04h */ case    1:  		/* bl 19644 */
		/* 8224EE04h case    1:*/		regs.LR = 0x8224EE08; return 0x82253AC0;
		/* 8224EE04h case    1:*/		return 0x8224EE08;
	}
	return 0x8224EE08;
} // Block from 8224EE00h-8224EE08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224EE08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EE08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EE08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EE08);
		  /* 8224EE08h */ case    0:  		/* stw R30, <#[R3]> */
		/* 8224EE08h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224EE08h case    0:*/		return 0x8224EE0C;
		  /* 8224EE0Ch */ case    1:  		/* lwz R11, <#[R31 + 60]> */
		/* 8224EE0Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 8224EE0Ch case    1:*/		return 0x8224EE10;
		  /* 8224EE10h */ case    2:  		/* addi R11, R11, 1 */
		/* 8224EE10h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224EE10h case    2:*/		return 0x8224EE14;
		  /* 8224EE14h */ case    3:  		/* stw R11, <#[R31 + 60]> */
		/* 8224EE14h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 8224EE14h case    3:*/		return 0x8224EE18;
		  /* 8224EE18h */ case    4:  		/* lwz R9, <#[R30 + 12]> */
		/* 8224EE18h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000000C) );
		/* 8224EE18h case    4:*/		return 0x8224EE1C;
		  /* 8224EE1Ch */ case    5:  		/* lwz R10, <#[R24 + 28]> */
		/* 8224EE1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000001C) );
		/* 8224EE1Ch case    5:*/		return 0x8224EE20;
		  /* 8224EE20h */ case    6:  		/* lwz R11, <#[R23 + 36]> */
		/* 8224EE20h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000024) );
		/* 8224EE20h case    6:*/		return 0x8224EE24;
		  /* 8224EE24h */ case    7:  		/* add R10, R9, R10 */
		/* 8224EE24h case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8224EE24h case    7:*/		return 0x8224EE28;
		  /* 8224EE28h */ case    8:  		/* addi R11, R11, 1 */
		/* 8224EE28h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224EE28h case    8:*/		return 0x8224EE2C;
		  /* 8224EE2Ch */ case    9:  		/* stw R10, <#[R23 + 32]> */
		/* 8224EE2Ch case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R23 + 0x00000020) );
		/* 8224EE2Ch case    9:*/		return 0x8224EE30;
		  /* 8224EE30h */ case   10:  		/* stw R11, <#[R23 + 36]> */
		/* 8224EE30h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000024) );
		/* 8224EE30h case   10:*/		return 0x8224EE34;
	}
	return 0x8224EE34;
} // Block from 8224EE08h-8224EE34h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224EE34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EE34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EE34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EE34);
		  /* 8224EE34h */ case    0:  		/* lwz R11, <#[R24 + 136]> */
		/* 8224EE34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000088) );
		/* 8224EE34h case    0:*/		return 0x8224EE38;
		  /* 8224EE38h */ case    1:  		/* mr R4, R29 */
		/* 8224EE38h case    1:*/		regs.R4 = regs.R29;
		/* 8224EE38h case    1:*/		return 0x8224EE3C;
		  /* 8224EE3Ch */ case    2:  		/* lwz R3, <#[R24 + 8]> */
		/* 8224EE3Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000008) );
		/* 8224EE3Ch case    2:*/		return 0x8224EE40;
		  /* 8224EE40h */ case    3:  		/* addi R11, R11, 1 */
		/* 8224EE40h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224EE40h case    3:*/		return 0x8224EE44;
		  /* 8224EE44h */ case    4:  		/* stw R11, <#[R24 + 136]> */
		/* 8224EE44h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x00000088) );
		/* 8224EE44h case    4:*/		return 0x8224EE48;
		  /* 8224EE48h */ case    5:  		/* bl 97496 */
		/* 8224EE48h case    5:*/		regs.LR = 0x8224EE4C; return 0x82266B20;
		/* 8224EE48h case    5:*/		return 0x8224EE4C;
		  /* 8224EE4Ch */ case    6:  		/* mr R3, R31 */
		/* 8224EE4Ch case    6:*/		regs.R3 = regs.R31;
		/* 8224EE4Ch case    6:*/		return 0x8224EE50;
		  /* 8224EE50h */ case    7:  		/* b 8 */
		/* 8224EE50h case    7:*/		return 0x8224EE58;
		/* 8224EE50h case    7:*/		return 0x8224EE54;
	}
	return 0x8224EE54;
} // Block from 8224EE34h-8224EE54h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224EE54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EE54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EE54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EE54);
		  /* 8224EE54h */ case    0:  		/* li R3, 0 */
		/* 8224EE54h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224EE54h case    0:*/		return 0x8224EE58;
	}
	return 0x8224EE58;
} // Block from 8224EE54h-8224EE58h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224EE58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EE58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EE58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EE58);
		  /* 8224EE58h */ case    0:  		/* addi R1, R1, 224 */
		/* 8224EE58h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 8224EE58h case    0:*/		return 0x8224EE5C;
		  /* 8224EE5Ch */ case    1:  		/* b -1825760 */
		/* 8224EE5Ch case    1:*/		return 0x8209127C;
		/* 8224EE5Ch case    1:*/		return 0x8224EE60;
	}
	return 0x8224EE60;
} // Block from 8224EE58h-8224EE60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224EE60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EE60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EE60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EE60);
		  /* 8224EE60h */ case    0:  		/* mfspr R12, LR */
		/* 8224EE60h case    0:*/		regs.R12 = regs.LR;
		/* 8224EE60h case    0:*/		return 0x8224EE64;
		  /* 8224EE64h */ case    1:  		/* bl -1825804 */
		/* 8224EE64h case    1:*/		regs.LR = 0x8224EE68; return 0x82091258;
		/* 8224EE64h case    1:*/		return 0x8224EE68;
		  /* 8224EE68h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8224EE68h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8224EE68h case    2:*/		return 0x8224EE6C;
		  /* 8224EE6Ch */ case    3:  		/* lwz R9, <#[R4 + 28]> */
		/* 8224EE6Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x0000001C) );
		/* 8224EE6Ch case    3:*/		return 0x8224EE70;
		  /* 8224EE70h */ case    4:  		/* lis R11, -32253 */
		/* 8224EE70h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8224EE70h case    4:*/		return 0x8224EE74;
		  /* 8224EE74h */ case    5:  		/* lis R10, -32252 */
		/* 8224EE74h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224EE74h case    5:*/		return 0x8224EE78;
		  /* 8224EE78h */ case    6:  		/* mr R29, R3 */
		/* 8224EE78h case    6:*/		regs.R29 = regs.R3;
		/* 8224EE78h case    6:*/		return 0x8224EE7C;
		  /* 8224EE7Ch */ case    7:  		/* mr R31, R4 */
		/* 8224EE7Ch case    7:*/		regs.R31 = regs.R4;
		/* 8224EE7Ch case    7:*/		return 0x8224EE80;
		  /* 8224EE80h */ case    8:  		/* addi R30, R11, 27460 */
		/* 8224EE80h case    8:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x6B44);
		/* 8224EE80h case    8:*/		return 0x8224EE84;
		  /* 8224EE84h */ case    9:  		/* addi R28, R10, 14208 */
		/* 8224EE84h case    9:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R10,0x3780);
		/* 8224EE84h case    9:*/		return 0x8224EE88;
		  /* 8224EE88h */ case   10:  		/* cmpwi CR6, R9, -1 */
		/* 8224EE88h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 8224EE88h case   10:*/		return 0x8224EE8C;
		  /* 8224EE8Ch */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 8224EE8Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x8224EEAC;  }
		/* 8224EE8Ch case   11:*/		return 0x8224EE90;
		  /* 8224EE90h */ case   12:  		/* lis R11, -32252 */
		/* 8224EE90h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224EE90h case   12:*/		return 0x8224EE94;
		  /* 8224EE94h */ case   13:  		/* mr R6, R28 */
		/* 8224EE94h case   13:*/		regs.R6 = regs.R28;
		/* 8224EE94h case   13:*/		return 0x8224EE98;
		  /* 8224EE98h */ case   14:  		/* addi R5, R11, 14708 */
		/* 8224EE98h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3974);
		/* 8224EE98h case   14:*/		return 0x8224EE9C;
		  /* 8224EE9Ch */ case   15:  		/* mr R4, R30 */
		/* 8224EE9Ch case   15:*/		regs.R4 = regs.R30;
		/* 8224EE9Ch case   15:*/		return 0x8224EEA0;
		  /* 8224EEA0h */ case   16:  		/* li R7, 1780 */
		/* 8224EEA0h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x6F4);
		/* 8224EEA0h case   16:*/		return 0x8224EEA4;
		  /* 8224EEA4h */ case   17:  		/* li R3, 0 */
		/* 8224EEA4h case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224EEA4h case   17:*/		return 0x8224EEA8;
		  /* 8224EEA8h */ case   18:  		/* bl -1012384 */
		/* 8224EEA8h case   18:*/		regs.LR = 0x8224EEAC; return 0x82157C08;
		/* 8224EEA8h case   18:*/		return 0x8224EEAC;
	}
	return 0x8224EEAC;
} // Block from 8224EE60h-8224EEACh (19 instructions)

//////////////////////////////////////////////////////
// Block at 8224EEACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EEAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EEAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EEAC);
		  /* 8224EEACh */ case    0:  		/* lwz R11, <#[R31 + 36]> */
		/* 8224EEACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 8224EEACh case    0:*/		return 0x8224EEB0;
		  /* 8224EEB0h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224EEB0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224EEB0h case    1:*/		return 0x8224EEB4;
		  /* 8224EEB4h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 8224EEB4h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224EED4;  }
		/* 8224EEB4h case    2:*/		return 0x8224EEB8;
		  /* 8224EEB8h */ case    3:  		/* lis R11, -32252 */
		/* 8224EEB8h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224EEB8h case    3:*/		return 0x8224EEBC;
		  /* 8224EEBCh */ case    4:  		/* mr R6, R28 */
		/* 8224EEBCh case    4:*/		regs.R6 = regs.R28;
		/* 8224EEBCh case    4:*/		return 0x8224EEC0;
		  /* 8224EEC0h */ case    5:  		/* addi R5, R11, 14684 */
		/* 8224EEC0h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x395C);
		/* 8224EEC0h case    5:*/		return 0x8224EEC4;
		  /* 8224EEC4h */ case    6:  		/* mr R4, R30 */
		/* 8224EEC4h case    6:*/		regs.R4 = regs.R30;
		/* 8224EEC4h case    6:*/		return 0x8224EEC8;
		  /* 8224EEC8h */ case    7:  		/* li R7, 1781 */
		/* 8224EEC8h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x6F5);
		/* 8224EEC8h case    7:*/		return 0x8224EECC;
		  /* 8224EECCh */ case    8:  		/* li R3, 0 */
		/* 8224EECCh case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224EECCh case    8:*/		return 0x8224EED0;
		  /* 8224EED0h */ case    9:  		/* bl -1012424 */
		/* 8224EED0h case    9:*/		regs.LR = 0x8224EED4; return 0x82157C08;
		/* 8224EED0h case    9:*/		return 0x8224EED4;
	}
	return 0x8224EED4;
} // Block from 8224EEACh-8224EED4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224EED4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EED4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EED4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EED4);
		  /* 8224EED4h */ case    0:  		/* lwz R11, <#[R31 + 32]> */
		/* 8224EED4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8224EED4h case    0:*/		return 0x8224EED8;
		  /* 8224EED8h */ case    1:  		/* lwz R10, <#[R29 + 28]> */
		/* 8224EED8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000001C) );
		/* 8224EED8h case    1:*/		return 0x8224EEDC;
		  /* 8224EEDCh */ case    2:  		/* cmpw CR6, R11, R10 */
		/* 8224EEDCh case    2:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224EEDCh case    2:*/		return 0x8224EEE0;
		  /* 8224EEE0h */ case    3:  		/* bc 4, CR6_GT, 32 */
		/* 8224EEE0h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8224EF00;  }
		/* 8224EEE0h case    3:*/		return 0x8224EEE4;
		  /* 8224EEE4h */ case    4:  		/* lis R11, -32252 */
		/* 8224EEE4h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224EEE4h case    4:*/		return 0x8224EEE8;
		  /* 8224EEE8h */ case    5:  		/* mr R6, R28 */
		/* 8224EEE8h case    5:*/		regs.R6 = regs.R28;
		/* 8224EEE8h case    5:*/		return 0x8224EEEC;
		  /* 8224EEECh */ case    6:  		/* addi R5, R11, 15712 */
		/* 8224EEECh case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3D60);
		/* 8224EEECh case    6:*/		return 0x8224EEF0;
		  /* 8224EEF0h */ case    7:  		/* mr R4, R30 */
		/* 8224EEF0h case    7:*/		regs.R4 = regs.R30;
		/* 8224EEF0h case    7:*/		return 0x8224EEF4;
		  /* 8224EEF4h */ case    8:  		/* li R7, 1782 */
		/* 8224EEF4h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x6F6);
		/* 8224EEF4h case    8:*/		return 0x8224EEF8;
		  /* 8224EEF8h */ case    9:  		/* li R3, 0 */
		/* 8224EEF8h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224EEF8h case    9:*/		return 0x8224EEFC;
		  /* 8224EEFCh */ case   10:  		/* bl -1012468 */
		/* 8224EEFCh case   10:*/		regs.LR = 0x8224EF00; return 0x82157C08;
		/* 8224EEFCh case   10:*/		return 0x8224EF00;
	}
	return 0x8224EF00;
} // Block from 8224EED4h-8224EF00h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224EF00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EF00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EF00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EF00);
		  /* 8224EF00h */ case    0:  		/* mr R4, R31 */
		/* 8224EF00h case    0:*/		regs.R4 = regs.R31;
		/* 8224EF00h case    0:*/		return 0x8224EF04;
		  /* 8224EF04h */ case    1:  		/* lwz R3, <#[R29 + 32]> */
		/* 8224EF04h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000020) );
		/* 8224EF04h case    1:*/		return 0x8224EF08;
		  /* 8224EF08h */ case    2:  		/* bl -16408 */
		/* 8224EF08h case    2:*/		regs.LR = 0x8224EF0C; return 0x8224AEF0;
		/* 8224EF08h case    2:*/		return 0x8224EF0C;
		  /* 8224EF0Ch */ case    3:  		/* lwz R10, <#[R29 + 28]> */
		/* 8224EF0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000001C) );
		/* 8224EF0Ch case    3:*/		return 0x8224EF10;
		  /* 8224EF10h */ case    4:  		/* lwz R11, <#[R31 + 12]> */
		/* 8224EF10h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224EF10h case    4:*/		return 0x8224EF14;
		  /* 8224EF14h */ case    5:  		/* stw R10, <#[R31 + 32]> */
		/* 8224EF14h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000020) );
		/* 8224EF14h case    5:*/		return 0x8224EF18;
		  /* 8224EF18h */ case    6:  		/* stw R10, <#[R31 + 28]> */
		/* 8224EF18h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 8224EF18h case    6:*/		return 0x8224EF1C;
		  /* 8224EF1Ch */ case    7:  		/* lwz R10, <#[R29 + 112]> */
		/* 8224EF1Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000070) );
		/* 8224EF1Ch case    7:*/		return 0x8224EF20;
		  /* 8224EF20h */ case    8:  		/* cmpw CR6, R11, R10 */
		/* 8224EF20h case    8:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224EF20h case    8:*/		return 0x8224EF24;
		  /* 8224EF24h */ case    9:  		/* bc 4, CR6_LT, 8 */
		/* 8224EF24h case    9:*/		if ( !regs.CR[6].lt ) { return 0x8224EF2C;  }
		/* 8224EF24h case    9:*/		return 0x8224EF28;
		  /* 8224EF28h */ case   10:  		/* stw R11, <#[R29 + 112]> */
		/* 8224EF28h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000070) );
		/* 8224EF28h case   10:*/		return 0x8224EF2C;
	}
	return 0x8224EF2C;
} // Block from 8224EF00h-8224EF2Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224EF2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EF2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EF2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EF2C);
		  /* 8224EF2Ch */ case    0:  		/* mr R4, R31 */
		/* 8224EF2Ch case    0:*/		regs.R4 = regs.R31;
		/* 8224EF2Ch case    0:*/		return 0x8224EF30;
		  /* 8224EF30h */ case    1:  		/* mr R3, R29 */
		/* 8224EF30h case    1:*/		regs.R3 = regs.R29;
		/* 8224EF30h case    1:*/		return 0x8224EF34;
		  /* 8224EF34h */ case    2:  		/* bl -5508 */
		/* 8224EF34h case    2:*/		regs.LR = 0x8224EF38; return 0x8224D9B0;
		/* 8224EF34h case    2:*/		return 0x8224EF38;
		  /* 8224EF38h */ case    3:  		/* mr R4, R31 */
		/* 8224EF38h case    3:*/		regs.R4 = regs.R31;
		/* 8224EF38h case    3:*/		return 0x8224EF3C;
		  /* 8224EF3Ch */ case    4:  		/* mr R3, R29 */
		/* 8224EF3Ch case    4:*/		regs.R3 = regs.R29;
		/* 8224EF3Ch case    4:*/		return 0x8224EF40;
		  /* 8224EF40h */ case    5:  		/* bl -3984 */
		/* 8224EF40h case    5:*/		regs.LR = 0x8224EF44; return 0x8224DFB0;
		/* 8224EF40h case    5:*/		return 0x8224EF44;
		  /* 8224EF44h */ case    6:  		/* lwz R11, <#[R29 + 120]> */
		/* 8224EF44h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000078) );
		/* 8224EF44h case    6:*/		return 0x8224EF48;
		  /* 8224EF48h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8224EF48h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224EF48h case    7:*/		return 0x8224EF4C;
		  /* 8224EF4Ch */ case    8:  		/* bc 12, CR6_EQ, 188 */
		/* 8224EF4Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x8224F008;  }
		/* 8224EF4Ch case    8:*/		return 0x8224EF50;
		  /* 8224EF50h */ case    9:  		/* lwz R3, <#[R31 + 40]> */
		/* 8224EF50h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000028) );
		/* 8224EF50h case    9:*/		return 0x8224EF54;
		  /* 8224EF54h */ case   10:  		/* lwz R11, <#[R11 + 40]> */
		/* 8224EF54h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8224EF54h case   10:*/		return 0x8224EF58;
		  /* 8224EF58h */ case   11:  		/* lwz R10, <#[R3]> */
		/* 8224EF58h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8224EF58h case   11:*/		return 0x8224EF5C;
		  /* 8224EF5Ch */ case   12:  		/* lwz R30, <#[R11 + 172]> */
		/* 8224EF5Ch case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000000AC) );
		/* 8224EF5Ch case   12:*/		return 0x8224EF60;
		  /* 8224EF60h */ case   13:  		/* lwz R11, <#[R10 + 68]> */
		/* 8224EF60h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000044) );
		/* 8224EF60h case   13:*/		return 0x8224EF64;
		  /* 8224EF64h */ case   14:  		/* mtspr CTR, R11 */
		/* 8224EF64h case   14:*/		regs.CTR = regs.R11;
		/* 8224EF64h case   14:*/		return 0x8224EF68;
		  /* 8224EF68h */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 8224EF68h case   15:*/		if ( 1 ) { regs.LR = 0x8224EF6C; return (uint32)regs.CTR; }
		/* 8224EF68h case   15:*/		return 0x8224EF6C;
		  /* 8224EF6Ch */ case   16:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224EF6Ch case   16:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224EF6Ch case   16:*/		return 0x8224EF70;
		  /* 8224EF70h */ case   17:  		/* bc 12, CR0_EQ, 52 */
		/* 8224EF70h case   17:*/		if ( regs.CR[0].eq ) { return 0x8224EFA4;  }
		/* 8224EF70h case   17:*/		return 0x8224EF74;
		  /* 8224EF74h */ case   18:  		/* lwz R3, <#[R31 + 40]> */
		/* 8224EF74h case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000028) );
		/* 8224EF74h case   18:*/		return 0x8224EF78;
		  /* 8224EF78h */ case   19:  		/* lwz R10, <#[R30 + 56]> */
		/* 8224EF78h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000038) );
		/* 8224EF78h case   19:*/		return 0x8224EF7C;
		  /* 8224EF7Ch */ case   20:  		/* lwz R11, <#[R3 + 236]> */
		/* 8224EF7Ch case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000EC) );
		/* 8224EF7Ch case   20:*/		return 0x8224EF80;
		  /* 8224EF80h */ case   21:  		/* lwz R9, <#[R11 + 56]> */
		/* 8224EF80h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000038) );
		/* 8224EF80h case   21:*/		return 0x8224EF84;
		  /* 8224EF84h */ case   22:  		/* cmpw CR6, R9, R10 */
		/* 8224EF84h case   22:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R10);
		/* 8224EF84h case   22:*/		return 0x8224EF88;
		  /* 8224EF88h */ case   23:  		/* bc 4, CR6_EQ, 128 */
		/* 8224EF88h case   23:*/		if ( !regs.CR[6].eq ) { return 0x8224F008;  }
		/* 8224EF88h case   23:*/		return 0x8224EF8C;
		  /* 8224EF8Ch */ case   24:  		/* cmplw CR6, R11, R30 */
		/* 8224EF8Ch case   24:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 8224EF8Ch case   24:*/		return 0x8224EF90;
		  /* 8224EF90h */ case   25:  		/* bc 12, CR6_EQ, 120 */
		/* 8224EF90h case   25:*/		if ( regs.CR[6].eq ) { return 0x8224F008;  }
		/* 8224EF90h case   25:*/		return 0x8224EF94;
		  /* 8224EF94h */ case   26:  		/* mr R5, R30 */
		/* 8224EF94h case   26:*/		regs.R5 = regs.R30;
		/* 8224EF94h case   26:*/		return 0x8224EF98;
		  /* 8224EF98h */ case   27:  		/* li R4, 1 */
		/* 8224EF98h case   27:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224EF98h case   27:*/		return 0x8224EF9C;
		  /* 8224EF9Ch */ case   28:  		/* bl -102476 */
		/* 8224EF9Ch case   28:*/		regs.LR = 0x8224EFA0; return 0x82235F50;
		/* 8224EF9Ch case   28:*/		return 0x8224EFA0;
		  /* 8224EFA0h */ case   29:  		/* b 104 */
		/* 8224EFA0h case   29:*/		return 0x8224F008;
		/* 8224EFA0h case   29:*/		return 0x8224EFA4;
	}
	return 0x8224EFA4;
} // Block from 8224EF2Ch-8224EFA4h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8224EFA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EFA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EFA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EFA4);
		  /* 8224EFA4h */ case    0:  		/* lwz R11, <#[R31 + 40]> */
		/* 8224EFA4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8224EFA4h case    0:*/		return 0x8224EFA8;
		  /* 8224EFA8h */ case    1:  		/* cmplw CR6, R11, R30 */
		/* 8224EFA8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 8224EFA8h case    1:*/		return 0x8224EFAC;
		  /* 8224EFACh */ case    2:  		/* bc 4, CR6_EQ, 92 */
		/* 8224EFACh case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224F008;  }
		/* 8224EFACh case    2:*/		return 0x8224EFB0;
		  /* 8224EFB0h */ case    3:  		/* lwz R10, <#[R11 + 228]> */
		/* 8224EFB0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 8224EFB0h case    3:*/		return 0x8224EFB4;
		  /* 8224EFB4h */ case    4:  		/* rlwinm. R10, R10, 23, 31, 31 */
		/* 8224EFB4h case    4:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R10,regs.R10);
		/* 8224EFB4h case    4:*/		return 0x8224EFB8;
		  /* 8224EFB8h */ case    5:  		/* bc 12, CR0_EQ, 80 */
		/* 8224EFB8h case    5:*/		if ( regs.CR[0].eq ) { return 0x8224F008;  }
		/* 8224EFB8h case    5:*/		return 0x8224EFBC;
		  /* 8224EFBCh */ case    6:  		/* lwz R10, <#[R29 + 120]> */
		/* 8224EFBCh case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000078) );
		/* 8224EFBCh case    6:*/		return 0x8224EFC0;
		  /* 8224EFC0h */ case    7:  		/* lwz R9, <#[R11 + 228]> */
		/* 8224EFC0h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x000000E4) );
		/* 8224EFC0h case    7:*/		return 0x8224EFC4;
		  /* 8224EFC4h */ case    8:  		/* rlwinm. R9, R9, 23, 31, 31 */
		/* 8224EFC4h case    8:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R9,regs.R9);
		/* 8224EFC4h case    8:*/		return 0x8224EFC8;
		  /* 8224EFC8h */ case    9:  		/* lwz R10, <#[R10 + 40]> */
		/* 8224EFC8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000028) );
		/* 8224EFC8h case    9:*/		return 0x8224EFCC;
		  /* 8224EFCCh */ case   10:  		/* lwz R9, <#[R10 + 236]> */
		/* 8224EFCCh case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x000000EC) );
		/* 8224EFCCh case   10:*/		return 0x8224EFD0;
		  /* 8224EFD0h */ case   11:  		/* lwz R10, <#[R11 + 20]> */
		/* 8224EFD0h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 8224EFD0h case   11:*/		return 0x8224EFD4;
		  /* 8224EFD4h */ case   12:  		/* bc 12, CR0_EQ, 20 */
		/* 8224EFD4h case   12:*/		if ( regs.CR[0].eq ) { return 0x8224EFE8;  }
		/* 8224EFD4h case   12:*/		return 0x8224EFD8;
		  /* 8224EFD8h */ case   13:  		/* addi R10, R10, 58 */
		/* 8224EFD8h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x3A);
		/* 8224EFD8h case   13:*/		return 0x8224EFDC;
		  /* 8224EFDCh */ case   14:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8224EFDCh case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8224EFDCh case   14:*/		return 0x8224EFE0;
		  /* 8224EFE0h */ case   15:  		/* stwx R9, <#[R10 + R11]> */
		/* 8224EFE0h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8224EFE0h case   15:*/		return 0x8224EFE4;
		  /* 8224EFE4h */ case   16:  		/* b 36 */
		/* 8224EFE4h case   16:*/		return 0x8224F008;
		/* 8224EFE4h case   16:*/		return 0x8224EFE8;
	}
	return 0x8224EFE8;
} // Block from 8224EFA4h-8224EFE8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8224EFE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224EFE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224EFE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224EFE8);
		  /* 8224EFE8h */ case    0:  		/* addi R10, R10, 1 */
		/* 8224EFE8h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8224EFE8h case    0:*/		return 0x8224EFEC;
		  /* 8224EFECh */ case    1:  		/* addi R8, R10, 58 */
		/* 8224EFECh case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x3A);
		/* 8224EFECh case    1:*/		return 0x8224EFF0;
		  /* 8224EFF0h */ case    2:  		/* stw R10, <#[R11 + 20]> */
		/* 8224EFF0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 8224EFF0h case    2:*/		return 0x8224EFF4;
		  /* 8224EFF4h */ case    3:  		/* rlwinm R10, R8, 2, 0, 29 */
		/* 8224EFF4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R8);
		/* 8224EFF4h case    3:*/		return 0x8224EFF8;
		  /* 8224EFF8h */ case    4:  		/* stwx R9, <#[R10 + R11]> */
		/* 8224EFF8h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8224EFF8h case    4:*/		return 0x8224EFFC;
		  /* 8224EFFCh */ case    5:  		/* lwz R10, <#[R11 + 228]> */
		/* 8224EFFCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 8224EFFCh case    5:*/		return 0x8224F000;
		  /* 8224F000h */ case    6:  		/* ori R10, R10, 512 */
		/* 8224F000h case    6:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x200);
		/* 8224F000h case    6:*/		return 0x8224F004;
		  /* 8224F004h */ case    7:  		/* stw R10, <#[R11 + 228]> */
		/* 8224F004h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 8224F004h case    7:*/		return 0x8224F008;
	}
	return 0x8224F008;
} // Block from 8224EFE8h-8224F008h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224F008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F008);
		  /* 8224F008h */ case    0:  		/* lwz R3, <#[R31 + 40]> */
		/* 8224F008h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000028) );
		/* 8224F008h case    0:*/		return 0x8224F00C;
		  /* 8224F00Ch */ case    1:  		/* lwz R11, <#[R3]> */
		/* 8224F00Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224F00Ch case    1:*/		return 0x8224F010;
		  /* 8224F010h */ case    2:  		/* lwz R11, <#[R11 + 68]> */
		/* 8224F010h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000044) );
		/* 8224F010h case    2:*/		return 0x8224F014;
		  /* 8224F014h */ case    3:  		/* mtspr CTR, R11 */
		/* 8224F014h case    3:*/		regs.CTR = regs.R11;
		/* 8224F014h case    3:*/		return 0x8224F018;
		  /* 8224F018h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8224F018h case    4:*/		if ( 1 ) { regs.LR = 0x8224F01C; return (uint32)regs.CTR; }
		/* 8224F018h case    4:*/		return 0x8224F01C;
		  /* 8224F01Ch */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224F01Ch case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224F01Ch case    5:*/		return 0x8224F020;
		  /* 8224F020h */ case    6:  		/* bc 12, CR0_EQ, 8 */
		/* 8224F020h case    6:*/		if ( regs.CR[0].eq ) { return 0x8224F028;  }
		/* 8224F020h case    6:*/		return 0x8224F024;
		  /* 8224F024h */ case    7:  		/* stw R31, <#[R29 + 120]> */
		/* 8224F024h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R29 + 0x00000078) );
		/* 8224F024h case    7:*/		return 0x8224F028;
	}
	return 0x8224F028;
} // Block from 8224F008h-8224F028h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224F028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F028);
		  /* 8224F028h */ case    0:  		/* lwz R3, <#[R29 + 8]> */
		/* 8224F028h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000008) );
		/* 8224F028h case    0:*/		return 0x8224F02C;
		  /* 8224F02Ch */ case    1:  		/* lwz R4, <#[R31 + 40]> */
		/* 8224F02Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000028) );
		/* 8224F02Ch case    1:*/		return 0x8224F030;
		  /* 8224F030h */ case    2:  		/* lwz R11, <#[R3]> */
		/* 8224F030h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224F030h case    2:*/		return 0x8224F034;
		  /* 8224F034h */ case    3:  		/* lwz R11, <#[R11 + 8]> */
		/* 8224F034h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8224F034h case    3:*/		return 0x8224F038;
		  /* 8224F038h */ case    4:  		/* mtspr CTR, R11 */
		/* 8224F038h case    4:*/		regs.CTR = regs.R11;
		/* 8224F038h case    4:*/		return 0x8224F03C;
		  /* 8224F03Ch */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 8224F03Ch case    5:*/		if ( 1 ) { regs.LR = 0x8224F040; return (uint32)regs.CTR; }
		/* 8224F03Ch case    5:*/		return 0x8224F040;
		  /* 8224F040h */ case    6:  		/* lwz R4, <#[R31 + 40]> */
		/* 8224F040h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000028) );
		/* 8224F040h case    6:*/		return 0x8224F044;
		  /* 8224F044h */ case    7:  		/* lwz R3, <#[R29 + 8]> */
		/* 8224F044h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000008) );
		/* 8224F044h case    7:*/		return 0x8224F048;
		  /* 8224F048h */ case    8:  		/* bl 97112 */
		/* 8224F048h case    8:*/		regs.LR = 0x8224F04C; return 0x82266BA0;
		/* 8224F048h case    8:*/		return 0x8224F04C;
		  /* 8224F04Ch */ case    9:  		/* mr R4, R31 */
		/* 8224F04Ch case    9:*/		regs.R4 = regs.R31;
		/* 8224F04Ch case    9:*/		return 0x8224F050;
		  /* 8224F050h */ case   10:  		/* lwz R3, <#[R29 + 12]> */
		/* 8224F050h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x0000000C) );
		/* 8224F050h case   10:*/		return 0x8224F054;
		  /* 8224F054h */ case   11:  		/* bl -13116 */
		/* 8224F054h case   11:*/		regs.LR = 0x8224F058; return 0x8224BD18;
		/* 8224F054h case   11:*/		return 0x8224F058;
		  /* 8224F058h */ case   12:  		/* addi R1, R1, 128 */
		/* 8224F058h case   12:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8224F058h case   12:*/		return 0x8224F05C;
		  /* 8224F05Ch */ case   13:  		/* b -1826228 */
		/* 8224F05Ch case   13:*/		return 0x820912A8;
		/* 8224F05Ch case   13:*/		return 0x8224F060;
	}
	return 0x8224F060;
} // Block from 8224F028h-8224F060h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224F060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F060);
		  /* 8224F060h */ case    0:  		/* mfspr R12, LR */
		/* 8224F060h case    0:*/		regs.R12 = regs.LR;
		/* 8224F060h case    0:*/		return 0x8224F064;
		  /* 8224F064h */ case    1:  		/* bl -1826312 */
		/* 8224F064h case    1:*/		regs.LR = 0x8224F068; return 0x8209125C;
		/* 8224F064h case    1:*/		return 0x8224F068;
		  /* 8224F068h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8224F068h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8224F068h case    2:*/		return 0x8224F06C;
		  /* 8224F06Ch */ case    3:  		/* mr R31, R3 */
		/* 8224F06Ch case    3:*/		regs.R31 = regs.R3;
		/* 8224F06Ch case    3:*/		return 0x8224F070;
		  /* 8224F070h */ case    4:  		/* b 16 */
		/* 8224F070h case    4:*/		return 0x8224F080;
		/* 8224F070h case    4:*/		return 0x8224F074;
		  /* 8224F074h */ case    5:  		/* mr R4, R3 */
		/* 8224F074h case    5:*/		regs.R4 = regs.R3;
		/* 8224F074h case    5:*/		return 0x8224F078;
		  /* 8224F078h */ case    6:  		/* mr R3, R31 */
		/* 8224F078h case    6:*/		regs.R3 = regs.R31;
		/* 8224F078h case    6:*/		return 0x8224F07C;
		  /* 8224F07Ch */ case    7:  		/* bl -540 */
		/* 8224F07Ch case    7:*/		regs.LR = 0x8224F080; return 0x8224EE60;
		/* 8224F07Ch case    7:*/		return 0x8224F080;
	}
	return 0x8224F080;
} // Block from 8224F060h-8224F080h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224F080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F080);
		  /* 8224F080h */ case    0:  		/* mr R3, R31 */
		/* 8224F080h case    0:*/		regs.R3 = regs.R31;
		/* 8224F080h case    0:*/		return 0x8224F084;
		  /* 8224F084h */ case    1:  		/* bl -2756 */
		/* 8224F084h case    1:*/		regs.LR = 0x8224F088; return 0x8224E5C0;
		/* 8224F084h case    1:*/		return 0x8224F088;
		  /* 8224F088h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 8224F088h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8224F088h case    2:*/		return 0x8224F08C;
		  /* 8224F08Ch */ case    3:  		/* bc 4, CR0_EQ, -24 */
		/* 8224F08Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8224F074;  }
		/* 8224F08Ch case    3:*/		return 0x8224F090;
		  /* 8224F090h */ case    4:  		/* lwz R3, <#[R31 + 12]> */
		/* 8224F090h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224F090h case    4:*/		return 0x8224F094;
		  /* 8224F094h */ case    5:  		/* lwz R4, <#[R31 + 32]> */
		/* 8224F094h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000020) );
		/* 8224F094h case    5:*/		return 0x8224F098;
		  /* 8224F098h */ case    6:  		/* bl -18208 */
		/* 8224F098h case    6:*/		regs.LR = 0x8224F09C; return 0x8224A978;
		/* 8224F098h case    6:*/		return 0x8224F09C;
		  /* 8224F09Ch */ case    7:  		/* li R11, 0 */
		/* 8224F09Ch case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224F09Ch case    7:*/		return 0x8224F0A0;
		  /* 8224F0A0h */ case    8:  		/* li R29, 0 */
		/* 8224F0A0h case    8:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8224F0A0h case    8:*/		return 0x8224F0A4;
		  /* 8224F0A4h */ case    9:  		/* lwz R10, <#[R31 + 32]> */
		/* 8224F0A4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000020) );
		/* 8224F0A4h case    9:*/		return 0x8224F0A8;
		  /* 8224F0A8h */ case   10:  		/* lwzx R10, <#[R10 + R29]> */
		/* 8224F0A8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 8224F0A8h case   10:*/		return 0x8224F0AC;
		  /* 8224F0ACh */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 8224F0ACh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8224F0ACh case   11:*/		return 0x8224F0B0;
		  /* 8224F0B0h */ case   12:  		/* bc 12, CR6_EQ, 52 */
		/* 8224F0B0h case   12:*/		if ( regs.CR[6].eq ) { return 0x8224F0E4;  }
		/* 8224F0B0h case   12:*/		return 0x8224F0B4;
		  /* 8224F0B4h */ case   13:  		/* lwz R11, <#[R31 + 32]> */
		/* 8224F0B4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8224F0B4h case   13:*/		return 0x8224F0B8;
		  /* 8224F0B8h */ case   14:  		/* li R10, 0 */
		/* 8224F0B8h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8224F0B8h case   14:*/		return 0x8224F0BC;
		  /* 8224F0BCh */ case   15:  		/* lwzx R9, <#[R11 + R29]> */
		/* 8224F0BCh case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 8224F0BCh case   15:*/		return 0x8224F0C0;
		  /* 8224F0C0h */ case   16:  		/* lwz R30, <#[R9 + 40]> */
		/* 8224F0C0h case   16:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + 0x00000028) );
		/* 8224F0C0h case   16:*/		return 0x8224F0C4;
		  /* 8224F0C4h */ case   17:  		/* stwx R10, <#[R11 + R29]> */
		/* 8224F0C4h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 8224F0C4h case   17:*/		return 0x8224F0C8;
		  /* 8224F0C8h */ case   18:  		/* mr R4, R30 */
		/* 8224F0C8h case   18:*/		regs.R4 = regs.R30;
		/* 8224F0C8h case   18:*/		return 0x8224F0CC;
		  /* 8224F0CCh */ case   19:  		/* lwz R3, <#[R31 + 16]> */
		/* 8224F0CCh case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8224F0CCh case   19:*/		return 0x8224F0D0;
		  /* 8224F0D0h */ case   20:  		/* bl 40544 */
		/* 8224F0D0h case   20:*/		regs.LR = 0x8224F0D4; return 0x82258F30;
		/* 8224F0D0h case   20:*/		return 0x8224F0D4;
		  /* 8224F0D4h */ case   21:  		/* lwz R10, <#[R30 + 228]> */
		/* 8224F0D4h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x000000E4) );
		/* 8224F0D4h case   21:*/		return 0x8224F0D8;
	}
	return 0x8224F0D8;
} // Block from 8224F080h-8224F0D8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8224F0D8h
// Function '?SelectFromReadyList@Scheduler@XGRAPHICS@@AAAPAVSchedNode@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F0D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F0D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F0D8);
		  /* 8224F0D8h */ case    0:  		/* ori R10, R10, 4 */
		/* 8224F0D8h case    0:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8224F0D8h case    0:*/		return 0x8224F0DC;
		  /* 8224F0DCh */ case    1:  		/* mr R11, R30 */
		/* 8224F0DCh case    1:*/		regs.R11 = regs.R30;
		/* 8224F0DCh case    1:*/		return 0x8224F0E0;
		  /* 8224F0E0h */ case    2:  		/* stw R10, <#[R30 + 228]> */
		/* 8224F0E0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x000000E4) );
		/* 8224F0E0h case    2:*/		return 0x8224F0E4;
	}
	return 0x8224F0E4;
} // Block from 8224F0D8h-8224F0E4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224F0E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F0E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F0E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F0E4);
		  /* 8224F0E4h */ case    0:  		/* addi R29, R29, 4 */
		/* 8224F0E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8224F0E4h case    0:*/		return 0x8224F0E8;
		  /* 8224F0E8h */ case    1:  		/* cmpwi CR6, R29, 8 */
		/* 8224F0E8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000008);
		/* 8224F0E8h case    1:*/		return 0x8224F0EC;
		  /* 8224F0ECh */ case    2:  		/* bc 12, CR6_LT, -72 */
		/* 8224F0ECh case    2:*/		if ( regs.CR[6].lt ) { return 0x8224F0A4;  }
		/* 8224F0ECh case    2:*/		return 0x8224F0F0;
		  /* 8224F0F0h */ case    3:  		/* lwz R10, <#[R31 + 32]> */
		/* 8224F0F0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000020) );
		/* 8224F0F0h case    3:*/		return 0x8224F0F4;
		  /* 8224F0F4h */ case    4:  		/* lwz R3, <#[R10 + 16]> */
		/* 8224F0F4h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x00000010) );
		/* 8224F0F4h case    4:*/		return 0x8224F0F8;
		  /* 8224F0F8h */ case    5:  		/* lwz R30, <#[R3 + 8]> */
		/* 8224F0F8h case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000008) );
		/* 8224F0F8h case    5:*/		return 0x8224F0FC;
		  /* 8224F0FCh */ case    6:  		/* b 48 */
		/* 8224F0FCh case    6:*/		return 0x8224F12C;
		/* 8224F0FCh case    6:*/		return 0x8224F100;
		  /* 8224F100h */ case    7:  		/* lwz R29, <#[R3 + 40]> */
		/* 8224F100h case    7:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000028) );
		/* 8224F100h case    7:*/		return 0x8224F104;
		  /* 8224F104h */ case    8:  		/* bl 18180 */
		/* 8224F104h case    8:*/		regs.LR = 0x8224F108; return 0x82253808;
		/* 8224F104h case    8:*/		return 0x8224F108;
		  /* 8224F108h */ case    9:  		/* mr R4, R29 */
		/* 8224F108h case    9:*/		regs.R4 = regs.R29;
		/* 8224F108h case    9:*/		return 0x8224F10C;
		  /* 8224F10Ch */ case   10:  		/* lwz R3, <#[R31 + 16]> */
		/* 8224F10Ch case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8224F10Ch case   10:*/		return 0x8224F110;
		  /* 8224F110h */ case   11:  		/* bl 40480 */
		/* 8224F110h case   11:*/		regs.LR = 0x8224F114; return 0x82258F30;
		/* 8224F110h case   11:*/		return 0x8224F114;
		  /* 8224F114h */ case   12:  		/* lwz R10, <#[R29 + 228]> */
		/* 8224F114h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x000000E4) );
		/* 8224F114h case   12:*/		return 0x8224F118;
		  /* 8224F118h */ case   13:  		/* mr R3, R30 */
		/* 8224F118h case   13:*/		regs.R3 = regs.R30;
		/* 8224F118h case   13:*/		return 0x8224F11C;
		  /* 8224F11Ch */ case   14:  		/* ori R10, R10, 4 */
		/* 8224F11Ch case   14:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8224F11Ch case   14:*/		return 0x8224F120;
		  /* 8224F120h */ case   15:  		/* mr R11, R29 */
		/* 8224F120h case   15:*/		regs.R11 = regs.R29;
		/* 8224F120h case   15:*/		return 0x8224F124;
		  /* 8224F124h */ case   16:  		/* stw R10, <#[R29 + 228]> */
		/* 8224F124h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x000000E4) );
		/* 8224F124h case   16:*/		return 0x8224F128;
		  /* 8224F128h */ case   17:  		/* lwz R30, <#[R30 + 8]> */
		/* 8224F128h case   17:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 8224F128h case   17:*/		return 0x8224F12C;
	}
	return 0x8224F12C;
} // Block from 8224F0E4h-8224F12Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 8224F12Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F12C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F12C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F12C);
		  /* 8224F12Ch */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 8224F12Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8224F12Ch case    0:*/		return 0x8224F130;
		  /* 8224F130h */ case    1:  		/* bc 4, CR6_EQ, -48 */
		/* 8224F130h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8224F100;  }
		/* 8224F130h case    1:*/		return 0x8224F134;
		  /* 8224F134h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8224F134h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224F134h case    2:*/		return 0x8224F138;
		  /* 8224F138h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 8224F138h case    3:*/		if ( regs.CR[6].eq ) { return 0x8224F148;  }
		/* 8224F138h case    3:*/		return 0x8224F13C;
		  /* 8224F13Ch */ case    4:  		/* lwz R10, <#[R11 + 228]> */
		/* 8224F13Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 8224F13Ch case    4:*/		return 0x8224F140;
		  /* 8224F140h */ case    5:  		/* rlwinm R10, R10, 0, 30, 28 */
		/* 8224F140h case    5:*/		cpu::op::rlwinm<0,0,30,28>(regs,&regs.R10,regs.R10);
		/* 8224F140h case    5:*/		return 0x8224F144;
		  /* 8224F144h */ case    6:  		/* stw R10, <#[R11 + 228]> */
		/* 8224F144h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 8224F144h case    6:*/		return 0x8224F148;
	}
	return 0x8224F148;
} // Block from 8224F12Ch-8224F148h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224F148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F148);
		  /* 8224F148h */ case    0:  		/* mr R3, R31 */
		/* 8224F148h case    0:*/		regs.R3 = regs.R31;
		/* 8224F148h case    0:*/		return 0x8224F14C;
		  /* 8224F14Ch */ case    1:  		/* bl -5676 */
		/* 8224F14Ch case    1:*/		regs.LR = 0x8224F150; return 0x8224DB20;
		/* 8224F14Ch case    1:*/		return 0x8224F150;
		  /* 8224F150h */ case    2:  		/* addi R30, R31, 36 */
		/* 8224F150h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x24);
		/* 8224F150h case    2:*/		return 0x8224F154;
		  /* 8224F154h */ case    3:  		/* mr R3, R30 */
		/* 8224F154h case    3:*/		regs.R3 = regs.R30;
		/* 8224F154h case    3:*/		return 0x8224F158;
		  /* 8224F158h */ case    4:  		/* bl 17960 */
		/* 8224F158h case    4:*/		regs.LR = 0x8224F15C; return 0x82253780;
		/* 8224F158h case    4:*/		return 0x8224F15C;
		  /* 8224F15Ch */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224F15Ch case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224F15Ch case    5:*/		return 0x8224F160;
		  /* 8224F160h */ case    6:  		/* bc 12, CR0_EQ, 48 */
		/* 8224F160h case    6:*/		if ( regs.CR[0].eq ) { return 0x8224F190;  }
		/* 8224F160h case    6:*/		return 0x8224F164;
		  /* 8224F164h */ case    7:  		/* addi R29, R31, 60 */
		/* 8224F164h case    7:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x3C);
		/* 8224F164h case    7:*/		return 0x8224F168;
		  /* 8224F168h */ case    8:  		/* mr R3, R29 */
		/* 8224F168h case    8:*/		regs.R3 = regs.R29;
		/* 8224F168h case    8:*/		return 0x8224F16C;
		  /* 8224F16Ch */ case    9:  		/* bl 17940 */
		/* 8224F16Ch case    9:*/		regs.LR = 0x8224F170; return 0x82253780;
		/* 8224F16Ch case    9:*/		return 0x8224F170;
		  /* 8224F170h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224F170h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224F170h case   10:*/		return 0x8224F174;
		  /* 8224F174h */ case   11:  		/* bc 4, CR0_EQ, 28 */
		/* 8224F174h case   11:*/		if ( !regs.CR[0].eq ) { return 0x8224F190;  }
		/* 8224F174h case   11:*/		return 0x8224F178;
		  /* 8224F178h */ case   12:  		/* mr R3, R31 */
		/* 8224F178h case   12:*/		regs.R3 = regs.R31;
		/* 8224F178h case   12:*/		return 0x8224F17C;
		  /* 8224F17Ch */ case   13:  		/* bl -5724 */
		/* 8224F17Ch case   13:*/		regs.LR = 0x8224F180; return 0x8224DB20;
		/* 8224F17Ch case   13:*/		return 0x8224F180;
		  /* 8224F180h */ case   14:  		/* mr R3, R30 */
		/* 8224F180h case   14:*/		regs.R3 = regs.R30;
		/* 8224F180h case   14:*/		return 0x8224F184;
		  /* 8224F184h */ case   15:  		/* bl 17916 */
		/* 8224F184h case   15:*/		regs.LR = 0x8224F188; return 0x82253780;
		/* 8224F184h case   15:*/		return 0x8224F188;
		  /* 8224F188h */ case   16:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224F188h case   16:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224F188h case   16:*/		return 0x8224F18C;
		  /* 8224F18Ch */ case   17:  		/* bc 4, CR0_EQ, -36 */
		/* 8224F18Ch case   17:*/		if ( !regs.CR[0].eq ) { return 0x8224F168;  }
		/* 8224F18Ch case   17:*/		return 0x8224F190;
	}
	return 0x8224F190;
} // Block from 8224F148h-8224F190h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8224F190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F190);
		  /* 8224F190h */ case    0:  		/* addi R1, R1, 112 */
		/* 8224F190h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8224F190h case    0:*/		return 0x8224F194;
		  /* 8224F194h */ case    1:  		/* b -1826536 */
		/* 8224F194h case    1:*/		return 0x820912AC;
		/* 8224F194h case    1:*/		return 0x8224F198;
	}
	return 0x8224F198;
} // Block from 8224F190h-8224F198h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224F198h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F198);
		  /* 8224F198h */ case    0:  		/* mfspr R12, LR */
		/* 8224F198h case    0:*/		regs.R12 = regs.LR;
		/* 8224F198h case    0:*/		return 0x8224F19C;
		  /* 8224F19Ch */ case    1:  		/* bl -1826648 */
		/* 8224F19Ch case    1:*/		regs.LR = 0x8224F1A0; return 0x82091244;
		/* 8224F19Ch case    1:*/		return 0x8224F1A0;
		  /* 8224F1A0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 8224F1A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 8224F1A0h case    2:*/		return 0x8224F1A4;
		  /* 8224F1A4h */ case    3:  		/* mr R28, R3 */
		/* 8224F1A4h case    3:*/		regs.R28 = regs.R3;
		/* 8224F1A4h case    3:*/		return 0x8224F1A8;
		  /* 8224F1A8h */ case    4:  		/* mr R23, R4 */
		/* 8224F1A8h case    4:*/		regs.R23 = regs.R4;
		/* 8224F1A8h case    4:*/		return 0x8224F1AC;
		  /* 8224F1ACh */ case    5:  		/* bl -10636 */
		/* 8224F1ACh case    5:*/		regs.LR = 0x8224F1B0; return 0x8224C820;
		/* 8224F1ACh case    5:*/		return 0x8224F1B0;
		  /* 8224F1B0h */ case    6:  		/* mr R3, R28 */
		/* 8224F1B0h case    6:*/		regs.R3 = regs.R28;
		/* 8224F1B0h case    6:*/		return 0x8224F1B4;
		  /* 8224F1B4h */ case    7:  		/* bl -6924 */
		/* 8224F1B4h case    7:*/		regs.LR = 0x8224F1B8; return 0x8224D6A8;
		/* 8224F1B4h case    7:*/		return 0x8224F1B8;
		  /* 8224F1B8h */ case    8:  		/* lwz R11, <#[R28 + 116]> */
		/* 8224F1B8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000074) );
		/* 8224F1B8h case    8:*/		return 0x8224F1BC;
		  /* 8224F1BCh */ case    9:  		/* li R24, 0 */
		/* 8224F1BCh case    9:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 8224F1BCh case    9:*/		return 0x8224F1C0;
		  /* 8224F1C0h */ case   10:  		/* lwz R8, <#[R23 + 100]> */
		/* 8224F1C0h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R23 + 0x00000064) );
		/* 8224F1C0h case   10:*/		return 0x8224F1C4;
		  /* 8224F1C4h */ case   11:  		/* mr R9, R24 */
		/* 8224F1C4h case   11:*/		regs.R9 = regs.R24;
		/* 8224F1C4h case   11:*/		return 0x8224F1C8;
		  /* 8224F1C8h */ case   12:  		/* lwz R10, <#[R11]> */
		/* 8224F1C8h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8224F1C8h case   12:*/		return 0x8224F1CC;
		  /* 8224F1CCh */ case   13:  		/* cmplwi CR6, R10, 0 */
		/* 8224F1CCh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8224F1CCh case   13:*/		return 0x8224F1D0;
		  /* 8224F1D0h */ case   14:  		/* bc 4, CR6_GT, 40 */
		/* 8224F1D0h case   14:*/		if ( !regs.CR[6].gt ) { return 0x8224F1F8;  }
		/* 8224F1D0h case   14:*/		return 0x8224F1D4;
		  /* 8224F1D4h */ case   15:  		/* addi R10, R11, 8 */
		/* 8224F1D4h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x8);
		/* 8224F1D4h case   15:*/		return 0x8224F1D8;
		  /* 8224F1D8h */ case   16:  		/* subf R8, R11, R8 */
		/* 8224F1D8h case   16:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R11,regs.R8);
		/* 8224F1D8h case   16:*/		return 0x8224F1DC;
		  /* 8224F1DCh */ case   17:  		/* lwzx R7, <#[R8 + R10]> */
		/* 8224F1DCh case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 8224F1DCh case   17:*/		return 0x8224F1E0;
		  /* 8224F1E0h */ case   18:  		/* addi R9, R9, 1 */
		/* 8224F1E0h case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8224F1E0h case   18:*/		return 0x8224F1E4;
		  /* 8224F1E4h */ case   19:  		/* stw R7, <#[R10]> */
		/* 8224F1E4h case   19:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 8224F1E4h case   19:*/		return 0x8224F1E8;
		  /* 8224F1E8h */ case   20:  		/* addi R10, R10, 4 */
		/* 8224F1E8h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8224F1E8h case   20:*/		return 0x8224F1EC;
		  /* 8224F1ECh */ case   21:  		/* lwz R7, <#[R11]> */
		/* 8224F1ECh case   21:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8224F1ECh case   21:*/		return 0x8224F1F0;
		  /* 8224F1F0h */ case   22:  		/* cmplw CR6, R9, R7 */
		/* 8224F1F0h case   22:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 8224F1F0h case   22:*/		return 0x8224F1F4;
		  /* 8224F1F4h */ case   23:  		/* bc 12, CR6_LT, -24 */
		/* 8224F1F4h case   23:*/		if ( regs.CR[6].lt ) { return 0x8224F1DC;  }
		/* 8224F1F4h case   23:*/		return 0x8224F1F8;
	}
	return 0x8224F1F8;
} // Block from 8224F198h-8224F1F8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8224F1F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F1F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F1F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F1F8);
		  /* 8224F1F8h */ case    0:  		/* lwz R11, <#[R28 + 20]> */
		/* 8224F1F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 8224F1F8h case    0:*/		return 0x8224F1FC;
		  /* 8224F1FCh */ case    1:  		/* mr R30, R24 */
		/* 8224F1FCh case    1:*/		regs.R30 = regs.R24;
		/* 8224F1FCh case    1:*/		return 0x8224F200;
		  /* 8224F200h */ case    2:  		/* lwz R11, <#[R11 + 4]> */
		/* 8224F200h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8224F200h case    2:*/		return 0x8224F204;
		  /* 8224F204h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8224F204h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224F204h case    3:*/		return 0x8224F208;
		  /* 8224F208h */ case    4:  		/* bc 4, CR6_GT, 268 */
		/* 8224F208h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8224F314;  }
		/* 8224F208h case    4:*/		return 0x8224F20C;
		  /* 8224F20Ch */ case    5:  		/* lis R11, -32253 */
		/* 8224F20Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8224F20Ch case    5:*/		return 0x8224F210;
		  /* 8224F210h */ case    6:  		/* lis R10, -32252 */
		/* 8224F210h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224F210h case    6:*/		return 0x8224F214;
		  /* 8224F214h */ case    7:  		/* lis R9, -32252 */
		/* 8224F214h case    7:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 8224F214h case    7:*/		return 0x8224F218;
		  /* 8224F218h */ case    8:  		/* mr R29, R24 */
		/* 8224F218h case    8:*/		regs.R29 = regs.R24;
		/* 8224F218h case    8:*/		return 0x8224F21C;
		  /* 8224F21Ch */ case    9:  		/* addi R27, R11, 27460 */
		/* 8224F21Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0x6B44);
		/* 8224F21Ch case    9:*/		return 0x8224F220;
		  /* 8224F220h */ case   10:  		/* addi R26, R10, 15744 */
		/* 8224F220h case   10:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R10,0x3D80);
		/* 8224F220h case   10:*/		return 0x8224F224;
		  /* 8224F224h */ case   11:  		/* addi R25, R9, 14208 */
		/* 8224F224h case   11:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R9,0x3780);
		/* 8224F224h case   11:*/		return 0x8224F228;
		  /* 8224F228h */ case   12:  		/* lwz R3, <#[R28 + 20]> */
		/* 8224F228h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000014) );
		/* 8224F228h case   12:*/		return 0x8224F22C;
		  /* 8224F22Ch */ case   13:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224F22Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224F22Ch case   13:*/		return 0x8224F230;
		  /* 8224F230h */ case   14:  		/* cmplw CR6, R30, R11 */
		/* 8224F230h case   14:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8224F230h case   14:*/		return 0x8224F234;
		  /* 8224F234h */ case   15:  		/* bc 4, CR6_LT, 16 */
		/* 8224F234h case   15:*/		if ( !regs.CR[6].lt ) { return 0x8224F244;  }
		/* 8224F234h case   15:*/		return 0x8224F238;
		  /* 8224F238h */ case   16:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224F238h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224F238h case   16:*/		return 0x8224F23C;
		  /* 8224F23Ch */ case   17:  		/* add R3, R11, R29 */
		/* 8224F23Ch case   17:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 8224F23Ch case   17:*/		return 0x8224F240;
		  /* 8224F240h */ case   18:  		/* b 12 */
		/* 8224F240h case   18:*/		return 0x8224F24C;
		/* 8224F240h case   18:*/		return 0x8224F244;
	}
	return 0x8224F244;
} // Block from 8224F1F8h-8224F244h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8224F244h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F244( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F244) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F244);
		  /* 8224F244h */ case    0:  		/* mr R4, R30 */
		/* 8224F244h case    0:*/		regs.R4 = regs.R30;
		/* 8224F244h case    0:*/		return 0x8224F248;
		  /* 8224F248h */ case    1:  		/* bl 18552 */
		/* 8224F248h case    1:*/		regs.LR = 0x8224F24C; return 0x82253AC0;
		/* 8224F248h case    1:*/		return 0x8224F24C;
	}
	return 0x8224F24C;
} // Block from 8224F244h-8224F24Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224F24Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F24C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F24C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F24C);
		  /* 8224F24Ch */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224F24Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224F24Ch case    0:*/		return 0x8224F250;
		  /* 8224F250h */ case    1:  		/* lwz R31, <#[R11 + 40]> */
		/* 8224F250h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000028) );
		/* 8224F250h case    1:*/		return 0x8224F254;
		  /* 8224F254h */ case    2:  		/* lwz R11, <#[R31 + 228]> */
		/* 8224F254h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8224F254h case    2:*/		return 0x8224F258;
		  /* 8224F258h */ case    3:  		/* rlwinm. R11, R11, 26, 31, 31 */
		/* 8224F258h case    3:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R11,regs.R11);
		/* 8224F258h case    3:*/		return 0x8224F25C;
		  /* 8224F25Ch */ case    4:  		/* bc 12, CR0_EQ, 160 */
		/* 8224F25Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x8224F2FC;  }
		/* 8224F25Ch case    4:*/		return 0x8224F260;
		  /* 8224F260h */ case    5:  		/* lwz R10, <#[R31 + 56]> */
		/* 8224F260h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 8224F260h case    5:*/		return 0x8224F264;
		  /* 8224F264h */ case    6:  		/* lwz R9, <#[R23 + 100]> */
		/* 8224F264h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000064) );
		/* 8224F264h case    6:*/		return 0x8224F268;
		  /* 8224F268h */ case    7:  		/* rlwinm R11, R10, 27, 5, 31 */
		/* 8224F268h case    7:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R10);
		/* 8224F268h case    7:*/		return 0x8224F26C;
		  /* 8224F26Ch */ case    8:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 8224F26Ch case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 8224F26Ch case    8:*/		return 0x8224F270;
		  /* 8224F270h */ case    9:  		/* addi R11, R11, 2 */
		/* 8224F270h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8224F270h case    9:*/		return 0x8224F274;
		  /* 8224F274h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8224F274h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8224F274h case   10:*/		return 0x8224F278;
		  /* 8224F278h */ case   11:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8224F278h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8224F278h case   11:*/		return 0x8224F27C;
		  /* 8224F27Ch */ case   12:  		/* srw R11, R11, R10 */
		/* 8224F27Ch case   12:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8224F27Ch case   12:*/		return 0x8224F280;
		  /* 8224F280h */ case   13:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8224F280h case   13:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8224F280h case   13:*/		return 0x8224F284;
		  /* 8224F284h */ case   14:  		/* bc 4, CR0_EQ, 28 */
		/* 8224F284h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8224F2A0;  }
		/* 8224F284h case   14:*/		return 0x8224F288;
		  /* 8224F288h */ case   15:  		/* mr R6, R25 */
		/* 8224F288h case   15:*/		regs.R6 = regs.R25;
		/* 8224F288h case   15:*/		return 0x8224F28C;
		  /* 8224F28Ch */ case   16:  		/* mr R5, R26 */
		/* 8224F28Ch case   16:*/		regs.R5 = regs.R26;
		/* 8224F28Ch case   16:*/		return 0x8224F290;
		  /* 8224F290h */ case   17:  		/* mr R4, R27 */
		/* 8224F290h case   17:*/		regs.R4 = regs.R27;
		/* 8224F290h case   17:*/		return 0x8224F294;
		  /* 8224F294h */ case   18:  		/* li R7, 1271 */
		/* 8224F294h case   18:*/		cpu::op::li<0>(regs,&regs.R7,0x4F7);
		/* 8224F294h case   18:*/		return 0x8224F298;
		  /* 8224F298h */ case   19:  		/* li R3, 0 */
		/* 8224F298h case   19:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224F298h case   19:*/		return 0x8224F29C;
		  /* 8224F29Ch */ case   20:  		/* bl -1013396 */
		/* 8224F29Ch case   20:*/		regs.LR = 0x8224F2A0; return 0x82157C08;
		/* 8224F29Ch case   20:*/		return 0x8224F2A0;
	}
	return 0x8224F2A0;
} // Block from 8224F24Ch-8224F2A0h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8224F2A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F2A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F2A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F2A0);
		  /* 8224F2A0h */ case    0:  		/* lwz R10, <#[R31 + 56]> */
		/* 8224F2A0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 8224F2A0h case    0:*/		return 0x8224F2A4;
		  /* 8224F2A4h */ case    1:  		/* lwz R9, <#[R23 + 104]> */
		/* 8224F2A4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000068) );
		/* 8224F2A4h case    1:*/		return 0x8224F2A8;
		  /* 8224F2A8h */ case    2:  		/* rlwinm R11, R10, 27, 5, 31 */
		/* 8224F2A8h case    2:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R10);
		/* 8224F2A8h case    2:*/		return 0x8224F2AC;
		  /* 8224F2ACh */ case    3:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 8224F2ACh case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 8224F2ACh case    3:*/		return 0x8224F2B0;
		  /* 8224F2B0h */ case    4:  		/* addi R11, R11, 2 */
		/* 8224F2B0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8224F2B0h case    4:*/		return 0x8224F2B4;
		  /* 8224F2B4h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8224F2B4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8224F2B4h case    5:*/		return 0x8224F2B8;
		  /* 8224F2B8h */ case    6:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8224F2B8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8224F2B8h case    6:*/		return 0x8224F2BC;
		  /* 8224F2BCh */ case    7:  		/* srw R11, R11, R10 */
		/* 8224F2BCh case    7:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8224F2BCh case    7:*/		return 0x8224F2C0;
		  /* 8224F2C0h */ case    8:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8224F2C0h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8224F2C0h case    8:*/		return 0x8224F2C4;
		  /* 8224F2C4h */ case    9:  		/* bc 12, CR0_EQ, 56 */
		/* 8224F2C4h case    9:*/		if ( regs.CR[0].eq ) { return 0x8224F2FC;  }
		/* 8224F2C4h case    9:*/		return 0x8224F2C8;
		  /* 8224F2C8h */ case   10:  		/* lwz R3, <#[R28 + 20]> */
		/* 8224F2C8h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000014) );
		/* 8224F2C8h case   10:*/		return 0x8224F2CC;
		  /* 8224F2CCh */ case   11:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224F2CCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224F2CCh case   11:*/		return 0x8224F2D0;
		  /* 8224F2D0h */ case   12:  		/* cmplw CR6, R30, R11 */
		/* 8224F2D0h case   12:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8224F2D0h case   12:*/		return 0x8224F2D4;
		  /* 8224F2D4h */ case   13:  		/* bc 4, CR6_LT, 16 */
		/* 8224F2D4h case   13:*/		if ( !regs.CR[6].lt ) { return 0x8224F2E4;  }
		/* 8224F2D4h case   13:*/		return 0x8224F2D8;
		  /* 8224F2D8h */ case   14:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224F2D8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224F2D8h case   14:*/		return 0x8224F2DC;
		  /* 8224F2DCh */ case   15:  		/* add R3, R11, R29 */
		/* 8224F2DCh case   15:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 8224F2DCh case   15:*/		return 0x8224F2E0;
		  /* 8224F2E0h */ case   16:  		/* b 12 */
		/* 8224F2E0h case   16:*/		return 0x8224F2EC;
		/* 8224F2E0h case   16:*/		return 0x8224F2E4;
	}
	return 0x8224F2E4;
} // Block from 8224F2A0h-8224F2E4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8224F2E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F2E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F2E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F2E4);
		  /* 8224F2E4h */ case    0:  		/* mr R4, R30 */
		/* 8224F2E4h case    0:*/		regs.R4 = regs.R30;
		/* 8224F2E4h case    0:*/		return 0x8224F2E8;
		  /* 8224F2E8h */ case    1:  		/* bl 18392 */
		/* 8224F2E8h case    1:*/		regs.LR = 0x8224F2EC; return 0x82253AC0;
		/* 8224F2E8h case    1:*/		return 0x8224F2EC;
	}
	return 0x8224F2EC;
} // Block from 8224F2E4h-8224F2ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224F2ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F2EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F2EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F2EC);
		  /* 8224F2ECh */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224F2ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224F2ECh case    0:*/		return 0x8224F2F0;
		  /* 8224F2F0h */ case    1:  		/* lwz R10, <#[R11 + 60]> */
		/* 8224F2F0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000003C) );
		/* 8224F2F0h case    1:*/		return 0x8224F2F4;
		  /* 8224F2F4h */ case    2:  		/* addi R10, R10, 1 */
		/* 8224F2F4h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8224F2F4h case    2:*/		return 0x8224F2F8;
		  /* 8224F2F8h */ case    3:  		/* stw R10, <#[R11 + 60]> */
		/* 8224F2F8h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000003C) );
		/* 8224F2F8h case    3:*/		return 0x8224F2FC;
	}
	return 0x8224F2FC;
} // Block from 8224F2ECh-8224F2FCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224F2FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F2FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F2FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F2FC);
		  /* 8224F2FCh */ case    0:  		/* lwz R11, <#[R28 + 20]> */
		/* 8224F2FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 8224F2FCh case    0:*/		return 0x8224F300;
		  /* 8224F300h */ case    1:  		/* addi R30, R30, 1 */
		/* 8224F300h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8224F300h case    1:*/		return 0x8224F304;
		  /* 8224F304h */ case    2:  		/* addi R29, R29, 4 */
		/* 8224F304h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8224F304h case    2:*/		return 0x8224F308;
		  /* 8224F308h */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 8224F308h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8224F308h case    3:*/		return 0x8224F30C;
		  /* 8224F30Ch */ case    4:  		/* cmplw CR6, R30, R11 */
		/* 8224F30Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8224F30Ch case    4:*/		return 0x8224F310;
		  /* 8224F310h */ case    5:  		/* bc 12, CR6_LT, -232 */
		/* 8224F310h case    5:*/		if ( regs.CR[6].lt ) { return 0x8224F228;  }
		/* 8224F310h case    5:*/		return 0x8224F314;
	}
	return 0x8224F314;
} // Block from 8224F2FCh-8224F314h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224F314h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F314( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F314) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F314);
		  /* 8224F314h */ case    0:  		/* lwz R3, <#[R28 + 8]> */
		/* 8224F314h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000008) );
		/* 8224F314h case    0:*/		return 0x8224F318;
		  /* 8224F318h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 8224F318h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224F318h case    1:*/		return 0x8224F31C;
		  /* 8224F31Ch */ case    2:  		/* lwz R11, <#[R11]> */
		/* 8224F31Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8224F31Ch case    2:*/		return 0x8224F320;
		  /* 8224F320h */ case    3:  		/* mtspr CTR, R11 */
		/* 8224F320h case    3:*/		regs.CTR = regs.R11;
		/* 8224F320h case    3:*/		return 0x8224F324;
		  /* 8224F324h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8224F324h case    4:*/		if ( 1 ) { regs.LR = 0x8224F328; return (uint32)regs.CTR; }
		/* 8224F324h case    4:*/		return 0x8224F328;
		  /* 8224F328h */ case    5:  		/* lwz R10, <#[R28 + 12]> */
		/* 8224F328h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000000C) );
		/* 8224F328h case    5:*/		return 0x8224F32C;
		  /* 8224F32Ch */ case    6:  		/* li R11, -1 */
		/* 8224F32Ch case    6:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 8224F32Ch case    6:*/		return 0x8224F330;
		  /* 8224F330h */ case    7:  		/* mr R31, R24 */
		/* 8224F330h case    7:*/		regs.R31 = regs.R24;
		/* 8224F330h case    7:*/		return 0x8224F334;
		  /* 8224F334h */ case    8:  		/* stw R24, <#[R10]> */
		/* 8224F334h case    8:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R10 + 0x00000000) );
		/* 8224F334h case    8:*/		return 0x8224F338;
		  /* 8224F338h */ case    9:  		/* stw R24, <#[R10 + 4]> */
		/* 8224F338h case    9:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R10 + 0x00000004) );
		/* 8224F338h case    9:*/		return 0x8224F33C;
		  /* 8224F33Ch */ case   10:  		/* stw R24, <#[R10 + 8]> */
		/* 8224F33Ch case   10:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R10 + 0x00000008) );
		/* 8224F33Ch case   10:*/		return 0x8224F340;
		  /* 8224F340h */ case   11:  		/* stw R11, <#[R10 + 12]> */
		/* 8224F340h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 8224F340h case   11:*/		return 0x8224F344;
		  /* 8224F344h */ case   12:  		/* stw R24, <#[R28 + 28]> */
		/* 8224F344h case   12:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R28 + 0x0000001C) );
		/* 8224F344h case   12:*/		return 0x8224F348;
		  /* 8224F348h */ case   13:  		/* stw R24, <#[R28 + 120]> */
		/* 8224F348h case   13:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R28 + 0x00000078) );
		/* 8224F348h case   13:*/		return 0x8224F34C;
		  /* 8224F34Ch */ case   14:  		/* stw R24, <#[R28 + 112]> */
		/* 8224F34Ch case   14:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R28 + 0x00000070) );
		/* 8224F34Ch case   14:*/		return 0x8224F350;
		  /* 8224F350h */ case   15:  		/* lwz R11, <#[R28 + 24]> */
		/* 8224F350h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000018) );
		/* 8224F350h case   15:*/		return 0x8224F354;
		  /* 8224F354h */ case   16:  		/* lwz R29, <#[R11 + 4]> */
		/* 8224F354h case   16:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000004) );
		/* 8224F354h case   16:*/		return 0x8224F358;
		  /* 8224F358h */ case   17:  		/* cmpwi CR6, R29, 0 */
		/* 8224F358h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 8224F358h case   17:*/		return 0x8224F35C;
		  /* 8224F35Ch */ case   18:  		/* bc 4, CR6_GT, 84 */
		/* 8224F35Ch case   18:*/		if ( !regs.CR[6].gt ) { return 0x8224F3B0;  }
		/* 8224F35Ch case   18:*/		return 0x8224F360;
		  /* 8224F360h */ case   19:  		/* mr R30, R24 */
		/* 8224F360h case   19:*/		regs.R30 = regs.R24;
		/* 8224F360h case   19:*/		return 0x8224F364;
		  /* 8224F364h */ case   20:  		/* lwz R3, <#[R28 + 24]> */
		/* 8224F364h case   20:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000018) );
		/* 8224F364h case   20:*/		return 0x8224F368;
		  /* 8224F368h */ case   21:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224F368h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224F368h case   21:*/		return 0x8224F36C;
		  /* 8224F36Ch */ case   22:  		/* cmplw CR6, R31, R11 */
		/* 8224F36Ch case   22:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8224F36Ch case   22:*/		return 0x8224F370;
		  /* 8224F370h */ case   23:  		/* bc 4, CR6_LT, 16 */
		/* 8224F370h case   23:*/		if ( !regs.CR[6].lt ) { return 0x8224F380;  }
		/* 8224F370h case   23:*/		return 0x8224F374;
		  /* 8224F374h */ case   24:  		/* lwz R11, <#[R3 + 8]> */
		/* 8224F374h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8224F374h case   24:*/		return 0x8224F378;
		  /* 8224F378h */ case   25:  		/* add R3, R11, R30 */
		/* 8224F378h case   25:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R30);
		/* 8224F378h case   25:*/		return 0x8224F37C;
		  /* 8224F37Ch */ case   26:  		/* b 12 */
		/* 8224F37Ch case   26:*/		return 0x8224F388;
		/* 8224F37Ch case   26:*/		return 0x8224F380;
	}
	return 0x8224F380;
} // Block from 8224F314h-8224F380h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8224F380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F380);
		  /* 8224F380h */ case    0:  		/* mr R4, R31 */
		/* 8224F380h case    0:*/		regs.R4 = regs.R31;
		/* 8224F380h case    0:*/		return 0x8224F384;
		  /* 8224F384h */ case    1:  		/* bl 18236 */
		/* 8224F384h case    1:*/		regs.LR = 0x8224F388; return 0x82253AC0;
		/* 8224F384h case    1:*/		return 0x8224F388;
	}
	return 0x8224F388;
} // Block from 8224F380h-8224F388h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224F388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F388);
		  /* 8224F388h */ case    0:  		/* lwz R4, <#[R3]> */
		/* 8224F388h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000000) );
		/* 8224F388h case    0:*/		return 0x8224F38C;
		  /* 8224F38Ch */ case    1:  		/* lwz R11, <#[R4 + 36]> */
		/* 8224F38Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000024) );
		/* 8224F38Ch case    1:*/		return 0x8224F390;
		  /* 8224F390h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 8224F390h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224F390h case    2:*/		return 0x8224F394;
		  /* 8224F394h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 8224F394h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8224F3A0;  }
		/* 8224F394h case    3:*/		return 0x8224F398;
		  /* 8224F398h */ case    4:  		/* mr R3, R28 */
		/* 8224F398h case    4:*/		regs.R3 = regs.R28;
		/* 8224F398h case    4:*/		return 0x8224F39C;
		  /* 8224F39Ch */ case    5:  		/* bl -15820 */
		/* 8224F39Ch case    5:*/		regs.LR = 0x8224F3A0; return 0x8224B5D0;
		/* 8224F39Ch case    5:*/		return 0x8224F3A0;
	}
	return 0x8224F3A0;
} // Block from 8224F388h-8224F3A0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224F3A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F3A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F3A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F3A0);
		  /* 8224F3A0h */ case    0:  		/* addi R31, R31, 1 */
		/* 8224F3A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8224F3A0h case    0:*/		return 0x8224F3A4;
		  /* 8224F3A4h */ case    1:  		/* addi R30, R30, 4 */
		/* 8224F3A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8224F3A4h case    1:*/		return 0x8224F3A8;
		  /* 8224F3A8h */ case    2:  		/* cmpw CR6, R31, R29 */
		/* 8224F3A8h case    2:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R29);
		/* 8224F3A8h case    2:*/		return 0x8224F3AC;
		  /* 8224F3ACh */ case    3:  		/* bc 12, CR6_LT, -72 */
		/* 8224F3ACh case    3:*/		if ( regs.CR[6].lt ) { return 0x8224F364;  }
		/* 8224F3ACh case    3:*/		return 0x8224F3B0;
	}
	return 0x8224F3B0;
} // Block from 8224F3A0h-8224F3B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224F3B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F3B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F3B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F3B0);
		  /* 8224F3B0h */ case    0:  		/* lwz R11, <#[R28 + 16]> */
		/* 8224F3B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 8224F3B0h case    0:*/		return 0x8224F3B4;
		  /* 8224F3B4h */ case    1:  		/* mr R30, R24 */
		/* 8224F3B4h case    1:*/		regs.R30 = regs.R24;
		/* 8224F3B4h case    1:*/		return 0x8224F3B8;
		  /* 8224F3B8h */ case    2:  		/* lwz R31, <#[R11 + 28]> */
		/* 8224F3B8h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x0000001C) );
		/* 8224F3B8h case    2:*/		return 0x8224F3BC;
		  /* 8224F3BCh */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 8224F3BCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8224F3BCh case    3:*/		return 0x8224F3C0;
		  /* 8224F3C0h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 8224F3C0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224F3C0h case    4:*/		return 0x8224F3C4;
		  /* 8224F3C4h */ case    5:  		/* bc 12, CR6_EQ, 200 */
		/* 8224F3C4h case    5:*/		if ( regs.CR[6].eq ) { return 0x8224F48C;  }
		/* 8224F3C4h case    5:*/		return 0x8224F3C8;
		  /* 8224F3C8h */ case    6:  		/* lwz R11, <#[R31 + 228]> */
		/* 8224F3C8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8224F3C8h case    6:*/		return 0x8224F3CC;
		  /* 8224F3CCh */ case    7:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8224F3CCh case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8224F3CCh case    7:*/		return 0x8224F3D0;
		  /* 8224F3D0h */ case    8:  		/* bc 12, CR0_EQ, 152 */
		/* 8224F3D0h case    8:*/		if ( regs.CR[0].eq ) { return 0x8224F468;  }
		/* 8224F3D0h case    8:*/		return 0x8224F3D4;
		  /* 8224F3D4h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 8224F3D4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224F3D4h case    9:*/		return 0x8224F3D8;
		  /* 8224F3D8h */ case   10:  		/* mr R3, R31 */
		/* 8224F3D8h case   10:*/		regs.R3 = regs.R31;
		/* 8224F3D8h case   10:*/		return 0x8224F3DC;
		  /* 8224F3DCh */ case   11:  		/* lwz R11, <#[R11 + 36]> */
		/* 8224F3DCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 8224F3DCh case   11:*/		return 0x8224F3E0;
		  /* 8224F3E0h */ case   12:  		/* mtspr CTR, R11 */
		/* 8224F3E0h case   12:*/		regs.CTR = regs.R11;
		/* 8224F3E0h case   12:*/		return 0x8224F3E4;
		  /* 8224F3E4h */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 8224F3E4h case   13:*/		if ( 1 ) { regs.LR = 0x8224F3E8; return (uint32)regs.CTR; }
		/* 8224F3E4h case   13:*/		return 0x8224F3E8;
		  /* 8224F3E8h */ case   14:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224F3E8h case   14:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224F3E8h case   14:*/		return 0x8224F3EC;
		  /* 8224F3ECh */ case   15:  		/* bc 4, CR0_EQ, 72 */
		/* 8224F3ECh case   15:*/		if ( !regs.CR[0].eq ) { return 0x8224F434;  }
		/* 8224F3ECh case   15:*/		return 0x8224F3F0;
		  /* 8224F3F0h */ case   16:  		/* lwz R11, <#[R31]> */
		/* 8224F3F0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224F3F0h case   16:*/		return 0x8224F3F4;
		  /* 8224F3F4h */ case   17:  		/* mr R3, R31 */
		/* 8224F3F4h case   17:*/		regs.R3 = regs.R31;
		/* 8224F3F4h case   17:*/		return 0x8224F3F8;
		  /* 8224F3F8h */ case   18:  		/* lwz R11, <#[R11 + 40]> */
		/* 8224F3F8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8224F3F8h case   18:*/		return 0x8224F3FC;
		  /* 8224F3FCh */ case   19:  		/* mtspr CTR, R11 */
		/* 8224F3FCh case   19:*/		regs.CTR = regs.R11;
		/* 8224F3FCh case   19:*/		return 0x8224F400;
		  /* 8224F400h */ case   20:  		/* bcctrl 20, CR0_LT */
		/* 8224F400h case   20:*/		if ( 1 ) { regs.LR = 0x8224F404; return (uint32)regs.CTR; }
		/* 8224F400h case   20:*/		return 0x8224F404;
		  /* 8224F404h */ case   21:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224F404h case   21:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224F404h case   21:*/		return 0x8224F408;
		  /* 8224F408h */ case   22:  		/* bc 4, CR0_EQ, 44 */
		/* 8224F408h case   22:*/		if ( !regs.CR[0].eq ) { return 0x8224F434;  }
		/* 8224F408h case   22:*/		return 0x8224F40C;
		  /* 8224F40Ch */ case   23:  		/* lwz R11, <#[R31]> */
		/* 8224F40Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224F40Ch case   23:*/		return 0x8224F410;
		  /* 8224F410h */ case   24:  		/* mr R3, R31 */
		/* 8224F410h case   24:*/		regs.R3 = regs.R31;
		/* 8224F410h case   24:*/		return 0x8224F414;
		  /* 8224F414h */ case   25:  		/* lwz R11, <#[R11 + 44]> */
		/* 8224F414h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 8224F414h case   25:*/		return 0x8224F418;
		  /* 8224F418h */ case   26:  		/* mtspr CTR, R11 */
		/* 8224F418h case   26:*/		regs.CTR = regs.R11;
		/* 8224F418h case   26:*/		return 0x8224F41C;
		  /* 8224F41Ch */ case   27:  		/* bcctrl 20, CR0_LT */
		/* 8224F41Ch case   27:*/		if ( 1 ) { regs.LR = 0x8224F420; return (uint32)regs.CTR; }
		/* 8224F41Ch case   27:*/		return 0x8224F420;
		  /* 8224F420h */ case   28:  		/* cmplwi CR0, R3, 0 */
		/* 8224F420h case   28:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8224F420h case   28:*/		return 0x8224F424;
		  /* 8224F424h */ case   29:  		/* bc 4, CR0_EQ, 16 */
		/* 8224F424h case   29:*/		if ( !regs.CR[0].eq ) { return 0x8224F434;  }
		/* 8224F424h case   29:*/		return 0x8224F428;
		  /* 8224F428h */ case   30:  		/* mr R3, R31 */
		/* 8224F428h case   30:*/		regs.R3 = regs.R31;
		/* 8224F428h case   30:*/		return 0x8224F42C;
		  /* 8224F42Ch */ case   31:  		/* bl 17372 */
		/* 8224F42Ch case   31:*/		regs.LR = 0x8224F430; return 0x82253808;
		/* 8224F42Ch case   31:*/		return 0x8224F430;
		  /* 8224F430h */ case   32:  		/* b 56 */
		/* 8224F430h case   32:*/		return 0x8224F468;
		/* 8224F430h case   32:*/		return 0x8224F434;
	}
	return 0x8224F434;
} // Block from 8224F3B0h-8224F434h (33 instructions)

//////////////////////////////////////////////////////
// Block at 8224F434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F434);
		  /* 8224F434h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8224F434h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224F434h case    0:*/		return 0x8224F438;
		  /* 8224F438h */ case    1:  		/* mr R3, R31 */
		/* 8224F438h case    1:*/		regs.R3 = regs.R31;
		/* 8224F438h case    1:*/		return 0x8224F43C;
		  /* 8224F43Ch */ case    2:  		/* lwz R11, <#[R11 + 44]> */
		/* 8224F43Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 8224F43Ch case    2:*/		return 0x8224F440;
		  /* 8224F440h */ case    3:  		/* mtspr CTR, R11 */
		/* 8224F440h case    3:*/		regs.CTR = regs.R11;
		/* 8224F440h case    3:*/		return 0x8224F444;
		  /* 8224F444h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8224F444h case    4:*/		if ( 1 ) { regs.LR = 0x8224F448; return (uint32)regs.CTR; }
		/* 8224F444h case    4:*/		return 0x8224F448;
		  /* 8224F448h */ case    5:  		/* lwz R11, <#[R31 + 228]> */
		/* 8224F448h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8224F448h case    5:*/		return 0x8224F44C;
		  /* 8224F44Ch */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 8224F44Ch case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8224F44Ch case    6:*/		return 0x8224F450;
		  /* 8224F450h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 8224F450h case    7:*/		if ( regs.CR[0].eq ) { return 0x8224F460;  }
		/* 8224F450h case    7:*/		return 0x8224F454;
		  /* 8224F454h */ case    8:  		/* mr R30, R31 */
		/* 8224F454h case    8:*/		regs.R30 = regs.R31;
		/* 8224F454h case    8:*/		return 0x8224F458;
		  /* 8224F458h */ case    9:  		/* ori R11, R11, 4 */
		/* 8224F458h case    9:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8224F458h case    9:*/		return 0x8224F45C;
		  /* 8224F45Ch */ case   10:  		/* b 8 */
		/* 8224F45Ch case   10:*/		return 0x8224F464;
		/* 8224F45Ch case   10:*/		return 0x8224F460;
	}
	return 0x8224F460;
} // Block from 8224F434h-8224F460h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224F460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F460);
		  /* 8224F460h */ case    0:  		/* rlwinm R11, R11, 0, 30, 28 */
		/* 8224F460h case    0:*/		cpu::op::rlwinm<0,0,30,28>(regs,&regs.R11,regs.R11);
		/* 8224F460h case    0:*/		return 0x8224F464;
	}
	return 0x8224F464;
} // Block from 8224F460h-8224F464h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224F464h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F464);
		  /* 8224F464h */ case    0:  		/* stw R11, <#[R31 + 228]> */
		/* 8224F464h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8224F464h case    0:*/		return 0x8224F468;
	}
	return 0x8224F468;
} // Block from 8224F464h-8224F468h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224F468h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F468);
		  /* 8224F468h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 8224F468h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 8224F468h case    0:*/		return 0x8224F46C;
		  /* 8224F46Ch */ case    1:  		/* lwz R11, <#[R31 + 8]> */
		/* 8224F46Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8224F46Ch case    1:*/		return 0x8224F470;
		  /* 8224F470h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 8224F470h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224F470h case    2:*/		return 0x8224F474;
		  /* 8224F474h */ case    3:  		/* bc 4, CR6_EQ, -172 */
		/* 8224F474h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8224F3C8;  }
		/* 8224F474h case    3:*/		return 0x8224F478;
		  /* 8224F478h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 8224F478h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8224F478h case    4:*/		return 0x8224F47C;
		  /* 8224F47Ch */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 8224F47Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x8224F48C;  }
		/* 8224F47Ch case    5:*/		return 0x8224F480;
		  /* 8224F480h */ case    6:  		/* lwz R11, <#[R30 + 228]> */
		/* 8224F480h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000E4) );
		/* 8224F480h case    6:*/		return 0x8224F484;
		  /* 8224F484h */ case    7:  		/* rlwinm R11, R11, 0, 30, 28 */
		/* 8224F484h case    7:*/		cpu::op::rlwinm<0,0,30,28>(regs,&regs.R11,regs.R11);
		/* 8224F484h case    7:*/		return 0x8224F488;
		  /* 8224F488h */ case    8:  		/* stw R11, <#[R30 + 228]> */
		/* 8224F488h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x000000E4) );
		/* 8224F488h case    8:*/		return 0x8224F48C;
	}
	return 0x8224F48C;
} // Block from 8224F468h-8224F48Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224F48Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F48C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F48C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F48C);
		  /* 8224F48Ch */ case    0:  		/* addi R31, R28, 36 */
		/* 8224F48Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R28,0x24);
		/* 8224F48Ch case    0:*/		return 0x8224F490;
		  /* 8224F490h */ case    1:  		/* b 12 */
		/* 8224F490h case    1:*/		return 0x8224F49C;
		/* 8224F490h case    1:*/		return 0x8224F494;
		  /* 8224F494h */ case    2:  		/* mr R3, R28 */
		/* 8224F494h case    2:*/		regs.R3 = regs.R28;
		/* 8224F494h case    2:*/		return 0x8224F498;
		  /* 8224F498h */ case    3:  		/* bl -1080 */
		/* 8224F498h case    3:*/		regs.LR = 0x8224F49C; return 0x8224F060;
		/* 8224F498h case    3:*/		return 0x8224F49C;
	}
	return 0x8224F49C;
} // Block from 8224F48Ch-8224F49Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224F49Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F49C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F49C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F49C);
		  /* 8224F49Ch */ case    0:  		/* mr R3, R31 */
		/* 8224F49Ch case    0:*/		regs.R3 = regs.R31;
		/* 8224F49Ch case    0:*/		return 0x8224F4A0;
		  /* 8224F4A0h */ case    1:  		/* bl 17120 */
		/* 8224F4A0h case    1:*/		regs.LR = 0x8224F4A4; return 0x82253780;
		/* 8224F4A0h case    1:*/		return 0x8224F4A4;
		  /* 8224F4A4h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224F4A4h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224F4A4h case    2:*/		return 0x8224F4A8;
		  /* 8224F4A8h */ case    3:  		/* bc 12, CR0_EQ, -20 */
		/* 8224F4A8h case    3:*/		if ( regs.CR[0].eq ) { return 0x8224F494;  }
		/* 8224F4A8h case    3:*/		return 0x8224F4AC;
		  /* 8224F4ACh */ case    4:  		/* lwz R11, <#[R28 + 12]> */
		/* 8224F4ACh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000000C) );
		/* 8224F4ACh case    4:*/		return 0x8224F4B0;
		  /* 8224F4B0h */ case    5:  		/* lwz R10, <#[R11 + 12]> */
		/* 8224F4B0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8224F4B0h case    5:*/		return 0x8224F4B4;
		  /* 8224F4B4h */ case    6:  		/* lwz R11, <#[R11 + 8]> */
		/* 8224F4B4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8224F4B4h case    6:*/		return 0x8224F4B8;
		  /* 8224F4B8h */ case    7:  		/* cmpw CR6, R10, R11 */
		/* 8224F4B8h case    7:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 8224F4B8h case    7:*/		return 0x8224F4BC;
		  /* 8224F4BCh */ case    8:  		/* bc 12, CR6_LT, 80 */
		/* 8224F4BCh case    8:*/		if ( regs.CR[6].lt ) { return 0x8224F50C;  }
		/* 8224F4BCh case    8:*/		return 0x8224F4C0;
		  /* 8224F4C0h */ case    9:  		/* mr R8, R24 */
		/* 8224F4C0h case    9:*/		regs.R8 = regs.R24;
		/* 8224F4C0h case    9:*/		return 0x8224F4C4;
		  /* 8224F4C4h */ case   10:  		/* mr R11, R24 */
		/* 8224F4C4h case   10:*/		regs.R11 = regs.R24;
		/* 8224F4C4h case   10:*/		return 0x8224F4C8;
		  /* 8224F4C8h */ case   11:  		/* li R9, 1 */
		/* 8224F4C8h case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8224F4C8h case   11:*/		return 0x8224F4CC;
		  /* 8224F4CCh */ case   12:  		/* lwz R10, <#[R23 + 56]> */
		/* 8224F4CCh case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000038) );
		/* 8224F4CCh case   12:*/		return 0x8224F4D0;
		  /* 8224F4D0h */ case   13:  		/* lwz R7, <#[R10 + 4]> */
		/* 8224F4D0h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 8224F4D0h case   13:*/		return 0x8224F4D4;
		  /* 8224F4D4h */ case   14:  		/* cmplw CR6, R9, R7 */
		/* 8224F4D4h case   14:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 8224F4D4h case   14:*/		return 0x8224F4D8;
		  /* 8224F4D8h */ case   15:  		/* bc 4, CR6_GT, 12 */
		/* 8224F4D8h case   15:*/		if ( !regs.CR[6].gt ) { return 0x8224F4E4;  }
		/* 8224F4D8h case   15:*/		return 0x8224F4DC;
		  /* 8224F4DCh */ case   16:  		/* mr R10, R24 */
		/* 8224F4DCh case   16:*/		regs.R10 = regs.R24;
		/* 8224F4DCh case   16:*/		return 0x8224F4E0;
		  /* 8224F4E0h */ case   17:  		/* b 16 */
		/* 8224F4E0h case   17:*/		return 0x8224F4F0;
		/* 8224F4E0h case   17:*/		return 0x8224F4E4;
	}
	return 0x8224F4E4;
} // Block from 8224F49Ch-8224F4E4h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8224F4E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F4E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F4E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F4E4);
		  /* 8224F4E4h */ case    0:  		/* lwz R8, <#[R10 + 8]> */
		/* 8224F4E4h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 8224F4E4h case    0:*/		return 0x8224F4E8;
		  /* 8224F4E8h */ case    1:  		/* li R10, 1 */
		/* 8224F4E8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8224F4E8h case    1:*/		return 0x8224F4EC;
		  /* 8224F4ECh */ case    2:  		/* lwzx R8, <#[R8 + R11]> */
		/* 8224F4ECh case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8224F4ECh case    2:*/		return 0x8224F4F0;
	}
	return 0x8224F4F0;
} // Block from 8224F4E4h-8224F4F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224F4F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F4F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F4F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F4F0);
		  /* 8224F4F0h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 8224F4F0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 8224F4F0h case    0:*/		return 0x8224F4F4;
		  /* 8224F4F4h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 8224F4F4h case    1:*/		if ( regs.CR[0].eq ) { return 0x8224F50C;  }
		/* 8224F4F4h case    1:*/		return 0x8224F4F8;
		  /* 8224F4F8h */ case    2:  		/* li R10, 1 */
		/* 8224F4F8h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8224F4F8h case    2:*/		return 0x8224F4FC;
		  /* 8224F4FCh */ case    3:  		/* addi R9, R9, 1 */
		/* 8224F4FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8224F4FCh case    3:*/		return 0x8224F500;
		  /* 8224F500h */ case    4:  		/* stb R10, <#[R8 + 124]> */
		/* 8224F500h case    4:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R8 + 0x0000007C) );
		/* 8224F500h case    4:*/		return 0x8224F504;
		  /* 8224F504h */ case    5:  		/* addi R11, R11, 4 */
		/* 8224F504h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8224F504h case    5:*/		return 0x8224F508;
		  /* 8224F508h */ case    6:  		/* b -60 */
		/* 8224F508h case    6:*/		return 0x8224F4CC;
		/* 8224F508h case    6:*/		return 0x8224F50C;
	}
	return 0x8224F50C;
} // Block from 8224F4F0h-8224F50Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224F50Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F50C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F50C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F50C);
		  /* 8224F50Ch */ case    0:  		/* mr R3, R28 */
		/* 8224F50Ch case    0:*/		regs.R3 = regs.R28;
		/* 8224F50Ch case    0:*/		return 0x8224F510;
		  /* 8224F510h */ case    1:  		/* bl -4696 */
		/* 8224F510h case    1:*/		regs.LR = 0x8224F514; return 0x8224E2B8;
		/* 8224F510h case    1:*/		return 0x8224F514;
		  /* 8224F514h */ case    2:  		/* addi R1, R1, 160 */
		/* 8224F514h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 8224F514h case    2:*/		return 0x8224F518;
		  /* 8224F518h */ case    3:  		/* b -1827460 */
		/* 8224F518h case    3:*/		return 0x82091294;
		/* 8224F518h case    3:*/		return 0x8224F51C;
		  /* 8224F51Ch */ case    4:  		/* nop */
		/* 8224F51Ch case    4:*/		cpu::op::nop();
		/* 8224F51Ch case    4:*/		return 0x8224F520;
	}
	return 0x8224F520;
} // Block from 8224F50Ch-8224F520h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224F520h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F520);
		  /* 8224F520h */ case    0:  		/* mfspr R12, LR */
		/* 8224F520h case    0:*/		regs.R12 = regs.LR;
		/* 8224F520h case    0:*/		return 0x8224F524;
		  /* 8224F524h */ case    1:  		/* bl -1827540 */
		/* 8224F524h case    1:*/		regs.LR = 0x8224F528; return 0x82091250;
		/* 8224F524h case    1:*/		return 0x8224F528;
		  /* 8224F528h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8224F528h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8224F528h case    2:*/		return 0x8224F52C;
		  /* 8224F52Ch */ case    3:  		/* mr R27, R4 */
		/* 8224F52Ch case    3:*/		regs.R27 = regs.R4;
		/* 8224F52Ch case    3:*/		return 0x8224F530;
		  /* 8224F530h */ case    4:  		/* stw R4, <#[R3 + 4]> */
		/* 8224F530h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224F530h case    4:*/		return 0x8224F534;
		  /* 8224F534h */ case    5:  		/* mr R31, R3 */
		/* 8224F534h case    5:*/		regs.R31 = regs.R3;
		/* 8224F534h case    5:*/		return 0x8224F538;
		  /* 8224F538h */ case    6:  		/* li R4, 32 */
		/* 8224F538h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x20);
		/* 8224F538h case    6:*/		return 0x8224F53C;
		  /* 8224F53Ch */ case    7:  		/* lwz R11, <#[R27 + 12]> */
		/* 8224F53Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 8224F53Ch case    7:*/		return 0x8224F540;
		  /* 8224F540h */ case    8:  		/* stw R11, <#[R3]> */
		/* 8224F540h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224F540h case    8:*/		return 0x8224F544;
		  /* 8224F544h */ case    9:  		/* lwz R30, <#[R11 + 1456]> */
		/* 8224F544h case    9:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224F544h case    9:*/		return 0x8224F548;
		  /* 8224F548h */ case   10:  		/* mr R3, R30 */
		/* 8224F548h case   10:*/		regs.R3 = regs.R30;
		/* 8224F548h case   10:*/		return 0x8224F54C;
		  /* 8224F54Ch */ case   11:  		/* bl -209044 */
		/* 8224F54Ch case   11:*/		regs.LR = 0x8224F550; return 0x8221C4B8;
		/* 8224F54Ch case   11:*/		return 0x8224F550;
		  /* 8224F550h */ case   12:  		/* mr R11, R3 */
		/* 8224F550h case   12:*/		regs.R11 = regs.R3;
		/* 8224F550h case   12:*/		return 0x8224F554;
		  /* 8224F554h */ case   13:  		/* li R29, 0 */
		/* 8224F554h case   13:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8224F554h case   13:*/		return 0x8224F558;
		  /* 8224F558h */ case   14:  		/* addic. R3, R3, 4 */
		/* 8224F558h case   14:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 8224F558h case   14:*/		return 0x8224F55C;
		  /* 8224F55Ch */ case   15:  		/* stw R30, <#[R11]> */
		/* 8224F55Ch case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 8224F55Ch case   15:*/		return 0x8224F560;
		  /* 8224F560h */ case   16:  		/* bc 12, CR0_EQ, 20 */
		/* 8224F560h case   16:*/		if ( regs.CR[0].eq ) { return 0x8224F574;  }
		/* 8224F560h case   16:*/		return 0x8224F564;
		  /* 8224F564h */ case   17:  		/* lwz R11, <#[R31]> */
		/* 8224F564h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224F564h case   17:*/		return 0x8224F568;
		  /* 8224F568h */ case   18:  		/* lwz R4, <#[R11 + 1456]> */
		/* 8224F568h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224F568h case   18:*/		return 0x8224F56C;
		  /* 8224F56Ch */ case   19:  		/* bl -15508 */
		/* 8224F56Ch case   19:*/		regs.LR = 0x8224F570; return 0x8224B8D8;
		/* 8224F56Ch case   19:*/		return 0x8224F570;
		  /* 8224F570h */ case   20:  		/* b 8 */
		/* 8224F570h case   20:*/		return 0x8224F578;
		/* 8224F570h case   20:*/		return 0x8224F574;
	}
	return 0x8224F574;
} // Block from 8224F520h-8224F574h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8224F574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F574);
		  /* 8224F574h */ case    0:  		/* mr R3, R29 */
		/* 8224F574h case    0:*/		regs.R3 = regs.R29;
		/* 8224F574h case    0:*/		return 0x8224F578;
	}
	return 0x8224F578;
} // Block from 8224F574h-8224F578h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224F578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F578);
		  /* 8224F578h */ case    0:  		/* stw R3, <#[R31 + 8]> */
		/* 8224F578h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 8224F578h case    0:*/		return 0x8224F57C;
		  /* 8224F57Ch */ case    1:  		/* li R4, 20 */
		/* 8224F57Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 8224F57Ch case    1:*/		return 0x8224F580;
		  /* 8224F580h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 8224F580h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224F580h case    2:*/		return 0x8224F584;
		  /* 8224F584h */ case    3:  		/* lwz R30, <#[R11 + 1456]> */
		/* 8224F584h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224F584h case    3:*/		return 0x8224F588;
		  /* 8224F588h */ case    4:  		/* mr R3, R30 */
		/* 8224F588h case    4:*/		regs.R3 = regs.R30;
		/* 8224F588h case    4:*/		return 0x8224F58C;
		  /* 8224F58Ch */ case    5:  		/* bl -209108 */
		/* 8224F58Ch case    5:*/		regs.LR = 0x8224F590; return 0x8221C4B8;
		/* 8224F58Ch case    5:*/		return 0x8224F590;
		  /* 8224F590h */ case    6:  		/* li R28, -1 */
		/* 8224F590h case    6:*/		cpu::op::li<0>(regs,&regs.R28,0xFFFFFFFF);
		/* 8224F590h case    6:*/		return 0x8224F594;
		  /* 8224F594h */ case    7:  		/* addic. R11, R3, 4 */
		/* 8224F594h case    7:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R3,0x4);
		/* 8224F594h case    7:*/		return 0x8224F598;
		  /* 8224F598h */ case    8:  		/* stw R30, <#[R3]> */
		/* 8224F598h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224F598h case    8:*/		return 0x8224F59C;
		  /* 8224F59Ch */ case    9:  		/* bc 12, CR0_EQ, 24 */
		/* 8224F59Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x8224F5B4;  }
		/* 8224F59Ch case    9:*/		return 0x8224F5A0;
		  /* 8224F5A0h */ case   10:  		/* stw R29, <#[R11]> */
		/* 8224F5A0h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 8224F5A0h case   10:*/		return 0x8224F5A4;
		  /* 8224F5A4h */ case   11:  		/* stw R29, <#[R11 + 4]> */
		/* 8224F5A4h case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000004) );
		/* 8224F5A4h case   11:*/		return 0x8224F5A8;
		  /* 8224F5A8h */ case   12:  		/* stw R29, <#[R11 + 8]> */
		/* 8224F5A8h case   12:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000008) );
		/* 8224F5A8h case   12:*/		return 0x8224F5AC;
		  /* 8224F5ACh */ case   13:  		/* stw R28, <#[R11 + 12]> */
		/* 8224F5ACh case   13:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x0000000C) );
		/* 8224F5ACh case   13:*/		return 0x8224F5B0;
		  /* 8224F5B0h */ case   14:  		/* b 8 */
		/* 8224F5B0h case   14:*/		return 0x8224F5B8;
		/* 8224F5B0h case   14:*/		return 0x8224F5B4;
	}
	return 0x8224F5B4;
} // Block from 8224F578h-8224F5B4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8224F5B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F5B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F5B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F5B4);
		  /* 8224F5B4h */ case    0:  		/* mr R11, R29 */
		/* 8224F5B4h case    0:*/		regs.R11 = regs.R29;
		/* 8224F5B4h case    0:*/		return 0x8224F5B8;
	}
	return 0x8224F5B8;
} // Block from 8224F5B4h-8224F5B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224F5B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F5B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F5B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F5B8);
		  /* 8224F5B8h */ case    0:  		/* stw R11, <#[R31 + 12]> */
		/* 8224F5B8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224F5B8h case    0:*/		return 0x8224F5BC;
		  /* 8224F5BCh */ case    1:  		/* li R4, 20 */
		/* 8224F5BCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 8224F5BCh case    1:*/		return 0x8224F5C0;
		  /* 8224F5C0h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 8224F5C0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224F5C0h case    2:*/		return 0x8224F5C4;
		  /* 8224F5C4h */ case    3:  		/* lwz R26, <#[R11 + 1456]> */
		/* 8224F5C4h case    3:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224F5C4h case    3:*/		return 0x8224F5C8;
		  /* 8224F5C8h */ case    4:  		/* mr R3, R26 */
		/* 8224F5C8h case    4:*/		regs.R3 = regs.R26;
		/* 8224F5C8h case    4:*/		return 0x8224F5CC;
		  /* 8224F5CCh */ case    5:  		/* bl -209172 */
		/* 8224F5CCh case    5:*/		regs.LR = 0x8224F5D0; return 0x8221C4B8;
		/* 8224F5CCh case    5:*/		return 0x8224F5D0;
		  /* 8224F5D0h */ case    6:  		/* addic. R30, R3, 4 */
		/* 8224F5D0h case    6:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 8224F5D0h case    6:*/		return 0x8224F5D4;
		  /* 8224F5D4h */ case    7:  		/* stw R26, <#[R3]> */
		/* 8224F5D4h case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x00000000) );
		/* 8224F5D4h case    7:*/		return 0x8224F5D8;
		  /* 8224F5D8h */ case    8:  		/* bc 12, CR0_EQ, 24 */
		/* 8224F5D8h case    8:*/		if ( regs.CR[0].eq ) { return 0x8224F5F0;  }
		/* 8224F5D8h case    8:*/		return 0x8224F5DC;
		  /* 8224F5DCh */ case    9:  		/* lwz R11, <#[R31]> */
		/* 8224F5DCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224F5DCh case    9:*/		return 0x8224F5E0;
		  /* 8224F5E0h */ case   10:  		/* mr R3, R30 */
		/* 8224F5E0h case   10:*/		regs.R3 = regs.R30;
		/* 8224F5E0h case   10:*/		return 0x8224F5E4;
		  /* 8224F5E4h */ case   11:  		/* lwz R4, <#[R11 + 1456]> */
		/* 8224F5E4h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224F5E4h case   11:*/		return 0x8224F5E8;
		  /* 8224F5E8h */ case   12:  		/* bl -104584 */
		/* 8224F5E8h case   12:*/		regs.LR = 0x8224F5EC; return 0x82235D60;
		/* 8224F5E8h case   12:*/		return 0x8224F5EC;
		  /* 8224F5ECh */ case   13:  		/* b 8 */
		/* 8224F5ECh case   13:*/		return 0x8224F5F4;
		/* 8224F5ECh case   13:*/		return 0x8224F5F0;
	}
	return 0x8224F5F0;
} // Block from 8224F5B8h-8224F5F0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224F5F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F5F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F5F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F5F0);
		  /* 8224F5F0h */ case    0:  		/* mr R30, R29 */
		/* 8224F5F0h case    0:*/		regs.R30 = regs.R29;
		/* 8224F5F0h case    0:*/		return 0x8224F5F4;
	}
	return 0x8224F5F4;
} // Block from 8224F5F0h-8224F5F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224F5F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F5F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F5F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F5F4);
		  /* 8224F5F4h */ case    0:  		/* stw R30, <#[R31 + 20]> */
		/* 8224F5F4h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000014) );
		/* 8224F5F4h case    0:*/		return 0x8224F5F8;
		  /* 8224F5F8h */ case    1:  		/* li R4, 20 */
		/* 8224F5F8h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 8224F5F8h case    1:*/		return 0x8224F5FC;
		  /* 8224F5FCh */ case    2:  		/* lwz R11, <#[R31]> */
		/* 8224F5FCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224F5FCh case    2:*/		return 0x8224F600;
		  /* 8224F600h */ case    3:  		/* lwz R26, <#[R11 + 1456]> */
		/* 8224F600h case    3:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224F600h case    3:*/		return 0x8224F604;
		  /* 8224F604h */ case    4:  		/* mr R3, R26 */
		/* 8224F604h case    4:*/		regs.R3 = regs.R26;
		/* 8224F604h case    4:*/		return 0x8224F608;
		  /* 8224F608h */ case    5:  		/* bl -209232 */
		/* 8224F608h case    5:*/		regs.LR = 0x8224F60C; return 0x8221C4B8;
		/* 8224F608h case    5:*/		return 0x8224F60C;
		  /* 8224F60Ch */ case    6:  		/* addic. R30, R3, 4 */
		/* 8224F60Ch case    6:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 8224F60Ch case    6:*/		return 0x8224F610;
		  /* 8224F610h */ case    7:  		/* stw R26, <#[R3]> */
		/* 8224F610h case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x00000000) );
		/* 8224F610h case    7:*/		return 0x8224F614;
		  /* 8224F614h */ case    8:  		/* bc 12, CR0_EQ, 24 */
		/* 8224F614h case    8:*/		if ( regs.CR[0].eq ) { return 0x8224F62C;  }
		/* 8224F614h case    8:*/		return 0x8224F618;
		  /* 8224F618h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 8224F618h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224F618h case    9:*/		return 0x8224F61C;
		  /* 8224F61Ch */ case   10:  		/* mr R3, R30 */
		/* 8224F61Ch case   10:*/		regs.R3 = regs.R30;
		/* 8224F61Ch case   10:*/		return 0x8224F620;
		  /* 8224F620h */ case   11:  		/* lwz R4, <#[R11 + 1456]> */
		/* 8224F620h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224F620h case   11:*/		return 0x8224F624;
		  /* 8224F624h */ case   12:  		/* bl -104644 */
		/* 8224F624h case   12:*/		regs.LR = 0x8224F628; return 0x82235D60;
		/* 8224F624h case   12:*/		return 0x8224F628;
		  /* 8224F628h */ case   13:  		/* b 8 */
		/* 8224F628h case   13:*/		return 0x8224F630;
		/* 8224F628h case   13:*/		return 0x8224F62C;
	}
	return 0x8224F62C;
} // Block from 8224F5F4h-8224F62Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224F62Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F62C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F62C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F62C);
		  /* 8224F62Ch */ case    0:  		/* mr R30, R29 */
		/* 8224F62Ch case    0:*/		regs.R30 = regs.R29;
		/* 8224F62Ch case    0:*/		return 0x8224F630;
	}
	return 0x8224F630;
} // Block from 8224F62Ch-8224F630h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224F630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F630);
		  /* 8224F630h */ case    0:  		/* stw R30, <#[R31 + 24]> */
		/* 8224F630h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000018) );
		/* 8224F630h case    0:*/		return 0x8224F634;
		  /* 8224F634h */ case    1:  		/* li R4, 36 */
		/* 8224F634h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x24);
		/* 8224F634h case    1:*/		return 0x8224F638;
		  /* 8224F638h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 8224F638h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224F638h case    2:*/		return 0x8224F63C;
		  /* 8224F63Ch */ case    3:  		/* lwz R26, <#[R11 + 1456]> */
		/* 8224F63Ch case    3:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224F63Ch case    3:*/		return 0x8224F640;
		  /* 8224F640h */ case    4:  		/* mr R3, R26 */
		/* 8224F640h case    4:*/		regs.R3 = regs.R26;
		/* 8224F640h case    4:*/		return 0x8224F644;
		  /* 8224F644h */ case    5:  		/* bl -209292 */
		/* 8224F644h case    5:*/		regs.LR = 0x8224F648; return 0x8221C4B8;
		/* 8224F644h case    5:*/		return 0x8224F648;
		  /* 8224F648h */ case    6:  		/* addic. R30, R3, 4 */
		/* 8224F648h case    6:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 8224F648h case    6:*/		return 0x8224F64C;
		  /* 8224F64Ch */ case    7:  		/* stw R26, <#[R3]> */
		/* 8224F64Ch case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x00000000) );
		/* 8224F64Ch case    7:*/		return 0x8224F650;
		  /* 8224F650h */ case    8:  		/* bc 12, CR0_EQ, 28 */
		/* 8224F650h case    8:*/		if ( regs.CR[0].eq ) { return 0x8224F66C;  }
		/* 8224F650h case    8:*/		return 0x8224F654;
		  /* 8224F654h */ case    9:  		/* addi R3, R30, 8 */
		/* 8224F654h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x8);
		/* 8224F654h case    9:*/		return 0x8224F658;
		  /* 8224F658h */ case   10:  		/* bl 16848 */
		/* 8224F658h case   10:*/		regs.LR = 0x8224F65C; return 0x82253828;
		/* 8224F658h case   10:*/		return 0x8224F65C;
		  /* 8224F65Ch */ case   11:  		/* stw R29, <#[R30]> */
		/* 8224F65Ch case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000000) );
		/* 8224F65Ch case   11:*/		return 0x8224F660;
		  /* 8224F660h */ case   12:  		/* mr R11, R30 */
		/* 8224F660h case   12:*/		regs.R11 = regs.R30;
		/* 8224F660h case   12:*/		return 0x8224F664;
		  /* 8224F664h */ case   13:  		/* stw R29, <#[R30 + 4]> */
		/* 8224F664h case   13:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000004) );
		/* 8224F664h case   13:*/		return 0x8224F668;
		  /* 8224F668h */ case   14:  		/* b 8 */
		/* 8224F668h case   14:*/		return 0x8224F670;
		/* 8224F668h case   14:*/		return 0x8224F66C;
	}
	return 0x8224F66C;
} // Block from 8224F630h-8224F66Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8224F66Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F66C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F66C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F66C);
		  /* 8224F66Ch */ case    0:  		/* mr R11, R29 */
		/* 8224F66Ch case    0:*/		regs.R11 = regs.R29;
		/* 8224F66Ch case    0:*/		return 0x8224F670;
	}
	return 0x8224F670;
} // Block from 8224F66Ch-8224F670h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224F670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F670);
		  /* 8224F670h */ case    0:  		/* stw R11, <#[R31 + 32]> */
		/* 8224F670h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8224F670h case    0:*/		return 0x8224F674;
		  /* 8224F674h */ case    1:  		/* lwz R11, <#[R31]> */
		/* 8224F674h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224F674h case    1:*/		return 0x8224F678;
		  /* 8224F678h */ case    2:  		/* lwz R10, <#[R11 + 1360]> */
		/* 8224F678h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000550) );
		/* 8224F678h case    2:*/		return 0x8224F67C;
		  /* 8224F67Ch */ case    3:  		/* lwz R4, <#[R11 + 1456]> */
		/* 8224F67Ch case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224F67Ch case    3:*/		return 0x8224F680;
		  /* 8224F680h */ case    4:  		/* lwz R3, <#[R10 + 4]> */
		/* 8224F680h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x00000004) );
		/* 8224F680h case    4:*/		return 0x8224F684;
		  /* 8224F684h */ case    5:  		/* bl -101700 */
		/* 8224F684h case    5:*/		regs.LR = 0x8224F688; return 0x82236940;
		/* 8224F684h case    5:*/		return 0x8224F688;
		  /* 8224F688h */ case    6:  		/* stw R3, <#[R31 + 116]> */
		/* 8224F688h case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000074) );
		/* 8224F688h case    6:*/		return 0x8224F68C;
		  /* 8224F68Ch */ case    7:  		/* mr R3, R31 */
		/* 8224F68Ch case    7:*/		regs.R3 = regs.R31;
		/* 8224F68Ch case    7:*/		return 0x8224F690;
		  /* 8224F690h */ case    8:  		/* stw R29, <#[R31 + 124]> */
		/* 8224F690h case    8:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x0000007C) );
		/* 8224F690h case    8:*/		return 0x8224F694;
		  /* 8224F694h */ case    9:  		/* stw R28, <#[R31 + 128]> */
		/* 8224F694h case    9:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000080) );
		/* 8224F694h case    9:*/		return 0x8224F698;
		  /* 8224F698h */ case   10:  		/* stw R29, <#[R31 + 132]> */
		/* 8224F698h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000084) );
		/* 8224F698h case   10:*/		return 0x8224F69C;
		  /* 8224F69Ch */ case   11:  		/* stw R29, <#[R31 + 136]> */
		/* 8224F69Ch case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000088) );
		/* 8224F69Ch case   11:*/		return 0x8224F6A0;
		  /* 8224F6A0h */ case   12:  		/* stw R29, <#[R31 + 140]> */
		/* 8224F6A0h case   12:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x0000008C) );
		/* 8224F6A0h case   12:*/		return 0x8224F6A4;
		  /* 8224F6A4h */ case   13:  		/* stw R29, <#[R31 + 144]> */
		/* 8224F6A4h case   13:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000090) );
		/* 8224F6A4h case   13:*/		return 0x8224F6A8;
		  /* 8224F6A8h */ case   14:  		/* bl -18096 */
		/* 8224F6A8h case   14:*/		regs.LR = 0x8224F6AC; return 0x8224AFF8;
		/* 8224F6A8h case   14:*/		return 0x8224F6AC;
		  /* 8224F6ACh */ case   15:  		/* mr R3, R31 */
		/* 8224F6ACh case   15:*/		regs.R3 = regs.R31;
		/* 8224F6ACh case   15:*/		return 0x8224F6B0;
		  /* 8224F6B0h */ case   16:  		/* bl -14072 */
		/* 8224F6B0h case   16:*/		regs.LR = 0x8224F6B4; return 0x8224BFB8;
		/* 8224F6B0h case   16:*/		return 0x8224F6B4;
		  /* 8224F6B4h */ case   17:  		/* mr R3, R31 */
		/* 8224F6B4h case   17:*/		regs.R3 = regs.R31;
		/* 8224F6B4h case   17:*/		return 0x8224F6B8;
		  /* 8224F6B8h */ case   18:  		/* bl -13264 */
		/* 8224F6B8h case   18:*/		regs.LR = 0x8224F6BC; return 0x8224C2E8;
		/* 8224F6B8h case   18:*/		return 0x8224F6BC;
		  /* 8224F6BCh */ case   19:  		/* lwz R11, <#[R31 + 4]> */
		/* 8224F6BCh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8224F6BCh case   19:*/		return 0x8224F6C0;
		  /* 8224F6C0h */ case   20:  		/* lwz R30, <#[R11 + 136]> */
		/* 8224F6C0h case   20:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000088) );
		/* 8224F6C0h case   20:*/		return 0x8224F6C4;
		  /* 8224F6C4h */ case   21:  		/* b 52 */
		/* 8224F6C4h case   21:*/		return 0x8224F6F8;
		/* 8224F6C4h case   21:*/		return 0x8224F6C8;
		  /* 8224F6C8h */ case   22:  		/* addi R3, R30, 20 */
		/* 8224F6C8h case   22:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x14);
		/* 8224F6C8h case   22:*/		return 0x8224F6CC;
		  /* 8224F6CCh */ case   23:  		/* bl 16788 */
		/* 8224F6CCh case   23:*/		regs.LR = 0x8224F6D0; return 0x82253860;
		/* 8224F6CCh case   23:*/		return 0x8224F6D0;
		  /* 8224F6D0h */ case   24:  		/* cmpwi CR6, R3, 2 */
		/* 8224F6D0h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 8224F6D0h case   24:*/		return 0x8224F6D4;
		  /* 8224F6D4h */ case   25:  		/* bc 4, CR6_GT, 32 */
		/* 8224F6D4h case   25:*/		if ( !regs.CR[6].gt ) { return 0x8224F6F4;  }
		/* 8224F6D4h case   25:*/		return 0x8224F6D8;
		  /* 8224F6D8h */ case   26:  		/* mr R4, R30 */
		/* 8224F6D8h case   26:*/		regs.R4 = regs.R30;
		/* 8224F6D8h case   26:*/		return 0x8224F6DC;
		  /* 8224F6DCh */ case   27:  		/* mr R3, R31 */
		/* 8224F6DCh case   27:*/		regs.R3 = regs.R31;
		/* 8224F6DCh case   27:*/		return 0x8224F6E0;
		  /* 8224F6E0h */ case   28:  		/* bl -1352 */
		/* 8224F6E0h case   28:*/		regs.LR = 0x8224F6E4; return 0x8224F198;
		/* 8224F6E0h case   28:*/		return 0x8224F6E4;
		  /* 8224F6E4h */ case   29:  		/* lwz R11, <#[R31 + 124]> */
		/* 8224F6E4h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000007C) );
		/* 8224F6E4h case   29:*/		return 0x8224F6E8;
		  /* 8224F6E8h */ case   30:  		/* lwz R10, <#[R31 + 28]> */
		/* 8224F6E8h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 8224F6E8h case   30:*/		return 0x8224F6EC;
		  /* 8224F6ECh */ case   31:  		/* add R11, R10, R11 */
		/* 8224F6ECh case   31:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8224F6ECh case   31:*/		return 0x8224F6F0;
		  /* 8224F6F0h */ case   32:  		/* stw R11, <#[R31 + 124]> */
		/* 8224F6F0h case   32:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000007C) );
		/* 8224F6F0h case   32:*/		return 0x8224F6F4;
	}
	return 0x8224F6F4;
} // Block from 8224F670h-8224F6F4h (33 instructions)

//////////////////////////////////////////////////////
// Block at 8224F6F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F6F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F6F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F6F4);
		  /* 8224F6F4h */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 8224F6F4h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 8224F6F4h case    0:*/		return 0x8224F6F8;
	}
	return 0x8224F6F8;
} // Block from 8224F6F4h-8224F6F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224F6F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F6F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F6F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F6F8);
		  /* 8224F6F8h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 8224F6F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8224F6F8h case    0:*/		return 0x8224F6FC;
		  /* 8224F6FCh */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224F6FCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224F6FCh case    1:*/		return 0x8224F700;
		  /* 8224F700h */ case    2:  		/* bc 4, CR6_EQ, -56 */
		/* 8224F700h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224F6C8;  }
		/* 8224F700h case    2:*/		return 0x8224F704;
		  /* 8224F704h */ case    3:  		/* lwz R11, <#[R31 + 128]> */
		/* 8224F704h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 8224F704h case    3:*/		return 0x8224F708;
		  /* 8224F708h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 8224F708h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224F708h case    4:*/		return 0x8224F70C;
		  /* 8224F70Ch */ case    5:  		/* bc 12, CR6_LT, 32 */
		/* 8224F70Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x8224F72C;  }
		/* 8224F70Ch case    5:*/		return 0x8224F710;
		  /* 8224F710h */ case    6:  		/* mr R4, R29 */
		/* 8224F710h case    6:*/		regs.R4 = regs.R29;
		/* 8224F710h case    6:*/		return 0x8224F714;
		  /* 8224F714h */ case    7:  		/* lwz R3, <#[R31 + 4]> */
		/* 8224F714h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 8224F714h case    7:*/		return 0x8224F718;
		  /* 8224F718h */ case    8:  		/* bl -33128 */
		/* 8224F718h case    8:*/		regs.LR = 0x8224F71C; return 0x822475B0;
		/* 8224F718h case    8:*/		return 0x8224F71C;
		  /* 8224F71Ch */ case    9:  		/* lwz R11, <#[R31 + 128]> */
		/* 8224F71Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 8224F71Ch case    9:*/		return 0x8224F720;
		  /* 8224F720h */ case   10:  		/* addi R29, R29, 1 */
		/* 8224F720h case   10:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8224F720h case   10:*/		return 0x8224F724;
		  /* 8224F724h */ case   11:  		/* cmpw CR6, R29, R11 */
		/* 8224F724h case   11:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R11);
		/* 8224F724h case   11:*/		return 0x8224F728;
		  /* 8224F728h */ case   12:  		/* bc 4, CR6_GT, -24 */
		/* 8224F728h case   12:*/		if ( !regs.CR[6].gt ) { return 0x8224F710;  }
		/* 8224F728h case   12:*/		return 0x8224F72C;
	}
	return 0x8224F72C;
} // Block from 8224F6F8h-8224F72Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224F72Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F72C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F72C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F72C);
		  /* 8224F72Ch */ case    0:  		/* lis R11, -32252 */
		/* 8224F72Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224F72Ch case    0:*/		return 0x8224F730;
		  /* 8224F730h */ case    1:  		/* lwz R5, <#[R31 + 124]> */
		/* 8224F730h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000007C) );
		/* 8224F730h case    1:*/		return 0x8224F734;
		  /* 8224F734h */ case    2:  		/* lwz R3, <#[R31]> */
		/* 8224F734h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8224F734h case    2:*/		return 0x8224F738;
		  /* 8224F738h */ case    3:  		/* addi R4, R11, 15864 */
		/* 8224F738h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x3DF8);
		/* 8224F738h case    3:*/		return 0x8224F73C;
		  /* 8224F73Ch */ case    4:  		/* bl -205692 */
		/* 8224F73Ch case    4:*/		regs.LR = 0x8224F740; return 0x8221D3C0;
		/* 8224F73Ch case    4:*/		return 0x8224F740;
		  /* 8224F740h */ case    5:  		/* lwz R5, <#[R31 + 128]> */
		/* 8224F740h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000080) );
		/* 8224F740h case    5:*/		return 0x8224F744;
		  /* 8224F744h */ case    6:  		/* cmpwi CR6, R5, 0 */
		/* 8224F744h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 8224F744h case    6:*/		return 0x8224F748;
		  /* 8224F748h */ case    7:  		/* bc 12, CR6_LT, 20 */
		/* 8224F748h case    7:*/		if ( regs.CR[6].lt ) { return 0x8224F75C;  }
		/* 8224F748h case    7:*/		return 0x8224F74C;
		  /* 8224F74Ch */ case    8:  		/* lis R11, -32252 */
		/* 8224F74Ch case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224F74Ch case    8:*/		return 0x8224F750;
		  /* 8224F750h */ case    9:  		/* lwz R3, <#[R31]> */
		/* 8224F750h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8224F750h case    9:*/		return 0x8224F754;
		  /* 8224F754h */ case   10:  		/* addi R4, R11, 15828 */
		/* 8224F754h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x3DD4);
		/* 8224F754h case   10:*/		return 0x8224F758;
		  /* 8224F758h */ case   11:  		/* bl -205720 */
		/* 8224F758h case   11:*/		regs.LR = 0x8224F75C; return 0x8221D3C0;
		/* 8224F758h case   11:*/		return 0x8224F75C;
	}
	return 0x8224F75C;
} // Block from 8224F72Ch-8224F75Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224F75Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F75C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F75C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F75C);
		  /* 8224F75Ch */ case    0:  		/* lis R11, -32252 */
		/* 8224F75Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224F75Ch case    0:*/		return 0x8224F760;
		  /* 8224F760h */ case    1:  		/* lwz R6, <#[R31 + 136]> */
		/* 8224F760h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000088) );
		/* 8224F760h case    1:*/		return 0x8224F764;
		  /* 8224F764h */ case    2:  		/* lwz R5, <#[R31 + 132]> */
		/* 8224F764h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000084) );
		/* 8224F764h case    2:*/		return 0x8224F768;
		  /* 8224F768h */ case    3:  		/* addi R4, R11, 15784 */
		/* 8224F768h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x3DA8);
		/* 8224F768h case    3:*/		return 0x8224F76C;
		  /* 8224F76Ch */ case    4:  		/* lwz R3, <#[R31]> */
		/* 8224F76Ch case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8224F76Ch case    4:*/		return 0x8224F770;
		  /* 8224F770h */ case    5:  		/* bl -205744 */
		/* 8224F770h case    5:*/		regs.LR = 0x8224F774; return 0x8221D3C0;
		/* 8224F770h case    5:*/		return 0x8224F774;
		  /* 8224F774h */ case    6:  		/* mr R3, R27 */
		/* 8224F774h case    6:*/		regs.R3 = regs.R27;
		/* 8224F774h case    6:*/		return 0x8224F778;
		  /* 8224F778h */ case    7:  		/* bl 81416 */
		/* 8224F778h case    7:*/		regs.LR = 0x8224F77C; return 0x82263580;
		/* 8224F778h case    7:*/		return 0x8224F77C;
		  /* 8224F77Ch */ case    8:  		/* lwz R11, <#[R31 + 116]> */
		/* 8224F77Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000074) );
		/* 8224F77Ch case    8:*/		return 0x8224F780;
		  /* 8224F780h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 8224F780h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224F780h case    9:*/		return 0x8224F784;
		  /* 8224F784h */ case   10:  		/* bc 12, CR6_EQ, 16 */
		/* 8224F784h case   10:*/		if ( regs.CR[6].eq ) { return 0x8224F794;  }
		/* 8224F784h case   10:*/		return 0x8224F788;
		  /* 8224F788h */ case   11:  		/* addi R4, R11, -4 */
		/* 8224F788h case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 8224F788h case   11:*/		return 0x8224F78C;
		  /* 8224F78Ch */ case   12:  		/* lwz R3, <#[R11 - 4]> */
		/* 8224F78Ch case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 8224F78Ch case   12:*/		return 0x8224F790;
		  /* 8224F790h */ case   13:  		/* bl -209232 */
		/* 8224F790h case   13:*/		regs.LR = 0x8224F794; return 0x8221C640;
		/* 8224F790h case   13:*/		return 0x8224F794;
	}
	return 0x8224F794;
} // Block from 8224F75Ch-8224F794h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224F794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F794);
		  /* 8224F794h */ case    0:  		/* lwz R3, <#[R31 + 32]> */
		/* 8224F794h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000020) );
		/* 8224F794h case    0:*/		return 0x8224F798;
		  /* 8224F798h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8224F798h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8224F798h case    1:*/		return 0x8224F79C;
		  /* 8224F79Ch */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8224F79Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8224F7A8;  }
		/* 8224F79Ch case    2:*/		return 0x8224F7A0;
		  /* 8224F7A0h */ case    3:  		/* li R4, 1 */
		/* 8224F7A0h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224F7A0h case    3:*/		return 0x8224F7A4;
		  /* 8224F7A4h */ case    4:  		/* bl -14404 */
		/* 8224F7A4h case    4:*/		regs.LR = 0x8224F7A8; return 0x8224BF60;
		/* 8224F7A4h case    4:*/		return 0x8224F7A8;
	}
	return 0x8224F7A8;
} // Block from 8224F794h-8224F7A8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224F7A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F7A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F7A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F7A8);
		  /* 8224F7A8h */ case    0:  		/* lwz R3, <#[R31 + 24]> */
		/* 8224F7A8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 8224F7A8h case    0:*/		return 0x8224F7AC;
		  /* 8224F7ACh */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8224F7ACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8224F7ACh case    1:*/		return 0x8224F7B0;
		  /* 8224F7B0h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8224F7B0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224F7BC;  }
		/* 8224F7B0h case    2:*/		return 0x8224F7B4;
		  /* 8224F7B4h */ case    3:  		/* li R4, 1 */
		/* 8224F7B4h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224F7B4h case    3:*/		return 0x8224F7B8;
		  /* 8224F7B8h */ case    4:  		/* bl -64544 */
		/* 8224F7B8h case    4:*/		regs.LR = 0x8224F7BC; return 0x8223FB98;
		/* 8224F7B8h case    4:*/		return 0x8224F7BC;
	}
	return 0x8224F7BC;
} // Block from 8224F7A8h-8224F7BCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224F7BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F7BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F7BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F7BC);
		  /* 8224F7BCh */ case    0:  		/* lwz R3, <#[R31 + 20]> */
		/* 8224F7BCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 8224F7BCh case    0:*/		return 0x8224F7C0;
		  /* 8224F7C0h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8224F7C0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8224F7C0h case    1:*/		return 0x8224F7C4;
		  /* 8224F7C4h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8224F7C4h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224F7D0;  }
		/* 8224F7C4h case    2:*/		return 0x8224F7C8;
		  /* 8224F7C8h */ case    3:  		/* li R4, 1 */
		/* 8224F7C8h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224F7C8h case    3:*/		return 0x8224F7CC;
		  /* 8224F7CCh */ case    4:  		/* bl -64564 */
		/* 8224F7CCh case    4:*/		regs.LR = 0x8224F7D0; return 0x8223FB98;
		/* 8224F7CCh case    4:*/		return 0x8224F7D0;
	}
	return 0x8224F7D0;
} // Block from 8224F7BCh-8224F7D0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224F7D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F7D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F7D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F7D0);
		  /* 8224F7D0h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8224F7D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224F7D0h case    0:*/		return 0x8224F7D4;
		  /* 8224F7D4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8224F7D4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224F7D4h case    1:*/		return 0x8224F7D8;
		  /* 8224F7D8h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8224F7D8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224F7E8;  }
		/* 8224F7D8h case    2:*/		return 0x8224F7DC;
		  /* 8224F7DCh */ case    3:  		/* addi R4, R11, -4 */
		/* 8224F7DCh case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 8224F7DCh case    3:*/		return 0x8224F7E0;
		  /* 8224F7E0h */ case    4:  		/* lwz R3, <#[R11 - 4]> */
		/* 8224F7E0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 8224F7E0h case    4:*/		return 0x8224F7E4;
		  /* 8224F7E4h */ case    5:  		/* bl -209316 */
		/* 8224F7E4h case    5:*/		regs.LR = 0x8224F7E8; return 0x8221C640;
		/* 8224F7E4h case    5:*/		return 0x8224F7E8;
	}
	return 0x8224F7E8;
} // Block from 8224F7D0h-8224F7E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224F7E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F7E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F7E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F7E8);
		  /* 8224F7E8h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8224F7E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8224F7E8h case    0:*/		return 0x8224F7EC;
		  /* 8224F7ECh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8224F7ECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224F7ECh case    1:*/		return 0x8224F7F0;
		  /* 8224F7F0h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8224F7F0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224F800;  }
		/* 8224F7F0h case    2:*/		return 0x8224F7F4;
		  /* 8224F7F4h */ case    3:  		/* addi R4, R11, -4 */
		/* 8224F7F4h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 8224F7F4h case    3:*/		return 0x8224F7F8;
		  /* 8224F7F8h */ case    4:  		/* lwz R3, <#[R11 - 4]> */
		/* 8224F7F8h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 8224F7F8h case    4:*/		return 0x8224F7FC;
		  /* 8224F7FCh */ case    5:  		/* bl -209340 */
		/* 8224F7FCh case    5:*/		regs.LR = 0x8224F800; return 0x8221C640;
		/* 8224F7FCh case    5:*/		return 0x8224F800;
	}
	return 0x8224F800;
} // Block from 8224F7E8h-8224F800h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224F800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F800);
		  /* 8224F800h */ case    0:  		/* addi R1, R1, 144 */
		/* 8224F800h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8224F800h case    0:*/		return 0x8224F804;
		  /* 8224F804h */ case    1:  		/* b -1828196 */
		/* 8224F804h case    1:*/		return 0x820912A0;
		/* 8224F804h case    1:*/		return 0x8224F808;
	}
	return 0x8224F808;
} // Block from 8224F800h-8224F808h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224F808h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F808);
		  /* 8224F808h */ case    0:  		/* mfspr R12, LR */
		/* 8224F808h case    0:*/		regs.R12 = regs.LR;
		/* 8224F808h case    0:*/		return 0x8224F80C;
		  /* 8224F80Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8224F80Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224F80Ch case    1:*/		return 0x8224F810;
		  /* 8224F810h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8224F810h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224F810h case    2:*/		return 0x8224F814;
		  /* 8224F814h */ case    3:  		/* stwu R1, <#[R1 - 256]> */
		/* 8224F814h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 8224F814h case    3:*/		return 0x8224F818;
		  /* 8224F818h */ case    4:  		/* mr R31, R3 */
		/* 8224F818h case    4:*/		regs.R31 = regs.R3;
		/* 8224F818h case    4:*/		return 0x8224F81C;
		  /* 8224F81Ch */ case    5:  		/* addi R3, R1, 116 */
		/* 8224F81Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x74);
		/* 8224F81Ch case    5:*/		return 0x8224F820;
		  /* 8224F820h */ case    6:  		/* bl 16392 */
		/* 8224F820h case    6:*/		regs.LR = 0x8224F824; return 0x82253828;
		/* 8224F820h case    6:*/		return 0x8224F824;
		  /* 8224F824h */ case    7:  		/* addi R3, R1, 140 */
		/* 8224F824h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x8C);
		/* 8224F824h case    7:*/		return 0x8224F828;
		  /* 8224F828h */ case    8:  		/* bl 16384 */
		/* 8224F828h case    8:*/		regs.LR = 0x8224F82C; return 0x82253828;
		/* 8224F828h case    8:*/		return 0x8224F82C;
		  /* 8224F82Ch */ case    9:  		/* addi R3, R1, 164 */
		/* 8224F82Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA4);
		/* 8224F82Ch case    9:*/		return 0x8224F830;
		  /* 8224F830h */ case   10:  		/* bl 16376 */
		/* 8224F830h case   10:*/		regs.LR = 0x8224F834; return 0x82253828;
		/* 8224F830h case   10:*/		return 0x8224F834;
		  /* 8224F834h */ case   11:  		/* mr R4, R31 */
		/* 8224F834h case   11:*/		regs.R4 = regs.R31;
		/* 8224F834h case   11:*/		return 0x8224F838;
		  /* 8224F838h */ case   12:  		/* addi R3, R1, 80 */
		/* 8224F838h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8224F838h case   12:*/		return 0x8224F83C;
		  /* 8224F83Ch */ case   13:  		/* bl -796 */
		/* 8224F83Ch case   13:*/		regs.LR = 0x8224F840; return 0x8224F520;
		/* 8224F83Ch case   13:*/		return 0x8224F840;
		  /* 8224F840h */ case   14:  		/* mr R3, R31 */
		/* 8224F840h case   14:*/		regs.R3 = regs.R31;
		/* 8224F840h case   14:*/		return 0x8224F844;
		  /* 8224F844h */ case   15:  		/* bl -102036 */
		/* 8224F844h case   15:*/		regs.LR = 0x8224F848; return 0x822369B0;
		/* 8224F844h case   15:*/		return 0x8224F848;
		  /* 8224F848h */ case   16:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224F848h case   16:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224F848h case   16:*/		return 0x8224F84C;
		  /* 8224F84Ch */ case   17:  		/* bc 4, CR0_EQ, 40 */
		/* 8224F84Ch case   17:*/		if ( !regs.CR[0].eq ) { return 0x8224F874;  }
		/* 8224F84Ch case   17:*/		return 0x8224F850;
		  /* 8224F850h */ case   18:  		/* lis R11, -32252 */
		/* 8224F850h case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224F850h case   18:*/		return 0x8224F854;
		  /* 8224F854h */ case   19:  		/* lis R10, -32252 */
		/* 8224F854h case   19:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224F854h case   19:*/		return 0x8224F858;
		  /* 8224F858h */ case   20:  		/* lis R9, -32253 */
		/* 8224F858h case   20:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8224F858h case   20:*/		return 0x8224F85C;
		  /* 8224F85Ch */ case   21:  		/* addi R6, R11, 14208 */
		/* 8224F85Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x3780);
		/* 8224F85Ch case   21:*/		return 0x8224F860;
		  /* 8224F860h */ case   22:  		/* addi R5, R10, 15896 */
		/* 8224F860h case   22:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x3E18);
		/* 8224F860h case   22:*/		return 0x8224F864;
		  /* 8224F864h */ case   23:  		/* addi R4, R9, 27460 */
		/* 8224F864h case   23:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8224F864h case   23:*/		return 0x8224F868;
		  /* 8224F868h */ case   24:  		/* li R7, 491 */
		/* 8224F868h case   24:*/		cpu::op::li<0>(regs,&regs.R7,0x1EB);
		/* 8224F868h case   24:*/		return 0x8224F86C;
		  /* 8224F86Ch */ case   25:  		/* li R3, 0 */
		/* 8224F86Ch case   25:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224F86Ch case   25:*/		return 0x8224F870;
		  /* 8224F870h */ case   26:  		/* bl -1014888 */
		/* 8224F870h case   26:*/		regs.LR = 0x8224F874; return 0x82157C08;
		/* 8224F870h case   26:*/		return 0x8224F874;
	}
	return 0x8224F874;
} // Block from 8224F808h-8224F874h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8224F874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F874);
		  /* 8224F874h */ case    0:  		/* addi R1, R1, 256 */
		/* 8224F874h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 8224F874h case    0:*/		return 0x8224F878;
		  /* 8224F878h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8224F878h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224F878h case    1:*/		return 0x8224F87C;
		  /* 8224F87Ch */ case    2:  		/* mtspr LR, R12 */
		/* 8224F87Ch case    2:*/		regs.LR = regs.R12;
		/* 8224F87Ch case    2:*/		return 0x8224F880;
		  /* 8224F880h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8224F880h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224F880h case    3:*/		return 0x8224F884;
		  /* 8224F884h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8224F884h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224F884h case    4:*/		return 0x8224F888;
	}
	return 0x8224F888;
} // Block from 8224F874h-8224F888h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224F888h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F888);
		  /* 8224F888h */ case    0:  		/* stw R3, <#[R1 + 20]> */
		/* 8224F888h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000014) );
		/* 8224F888h case    0:*/		return 0x8224F88C;
		  /* 8224F88Ch */ case    1:  		/* li R9, 0 */
		/* 8224F88Ch case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8224F88Ch case    1:*/		return 0x8224F890;
		  /* 8224F890h */ case    2:  		/* lbz R10, <#[R1 + 21]> */
		/* 8224F890h case    2:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000015) );
		/* 8224F890h case    2:*/		return 0x8224F894;
		  /* 8224F894h */ case    3:  		/* lbz R8, <#[R1 + 22]> */
		/* 8224F894h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000016) );
		/* 8224F894h case    3:*/		return 0x8224F898;
		  /* 8224F898h */ case    4:  		/* lbz R7, <#[R1 + 23]> */
		/* 8224F898h case    4:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000017) );
		/* 8224F898h case    4:*/		return 0x8224F89C;
		  /* 8224F89Ch */ case    5:  		/* lbz R11, <#[R1 + 20]> */
		/* 8224F89Ch case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000014) );
		/* 8224F89Ch case    5:*/		return 0x8224F8A0;
		  /* 8224F8A0h */ case    6:  		/* addi R11, R11, -1 */
		/* 8224F8A0h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8224F8A0h case    6:*/		return 0x8224F8A4;
		  /* 8224F8A4h */ case    7:  		/* addic R6, R11, -1 */
		/* 8224F8A4h case    7:*/		cpu::op::addic<0>(regs,&regs.R6,regs.R11,0xFFFFFFFF);
		/* 8224F8A4h case    7:*/		return 0x8224F8A8;
		  /* 8224F8A8h */ case    8:  		/* stw R9, <#[R1 - 16]> */
		/* 8224F8A8h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224F8A8h case    8:*/		return 0x8224F8AC;
		  /* 8224F8ACh */ case    9:  		/* addi R10, R10, -1 */
		/* 8224F8ACh case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8224F8ACh case    9:*/		return 0x8224F8B0;
		  /* 8224F8B0h */ case   10:  		/* mr R9, R8 */
		/* 8224F8B0h case   10:*/		regs.R9 = regs.R8;
		/* 8224F8B0h case   10:*/		return 0x8224F8B4;
		  /* 8224F8B4h */ case   11:  		/* subfe R8, R6, R11 */
		/* 8224F8B4h case   11:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R6,regs.R11);
		/* 8224F8B4h case   11:*/		return 0x8224F8B8;
		  /* 8224F8B8h */ case   12:  		/* addic R6, R10, -1 */
		/* 8224F8B8h case   12:*/		cpu::op::addic<0>(regs,&regs.R6,regs.R10,0xFFFFFFFF);
		/* 8224F8B8h case   12:*/		return 0x8224F8BC;
		  /* 8224F8BCh */ case   13:  		/* addi R11, R9, -1 */
		/* 8224F8BCh case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 8224F8BCh case   13:*/		return 0x8224F8C0;
		  /* 8224F8C0h */ case   14:  		/* stb R8, <#[R1 - 16]> */
		/* 8224F8C0h case   14:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224F8C0h case   14:*/		return 0x8224F8C4;
		  /* 8224F8C4h */ case   15:  		/* mr R9, R7 */
		/* 8224F8C4h case   15:*/		regs.R9 = regs.R7;
		/* 8224F8C4h case   15:*/		return 0x8224F8C8;
		  /* 8224F8C8h */ case   16:  		/* subfe R8, R6, R10 */
		/* 8224F8C8h case   16:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R6,regs.R10);
		/* 8224F8C8h case   16:*/		return 0x8224F8CC;
		  /* 8224F8CCh */ case   17:  		/* addic R7, R11, -1 */
		/* 8224F8CCh case   17:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R11,0xFFFFFFFF);
		/* 8224F8CCh case   17:*/		return 0x8224F8D0;
		  /* 8224F8D0h */ case   18:  		/* addi R10, R9, -1 */
		/* 8224F8D0h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFFFFF);
		/* 8224F8D0h case   18:*/		return 0x8224F8D4;
		  /* 8224F8D4h */ case   19:  		/* stb R8, <#[R1 - 15]> */
		/* 8224F8D4h case   19:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R1 + 0xFFFFFFF1) );
		/* 8224F8D4h case   19:*/		return 0x8224F8D8;
		  /* 8224F8D8h */ case   20:  		/* subfe R11, R7, R11 */
		/* 8224F8D8h case   20:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 8224F8D8h case   20:*/		return 0x8224F8DC;
		  /* 8224F8DCh */ case   21:  		/* addic R9, R10, -1 */
		/* 8224F8DCh case   21:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 8224F8DCh case   21:*/		return 0x8224F8E0;
		  /* 8224F8E0h */ case   22:  		/* stb R11, <#[R1 - 14]> */
		/* 8224F8E0h case   22:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF2) );
		/* 8224F8E0h case   22:*/		return 0x8224F8E4;
		  /* 8224F8E4h */ case   23:  		/* subfe R11, R9, R10 */
		/* 8224F8E4h case   23:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R9,regs.R10);
		/* 8224F8E4h case   23:*/		return 0x8224F8E8;
		  /* 8224F8E8h */ case   24:  		/* stb R11, <#[R1 - 13]> */
		/* 8224F8E8h case   24:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF3) );
		/* 8224F8E8h case   24:*/		return 0x8224F8EC;
		  /* 8224F8ECh */ case   25:  		/* lwz R3, <#[R1 - 16]> */
		/* 8224F8ECh case   25:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224F8ECh case   25:*/		return 0x8224F8F0;
		  /* 8224F8F0h */ case   26:  		/* bclr 20, CR0_LT */
		/* 8224F8F0h case   26:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224F8F0h case   26:*/		return 0x8224F8F4;
	}
	return 0x8224F8F4;
} // Block from 8224F888h-8224F8F4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8224F8F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F8F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F8F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F8F4);
		  /* 8224F8F4h */ case    0:  		/* nop */
		/* 8224F8F4h case    0:*/		cpu::op::nop();
		/* 8224F8F4h case    0:*/		return 0x8224F8F8;
		  /* 8224F8F8h */ case    1:  		/* li R10, 0 */
		/* 8224F8F8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8224F8F8h case    1:*/		return 0x8224F8FC;
		  /* 8224F8FCh */ case    2:  		/* stw R3, <#[R1 + 20]> */
		/* 8224F8FCh case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000014) );
		/* 8224F8FCh case    2:*/		return 0x8224F900;
		  /* 8224F900h */ case    3:  		/* lbz R11, <#[R1 + 20]> */
		/* 8224F900h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000014) );
		/* 8224F900h case    3:*/		return 0x8224F904;
		  /* 8224F904h */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 8224F904h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224F904h case    4:*/		return 0x8224F908;
		  /* 8224F908h */ case    5:  		/* stw R4, <#[R1 + 28]> */
		/* 8224F908h case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000001C) );
		/* 8224F908h case    5:*/		return 0x8224F90C;
		  /* 8224F90Ch */ case    6:  		/* stw R10, <#[R1 - 16]> */
		/* 8224F90Ch case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224F90Ch case    6:*/		return 0x8224F910;
		  /* 8224F910h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 8224F910h case    7:*/		if ( regs.CR[0].eq ) { return 0x8224F91C;  }
		/* 8224F910h case    7:*/		return 0x8224F914;
		  /* 8224F914h */ case    8:  		/* li R11, 0 */
		/* 8224F914h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224F914h case    8:*/		return 0x8224F918;
		  /* 8224F918h */ case    9:  		/* b 8 */
		/* 8224F918h case    9:*/		return 0x8224F920;
		/* 8224F918h case    9:*/		return 0x8224F91C;
	}
	return 0x8224F91C;
} // Block from 8224F8F4h-8224F91Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224F91Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F91C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F91C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F91C);
		  /* 8224F91Ch */ case    0:  		/* lbz R11, <#[R1 + 28]> */
		/* 8224F91Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000001C) );
		/* 8224F91Ch case    0:*/		return 0x8224F920;
	}
	return 0x8224F920;
} // Block from 8224F91Ch-8224F920h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224F920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F920);
		  /* 8224F920h */ case    0:  		/* lbz R10, <#[R1 + 21]> */
		/* 8224F920h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000015) );
		/* 8224F920h case    0:*/		return 0x8224F924;
		  /* 8224F924h */ case    1:  		/* stb R11, <#[R1 - 16]> */
		/* 8224F924h case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224F924h case    1:*/		return 0x8224F928;
		  /* 8224F928h */ case    2:  		/* cmplwi CR0, R10, 0 */
		/* 8224F928h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 8224F928h case    2:*/		return 0x8224F92C;
		  /* 8224F92Ch */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 8224F92Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x8224F938;  }
		/* 8224F92Ch case    3:*/		return 0x8224F930;
		  /* 8224F930h */ case    4:  		/* li R11, 0 */
		/* 8224F930h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224F930h case    4:*/		return 0x8224F934;
		  /* 8224F934h */ case    5:  		/* b 8 */
		/* 8224F934h case    5:*/		return 0x8224F93C;
		/* 8224F934h case    5:*/		return 0x8224F938;
	}
	return 0x8224F938;
} // Block from 8224F920h-8224F938h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224F938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F938);
		  /* 8224F938h */ case    0:  		/* lbz R11, <#[R1 + 29]> */
		/* 8224F938h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000001D) );
		/* 8224F938h case    0:*/		return 0x8224F93C;
	}
	return 0x8224F93C;
} // Block from 8224F938h-8224F93Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224F93Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F93C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F93C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F93C);
		  /* 8224F93Ch */ case    0:  		/* lbz R10, <#[R1 + 22]> */
		/* 8224F93Ch case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000016) );
		/* 8224F93Ch case    0:*/		return 0x8224F940;
		  /* 8224F940h */ case    1:  		/* stb R11, <#[R1 - 15]> */
		/* 8224F940h case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF1) );
		/* 8224F940h case    1:*/		return 0x8224F944;
		  /* 8224F944h */ case    2:  		/* cmplwi CR0, R10, 0 */
		/* 8224F944h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 8224F944h case    2:*/		return 0x8224F948;
		  /* 8224F948h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 8224F948h case    3:*/		if ( regs.CR[0].eq ) { return 0x8224F954;  }
		/* 8224F948h case    3:*/		return 0x8224F94C;
		  /* 8224F94Ch */ case    4:  		/* li R11, 0 */
		/* 8224F94Ch case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224F94Ch case    4:*/		return 0x8224F950;
		  /* 8224F950h */ case    5:  		/* b 8 */
		/* 8224F950h case    5:*/		return 0x8224F958;
		/* 8224F950h case    5:*/		return 0x8224F954;
	}
	return 0x8224F954;
} // Block from 8224F93Ch-8224F954h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224F954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F954);
		  /* 8224F954h */ case    0:  		/* lbz R11, <#[R1 + 30]> */
		/* 8224F954h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000001E) );
		/* 8224F954h case    0:*/		return 0x8224F958;
	}
	return 0x8224F958;
} // Block from 8224F954h-8224F958h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224F958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F958);
		  /* 8224F958h */ case    0:  		/* lbz R10, <#[R1 + 23]> */
		/* 8224F958h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000017) );
		/* 8224F958h case    0:*/		return 0x8224F95C;
		  /* 8224F95Ch */ case    1:  		/* stb R11, <#[R1 - 14]> */
		/* 8224F95Ch case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF2) );
		/* 8224F95Ch case    1:*/		return 0x8224F960;
		  /* 8224F960h */ case    2:  		/* cmplwi CR0, R10, 0 */
		/* 8224F960h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 8224F960h case    2:*/		return 0x8224F964;
		  /* 8224F964h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 8224F964h case    3:*/		if ( regs.CR[0].eq ) { return 0x8224F970;  }
		/* 8224F964h case    3:*/		return 0x8224F968;
		  /* 8224F968h */ case    4:  		/* li R11, 0 */
		/* 8224F968h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224F968h case    4:*/		return 0x8224F96C;
		  /* 8224F96Ch */ case    5:  		/* b 8 */
		/* 8224F96Ch case    5:*/		return 0x8224F974;
		/* 8224F96Ch case    5:*/		return 0x8224F970;
	}
	return 0x8224F970;
} // Block from 8224F958h-8224F970h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224F970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F970);
		  /* 8224F970h */ case    0:  		/* lbz R11, <#[R1 + 31]> */
		/* 8224F970h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000001F) );
		/* 8224F970h case    0:*/		return 0x8224F974;
	}
	return 0x8224F974;
} // Block from 8224F970h-8224F974h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224F974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F974);
		  /* 8224F974h */ case    0:  		/* stb R11, <#[R1 - 13]> */
		/* 8224F974h case    0:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF3) );
		/* 8224F974h case    0:*/		return 0x8224F978;
	}
	return 0x8224F978;
} // Block from 8224F974h-8224F978h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224F978h
// Function '?ScheduleInst@Scheduler@XGRAPHICS@@AAAXPAVSchedNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F978);
		  /* 8224F978h */ case    0:  		/* lwz R3, <#[R1 - 16]> */
		/* 8224F978h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224F978h case    0:*/		return 0x8224F97C;
		  /* 8224F97Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8224F97Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224F97Ch case    1:*/		return 0x8224F980;
	}
	return 0x8224F980;
} // Block from 8224F978h-8224F980h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224F980h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224F980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224F980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224F980);
		  /* 8224F980h */ case    0:  		/* stw R3, <#[R1 + 20]> */
		/* 8224F980h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000014) );
		/* 8224F980h case    0:*/		return 0x8224F984;
		  /* 8224F984h */ case    1:  		/* lis R10, -32216 */
		/* 8224F984h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8228);
		/* 8224F984h case    1:*/		return 0x8224F988;
		  /* 8224F988h */ case    2:  		/* lbz R8, <#[R1 + 20]> */
		/* 8224F988h case    2:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000014) );
		/* 8224F988h case    2:*/		return 0x8224F98C;
		  /* 8224F98Ch */ case    3:  		/* lbz R7, <#[R1 + 21]> */
		/* 8224F98Ch case    3:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000015) );
		/* 8224F98Ch case    3:*/		return 0x8224F990;
		  /* 8224F990h */ case    4:  		/* addi R10, R10, 11672 */
		/* 8224F990h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2D98);
		/* 8224F990h case    4:*/		return 0x8224F994;
		  /* 8224F994h */ case    5:  		/* stw R4, <#[R1 + 28]> */
		/* 8224F994h case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000001C) );
		/* 8224F994h case    5:*/		return 0x8224F998;
		  /* 8224F998h */ case    6:  		/* lbz R6, <#[R1 + 30]> */
		/* 8224F998h case    6:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000001E) );
		/* 8224F998h case    6:*/		return 0x8224F99C;
		  /* 8224F99Ch */ case    7:  		/* lbz R11, <#[R1 + 28]> */
		/* 8224F99Ch case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000001C) );
		/* 8224F99Ch case    7:*/		return 0x8224F9A0;
		  /* 8224F9A0h */ case    8:  		/* lbz R9, <#[R1 + 29]> */
		/* 8224F9A0h case    8:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000001D) );
		/* 8224F9A0h case    8:*/		return 0x8224F9A4;
		  /* 8224F9A4h */ case    9:  		/* rlwimi R9, R11, 1, 30, 30 */
		/* 8224F9A4h case    9:*/		cpu::op::rlwimi<0,1,30,30>(regs,&regs.R9,regs.R11);
		/* 8224F9A4h case    9:*/		return 0x8224F9A8;
		  /* 8224F9A8h */ case   10:  		/* lbz R11, <#[R1 + 31]> */
		/* 8224F9A8h case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000001F) );
		/* 8224F9A8h case   10:*/		return 0x8224F9AC;
		  /* 8224F9ACh */ case   11:  		/* rlwimi R7, R8, 1, 30, 30 */
		/* 8224F9ACh case   11:*/		cpu::op::rlwimi<0,1,30,30>(regs,&regs.R7,regs.R8);
		/* 8224F9ACh case   11:*/		return 0x8224F9B0;
		  /* 8224F9B0h */ case   12:  		/* lbz R5, <#[R1 + 23]> */
		/* 8224F9B0h case   12:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000017) );
		/* 8224F9B0h case   12:*/		return 0x8224F9B4;
		  /* 8224F9B4h */ case   13:  		/* rlwinm R9, R9, 0, 30, 31 */
		/* 8224F9B4h case   13:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R9,regs.R9);
		/* 8224F9B4h case   13:*/		return 0x8224F9B8;
		  /* 8224F9B8h */ case   14:  		/* rlwinm R7, R7, 0, 30, 31 */
		/* 8224F9B8h case   14:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R7,regs.R7);
		/* 8224F9B8h case   14:*/		return 0x8224F9BC;
		  /* 8224F9BCh */ case   15:  		/* lbz R8, <#[R1 + 22]> */
		/* 8224F9BCh case   15:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000016) );
		/* 8224F9BCh case   15:*/		return 0x8224F9C0;
		  /* 8224F9C0h */ case   16:  		/* rlwimi R6, R9, 1, 0, 30 */
		/* 8224F9C0h case   16:*/		cpu::op::rlwimi<0,1,0,30>(regs,&regs.R6,regs.R9);
		/* 8224F9C0h case   16:*/		return 0x8224F9C4;
		  /* 8224F9C4h */ case   17:  		/* rlwimi R8, R7, 1, 0, 30 */
		/* 8224F9C4h case   17:*/		cpu::op::rlwimi<0,1,0,30>(regs,&regs.R8,regs.R7);
		/* 8224F9C4h case   17:*/		return 0x8224F9C8;
		  /* 8224F9C8h */ case   18:  		/* rlwimi R11, R6, 1, 0, 30 */
		/* 8224F9C8h case   18:*/		cpu::op::rlwimi<0,1,0,30>(regs,&regs.R11,regs.R6);
		/* 8224F9C8h case   18:*/		return 0x8224F9CC;
		  /* 8224F9CCh */ case   19:  		/* rlwimi R5, R8, 1, 0, 30 */
		/* 8224F9CCh case   19:*/		cpu::op::rlwimi<0,1,0,30>(regs,&regs.R5,regs.R8);
		/* 8224F9CCh case   19:*/		return 0x8224F9D0;
		  /* 8224F9D0h */ case   20:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 8224F9D0h case   20:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 8224F9D0h case   20:*/		return 0x8224F9D4;
		  /* 8224F9D4h */ case   21:  		/* add R11, R11, R5 */
		/* 8224F9D4h case   21:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 8224F9D4h case   21:*/		return 0x8224F9D8;
		  /* 8224F9D8h */ case   22:  		/* lbzx R11, <#[R11 + R10]> */
		/* 8224F9D8h case   22:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8224F9D8h case   22:*/		return 0x8224F9DC;
		  /* 8224F9DCh */ case   23:  		/* rlwinm R10, R11, 29, 31, 31 */
		/* 8224F9DCh case   23:*/		cpu::op::rlwinm<0,29,31,31>(regs,&regs.R10,regs.R11);
		/* 8224F9DCh case   23:*/		return 0x8224F9E0;
		  /* 8224F9E0h */ case   24:  		/* rlwinm R9, R11, 30, 31, 31 */
		/* 8224F9E0h case   24:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R9,regs.R11);
		/* 8224F9E0h case   24:*/		return 0x8224F9E4;
		  /* 8224F9E4h */ case   25:  		/* rlwinm R8, R11, 31, 31, 31 */
		/* 8224F9E4h case   25:*/		cpu::op::rlwinm<0,31,31,31>(regs,&regs.R8,regs.R11);
		/* 8224F9E4h case   25:*/		return 0x8224F9E8;
		  /* 8224F9E8h */ case   26:  		/* stb R10, <#[R1 - 16]> */
		/* 8224F9E8h case   26:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224F9E8h case   26:*/		return 0x8224F9EC;
		  /* 8224F9ECh */ case   27:  		/* rlwinm R11, R11, 0, 31, 31 */
		/* 8224F9ECh case   27:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8224F9ECh case   27:*/		return 0x8224F9F0;
		  /* 8224F9F0h */ case   28:  		/* stb R9, <#[R1 - 15]> */
		/* 8224F9F0h case   28:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R1 + 0xFFFFFFF1) );
		/* 8224F9F0h case   28:*/		return 0x8224F9F4;
		  /* 8224F9F4h */ case   29:  		/* stb R8, <#[R1 - 14]> */
		/* 8224F9F4h case   29:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R1 + 0xFFFFFFF2) );
		/* 8224F9F4h case   29:*/		return 0x8224F9F8;
		  /* 8224F9F8h */ case   30:  		/* stb R11, <#[R1 - 13]> */
		/* 8224F9F8h case   30:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF3) );
		/* 8224F9F8h case   30:*/		return 0x8224F9FC;
		  /* 8224F9FCh */ case   31:  		/* lwz R3, <#[R1 - 16]> */
		/* 8224F9FCh case   31:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224F9FCh case   31:*/		return 0x8224FA00;
		  /* 8224FA00h */ case   32:  		/* bclr 20, CR0_LT */
		/* 8224FA00h case   32:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224FA00h case   32:*/		return 0x8224FA04;
	}
	return 0x8224FA04;
} // Block from 8224F980h-8224FA04h (33 instructions)

//////////////////////////////////////////////////////
// Block at 8224FA04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FA04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FA04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FA04);
		  /* 8224FA04h */ case    0:  		/* nop */
		/* 8224FA04h case    0:*/		cpu::op::nop();
		/* 8224FA04h case    0:*/		return 0x8224FA08;
	}
	return 0x8224FA08;
} // Block from 8224FA04h-8224FA08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224FA08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FA08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FA08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FA08);
		  /* 8224FA08h */ case    0:  		/* lwz R3, <#[R3 + 20]> */
		/* 8224FA08h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000014) );
		/* 8224FA08h case    0:*/		return 0x8224FA0C;
		  /* 8224FA0Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8224FA0Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224FA0Ch case    1:*/		return 0x8224FA10;
	}
	return 0x8224FA10;
} // Block from 8224FA08h-8224FA10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224FA10h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FA10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FA10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FA10);
		  /* 8224FA10h */ case    0:  		/* lwz R3, <#[R3 + 16]> */
		/* 8224FA10h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000010) );
		/* 8224FA10h case    0:*/		return 0x8224FA14;
		  /* 8224FA14h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8224FA14h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224FA14h case    1:*/		return 0x8224FA18;
	}
	return 0x8224FA18;
} // Block from 8224FA10h-8224FA18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224FA18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FA18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FA18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FA18);
		  /* 8224FA18h */ case    0:  		/* lis R11, -32253 */
		/* 8224FA18h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8224FA18h case    0:*/		return 0x8224FA1C;
		  /* 8224FA1Ch */ case    1:  		/* addi R3, R11, 8792 */
		/* 8224FA1Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x2258);
		/* 8224FA1Ch case    1:*/		return 0x8224FA20;
		  /* 8224FA20h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8224FA20h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224FA20h case    2:*/		return 0x8224FA24;
	}
	return 0x8224FA24;
} // Block from 8224FA18h-8224FA24h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224FA24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FA24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FA24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FA24);
		  /* 8224FA24h */ case    0:  		/* nop */
		/* 8224FA24h case    0:*/		cpu::op::nop();
		/* 8224FA24h case    0:*/		return 0x8224FA28;
	}
	return 0x8224FA28;
} // Block from 8224FA24h-8224FA28h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224FA28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FA28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FA28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FA28);
		  /* 8224FA28h */ case    0:  		/* lis R11, -32252 */
		/* 8224FA28h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224FA28h case    0:*/		return 0x8224FA2C;
		  /* 8224FA2Ch */ case    1:  		/* addi R3, R11, 16048 */
		/* 8224FA2Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x3EB0);
		/* 8224FA2Ch case    1:*/		return 0x8224FA30;
		  /* 8224FA30h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8224FA30h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224FA30h case    2:*/		return 0x8224FA34;
	}
	return 0x8224FA34;
} // Block from 8224FA28h-8224FA34h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224FA34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FA34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FA34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FA34);
		  /* 8224FA34h */ case    0:  		/* nop */
		/* 8224FA34h case    0:*/		cpu::op::nop();
		/* 8224FA34h case    0:*/		return 0x8224FA38;
	}
	return 0x8224FA38;
} // Block from 8224FA34h-8224FA38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224FA38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FA38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FA38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FA38);
		  /* 8224FA38h */ case    0:  		/* li R3, 3 */
		/* 8224FA38h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 8224FA38h case    0:*/		return 0x8224FA3C;
		  /* 8224FA3Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8224FA3Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224FA3Ch case    1:*/		return 0x8224FA40;
	}
	return 0x8224FA40;
} // Block from 8224FA38h-8224FA40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224FA40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FA40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FA40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FA40);
		  /* 8224FA40h */ case    0:  		/* addi R11, R4, 32 */
		/* 8224FA40h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x20);
		/* 8224FA40h case    0:*/		return 0x8224FA44;
		  /* 8224FA44h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8224FA44h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8224FA44h case    1:*/		return 0x8224FA48;
		  /* 8224FA48h */ case    2:  		/* add R11, R11, R5 */
		/* 8224FA48h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 8224FA48h case    2:*/		return 0x8224FA4C;
		  /* 8224FA4Ch */ case    3:  		/* stbx R6, <#[R11 + R3]> */
		/* 8224FA4Ch case    3:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8224FA4Ch case    3:*/		return 0x8224FA50;
		  /* 8224FA50h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8224FA50h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224FA50h case    4:*/		return 0x8224FA54;
	}
	return 0x8224FA54;
} // Block from 8224FA40h-8224FA54h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224FA54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FA54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FA54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FA54);
		  /* 8224FA54h */ case    0:  		/* nop */
		/* 8224FA54h case    0:*/		cpu::op::nop();
		/* 8224FA54h case    0:*/		return 0x8224FA58;
	}
	return 0x8224FA58;
} // Block from 8224FA54h-8224FA58h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224FA58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FA58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FA58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FA58);
		  /* 8224FA58h */ case    0:  		/* cmpwi CR6, R6, 4 */
		/* 8224FA58h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000004);
		/* 8224FA58h case    0:*/		return 0x8224FA5C;
		  /* 8224FA5Ch */ case    1:  		/* bc 12, CR6_LT, 48 */
		/* 8224FA5Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x8224FA8C;  }
		/* 8224FA5Ch case    1:*/		return 0x8224FA60;
		  /* 8224FA60h */ case    2:  		/* cmpwi CR6, R6, 5 */
		/* 8224FA60h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000005);
		/* 8224FA60h case    2:*/		return 0x8224FA64;
		  /* 8224FA64h */ case    3:  		/* bc 12, CR6_GT, 40 */
		/* 8224FA64h case    3:*/		if ( regs.CR[6].gt ) { return 0x8224FA8C;  }
		/* 8224FA64h case    3:*/		return 0x8224FA68;
		  /* 8224FA68h */ case    4:  		/* lis R11, -32252 */
		/* 8224FA68h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224FA68h case    4:*/		return 0x8224FA6C;
		  /* 8224FA6Ch */ case    5:  		/* lis R10, -32255 */
		/* 8224FA6Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8224FA6Ch case    5:*/		return 0x8224FA70;
		  /* 8224FA70h */ case    6:  		/* lis R9, -32253 */
		/* 8224FA70h case    6:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8224FA70h case    6:*/		return 0x8224FA74;
		  /* 8224FA74h */ case    7:  		/* addi R6, R11, 10440 */
		/* 8224FA74h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x28C8);
		/* 8224FA74h case    7:*/		return 0x8224FA78;
		  /* 8224FA78h */ case    8:  		/* addi R5, R10, 5216 */
		/* 8224FA78h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x1460);
		/* 8224FA78h case    8:*/		return 0x8224FA7C;
		  /* 8224FA7Ch */ case    9:  		/* addi R4, R9, 27460 */
		/* 8224FA7Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8224FA7Ch case    9:*/		return 0x8224FA80;
		  /* 8224FA80h */ case   10:  		/* li R7, 1686 */
		/* 8224FA80h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x696);
		/* 8224FA80h case   10:*/		return 0x8224FA84;
		  /* 8224FA84h */ case   11:  		/* li R3, 0 */
		/* 8224FA84h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224FA84h case   11:*/		return 0x8224FA88;
		  /* 8224FA88h */ case   12:  		/* b -1015424 */
		/* 8224FA88h case   12:*/		return 0x82157C08;
		/* 8224FA88h case   12:*/		return 0x8224FA8C;
	}
	return 0x8224FA8C;
} // Block from 8224FA58h-8224FA8Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224FA8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FA8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FA8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FA8C);
		  /* 8224FA8Ch */ case    0:  		/* addi R11, R4, 32 */
		/* 8224FA8Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x20);
		/* 8224FA8Ch case    0:*/		return 0x8224FA90;
		  /* 8224FA90h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8224FA90h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8224FA90h case    1:*/		return 0x8224FA94;
		  /* 8224FA94h */ case    2:  		/* add R11, R11, R5 */
		/* 8224FA94h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 8224FA94h case    2:*/		return 0x8224FA98;
		  /* 8224FA98h */ case    3:  		/* stbx R6, <#[R11 + R3]> */
		/* 8224FA98h case    3:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8224FA98h case    3:*/		return 0x8224FA9C;
		  /* 8224FA9Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 8224FA9Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224FA9Ch case    4:*/		return 0x8224FAA0;
	}
	return 0x8224FAA0;
} // Block from 8224FA8Ch-8224FAA0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224FAA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FAA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FAA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FAA0);
		  /* 8224FAA0h */ case    0:  		/* cmpwi CR6, R6, 4 */
		/* 8224FAA0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000004);
		/* 8224FAA0h case    0:*/		return 0x8224FAA4;
		  /* 8224FAA4h */ case    1:  		/* bc 12, CR6_LT, 48 */
		/* 8224FAA4h case    1:*/		if ( regs.CR[6].lt ) { return 0x8224FAD4;  }
		/* 8224FAA4h case    1:*/		return 0x8224FAA8;
		  /* 8224FAA8h */ case    2:  		/* cmpwi CR6, R6, 5 */
		/* 8224FAA8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000005);
		/* 8224FAA8h case    2:*/		return 0x8224FAAC;
		  /* 8224FAACh */ case    3:  		/* bc 12, CR6_GT, 40 */
		/* 8224FAACh case    3:*/		if ( regs.CR[6].gt ) { return 0x8224FAD4;  }
		/* 8224FAACh case    3:*/		return 0x8224FAB0;
		  /* 8224FAB0h */ case    4:  		/* lis R11, -32252 */
		/* 8224FAB0h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224FAB0h case    4:*/		return 0x8224FAB4;
		  /* 8224FAB4h */ case    5:  		/* lis R10, -32255 */
		/* 8224FAB4h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8224FAB4h case    5:*/		return 0x8224FAB8;
		  /* 8224FAB8h */ case    6:  		/* lis R9, -32253 */
		/* 8224FAB8h case    6:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8224FAB8h case    6:*/		return 0x8224FABC;
		  /* 8224FABCh */ case    7:  		/* addi R6, R11, 10440 */
		/* 8224FABCh case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x28C8);
		/* 8224FABCh case    7:*/		return 0x8224FAC0;
		  /* 8224FAC0h */ case    8:  		/* addi R5, R10, 5216 */
		/* 8224FAC0h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x1460);
		/* 8224FAC0h case    8:*/		return 0x8224FAC4;
		  /* 8224FAC4h */ case    9:  		/* addi R4, R9, 27460 */
		/* 8224FAC4h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8224FAC4h case    9:*/		return 0x8224FAC8;
		  /* 8224FAC8h */ case   10:  		/* li R7, 1699 */
		/* 8224FAC8h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x6A3);
		/* 8224FAC8h case   10:*/		return 0x8224FACC;
		  /* 8224FACCh */ case   11:  		/* li R3, 0 */
		/* 8224FACCh case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224FACCh case   11:*/		return 0x8224FAD0;
		  /* 8224FAD0h */ case   12:  		/* b -1015496 */
		/* 8224FAD0h case   12:*/		return 0x82157C08;
		/* 8224FAD0h case   12:*/		return 0x8224FAD4;
	}
	return 0x8224FAD4;
} // Block from 8224FAA0h-8224FAD4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224FAD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FAD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FAD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FAD4);
		  /* 8224FAD4h */ case    0:  		/* addi R11, R4, 32 */
		/* 8224FAD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x20);
		/* 8224FAD4h case    0:*/		return 0x8224FAD8;
		  /* 8224FAD8h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8224FAD8h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8224FAD8h case    1:*/		return 0x8224FADC;
		  /* 8224FADCh */ case    2:  		/* add R11, R11, R5 */
		/* 8224FADCh case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 8224FADCh case    2:*/		return 0x8224FAE0;
		  /* 8224FAE0h */ case    3:  		/* stbx R6, <#[R11 + R3]> */
		/* 8224FAE0h case    3:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8224FAE0h case    3:*/		return 0x8224FAE4;
		  /* 8224FAE4h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8224FAE4h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224FAE4h case    4:*/		return 0x8224FAE8;
	}
	return 0x8224FAE8;
} // Block from 8224FAD4h-8224FAE8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224FAE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FAE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FAE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FAE8);
		  /* 8224FAE8h */ case    0:  		/* addi R11, R4, 32 */
		/* 8224FAE8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x20);
		/* 8224FAE8h case    0:*/		return 0x8224FAEC;
		  /* 8224FAECh */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8224FAECh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8224FAECh case    1:*/		return 0x8224FAF0;
		  /* 8224FAF0h */ case    2:  		/* add R11, R11, R5 */
		/* 8224FAF0h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 8224FAF0h case    2:*/		return 0x8224FAF4;
		  /* 8224FAF4h */ case    3:  		/* lbzx R3, <#[R11 + R3]> */
		/* 8224FAF4h case    3:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8224FAF4h case    3:*/		return 0x8224FAF8;
		  /* 8224FAF8h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8224FAF8h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224FAF8h case    4:*/		return 0x8224FAFC;
	}
	return 0x8224FAFC;
} // Block from 8224FAE8h-8224FAFCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224FAFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FAFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FAFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FAFC);
		  /* 8224FAFCh */ case    0:  		/* nop */
		/* 8224FAFCh case    0:*/		cpu::op::nop();
		/* 8224FAFCh case    0:*/		return 0x8224FB00;
	}
	return 0x8224FB00;
} // Block from 8224FAFCh-8224FB00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224FB00h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FB00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FB00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FB00);
		  /* 8224FB00h */ case    0:  		/* mfspr R12, LR */
		/* 8224FB00h case    0:*/		regs.R12 = regs.LR;
		/* 8224FB00h case    0:*/		return 0x8224FB04;
		  /* 8224FB04h */ case    1:  		/* bl -1829080 */
		/* 8224FB04h case    1:*/		regs.LR = 0x8224FB08; return 0x8209122C;
		/* 8224FB04h case    1:*/		return 0x8224FB08;
		  /* 8224FB08h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 8224FB08h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 8224FB08h case    2:*/		return 0x8224FB0C;
		  /* 8224FB0Ch */ case    3:  		/* lwz R18, <#[R3 + 136]> */
		/* 8224FB0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R3 + 0x00000088) );
		/* 8224FB0Ch case    3:*/		return 0x8224FB10;
		  /* 8224FB10h */ case    4:  		/* mr R17, R3 */
		/* 8224FB10h case    4:*/		regs.R17 = regs.R3;
		/* 8224FB10h case    4:*/		return 0x8224FB14;
		  /* 8224FB14h */ case    5:  		/* li R20, 0 */
		/* 8224FB14h case    5:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 8224FB14h case    5:*/		return 0x8224FB18;
		  /* 8224FB18h */ case    6:  		/* lwz R11, <#[R18 + 8]> */
		/* 8224FB18h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000008) );
		/* 8224FB18h case    6:*/		return 0x8224FB1C;
		  /* 8224FB1Ch */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 8224FB1Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224FB1Ch case    7:*/		return 0x8224FB20;
		  /* 8224FB20h */ case    8:  		/* bc 12, CR6_EQ, 652 */
		/* 8224FB20h case    8:*/		if ( regs.CR[6].eq ) { return 0x8224FDAC;  }
		/* 8224FB20h case    8:*/		return 0x8224FB24;
		  /* 8224FB24h */ case    9:  		/* lis R11, -32216 */
		/* 8224FB24h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 8224FB24h case    9:*/		return 0x8224FB28;
		  /* 8224FB28h */ case   10:  		/* li R19, 1 */
		/* 8224FB28h case   10:*/		cpu::op::li<0>(regs,&regs.R19,0x1);
		/* 8224FB28h case   10:*/		return 0x8224FB2C;
		  /* 8224FB2Ch */ case   11:  		/* addi R22, R11, 17992 */
		/* 8224FB2Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R11,0x4648);
		/* 8224FB2Ch case   11:*/		return 0x8224FB30;
		  /* 8224FB30h */ case   12:  		/* lwz R31, <#[R18 + 28]> */
		/* 8224FB30h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R18 + 0x0000001C) );
		/* 8224FB30h case   12:*/		return 0x8224FB34;
		  /* 8224FB34h */ case   13:  		/* lwz R11, <#[R31 + 8]> */
		/* 8224FB34h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8224FB34h case   13:*/		return 0x8224FB38;
		  /* 8224FB38h */ case   14:  		/* b 8 */
		/* 8224FB38h case   14:*/		return 0x8224FB40;
		/* 8224FB38h case   14:*/		return 0x8224FB3C;
		  /* 8224FB3Ch */ case   15:  		/* lwz R11, <#[R11 + 8]> */
		/* 8224FB3Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8224FB3Ch case   15:*/		return 0x8224FB40;
	}
	return 0x8224FB40;
} // Block from 8224FB00h-8224FB40h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8224FB40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FB40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FB40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FB40);
		  /* 8224FB40h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 8224FB40h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224FB40h case    0:*/		return 0x8224FB44;
		  /* 8224FB44h */ case    1:  		/* bc 4, CR6_EQ, -8 */
		/* 8224FB44h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8224FB3C;  }
		/* 8224FB44h case    1:*/		return 0x8224FB48;
		  /* 8224FB48h */ case    2:  		/* addi R21, R31, 8 */
		/* 8224FB48h case    2:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R31,0x8);
		/* 8224FB48h case    2:*/		return 0x8224FB4C;
		  /* 8224FB4Ch */ case    3:  		/* lwz R11, <#[R21]> */
		/* 8224FB4Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 8224FB4Ch case    3:*/		return 0x8224FB50;
		  /* 8224FB50h */ case    4:  		/* b 552 */
		/* 8224FB50h case    4:*/		return 0x8224FD78;
		/* 8224FB50h case    4:*/		return 0x8224FB54;
		  /* 8224FB54h */ case    5:  		/* lwz R11, <#[R31 + 228]> */
		/* 8224FB54h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8224FB54h case    5:*/		return 0x8224FB58;
		  /* 8224FB58h */ case    6:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8224FB58h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8224FB58h case    6:*/		return 0x8224FB5C;
		  /* 8224FB5Ch */ case    7:  		/* bc 12, CR0_EQ, 528 */
		/* 8224FB5Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x8224FD6C;  }
		/* 8224FB5Ch case    7:*/		return 0x8224FB60;
		  /* 8224FB60h */ case    8:  		/* lwz R11, <#[R17 + 12]> */
		/* 8224FB60h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000000C) );
		/* 8224FB60h case    8:*/		return 0x8224FB64;
		  /* 8224FB64h */ case    9:  		/* lwz R11, <#[R11 + 2724]> */
		/* 8224FB64h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000AA4) );
		/* 8224FB64h case    9:*/		return 0x8224FB68;
		  /* 8224FB68h */ case   10:  		/* cmpw CR6, R20, R11 */
		/* 8224FB68h case   10:*/		cpu::op::cmpw<6>(regs,regs.R20,regs.R11);
		/* 8224FB68h case   10:*/		return 0x8224FB6C;
		  /* 8224FB6Ch */ case   11:  		/* bc 4, CR6_LT, 512 */
		/* 8224FB6Ch case   11:*/		if ( !regs.CR[6].lt ) { return 0x8224FD6C;  }
		/* 8224FB6Ch case   11:*/		return 0x8224FB70;
		  /* 8224FB70h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 8224FB70h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224FB70h case   12:*/		return 0x8224FB74;
		  /* 8224FB74h */ case   13:  		/* mr R3, R31 */
		/* 8224FB74h case   13:*/		regs.R3 = regs.R31;
		/* 8224FB74h case   13:*/		return 0x8224FB78;
	}
	return 0x8224FB78;
} // Block from 8224FB40h-8224FB78h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224FB78h
// Function '?ScheduleParallelGroup@Scheduler@XGRAPHICS@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FB78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FB78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FB78);
		  /* 8224FB78h */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 8224FB78h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8224FB78h case    0:*/		return 0x8224FB7C;
		  /* 8224FB7Ch */ case    1:  		/* mtspr CTR, R11 */
		/* 8224FB7Ch case    1:*/		regs.CTR = regs.R11;
		/* 8224FB7Ch case    1:*/		return 0x8224FB80;
		  /* 8224FB80h */ case    2:  		/* bcctrl 20, CR0_LT */
		/* 8224FB80h case    2:*/		if ( 1 ) { regs.LR = 0x8224FB84; return (uint32)regs.CTR; }
		/* 8224FB80h case    2:*/		return 0x8224FB84;
		  /* 8224FB84h */ case    3:  		/* lwz R11, <#[R31 + 24]> */
		/* 8224FB84h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8224FB84h case    3:*/		return 0x8224FB88;
		  /* 8224FB88h */ case    4:  		/* mr R25, R3 */
		/* 8224FB88h case    4:*/		regs.R25 = regs.R3;
		/* 8224FB88h case    4:*/		return 0x8224FB8C;
		  /* 8224FB8Ch */ case    5:  		/* li R24, 0 */
		/* 8224FB8Ch case    5:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 8224FB8Ch case    5:*/		return 0x8224FB90;
		  /* 8224FB90h */ case    6:  		/* mulli R10, R11, 52 */
		/* 8224FB90h case    6:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R11,0x34);
		/* 8224FB90h case    6:*/		return 0x8224FB94;
		  /* 8224FB94h */ case    7:  		/* lwzx R9, <#[R10 + R22]> */
		/* 8224FB94h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R22 + 0x00000000) );
		/* 8224FB94h case    7:*/		return 0x8224FB98;
		  /* 8224FB98h */ case    8:  		/* rlwinm. R9, R9, 31, 31, 31 */
		/* 8224FB98h case    8:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R9,regs.R9);
		/* 8224FB98h case    8:*/		return 0x8224FB9C;
		  /* 8224FB9Ch */ case    9:  		/* li R23, 0 */
		/* 8224FB9Ch case    9:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 8224FB9Ch case    9:*/		return 0x8224FBA0;
		  /* 8224FBA0h */ case   10:  		/* bc 12, CR0_EQ, 40 */
		/* 8224FBA0h case   10:*/		if ( regs.CR[0].eq ) { return 0x8224FBC8;  }
		/* 8224FBA0h case   10:*/		return 0x8224FBA4;
		  /* 8224FBA4h */ case   11:  		/* addi R9, R22, 4 */
		/* 8224FBA4h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R22,0x4);
		/* 8224FBA4h case   11:*/		return 0x8224FBA8;
		  /* 8224FBA8h */ case   12:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8224FBA8h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8224FBA8h case   12:*/		return 0x8224FBAC;
		  /* 8224FBACh */ case   13:  		/* cmpwi CR6, R10, 0 */
		/* 8224FBACh case   13:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8224FBACh case   13:*/		return 0x8224FBB0;
		  /* 8224FBB0h */ case   14:  		/* bc 12, CR6_EQ, 24 */
		/* 8224FBB0h case   14:*/		if ( regs.CR[6].eq ) { return 0x8224FBC8;  }
		/* 8224FBB0h case   14:*/		return 0x8224FBB4;
		  /* 8224FBB4h */ case   15:  		/* addi R10, R11, -18 */
		/* 8224FBB4h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFEE);
		/* 8224FBB4h case   15:*/		return 0x8224FBB8;
		  /* 8224FBB8h */ case   16:  		/* mr R11, R19 */
		/* 8224FBB8h case   16:*/		regs.R11 = regs.R19;
		/* 8224FBB8h case   16:*/		return 0x8224FBBC;
		  /* 8224FBBCh */ case   17:  		/* cntlzw R10, R10 */
		/* 8224FBBCh case   17:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 8224FBBCh case   17:*/		return 0x8224FBC0;
		  /* 8224FBC0h */ case   18:  		/* rlwinm R24, R10, 27, 31, 31 */
		/* 8224FBC0h case   18:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R24,regs.R10);
		/* 8224FBC0h case   18:*/		return 0x8224FBC4;
		  /* 8224FBC4h */ case   19:  		/* b 8 */
		/* 8224FBC4h case   19:*/		return 0x8224FBCC;
		/* 8224FBC4h case   19:*/		return 0x8224FBC8;
	}
	return 0x8224FBC8;
} // Block from 8224FB78h-8224FBC8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8224FBC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FBC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FBC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FBC8);
		  /* 8224FBC8h */ case    0:  		/* li R11, 0 */
		/* 8224FBC8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224FBC8h case    0:*/		return 0x8224FBCC;
	}
	return 0x8224FBCC;
} // Block from 8224FBC8h-8224FBCCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224FBCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FBCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FBCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FBCC);
		  /* 8224FBCCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8224FBCCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8224FBCCh case    0:*/		return 0x8224FBD0;
		  /* 8224FBD0h */ case    1:  		/* bc 12, CR0_EQ, 412 */
		/* 8224FBD0h case    1:*/		if ( regs.CR[0].eq ) { return 0x8224FD6C;  }
		/* 8224FBD0h case    1:*/		return 0x8224FBD4;
		  /* 8224FBD4h */ case    2:  		/* lwz R11, <#[R31 + 228]> */
		/* 8224FBD4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8224FBD4h case    2:*/		return 0x8224FBD8;
		  /* 8224FBD8h */ case    3:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 8224FBD8h case    3:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 8224FBD8h case    3:*/		return 0x8224FBDC;
		  /* 8224FBDCh */ case    4:  		/* bc 4, CR0_EQ, 400 */
		/* 8224FBDCh case    4:*/		if ( !regs.CR[0].eq ) { return 0x8224FD6C;  }
		/* 8224FBDCh case    4:*/		return 0x8224FBE0;
		  /* 8224FBE0h */ case    5:  		/* li R29, 0 */
		/* 8224FBE0h case    5:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8224FBE0h case    5:*/		return 0x8224FBE4;
		  /* 8224FBE4h */ case    6:  		/* li R27, -1 */
		/* 8224FBE4h case    6:*/		cpu::op::li<0>(regs,&regs.R27,0xFFFFFFFF);
		/* 8224FBE4h case    6:*/		return 0x8224FBE8;
		  /* 8224FBE8h */ case    7:  		/* li R26, -1 */
		/* 8224FBE8h case    7:*/		cpu::op::li<0>(regs,&regs.R26,0xFFFFFFFF);
		/* 8224FBE8h case    7:*/		return 0x8224FBEC;
		  /* 8224FBECh */ case    8:  		/* li R30, 0 */
		/* 8224FBECh case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8224FBECh case    8:*/		return 0x8224FBF0;
		  /* 8224FBF0h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 8224FBF0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224FBF0h case    9:*/		return 0x8224FBF4;
		  /* 8224FBF4h */ case   10:  		/* mr R5, R30 */
		/* 8224FBF4h case   10:*/		regs.R5 = regs.R30;
		/* 8224FBF4h case   10:*/		return 0x8224FBF8;
		  /* 8224FBF8h */ case   11:  		/* li R4, 0 */
		/* 8224FBF8h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8224FBF8h case   11:*/		return 0x8224FBFC;
		  /* 8224FBFCh */ case   12:  		/* mr R3, R31 */
		/* 8224FBFCh case   12:*/		regs.R3 = regs.R31;
		/* 8224FBFCh case   12:*/		return 0x8224FC00;
		  /* 8224FC00h */ case   13:  		/* lwz R11, <#[R11 + 80]> */
		/* 8224FC00h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 8224FC00h case   13:*/		return 0x8224FC04;
		  /* 8224FC04h */ case   14:  		/* mtspr CTR, R11 */
		/* 8224FC04h case   14:*/		regs.CTR = regs.R11;
		/* 8224FC04h case   14:*/		return 0x8224FC08;
		  /* 8224FC08h */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 8224FC08h case   15:*/		if ( 1 ) { regs.LR = 0x8224FC0C; return (uint32)regs.CTR; }
		/* 8224FC08h case   15:*/		return 0x8224FC0C;
		  /* 8224FC0Ch */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 8224FC0Ch case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8224FC0Ch case   16:*/		return 0x8224FC10;
		  /* 8224FC10h */ case   17:  		/* bc 4, CR0_EQ, 12 */
		/* 8224FC10h case   17:*/		if ( !regs.CR[0].eq ) { return 0x8224FC1C;  }
		/* 8224FC10h case   17:*/		return 0x8224FC14;
		  /* 8224FC14h */ case   18:  		/* slw R11, R19, R30 */
		/* 8224FC14h case   18:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R19,regs.R30);
		/* 8224FC14h case   18:*/		return 0x8224FC18;
		  /* 8224FC18h */ case   19:  		/* or R29, R11, R29 */
		/* 8224FC18h case   19:*/		cpu::op::or<0>(regs,&regs.R29,regs.R11,regs.R29);
		/* 8224FC18h case   19:*/		return 0x8224FC1C;
	}
	return 0x8224FC1C;
} // Block from 8224FBCCh-8224FC1Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 8224FC1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FC1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FC1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FC1C);
		  /* 8224FC1Ch */ case    0:  		/* addi R30, R30, 1 */
		/* 8224FC1Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8224FC1Ch case    0:*/		return 0x8224FC20;
		  /* 8224FC20h */ case    1:  		/* cmpwi CR6, R30, 4 */
		/* 8224FC20h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 8224FC20h case    1:*/		return 0x8224FC24;
		  /* 8224FC24h */ case    2:  		/* bc 12, CR6_LT, -52 */
		/* 8224FC24h case    2:*/		if ( regs.CR[6].lt ) { return 0x8224FBF0;  }
		/* 8224FC24h case    2:*/		return 0x8224FC28;
		  /* 8224FC28h */ case    3:  		/* mr R28, R19 */
		/* 8224FC28h case    3:*/		regs.R28 = regs.R19;
		/* 8224FC28h case    3:*/		return 0x8224FC2C;
		  /* 8224FC2Ch */ case    4:  		/* li R30, 0 */
		/* 8224FC2Ch case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8224FC2Ch case    4:*/		return 0x8224FC30;
		  /* 8224FC30h */ case    5:  		/* slw R11, R19, R30 */
		/* 8224FC30h case    5:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R19,regs.R30);
		/* 8224FC30h case    5:*/		return 0x8224FC34;
		  /* 8224FC34h */ case    6:  		/* and. R11, R11, R29 */
		/* 8224FC34h case    6:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8224FC34h case    6:*/		return 0x8224FC38;
		  /* 8224FC38h */ case    7:  		/* bc 12, CR0_EQ, 164 */
		/* 8224FC38h case    7:*/		if ( regs.CR[0].eq ) { return 0x8224FCDC;  }
		/* 8224FC38h case    7:*/		return 0x8224FC3C;
		  /* 8224FC3Ch */ case    8:  		/* cmpwi CR6, R27, 0 */
		/* 8224FC3Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 8224FC3Ch case    8:*/		return 0x8224FC40;
		  /* 8224FC40h */ case    9:  		/* bc 12, CR6_LT, 40 */
		/* 8224FC40h case    9:*/		if ( regs.CR[6].lt ) { return 0x8224FC68;  }
		/* 8224FC40h case    9:*/		return 0x8224FC44;
		  /* 8224FC44h */ case   10:  		/* lwz R11, <#[R31]> */
		/* 8224FC44h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224FC44h case   10:*/		return 0x8224FC48;
		  /* 8224FC48h */ case   11:  		/* mr R5, R30 */
		/* 8224FC48h case   11:*/		regs.R5 = regs.R30;
		/* 8224FC48h case   11:*/		return 0x8224FC4C;
		  /* 8224FC4Ch */ case   12:  		/* li R4, 1 */
		/* 8224FC4Ch case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224FC4Ch case   12:*/		return 0x8224FC50;
		  /* 8224FC50h */ case   13:  		/* mr R3, R31 */
		/* 8224FC50h case   13:*/		regs.R3 = regs.R31;
		/* 8224FC50h case   13:*/		return 0x8224FC54;
		  /* 8224FC54h */ case   14:  		/* lwz R11, <#[R11 + 80]> */
		/* 8224FC54h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 8224FC54h case   14:*/		return 0x8224FC58;
		  /* 8224FC58h */ case   15:  		/* mtspr CTR, R11 */
		/* 8224FC58h case   15:*/		regs.CTR = regs.R11;
		/* 8224FC58h case   15:*/		return 0x8224FC5C;
		  /* 8224FC5Ch */ case   16:  		/* bcctrl 20, CR0_LT */
		/* 8224FC5Ch case   16:*/		if ( 1 ) { regs.LR = 0x8224FC60; return (uint32)regs.CTR; }
		/* 8224FC5Ch case   16:*/		return 0x8224FC60;
		  /* 8224FC60h */ case   17:  		/* cmpw CR6, R27, R3 */
		/* 8224FC60h case   17:*/		cpu::op::cmpw<6>(regs,regs.R27,regs.R3);
		/* 8224FC60h case   17:*/		return 0x8224FC64;
		  /* 8224FC64h */ case   18:  		/* bc 4, CR6_EQ, 136 */
		/* 8224FC64h case   18:*/		if ( !regs.CR[6].eq ) { return 0x8224FCEC;  }
		/* 8224FC64h case   18:*/		return 0x8224FC68;
	}
	return 0x8224FC68;
} // Block from 8224FC1Ch-8224FC68h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8224FC68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FC68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FC68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FC68);
		  /* 8224FC68h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8224FC68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224FC68h case    0:*/		return 0x8224FC6C;
		  /* 8224FC6Ch */ case    1:  		/* mr R5, R30 */
		/* 8224FC6Ch case    1:*/		regs.R5 = regs.R30;
		/* 8224FC6Ch case    1:*/		return 0x8224FC70;
		  /* 8224FC70h */ case    2:  		/* li R4, 1 */
		/* 8224FC70h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224FC70h case    2:*/		return 0x8224FC74;
		  /* 8224FC74h */ case    3:  		/* mr R3, R31 */
		/* 8224FC74h case    3:*/		regs.R3 = regs.R31;
		/* 8224FC74h case    3:*/		return 0x8224FC78;
		  /* 8224FC78h */ case    4:  		/* lwz R11, <#[R11 + 80]> */
		/* 8224FC78h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 8224FC78h case    4:*/		return 0x8224FC7C;
		  /* 8224FC7Ch */ case    5:  		/* mtspr CTR, R11 */
		/* 8224FC7Ch case    5:*/		regs.CTR = regs.R11;
		/* 8224FC7Ch case    5:*/		return 0x8224FC80;
		  /* 8224FC80h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 8224FC80h case    6:*/		if ( 1 ) { regs.LR = 0x8224FC84; return (uint32)regs.CTR; }
		/* 8224FC80h case    6:*/		return 0x8224FC84;
		  /* 8224FC84h */ case    7:  		/* mr R27, R3 */
		/* 8224FC84h case    7:*/		regs.R27 = regs.R3;
		/* 8224FC84h case    7:*/		return 0x8224FC88;
		  /* 8224FC88h */ case    8:  		/* cmpwi CR6, R25, 2 */
		/* 8224FC88h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000002);
		/* 8224FC88h case    8:*/		return 0x8224FC8C;
		  /* 8224FC8Ch */ case    9:  		/* bc 4, CR6_EQ, 80 */
		/* 8224FC8Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x8224FCDC;  }
		/* 8224FC8Ch case    9:*/		return 0x8224FC90;
		  /* 8224FC90h */ case   10:  		/* cmpwi CR6, R26, 0 */
		/* 8224FC90h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 8224FC90h case   10:*/		return 0x8224FC94;
		  /* 8224FC94h */ case   11:  		/* bc 12, CR6_LT, 40 */
		/* 8224FC94h case   11:*/		if ( regs.CR[6].lt ) { return 0x8224FCBC;  }
		/* 8224FC94h case   11:*/		return 0x8224FC98;
		  /* 8224FC98h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 8224FC98h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224FC98h case   12:*/		return 0x8224FC9C;
		  /* 8224FC9Ch */ case   13:  		/* mr R5, R30 */
		/* 8224FC9Ch case   13:*/		regs.R5 = regs.R30;
		/* 8224FC9Ch case   13:*/		return 0x8224FCA0;
		  /* 8224FCA0h */ case   14:  		/* li R4, 2 */
		/* 8224FCA0h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8224FCA0h case   14:*/		return 0x8224FCA4;
		  /* 8224FCA4h */ case   15:  		/* mr R3, R31 */
		/* 8224FCA4h case   15:*/		regs.R3 = regs.R31;
		/* 8224FCA4h case   15:*/		return 0x8224FCA8;
		  /* 8224FCA8h */ case   16:  		/* lwz R11, <#[R11 + 80]> */
		/* 8224FCA8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 8224FCA8h case   16:*/		return 0x8224FCAC;
		  /* 8224FCACh */ case   17:  		/* mtspr CTR, R11 */
		/* 8224FCACh case   17:*/		regs.CTR = regs.R11;
		/* 8224FCACh case   17:*/		return 0x8224FCB0;
	}
	return 0x8224FCB0;
} // Block from 8224FC68h-8224FCB0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8224FCB0h
// Function '?ScheduleBlock@Scheduler@XGRAPHICS@@AAAXPAVBlock@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FCB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FCB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FCB0);
		  /* 8224FCB0h */ case    0:  		/* bcctrl 20, CR0_LT */
		/* 8224FCB0h case    0:*/		if ( 1 ) { regs.LR = 0x8224FCB4; return (uint32)regs.CTR; }
		/* 8224FCB0h case    0:*/		return 0x8224FCB4;
		  /* 8224FCB4h */ case    1:  		/* cmpw CR6, R26, R3 */
		/* 8224FCB4h case    1:*/		cpu::op::cmpw<6>(regs,regs.R26,regs.R3);
		/* 8224FCB4h case    1:*/		return 0x8224FCB8;
		  /* 8224FCB8h */ case    2:  		/* bc 4, CR6_EQ, 52 */
		/* 8224FCB8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224FCEC;  }
		/* 8224FCB8h case    2:*/		return 0x8224FCBC;
	}
	return 0x8224FCBC;
} // Block from 8224FCB0h-8224FCBCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224FCBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FCBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FCBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FCBC);
		  /* 8224FCBCh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8224FCBCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224FCBCh case    0:*/		return 0x8224FCC0;
		  /* 8224FCC0h */ case    1:  		/* mr R5, R30 */
		/* 8224FCC0h case    1:*/		regs.R5 = regs.R30;
		/* 8224FCC0h case    1:*/		return 0x8224FCC4;
		  /* 8224FCC4h */ case    2:  		/* li R4, 2 */
		/* 8224FCC4h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8224FCC4h case    2:*/		return 0x8224FCC8;
		  /* 8224FCC8h */ case    3:  		/* mr R3, R31 */
		/* 8224FCC8h case    3:*/		regs.R3 = regs.R31;
		/* 8224FCC8h case    3:*/		return 0x8224FCCC;
		  /* 8224FCCCh */ case    4:  		/* lwz R11, <#[R11 + 80]> */
		/* 8224FCCCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 8224FCCCh case    4:*/		return 0x8224FCD0;
		  /* 8224FCD0h */ case    5:  		/* mtspr CTR, R11 */
		/* 8224FCD0h case    5:*/		regs.CTR = regs.R11;
		/* 8224FCD0h case    5:*/		return 0x8224FCD4;
		  /* 8224FCD4h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 8224FCD4h case    6:*/		if ( 1 ) { regs.LR = 0x8224FCD8; return (uint32)regs.CTR; }
		/* 8224FCD4h case    6:*/		return 0x8224FCD8;
		  /* 8224FCD8h */ case    7:  		/* mr R26, R3 */
		/* 8224FCD8h case    7:*/		regs.R26 = regs.R3;
		/* 8224FCD8h case    7:*/		return 0x8224FCDC;
	}
	return 0x8224FCDC;
} // Block from 8224FCBCh-8224FCDCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224FCDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FCDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FCDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FCDC);
		  /* 8224FCDCh */ case    0:  		/* addi R30, R30, 1 */
		/* 8224FCDCh case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8224FCDCh case    0:*/		return 0x8224FCE0;
		  /* 8224FCE0h */ case    1:  		/* cmpwi CR6, R30, 4 */
		/* 8224FCE0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 8224FCE0h case    1:*/		return 0x8224FCE4;
		  /* 8224FCE4h */ case    2:  		/* bc 12, CR6_LT, -180 */
		/* 8224FCE4h case    2:*/		if ( regs.CR[6].lt ) { return 0x8224FC30;  }
		/* 8224FCE4h case    2:*/		return 0x8224FCE8;
		  /* 8224FCE8h */ case    3:  		/* b 8 */
		/* 8224FCE8h case    3:*/		return 0x8224FCF0;
		/* 8224FCE8h case    3:*/		return 0x8224FCEC;
	}
	return 0x8224FCEC;
} // Block from 8224FCDCh-8224FCECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224FCECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FCEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FCEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FCEC);
		  /* 8224FCECh */ case    0:  		/* li R28, 0 */
		/* 8224FCECh case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8224FCECh case    0:*/		return 0x8224FCF0;
	}
	return 0x8224FCF0;
} // Block from 8224FCECh-8224FCF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224FCF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FCF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FCF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FCF0);
		  /* 8224FCF0h */ case    0:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 8224FCF0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 8224FCF0h case    0:*/		return 0x8224FCF4;
		  /* 8224FCF4h */ case    1:  		/* bc 12, CR0_EQ, 120 */
		/* 8224FCF4h case    1:*/		if ( regs.CR[0].eq ) { return 0x8224FD6C;  }
		/* 8224FCF4h case    1:*/		return 0x8224FCF8;
		  /* 8224FCF8h */ case    2:  		/* cmpwi CR6, R25, 2 */
		/* 8224FCF8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000002);
		/* 8224FCF8h case    2:*/		return 0x8224FCFC;
		  /* 8224FCFCh */ case    3:  		/* bc 4, CR6_EQ, 88 */
		/* 8224FCFCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x8224FD54;  }
		/* 8224FCFCh case    3:*/		return 0x8224FD00;
		  /* 8224FD00h */ case    4:  		/* lwz R11, <#[R31 + 240]> */
		/* 8224FD00h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000F0) );
		/* 8224FD00h case    4:*/		return 0x8224FD04;
		  /* 8224FD04h */ case    5:  		/* lwz R10, <#[R31 + 236]> */
		/* 8224FD04h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000EC) );
		/* 8224FD04h case    5:*/		return 0x8224FD08;
		  /* 8224FD08h */ case    6:  		/* cmpw CR6, R10, R11 */
		/* 8224FD08h case    6:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 8224FD08h case    6:*/		return 0x8224FD0C;
		  /* 8224FD0Ch */ case    7:  		/* bc 4, CR6_EQ, 36 */
		/* 8224FD0Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x8224FD30;  }
		/* 8224FD0Ch case    7:*/		return 0x8224FD10;
		  /* 8224FD10h */ case    8:  		/* lbz R9, <#[R31 + 154]> */
		/* 8224FD10h case    8:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000009A) );
		/* 8224FD10h case    8:*/		return 0x8224FD14;
		  /* 8224FD14h */ case    9:  		/* lbz R8, <#[R31 + 153]> */
		/* 8224FD14h case    9:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000099) );
		/* 8224FD14h case    9:*/		return 0x8224FD18;
		  /* 8224FD18h */ case   10:  		/* cmplw CR6, R8, R9 */
		/* 8224FD18h case   10:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8224FD18h case   10:*/		return 0x8224FD1C;
		  /* 8224FD1Ch */ case   11:  		/* bc 4, CR6_EQ, 20 */
		/* 8224FD1Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x8224FD30;  }
		/* 8224FD1Ch case   11:*/		return 0x8224FD20;
		  /* 8224FD20h */ case   12:  		/* lbz R9, <#[R31 + 160]> */
		/* 8224FD20h case   12:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R31 + 0x000000A0) );
		/* 8224FD20h case   12:*/		return 0x8224FD24;
		  /* 8224FD24h */ case   13:  		/* lbz R8, <#[R31 + 159]> */
		/* 8224FD24h case   13:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000009F) );
		/* 8224FD24h case   13:*/		return 0x8224FD28;
		  /* 8224FD28h */ case   14:  		/* cmplw CR6, R8, R9 */
		/* 8224FD28h case   14:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8224FD28h case   14:*/		return 0x8224FD2C;
		  /* 8224FD2Ch */ case   15:  		/* bc 12, CR6_EQ, 40 */
		/* 8224FD2Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x8224FD54;  }
		/* 8224FD2Ch case   15:*/		return 0x8224FD30;
	}
	return 0x8224FD30;
} // Block from 8224FCF0h-8224FD30h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8224FD30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FD30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FD30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FD30);
		  /* 8224FD30h */ case    0:  		/* rlwinm. R9, R24, 0, 24, 31 */
		/* 8224FD30h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R24);
		/* 8224FD30h case    0:*/		return 0x8224FD34;
		  /* 8224FD34h */ case    1:  		/* bc 12, CR0_EQ, 56 */
		/* 8224FD34h case    1:*/		if ( regs.CR[0].eq ) { return 0x8224FD6C;  }
		/* 8224FD34h case    1:*/		return 0x8224FD38;
		  /* 8224FD38h */ case    2:  		/* cmpw CR6, R10, R11 */
		/* 8224FD38h case    2:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 8224FD38h case    2:*/		return 0x8224FD3C;
		  /* 8224FD3Ch */ case    3:  		/* bc 4, CR6_EQ, 48 */
		/* 8224FD3Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8224FD6C;  }
		/* 8224FD3Ch case    3:*/		return 0x8224FD40;
		  /* 8224FD40h */ case    4:  		/* lbz R11, <#[R31 + 160]> */
		/* 8224FD40h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000A0) );
		/* 8224FD40h case    4:*/		return 0x8224FD44;
		  /* 8224FD44h */ case    5:  		/* lbz R10, <#[R31 + 159]> */
		/* 8224FD44h case    5:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000009F) );
		/* 8224FD44h case    5:*/		return 0x8224FD48;
		  /* 8224FD48h */ case    6:  		/* cmplw CR6, R10, R11 */
		/* 8224FD48h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8224FD48h case    6:*/		return 0x8224FD4C;
		  /* 8224FD4Ch */ case    7:  		/* bc 4, CR6_EQ, 32 */
		/* 8224FD4Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x8224FD6C;  }
		/* 8224FD4Ch case    7:*/		return 0x8224FD50;
		  /* 8224FD50h */ case    8:  		/* mr R23, R19 */
		/* 8224FD50h case    8:*/		regs.R23 = regs.R19;
		/* 8224FD50h case    8:*/		return 0x8224FD54;
	}
	return 0x8224FD54;
} // Block from 8224FD30h-8224FD54h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224FD54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FD54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FD54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FD54);
		  /* 8224FD54h */ case    0:  		/* mr R6, R23 */
		/* 8224FD54h case    0:*/		regs.R6 = regs.R23;
		/* 8224FD54h case    0:*/		return 0x8224FD58;
		  /* 8224FD58h */ case    1:  		/* mr R5, R26 */
		/* 8224FD58h case    1:*/		regs.R5 = regs.R26;
		/* 8224FD58h case    1:*/		return 0x8224FD5C;
		  /* 8224FD5Ch */ case    2:  		/* mr R4, R27 */
		/* 8224FD5Ch case    2:*/		regs.R4 = regs.R27;
		/* 8224FD5Ch case    2:*/		return 0x8224FD60;
		  /* 8224FD60h */ case    3:  		/* mr R3, R31 */
		/* 8224FD60h case    3:*/		regs.R3 = regs.R31;
		/* 8224FD60h case    3:*/		return 0x8224FD64;
		  /* 8224FD64h */ case    4:  		/* addi R20, R20, 1 */
		/* 8224FD64h case    4:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0x1);
		/* 8224FD64h case    4:*/		return 0x8224FD68;
		  /* 8224FD68h */ case    5:  		/* bl 28320 */
		/* 8224FD68h case    5:*/		regs.LR = 0x8224FD6C; return 0x82256C08;
		/* 8224FD68h case    5:*/		return 0x8224FD6C;
	}
	return 0x8224FD6C;
} // Block from 8224FD54h-8224FD6Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224FD6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FD6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FD6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FD6C);
		  /* 8224FD6Ch */ case    0:  		/* lwz R31, <#[R21]> */
		/* 8224FD6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R21 + 0x00000000) );
		/* 8224FD6Ch case    0:*/		return 0x8224FD70;
		  /* 8224FD70h */ case    1:  		/* addi R21, R31, 8 */
		/* 8224FD70h case    1:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R31,0x8);
		/* 8224FD70h case    1:*/		return 0x8224FD74;
		  /* 8224FD74h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 8224FD74h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8224FD74h case    2:*/		return 0x8224FD78;
	}
	return 0x8224FD78;
} // Block from 8224FD6Ch-8224FD78h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224FD78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FD78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FD78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FD78);
		  /* 8224FD78h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 8224FD78h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224FD78h case    0:*/		return 0x8224FD7C;
		  /* 8224FD7Ch */ case    1:  		/* bc 4, CR6_EQ, -552 */
		/* 8224FD7Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8224FB54;  }
		/* 8224FD7Ch case    1:*/		return 0x8224FD80;
		  /* 8224FD80h */ case    2:  		/* lwz R18, <#[R18 + 8]> */
		/* 8224FD80h case    2:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R18 + 0x00000008) );
		/* 8224FD80h case    2:*/		return 0x8224FD84;
		  /* 8224FD84h */ case    3:  		/* lwz R11, <#[R18 + 8]> */
		/* 8224FD84h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000008) );
		/* 8224FD84h case    3:*/		return 0x8224FD88;
		  /* 8224FD88h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 8224FD88h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224FD88h case    4:*/		return 0x8224FD8C;
		  /* 8224FD8Ch */ case    5:  		/* bc 4, CR6_EQ, -604 */
		/* 8224FD8Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x8224FB30;  }
		/* 8224FD8Ch case    5:*/		return 0x8224FD90;
		  /* 8224FD90h */ case    6:  		/* cmpwi CR6, R20, 0 */
		/* 8224FD90h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 8224FD90h case    6:*/		return 0x8224FD94;
		  /* 8224FD94h */ case    7:  		/* bc 4, CR6_GT, 24 */
		/* 8224FD94h case    7:*/		if ( !regs.CR[6].gt ) { return 0x8224FDAC;  }
		/* 8224FD94h case    7:*/		return 0x8224FD98;
		  /* 8224FD98h */ case    8:  		/* lis R11, -32252 */
		/* 8224FD98h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224FD98h case    8:*/		return 0x8224FD9C;
		  /* 8224FD9Ch */ case    9:  		/* lwz R3, <#[R17 + 12]> */
		/* 8224FD9Ch case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R17 + 0x0000000C) );
		/* 8224FD9Ch case    9:*/		return 0x8224FDA0;
		  /* 8224FDA0h */ case   10:  		/* mr R5, R20 */
		/* 8224FDA0h case   10:*/		regs.R5 = regs.R20;
		/* 8224FDA0h case   10:*/		return 0x8224FDA4;
		  /* 8224FDA4h */ case   11:  		/* addi R4, R11, 16160 */
		/* 8224FDA4h case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x3F20);
		/* 8224FDA4h case   11:*/		return 0x8224FDA8;
		  /* 8224FDA8h */ case   12:  		/* bl -207336 */
		/* 8224FDA8h case   12:*/		regs.LR = 0x8224FDAC; return 0x8221D3C0;
		/* 8224FDA8h case   12:*/		return 0x8224FDAC;
	}
	return 0x8224FDAC;
} // Block from 8224FD78h-8224FDACh (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224FDACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FDAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FDAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FDAC);
		  /* 8224FDACh */ case    0:  		/* addi R1, R1, 208 */
		/* 8224FDACh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 8224FDACh case    0:*/		return 0x8224FDB0;
		  /* 8224FDB0h */ case    1:  		/* b -1829684 */
		/* 8224FDB0h case    1:*/		return 0x8209127C;
		/* 8224FDB0h case    1:*/		return 0x8224FDB4;
		  /* 8224FDB4h */ case    2:  		/* nop */
		/* 8224FDB4h case    2:*/		cpu::op::nop();
		/* 8224FDB4h case    2:*/		return 0x8224FDB8;
	}
	return 0x8224FDB8;
} // Block from 8224FDACh-8224FDB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224FDB8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FDB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FDB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FDB8);
		  /* 8224FDB8h */ case    0:  		/* mfspr R12, LR */
		/* 8224FDB8h case    0:*/		regs.R12 = regs.LR;
		/* 8224FDB8h case    0:*/		return 0x8224FDBC;
		  /* 8224FDBCh */ case    1:  		/* bl -1829740 */
		/* 8224FDBCh case    1:*/		regs.LR = 0x8224FDC0; return 0x82091250;
		/* 8224FDBCh case    1:*/		return 0x8224FDC0;
		  /* 8224FDC0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 8224FDC0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 8224FDC0h case    2:*/		return 0x8224FDC4;
		  /* 8224FDC4h */ case    3:  		/* addi R11, R4, 32 */
		/* 8224FDC4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x20);
		/* 8224FDC4h case    3:*/		return 0x8224FDC8;
		  /* 8224FDC8h */ case    4:  		/* lwz R8, <#[R3 + 128]> */
		/* 8224FDC8h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000080) );
		/* 8224FDC8h case    4:*/		return 0x8224FDCC;
		  /* 8224FDCCh */ case    5:  		/* lwz R7, <#[R3 + 12]> */
		/* 8224FDCCh case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x0000000C) );
		/* 8224FDCCh case    5:*/		return 0x8224FDD0;
		  /* 8224FDD0h */ case    6:  		/* mr R31, R3 */
		/* 8224FDD0h case    6:*/		regs.R31 = regs.R3;
		/* 8224FDD0h case    6:*/		return 0x8224FDD4;
		  /* 8224FDD4h */ case    7:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8224FDD4h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8224FDD4h case    7:*/		return 0x8224FDD8;
		  /* 8224FDD8h */ case    8:  		/* li R11, 4 */
		/* 8224FDD8h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 8224FDD8h case    8:*/		return 0x8224FDDC;
		  /* 8224FDDCh */ case    9:  		/* mr R28, R4 */
		/* 8224FDDCh case    9:*/		regs.R28 = regs.R4;
		/* 8224FDDCh case    9:*/		return 0x8224FDE0;
		  /* 8224FDE0h */ case   10:  		/* mr R27, R5 */
		/* 8224FDE0h case   10:*/		regs.R27 = regs.R5;
		/* 8224FDE0h case   10:*/		return 0x8224FDE4;
		  /* 8224FDE4h */ case   11:  		/* stw R8, <#[R1 + 84]> */
		/* 8224FDE4h case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 8224FDE4h case   11:*/		return 0x8224FDE8;
		  /* 8224FDE8h */ case   12:  		/* li R10, 0 */
		/* 8224FDE8h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8224FDE8h case   12:*/		return 0x8224FDEC;
		  /* 8224FDECh */ case   13:  		/* stw R7, <#[R1 + 88]> */
		/* 8224FDECh case   13:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000058) );
		/* 8224FDECh case   13:*/		return 0x8224FDF0;
		  /* 8224FDF0h */ case   14:  		/* lwzx R29, <#[R9 + R3]> */
		/* 8224FDF0h case   14:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8224FDF0h case   14:*/		return 0x8224FDF4;
		  /* 8224FDF4h */ case   15:  		/* li R26, 1 */
		/* 8224FDF4h case   15:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 8224FDF4h case   15:*/		return 0x8224FDF8;
		  /* 8224FDF8h */ case   16:  		/* mtspr CTR, R11 */
		/* 8224FDF8h case   16:*/		regs.CTR = regs.R11;
		/* 8224FDF8h case   16:*/		return 0x8224FDFC;
		  /* 8224FDFCh */ case   17:  		/* stw R29, <#[R1 + 80]> */
		/* 8224FDFCh case   17:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 8224FDFCh case   17:*/		return 0x8224FE00;
		  /* 8224FE00h */ case   18:  		/* addi R11, R1, 88 */
		/* 8224FE00h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x58);
		/* 8224FE00h case   18:*/		return 0x8224FE04;
		  /* 8224FE04h */ case   19:  		/* lbzx R11, <#[R10 + R11]> */
		/* 8224FE04h case   19:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8224FE04h case   19:*/		return 0x8224FE08;
		  /* 8224FE08h */ case   20:  		/* cmplwi CR0, R11, 0 */
		/* 8224FE08h case   20:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224FE08h case   20:*/		return 0x8224FE0C;
		  /* 8224FE0Ch */ case   21:  		/* bc 12, CR0_EQ, 16 */
		/* 8224FE0Ch case   21:*/		if ( regs.CR[0].eq ) { return 0x8224FE1C;  }
		/* 8224FE0Ch case   21:*/		return 0x8224FE10;
		  /* 8224FE10h */ case   22:  		/* addi R11, R1, 84 */
		/* 8224FE10h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x54);
		/* 8224FE10h case   22:*/		return 0x8224FE14;
		  /* 8224FE14h */ case   23:  		/* lbzx R11, <#[R10 + R11]> */
		/* 8224FE14h case   23:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8224FE14h case   23:*/		return 0x8224FE18;
		  /* 8224FE18h */ case   24:  		/* b 8 */
		/* 8224FE18h case   24:*/		return 0x8224FE20;
		/* 8224FE18h case   24:*/		return 0x8224FE1C;
	}
	return 0x8224FE1C;
} // Block from 8224FDB8h-8224FE1Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 8224FE1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FE1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FE1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FE1C);
		  /* 8224FE1Ch */ case    0:  		/* mr R11, R26 */
		/* 8224FE1Ch case    0:*/		regs.R11 = regs.R26;
		/* 8224FE1Ch case    0:*/		return 0x8224FE20;
	}
	return 0x8224FE20;
} // Block from 8224FE1Ch-8224FE20h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224FE20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FE20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FE20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FE20);
		  /* 8224FE20h */ case    0:  		/* addi R9, R1, 84 */
		/* 8224FE20h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x54);
		/* 8224FE20h case    0:*/		return 0x8224FE24;
		  /* 8224FE24h */ case    1:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 8224FE24h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8224FE24h case    1:*/		return 0x8224FE28;
		  /* 8224FE28h */ case    2:  		/* stbx R11, <#[R10 + R9]> */
		/* 8224FE28h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8224FE28h case    2:*/		return 0x8224FE2C;
		  /* 8224FE2Ch */ case    3:  		/* addi R10, R10, 1 */
		/* 8224FE2Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8224FE2Ch case    3:*/		return 0x8224FE30;
		  /* 8224FE30h */ case    4:  		/* bc 16, CR0_LT, -48 */
		/* 8224FE30h case    4:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8224FE00;  }
		/* 8224FE30h case    4:*/		return 0x8224FE34;
		  /* 8224FE34h */ case    5:  		/* lwz R11, <#[R31]> */
		/* 8224FE34h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224FE34h case    5:*/		return 0x8224FE38;
		  /* 8224FE38h */ case    6:  		/* li R30, 0 */
		/* 8224FE38h case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8224FE38h case    6:*/		return 0x8224FE3C;
		  /* 8224FE3Ch */ case    7:  		/* mr R3, R31 */
		/* 8224FE3Ch case    7:*/		regs.R3 = regs.R31;
		/* 8224FE3Ch case    7:*/		return 0x8224FE40;
		  /* 8224FE40h */ case    8:  		/* stw R30, <#[R1 + 88]> */
		/* 8224FE40h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000058) );
		/* 8224FE40h case    8:*/		return 0x8224FE44;
		  /* 8224FE44h */ case    9:  		/* lwz R11, <#[R11 + 20]> */
		/* 8224FE44h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8224FE44h case    9:*/		return 0x8224FE48;
		  /* 8224FE48h */ case   10:  		/* mtspr CTR, R11 */
		/* 8224FE48h case   10:*/		regs.CTR = regs.R11;
		/* 8224FE48h case   10:*/		return 0x8224FE4C;
		  /* 8224FE4Ch */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 8224FE4Ch case   11:*/		if ( 1 ) { regs.LR = 0x8224FE50; return (uint32)regs.CTR; }
		/* 8224FE4Ch case   11:*/		return 0x8224FE50;
		  /* 8224FE50h */ case   12:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224FE50h case   12:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224FE50h case   12:*/		return 0x8224FE54;
		  /* 8224FE54h */ case   13:  		/* bc 12, CR0_EQ, 564 */
		/* 8224FE54h case   13:*/		if ( regs.CR[0].eq ) { return 0x82250088;  }
		/* 8224FE54h case   13:*/		return 0x8224FE58;
		  /* 8224FE58h */ case   14:  		/* lwz R11, <#[R31 + 24]> */
		/* 8224FE58h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8224FE58h case   14:*/		return 0x8224FE5C;
		  /* 8224FE5Ch */ case   15:  		/* lis R10, -32216 */
		/* 8224FE5Ch case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8228);
		/* 8224FE5Ch case   15:*/		return 0x8224FE60;
		  /* 8224FE60h */ case   16:  		/* addi R10, R10, 17992 */
		/* 8224FE60h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4648);
		/* 8224FE60h case   16:*/		return 0x8224FE64;
		  /* 8224FE64h */ case   17:  		/* mulli R9, R11, 52 */
		/* 8224FE64h case   17:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R11,0x34);
		/* 8224FE64h case   17:*/		return 0x8224FE68;
		  /* 8224FE68h */ case   18:  		/* lwzx R10, <#[R9 + R10]> */
		/* 8224FE68h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8224FE68h case   18:*/		return 0x8224FE6C;
		  /* 8224FE6Ch */ case   19:  		/* rlwinm. R10, R10, 30, 31, 31 */
		/* 8224FE6Ch case   19:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R10,regs.R10);
		/* 8224FE6Ch case   19:*/		return 0x8224FE70;
		  /* 8224FE70h */ case   20:  		/* bc 12, CR0_EQ, 156 */
		/* 8224FE70h case   20:*/		if ( regs.CR[0].eq ) { return 0x8224FF0C;  }
		/* 8224FE70h case   20:*/		return 0x8224FE74;
		  /* 8224FE74h */ case   21:  		/* lwz R11, <#[R31]> */
		/* 8224FE74h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224FE74h case   21:*/		return 0x8224FE78;
		  /* 8224FE78h */ case   22:  		/* mr R3, R31 */
		/* 8224FE78h case   22:*/		regs.R3 = regs.R31;
		/* 8224FE78h case   22:*/		return 0x8224FE7C;
		  /* 8224FE7Ch */ case   23:  		/* lwz R11, <#[R11 + 4]> */
		/* 8224FE7Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8224FE7Ch case   23:*/		return 0x8224FE80;
		  /* 8224FE80h */ case   24:  		/* mtspr CTR, R11 */
		/* 8224FE80h case   24:*/		regs.CTR = regs.R11;
		/* 8224FE80h case   24:*/		return 0x8224FE84;
		  /* 8224FE84h */ case   25:  		/* bcctrl 20, CR0_LT */
		/* 8224FE84h case   25:*/		if ( 1 ) { regs.LR = 0x8224FE88; return (uint32)regs.CTR; }
		/* 8224FE84h case   25:*/		return 0x8224FE88;
		  /* 8224FE88h */ case   26:  		/* cmpwi CR6, R3, 1 */
		/* 8224FE88h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8224FE88h case   26:*/		return 0x8224FE8C;
		  /* 8224FE8Ch */ case   27:  		/* bc 12, CR6_EQ, 120 */
		/* 8224FE8Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x8224FF04;  }
		/* 8224FE8Ch case   27:*/		return 0x8224FE90;
		  /* 8224FE90h */ case   28:  		/* cmpwi CR6, R3, 2 */
		/* 8224FE90h case   28:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 8224FE90h case   28:*/		return 0x8224FE94;
		  /* 8224FE94h */ case   29:  		/* bc 12, CR6_EQ, 36 */
		/* 8224FE94h case   29:*/		if ( regs.CR[6].eq ) { return 0x8224FEB8;  }
		/* 8224FE94h case   29:*/		return 0x8224FE98;
		  /* 8224FE98h */ case   30:  		/* lis R11, -32252 */
		/* 8224FE98h case   30:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224FE98h case   30:*/		return 0x8224FE9C;
		  /* 8224FE9Ch */ case   31:  		/* lis R10, -32255 */
		/* 8224FE9Ch case   31:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8224FE9Ch case   31:*/		return 0x8224FEA0;
		  /* 8224FEA0h */ case   32:  		/* lis R9, -32253 */
		/* 8224FEA0h case   32:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8224FEA0h case   32:*/		return 0x8224FEA4;
		  /* 8224FEA4h */ case   33:  		/* addi R6, R11, 16232 */
		/* 8224FEA4h case   33:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x3F68);
		/* 8224FEA4h case   33:*/		return 0x8224FEA8;
		  /* 8224FEA8h */ case   34:  		/* addi R5, R10, 5216 */
		/* 8224FEA8h case   34:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x1460);
		/* 8224FEA8h case   34:*/		return 0x8224FEAC;
		  /* 8224FEACh */ case   35:  		/* addi R4, R9, 27460 */
		/* 8224FEACh case   35:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8224FEACh case   35:*/		return 0x8224FEB0;
		  /* 8224FEB0h */ case   36:  		/* li R7, 639 */
		/* 8224FEB0h case   36:*/		cpu::op::li<0>(regs,&regs.R7,0x27F);
		/* 8224FEB0h case   36:*/		return 0x8224FEB4;
		  /* 8224FEB4h */ case   37:  		/* b 68 */
		/* 8224FEB4h case   37:*/		return 0x8224FEF8;
		/* 8224FEB4h case   37:*/		return 0x8224FEB8;
	}
	return 0x8224FEB8;
} // Block from 8224FE20h-8224FEB8h (38 instructions)

//////////////////////////////////////////////////////
// Block at 8224FEB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FEB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FEB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FEB8);
		  /* 8224FEB8h */ case    0:  		/* cmpwi CR6, R28, 1 */
		/* 8224FEB8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000001);
		/* 8224FEB8h case    0:*/		return 0x8224FEBC;
		  /* 8224FEBCh */ case    1:  		/* bc 12, CR6_EQ, 72 */
		/* 8224FEBCh case    1:*/		if ( regs.CR[6].eq ) { return 0x8224FF04;  }
		/* 8224FEBCh case    1:*/		return 0x8224FEC0;
		  /* 8224FEC0h */ case    2:  		/* lbz R11, <#[R1 + 80]> */
		/* 8224FEC0h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8224FEC0h case    2:*/		return 0x8224FEC4;
		  /* 8224FEC4h */ case    3:  		/* lis R10, -32252 */
		/* 8224FEC4h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224FEC4h case    3:*/		return 0x8224FEC8;
		  /* 8224FEC8h */ case    4:  		/* cmpwi CR6, R28, 2 */
		/* 8224FEC8h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000002);
		/* 8224FEC8h case    4:*/		return 0x8224FECC;
		  /* 8224FECCh */ case    5:  		/* rlwinm R11, R11, 2, 0, 31 */
		/* 8224FECCh case    5:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R11,regs.R11);
		/* 8224FECCh case    5:*/		return 0x8224FED0;
		  /* 8224FED0h */ case    6:  		/* addi R10, R10, 15916 */
		/* 8224FED0h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x3E2C);
		/* 8224FED0h case    6:*/		return 0x8224FED4;
		  /* 8224FED4h */ case    7:  		/* lwzx R30, <#[R11 + R10]> */
		/* 8224FED4h case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8224FED4h case    7:*/		return 0x8224FED8;
		  /* 8224FED8h */ case    8:  		/* bc 12, CR6_EQ, 720 */
		/* 8224FED8h case    8:*/		if ( regs.CR[6].eq ) { return 0x822501A8;  }
		/* 8224FED8h case    8:*/		return 0x8224FEDC;
		  /* 8224FEDCh */ case    9:  		/* lis R7, -32253 */
		/* 8224FEDCh case    9:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8203);
		/* 8224FEDCh case    9:*/		return 0x8224FEE0;
		  /* 8224FEE0h */ case   10:  		/* lis R9, -32252 */
		/* 8224FEE0h case   10:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 8224FEE0h case   10:*/		return 0x8224FEE4;
		  /* 8224FEE4h */ case   11:  		/* lis R8, -32255 */
		/* 8224FEE4h case   11:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8201);
		/* 8224FEE4h case   11:*/		return 0x8224FEE8;
		  /* 8224FEE8h */ case   12:  		/* addi R4, R7, 27460 */
		/* 8224FEE8h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R7,0x6B44);
		/* 8224FEE8h case   12:*/		return 0x8224FEEC;
		  /* 8224FEECh */ case   13:  		/* addi R6, R9, 16232 */
		/* 8224FEECh case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R9,0x3F68);
		/* 8224FEECh case   13:*/		return 0x8224FEF0;
		  /* 8224FEF0h */ case   14:  		/* addi R5, R8, 5216 */
		/* 8224FEF0h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R8,0x1460);
		/* 8224FEF0h case   14:*/		return 0x8224FEF4;
		  /* 8224FEF4h */ case   15:  		/* li R7, 635 */
		/* 8224FEF4h case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x27B);
		/* 8224FEF4h case   15:*/		return 0x8224FEF8;
	}
	return 0x8224FEF8;
} // Block from 8224FEB8h-8224FEF8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8224FEF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FEF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FEF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FEF8);
		  /* 8224FEF8h */ case    0:  		/* li R3, 0 */
		/* 8224FEF8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224FEF8h case    0:*/		return 0x8224FEFC;
		  /* 8224FEFCh */ case    1:  		/* bl -1016564 */
		/* 8224FEFCh case    1:*/		regs.LR = 0x8224FF00; return 0x82157C08;
		/* 8224FEFCh case    1:*/		return 0x8224FF00;
		  /* 8224FF00h */ case    2:  		/* b 680 */
		/* 8224FF00h case    2:*/		return 0x822501A8;
		/* 8224FF00h case    2:*/		return 0x8224FF04;
	}
	return 0x8224FF04;
} // Block from 8224FEF8h-8224FF04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224FF04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FF04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FF04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FF04);
		  /* 8224FF04h */ case    0:  		/* lbz R11, <#[R1 + 83]> */
		/* 8224FF04h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000053) );
		/* 8224FF04h case    0:*/		return 0x8224FF08;
		  /* 8224FF08h */ case    1:  		/* b 632 */
		/* 8224FF08h case    1:*/		return 0x82250180;
		/* 8224FF08h case    1:*/		return 0x8224FF0C;
	}
	return 0x8224FF0C;
} // Block from 8224FF04h-8224FF0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224FF0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FF0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FF0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FF0C);
		  /* 8224FF0Ch */ case    0:  		/* cmpwi CR6, R11, 28 */
		/* 8224FF0Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000001C);
		/* 8224FF0Ch case    0:*/		return 0x8224FF10;
		  /* 8224FF10h */ case    1:  		/* bc 12, CR6_EQ, 316 */
		/* 8224FF10h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225004C;  }
		/* 8224FF10h case    1:*/		return 0x8224FF14;
		  /* 8224FF14h */ case    2:  		/* cmpwi CR6, R11, 29 */
		/* 8224FF14h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000001D);
		/* 8224FF14h case    2:*/		return 0x8224FF18;
		  /* 8224FF18h */ case    3:  		/* bc 12, CR6_EQ, 248 */
		/* 8224FF18h case    3:*/		if ( regs.CR[6].eq ) { return 0x82250010;  }
		/* 8224FF18h case    3:*/		return 0x8224FF1C;
		  /* 8224FF1Ch */ case    4:  		/* cmpwi CR6, R11, 30 */
		/* 8224FF1Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000001E);
		/* 8224FF1Ch case    4:*/		return 0x8224FF20;
		  /* 8224FF20h */ case    5:  		/* bc 12, CR6_EQ, 180 */
		/* 8224FF20h case    5:*/		if ( regs.CR[6].eq ) { return 0x8224FFD4;  }
		/* 8224FF20h case    5:*/		return 0x8224FF24;
		  /* 8224FF24h */ case    6:  		/* cmpwi CR6, R11, 50 */
		/* 8224FF24h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000032);
		/* 8224FF24h case    6:*/		return 0x8224FF28;
		  /* 8224FF28h */ case    7:  		/* bc 12, CR6_EQ, 232 */
		/* 8224FF28h case    7:*/		if ( regs.CR[6].eq ) { return 0x82250010;  }
		/* 8224FF28h case    7:*/		return 0x8224FF2C;
		  /* 8224FF2Ch */ case    8:  		/* cmpwi CR6, R11, 133 */
		/* 8224FF2Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000085);
		/* 8224FF2Ch case    8:*/		return 0x8224FF30;
		  /* 8224FF30h */ case    9:  		/* bc 4, CR6_GT, 12 */
		/* 8224FF30h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8224FF3C;  }
		/* 8224FF30h case    9:*/		return 0x8224FF34;
		  /* 8224FF34h */ case   10:  		/* cmpwi CR6, R11, 135 */
		/* 8224FF34h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000087);
		/* 8224FF34h case   10:*/		return 0x8224FF38;
		  /* 8224FF38h */ case   11:  		/* bc 4, CR6_GT, 216 */
		/* 8224FF38h case   11:*/		if ( !regs.CR[6].gt ) { return 0x82250010;  }
		/* 8224FF38h case   11:*/		return 0x8224FF3C;
	}
	return 0x8224FF3C;
} // Block from 8224FF0Ch-8224FF3Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224FF3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FF3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FF3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FF3C);
		  /* 8224FF3Ch */ case    0:  		/* lbz R10, <#[R1 + 84]> */
		/* 8224FF3Ch case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 8224FF3Ch case    0:*/		return 0x8224FF40;
		  /* 8224FF40h */ case    1:  		/* lis R11, -32252 */
		/* 8224FF40h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224FF40h case    1:*/		return 0x8224FF44;
		  /* 8224FF44h */ case    2:  		/* addi R9, R11, 15916 */
		/* 8224FF44h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x3E2C);
		/* 8224FF44h case    2:*/		return 0x8224FF48;
		  /* 8224FF48h */ case    3:  		/* cmplwi CR0, R10, 0 */
		/* 8224FF48h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 8224FF48h case    3:*/		return 0x8224FF4C;
		  /* 8224FF4Ch */ case    4:  		/* bc 4, CR0_EQ, 20 */
		/* 8224FF4Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x8224FF60;  }
		/* 8224FF4Ch case    4:*/		return 0x8224FF50;
		  /* 8224FF50h */ case    5:  		/* lbz R11, <#[R1 + 80]> */
		/* 8224FF50h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8224FF50h case    5:*/		return 0x8224FF54;
		  /* 8224FF54h */ case    6:  		/* rlwinm R11, R11, 2, 0, 31 */
		/* 8224FF54h case    6:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R11,regs.R11);
		/* 8224FF54h case    6:*/		return 0x8224FF58;
		  /* 8224FF58h */ case    7:  		/* lwzx R10, <#[R11 + R9]> */
		/* 8224FF58h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8224FF58h case    7:*/		return 0x8224FF5C;
		  /* 8224FF5Ch */ case    8:  		/* b 8 */
		/* 8224FF5Ch case    8:*/		return 0x8224FF64;
		/* 8224FF5Ch case    8:*/		return 0x8224FF60;
	}
	return 0x8224FF60;
} // Block from 8224FF3Ch-8224FF60h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224FF60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FF60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FF60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FF60);
		  /* 8224FF60h */ case    0:  		/* li R10, 0 */
		/* 8224FF60h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8224FF60h case    0:*/		return 0x8224FF64;
	}
	return 0x8224FF64;
} // Block from 8224FF60h-8224FF64h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224FF64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FF64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FF64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FF64);
		  /* 8224FF64h */ case    0:  		/* lbz R11, <#[R1 + 85]> */
		/* 8224FF64h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000055) );
		/* 8224FF64h case    0:*/		return 0x8224FF68;
		  /* 8224FF68h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 8224FF68h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224FF68h case    1:*/		return 0x8224FF6C;
		  /* 8224FF6Ch */ case    2:  		/* bc 4, CR0_EQ, 20 */
		/* 8224FF6Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x8224FF80;  }
		/* 8224FF6Ch case    2:*/		return 0x8224FF70;
		  /* 8224FF70h */ case    3:  		/* lbz R11, <#[R1 + 81]> */
		/* 8224FF70h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000051) );
		/* 8224FF70h case    3:*/		return 0x8224FF74;
		  /* 8224FF74h */ case    4:  		/* rlwinm R11, R11, 2, 0, 31 */
		/* 8224FF74h case    4:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R11,regs.R11);
		/* 8224FF74h case    4:*/		return 0x8224FF78;
		  /* 8224FF78h */ case    5:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8224FF78h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8224FF78h case    5:*/		return 0x8224FF7C;
		  /* 8224FF7Ch */ case    6:  		/* b 8 */
		/* 8224FF7Ch case    6:*/		return 0x8224FF84;
		/* 8224FF7Ch case    6:*/		return 0x8224FF80;
	}
	return 0x8224FF80;
} // Block from 8224FF64h-8224FF80h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224FF80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FF80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FF80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FF80);
		  /* 8224FF80h */ case    0:  		/* li R11, 0 */
		/* 8224FF80h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224FF80h case    0:*/		return 0x8224FF84;
	}
	return 0x8224FF84;
} // Block from 8224FF80h-8224FF84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224FF84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FF84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FF84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FF84);
		  /* 8224FF84h */ case    0:  		/* lbz R8, <#[R1 + 86]> */
		/* 8224FF84h case    0:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000056) );
		/* 8224FF84h case    0:*/		return 0x8224FF88;
		  /* 8224FF88h */ case    1:  		/* or R10, R11, R10 */
		/* 8224FF88h case    1:*/		cpu::op::or<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 8224FF88h case    1:*/		return 0x8224FF8C;
		  /* 8224FF8Ch */ case    2:  		/* cmplwi CR0, R8, 0 */
		/* 8224FF8Ch case    2:*/		cpu::op::cmplwi<0>(regs,regs.R8,0x00000000);
		/* 8224FF8Ch case    2:*/		return 0x8224FF90;
		  /* 8224FF90h */ case    3:  		/* bc 4, CR0_EQ, 20 */
		/* 8224FF90h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8224FFA4;  }
		/* 8224FF90h case    3:*/		return 0x8224FF94;
		  /* 8224FF94h */ case    4:  		/* lbz R11, <#[R1 + 82]> */
		/* 8224FF94h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000052) );
		/* 8224FF94h case    4:*/		return 0x8224FF98;
		  /* 8224FF98h */ case    5:  		/* rlwinm R11, R11, 2, 0, 31 */
		/* 8224FF98h case    5:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R11,regs.R11);
		/* 8224FF98h case    5:*/		return 0x8224FF9C;
		  /* 8224FF9Ch */ case    6:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8224FF9Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8224FF9Ch case    6:*/		return 0x8224FFA0;
		  /* 8224FFA0h */ case    7:  		/* b 8 */
		/* 8224FFA0h case    7:*/		return 0x8224FFA8;
		/* 8224FFA0h case    7:*/		return 0x8224FFA4;
	}
	return 0x8224FFA4;
} // Block from 8224FF84h-8224FFA4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224FFA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FFA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FFA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FFA4);
		  /* 8224FFA4h */ case    0:  		/* li R11, 0 */
		/* 8224FFA4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224FFA4h case    0:*/		return 0x8224FFA8;
	}
	return 0x8224FFA8;
} // Block from 8224FFA4h-8224FFA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224FFA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FFA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FFA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FFA8);
		  /* 8224FFA8h */ case    0:  		/* lbz R8, <#[R1 + 87]> */
		/* 8224FFA8h case    0:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000057) );
		/* 8224FFA8h case    0:*/		return 0x8224FFAC;
		  /* 8224FFACh */ case    1:  		/* or R10, R11, R10 */
		/* 8224FFACh case    1:*/		cpu::op::or<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 8224FFACh case    1:*/		return 0x8224FFB0;
		  /* 8224FFB0h */ case    2:  		/* cmplwi CR0, R8, 0 */
		/* 8224FFB0h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R8,0x00000000);
		/* 8224FFB0h case    2:*/		return 0x8224FFB4;
		  /* 8224FFB4h */ case    3:  		/* bc 4, CR0_EQ, 20 */
		/* 8224FFB4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8224FFC8;  }
		/* 8224FFB4h case    3:*/		return 0x8224FFB8;
		  /* 8224FFB8h */ case    4:  		/* lbz R11, <#[R1 + 83]> */
		/* 8224FFB8h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000053) );
		/* 8224FFB8h case    4:*/		return 0x8224FFBC;
		  /* 8224FFBCh */ case    5:  		/* rlwinm R11, R11, 2, 0, 31 */
		/* 8224FFBCh case    5:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R11,regs.R11);
		/* 8224FFBCh case    5:*/		return 0x8224FFC0;
		  /* 8224FFC0h */ case    6:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8224FFC0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8224FFC0h case    6:*/		return 0x8224FFC4;
		  /* 8224FFC4h */ case    7:  		/* b 8 */
		/* 8224FFC4h case    7:*/		return 0x8224FFCC;
		/* 8224FFC4h case    7:*/		return 0x8224FFC8;
	}
	return 0x8224FFC8;
} // Block from 8224FFA8h-8224FFC8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224FFC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FFC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FFC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FFC8);
		  /* 8224FFC8h */ case    0:  		/* li R11, 0 */
		/* 8224FFC8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224FFC8h case    0:*/		return 0x8224FFCC;
	}
	return 0x8224FFCC;
} // Block from 8224FFC8h-8224FFCCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224FFCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FFCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FFCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FFCC);
		  /* 8224FFCCh */ case    0:  		/* or R30, R11, R10 */
		/* 8224FFCCh case    0:*/		cpu::op::or<0>(regs,&regs.R30,regs.R11,regs.R10);
		/* 8224FFCCh case    0:*/		return 0x8224FFD0;
		  /* 8224FFD0h */ case    1:  		/* b 472 */
		/* 8224FFD0h case    1:*/		return 0x822501A8;
		/* 8224FFD0h case    1:*/		return 0x8224FFD4;
	}
	return 0x8224FFD4;
} // Block from 8224FFCCh-8224FFD4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224FFD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224FFD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224FFD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224FFD4);
		  /* 8224FFD4h */ case    0:  		/* li R10, 2 */
		/* 8224FFD4h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 8224FFD4h case    0:*/		return 0x8224FFD8;
		  /* 8224FFD8h */ case    1:  		/* stw R29, <#[R1 + 88]> */
		/* 8224FFD8h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000058) );
		/* 8224FFD8h case    1:*/		return 0x8224FFDC;
		  /* 8224FFDCh */ case    2:  		/* li R30, 0 */
		/* 8224FFDCh case    2:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8224FFDCh case    2:*/		return 0x8224FFE0;
		  /* 8224FFE0h */ case    3:  		/* li R11, 0 */
		/* 8224FFE0h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224FFE0h case    3:*/		return 0x8224FFE4;
		  /* 8224FFE4h */ case    4:  		/* mtspr CTR, R10 */
		/* 8224FFE4h case    4:*/		regs.CTR = regs.R10;
		/* 8224FFE4h case    4:*/		return 0x8224FFE8;
		  /* 8224FFE8h */ case    5:  		/* lis R10, -32252 */
		/* 8224FFE8h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224FFE8h case    5:*/		return 0x8224FFEC;
		  /* 8224FFECh */ case    6:  		/* addi R10, R10, 15916 */
		/* 8224FFECh case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x3E2C);
		/* 8224FFECh case    6:*/		return 0x8224FFF0;
		  /* 8224FFF0h */ case    7:  		/* addi R9, R1, 88 */
		/* 8224FFF0h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x58);
		/* 8224FFF0h case    7:*/		return 0x8224FFF4;
		  /* 8224FFF4h */ case    8:  		/* lbzx R9, <#[R11 + R9]> */
		/* 8224FFF4h case    8:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8224FFF4h case    8:*/		return 0x8224FFF8;
		  /* 8224FFF8h */ case    9:  		/* addi R11, R11, 1 */
		/* 8224FFF8h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224FFF8h case    9:*/		return 0x8224FFFC;
		  /* 8224FFFCh */ case   10:  		/* rlwinm R9, R9, 2, 0, 31 */
		/* 8224FFFCh case   10:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R9,regs.R9);
		/* 8224FFFCh case   10:*/		return 0x82250000;
		  /* 82250000h */ case   11:  		/* lwzx R9, <#[R9 + R10]> */
		/* 82250000h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82250000h case   11:*/		return 0x82250004;
		  /* 82250004h */ case   12:  		/* or R30, R9, R30 */
		/* 82250004h case   12:*/		cpu::op::or<0>(regs,&regs.R30,regs.R9,regs.R30);
		/* 82250004h case   12:*/		return 0x82250008;
		  /* 82250008h */ case   13:  		/* bc 16, CR0_LT, -24 */
		/* 82250008h case   13:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8224FFF0;  }
		/* 82250008h case   13:*/		return 0x8225000C;
		  /* 8225000Ch */ case   14:  		/* b 412 */
		/* 8225000Ch case   14:*/		return 0x822501A8;
		/* 8225000Ch case   14:*/		return 0x82250010;
	}
	return 0x82250010;
} // Block from 8224FFD4h-82250010h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82250010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250010);
		  /* 82250010h */ case    0:  		/* li R10, 4 */
		/* 82250010h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 82250010h case    0:*/		return 0x82250014;
		  /* 82250014h */ case    1:  		/* stw R29, <#[R1 + 88]> */
		/* 82250014h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000058) );
		/* 82250014h case    1:*/		return 0x82250018;
		  /* 82250018h */ case    2:  		/* li R30, 0 */
		/* 82250018h case    2:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82250018h case    2:*/		return 0x8225001C;
		  /* 8225001Ch */ case    3:  		/* li R11, 0 */
		/* 8225001Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225001Ch case    3:*/		return 0x82250020;
		  /* 82250020h */ case    4:  		/* mtspr CTR, R10 */
		/* 82250020h case    4:*/		regs.CTR = regs.R10;
		/* 82250020h case    4:*/		return 0x82250024;
		  /* 82250024h */ case    5:  		/* lis R10, -32252 */
		/* 82250024h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82250024h case    5:*/		return 0x82250028;
		  /* 82250028h */ case    6:  		/* addi R10, R10, 15916 */
		/* 82250028h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x3E2C);
		/* 82250028h case    6:*/		return 0x8225002C;
		  /* 8225002Ch */ case    7:  		/* addi R9, R1, 88 */
		/* 8225002Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x58);
		/* 8225002Ch case    7:*/		return 0x82250030;
		  /* 82250030h */ case    8:  		/* lbzx R9, <#[R11 + R9]> */
		/* 82250030h case    8:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82250030h case    8:*/		return 0x82250034;
		  /* 82250034h */ case    9:  		/* addi R11, R11, 1 */
		/* 82250034h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82250034h case    9:*/		return 0x82250038;
	}
	return 0x82250038;
} // Block from 82250010h-82250038h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82250038h
// Function '?Run@Scheduler@XGRAPHICS@@QAAXPAVCFG@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250038);
		  /* 82250038h */ case    0:  		/* rlwinm R9, R9, 2, 0, 31 */
		/* 82250038h case    0:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R9,regs.R9);
		/* 82250038h case    0:*/		return 0x8225003C;
		  /* 8225003Ch */ case    1:  		/* lwzx R9, <#[R9 + R10]> */
		/* 8225003Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8225003Ch case    1:*/		return 0x82250040;
		  /* 82250040h */ case    2:  		/* or R30, R9, R30 */
		/* 82250040h case    2:*/		cpu::op::or<0>(regs,&regs.R30,regs.R9,regs.R30);
		/* 82250040h case    2:*/		return 0x82250044;
		  /* 82250044h */ case    3:  		/* bc 16, CR0_LT, -24 */
		/* 82250044h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8225002C;  }
		/* 82250044h case    3:*/		return 0x82250048;
		  /* 82250048h */ case    4:  		/* b 352 */
		/* 82250048h case    4:*/		return 0x822501A8;
		/* 82250048h case    4:*/		return 0x8225004C;
	}
	return 0x8225004C;
} // Block from 82250038h-8225004Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225004Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225004C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225004C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225004C);
		  /* 8225004Ch */ case    0:  		/* li R10, 3 */
		/* 8225004Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 8225004Ch case    0:*/		return 0x82250050;
		  /* 82250050h */ case    1:  		/* stw R29, <#[R1 + 88]> */
		/* 82250050h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000058) );
		/* 82250050h case    1:*/		return 0x82250054;
		  /* 82250054h */ case    2:  		/* li R30, 0 */
		/* 82250054h case    2:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82250054h case    2:*/		return 0x82250058;
		  /* 82250058h */ case    3:  		/* li R11, 0 */
		/* 82250058h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82250058h case    3:*/		return 0x8225005C;
		  /* 8225005Ch */ case    4:  		/* mtspr CTR, R10 */
		/* 8225005Ch case    4:*/		regs.CTR = regs.R10;
		/* 8225005Ch case    4:*/		return 0x82250060;
		  /* 82250060h */ case    5:  		/* lis R10, -32252 */
		/* 82250060h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82250060h case    5:*/		return 0x82250064;
		  /* 82250064h */ case    6:  		/* addi R10, R10, 15916 */
		/* 82250064h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x3E2C);
		/* 82250064h case    6:*/		return 0x82250068;
		  /* 82250068h */ case    7:  		/* addi R9, R1, 88 */
		/* 82250068h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x58);
		/* 82250068h case    7:*/		return 0x8225006C;
		  /* 8225006Ch */ case    8:  		/* lbzx R9, <#[R11 + R9]> */
		/* 8225006Ch case    8:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8225006Ch case    8:*/		return 0x82250070;
		  /* 82250070h */ case    9:  		/* addi R11, R11, 1 */
		/* 82250070h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82250070h case    9:*/		return 0x82250074;
		  /* 82250074h */ case   10:  		/* rlwinm R9, R9, 2, 0, 31 */
		/* 82250074h case   10:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R9,regs.R9);
		/* 82250074h case   10:*/		return 0x82250078;
		  /* 82250078h */ case   11:  		/* lwzx R9, <#[R9 + R10]> */
		/* 82250078h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82250078h case   11:*/		return 0x8225007C;
		  /* 8225007Ch */ case   12:  		/* or R30, R9, R30 */
		/* 8225007Ch case   12:*/		cpu::op::or<0>(regs,&regs.R30,regs.R9,regs.R30);
		/* 8225007Ch case   12:*/		return 0x82250080;
		  /* 82250080h */ case   13:  		/* bc 16, CR0_LT, -24 */
		/* 82250080h case   13:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82250068;  }
		/* 82250080h case   13:*/		return 0x82250084;
		  /* 82250084h */ case   14:  		/* b 292 */
		/* 82250084h case   14:*/		return 0x822501A8;
		/* 82250084h case   14:*/		return 0x82250088;
	}
	return 0x82250088;
} // Block from 8225004Ch-82250088h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82250088h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250088);
		  /* 82250088h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82250088h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82250088h case    0:*/		return 0x8225008C;
		  /* 8225008Ch */ case    1:  		/* mr R3, R31 */
		/* 8225008Ch case    1:*/		regs.R3 = regs.R31;
		/* 8225008Ch case    1:*/		return 0x82250090;
		  /* 82250090h */ case    2:  		/* lwz R11, <#[R11 + 32]> */
		/* 82250090h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 82250090h case    2:*/		return 0x82250094;
		  /* 82250094h */ case    3:  		/* mtspr CTR, R11 */
		/* 82250094h case    3:*/		regs.CTR = regs.R11;
		/* 82250094h case    3:*/		return 0x82250098;
		  /* 82250098h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 82250098h case    4:*/		if ( 1 ) { regs.LR = 0x8225009C; return (uint32)regs.CTR; }
		/* 82250098h case    4:*/		return 0x8225009C;
		  /* 8225009Ch */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225009Ch case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225009Ch case    5:*/		return 0x822500A0;
		  /* 822500A0h */ case    6:  		/* bc 12, CR0_EQ, 244 */
		/* 822500A0h case    6:*/		if ( regs.CR[0].eq ) { return 0x82250194;  }
		/* 822500A0h case    6:*/		return 0x822500A4;
		  /* 822500A4h */ case    7:  		/* lwz R10, <#[R31 + 176]> */
		/* 822500A4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000B0) );
		/* 822500A4h case    7:*/		return 0x822500A8;
		  /* 822500A8h */ case    8:  		/* lwz R11, <#[R27 + 88]> */
		/* 822500A8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000058) );
		/* 822500A8h case    8:*/		return 0x822500AC;
		  /* 822500ACh */ case    9:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 822500ACh case    9:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 822500ACh case    9:*/		return 0x822500B0;
		  /* 822500B0h */ case   10:  		/* add R11, R10, R11 */
		/* 822500B0h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 822500B0h case   10:*/		return 0x822500B4;
		  /* 822500B4h */ case   11:  		/* lwz R11, <#[R11 + 4]> */
		/* 822500B4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822500B4h case   11:*/		return 0x822500B8;
		  /* 822500B8h */ case   12:  		/* cmpwi CR6, R11, 1 */
		/* 822500B8h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 822500B8h case   12:*/		return 0x822500BC;
		  /* 822500BCh */ case   13:  		/* bc 12, CR6_EQ, 192 */
		/* 822500BCh case   13:*/		if ( regs.CR[6].eq ) { return 0x8225017C;  }
		/* 822500BCh case   13:*/		return 0x822500C0;
		  /* 822500C0h */ case   14:  		/* cmpwi CR6, R11, 2 */
		/* 822500C0h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 822500C0h case   14:*/		return 0x822500C4;
		  /* 822500C4h */ case   15:  		/* bc 12, CR6_EQ, 148 */
		/* 822500C4h case   15:*/		if ( regs.CR[6].eq ) { return 0x82250158;  }
		/* 822500C4h case   15:*/		return 0x822500C8;
		  /* 822500C8h */ case   16:  		/* cmpwi CR6, R11, 3 */
		/* 822500C8h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 822500C8h case   16:*/		return 0x822500CC;
		  /* 822500CCh */ case   17:  		/* bc 12, CR6_EQ, 88 */
		/* 822500CCh case   17:*/		if ( regs.CR[6].eq ) { return 0x82250124;  }
		/* 822500CCh case   17:*/		return 0x822500D0;
		  /* 822500D0h */ case   18:  		/* cmpwi CR6, R11, 4 */
		/* 822500D0h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 822500D0h case   18:*/		return 0x822500D4;
		  /* 822500D4h */ case   19:  		/* bc 12, CR6_EQ, 12 */
		/* 822500D4h case   19:*/		if ( regs.CR[6].eq ) { return 0x822500E0;  }
		/* 822500D4h case   19:*/		return 0x822500D8;
		  /* 822500D8h */ case   20:  		/* cmpwi CR6, R11, 5 */
		/* 822500D8h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000005);
		/* 822500D8h case   20:*/		return 0x822500DC;
		  /* 822500DCh */ case   21:  		/* bc 12, CR6_EQ, 124 */
		/* 822500DCh case   21:*/		if ( regs.CR[6].eq ) { return 0x82250158;  }
		/* 822500DCh case   21:*/		return 0x822500E0;
	}
	return 0x822500E0;
} // Block from 82250088h-822500E0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 822500E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822500E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822500E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822500E0);
		  /* 822500E0h */ case    0:  		/* lbz R11, <#[R1 + 82]> */
		/* 822500E0h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000052) );
		/* 822500E0h case    0:*/		return 0x822500E4;
		  /* 822500E4h */ case    1:  		/* lis R10, -32252 */
		/* 822500E4h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 822500E4h case    1:*/		return 0x822500E8;
		  /* 822500E8h */ case    2:  		/* lbz R9, <#[R1 + 81]> */
		/* 822500E8h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000051) );
		/* 822500E8h case    2:*/		return 0x822500EC;
		  /* 822500ECh */ case    3:  		/* lbz R8, <#[R1 + 80]> */
		/* 822500ECh case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 822500ECh case    3:*/		return 0x822500F0;
		  /* 822500F0h */ case    4:  		/* addi R10, R10, 15916 */
		/* 822500F0h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x3E2C);
		/* 822500F0h case    4:*/		return 0x822500F4;
		  /* 822500F4h */ case    5:  		/* rlwinm R11, R11, 2, 0, 31 */
		/* 822500F4h case    5:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R11,regs.R11);
		/* 822500F4h case    5:*/		return 0x822500F8;
		  /* 822500F8h */ case    6:  		/* lbz R7, <#[R1 + 83]> */
		/* 822500F8h case    6:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000053) );
		/* 822500F8h case    6:*/		return 0x822500FC;
		  /* 822500FCh */ case    7:  		/* rlwinm R9, R9, 2, 0, 31 */
		/* 822500FCh case    7:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R9,regs.R9);
		/* 822500FCh case    7:*/		return 0x82250100;
		  /* 82250100h */ case    8:  		/* rlwinm R8, R8, 2, 0, 31 */
		/* 82250100h case    8:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R8,regs.R8);
		/* 82250100h case    8:*/		return 0x82250104;
		  /* 82250104h */ case    9:  		/* rlwinm R7, R7, 2, 0, 31 */
		/* 82250104h case    9:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R7,regs.R7);
		/* 82250104h case    9:*/		return 0x82250108;
		  /* 82250108h */ case   10:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82250108h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82250108h case   10:*/		return 0x8225010C;
		  /* 8225010Ch */ case   11:  		/* lwzx R9, <#[R9 + R10]> */
		/* 8225010Ch case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8225010Ch case   11:*/		return 0x82250110;
		  /* 82250110h */ case   12:  		/* lwzx R8, <#[R8 + R10]> */
		/* 82250110h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 82250110h case   12:*/		return 0x82250114;
		  /* 82250114h */ case   13:  		/* or R11, R11, R9 */
		/* 82250114h case   13:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82250114h case   13:*/		return 0x82250118;
		  /* 82250118h */ case   14:  		/* lwzx R10, <#[R7 + R10]> */
		/* 82250118h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 82250118h case   14:*/		return 0x8225011C;
		  /* 8225011Ch */ case   15:  		/* or R11, R11, R8 */
		/* 8225011Ch case   15:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8225011Ch case   15:*/		return 0x82250120;
		  /* 82250120h */ case   16:  		/* b -340 */
		/* 82250120h case   16:*/		return 0x8224FFCC;
		/* 82250120h case   16:*/		return 0x82250124;
	}
	return 0x82250124;
} // Block from 822500E0h-82250124h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82250124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250124);
		  /* 82250124h */ case    0:  		/* lbz R11, <#[R1 + 82]> */
		/* 82250124h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000052) );
		/* 82250124h case    0:*/		return 0x82250128;
		  /* 82250128h */ case    1:  		/* lis R10, -32252 */
		/* 82250128h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82250128h case    1:*/		return 0x8225012C;
		  /* 8225012Ch */ case    2:  		/* lbz R9, <#[R1 + 81]> */
		/* 8225012Ch case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000051) );
		/* 8225012Ch case    2:*/		return 0x82250130;
		  /* 82250130h */ case    3:  		/* lbz R8, <#[R1 + 80]> */
		/* 82250130h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 82250130h case    3:*/		return 0x82250134;
		  /* 82250134h */ case    4:  		/* addi R10, R10, 15916 */
		/* 82250134h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x3E2C);
		/* 82250134h case    4:*/		return 0x82250138;
		  /* 82250138h */ case    5:  		/* rlwinm R11, R11, 2, 0, 31 */
		/* 82250138h case    5:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R11,regs.R11);
		/* 82250138h case    5:*/		return 0x8225013C;
		  /* 8225013Ch */ case    6:  		/* rlwinm R9, R9, 2, 0, 31 */
		/* 8225013Ch case    6:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R9,regs.R9);
		/* 8225013Ch case    6:*/		return 0x82250140;
		  /* 82250140h */ case    7:  		/* rlwinm R8, R8, 2, 0, 31 */
		/* 82250140h case    7:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R8,regs.R8);
		/* 82250140h case    7:*/		return 0x82250144;
		  /* 82250144h */ case    8:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82250144h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82250144h case    8:*/		return 0x82250148;
		  /* 82250148h */ case    9:  		/* lwzx R9, <#[R9 + R10]> */
		/* 82250148h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82250148h case    9:*/		return 0x8225014C;
		  /* 8225014Ch */ case   10:  		/* lwzx R10, <#[R8 + R10]> */
		/* 8225014Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 8225014Ch case   10:*/		return 0x82250150;
		  /* 82250150h */ case   11:  		/* or R11, R11, R9 */
		/* 82250150h case   11:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82250150h case   11:*/		return 0x82250154;
		  /* 82250154h */ case   12:  		/* b -392 */
		/* 82250154h case   12:*/		return 0x8224FFCC;
		/* 82250154h case   12:*/		return 0x82250158;
	}
	return 0x82250158;
} // Block from 82250124h-82250158h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82250158h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250158);
		  /* 82250158h */ case    0:  		/* lbz R11, <#[R1 + 81]> */
		/* 82250158h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000051) );
		/* 82250158h case    0:*/		return 0x8225015C;
		  /* 8225015Ch */ case    1:  		/* lis R10, -32252 */
		/* 8225015Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8225015Ch case    1:*/		return 0x82250160;
		  /* 82250160h */ case    2:  		/* lbz R9, <#[R1 + 80]> */
		/* 82250160h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 82250160h case    2:*/		return 0x82250164;
		  /* 82250164h */ case    3:  		/* addi R10, R10, 15916 */
		/* 82250164h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x3E2C);
		/* 82250164h case    3:*/		return 0x82250168;
		  /* 82250168h */ case    4:  		/* rlwinm R11, R11, 2, 0, 31 */
		/* 82250168h case    4:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R11,regs.R11);
		/* 82250168h case    4:*/		return 0x8225016C;
		  /* 8225016Ch */ case    5:  		/* rlwinm R9, R9, 2, 0, 31 */
		/* 8225016Ch case    5:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R9,regs.R9);
		/* 8225016Ch case    5:*/		return 0x82250170;
		  /* 82250170h */ case    6:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82250170h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82250170h case    6:*/		return 0x82250174;
		  /* 82250174h */ case    7:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82250174h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82250174h case    7:*/		return 0x82250178;
		  /* 82250178h */ case    8:  		/* b -428 */
		/* 82250178h case    8:*/		return 0x8224FFCC;
		/* 82250178h case    8:*/		return 0x8225017C;
	}
	return 0x8225017C;
} // Block from 82250158h-8225017Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225017Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225017C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225017C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225017C);
		  /* 8225017Ch */ case    0:  		/* lbz R11, <#[R1 + 80]> */
		/* 8225017Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8225017Ch case    0:*/		return 0x82250180;
	}
	return 0x82250180;
} // Block from 8225017Ch-82250180h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82250180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250180);
		  /* 82250180h */ case    0:  		/* lis R10, -32252 */
		/* 82250180h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82250180h case    0:*/		return 0x82250184;
		  /* 82250184h */ case    1:  		/* rlwinm R11, R11, 2, 0, 31 */
		/* 82250184h case    1:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R11,regs.R11);
		/* 82250184h case    1:*/		return 0x82250188;
		  /* 82250188h */ case    2:  		/* addi R10, R10, 15916 */
		/* 82250188h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x3E2C);
		/* 82250188h case    2:*/		return 0x8225018C;
		  /* 8225018Ch */ case    3:  		/* lwzx R30, <#[R11 + R10]> */
		/* 8225018Ch case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8225018Ch case    3:*/		return 0x82250190;
		  /* 82250190h */ case    4:  		/* b 24 */
		/* 82250190h case    4:*/		return 0x822501A8;
		/* 82250190h case    4:*/		return 0x82250194;
	}
	return 0x82250194;
} // Block from 82250180h-82250194h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82250194h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250194( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250194) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250194);
		  /* 82250194h */ case    0:  		/* stb R26, <#[R1 + 88]> */
		/* 82250194h case    0:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R1 + 0x00000058) );
		/* 82250194h case    0:*/		return 0x82250198;
		  /* 82250198h */ case    1:  		/* stb R26, <#[R1 + 89]> */
		/* 82250198h case    1:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R1 + 0x00000059) );
		/* 82250198h case    1:*/		return 0x8225019C;
		  /* 8225019Ch */ case    2:  		/* stb R26, <#[R1 + 90]> */
		/* 8225019Ch case    2:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R1 + 0x0000005A) );
		/* 8225019Ch case    2:*/		return 0x822501A0;
		  /* 822501A0h */ case    3:  		/* stb R26, <#[R1 + 91]> */
		/* 822501A0h case    3:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R1 + 0x0000005B) );
		/* 822501A0h case    3:*/		return 0x822501A4;
		  /* 822501A4h */ case    4:  		/* lwz R30, <#[R1 + 88]> */
		/* 822501A4h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000058) );
		/* 822501A4h case    4:*/		return 0x822501A8;
	}
	return 0x822501A8;
} // Block from 82250194h-822501A8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822501A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822501A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822501A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822501A8);
		  /* 822501A8h */ case    0:  		/* mr R3, R30 */
		/* 822501A8h case    0:*/		regs.R3 = regs.R30;
		/* 822501A8h case    0:*/		return 0x822501AC;
		  /* 822501ACh */ case    1:  		/* addi R1, R1, 160 */
		/* 822501ACh case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 822501ACh case    1:*/		return 0x822501B0;
		  /* 822501B0h */ case    2:  		/* b -1830672 */
		/* 822501B0h case    2:*/		return 0x820912A0;
		/* 822501B0h case    2:*/		return 0x822501B4;
		  /* 822501B4h */ case    3:  		/* nop */
		/* 822501B4h case    3:*/		cpu::op::nop();
		/* 822501B4h case    3:*/		return 0x822501B8;
	}
	return 0x822501B8;
} // Block from 822501A8h-822501B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822501B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822501B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822501B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822501B8);
		  /* 822501B8h */ case    0:  		/* mfspr R12, LR */
		/* 822501B8h case    0:*/		regs.R12 = regs.LR;
		/* 822501B8h case    0:*/		return 0x822501BC;
		  /* 822501BCh */ case    1:  		/* bl -1830756 */
		/* 822501BCh case    1:*/		regs.LR = 0x822501C0; return 0x82091258;
		/* 822501BCh case    1:*/		return 0x822501C0;
		  /* 822501C0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 822501C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822501C0h case    2:*/		return 0x822501C4;
		  /* 822501C4h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 822501C4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822501C4h case    3:*/		return 0x822501C8;
		  /* 822501C8h */ case    4:  		/* mr R31, R3 */
		/* 822501C8h case    4:*/		regs.R31 = regs.R3;
		/* 822501C8h case    4:*/		return 0x822501CC;
		  /* 822501CCh */ case    5:  		/* lwz R11, <#[R11 + 76]> */
		/* 822501CCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 822501CCh case    5:*/		return 0x822501D0;
		  /* 822501D0h */ case    6:  		/* mtspr CTR, R11 */
		/* 822501D0h case    6:*/		regs.CTR = regs.R11;
		/* 822501D0h case    6:*/		return 0x822501D4;
		  /* 822501D4h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 822501D4h case    7:*/		if ( 1 ) { regs.LR = 0x822501D8; return (uint32)regs.CTR; }
		/* 822501D4h case    7:*/		return 0x822501D8;
		  /* 822501D8h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822501D8h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822501D8h case    8:*/		return 0x822501DC;
		  /* 822501DCh */ case    9:  		/* bc 12, CR0_EQ, 212 */
		/* 822501DCh case    9:*/		if ( regs.CR[0].eq ) { return 0x822502B0;  }
		/* 822501DCh case    9:*/		return 0x822501E0;
		  /* 822501E0h */ case   10:  		/* lwz R11, <#[R31 + 228]> */
		/* 822501E0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 822501E0h case   10:*/		return 0x822501E4;
		  /* 822501E4h */ case   11:  		/* rlwinm. R11, R11, 23, 31, 31 */
		/* 822501E4h case   11:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R11,regs.R11);
		/* 822501E4h case   11:*/		return 0x822501E8;
		  /* 822501E8h */ case   12:  		/* bc 12, CR0_EQ, 200 */
		/* 822501E8h case   12:*/		if ( regs.CR[0].eq ) { return 0x822502B0;  }
		/* 822501E8h case   12:*/		return 0x822501EC;
		  /* 822501ECh */ case   13:  		/* lwz R29, <#[R31 + 240]> */
		/* 822501ECh case   13:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x000000F0) );
		/* 822501ECh case   13:*/		return 0x822501F0;
		  /* 822501F0h */ case   14:  		/* lis R11, -32252 */
		/* 822501F0h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822501F0h case   14:*/		return 0x822501F4;
		  /* 822501F4h */ case   15:  		/* lwz R28, <#[R31 + 236]> */
		/* 822501F4h case   15:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x000000EC) );
		/* 822501F4h case   15:*/		return 0x822501F8;
		  /* 822501F8h */ case   16:  		/* addi R30, R11, 15932 */
		/* 822501F8h case   16:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x3E3C);
		/* 822501F8h case   16:*/		return 0x822501FC;
		  /* 822501FCh */ case   17:  		/* lwz R11, <#[R31 + 128]> */
		/* 822501FCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 822501FCh case   17:*/		return 0x82250200;
		  /* 82250200h */ case   18:  		/* lwz R9, <#[R29 + 128]> */
		/* 82250200h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000080) );
		/* 82250200h case   18:*/		return 0x82250204;
		  /* 82250204h */ case   19:  		/* lwz R10, <#[R30 + 8]> */
		/* 82250204h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82250204h case   19:*/		return 0x82250208;
		  /* 82250208h */ case   20:  		/* stw R11, <#[R1 + 80]> */
		/* 82250208h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82250208h case   20:*/		return 0x8225020C;
		  /* 8225020Ch */ case   21:  		/* cmplw CR6, R11, R10 */
		/* 8225020Ch case   21:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8225020Ch case   21:*/		return 0x82250210;
		  /* 82250210h */ case   22:  		/* stw R9, <#[R1 + 84]> */
		/* 82250210h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 82250210h case   22:*/		return 0x82250214;
		  /* 82250214h */ case   23:  		/* bc 12, CR6_EQ, 156 */
		/* 82250214h case   23:*/		if ( regs.CR[6].eq ) { return 0x822502B0;  }
		/* 82250214h case   23:*/		return 0x82250218;
		  /* 82250218h */ case   24:  		/* lwz R11, <#[R28]> */
		/* 82250218h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82250218h case   24:*/		return 0x8225021C;
		  /* 8225021Ch */ case   25:  		/* mr R3, R28 */
		/* 8225021Ch case   25:*/		regs.R3 = regs.R28;
		/* 8225021Ch case   25:*/		return 0x82250220;
		  /* 82250220h */ case   26:  		/* lwz R11, <#[R11 + 64]> */
		/* 82250220h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000040) );
		/* 82250220h case   26:*/		return 0x82250224;
		  /* 82250224h */ case   27:  		/* mtspr CTR, R11 */
		/* 82250224h case   27:*/		regs.CTR = regs.R11;
		/* 82250224h case   27:*/		return 0x82250228;
		  /* 82250228h */ case   28:  		/* bcctrl 20, CR0_LT */
		/* 82250228h case   28:*/		if ( 1 ) { regs.LR = 0x8225022C; return (uint32)regs.CTR; }
		/* 82250228h case   28:*/		return 0x8225022C;
		  /* 8225022Ch */ case   29:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225022Ch case   29:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225022Ch case   29:*/		return 0x82250230;
		  /* 82250230h */ case   30:  		/* bc 12, CR0_EQ, 128 */
		/* 82250230h case   30:*/		if ( regs.CR[0].eq ) { return 0x822502B0;  }
		/* 82250230h case   30:*/		return 0x82250234;
		  /* 82250234h */ case   31:  		/* lwz R11, <#[R29]> */
		/* 82250234h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82250234h case   31:*/		return 0x82250238;
		  /* 82250238h */ case   32:  		/* mr R3, R29 */
		/* 82250238h case   32:*/		regs.R3 = regs.R29;
		/* 82250238h case   32:*/		return 0x8225023C;
		  /* 8225023Ch */ case   33:  		/* lwz R11, <#[R11 + 28]> */
		/* 8225023Ch case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8225023Ch case   33:*/		return 0x82250240;
		  /* 82250240h */ case   34:  		/* mtspr CTR, R11 */
		/* 82250240h case   34:*/		regs.CTR = regs.R11;
		/* 82250240h case   34:*/		return 0x82250244;
		  /* 82250244h */ case   35:  		/* bcctrl 20, CR0_LT */
		/* 82250244h case   35:*/		if ( 1 ) { regs.LR = 0x82250248; return (uint32)regs.CTR; }
		/* 82250244h case   35:*/		return 0x82250248;
		  /* 82250248h */ case   36:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82250248h case   36:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82250248h case   36:*/		return 0x8225024C;
		  /* 8225024Ch */ case   37:  		/* bc 12, CR0_EQ, 100 */
		/* 8225024Ch case   37:*/		if ( regs.CR[0].eq ) { return 0x822502B0;  }
		/* 8225024Ch case   37:*/		return 0x82250250;
		  /* 82250250h */ case   38:  		/* li R5, 0 */
		/* 82250250h case   38:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82250250h case   38:*/		return 0x82250254;
		  /* 82250254h */ case   39:  		/* addi R11, R1, 80 */
		/* 82250254h case   39:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 82250254h case   39:*/		return 0x82250258;
		  /* 82250258h */ case   40:  		/* lbzx R11, <#[R5 + R11]> */
		/* 82250258h case   40:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 82250258h case   40:*/		return 0x8225025C;
		  /* 8225025Ch */ case   41:  		/* cmplwi CR0, R11, 0 */
		/* 8225025Ch case   41:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8225025Ch case   41:*/		return 0x82250260;
		  /* 82250260h */ case   42:  		/* bc 4, CR0_EQ, 20 */
		/* 82250260h case   42:*/		if ( !regs.CR[0].eq ) { return 0x82250274;  }
		/* 82250260h case   42:*/		return 0x82250264;
		  /* 82250264h */ case   43:  		/* addi R10, R1, 84 */
		/* 82250264h case   43:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x54);
		/* 82250264h case   43:*/		return 0x82250268;
		  /* 82250268h */ case   44:  		/* lbzx R10, <#[R5 + R10]> */
		/* 82250268h case   44:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R5 + regs.R10 + 0x00000000) );
		/* 82250268h case   44:*/		return 0x8225026C;
		  /* 8225026Ch */ case   45:  		/* cmplwi CR0, R10, 0 */
		/* 8225026Ch case   45:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 8225026Ch case   45:*/		return 0x82250270;
		  /* 82250270h */ case   46:  		/* bc 12, CR0_EQ, 72 */
		/* 82250270h case   46:*/		if ( regs.CR[0].eq ) { return 0x822502B8;  }
		/* 82250270h case   46:*/		return 0x82250274;
	}
	return 0x82250274;
} // Block from 822501B8h-82250274h (47 instructions)

//////////////////////////////////////////////////////
// Block at 82250274h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250274( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250274) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250274);
		  /* 82250274h */ case    0:  		/* cmplwi CR6, R11, 1 */
		/* 82250274h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82250274h case    0:*/		return 0x82250278;
		  /* 82250278h */ case    1:  		/* bc 4, CR6_EQ, 56 */
		/* 82250278h case    1:*/		if ( !regs.CR[6].eq ) { return 0x822502B0;  }
		/* 82250278h case    1:*/		return 0x8225027C;
		  /* 8225027Ch */ case    2:  		/* addi R5, R5, 1 */
		/* 8225027Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 8225027Ch case    2:*/		return 0x82250280;
		  /* 82250280h */ case    3:  		/* cmpwi CR6, R5, 4 */
		/* 82250280h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000004);
		/* 82250280h case    3:*/		return 0x82250284;
		  /* 82250284h */ case    4:  		/* bc 12, CR6_LT, -48 */
		/* 82250284h case    4:*/		if ( regs.CR[6].lt ) { return 0x82250254;  }
		/* 82250284h case    4:*/		return 0x82250288;
		  /* 82250288h */ case    5:  		/* mr R5, R29 */
		/* 82250288h case    5:*/		regs.R5 = regs.R29;
		/* 82250288h case    5:*/		return 0x8225028C;
		  /* 8225028Ch */ case    6:  		/* li R4, 1 */
		/* 8225028Ch case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225028Ch case    6:*/		return 0x82250290;
		  /* 82250290h */ case    7:  		/* mr R3, R31 */
		/* 82250290h case    7:*/		regs.R3 = regs.R31;
		/* 82250290h case    7:*/		return 0x82250294;
		  /* 82250294h */ case    8:  		/* bl -107332 */
		/* 82250294h case    8:*/		regs.LR = 0x82250298; return 0x82235F50;
		/* 82250294h case    8:*/		return 0x82250298;
		  /* 82250298h */ case    9:  		/* lwz R11, <#[R30 + 4]> */
		/* 82250298h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82250298h case    9:*/		return 0x8225029C;
		  /* 8225029Ch */ case   10:  		/* lwz R10, <#[R30]> */
		/* 8225029Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8225029Ch case   10:*/		return 0x822502A0;
		  /* 822502A0h */ case   11:  		/* mr R3, R31 */
		/* 822502A0h case   11:*/		regs.R3 = regs.R31;
		/* 822502A0h case   11:*/		return 0x822502A4;
		  /* 822502A4h */ case   12:  		/* stw R11, <#[R31 + 128]> */
		/* 822502A4h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 822502A4h case   12:*/		return 0x822502A8;
		  /* 822502A8h */ case   13:  		/* stw R10, <#[R31 + 132]> */
		/* 822502A8h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000084) );
		/* 822502A8h case   13:*/		return 0x822502AC;
		  /* 822502ACh */ case   14:  		/* bl -107660 */
		/* 822502ACh case   14:*/		regs.LR = 0x822502B0; return 0x82235E20;
		/* 822502ACh case   14:*/		return 0x822502B0;
	}
	return 0x822502B0;
} // Block from 82250274h-822502B0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 822502B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822502B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822502B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822502B0);
		  /* 822502B0h */ case    0:  		/* addi R1, R1, 128 */
		/* 822502B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822502B0h case    0:*/		return 0x822502B4;
		  /* 822502B4h */ case    1:  		/* b -1830924 */
		/* 822502B4h case    1:*/		return 0x820912A8;
		/* 822502B4h case    1:*/		return 0x822502B8;
	}
	return 0x822502B8;
} // Block from 822502B0h-822502B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822502B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822502B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822502B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822502B8);
		  /* 822502B8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 822502B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822502B8h case    0:*/		return 0x822502BC;
		  /* 822502BCh */ case    1:  		/* li R4, 1 */
		/* 822502BCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822502BCh case    1:*/		return 0x822502C0;
		  /* 822502C0h */ case    2:  		/* mr R3, R31 */
		/* 822502C0h case    2:*/		regs.R3 = regs.R31;
		/* 822502C0h case    2:*/		return 0x822502C4;
		  /* 822502C4h */ case    3:  		/* lwz R11, <#[R11 + 80]> */
		/* 822502C4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 822502C4h case    3:*/		return 0x822502C8;
		  /* 822502C8h */ case    4:  		/* mtspr CTR, R11 */
		/* 822502C8h case    4:*/		regs.CTR = regs.R11;
		/* 822502C8h case    4:*/		return 0x822502CC;
		  /* 822502CCh */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 822502CCh case    5:*/		if ( 1 ) { regs.LR = 0x822502D0; return (uint32)regs.CTR; }
		/* 822502CCh case    5:*/		return 0x822502D0;
		  /* 822502D0h */ case    6:  		/* addi R11, R3, 112 */
		/* 822502D0h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x70);
		/* 822502D0h case    6:*/		return 0x822502D4;
		  /* 822502D4h */ case    7:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 822502D4h case    7:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 822502D4h case    7:*/		return 0x822502D8;
		  /* 822502D8h */ case    8:  		/* b -40 */
		/* 822502D8h case    8:*/		return 0x822502B0;
		/* 822502D8h case    8:*/		return 0x822502DC;
		  /* 822502DCh */ case    9:  		/* nop */
		/* 822502DCh case    9:*/		cpu::op::nop();
		/* 822502DCh case    9:*/		return 0x822502E0;
	}
	return 0x822502E0;
} // Block from 822502B8h-822502E0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822502E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822502E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822502E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822502E0);
		  /* 822502E0h */ case    0:  		/* mfspr R12, LR */
		/* 822502E0h case    0:*/		regs.R12 = regs.LR;
		/* 822502E0h case    0:*/		return 0x822502E4;
		  /* 822502E4h */ case    1:  		/* bl -1831052 */
		/* 822502E4h case    1:*/		regs.LR = 0x822502E8; return 0x82091258;
		/* 822502E4h case    1:*/		return 0x822502E8;
		  /* 822502E8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 822502E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822502E8h case    2:*/		return 0x822502EC;
		  /* 822502ECh */ case    3:  		/* lwz R11, <#[R3 + 24]> */
		/* 822502ECh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 822502ECh case    3:*/		return 0x822502F0;
		  /* 822502F0h */ case    4:  		/* mr R31, R3 */
		/* 822502F0h case    4:*/		regs.R31 = regs.R3;
		/* 822502F0h case    4:*/		return 0x822502F4;
		  /* 822502F4h */ case    5:  		/* mr R5, R4 */
		/* 822502F4h case    5:*/		regs.R5 = regs.R4;
		/* 822502F4h case    5:*/		return 0x822502F8;
		  /* 822502F8h */ case    6:  		/* cmpwi CR6, R11, 18 */
		/* 822502F8h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000012);
		/* 822502F8h case    6:*/		return 0x822502FC;
		  /* 822502FCh */ case    7:  		/* bc 4, CR6_EQ, 564 */
		/* 822502FCh case    7:*/		if ( !regs.CR[6].eq ) { return 0x82250530;  }
		/* 822502FCh case    7:*/		return 0x82250300;
		  /* 82250300h */ case    8:  		/* lwz R11, <#[R3 + 236]> */
		/* 82250300h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000EC) );
		/* 82250300h case    8:*/		return 0x82250304;
		  /* 82250304h */ case    9:  		/* li R29, 0 */
		/* 82250304h case    9:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82250304h case    9:*/		return 0x82250308;
		  /* 82250308h */ case   10:  		/* li R28, 0 */
		/* 82250308h case   10:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82250308h case   10:*/		return 0x8225030C;
		  /* 8225030Ch */ case   11:  		/* lwz R11, <#[R11 + 24]> */
		/* 8225030Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8225030Ch case   11:*/		return 0x82250310;
		  /* 82250310h */ case   12:  		/* cmpwi CR6, R11, 19 */
		/* 82250310h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000013);
		/* 82250310h case   12:*/		return 0x82250314;
		  /* 82250314h */ case   13:  		/* bc 4, CR6_EQ, 12 */
		/* 82250314h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82250320;  }
		/* 82250314h case   13:*/		return 0x82250318;
		  /* 82250318h */ case   14:  		/* li R29, 1 */
		/* 82250318h case   14:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 82250318h case   14:*/		return 0x8225031C;
		  /* 8225031Ch */ case   15:  		/* li R28, 2 */
		/* 8225031Ch case   15:*/		cpu::op::li<0>(regs,&regs.R28,0x2);
		/* 8225031Ch case   15:*/		return 0x82250320;
	}
	return 0x82250320;
} // Block from 822502E0h-82250320h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82250320h
// Function '?ScheduleInstructions@CFG@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250320);
		  /* 82250320h */ case    0:  		/* lwz R11, <#[R31 + 240]> */
		/* 82250320h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000F0) );
		/* 82250320h case    0:*/		return 0x82250324;
		  /* 82250324h */ case    1:  		/* lwz R11, <#[R11 + 24]> */
		/* 82250324h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82250324h case    1:*/		return 0x82250328;
		  /* 82250328h */ case    2:  		/* cmpwi CR6, R11, 19 */
		/* 82250328h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000013);
		/* 82250328h case    2:*/		return 0x8225032C;
		  /* 8225032Ch */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 8225032Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82250338;  }
		/* 8225032Ch case    3:*/		return 0x82250330;
		  /* 82250330h */ case    4:  		/* li R29, 2 */
		/* 82250330h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x2);
		/* 82250330h case    4:*/		return 0x82250334;
		  /* 82250334h */ case    5:  		/* li R28, 1 */
		/* 82250334h case    5:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 82250334h case    5:*/		return 0x82250338;
	}
	return 0x82250338;
} // Block from 82250320h-82250338h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82250338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250338);
		  /* 82250338h */ case    0:  		/* cmpwi CR6, R29, 0 */
		/* 82250338h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82250338h case    0:*/		return 0x8225033C;
		  /* 8225033Ch */ case    1:  		/* bc 12, CR6_EQ, 500 */
		/* 8225033Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82250530;  }
		/* 8225033Ch case    1:*/		return 0x82250340;
		  /* 82250340h */ case    2:  		/* addi R11, R29, 58 */
		/* 82250340h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x3A);
		/* 82250340h case    2:*/		return 0x82250344;
		  /* 82250344h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82250344h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82250344h case    3:*/		return 0x82250348;
		  /* 82250348h */ case    4:  		/* lwzx R30, <#[R11 + R31]> */
		/* 82250348h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82250348h case    4:*/		return 0x8225034C;
		  /* 8225034Ch */ case    5:  		/* lwz R11, <#[R30 + 128]> */
		/* 8225034Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000080) );
		/* 8225034Ch case    5:*/		return 0x82250350;
		  /* 82250350h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82250350h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82250350h case    6:*/		return 0x82250354;
		  /* 82250354h */ case    7:  		/* bc 4, CR6_EQ, 476 */
		/* 82250354h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82250530;  }
		/* 82250354h case    7:*/		return 0x82250358;
		  /* 82250358h */ case    8:  		/* lwz R11, <#[R30 + 956]> */
		/* 82250358h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000003BC) );
		/* 82250358h case    8:*/		return 0x8225035C;
		  /* 8225035Ch */ case    9:  		/* lwz R10, <#[R5 + 2152]> */
		/* 8225035Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000868) );
		/* 8225035Ch case    9:*/		return 0x82250360;
		  /* 82250360h */ case   10:  		/* subf R10, R10, R11 */
		/* 82250360h case   10:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82250360h case   10:*/		return 0x82250364;
		  /* 82250364h */ case   11:  		/* rlwinm R11, R10, 1, 31, 31 */
		/* 82250364h case   11:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R10);
		/* 82250364h case   11:*/		return 0x82250368;
		  /* 82250368h */ case   12:  		/* addi R11, R11, -1 */
		/* 82250368h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82250368h case   12:*/		return 0x8225036C;
		  /* 8225036Ch */ case   13:  		/* and R11, R11, R10 */
		/* 8225036Ch case   13:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8225036Ch case   13:*/		return 0x82250370;
		  /* 82250370h */ case   14:  		/* cmpwi CR6, R11, 1 */
		/* 82250370h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 82250370h case   14:*/		return 0x82250374;
		  /* 82250374h */ case   15:  		/* bc 12, CR6_GT, 444 */
		/* 82250374h case   15:*/		if ( regs.CR[6].gt ) { return 0x82250530;  }
		/* 82250374h case   15:*/		return 0x82250378;
		  /* 82250378h */ case   16:  		/* mr R4, R29 */
		/* 82250378h case   16:*/		regs.R4 = regs.R29;
		/* 82250378h case   16:*/		return 0x8225037C;
		  /* 8225037Ch */ case   17:  		/* mr R3, R31 */
		/* 8225037Ch case   17:*/		regs.R3 = regs.R31;
		/* 8225037Ch case   17:*/		return 0x82250380;
		  /* 82250380h */ case   18:  		/* bl -1480 */
		/* 82250380h case   18:*/		regs.LR = 0x82250384; return 0x8224FDB8;
		/* 82250380h case   18:*/		return 0x82250384;
		  /* 82250384h */ case   19:  		/* lwz R11, <#[R30 + 128]> */
		/* 82250384h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000080) );
		/* 82250384h case   19:*/		return 0x82250388;
		  /* 82250388h */ case   20:  		/* li R10, 0 */
		/* 82250388h case   20:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82250388h case   20:*/		return 0x8225038C;
		  /* 8225038Ch */ case   21:  		/* stw R10, <#[R1 + 80]> */
		/* 8225038Ch case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8225038Ch case   21:*/		return 0x82250390;
		  /* 82250390h */ case   22:  		/* rlwinm R8, R3, 8, 24, 31 */
		/* 82250390h case   22:*/		cpu::op::rlwinm<0,8,24,31>(regs,&regs.R8,regs.R3);
		/* 82250390h case   22:*/		return 0x82250394;
		  /* 82250394h */ case   23:  		/* rlwimi R8, R3, 24, 16, 23 */
		/* 82250394h case   23:*/		cpu::op::rlwimi<0,24,16,23>(regs,&regs.R8,regs.R3);
		/* 82250394h case   23:*/		return 0x82250398;
		  /* 82250398h */ case   24:  		/* stw R11, <#[R1 + 84]> */
		/* 82250398h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82250398h case   24:*/		return 0x8225039C;
		  /* 8225039Ch */ case   25:  		/* lbz R10, <#[R1 + 85]> */
		/* 8225039Ch case   25:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000055) );
		/* 8225039Ch case   25:*/		return 0x822503A0;
	}
	return 0x822503A0;
} // Block from 82250338h-822503A0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 822503A0h
// Function '?MarkUnmaskedChannels@XGRAPHICS@@YA?ATSwizzleOrMaskInfo@1@T21@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822503A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822503A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822503A0);
		  /* 822503A0h */ case    0:  		/* rlwimi R8, R3, 8, 8, 15 */
		/* 822503A0h case    0:*/		cpu::op::rlwimi<0,8,8,15>(regs,&regs.R8,regs.R3);
		/* 822503A0h case    0:*/		return 0x822503A4;
		  /* 822503A4h */ case    1:  		/* lbz R9, <#[R1 + 86]> */
		/* 822503A4h case    1:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000056) );
		/* 822503A4h case    1:*/		return 0x822503A8;
		  /* 822503A8h */ case    2:  		/* lbz R7, <#[R1 + 87]> */
		/* 822503A8h case    2:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000057) );
		/* 822503A8h case    2:*/		return 0x822503AC;
		  /* 822503ACh */ case    3:  		/* rlwimi R8, R3, 24, 0, 7 */
		/* 822503ACh case    3:*/		cpu::op::rlwimi<0,24,0,7>(regs,&regs.R8,regs.R3);
		/* 822503ACh case    3:*/		return 0x822503B0;
		  /* 822503B0h */ case    4:  		/* lbz R11, <#[R1 + 84]> */
		/* 822503B0h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 822503B0h case    4:*/		return 0x822503B4;
		  /* 822503B4h */ case    5:  		/* addi R11, R11, -1 */
		/* 822503B4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 822503B4h case    5:*/		return 0x822503B8;
		  /* 822503B8h */ case    6:  		/* addic R6, R11, -1 */
		/* 822503B8h case    6:*/		cpu::op::addic<0>(regs,&regs.R6,regs.R11,0xFFFFFFFF);
		/* 822503B8h case    6:*/		return 0x822503BC;
		  /* 822503BCh */ case    7:  		/* addi R10, R10, -1 */
		/* 822503BCh case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 822503BCh case    7:*/		return 0x822503C0;
		  /* 822503C0h */ case    8:  		/* subfe R6, R6, R11 */
		/* 822503C0h case    8:*/		cpu::op::subfe<0>(regs,&regs.R6,regs.R6,regs.R11);
		/* 822503C0h case    8:*/		return 0x822503C4;
		  /* 822503C4h */ case    9:  		/* addic R5, R10, -1 */
		/* 822503C4h case    9:*/		cpu::op::addic<0>(regs,&regs.R5,regs.R10,0xFFFFFFFF);
		/* 822503C4h case    9:*/		return 0x822503C8;
		  /* 822503C8h */ case   10:  		/* addi R11, R9, -1 */
		/* 822503C8h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 822503C8h case   10:*/		return 0x822503CC;
		  /* 822503CCh */ case   11:  		/* stb R6, <#[R1 + 80]> */
		/* 822503CCh case   11:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 822503CCh case   11:*/		return 0x822503D0;
		  /* 822503D0h */ case   12:  		/* mr R9, R7 */
		/* 822503D0h case   12:*/		regs.R9 = regs.R7;
		/* 822503D0h case   12:*/		return 0x822503D4;
		  /* 822503D4h */ case   13:  		/* subfe R7, R5, R10 */
		/* 822503D4h case   13:*/		cpu::op::subfe<0>(regs,&regs.R7,regs.R5,regs.R10);
		/* 822503D4h case   13:*/		return 0x822503D8;
		  /* 822503D8h */ case   14:  		/* addic R6, R11, -1 */
		/* 822503D8h case   14:*/		cpu::op::addic<0>(regs,&regs.R6,regs.R11,0xFFFFFFFF);
		/* 822503D8h case   14:*/		return 0x822503DC;
		  /* 822503DCh */ case   15:  		/* addi R10, R9, -1 */
		/* 822503DCh case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFFFFF);
		/* 822503DCh case   15:*/		return 0x822503E0;
		  /* 822503E0h */ case   16:  		/* stb R7, <#[R1 + 81]> */
		/* 822503E0h case   16:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R1 + 0x00000051) );
		/* 822503E0h case   16:*/		return 0x822503E4;
		  /* 822503E4h */ case   17:  		/* subfe R11, R6, R11 */
		/* 822503E4h case   17:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R6,regs.R11);
		/* 822503E4h case   17:*/		return 0x822503E8;
		  /* 822503E8h */ case   18:  		/* addic R9, R10, -1 */
		/* 822503E8h case   18:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 822503E8h case   18:*/		return 0x822503EC;
		  /* 822503ECh */ case   19:  		/* stb R11, <#[R1 + 82]> */
		/* 822503ECh case   19:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000052) );
		/* 822503ECh case   19:*/		return 0x822503F0;
		  /* 822503F0h */ case   20:  		/* subfe R11, R9, R10 */
		/* 822503F0h case   20:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R9,regs.R10);
		/* 822503F0h case   20:*/		return 0x822503F4;
		  /* 822503F4h */ case   21:  		/* stb R11, <#[R1 + 83]> */
		/* 822503F4h case   21:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000053) );
		/* 822503F4h case   21:*/		return 0x822503F8;
		  /* 822503F8h */ case   22:  		/* lwz R11, <#[R1 + 80]> */
		/* 822503F8h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 822503F8h case   22:*/		return 0x822503FC;
		  /* 822503FCh */ case   23:  		/* rlwinm R10, R11, 8, 24, 31 */
		/* 822503FCh case   23:*/		cpu::op::rlwinm<0,8,24,31>(regs,&regs.R10,regs.R11);
		/* 822503FCh case   23:*/		return 0x82250400;
		  /* 82250400h */ case   24:  		/* rlwimi R10, R11, 24, 16, 23 */
		/* 82250400h case   24:*/		cpu::op::rlwimi<0,24,16,23>(regs,&regs.R10,regs.R11);
		/* 82250400h case   24:*/		return 0x82250404;
		  /* 82250404h */ case   25:  		/* rlwimi R10, R11, 8, 8, 15 */
		/* 82250404h case   25:*/		cpu::op::rlwimi<0,8,8,15>(regs,&regs.R10,regs.R11);
		/* 82250404h case   25:*/		return 0x82250408;
		  /* 82250408h */ case   26:  		/* rlwimi R10, R11, 24, 0, 7 */
		/* 82250408h case   26:*/		cpu::op::rlwimi<0,24,0,7>(regs,&regs.R10,regs.R11);
		/* 82250408h case   26:*/		return 0x8225040C;
		  /* 8225040Ch */ case   27:  		/* cmplw CR6, R8, R10 */
		/* 8225040Ch case   27:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 8225040Ch case   27:*/		return 0x82250410;
	}
	return 0x82250410;
} // Block from 822503A0h-82250410h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82250410h
// Function '?SubtractMarkedMaskFromReq@XGRAPHICS@@YA?ATSwizzleOrMaskInfo@1@T21@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250410);
		  /* 82250410h */ case    0:  		/* bc 12, CR6_GT, 288 */
		/* 82250410h case    0:*/		if ( regs.CR[6].gt ) { return 0x82250530;  }
		/* 82250410h case    0:*/		return 0x82250414;
		  /* 82250414h */ case    1:  		/* and R10, R11, R3 */
		/* 82250414h case    1:*/		cpu::op::and<0>(regs,&regs.R10,regs.R11,regs.R3);
		/* 82250414h case    1:*/		return 0x82250418;
		  /* 82250418h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 82250418h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82250418h case    2:*/		return 0x8225041C;
		  /* 8225041Ch */ case    3:  		/* bc 4, CR6_EQ, 276 */
		/* 8225041Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82250530;  }
		/* 8225041Ch case    3:*/		return 0x82250420;
		  /* 82250420h */ case    4:  		/* add R11, R29, R31 */
		/* 82250420h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R29,regs.R31);
		/* 82250420h case    4:*/		return 0x82250424;
		  /* 82250424h */ case    5:  		/* lbz R10, <#[R11 + 158]> */
		/* 82250424h case    5:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000009E) );
		/* 82250424h case    5:*/		return 0x82250428;
		  /* 82250428h */ case    6:  		/* cmplwi CR0, R10, 0 */
		/* 82250428h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 82250428h case    6:*/		return 0x8225042C;
		  /* 8225042Ch */ case    7:  		/* bc 4, CR0_EQ, 260 */
		/* 8225042Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x82250530;  }
		/* 8225042Ch case    7:*/		return 0x82250430;
		  /* 82250430h */ case    8:  		/* lbz R11, <#[R11 + 152]> */
		/* 82250430h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000098) );
		/* 82250430h case    8:*/		return 0x82250434;
		  /* 82250434h */ case    9:  		/* cmplwi CR0, R11, 0 */
		/* 82250434h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82250434h case    9:*/		return 0x82250438;
		  /* 82250438h */ case   10:  		/* bc 4, CR0_EQ, 248 */
		/* 82250438h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82250530;  }
		/* 82250438h case   10:*/		return 0x8225043C;
		  /* 8225043Ch */ case   11:  		/* lbz R11, <#[R30 + 164]> */
		/* 8225043Ch case   11:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000A4) );
		/* 8225043Ch case   11:*/		return 0x82250440;
		  /* 82250440h */ case   12:  		/* cmplwi CR0, R11, 0 */
		/* 82250440h case   12:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82250440h case   12:*/		return 0x82250444;
		  /* 82250444h */ case   13:  		/* bc 4, CR0_EQ, 236 */
		/* 82250444h case   13:*/		if ( !regs.CR[0].eq ) { return 0x82250530;  }
		/* 82250444h case   13:*/		return 0x82250448;
		  /* 82250448h */ case   14:  		/* li R9, 20 */
		/* 82250448h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x14);
		/* 82250448h case   14:*/		return 0x8225044C;
		  /* 8225044Ch */ case   15:  		/* lwz R10, <#[R31 + 244]> */
		/* 8225044Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000F4) );
		/* 8225044Ch case   15:*/		return 0x82250450;
		  /* 82250450h */ case   16:  		/* lis R11, -32252 */
		/* 82250450h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82250450h case   16:*/		return 0x82250454;
		  /* 82250454h */ case   17:  		/* stw R9, <#[R31 + 24]> */
		/* 82250454h case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 82250454h case   17:*/		return 0x82250458;
		  /* 82250458h */ case   18:  		/* addi R9, R28, 58 */
		/* 82250458h case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R28,0x3A);
		/* 82250458h case   18:*/		return 0x8225045C;
		  /* 8225045Ch */ case   19:  		/* addi R11, R11, 16056 */
		/* 8225045Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3EB8);
		/* 8225045Ch case   19:*/		return 0x82250460;
		  /* 82250460h */ case   20:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82250460h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82250460h case   20:*/		return 0x82250464;
		  /* 82250464h */ case   21:  		/* stw R11, <#[R31]> */
		/* 82250464h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82250464h case   21:*/		return 0x82250468;
		  /* 82250468h */ case   22:  		/* addi R11, R28, 32 */
		/* 82250468h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0x20);
		/* 82250468h case   22:*/		return 0x8225046C;
		  /* 8225046Ch */ case   23:  		/* stw R10, <#[R31 + 248]> */
		/* 8225046Ch case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x000000F8) );
		/* 8225046Ch case   23:*/		return 0x82250470;
		  /* 82250470h */ case   24:  		/* addi R8, R28, 50 */
		/* 82250470h case   24:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R28,0x32);
		/* 82250470h case   24:*/		return 0x82250474;
		  /* 82250474h */ case   25:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 82250474h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 82250474h case   25:*/		return 0x82250478;
		  /* 82250478h */ case   26:  		/* add R11, R28, R31 */
		/* 82250478h case   26:*/		cpu::op::add<0>(regs,&regs.R11,regs.R28,regs.R31);
		/* 82250478h case   26:*/		return 0x8225047C;
		  /* 8225047Ch */ case   27:  		/* lwzx R9, <#[R9 + R31]> */
		/* 8225047Ch case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R31 + 0x00000000) );
		/* 8225047Ch case   27:*/		return 0x82250480;
		  /* 82250480h */ case   28:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82250480h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82250480h case   28:*/		return 0x82250484;
		  /* 82250484h */ case   29:  		/* stw R9, <#[R31 + 244]> */
		/* 82250484h case   29:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x000000F4) );
		/* 82250484h case   29:*/		return 0x82250488;
		  /* 82250488h */ case   30:  		/* lwz R9, <#[R30 + 240]> */
		/* 82250488h case   30:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x000000F0) );
		/* 82250488h case   30:*/		return 0x8225048C;
		  /* 8225048Ch */ case   31:  		/* stw R9, <#[R31 + 240]> */
		/* 8225048Ch case   31:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x000000F0) );
		/* 8225048Ch case   31:*/		return 0x82250490;
		  /* 82250490h */ case   32:  		/* lwz R9, <#[R30 + 236]> */
		/* 82250490h case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x000000EC) );
		/* 82250490h case   32:*/		return 0x82250494;
		  /* 82250494h */ case   33:  		/* stw R9, <#[R31 + 236]> */
		/* 82250494h case   33:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x000000EC) );
		/* 82250494h case   33:*/		return 0x82250498;
	}
	return 0x82250498;
} // Block from 82250410h-82250498h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82250498h
// Function '?SubtractMarkedMaskFromReqTable@XGRAPHICS@@YA?ATSwizzleOrMaskInfo@1@T21@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250498);
		  /* 82250498h */ case    0:  		/* lwz R9, <#[R31 + 140]> */
		/* 82250498h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000008C) );
		/* 82250498h case    0:*/		return 0x8225049C;
		  /* 8225049Ch */ case    1:  		/* stw R9, <#[R31 + 144]> */
		/* 8225049Ch case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000090) );
		/* 8225049Ch case    1:*/		return 0x822504A0;
		  /* 822504A0h */ case    2:  		/* lwzx R10, <#[R10 + R31]> */
		/* 822504A0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 822504A0h case    2:*/		return 0x822504A4;
		  /* 822504A4h */ case    3:  		/* stw R10, <#[R31 + 140]> */
		/* 822504A4h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000008C) );
		/* 822504A4h case    3:*/		return 0x822504A8;
		  /* 822504A8h */ case    4:  		/* lwz R10, <#[R30 + 136]> */
		/* 822504A8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000088) );
		/* 822504A8h case    4:*/		return 0x822504AC;
		  /* 822504ACh */ case    5:  		/* stw R10, <#[R31 + 136]> */
		/* 822504ACh case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000088) );
		/* 822504ACh case    5:*/		return 0x822504B0;
		  /* 822504B0h */ case    6:  		/* lwz R10, <#[R30 + 132]> */
		/* 822504B0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000084) );
		/* 822504B0h case    6:*/		return 0x822504B4;
		  /* 822504B4h */ case    7:  		/* stw R10, <#[R31 + 132]> */
		/* 822504B4h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000084) );
		/* 822504B4h case    7:*/		return 0x822504B8;
		  /* 822504B8h */ case    8:  		/* lbz R10, <#[R31 + 161]> */
		/* 822504B8h case    8:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000A1) );
		/* 822504B8h case    8:*/		return 0x822504BC;
		  /* 822504BCh */ case    9:  		/* stb R10, <#[R31 + 162]> */
		/* 822504BCh case    9:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x000000A2) );
		/* 822504BCh case    9:*/		return 0x822504C0;
		  /* 822504C0h */ case   10:  		/* lbz R10, <#[R11 + 158]> */
		/* 822504C0h case   10:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000009E) );
		/* 822504C0h case   10:*/		return 0x822504C4;
		  /* 822504C4h */ case   11:  		/* stb R10, <#[R31 + 161]> */
		/* 822504C4h case   11:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x000000A1) );
		/* 822504C4h case   11:*/		return 0x822504C8;
		  /* 822504C8h */ case   12:  		/* lbz R10, <#[R30 + 160]> */
		/* 822504C8h case   12:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R30 + 0x000000A0) );
		/* 822504C8h case   12:*/		return 0x822504CC;
		  /* 822504CCh */ case   13:  		/* stb R10, <#[R31 + 160]> */
		/* 822504CCh case   13:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x000000A0) );
		/* 822504CCh case   13:*/		return 0x822504D0;
		  /* 822504D0h */ case   14:  		/* lbz R10, <#[R30 + 159]> */
		/* 822504D0h case   14:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000009F) );
		/* 822504D0h case   14:*/		return 0x822504D4;
		  /* 822504D4h */ case   15:  		/* stb R10, <#[R31 + 159]> */
		/* 822504D4h case   15:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x0000009F) );
		/* 822504D4h case   15:*/		return 0x822504D8;
		  /* 822504D8h */ case   16:  		/* lbz R10, <#[R31 + 155]> */
		/* 822504D8h case   16:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000009B) );
		/* 822504D8h case   16:*/		return 0x822504DC;
		  /* 822504DCh */ case   17:  		/* stb R10, <#[R31 + 156]> */
		/* 822504DCh case   17:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x0000009C) );
		/* 822504DCh case   17:*/		return 0x822504E0;
		  /* 822504E0h */ case   18:  		/* lbz R11, <#[R11 + 152]> */
		/* 822504E0h case   18:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000098) );
		/* 822504E0h case   18:*/		return 0x822504E4;
		  /* 822504E4h */ case   19:  		/* stb R11, <#[R31 + 155]> */
		/* 822504E4h case   19:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x0000009B) );
		/* 822504E4h case   19:*/		return 0x822504E8;
		  /* 822504E8h */ case   20:  		/* lbz R11, <#[R30 + 154]> */
		/* 822504E8h case   20:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000009A) );
		/* 822504E8h case   20:*/		return 0x822504EC;
		  /* 822504ECh */ case   21:  		/* stb R11, <#[R31 + 154]> */
		/* 822504ECh case   21:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x0000009A) );
		/* 822504ECh case   21:*/		return 0x822504F0;
		  /* 822504F0h */ case   22:  		/* lbz R11, <#[R30 + 153]> */
		/* 822504F0h case   22:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000099) );
		/* 822504F0h case   22:*/		return 0x822504F4;
		  /* 822504F4h */ case   23:  		/* stb R11, <#[R31 + 153]> */
		/* 822504F4h case   23:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000099) );
		/* 822504F4h case   23:*/		return 0x822504F8;
		  /* 822504F8h */ case   24:  		/* lwz R11, <#[R31 + 212]> */
		/* 822504F8h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000D4) );
		/* 822504F8h case   24:*/		return 0x822504FC;
		  /* 822504FCh */ case   25:  		/* stw R11, <#[R31 + 216]> */
		/* 822504FCh case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000D8) );
		/* 822504FCh case   25:*/		return 0x82250500;
		  /* 82250500h */ case   26:  		/* lwzx R11, <#[R8 + R31]> */
		/* 82250500h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R31 + 0x00000000) );
		/* 82250500h case   26:*/		return 0x82250504;
		  /* 82250504h */ case   27:  		/* stw R11, <#[R31 + 212]> */
		/* 82250504h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000D4) );
		/* 82250504h case   27:*/		return 0x82250508;
		  /* 82250508h */ case   28:  		/* lwz R11, <#[R30 + 208]> */
		/* 82250508h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000D0) );
		/* 82250508h case   28:*/		return 0x8225050C;
		  /* 8225050Ch */ case   29:  		/* stw R11, <#[R31 + 208]> */
		/* 8225050Ch case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000D0) );
		/* 8225050Ch case   29:*/		return 0x82250510;
		  /* 82250510h */ case   30:  		/* lwz R11, <#[R30 + 204]> */
		/* 82250510h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000CC) );
		/* 82250510h case   30:*/		return 0x82250514;
		  /* 82250514h */ case   31:  		/* stw R11, <#[R31 + 204]> */
		/* 82250514h case   31:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000CC) );
		/* 82250514h case   31:*/		return 0x82250518;
		  /* 82250518h */ case   32:  		/* lwz R11, <#[R31 + 248]> */
		/* 82250518h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000F8) );
		/* 82250518h case   32:*/		return 0x8225051C;
		  /* 8225051Ch */ case   33:  		/* cmplwi CR6, R11, 0 */
		/* 8225051Ch case   33:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8225051Ch case   33:*/		return 0x82250520;
	}
	return 0x82250520;
} // Block from 82250498h-82250520h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82250520h
// Function '?OperationInputs@IRInst@XGRAPHICS@@UBA?BHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250520);
		  /* 82250520h */ case    0:  		/* li R11, 4 */
		/* 82250520h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 82250520h case    0:*/		return 0x82250524;
		  /* 82250524h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 82250524h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8225052C;  }
		/* 82250524h case    1:*/		return 0x82250528;
	}
	return 0x82250528;
} // Block from 82250520h-82250528h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82250528h
// Function '?InstType@IRInst@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250528);
		  /* 82250528h */ case    0:  		/* li R11, 3 */
		/* 82250528h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 82250528h case    0:*/		return 0x8225052C;
	}
	return 0x8225052C;
} // Block from 82250528h-8225052Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225052Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225052C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225052C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225052C);
		  /* 8225052Ch */ case    0:  		/* stw R11, <#[R31 + 20]> */
		/* 8225052Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8225052Ch case    0:*/		return 0x82250530;
	}
	return 0x82250530;
} // Block from 8225052Ch-82250530h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82250530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250530);
		  /* 82250530h */ case    0:  		/* addi R1, R1, 128 */
		/* 82250530h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82250530h case    0:*/		return 0x82250534;
		  /* 82250534h */ case    1:  		/* b -1831564 */
		/* 82250534h case    1:*/		return 0x820912A8;
		/* 82250534h case    1:*/		return 0x82250538;
	}
	return 0x82250538;
} // Block from 82250530h-82250538h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82250538h
// Function '?InstType@IRAlu@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250538);
		  /* 82250538h */ case    0:  		/* mfspr R12, LR */
		/* 82250538h case    0:*/		regs.R12 = regs.LR;
		/* 82250538h case    0:*/		return 0x8225053C;
		  /* 8225053Ch */ case    1:  		/* bl -1831652 */
		/* 8225053Ch case    1:*/		regs.LR = 0x82250540; return 0x82091258;
		/* 8225053Ch case    1:*/		return 0x82250540;
		  /* 82250540h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82250540h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82250540h case    2:*/		return 0x82250544;
		  /* 82250544h */ case    3:  		/* lwz R11, <#[R3 + 228]> */
		/* 82250544h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82250544h case    3:*/		return 0x82250548;
	}
	return 0x82250548;
} // Block from 82250538h-82250548h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82250548h
// Function '?OperationInputs@IRTrinary@XGRAPHICS@@UBA?BHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250548);
		  /* 82250548h */ case    0:  		/* mr R31, R3 */
		/* 82250548h case    0:*/		regs.R31 = regs.R3;
		/* 82250548h case    0:*/		return 0x8225054C;
		  /* 8225054Ch */ case    1:  		/* mr R29, R4 */
		/* 8225054Ch case    1:*/		regs.R29 = regs.R4;
		/* 8225054Ch case    1:*/		return 0x82250550;
	}
	return 0x82250550;
} // Block from 82250548h-82250550h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82250550h
// Function '?SetSwizzle@IRInst@XGRAPHICS@@UAAXHHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250550);
		  /* 82250550h */ case    0:  		/* rlwinm. R11, R11, 23, 31, 31 */
		/* 82250550h case    0:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R11,regs.R11);
		/* 82250550h case    0:*/		return 0x82250554;
		  /* 82250554h */ case    1:  		/* bc 12, CR0_EQ, 1700 */
		/* 82250554h case    1:*/		if ( regs.CR[0].eq ) { return 0x82250BF8;  }
		/* 82250554h case    1:*/		return 0x82250558;
		  /* 82250558h */ case    2:  		/* lwz R11, <#[R3 + 24]> */
		/* 82250558h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82250558h case    2:*/		return 0x8225055C;
		  /* 8225055Ch */ case    3:  		/* cmpwi CR6, R11, 24 */
		/* 8225055Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000018);
		/* 8225055Ch case    3:*/		return 0x82250560;
		  /* 82250560h */ case    4:  		/* bc 12, CR6_GT, 540 */
		/* 82250560h case    4:*/		if ( regs.CR[6].gt ) { return 0x8225077C;  }
		/* 82250560h case    4:*/		return 0x82250564;
		  /* 82250564h */ case    5:  		/* bc 12, CR6_EQ, 576 */
		/* 82250564h case    5:*/		if ( regs.CR[6].eq ) { return 0x822507A4;  }
		/* 82250564h case    5:*/		return 0x82250568;
	}
	return 0x82250568;
} // Block from 82250550h-82250568h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82250568h
// Function '?SetMask@IRAlu@XGRAPHICS@@UAAXHHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250568);
		  /* 82250568h */ case    0:  		/* cmpwi CR6, R11, 18 */
		/* 82250568h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000012);
		/* 82250568h case    0:*/		return 0x8225056C;
		  /* 8225056Ch */ case    1:  		/* bc 12, CR6_LT, 1676 */
		/* 8225056Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x82250BF8;  }
		/* 8225056Ch case    1:*/		return 0x82250570;
		  /* 82250570h */ case    2:  		/* cmpwi CR6, R11, 19 */
		/* 82250570h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000013);
		/* 82250570h case    2:*/		return 0x82250574;
		  /* 82250574h */ case    3:  		/* bc 4, CR6_GT, 32 */
		/* 82250574h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82250594;  }
		/* 82250574h case    3:*/		return 0x82250578;
		  /* 82250578h */ case    4:  		/* cmpwi CR6, R11, 20 */
		/* 82250578h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000014);
		/* 82250578h case    4:*/		return 0x8225057C;
		  /* 8225057Ch */ case    5:  		/* bc 12, CR6_EQ, 848 */
		/* 8225057Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x822508CC;  }
		/* 8225057Ch case    5:*/		return 0x82250580;
		  /* 82250580h */ case    6:  		/* bc 4, CR6_GT, 1656 */
		/* 82250580h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82250BF8;  }
		/* 82250580h case    6:*/		return 0x82250584;
		  /* 82250584h */ case    7:  		/* cmpwi CR6, R11, 22 */
		/* 82250584h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000016);
		/* 82250584h case    7:*/		return 0x82250588;
		  /* 82250588h */ case    8:  		/* bc 4, CR6_GT, 540 */
		/* 82250588h case    8:*/		if ( !regs.CR[6].gt ) { return 0x822507A4;  }
		/* 82250588h case    8:*/		return 0x8225058C;
		  /* 8225058Ch */ case    9:  		/* cmpwi CR6, R11, 23 */
		/* 8225058Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000017);
		/* 8225058Ch case    9:*/		return 0x82250590;
		  /* 82250590h */ case   10:  		/* bc 4, CR6_EQ, 1640 */
		/* 82250590h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82250BF8;  }
		/* 82250590h case   10:*/		return 0x82250594;
	}
	return 0x82250594;
} // Block from 82250568h-82250594h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82250594h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250594( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250594) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250594);
		  /* 82250594h */ case    0:  		/* mr R3, R31 */
		/* 82250594h case    0:*/		regs.R3 = regs.R31;
		/* 82250594h case    0:*/		return 0x82250598;
		  /* 82250598h */ case    1:  		/* bl -108512 */
		/* 82250598h case    1:*/		regs.LR = 0x8225059C; return 0x82235DB8;
		/* 82250598h case    1:*/		return 0x8225059C;
		  /* 8225059Ch */ case    2:  		/* lwz R11, <#[R29 + 2152]> */
		/* 8225059Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000868) );
		/* 8225059Ch case    2:*/		return 0x822505A0;
		  /* 822505A0h */ case    3:  		/* lwz R10, <#[R3 + 956]> */
		/* 822505A0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x000003BC) );
		/* 822505A0h case    3:*/		return 0x822505A4;
		  /* 822505A4h */ case    4:  		/* mr R30, R3 */
		/* 822505A4h case    4:*/		regs.R30 = regs.R3;
		/* 822505A4h case    4:*/		return 0x822505A8;
		  /* 822505A8h */ case    5:  		/* subf R10, R11, R10 */
		/* 822505A8h case    5:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 822505A8h case    5:*/		return 0x822505AC;
		  /* 822505ACh */ case    6:  		/* rlwinm R11, R10, 1, 31, 31 */
		/* 822505ACh case    6:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R10);
		/* 822505ACh case    6:*/		return 0x822505B0;
	}
	return 0x822505B0;
} // Block from 82250594h-822505B0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822505B0h
// Function '?SetSwizzle@IRAlu@XGRAPHICS@@UAAXHHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822505B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822505B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822505B0);
		  /* 822505B0h */ case    0:  		/* addi R11, R11, -1 */
		/* 822505B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 822505B0h case    0:*/		return 0x822505B4;
		  /* 822505B4h */ case    1:  		/* and R11, R11, R10 */
		/* 822505B4h case    1:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 822505B4h case    1:*/		return 0x822505B8;
		  /* 822505B8h */ case    2:  		/* cmpwi CR6, R11, 1 */
		/* 822505B8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 822505B8h case    2:*/		return 0x822505BC;
		  /* 822505BCh */ case    3:  		/* bc 12, CR6_GT, 1596 */
		/* 822505BCh case    3:*/		if ( regs.CR[6].gt ) { return 0x82250BF8;  }
		/* 822505BCh case    3:*/		return 0x822505C0;
		  /* 822505C0h */ case    4:  		/* lwz R11, <#[R31 + 24]> */
		/* 822505C0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 822505C0h case    4:*/		return 0x822505C4;
		  /* 822505C4h */ case    5:  		/* lwz R10, <#[R3 + 24]> */
		/* 822505C4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 822505C4h case    5:*/		return 0x822505C8;
		  /* 822505C8h */ case    6:  		/* cmpw CR6, R11, R10 */
		/* 822505C8h case    6:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 822505C8h case    6:*/		return 0x822505CC;
		  /* 822505CCh */ case    7:  		/* bc 4, CR6_EQ, 1580 */
		/* 822505CCh case    7:*/		if ( !regs.CR[6].eq ) { return 0x82250BF8;  }
		/* 822505CCh case    7:*/		return 0x822505D0;
		  /* 822505D0h */ case    8:  		/* mr R4, R3 */
		/* 822505D0h case    8:*/		regs.R4 = regs.R3;
		/* 822505D0h case    8:*/		return 0x822505D4;
		  /* 822505D4h */ case    9:  		/* mr R3, R31 */
		/* 822505D4h case    9:*/		regs.R3 = regs.R31;
		/* 822505D4h case    9:*/		return 0x822505D8;
		  /* 822505D8h */ case   10:  		/* bl 22472 */
		/* 822505D8h case   10:*/		regs.LR = 0x822505DC; return 0x82255DA0;
		/* 822505D8h case   10:*/		return 0x822505DC;
		  /* 822505DCh */ case   11:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822505DCh case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822505DCh case   11:*/		return 0x822505E0;
		  /* 822505E0h */ case   12:  		/* bc 12, CR0_EQ, 1560 */
		/* 822505E0h case   12:*/		if ( regs.CR[0].eq ) { return 0x82250BF8;  }
		/* 822505E0h case   12:*/		return 0x822505E4;
		  /* 822505E4h */ case   13:  		/* lwz R11, <#[R31]> */
		/* 822505E4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822505E4h case   13:*/		return 0x822505E8;
		  /* 822505E8h */ case   14:  		/* mr R3, R31 */
		/* 822505E8h case   14:*/		regs.R3 = regs.R31;
		/* 822505E8h case   14:*/		return 0x822505EC;
		  /* 822505ECh */ case   15:  		/* lwz R11, <#[R11 + 4]> */
		/* 822505ECh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822505ECh case   15:*/		return 0x822505F0;
		  /* 822505F0h */ case   16:  		/* mtspr CTR, R11 */
		/* 822505F0h case   16:*/		regs.CTR = regs.R11;
		/* 822505F0h case   16:*/		return 0x822505F4;
		  /* 822505F4h */ case   17:  		/* bcctrl 20, CR0_LT */
		/* 822505F4h case   17:*/		if ( 1 ) { regs.LR = 0x822505F8; return (uint32)regs.CTR; }
		/* 822505F4h case   17:*/		return 0x822505F8;
	}
	return 0x822505F8;
} // Block from 822505B0h-822505F8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 822505F8h
// Function '?GetModifier@IRInst@XGRAPHICS@@UBAHHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822505F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822505F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822505F8);
		  /* 822505F8h */ case    0:  		/* cmpwi CR6, R3, 2 */
		/* 822505F8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 822505F8h case    0:*/		return 0x822505FC;
		  /* 822505FCh */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 822505FCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82250624;  }
		/* 822505FCh case    1:*/		return 0x82250600;
		  /* 82250600h */ case    2:  		/* lis R11, -32252 */
		/* 82250600h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82250600h case    2:*/		return 0x82250604;
		  /* 82250604h */ case    3:  		/* lis R10, -32252 */
		/* 82250604h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82250604h case    3:*/		return 0x82250608;
		  /* 82250608h */ case    4:  		/* lis R9, -32253 */
		/* 82250608h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82250608h case    4:*/		return 0x8225060C;
		  /* 8225060Ch */ case    5:  		/* addi R6, R11, 16232 */
		/* 8225060Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x3F68);
		/* 8225060Ch case    5:*/		return 0x82250610;
	}
	return 0x82250610;
} // Block from 822505F8h-82250610h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82250610h
// Function '?BalanceVectorScalar@CFG@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250610);
		  /* 82250610h */ case    0:  		/* addi R5, R10, 16348 */
		/* 82250610h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x3FDC);
		/* 82250610h case    0:*/		return 0x82250614;
		  /* 82250614h */ case    1:  		/* addi R4, R9, 27460 */
		/* 82250614h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82250614h case    1:*/		return 0x82250618;
		  /* 82250618h */ case    2:  		/* li R7, 1073 */
		/* 82250618h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x431);
		/* 82250618h case    2:*/		return 0x8225061C;
		  /* 8225061Ch */ case    3:  		/* li R3, 0 */
		/* 8225061Ch case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225061Ch case    3:*/		return 0x82250620;
		  /* 82250620h */ case    4:  		/* bl -1018392 */
		/* 82250620h case    4:*/		regs.LR = 0x82250624; return 0x82157C08;
		/* 82250620h case    4:*/		return 0x82250624;
	}
	return 0x82250624;
} // Block from 82250610h-82250624h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82250624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250624);
		  /* 82250624h */ case    0:  		/* lwz R11, <#[R30 + 236]> */
		/* 82250624h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000EC) );
		/* 82250624h case    0:*/		return 0x82250628;
		  /* 82250628h */ case    1:  		/* lwz R10, <#[R31 + 236]> */
		/* 82250628h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000EC) );
		/* 82250628h case    1:*/		return 0x8225062C;
		  /* 8225062Ch */ case    2:  		/* cmpw CR6, R10, R11 */
		/* 8225062Ch case    2:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 8225062Ch case    2:*/		return 0x82250630;
		  /* 82250630h */ case    3:  		/* bc 4, CR6_EQ, 20 */
		/* 82250630h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82250644;  }
		/* 82250630h case    3:*/		return 0x82250634;
		  /* 82250634h */ case    4:  		/* lwz R9, <#[R30 + 240]> */
		/* 82250634h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x000000F0) );
		/* 82250634h case    4:*/		return 0x82250638;
		  /* 82250638h */ case    5:  		/* lwz R8, <#[R31 + 240]> */
		/* 82250638h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x000000F0) );
		/* 82250638h case    5:*/		return 0x8225063C;
		  /* 8225063Ch */ case    6:  		/* cmpw CR6, R8, R9 */
		/* 8225063Ch case    6:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R9);
		/* 8225063Ch case    6:*/		return 0x82250640;
		  /* 82250640h */ case    7:  		/* bc 12, CR6_EQ, 28 */
		/* 82250640h case    7:*/		if ( regs.CR[6].eq ) { return 0x8225065C;  }
		/* 82250640h case    7:*/		return 0x82250644;
	}
	return 0x82250644;
} // Block from 82250624h-82250644h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82250644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250644);
		  /* 82250644h */ case    0:  		/* lwz R9, <#[R31 + 240]> */
		/* 82250644h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x000000F0) );
		/* 82250644h case    0:*/		return 0x82250648;
		  /* 82250648h */ case    1:  		/* cmpw CR6, R9, R11 */
		/* 82250648h case    1:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R11);
		/* 82250648h case    1:*/		return 0x8225064C;
		  /* 8225064Ch */ case    2:  		/* bc 4, CR6_EQ, 1452 */
		/* 8225064Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82250BF8;  }
		/* 8225064Ch case    2:*/		return 0x82250650;
		  /* 82250650h */ case    3:  		/* lwz R11, <#[R30 + 240]> */
		/* 82250650h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000F0) );
		/* 82250650h case    3:*/		return 0x82250654;
		  /* 82250654h */ case    4:  		/* cmpw CR6, R10, R11 */
		/* 82250654h case    4:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 82250654h case    4:*/		return 0x82250658;
		  /* 82250658h */ case    5:  		/* bc 4, CR6_EQ, 1440 */
		/* 82250658h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82250BF8;  }
		/* 82250658h case    5:*/		return 0x8225065C;
	}
	return 0x8225065C;
} // Block from 82250644h-8225065Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225065Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225065C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225065C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225065C);
		  /* 8225065Ch */ case    0:  		/* mr R4, R30 */
		/* 8225065Ch case    0:*/		regs.R4 = regs.R30;
		/* 8225065Ch case    0:*/		return 0x82250660;
		  /* 82250660h */ case    1:  		/* mr R3, R31 */
		/* 82250660h case    1:*/		regs.R3 = regs.R31;
		/* 82250660h case    1:*/		return 0x82250664;
		  /* 82250664h */ case    2:  		/* bl 22164 */
		/* 82250664h case    2:*/		regs.LR = 0x82250668; return 0x82255CF8;
		/* 82250664h case    2:*/		return 0x82250668;
		  /* 82250668h */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82250668h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82250668h case    3:*/		return 0x8225066C;
		  /* 8225066Ch */ case    4:  		/* bc 12, CR0_EQ, 1420 */
		/* 8225066Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x82250BF8;  }
		/* 8225066Ch case    4:*/		return 0x82250670;
		  /* 82250670h */ case    5:  		/* lwz R11, <#[R31 + 236]> */
		/* 82250670h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000EC) );
		/* 82250670h case    5:*/		return 0x82250674;
		  /* 82250674h */ case    6:  		/* lwz R10, <#[R30 + 236]> */
		/* 82250674h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x000000EC) );
		/* 82250674h case    6:*/		return 0x82250678;
		  /* 82250678h */ case    7:  		/* cmpw CR6, R11, R10 */
		/* 82250678h case    7:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82250678h case    7:*/		return 0x8225067C;
		  /* 8225067Ch */ case    8:  		/* bc 4, CR6_EQ, 1104 */
		/* 8225067Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x82250ACC;  }
		/* 8225067Ch case    8:*/		return 0x82250680;
		  /* 82250680h */ case    9:  		/* lwz R11, <#[R31 + 240]> */
		/* 82250680h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000F0) );
		/* 82250680h case    9:*/		return 0x82250684;
		  /* 82250684h */ case   10:  		/* lwz R10, <#[R30 + 240]> */
		/* 82250684h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x000000F0) );
		/* 82250684h case   10:*/		return 0x82250688;
		  /* 82250688h */ case   11:  		/* cmpw CR6, R11, R10 */
		/* 82250688h case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82250688h case   11:*/		return 0x8225068C;
		  /* 8225068Ch */ case   12:  		/* bc 4, CR6_EQ, 1088 */
		/* 8225068Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x82250ACC;  }
		/* 8225068Ch case   12:*/		return 0x82250690;
		  /* 82250690h */ case   13:  		/* li R29, 0 */
		/* 82250690h case   13:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82250690h case   13:*/		return 0x82250694;
		  /* 82250694h */ case   14:  		/* lwz R11, <#[R30]> */
		/* 82250694h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82250694h case   14:*/		return 0x82250698;
		  /* 82250698h */ case   15:  		/* mr R5, R29 */
		/* 82250698h case   15:*/		regs.R5 = regs.R29;
		/* 82250698h case   15:*/		return 0x8225069C;
		  /* 8225069Ch */ case   16:  		/* li R4, 0 */
		/* 8225069Ch case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225069Ch case   16:*/		return 0x822506A0;
		  /* 822506A0h */ case   17:  		/* mr R3, R30 */
		/* 822506A0h case   17:*/		regs.R3 = regs.R30;
		/* 822506A0h case   17:*/		return 0x822506A4;
		  /* 822506A4h */ case   18:  		/* lwz R11, <#[R11 + 80]> */
		/* 822506A4h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 822506A4h case   18:*/		return 0x822506A8;
		  /* 822506A8h */ case   19:  		/* mtspr CTR, R11 */
		/* 822506A8h case   19:*/		regs.CTR = regs.R11;
		/* 822506A8h case   19:*/		return 0x822506AC;
		  /* 822506ACh */ case   20:  		/* bcctrl 20, CR0_LT */
		/* 822506ACh case   20:*/		if ( 1 ) { regs.LR = 0x822506B0; return (uint32)regs.CTR; }
		/* 822506ACh case   20:*/		return 0x822506B0;
		  /* 822506B0h */ case   21:  		/* cmpwi CR6, R3, 1 */
		/* 822506B0h case   21:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 822506B0h case   21:*/		return 0x822506B4;
		  /* 822506B4h */ case   22:  		/* bc 12, CR6_EQ, 184 */
		/* 822506B4h case   22:*/		if ( regs.CR[6].eq ) { return 0x8225076C;  }
		/* 822506B4h case   22:*/		return 0x822506B8;
		  /* 822506B8h */ case   23:  		/* lwz R11, <#[R30]> */
		/* 822506B8h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822506B8h case   23:*/		return 0x822506BC;
		  /* 822506BCh */ case   24:  		/* mr R5, R29 */
		/* 822506BCh case   24:*/		regs.R5 = regs.R29;
		/* 822506BCh case   24:*/		return 0x822506C0;
		  /* 822506C0h */ case   25:  		/* li R4, 0 */
		/* 822506C0h case   25:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822506C0h case   25:*/		return 0x822506C4;
		  /* 822506C4h */ case   26:  		/* lwz R28, <#[R31]> */
		/* 822506C4h case   26:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 822506C4h case   26:*/		return 0x822506C8;
		  /* 822506C8h */ case   27:  		/* mr R3, R30 */
		/* 822506C8h case   27:*/		regs.R3 = regs.R30;
		/* 822506C8h case   27:*/		return 0x822506CC;
		  /* 822506CCh */ case   28:  		/* lwz R11, <#[R11 + 80]> */
		/* 822506CCh case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 822506CCh case   28:*/		return 0x822506D0;
		  /* 822506D0h */ case   29:  		/* mtspr CTR, R11 */
		/* 822506D0h case   29:*/		regs.CTR = regs.R11;
		/* 822506D0h case   29:*/		return 0x822506D4;
		  /* 822506D4h */ case   30:  		/* bcctrl 20, CR0_LT */
		/* 822506D4h case   30:*/		if ( 1 ) { regs.LR = 0x822506D8; return (uint32)regs.CTR; }
		/* 822506D4h case   30:*/		return 0x822506D8;
		  /* 822506D8h */ case   31:  		/* lwz R11, <#[R28 + 84]> */
		/* 822506D8h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000054) );
		/* 822506D8h case   31:*/		return 0x822506DC;
		  /* 822506DCh */ case   32:  		/* mr R6, R3 */
		/* 822506DCh case   32:*/		regs.R6 = regs.R3;
		/* 822506DCh case   32:*/		return 0x822506E0;
		  /* 822506E0h */ case   33:  		/* mr R5, R29 */
		/* 822506E0h case   33:*/		regs.R5 = regs.R29;
		/* 822506E0h case   33:*/		return 0x822506E4;
		  /* 822506E4h */ case   34:  		/* li R4, 0 */
		/* 822506E4h case   34:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822506E4h case   34:*/		return 0x822506E8;
		  /* 822506E8h */ case   35:  		/* mr R3, R31 */
		/* 822506E8h case   35:*/		regs.R3 = regs.R31;
		/* 822506E8h case   35:*/		return 0x822506EC;
		  /* 822506ECh */ case   36:  		/* mtspr CTR, R11 */
		/* 822506ECh case   36:*/		regs.CTR = regs.R11;
		/* 822506ECh case   36:*/		return 0x822506F0;
		  /* 822506F0h */ case   37:  		/* bcctrl 20, CR0_LT */
		/* 822506F0h case   37:*/		if ( 1 ) { regs.LR = 0x822506F4; return (uint32)regs.CTR; }
		/* 822506F0h case   37:*/		return 0x822506F4;
		  /* 822506F4h */ case   38:  		/* lwz R11, <#[R30]> */
		/* 822506F4h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822506F4h case   38:*/		return 0x822506F8;
		  /* 822506F8h */ case   39:  		/* mr R5, R29 */
		/* 822506F8h case   39:*/		regs.R5 = regs.R29;
		/* 822506F8h case   39:*/		return 0x822506FC;
		  /* 822506FCh */ case   40:  		/* li R4, 1 */
		/* 822506FCh case   40:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822506FCh case   40:*/		return 0x82250700;
		  /* 82250700h */ case   41:  		/* mr R3, R30 */
		/* 82250700h case   41:*/		regs.R3 = regs.R30;
		/* 82250700h case   41:*/		return 0x82250704;
		  /* 82250704h */ case   42:  		/* lwz R11, <#[R11 + 80]> */
		/* 82250704h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82250704h case   42:*/		return 0x82250708;
		  /* 82250708h */ case   43:  		/* mtspr CTR, R11 */
		/* 82250708h case   43:*/		regs.CTR = regs.R11;
		/* 82250708h case   43:*/		return 0x8225070C;
		  /* 8225070Ch */ case   44:  		/* lwz R28, <#[R31]> */
		/* 8225070Ch case   44:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 8225070Ch case   44:*/		return 0x82250710;
		  /* 82250710h */ case   45:  		/* bcctrl 20, CR0_LT */
		/* 82250710h case   45:*/		if ( 1 ) { regs.LR = 0x82250714; return (uint32)regs.CTR; }
		/* 82250710h case   45:*/		return 0x82250714;
		  /* 82250714h */ case   46:  		/* lwz R11, <#[R28 + 88]> */
		/* 82250714h case   46:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000058) );
		/* 82250714h case   46:*/		return 0x82250718;
		  /* 82250718h */ case   47:  		/* mr R6, R3 */
		/* 82250718h case   47:*/		regs.R6 = regs.R3;
		/* 82250718h case   47:*/		return 0x8225071C;
		  /* 8225071Ch */ case   48:  		/* mr R5, R29 */
		/* 8225071Ch case   48:*/		regs.R5 = regs.R29;
		/* 8225071Ch case   48:*/		return 0x82250720;
		  /* 82250720h */ case   49:  		/* li R4, 1 */
		/* 82250720h case   49:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82250720h case   49:*/		return 0x82250724;
		  /* 82250724h */ case   50:  		/* mr R3, R31 */
		/* 82250724h case   50:*/		regs.R3 = regs.R31;
		/* 82250724h case   50:*/		return 0x82250728;
		  /* 82250728h */ case   51:  		/* mtspr CTR, R11 */
		/* 82250728h case   51:*/		regs.CTR = regs.R11;
		/* 82250728h case   51:*/		return 0x8225072C;
		  /* 8225072Ch */ case   52:  		/* bcctrl 20, CR0_LT */
		/* 8225072Ch case   52:*/		if ( 1 ) { regs.LR = 0x82250730; return (uint32)regs.CTR; }
		/* 8225072Ch case   52:*/		return 0x82250730;
		  /* 82250730h */ case   53:  		/* lwz R11, <#[R30]> */
		/* 82250730h case   53:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82250730h case   53:*/		return 0x82250734;
		  /* 82250734h */ case   54:  		/* mr R5, R29 */
		/* 82250734h case   54:*/		regs.R5 = regs.R29;
		/* 82250734h case   54:*/		return 0x82250738;
		  /* 82250738h */ case   55:  		/* li R4, 2 */
		/* 82250738h case   55:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 82250738h case   55:*/		return 0x8225073C;
		  /* 8225073Ch */ case   56:  		/* mr R3, R30 */
		/* 8225073Ch case   56:*/		regs.R3 = regs.R30;
		/* 8225073Ch case   56:*/		return 0x82250740;
		  /* 82250740h */ case   57:  		/* lwz R11, <#[R11 + 80]> */
		/* 82250740h case   57:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82250740h case   57:*/		return 0x82250744;
		  /* 82250744h */ case   58:  		/* mtspr CTR, R11 */
		/* 82250744h case   58:*/		regs.CTR = regs.R11;
		/* 82250744h case   58:*/		return 0x82250748;
		  /* 82250748h */ case   59:  		/* lwz R28, <#[R31]> */
		/* 82250748h case   59:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 82250748h case   59:*/		return 0x8225074C;
		  /* 8225074Ch */ case   60:  		/* bcctrl 20, CR0_LT */
		/* 8225074Ch case   60:*/		if ( 1 ) { regs.LR = 0x82250750; return (uint32)regs.CTR; }
		/* 8225074Ch case   60:*/		return 0x82250750;
		  /* 82250750h */ case   61:  		/* lwz R11, <#[R28 + 88]> */
		/* 82250750h case   61:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000058) );
		/* 82250750h case   61:*/		return 0x82250754;
		  /* 82250754h */ case   62:  		/* mr R6, R3 */
		/* 82250754h case   62:*/		regs.R6 = regs.R3;
		/* 82250754h case   62:*/		return 0x82250758;
		  /* 82250758h */ case   63:  		/* mr R5, R29 */
		/* 82250758h case   63:*/		regs.R5 = regs.R29;
		/* 82250758h case   63:*/		return 0x8225075C;
		  /* 8225075Ch */ case   64:  		/* li R4, 2 */
		/* 8225075Ch case   64:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8225075Ch case   64:*/		return 0x82250760;
		  /* 82250760h */ case   65:  		/* mr R3, R31 */
		/* 82250760h case   65:*/		regs.R3 = regs.R31;
		/* 82250760h case   65:*/		return 0x82250764;
		  /* 82250764h */ case   66:  		/* mtspr CTR, R11 */
		/* 82250764h case   66:*/		regs.CTR = regs.R11;
		/* 82250764h case   66:*/		return 0x82250768;
		  /* 82250768h */ case   67:  		/* bcctrl 20, CR0_LT */
		/* 82250768h case   67:*/		if ( 1 ) { regs.LR = 0x8225076C; return (uint32)regs.CTR; }
		/* 82250768h case   67:*/		return 0x8225076C;
	}
	return 0x8225076C;
} // Block from 8225065Ch-8225076Ch (68 instructions)

//////////////////////////////////////////////////////
// Block at 8225076Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225076C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225076C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225076C);
		  /* 8225076Ch */ case    0:  		/* addi R29, R29, 1 */
		/* 8225076Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8225076Ch case    0:*/		return 0x82250770;
		  /* 82250770h */ case    1:  		/* cmpwi CR6, R29, 4 */
		/* 82250770h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000004);
		/* 82250770h case    1:*/		return 0x82250774;
		  /* 82250774h */ case    2:  		/* bc 12, CR6_LT, -224 */
		/* 82250774h case    2:*/		if ( regs.CR[6].lt ) { return 0x82250694;  }
		/* 82250774h case    2:*/		return 0x82250778;
		  /* 82250778h */ case    3:  		/* b 1084 */
		/* 82250778h case    3:*/		return 0x82250BB4;
		/* 82250778h case    3:*/		return 0x8225077C;
	}
	return 0x8225077C;
} // Block from 8225076Ch-8225077Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225077Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225077C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225077C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225077C);
		  /* 8225077Ch */ case    0:  		/* cmpwi CR6, R11, 25 */
		/* 8225077Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000019);
		/* 8225077Ch case    0:*/		return 0x82250780;
		  /* 82250780h */ case    1:  		/* bc 12, CR6_EQ, -492 */
		/* 82250780h case    1:*/		if ( regs.CR[6].eq ) { return 0x82250594;  }
		/* 82250780h case    1:*/		return 0x82250784;
		  /* 82250784h */ case    2:  		/* cmpwi CR6, R11, 26 */
		/* 82250784h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000001A);
		/* 82250784h case    2:*/		return 0x82250788;
		  /* 82250788h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 82250788h case    3:*/		if ( regs.CR[6].eq ) { return 0x822507A4;  }
		/* 82250788h case    3:*/		return 0x8225078C;
		  /* 8225078Ch */ case    4:  		/* cmpwi CR6, R11, 35 */
		/* 8225078Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000023);
		/* 8225078Ch case    4:*/		return 0x82250790;
		  /* 82250790h */ case    5:  		/* bc 4, CR6_GT, 1128 */
		/* 82250790h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82250BF8;  }
		/* 82250790h case    5:*/		return 0x82250794;
		  /* 82250794h */ case    6:  		/* cmpwi CR6, R11, 38 */
		/* 82250794h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000026);
		/* 82250794h case    6:*/		return 0x82250798;
		  /* 82250798h */ case    7:  		/* bc 4, CR6_GT, 308 */
		/* 82250798h case    7:*/		if ( !regs.CR[6].gt ) { return 0x822508CC;  }
		/* 82250798h case    7:*/		return 0x8225079C;
		  /* 8225079Ch */ case    8:  		/* cmpwi CR6, R11, 49 */
		/* 8225079Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000031);
		/* 8225079Ch case    8:*/		return 0x822507A0;
		  /* 822507A0h */ case    9:  		/* bc 4, CR6_EQ, 1112 */
		/* 822507A0h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82250BF8;  }
		/* 822507A0h case    9:*/		return 0x822507A4;
	}
	return 0x822507A4;
} // Block from 8225077Ch-822507A4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822507A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822507A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822507A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822507A4);
		  /* 822507A4h */ case    0:  		/* mr R3, R31 */
		/* 822507A4h case    0:*/		regs.R3 = regs.R31;
		/* 822507A4h case    0:*/		return 0x822507A8;
		  /* 822507A8h */ case    1:  		/* bl -109040 */
		/* 822507A8h case    1:*/		regs.LR = 0x822507AC; return 0x82235DB8;
		/* 822507A8h case    1:*/		return 0x822507AC;
		  /* 822507ACh */ case    2:  		/* lwz R11, <#[R29 + 2152]> */
		/* 822507ACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000868) );
		/* 822507ACh case    2:*/		return 0x822507B0;
		  /* 822507B0h */ case    3:  		/* lwz R10, <#[R3 + 956]> */
		/* 822507B0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x000003BC) );
		/* 822507B0h case    3:*/		return 0x822507B4;
		  /* 822507B4h */ case    4:  		/* mr R30, R3 */
		/* 822507B4h case    4:*/		regs.R30 = regs.R3;
		/* 822507B4h case    4:*/		return 0x822507B8;
		  /* 822507B8h */ case    5:  		/* subf R10, R11, R10 */
		/* 822507B8h case    5:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 822507B8h case    5:*/		return 0x822507BC;
		  /* 822507BCh */ case    6:  		/* rlwinm R11, R10, 1, 31, 31 */
		/* 822507BCh case    6:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R10);
		/* 822507BCh case    6:*/		return 0x822507C0;
		  /* 822507C0h */ case    7:  		/* addi R11, R11, -1 */
		/* 822507C0h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 822507C0h case    7:*/		return 0x822507C4;
		  /* 822507C4h */ case    8:  		/* and R11, R11, R10 */
		/* 822507C4h case    8:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 822507C4h case    8:*/		return 0x822507C8;
		  /* 822507C8h */ case    9:  		/* cmpwi CR6, R11, 1 */
		/* 822507C8h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 822507C8h case    9:*/		return 0x822507CC;
		  /* 822507CCh */ case   10:  		/* bc 12, CR6_GT, 1068 */
		/* 822507CCh case   10:*/		if ( regs.CR[6].gt ) { return 0x82250BF8;  }
		/* 822507CCh case   10:*/		return 0x822507D0;
		  /* 822507D0h */ case   11:  		/* lwz R11, <#[R31 + 24]> */
		/* 822507D0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 822507D0h case   11:*/		return 0x822507D4;
		  /* 822507D4h */ case   12:  		/* lwz R10, <#[R3 + 24]> */
		/* 822507D4h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 822507D4h case   12:*/		return 0x822507D8;
		  /* 822507D8h */ case   13:  		/* cmpw CR6, R11, R10 */
		/* 822507D8h case   13:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 822507D8h case   13:*/		return 0x822507DC;
		  /* 822507DCh */ case   14:  		/* bc 4, CR6_EQ, 1052 */
		/* 822507DCh case   14:*/		if ( !regs.CR[6].eq ) { return 0x82250BF8;  }
		/* 822507DCh case   14:*/		return 0x822507E0;
		  /* 822507E0h */ case   15:  		/* mr R4, R3 */
		/* 822507E0h case   15:*/		regs.R4 = regs.R3;
		/* 822507E0h case   15:*/		return 0x822507E4;
		  /* 822507E4h */ case   16:  		/* mr R3, R31 */
		/* 822507E4h case   16:*/		regs.R3 = regs.R31;
		/* 822507E4h case   16:*/		return 0x822507E8;
		  /* 822507E8h */ case   17:  		/* bl 21944 */
		/* 822507E8h case   17:*/		regs.LR = 0x822507EC; return 0x82255DA0;
		/* 822507E8h case   17:*/		return 0x822507EC;
		  /* 822507ECh */ case   18:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822507ECh case   18:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822507ECh case   18:*/		return 0x822507F0;
		  /* 822507F0h */ case   19:  		/* bc 12, CR0_EQ, 1032 */
		/* 822507F0h case   19:*/		if ( regs.CR[0].eq ) { return 0x82250BF8;  }
		/* 822507F0h case   19:*/		return 0x822507F4;
		  /* 822507F4h */ case   20:  		/* mr R4, R30 */
		/* 822507F4h case   20:*/		regs.R4 = regs.R30;
		/* 822507F4h case   20:*/		return 0x822507F8;
		  /* 822507F8h */ case   21:  		/* mr R3, R31 */
		/* 822507F8h case   21:*/		regs.R3 = regs.R31;
		/* 822507F8h case   21:*/		return 0x822507FC;
		  /* 822507FCh */ case   22:  		/* bl 21756 */
		/* 822507FCh case   22:*/		regs.LR = 0x82250800; return 0x82255CF8;
		/* 822507FCh case   22:*/		return 0x82250800;
		  /* 82250800h */ case   23:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82250800h case   23:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82250800h case   23:*/		return 0x82250804;
		  /* 82250804h */ case   24:  		/* bc 12, CR0_EQ, 1012 */
		/* 82250804h case   24:*/		if ( regs.CR[0].eq ) { return 0x82250BF8;  }
		/* 82250804h case   24:*/		return 0x82250808;
		  /* 82250808h */ case   25:  		/* lwz R11, <#[R31 + 236]> */
		/* 82250808h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000EC) );
		/* 82250808h case   25:*/		return 0x8225080C;
		  /* 8225080Ch */ case   26:  		/* lwz R10, <#[R30 + 236]> */
		/* 8225080Ch case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x000000EC) );
		/* 8225080Ch case   26:*/		return 0x82250810;
		  /* 82250810h */ case   27:  		/* cmpw CR6, R11, R10 */
		/* 82250810h case   27:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82250810h case   27:*/		return 0x82250814;
		  /* 82250814h */ case   28:  		/* bc 4, CR6_EQ, 996 */
		/* 82250814h case   28:*/		if ( !regs.CR[6].eq ) { return 0x82250BF8;  }
		/* 82250814h case   28:*/		return 0x82250818;
		  /* 82250818h */ case   29:  		/* li R29, 0 */
		/* 82250818h case   29:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82250818h case   29:*/		return 0x8225081C;
		  /* 8225081Ch */ case   30:  		/* lwz R11, <#[R30]> */
		/* 8225081Ch case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225081Ch case   30:*/		return 0x82250820;
		  /* 82250820h */ case   31:  		/* mr R5, R29 */
		/* 82250820h case   31:*/		regs.R5 = regs.R29;
		/* 82250820h case   31:*/		return 0x82250824;
		  /* 82250824h */ case   32:  		/* li R4, 0 */
		/* 82250824h case   32:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82250824h case   32:*/		return 0x82250828;
		  /* 82250828h */ case   33:  		/* mr R3, R30 */
		/* 82250828h case   33:*/		regs.R3 = regs.R30;
		/* 82250828h case   33:*/		return 0x8225082C;
		  /* 8225082Ch */ case   34:  		/* lwz R11, <#[R11 + 80]> */
		/* 8225082Ch case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 8225082Ch case   34:*/		return 0x82250830;
		  /* 82250830h */ case   35:  		/* mtspr CTR, R11 */
		/* 82250830h case   35:*/		regs.CTR = regs.R11;
		/* 82250830h case   35:*/		return 0x82250834;
		  /* 82250834h */ case   36:  		/* bcctrl 20, CR0_LT */
		/* 82250834h case   36:*/		if ( 1 ) { regs.LR = 0x82250838; return (uint32)regs.CTR; }
		/* 82250834h case   36:*/		return 0x82250838;
		  /* 82250838h */ case   37:  		/* cmpwi CR6, R3, 1 */
		/* 82250838h case   37:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82250838h case   37:*/		return 0x8225083C;
		  /* 8225083Ch */ case   38:  		/* bc 12, CR6_EQ, 124 */
		/* 8225083Ch case   38:*/		if ( regs.CR[6].eq ) { return 0x822508B8;  }
		/* 8225083Ch case   38:*/		return 0x82250840;
		  /* 82250840h */ case   39:  		/* lwz R11, <#[R30]> */
		/* 82250840h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82250840h case   39:*/		return 0x82250844;
		  /* 82250844h */ case   40:  		/* mr R5, R29 */
		/* 82250844h case   40:*/		regs.R5 = regs.R29;
		/* 82250844h case   40:*/		return 0x82250848;
		  /* 82250848h */ case   41:  		/* li R4, 0 */
		/* 82250848h case   41:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82250848h case   41:*/		return 0x8225084C;
		  /* 8225084Ch */ case   42:  		/* lwz R28, <#[R31]> */
		/* 8225084Ch case   42:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 8225084Ch case   42:*/		return 0x82250850;
		  /* 82250850h */ case   43:  		/* mr R3, R30 */
		/* 82250850h case   43:*/		regs.R3 = regs.R30;
		/* 82250850h case   43:*/		return 0x82250854;
		  /* 82250854h */ case   44:  		/* lwz R11, <#[R11 + 80]> */
		/* 82250854h case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82250854h case   44:*/		return 0x82250858;
		  /* 82250858h */ case   45:  		/* mtspr CTR, R11 */
		/* 82250858h case   45:*/		regs.CTR = regs.R11;
		/* 82250858h case   45:*/		return 0x8225085C;
		  /* 8225085Ch */ case   46:  		/* bcctrl 20, CR0_LT */
		/* 8225085Ch case   46:*/		if ( 1 ) { regs.LR = 0x82250860; return (uint32)regs.CTR; }
		/* 8225085Ch case   46:*/		return 0x82250860;
		  /* 82250860h */ case   47:  		/* lwz R11, <#[R28 + 84]> */
		/* 82250860h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000054) );
		/* 82250860h case   47:*/		return 0x82250864;
		  /* 82250864h */ case   48:  		/* mr R6, R3 */
		/* 82250864h case   48:*/		regs.R6 = regs.R3;
		/* 82250864h case   48:*/		return 0x82250868;
		  /* 82250868h */ case   49:  		/* mr R5, R29 */
		/* 82250868h case   49:*/		regs.R5 = regs.R29;
		/* 82250868h case   49:*/		return 0x8225086C;
		  /* 8225086Ch */ case   50:  		/* li R4, 0 */
		/* 8225086Ch case   50:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225086Ch case   50:*/		return 0x82250870;
		  /* 82250870h */ case   51:  		/* mr R3, R31 */
		/* 82250870h case   51:*/		regs.R3 = regs.R31;
		/* 82250870h case   51:*/		return 0x82250874;
		  /* 82250874h */ case   52:  		/* mtspr CTR, R11 */
		/* 82250874h case   52:*/		regs.CTR = regs.R11;
		/* 82250874h case   52:*/		return 0x82250878;
		  /* 82250878h */ case   53:  		/* bcctrl 20, CR0_LT */
		/* 82250878h case   53:*/		if ( 1 ) { regs.LR = 0x8225087C; return (uint32)regs.CTR; }
		/* 82250878h case   53:*/		return 0x8225087C;
		  /* 8225087Ch */ case   54:  		/* lwz R11, <#[R30]> */
		/* 8225087Ch case   54:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225087Ch case   54:*/		return 0x82250880;
		  /* 82250880h */ case   55:  		/* mr R5, R29 */
		/* 82250880h case   55:*/		regs.R5 = regs.R29;
		/* 82250880h case   55:*/		return 0x82250884;
		  /* 82250884h */ case   56:  		/* li R4, 1 */
		/* 82250884h case   56:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82250884h case   56:*/		return 0x82250888;
		  /* 82250888h */ case   57:  		/* mr R3, R30 */
		/* 82250888h case   57:*/		regs.R3 = regs.R30;
		/* 82250888h case   57:*/		return 0x8225088C;
		  /* 8225088Ch */ case   58:  		/* lwz R11, <#[R11 + 80]> */
		/* 8225088Ch case   58:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 8225088Ch case   58:*/		return 0x82250890;
		  /* 82250890h */ case   59:  		/* mtspr CTR, R11 */
		/* 82250890h case   59:*/		regs.CTR = regs.R11;
		/* 82250890h case   59:*/		return 0x82250894;
		  /* 82250894h */ case   60:  		/* lwz R28, <#[R31]> */
		/* 82250894h case   60:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 82250894h case   60:*/		return 0x82250898;
		  /* 82250898h */ case   61:  		/* bcctrl 20, CR0_LT */
		/* 82250898h case   61:*/		if ( 1 ) { regs.LR = 0x8225089C; return (uint32)regs.CTR; }
		/* 82250898h case   61:*/		return 0x8225089C;
		  /* 8225089Ch */ case   62:  		/* lwz R11, <#[R28 + 88]> */
		/* 8225089Ch case   62:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000058) );
		/* 8225089Ch case   62:*/		return 0x822508A0;
		  /* 822508A0h */ case   63:  		/* mr R6, R3 */
		/* 822508A0h case   63:*/		regs.R6 = regs.R3;
		/* 822508A0h case   63:*/		return 0x822508A4;
		  /* 822508A4h */ case   64:  		/* mr R5, R29 */
		/* 822508A4h case   64:*/		regs.R5 = regs.R29;
		/* 822508A4h case   64:*/		return 0x822508A8;
		  /* 822508A8h */ case   65:  		/* li R4, 1 */
		/* 822508A8h case   65:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822508A8h case   65:*/		return 0x822508AC;
		  /* 822508ACh */ case   66:  		/* mr R3, R31 */
		/* 822508ACh case   66:*/		regs.R3 = regs.R31;
		/* 822508ACh case   66:*/		return 0x822508B0;
		  /* 822508B0h */ case   67:  		/* mtspr CTR, R11 */
		/* 822508B0h case   67:*/		regs.CTR = regs.R11;
		/* 822508B0h case   67:*/		return 0x822508B4;
		  /* 822508B4h */ case   68:  		/* bcctrl 20, CR0_LT */
		/* 822508B4h case   68:*/		if ( 1 ) { regs.LR = 0x822508B8; return (uint32)regs.CTR; }
		/* 822508B4h case   68:*/		return 0x822508B8;
	}
	return 0x822508B8;
} // Block from 822507A4h-822508B8h (69 instructions)

//////////////////////////////////////////////////////
// Block at 822508B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822508B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822508B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822508B8);
		  /* 822508B8h */ case    0:  		/* addi R29, R29, 1 */
		/* 822508B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 822508B8h case    0:*/		return 0x822508BC;
		  /* 822508BCh */ case    1:  		/* cmpwi CR6, R29, 4 */
		/* 822508BCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000004);
		/* 822508BCh case    1:*/		return 0x822508C0;
		  /* 822508C0h */ case    2:  		/* bc 12, CR6_LT, -164 */
		/* 822508C0h case    2:*/		if ( regs.CR[6].lt ) { return 0x8225081C;  }
		/* 822508C0h case    2:*/		return 0x822508C4;
		  /* 822508C4h */ case    3:  		/* lwz R10, <#[R30 + 240]> */
		/* 822508C4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x000000F0) );
		/* 822508C4h case    3:*/		return 0x822508C8;
	}
	return 0x822508C8;
} // Block from 822508B8h-822508C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822508C8h
// Function '?MarkUsedChannels@XGRAPHICS@@YA?ATSwizzleOrMaskInfo@1@PAVIRInst@1@HPAVCFG@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822508C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822508C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822508C8);
		  /* 822508C8h */ case    0:  		/* b 752 */
		/* 822508C8h case    0:*/		return 0x82250BB8;
		/* 822508C8h case    0:*/		return 0x822508CC;
	}
	return 0x822508CC;
} // Block from 822508C8h-822508CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822508CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822508CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822508CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822508CC);
		  /* 822508CCh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 822508CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822508CCh case    0:*/		return 0x822508D0;
		  /* 822508D0h */ case    1:  		/* mr R3, R31 */
		/* 822508D0h case    1:*/		regs.R3 = regs.R31;
		/* 822508D0h case    1:*/		return 0x822508D4;
		  /* 822508D4h */ case    2:  		/* lwz R11, <#[R11 + 4]> */
		/* 822508D4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822508D4h case    2:*/		return 0x822508D8;
		  /* 822508D8h */ case    3:  		/* mtspr CTR, R11 */
		/* 822508D8h case    3:*/		regs.CTR = regs.R11;
		/* 822508D8h case    3:*/		return 0x822508DC;
		  /* 822508DCh */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 822508DCh case    4:*/		if ( 1 ) { regs.LR = 0x822508E0; return (uint32)regs.CTR; }
		/* 822508DCh case    4:*/		return 0x822508E0;
		  /* 822508E0h */ case    5:  		/* cmpwi CR6, R3, 3 */
		/* 822508E0h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000003);
		/* 822508E0h case    5:*/		return 0x822508E4;
		  /* 822508E4h */ case    6:  		/* bc 12, CR6_EQ, 40 */
		/* 822508E4h case    6:*/		if ( regs.CR[6].eq ) { return 0x8225090C;  }
		/* 822508E4h case    6:*/		return 0x822508E8;
		  /* 822508E8h */ case    7:  		/* lis R11, -32252 */
		/* 822508E8h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822508E8h case    7:*/		return 0x822508EC;
		  /* 822508ECh */ case    8:  		/* lis R10, -32252 */
		/* 822508ECh case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 822508ECh case    8:*/		return 0x822508F0;
		  /* 822508F0h */ case    9:  		/* lis R9, -32253 */
		/* 822508F0h case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 822508F0h case    9:*/		return 0x822508F4;
		  /* 822508F4h */ case   10:  		/* addi R6, R11, 16232 */
		/* 822508F4h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x3F68);
		/* 822508F4h case   10:*/		return 0x822508F8;
		  /* 822508F8h */ case   11:  		/* addi R5, R10, 16324 */
		/* 822508F8h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x3FC4);
		/* 822508F8h case   11:*/		return 0x822508FC;
		  /* 822508FCh */ case   12:  		/* addi R4, R9, 27460 */
		/* 822508FCh case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 822508FCh case   12:*/		return 0x82250900;
		  /* 82250900h */ case   13:  		/* li R7, 1118 */
		/* 82250900h case   13:*/		cpu::op::li<0>(regs,&regs.R7,0x45E);
		/* 82250900h case   13:*/		return 0x82250904;
		  /* 82250904h */ case   14:  		/* li R3, 0 */
		/* 82250904h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82250904h case   14:*/		return 0x82250908;
		  /* 82250908h */ case   15:  		/* bl -1019136 */
		/* 82250908h case   15:*/		regs.LR = 0x8225090C; return 0x82157C08;
		/* 82250908h case   15:*/		return 0x8225090C;
	}
	return 0x8225090C;
} // Block from 822508CCh-8225090Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8225090Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225090C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225090C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225090C);
		  /* 8225090Ch */ case    0:  		/* mr R3, R31 */
		/* 8225090Ch case    0:*/		regs.R3 = regs.R31;
		/* 8225090Ch case    0:*/		return 0x82250910;
		  /* 82250910h */ case    1:  		/* bl -109400 */
		/* 82250910h case    1:*/		regs.LR = 0x82250914; return 0x82235DB8;
		/* 82250910h case    1:*/		return 0x82250914;
		  /* 82250914h */ case    2:  		/* lwz R11, <#[R29 + 2152]> */
		/* 82250914h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000868) );
		/* 82250914h case    2:*/		return 0x82250918;
		  /* 82250918h */ case    3:  		/* lwz R10, <#[R3 + 956]> */
		/* 82250918h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x000003BC) );
		/* 82250918h case    3:*/		return 0x8225091C;
		  /* 8225091Ch */ case    4:  		/* mr R30, R3 */
		/* 8225091Ch case    4:*/		regs.R30 = regs.R3;
		/* 8225091Ch case    4:*/		return 0x82250920;
		  /* 82250920h */ case    5:  		/* subf R10, R11, R10 */
		/* 82250920h case    5:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82250920h case    5:*/		return 0x82250924;
		  /* 82250924h */ case    6:  		/* rlwinm R11, R10, 1, 31, 31 */
		/* 82250924h case    6:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R10);
		/* 82250924h case    6:*/		return 0x82250928;
		  /* 82250928h */ case    7:  		/* addi R11, R11, -1 */
		/* 82250928h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82250928h case    7:*/		return 0x8225092C;
		  /* 8225092Ch */ case    8:  		/* and R11, R11, R10 */
		/* 8225092Ch case    8:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8225092Ch case    8:*/		return 0x82250930;
		  /* 82250930h */ case    9:  		/* cmpwi CR6, R11, 1 */
		/* 82250930h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 82250930h case    9:*/		return 0x82250934;
		  /* 82250934h */ case   10:  		/* bc 12, CR6_GT, 708 */
		/* 82250934h case   10:*/		if ( regs.CR[6].gt ) { return 0x82250BF8;  }
		/* 82250934h case   10:*/		return 0x82250938;
		  /* 82250938h */ case   11:  		/* lwz R11, <#[R31 + 24]> */
		/* 82250938h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82250938h case   11:*/		return 0x8225093C;
		  /* 8225093Ch */ case   12:  		/* lwz R10, <#[R3 + 24]> */
		/* 8225093Ch case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 8225093Ch case   12:*/		return 0x82250940;
		  /* 82250940h */ case   13:  		/* cmpw CR6, R11, R10 */
		/* 82250940h case   13:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82250940h case   13:*/		return 0x82250944;
		  /* 82250944h */ case   14:  		/* bc 4, CR6_EQ, 692 */
		/* 82250944h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82250BF8;  }
		/* 82250944h case   14:*/		return 0x82250948;
		  /* 82250948h */ case   15:  		/* mr R4, R3 */
		/* 82250948h case   15:*/		regs.R4 = regs.R3;
		/* 82250948h case   15:*/		return 0x8225094C;
		  /* 8225094Ch */ case   16:  		/* mr R3, R31 */
		/* 8225094Ch case   16:*/		regs.R3 = regs.R31;
		/* 8225094Ch case   16:*/		return 0x82250950;
		  /* 82250950h */ case   17:  		/* bl 21584 */
		/* 82250950h case   17:*/		regs.LR = 0x82250954; return 0x82255DA0;
		/* 82250950h case   17:*/		return 0x82250954;
		  /* 82250954h */ case   18:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82250954h case   18:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82250954h case   18:*/		return 0x82250958;
		  /* 82250958h */ case   19:  		/* bc 12, CR0_EQ, 672 */
		/* 82250958h case   19:*/		if ( regs.CR[0].eq ) { return 0x82250BF8;  }
		/* 82250958h case   19:*/		return 0x8225095C;
		  /* 8225095Ch */ case   20:  		/* mr R4, R30 */
		/* 8225095Ch case   20:*/		regs.R4 = regs.R30;
		/* 8225095Ch case   20:*/		return 0x82250960;
		  /* 82250960h */ case   21:  		/* mr R3, R31 */
		/* 82250960h case   21:*/		regs.R3 = regs.R31;
		/* 82250960h case   21:*/		return 0x82250964;
		  /* 82250964h */ case   22:  		/* bl 21396 */
		/* 82250964h case   22:*/		regs.LR = 0x82250968; return 0x82255CF8;
		/* 82250964h case   22:*/		return 0x82250968;
		  /* 82250968h */ case   23:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82250968h case   23:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82250968h case   23:*/		return 0x8225096C;
		  /* 8225096Ch */ case   24:  		/* bc 12, CR0_EQ, 652 */
		/* 8225096Ch case   24:*/		if ( regs.CR[0].eq ) { return 0x82250BF8;  }
		/* 8225096Ch case   24:*/		return 0x82250970;
		  /* 82250970h */ case   25:  		/* lwz R11, <#[R31 + 236]> */
		/* 82250970h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000EC) );
		/* 82250970h case   25:*/		return 0x82250974;
		  /* 82250974h */ case   26:  		/* lwz R10, <#[R30 + 236]> */
		/* 82250974h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x000000EC) );
		/* 82250974h case   26:*/		return 0x82250978;
		  /* 82250978h */ case   27:  		/* cmpw CR6, R11, R10 */
		/* 82250978h case   27:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82250978h case   27:*/		return 0x8225097C;
		  /* 8225097Ch */ case   28:  		/* bc 4, CR6_EQ, 636 */
		/* 8225097Ch case   28:*/		if ( !regs.CR[6].eq ) { return 0x82250BF8;  }
		/* 8225097Ch case   28:*/		return 0x82250980;
		  /* 82250980h */ case   29:  		/* lwz R11, <#[R31 + 240]> */
		/* 82250980h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000F0) );
		/* 82250980h case   29:*/		return 0x82250984;
		  /* 82250984h */ case   30:  		/* lwz R10, <#[R30 + 240]> */
		/* 82250984h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x000000F0) );
		/* 82250984h case   30:*/		return 0x82250988;
		  /* 82250988h */ case   31:  		/* cmpw CR6, R11, R10 */
		/* 82250988h case   31:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82250988h case   31:*/		return 0x8225098C;
		  /* 8225098Ch */ case   32:  		/* bc 4, CR6_EQ, 620 */
		/* 8225098Ch case   32:*/		if ( !regs.CR[6].eq ) { return 0x82250BF8;  }
		/* 8225098Ch case   32:*/		return 0x82250990;
		  /* 82250990h */ case   33:  		/* lwz R11, <#[R31 + 244]> */
		/* 82250990h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000F4) );
		/* 82250990h case   33:*/		return 0x82250994;
		  /* 82250994h */ case   34:  		/* lwz R10, <#[R30 + 244]> */
		/* 82250994h case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x000000F4) );
		/* 82250994h case   34:*/		return 0x82250998;
		  /* 82250998h */ case   35:  		/* cmpw CR6, R11, R10 */
		/* 82250998h case   35:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82250998h case   35:*/		return 0x8225099C;
		  /* 8225099Ch */ case   36:  		/* bc 4, CR6_EQ, 604 */
		/* 8225099Ch case   36:*/		if ( !regs.CR[6].eq ) { return 0x82250BF8;  }
		/* 8225099Ch case   36:*/		return 0x822509A0;
		  /* 822509A0h */ case   37:  		/* li R29, 0 */
		/* 822509A0h case   37:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 822509A0h case   37:*/		return 0x822509A4;
		  /* 822509A4h */ case   38:  		/* lwz R11, <#[R30]> */
		/* 822509A4h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822509A4h case   38:*/		return 0x822509A8;
		  /* 822509A8h */ case   39:  		/* mr R5, R29 */
		/* 822509A8h case   39:*/		regs.R5 = regs.R29;
		/* 822509A8h case   39:*/		return 0x822509AC;
		  /* 822509ACh */ case   40:  		/* li R4, 0 */
		/* 822509ACh case   40:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822509ACh case   40:*/		return 0x822509B0;
		  /* 822509B0h */ case   41:  		/* mr R3, R30 */
		/* 822509B0h case   41:*/		regs.R3 = regs.R30;
		/* 822509B0h case   41:*/		return 0x822509B4;
		  /* 822509B4h */ case   42:  		/* lwz R11, <#[R11 + 80]> */
		/* 822509B4h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 822509B4h case   42:*/		return 0x822509B8;
		  /* 822509B8h */ case   43:  		/* mtspr CTR, R11 */
		/* 822509B8h case   43:*/		regs.CTR = regs.R11;
		/* 822509B8h case   43:*/		return 0x822509BC;
		  /* 822509BCh */ case   44:  		/* bcctrl 20, CR0_LT */
		/* 822509BCh case   44:*/		if ( 1 ) { regs.LR = 0x822509C0; return (uint32)regs.CTR; }
		/* 822509BCh case   44:*/		return 0x822509C0;
		  /* 822509C0h */ case   45:  		/* cmpwi CR6, R3, 1 */
		/* 822509C0h case   45:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 822509C0h case   45:*/		return 0x822509C4;
		  /* 822509C4h */ case   46:  		/* bc 12, CR6_EQ, 244 */
		/* 822509C4h case   46:*/		if ( regs.CR[6].eq ) { return 0x82250AB8;  }
		/* 822509C4h case   46:*/		return 0x822509C8;
		  /* 822509C8h */ case   47:  		/* lwz R11, <#[R30]> */
		/* 822509C8h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822509C8h case   47:*/		return 0x822509CC;
		  /* 822509CCh */ case   48:  		/* mr R5, R29 */
		/* 822509CCh case   48:*/		regs.R5 = regs.R29;
		/* 822509CCh case   48:*/		return 0x822509D0;
		  /* 822509D0h */ case   49:  		/* li R4, 0 */
		/* 822509D0h case   49:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822509D0h case   49:*/		return 0x822509D4;
		  /* 822509D4h */ case   50:  		/* lwz R28, <#[R31]> */
		/* 822509D4h case   50:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 822509D4h case   50:*/		return 0x822509D8;
		  /* 822509D8h */ case   51:  		/* mr R3, R30 */
		/* 822509D8h case   51:*/		regs.R3 = regs.R30;
		/* 822509D8h case   51:*/		return 0x822509DC;
		  /* 822509DCh */ case   52:  		/* lwz R11, <#[R11 + 80]> */
		/* 822509DCh case   52:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 822509DCh case   52:*/		return 0x822509E0;
		  /* 822509E0h */ case   53:  		/* mtspr CTR, R11 */
		/* 822509E0h case   53:*/		regs.CTR = regs.R11;
		/* 822509E0h case   53:*/		return 0x822509E4;
		  /* 822509E4h */ case   54:  		/* bcctrl 20, CR0_LT */
		/* 822509E4h case   54:*/		if ( 1 ) { regs.LR = 0x822509E8; return (uint32)regs.CTR; }
		/* 822509E4h case   54:*/		return 0x822509E8;
		  /* 822509E8h */ case   55:  		/* lwz R11, <#[R28 + 84]> */
		/* 822509E8h case   55:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000054) );
		/* 822509E8h case   55:*/		return 0x822509EC;
		  /* 822509ECh */ case   56:  		/* mr R6, R3 */
		/* 822509ECh case   56:*/		regs.R6 = regs.R3;
		/* 822509ECh case   56:*/		return 0x822509F0;
		  /* 822509F0h */ case   57:  		/* mr R5, R29 */
		/* 822509F0h case   57:*/		regs.R5 = regs.R29;
		/* 822509F0h case   57:*/		return 0x822509F4;
		  /* 822509F4h */ case   58:  		/* li R4, 0 */
		/* 822509F4h case   58:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822509F4h case   58:*/		return 0x822509F8;
		  /* 822509F8h */ case   59:  		/* mr R3, R31 */
		/* 822509F8h case   59:*/		regs.R3 = regs.R31;
		/* 822509F8h case   59:*/		return 0x822509FC;
		  /* 822509FCh */ case   60:  		/* mtspr CTR, R11 */
		/* 822509FCh case   60:*/		regs.CTR = regs.R11;
		/* 822509FCh case   60:*/		return 0x82250A00;
		  /* 82250A00h */ case   61:  		/* bcctrl 20, CR0_LT */
		/* 82250A00h case   61:*/		if ( 1 ) { regs.LR = 0x82250A04; return (uint32)regs.CTR; }
		/* 82250A00h case   61:*/		return 0x82250A04;
		  /* 82250A04h */ case   62:  		/* lwz R11, <#[R30]> */
		/* 82250A04h case   62:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82250A04h case   62:*/		return 0x82250A08;
		  /* 82250A08h */ case   63:  		/* mr R5, R29 */
		/* 82250A08h case   63:*/		regs.R5 = regs.R29;
		/* 82250A08h case   63:*/		return 0x82250A0C;
		  /* 82250A0Ch */ case   64:  		/* li R4, 1 */
		/* 82250A0Ch case   64:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82250A0Ch case   64:*/		return 0x82250A10;
		  /* 82250A10h */ case   65:  		/* mr R3, R30 */
		/* 82250A10h case   65:*/		regs.R3 = regs.R30;
		/* 82250A10h case   65:*/		return 0x82250A14;
		  /* 82250A14h */ case   66:  		/* lwz R11, <#[R11 + 80]> */
		/* 82250A14h case   66:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82250A14h case   66:*/		return 0x82250A18;
		  /* 82250A18h */ case   67:  		/* mtspr CTR, R11 */
		/* 82250A18h case   67:*/		regs.CTR = regs.R11;
		/* 82250A18h case   67:*/		return 0x82250A1C;
		  /* 82250A1Ch */ case   68:  		/* lwz R28, <#[R31]> */
		/* 82250A1Ch case   68:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 82250A1Ch case   68:*/		return 0x82250A20;
		  /* 82250A20h */ case   69:  		/* bcctrl 20, CR0_LT */
		/* 82250A20h case   69:*/		if ( 1 ) { regs.LR = 0x82250A24; return (uint32)regs.CTR; }
		/* 82250A20h case   69:*/		return 0x82250A24;
		  /* 82250A24h */ case   70:  		/* lwz R11, <#[R28 + 88]> */
		/* 82250A24h case   70:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000058) );
		/* 82250A24h case   70:*/		return 0x82250A28;
		  /* 82250A28h */ case   71:  		/* mr R6, R3 */
		/* 82250A28h case   71:*/		regs.R6 = regs.R3;
		/* 82250A28h case   71:*/		return 0x82250A2C;
		  /* 82250A2Ch */ case   72:  		/* mr R5, R29 */
		/* 82250A2Ch case   72:*/		regs.R5 = regs.R29;
		/* 82250A2Ch case   72:*/		return 0x82250A30;
		  /* 82250A30h */ case   73:  		/* li R4, 1 */
		/* 82250A30h case   73:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82250A30h case   73:*/		return 0x82250A34;
		  /* 82250A34h */ case   74:  		/* mr R3, R31 */
		/* 82250A34h case   74:*/		regs.R3 = regs.R31;
		/* 82250A34h case   74:*/		return 0x82250A38;
		  /* 82250A38h */ case   75:  		/* mtspr CTR, R11 */
		/* 82250A38h case   75:*/		regs.CTR = regs.R11;
		/* 82250A38h case   75:*/		return 0x82250A3C;
		  /* 82250A3Ch */ case   76:  		/* bcctrl 20, CR0_LT */
		/* 82250A3Ch case   76:*/		if ( 1 ) { regs.LR = 0x82250A40; return (uint32)regs.CTR; }
		/* 82250A3Ch case   76:*/		return 0x82250A40;
		  /* 82250A40h */ case   77:  		/* lwz R11, <#[R30]> */
		/* 82250A40h case   77:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82250A40h case   77:*/		return 0x82250A44;
		  /* 82250A44h */ case   78:  		/* mr R5, R29 */
		/* 82250A44h case   78:*/		regs.R5 = regs.R29;
		/* 82250A44h case   78:*/		return 0x82250A48;
		  /* 82250A48h */ case   79:  		/* li R4, 2 */
		/* 82250A48h case   79:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 82250A48h case   79:*/		return 0x82250A4C;
		  /* 82250A4Ch */ case   80:  		/* mr R3, R30 */
		/* 82250A4Ch case   80:*/		regs.R3 = regs.R30;
		/* 82250A4Ch case   80:*/		return 0x82250A50;
		  /* 82250A50h */ case   81:  		/* lwz R11, <#[R11 + 80]> */
		/* 82250A50h case   81:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82250A50h case   81:*/		return 0x82250A54;
		  /* 82250A54h */ case   82:  		/* mtspr CTR, R11 */
		/* 82250A54h case   82:*/		regs.CTR = regs.R11;
		/* 82250A54h case   82:*/		return 0x82250A58;
		  /* 82250A58h */ case   83:  		/* lwz R28, <#[R31]> */
		/* 82250A58h case   83:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 82250A58h case   83:*/		return 0x82250A5C;
		  /* 82250A5Ch */ case   84:  		/* bcctrl 20, CR0_LT */
		/* 82250A5Ch case   84:*/		if ( 1 ) { regs.LR = 0x82250A60; return (uint32)regs.CTR; }
		/* 82250A5Ch case   84:*/		return 0x82250A60;
		  /* 82250A60h */ case   85:  		/* lwz R11, <#[R28 + 88]> */
		/* 82250A60h case   85:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000058) );
		/* 82250A60h case   85:*/		return 0x82250A64;
		  /* 82250A64h */ case   86:  		/* mr R6, R3 */
		/* 82250A64h case   86:*/		regs.R6 = regs.R3;
		/* 82250A64h case   86:*/		return 0x82250A68;
		  /* 82250A68h */ case   87:  		/* mr R5, R29 */
		/* 82250A68h case   87:*/		regs.R5 = regs.R29;
		/* 82250A68h case   87:*/		return 0x82250A6C;
		  /* 82250A6Ch */ case   88:  		/* li R4, 2 */
		/* 82250A6Ch case   88:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 82250A6Ch case   88:*/		return 0x82250A70;
		  /* 82250A70h */ case   89:  		/* mr R3, R31 */
		/* 82250A70h case   89:*/		regs.R3 = regs.R31;
		/* 82250A70h case   89:*/		return 0x82250A74;
		  /* 82250A74h */ case   90:  		/* mtspr CTR, R11 */
		/* 82250A74h case   90:*/		regs.CTR = regs.R11;
		/* 82250A74h case   90:*/		return 0x82250A78;
		  /* 82250A78h */ case   91:  		/* bcctrl 20, CR0_LT */
		/* 82250A78h case   91:*/		if ( 1 ) { regs.LR = 0x82250A7C; return (uint32)regs.CTR; }
		/* 82250A78h case   91:*/		return 0x82250A7C;
		  /* 82250A7Ch */ case   92:  		/* lwz R11, <#[R30]> */
		/* 82250A7Ch case   92:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82250A7Ch case   92:*/		return 0x82250A80;
		  /* 82250A80h */ case   93:  		/* mr R5, R29 */
		/* 82250A80h case   93:*/		regs.R5 = regs.R29;
		/* 82250A80h case   93:*/		return 0x82250A84;
		  /* 82250A84h */ case   94:  		/* li R4, 3 */
		/* 82250A84h case   94:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 82250A84h case   94:*/		return 0x82250A88;
		  /* 82250A88h */ case   95:  		/* mr R3, R30 */
		/* 82250A88h case   95:*/		regs.R3 = regs.R30;
		/* 82250A88h case   95:*/		return 0x82250A8C;
		  /* 82250A8Ch */ case   96:  		/* lwz R11, <#[R11 + 80]> */
		/* 82250A8Ch case   96:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82250A8Ch case   96:*/		return 0x82250A90;
		  /* 82250A90h */ case   97:  		/* mtspr CTR, R11 */
		/* 82250A90h case   97:*/		regs.CTR = regs.R11;
		/* 82250A90h case   97:*/		return 0x82250A94;
		  /* 82250A94h */ case   98:  		/* lwz R28, <#[R31]> */
		/* 82250A94h case   98:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 82250A94h case   98:*/		return 0x82250A98;
		  /* 82250A98h */ case   99:  		/* bcctrl 20, CR0_LT */
		/* 82250A98h case   99:*/		if ( 1 ) { regs.LR = 0x82250A9C; return (uint32)regs.CTR; }
		/* 82250A98h case   99:*/		return 0x82250A9C;
		  /* 82250A9Ch */ case  100:  		/* lwz R11, <#[R28 + 88]> */
		/* 82250A9Ch case  100:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000058) );
		/* 82250A9Ch case  100:*/		return 0x82250AA0;
		  /* 82250AA0h */ case  101:  		/* mr R6, R3 */
		/* 82250AA0h case  101:*/		regs.R6 = regs.R3;
		/* 82250AA0h case  101:*/		return 0x82250AA4;
		  /* 82250AA4h */ case  102:  		/* mr R5, R29 */
		/* 82250AA4h case  102:*/		regs.R5 = regs.R29;
		/* 82250AA4h case  102:*/		return 0x82250AA8;
		  /* 82250AA8h */ case  103:  		/* li R4, 3 */
		/* 82250AA8h case  103:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 82250AA8h case  103:*/		return 0x82250AAC;
		  /* 82250AACh */ case  104:  		/* mr R3, R31 */
		/* 82250AACh case  104:*/		regs.R3 = regs.R31;
		/* 82250AACh case  104:*/		return 0x82250AB0;
		  /* 82250AB0h */ case  105:  		/* mtspr CTR, R11 */
		/* 82250AB0h case  105:*/		regs.CTR = regs.R11;
		/* 82250AB0h case  105:*/		return 0x82250AB4;
		  /* 82250AB4h */ case  106:  		/* bcctrl 20, CR0_LT */
		/* 82250AB4h case  106:*/		if ( 1 ) { regs.LR = 0x82250AB8; return (uint32)regs.CTR; }
		/* 82250AB4h case  106:*/		return 0x82250AB8;
	}
	return 0x82250AB8;
} // Block from 8225090Ch-82250AB8h (107 instructions)

//////////////////////////////////////////////////////
// Block at 82250AB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250AB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250AB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250AB8);
		  /* 82250AB8h */ case    0:  		/* addi R29, R29, 1 */
		/* 82250AB8h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82250AB8h case    0:*/		return 0x82250ABC;
		  /* 82250ABCh */ case    1:  		/* cmpwi CR6, R29, 4 */
		/* 82250ABCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000004);
		/* 82250ABCh case    1:*/		return 0x82250AC0;
		  /* 82250AC0h */ case    2:  		/* bc 12, CR6_LT, -284 */
		/* 82250AC0h case    2:*/		if ( regs.CR[6].lt ) { return 0x822509A4;  }
		/* 82250AC0h case    2:*/		return 0x82250AC4;
		  /* 82250AC4h */ case    3:  		/* lwz R10, <#[R30 + 248]> */
		/* 82250AC4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x000000F8) );
		/* 82250AC4h case    3:*/		return 0x82250AC8;
		  /* 82250AC8h */ case    4:  		/* b 240 */
		/* 82250AC8h case    4:*/		return 0x82250BB8;
		/* 82250AC8h case    4:*/		return 0x82250ACC;
	}
	return 0x82250ACC;
} // Block from 82250AB8h-82250ACCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82250ACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250ACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250ACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250ACC);
		  /* 82250ACCh */ case    0:  		/* li R29, 0 */
		/* 82250ACCh case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82250ACCh case    0:*/		return 0x82250AD0;
		  /* 82250AD0h */ case    1:  		/* lwz R11, <#[R30]> */
		/* 82250AD0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82250AD0h case    1:*/		return 0x82250AD4;
		  /* 82250AD4h */ case    2:  		/* mr R5, R29 */
		/* 82250AD4h case    2:*/		regs.R5 = regs.R29;
		/* 82250AD4h case    2:*/		return 0x82250AD8;
		  /* 82250AD8h */ case    3:  		/* li R4, 0 */
		/* 82250AD8h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82250AD8h case    3:*/		return 0x82250ADC;
		  /* 82250ADCh */ case    4:  		/* mr R3, R30 */
		/* 82250ADCh case    4:*/		regs.R3 = regs.R30;
		/* 82250ADCh case    4:*/		return 0x82250AE0;
		  /* 82250AE0h */ case    5:  		/* lwz R11, <#[R11 + 80]> */
		/* 82250AE0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82250AE0h case    5:*/		return 0x82250AE4;
		  /* 82250AE4h */ case    6:  		/* mtspr CTR, R11 */
		/* 82250AE4h case    6:*/		regs.CTR = regs.R11;
		/* 82250AE4h case    6:*/		return 0x82250AE8;
		  /* 82250AE8h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 82250AE8h case    7:*/		if ( 1 ) { regs.LR = 0x82250AEC; return (uint32)regs.CTR; }
		/* 82250AE8h case    7:*/		return 0x82250AEC;
		  /* 82250AECh */ case    8:  		/* cmpwi CR6, R3, 1 */
		/* 82250AECh case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82250AECh case    8:*/		return 0x82250AF0;
		  /* 82250AF0h */ case    9:  		/* bc 12, CR6_EQ, 184 */
		/* 82250AF0h case    9:*/		if ( regs.CR[6].eq ) { return 0x82250BA8;  }
		/* 82250AF0h case    9:*/		return 0x82250AF4;
		  /* 82250AF4h */ case   10:  		/* lwz R11, <#[R30]> */
		/* 82250AF4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82250AF4h case   10:*/		return 0x82250AF8;
		  /* 82250AF8h */ case   11:  		/* mr R5, R29 */
		/* 82250AF8h case   11:*/		regs.R5 = regs.R29;
		/* 82250AF8h case   11:*/		return 0x82250AFC;
		  /* 82250AFCh */ case   12:  		/* li R4, 0 */
		/* 82250AFCh case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82250AFCh case   12:*/		return 0x82250B00;
		  /* 82250B00h */ case   13:  		/* lwz R28, <#[R31]> */
		/* 82250B00h case   13:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 82250B00h case   13:*/		return 0x82250B04;
		  /* 82250B04h */ case   14:  		/* mr R3, R30 */
		/* 82250B04h case   14:*/		regs.R3 = regs.R30;
		/* 82250B04h case   14:*/		return 0x82250B08;
		  /* 82250B08h */ case   15:  		/* lwz R11, <#[R11 + 80]> */
		/* 82250B08h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82250B08h case   15:*/		return 0x82250B0C;
		  /* 82250B0Ch */ case   16:  		/* mtspr CTR, R11 */
		/* 82250B0Ch case   16:*/		regs.CTR = regs.R11;
		/* 82250B0Ch case   16:*/		return 0x82250B10;
		  /* 82250B10h */ case   17:  		/* bcctrl 20, CR0_LT */
		/* 82250B10h case   17:*/		if ( 1 ) { regs.LR = 0x82250B14; return (uint32)regs.CTR; }
		/* 82250B10h case   17:*/		return 0x82250B14;
		  /* 82250B14h */ case   18:  		/* lwz R11, <#[R28 + 84]> */
		/* 82250B14h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000054) );
		/* 82250B14h case   18:*/		return 0x82250B18;
		  /* 82250B18h */ case   19:  		/* mr R6, R3 */
		/* 82250B18h case   19:*/		regs.R6 = regs.R3;
		/* 82250B18h case   19:*/		return 0x82250B1C;
		  /* 82250B1Ch */ case   20:  		/* mr R5, R29 */
		/* 82250B1Ch case   20:*/		regs.R5 = regs.R29;
		/* 82250B1Ch case   20:*/		return 0x82250B20;
		  /* 82250B20h */ case   21:  		/* li R4, 0 */
		/* 82250B20h case   21:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82250B20h case   21:*/		return 0x82250B24;
		  /* 82250B24h */ case   22:  		/* mr R3, R31 */
		/* 82250B24h case   22:*/		regs.R3 = regs.R31;
		/* 82250B24h case   22:*/		return 0x82250B28;
		  /* 82250B28h */ case   23:  		/* mtspr CTR, R11 */
		/* 82250B28h case   23:*/		regs.CTR = regs.R11;
		/* 82250B28h case   23:*/		return 0x82250B2C;
		  /* 82250B2Ch */ case   24:  		/* bcctrl 20, CR0_LT */
		/* 82250B2Ch case   24:*/		if ( 1 ) { regs.LR = 0x82250B30; return (uint32)regs.CTR; }
		/* 82250B2Ch case   24:*/		return 0x82250B30;
		  /* 82250B30h */ case   25:  		/* lwz R11, <#[R30]> */
		/* 82250B30h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82250B30h case   25:*/		return 0x82250B34;
		  /* 82250B34h */ case   26:  		/* mr R5, R29 */
		/* 82250B34h case   26:*/		regs.R5 = regs.R29;
		/* 82250B34h case   26:*/		return 0x82250B38;
		  /* 82250B38h */ case   27:  		/* li R4, 2 */
		/* 82250B38h case   27:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 82250B38h case   27:*/		return 0x82250B3C;
		  /* 82250B3Ch */ case   28:  		/* mr R3, R30 */
		/* 82250B3Ch case   28:*/		regs.R3 = regs.R30;
		/* 82250B3Ch case   28:*/		return 0x82250B40;
		  /* 82250B40h */ case   29:  		/* lwz R11, <#[R11 + 80]> */
		/* 82250B40h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82250B40h case   29:*/		return 0x82250B44;
		  /* 82250B44h */ case   30:  		/* mtspr CTR, R11 */
		/* 82250B44h case   30:*/		regs.CTR = regs.R11;
		/* 82250B44h case   30:*/		return 0x82250B48;
		  /* 82250B48h */ case   31:  		/* lwz R28, <#[R31]> */
		/* 82250B48h case   31:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 82250B48h case   31:*/		return 0x82250B4C;
		  /* 82250B4Ch */ case   32:  		/* bcctrl 20, CR0_LT */
		/* 82250B4Ch case   32:*/		if ( 1 ) { regs.LR = 0x82250B50; return (uint32)regs.CTR; }
		/* 82250B4Ch case   32:*/		return 0x82250B50;
		  /* 82250B50h */ case   33:  		/* lwz R11, <#[R28 + 88]> */
		/* 82250B50h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000058) );
		/* 82250B50h case   33:*/		return 0x82250B54;
		  /* 82250B54h */ case   34:  		/* mr R6, R3 */
		/* 82250B54h case   34:*/		regs.R6 = regs.R3;
		/* 82250B54h case   34:*/		return 0x82250B58;
		  /* 82250B58h */ case   35:  		/* mr R5, R29 */
		/* 82250B58h case   35:*/		regs.R5 = regs.R29;
		/* 82250B58h case   35:*/		return 0x82250B5C;
		  /* 82250B5Ch */ case   36:  		/* li R4, 1 */
		/* 82250B5Ch case   36:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82250B5Ch case   36:*/		return 0x82250B60;
		  /* 82250B60h */ case   37:  		/* mr R3, R31 */
		/* 82250B60h case   37:*/		regs.R3 = regs.R31;
		/* 82250B60h case   37:*/		return 0x82250B64;
		  /* 82250B64h */ case   38:  		/* mtspr CTR, R11 */
		/* 82250B64h case   38:*/		regs.CTR = regs.R11;
		/* 82250B64h case   38:*/		return 0x82250B68;
		  /* 82250B68h */ case   39:  		/* bcctrl 20, CR0_LT */
		/* 82250B68h case   39:*/		if ( 1 ) { regs.LR = 0x82250B6C; return (uint32)regs.CTR; }
		/* 82250B68h case   39:*/		return 0x82250B6C;
		  /* 82250B6Ch */ case   40:  		/* lwz R11, <#[R30]> */
		/* 82250B6Ch case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82250B6Ch case   40:*/		return 0x82250B70;
		  /* 82250B70h */ case   41:  		/* mr R5, R29 */
		/* 82250B70h case   41:*/		regs.R5 = regs.R29;
		/* 82250B70h case   41:*/		return 0x82250B74;
		  /* 82250B74h */ case   42:  		/* li R4, 1 */
		/* 82250B74h case   42:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82250B74h case   42:*/		return 0x82250B78;
		  /* 82250B78h */ case   43:  		/* mr R3, R30 */
		/* 82250B78h case   43:*/		regs.R3 = regs.R30;
		/* 82250B78h case   43:*/		return 0x82250B7C;
		  /* 82250B7Ch */ case   44:  		/* lwz R11, <#[R11 + 80]> */
		/* 82250B7Ch case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82250B7Ch case   44:*/		return 0x82250B80;
		  /* 82250B80h */ case   45:  		/* mtspr CTR, R11 */
		/* 82250B80h case   45:*/		regs.CTR = regs.R11;
		/* 82250B80h case   45:*/		return 0x82250B84;
		  /* 82250B84h */ case   46:  		/* lwz R28, <#[R31]> */
		/* 82250B84h case   46:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 82250B84h case   46:*/		return 0x82250B88;
		  /* 82250B88h */ case   47:  		/* bcctrl 20, CR0_LT */
		/* 82250B88h case   47:*/		if ( 1 ) { regs.LR = 0x82250B8C; return (uint32)regs.CTR; }
		/* 82250B88h case   47:*/		return 0x82250B8C;
		  /* 82250B8Ch */ case   48:  		/* lwz R11, <#[R28 + 88]> */
		/* 82250B8Ch case   48:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000058) );
		/* 82250B8Ch case   48:*/		return 0x82250B90;
		  /* 82250B90h */ case   49:  		/* mr R6, R3 */
		/* 82250B90h case   49:*/		regs.R6 = regs.R3;
		/* 82250B90h case   49:*/		return 0x82250B94;
		  /* 82250B94h */ case   50:  		/* mr R5, R29 */
		/* 82250B94h case   50:*/		regs.R5 = regs.R29;
		/* 82250B94h case   50:*/		return 0x82250B98;
		  /* 82250B98h */ case   51:  		/* li R4, 2 */
		/* 82250B98h case   51:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 82250B98h case   51:*/		return 0x82250B9C;
		  /* 82250B9Ch */ case   52:  		/* mr R3, R31 */
		/* 82250B9Ch case   52:*/		regs.R3 = regs.R31;
		/* 82250B9Ch case   52:*/		return 0x82250BA0;
		  /* 82250BA0h */ case   53:  		/* mtspr CTR, R11 */
		/* 82250BA0h case   53:*/		regs.CTR = regs.R11;
		/* 82250BA0h case   53:*/		return 0x82250BA4;
		  /* 82250BA4h */ case   54:  		/* bcctrl 20, CR0_LT */
		/* 82250BA4h case   54:*/		if ( 1 ) { regs.LR = 0x82250BA8; return (uint32)regs.CTR; }
		/* 82250BA4h case   54:*/		return 0x82250BA8;
	}
	return 0x82250BA8;
} // Block from 82250ACCh-82250BA8h (55 instructions)

//////////////////////////////////////////////////////
// Block at 82250BA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250BA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250BA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250BA8);
		  /* 82250BA8h */ case    0:  		/* addi R29, R29, 1 */
		/* 82250BA8h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82250BA8h case    0:*/		return 0x82250BAC;
		  /* 82250BACh */ case    1:  		/* cmpwi CR6, R29, 4 */
		/* 82250BACh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000004);
		/* 82250BACh case    1:*/		return 0x82250BB0;
		  /* 82250BB0h */ case    2:  		/* bc 12, CR6_LT, -224 */
		/* 82250BB0h case    2:*/		if ( regs.CR[6].lt ) { return 0x82250AD0;  }
		/* 82250BB0h case    2:*/		return 0x82250BB4;
	}
	return 0x82250BB4;
} // Block from 82250BA8h-82250BB4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82250BB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250BB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250BB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250BB4);
		  /* 82250BB4h */ case    0:  		/* lwz R10, <#[R30 + 244]> */
		/* 82250BB4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x000000F4) );
		/* 82250BB4h case    0:*/		return 0x82250BB8;
	}
	return 0x82250BB8;
} // Block from 82250BB4h-82250BB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82250BB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250BB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250BB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250BB8);
		  /* 82250BB8h */ case    0:  		/* lwz R11, <#[R31 + 228]> */
		/* 82250BB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82250BB8h case    0:*/		return 0x82250BBC;
		  /* 82250BBCh */ case    1:  		/* rlwinm. R11, R11, 23, 31, 31 */
		/* 82250BBCh case    1:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R11,regs.R11);
		/* 82250BBCh case    1:*/		return 0x82250BC0;
		  /* 82250BC0h */ case    2:  		/* lwz R11, <#[R31 + 20]> */
		/* 82250BC0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82250BC0h case    2:*/		return 0x82250BC4;
		  /* 82250BC4h */ case    3:  		/* bc 12, CR0_EQ, 20 */
		/* 82250BC4h case    3:*/		if ( regs.CR[0].eq ) { return 0x82250BD8;  }
		/* 82250BC4h case    3:*/		return 0x82250BC8;
		  /* 82250BC8h */ case    4:  		/* addi R11, R11, 58 */
		/* 82250BC8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3A);
		/* 82250BC8h case    4:*/		return 0x82250BCC;
		  /* 82250BCCh */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82250BCCh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82250BCCh case    5:*/		return 0x82250BD0;
		  /* 82250BD0h */ case    6:  		/* stwx R10, <#[R11 + R31]> */
		/* 82250BD0h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82250BD0h case    6:*/		return 0x82250BD4;
		  /* 82250BD4h */ case    7:  		/* b 36 */
		/* 82250BD4h case    7:*/		return 0x82250BF8;
		/* 82250BD4h case    7:*/		return 0x82250BD8;
	}
	return 0x82250BD8;
} // Block from 82250BB8h-82250BD8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82250BD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250BD8);
		  /* 82250BD8h */ case    0:  		/* addi R11, R11, 1 */
		/* 82250BD8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82250BD8h case    0:*/		return 0x82250BDC;
		  /* 82250BDCh */ case    1:  		/* addi R9, R11, 58 */
		/* 82250BDCh case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x3A);
		/* 82250BDCh case    1:*/		return 0x82250BE0;
		  /* 82250BE0h */ case    2:  		/* stw R11, <#[R31 + 20]> */
		/* 82250BE0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82250BE0h case    2:*/		return 0x82250BE4;
		  /* 82250BE4h */ case    3:  		/* rlwinm R11, R9, 2, 0, 29 */
		/* 82250BE4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R9);
		/* 82250BE4h case    3:*/		return 0x82250BE8;
		  /* 82250BE8h */ case    4:  		/* stwx R10, <#[R11 + R31]> */
		/* 82250BE8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82250BE8h case    4:*/		return 0x82250BEC;
		  /* 82250BECh */ case    5:  		/* lwz R11, <#[R31 + 228]> */
		/* 82250BECh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82250BECh case    5:*/		return 0x82250BF0;
		  /* 82250BF0h */ case    6:  		/* ori R11, R11, 512 */
		/* 82250BF0h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82250BF0h case    6:*/		return 0x82250BF4;
		  /* 82250BF4h */ case    7:  		/* stw R11, <#[R31 + 228]> */
		/* 82250BF4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82250BF4h case    7:*/		return 0x82250BF8;
	}
	return 0x82250BF8;
} // Block from 82250BD8h-82250BF8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82250BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250BF8);
		  /* 82250BF8h */ case    0:  		/* addi R1, R1, 128 */
		/* 82250BF8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82250BF8h case    0:*/		return 0x82250BFC;
		  /* 82250BFCh */ case    1:  		/* b -1833300 */
		/* 82250BFCh case    1:*/		return 0x820912A8;
		/* 82250BFCh case    1:*/		return 0x82250C00;
	}
	return 0x82250C00;
} // Block from 82250BF8h-82250C00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82250C00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250C00);
		  /* 82250C00h */ case    0:  		/* mfspr R12, LR */
		/* 82250C00h case    0:*/		regs.R12 = regs.LR;
		/* 82250C00h case    0:*/		return 0x82250C04;
		  /* 82250C04h */ case    1:  		/* bl -1833412 */
		/* 82250C04h case    1:*/		regs.LR = 0x82250C08; return 0x82091240;
		/* 82250C04h case    1:*/		return 0x82250C08;
		  /* 82250C08h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 82250C08h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 82250C08h case    2:*/		return 0x82250C0C;
		  /* 82250C0Ch */ case    3:  		/* lwz R11, <#[R3 + 12]> */
		/* 82250C0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82250C0Ch case    3:*/		return 0x82250C10;
		  /* 82250C10h */ case    4:  		/* mr R25, R3 */
		/* 82250C10h case    4:*/		regs.R25 = regs.R3;
		/* 82250C10h case    4:*/		return 0x82250C14;
		  /* 82250C14h */ case    5:  		/* addi R3, R1, 96 */
		/* 82250C14h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82250C14h case    5:*/		return 0x82250C18;
		  /* 82250C18h */ case    6:  		/* lwz R4, <#[R11 + 1456]> */
		/* 82250C18h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 82250C18h case    6:*/		return 0x82250C1C;
		  /* 82250C1Ch */ case    7:  		/* bl -110268 */
		/* 82250C1Ch case    7:*/		regs.LR = 0x82250C20; return 0x82235D60;
		/* 82250C1Ch case    7:*/		return 0x82250C20;
		  /* 82250C20h */ case    8:  		/* lis R11, -32252 */
		/* 82250C20h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82250C20h case    8:*/		return 0x82250C24;
		  /* 82250C24h */ case    9:  		/* lwz R3, <#[R25 + 12]> */
		/* 82250C24h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R25 + 0x0000000C) );
		/* 82250C24h case    9:*/		return 0x82250C28;
		  /* 82250C28h */ case   10:  		/* addi R4, R11, 16444 */
		/* 82250C28h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x403C);
		/* 82250C28h case   10:*/		return 0x82250C2C;
		  /* 82250C2Ch */ case   11:  		/* bl -211052 */
		/* 82250C2Ch case   11:*/		regs.LR = 0x82250C30; return 0x8221D3C0;
		/* 82250C2Ch case   11:*/		return 0x82250C30;
		  /* 82250C30h */ case   12:  		/* li R26, 0 */
		/* 82250C30h case   12:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82250C30h case   12:*/		return 0x82250C34;
		  /* 82250C34h */ case   13:  		/* li R29, 1 */
		/* 82250C34h case   13:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 82250C34h case   13:*/		return 0x82250C38;
		  /* 82250C38h */ case   14:  		/* mr R31, R26 */
		/* 82250C38h case   14:*/		regs.R31 = regs.R26;
		/* 82250C38h case   14:*/		return 0x82250C3C;
		  /* 82250C3Ch */ case   15:  		/* mr R30, R26 */
		/* 82250C3Ch case   15:*/		regs.R30 = regs.R26;
		/* 82250C3Ch case   15:*/		return 0x82250C40;
		  /* 82250C40h */ case   16:  		/* lwz R11, <#[R25 + 2068]> */
		/* 82250C40h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000814) );
		/* 82250C40h case   16:*/		return 0x82250C44;
		  /* 82250C44h */ case   17:  		/* lwz R10, <#[R11 + 4]> */
		/* 82250C44h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82250C44h case   17:*/		return 0x82250C48;
		  /* 82250C48h */ case   18:  		/* cmplw CR6, R29, R10 */
		/* 82250C48h case   18:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R10);
		/* 82250C48h case   18:*/		return 0x82250C4C;
		  /* 82250C4Ch */ case   19:  		/* bc 4, CR6_GT, 12 */
		/* 82250C4Ch case   19:*/		if ( !regs.CR[6].gt ) { return 0x82250C58;  }
		/* 82250C4Ch case   19:*/		return 0x82250C50;
		  /* 82250C50h */ case   20:  		/* mr R11, R26 */
		/* 82250C50h case   20:*/		regs.R11 = regs.R26;
		/* 82250C50h case   20:*/		return 0x82250C54;
		  /* 82250C54h */ case   21:  		/* b 16 */
		/* 82250C54h case   21:*/		return 0x82250C64;
		/* 82250C54h case   21:*/		return 0x82250C58;
	}
	return 0x82250C58;
} // Block from 82250C00h-82250C58h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82250C58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250C58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250C58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250C58);
		  /* 82250C58h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 82250C58h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82250C58h case    0:*/		return 0x82250C5C;
		  /* 82250C5Ch */ case    1:  		/* li R11, 1 */
		/* 82250C5Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82250C5Ch case    1:*/		return 0x82250C60;
		  /* 82250C60h */ case    2:  		/* lwzx R31, <#[R10 + R30]> */
		/* 82250C60h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 82250C60h case    2:*/		return 0x82250C64;
	}
	return 0x82250C64;
} // Block from 82250C58h-82250C64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82250C64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250C64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250C64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250C64);
		  /* 82250C64h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82250C64h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82250C64h case    0:*/		return 0x82250C68;
		  /* 82250C68h */ case    1:  		/* bc 12, CR0_EQ, 148 */
		/* 82250C68h case    1:*/		if ( regs.CR[0].eq ) { return 0x82250CFC;  }
		/* 82250C68h case    1:*/		return 0x82250C6C;
		  /* 82250C6Ch */ case    2:  		/* lwz R11, <#[R31 + 228]> */
		/* 82250C6Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82250C6Ch case    2:*/		return 0x82250C70;
		  /* 82250C70h */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82250C70h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82250C70h case    3:*/		return 0x82250C74;
		  /* 82250C74h */ case    4:  		/* bc 12, CR0_EQ, 124 */
		/* 82250C74h case    4:*/		if ( regs.CR[0].eq ) { return 0x82250CF0;  }
		/* 82250C74h case    4:*/		return 0x82250C78;
		  /* 82250C78h */ case    5:  		/* lwz R11, <#[R31 + 128]> */
		/* 82250C78h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 82250C78h case    5:*/		return 0x82250C7C;
		  /* 82250C7Ch */ case    6:  		/* addi R3, R1, 96 */
		/* 82250C7Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82250C7Ch case    6:*/		return 0x82250C80;
		  /* 82250C80h */ case    7:  		/* stw R26, <#[R1 + 80]> */
		/* 82250C80h case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 82250C80h case    7:*/		return 0x82250C84;
		  /* 82250C84h */ case    8:  		/* stw R11, <#[R1 + 84]> */
		/* 82250C84h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82250C84h case    8:*/		return 0x82250C88;
		  /* 82250C88h */ case    9:  		/* lbz R10, <#[R1 + 85]> */
		/* 82250C88h case    9:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000055) );
		/* 82250C88h case    9:*/		return 0x82250C8C;
		  /* 82250C8Ch */ case   10:  		/* lbz R9, <#[R1 + 86]> */
		/* 82250C8Ch case   10:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000056) );
		/* 82250C8Ch case   10:*/		return 0x82250C90;
		  /* 82250C90h */ case   11:  		/* lbz R8, <#[R1 + 87]> */
		/* 82250C90h case   11:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000057) );
		/* 82250C90h case   11:*/		return 0x82250C94;
		  /* 82250C94h */ case   12:  		/* lbz R11, <#[R1 + 84]> */
		/* 82250C94h case   12:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82250C94h case   12:*/		return 0x82250C98;
		  /* 82250C98h */ case   13:  		/* addi R11, R11, -1 */
		/* 82250C98h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82250C98h case   13:*/		return 0x82250C9C;
		  /* 82250C9Ch */ case   14:  		/* addic R7, R11, -1 */
		/* 82250C9Ch case   14:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R11,0xFFFFFFFF);
		/* 82250C9Ch case   14:*/		return 0x82250CA0;
		  /* 82250CA0h */ case   15:  		/* addi R10, R10, -1 */
		/* 82250CA0h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82250CA0h case   15:*/		return 0x82250CA4;
		  /* 82250CA4h */ case   16:  		/* subfe R7, R7, R11 */
		/* 82250CA4h case   16:*/		cpu::op::subfe<0>(regs,&regs.R7,regs.R7,regs.R11);
		/* 82250CA4h case   16:*/		return 0x82250CA8;
		  /* 82250CA8h */ case   17:  		/* addic R6, R10, -1 */
		/* 82250CA8h case   17:*/		cpu::op::addic<0>(regs,&regs.R6,regs.R10,0xFFFFFFFF);
		/* 82250CA8h case   17:*/		return 0x82250CAC;
		  /* 82250CACh */ case   18:  		/* addi R11, R9, -1 */
		/* 82250CACh case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 82250CACh case   18:*/		return 0x82250CB0;
		  /* 82250CB0h */ case   19:  		/* stb R7, <#[R1 + 80]> */
		/* 82250CB0h case   19:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 82250CB0h case   19:*/		return 0x82250CB4;
		  /* 82250CB4h */ case   20:  		/* mr R9, R8 */
		/* 82250CB4h case   20:*/		regs.R9 = regs.R8;
		/* 82250CB4h case   20:*/		return 0x82250CB8;
		  /* 82250CB8h */ case   21:  		/* subfe R8, R6, R10 */
		/* 82250CB8h case   21:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R6,regs.R10);
		/* 82250CB8h case   21:*/		return 0x82250CBC;
		  /* 82250CBCh */ case   22:  		/* addic R7, R11, -1 */
		/* 82250CBCh case   22:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R11,0xFFFFFFFF);
		/* 82250CBCh case   22:*/		return 0x82250CC0;
		  /* 82250CC0h */ case   23:  		/* addi R10, R9, -1 */
		/* 82250CC0h case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFFFFF);
		/* 82250CC0h case   23:*/		return 0x82250CC4;
		  /* 82250CC4h */ case   24:  		/* stb R8, <#[R1 + 81]> */
		/* 82250CC4h case   24:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R1 + 0x00000051) );
		/* 82250CC4h case   24:*/		return 0x82250CC8;
	}
	return 0x82250CC8;
} // Block from 82250C64h-82250CC8h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82250CC8h
// Function '?Special01Case@IRInst@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250CC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250CC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250CC8);
		  /* 82250CC8h */ case    0:  		/* subfe R11, R7, R11 */
		/* 82250CC8h case    0:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 82250CC8h case    0:*/		return 0x82250CCC;
		  /* 82250CCCh */ case    1:  		/* addic R9, R10, -1 */
		/* 82250CCCh case    1:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 82250CCCh case    1:*/		return 0x82250CD0;
		  /* 82250CD0h */ case    2:  		/* stb R11, <#[R1 + 82]> */
		/* 82250CD0h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000052) );
		/* 82250CD0h case    2:*/		return 0x82250CD4;
		  /* 82250CD4h */ case    3:  		/* subfe R11, R9, R10 */
		/* 82250CD4h case    3:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R9,regs.R10);
		/* 82250CD4h case    3:*/		return 0x82250CD8;
		  /* 82250CD8h */ case    4:  		/* stb R11, <#[R1 + 83]> */
		/* 82250CD8h case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000053) );
		/* 82250CD8h case    4:*/		return 0x82250CDC;
		  /* 82250CDCh */ case    5:  		/* lwz R11, <#[R1 + 80]> */
		/* 82250CDCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82250CDCh case    5:*/		return 0x82250CE0;
		  /* 82250CE0h */ case    6:  		/* stw R11, <#[R31 + 12]> */
		/* 82250CE0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82250CE0h case    6:*/		return 0x82250CE4;
		  /* 82250CE4h */ case    7:  		/* lwz R4, <#[R1 + 100]> */
		/* 82250CE4h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000064) );
		/* 82250CE4h case    7:*/		return 0x82250CE8;
		  /* 82250CE8h */ case    8:  		/* bl 11736 */
		/* 82250CE8h case    8:*/		regs.LR = 0x82250CEC; return 0x82253AC0;
		/* 82250CE8h case    8:*/		return 0x82250CEC;
		  /* 82250CECh */ case    9:  		/* stw R31, <#[R3]> */
		/* 82250CECh case    9:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82250CECh case    9:*/		return 0x82250CF0;
	}
	return 0x82250CF0;
} // Block from 82250CC8h-82250CF0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82250CF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250CF0);
		  /* 82250CF0h */ case    0:  		/* addi R29, R29, 1 */
		/* 82250CF0h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82250CF0h case    0:*/		return 0x82250CF4;
		  /* 82250CF4h */ case    1:  		/* addi R30, R30, 4 */
		/* 82250CF4h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82250CF4h case    1:*/		return 0x82250CF8;
		  /* 82250CF8h */ case    2:  		/* b -184 */
		/* 82250CF8h case    2:*/		return 0x82250C40;
		/* 82250CF8h case    2:*/		return 0x82250CFC;
	}
	return 0x82250CFC;
} // Block from 82250CF0h-82250CFCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82250CFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250CFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250CFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250CFC);
		  /* 82250CFCh */ case    0:  		/* lis R11, -32253 */
		/* 82250CFCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 82250CFCh case    0:*/		return 0x82250D00;
		  /* 82250D00h */ case    1:  		/* lis R10, -32252 */
		/* 82250D00h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82250D00h case    1:*/		return 0x82250D04;
		  /* 82250D04h */ case    2:  		/* lis R9, -32252 */
		/* 82250D04h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 82250D04h case    2:*/		return 0x82250D08;
		  /* 82250D08h */ case    3:  		/* addi R24, R11, 27460 */
		/* 82250D08h case    3:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x6B44);
		/* 82250D08h case    3:*/		return 0x82250D0C;
		  /* 82250D0Ch */ case    4:  		/* addi R23, R10, 16376 */
		/* 82250D0Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R10,0x3FF8);
		/* 82250D0Ch case    4:*/		return 0x82250D10;
		  /* 82250D10h */ case    5:  		/* addi R22, R9, 16232 */
		/* 82250D10h case    5:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R9,0x3F68);
		/* 82250D10h case    5:*/		return 0x82250D14;
		  /* 82250D14h */ case    6:  		/* b 368 */
		/* 82250D14h case    6:*/		return 0x82250E84;
		/* 82250D14h case    6:*/		return 0x82250D18;
		  /* 82250D18h */ case    7:  		/* lwz R3, <#[R1 + 104]> */
		/* 82250D18h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000068) );
		/* 82250D18h case    7:*/		return 0x82250D1C;
		  /* 82250D1Ch */ case    8:  		/* li R4, 0 */
		/* 82250D1Ch case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82250D1Ch case    8:*/		return 0x82250D20;
		  /* 82250D20h */ case    9:  		/* lwz R31, <#[R3]> */
		/* 82250D20h case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82250D20h case    9:*/		return 0x82250D24;
		  /* 82250D24h */ case   10:  		/* addi R3, R1, 96 */
		/* 82250D24h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82250D24h case   10:*/		return 0x82250D28;
		  /* 82250D28h */ case   11:  		/* bl 11480 */
		/* 82250D28h case   11:*/		regs.LR = 0x82250D2C; return 0x82253A00;
		/* 82250D28h case   11:*/		return 0x82250D2C;
		  /* 82250D2Ch */ case   12:  		/* mr R3, R31 */
		/* 82250D2Ch case   12:*/		regs.R3 = regs.R31;
		/* 82250D2Ch case   12:*/		return 0x82250D30;
		  /* 82250D30h */ case   13:  		/* bl -2936 */
		/* 82250D30h case   13:*/		regs.LR = 0x82250D34; return 0x822501B8;
		/* 82250D30h case   13:*/		return 0x82250D34;
		  /* 82250D34h */ case   14:  		/* lwz R11, <#[R31 + 228]> */
		/* 82250D34h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82250D34h case   14:*/		return 0x82250D38;
		  /* 82250D38h */ case   15:  		/* rlwinm. R11, R11, 23, 31, 31 */
		/* 82250D38h case   15:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R11,regs.R11);
		/* 82250D38h case   15:*/		return 0x82250D3C;
		  /* 82250D3Ch */ case   16:  		/* bc 12, CR0_EQ, 16 */
		/* 82250D3Ch case   16:*/		if ( regs.CR[0].eq ) { return 0x82250D4C;  }
		/* 82250D3Ch case   16:*/		return 0x82250D40;
		  /* 82250D40h */ case   17:  		/* lwz R11, <#[R31 + 20]> */
		/* 82250D40h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82250D40h case   17:*/		return 0x82250D44;
		  /* 82250D44h */ case   18:  		/* addi R27, R11, -1 */
		/* 82250D44h case   18:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFFFFFF);
		/* 82250D44h case   18:*/		return 0x82250D48;
		  /* 82250D48h */ case   19:  		/* b 8 */
		/* 82250D48h case   19:*/		return 0x82250D50;
		/* 82250D48h case   19:*/		return 0x82250D4C;
	}
	return 0x82250D4C;
} // Block from 82250CFCh-82250D4Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 82250D4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250D4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250D4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250D4C);
		  /* 82250D4Ch */ case    0:  		/* lwz R27, <#[R31 + 20]> */
		/* 82250D4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R31 + 0x00000014) );
		/* 82250D4Ch case    0:*/		return 0x82250D50;
	}
	return 0x82250D50;
} // Block from 82250D4Ch-82250D50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82250D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250D50);
		  /* 82250D50h */ case    0:  		/* li R29, 1 */
		/* 82250D50h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 82250D50h case    0:*/		return 0x82250D54;
		  /* 82250D54h */ case    1:  		/* cmpwi CR6, R27, 1 */
		/* 82250D54h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000001);
		/* 82250D54h case    1:*/		return 0x82250D58;
		  /* 82250D58h */ case    2:  		/* bc 12, CR6_LT, 80 */
		/* 82250D58h case    2:*/		if ( regs.CR[6].lt ) { return 0x82250DA8;  }
		/* 82250D58h case    2:*/		return 0x82250D5C;
		  /* 82250D5Ch */ case    3:  		/* addi R28, R31, 236 */
		/* 82250D5Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0xEC);
		/* 82250D5Ch case    3:*/		return 0x82250D60;
		  /* 82250D60h */ case    4:  		/* mr R5, R25 */
		/* 82250D60h case    4:*/		regs.R5 = regs.R25;
		/* 82250D60h case    4:*/		return 0x82250D64;
		  /* 82250D64h */ case    5:  		/* lwz R30, <#[R28]> */
		/* 82250D64h case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x00000000) );
		/* 82250D64h case    5:*/		return 0x82250D68;
		  /* 82250D68h */ case    6:  		/* mr R4, R29 */
		/* 82250D68h case    6:*/		regs.R4 = regs.R29;
		/* 82250D68h case    6:*/		return 0x82250D6C;
		  /* 82250D6Ch */ case    7:  		/* mr R3, R31 */
		/* 82250D6Ch case    7:*/		regs.R3 = regs.R31;
		/* 82250D6Ch case    7:*/		return 0x82250D70;
		  /* 82250D70h */ case    8:  		/* bl -4024 */
		/* 82250D70h case    8:*/		regs.LR = 0x82250D74; return 0x8224FDB8;
		/* 82250D70h case    8:*/		return 0x82250D74;
		  /* 82250D74h */ case    9:  		/* lwz R10, <#[R30 + 12]> */
		/* 82250D74h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000000C) );
		/* 82250D74h case    9:*/		return 0x82250D78;
		  /* 82250D78h */ case   10:  		/* or R11, R10, R3 */
		/* 82250D78h case   10:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R3);
		/* 82250D78h case   10:*/		return 0x82250D7C;
		  /* 82250D7Ch */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 82250D7Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82250D7Ch case   11:*/		return 0x82250D80;
		  /* 82250D80h */ case   12:  		/* bc 12, CR6_EQ, 24 */
		/* 82250D80h case   12:*/		if ( regs.CR[6].eq ) { return 0x82250D98;  }
		/* 82250D80h case   12:*/		return 0x82250D84;
		  /* 82250D84h */ case   13:  		/* stw R11, <#[R30 + 12]> */
		/* 82250D84h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82250D84h case   13:*/		return 0x82250D88;
		  /* 82250D88h */ case   14:  		/* addi R3, R1, 96 */
		/* 82250D88h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82250D88h case   14:*/		return 0x82250D8C;
		  /* 82250D8Ch */ case   15:  		/* lwz R4, <#[R1 + 100]> */
		/* 82250D8Ch case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000064) );
		/* 82250D8Ch case   15:*/		return 0x82250D90;
		  /* 82250D90h */ case   16:  		/* bl 11568 */
		/* 82250D90h case   16:*/		regs.LR = 0x82250D94; return 0x82253AC0;
		/* 82250D90h case   16:*/		return 0x82250D94;
		  /* 82250D94h */ case   17:  		/* stw R30, <#[R3]> */
		/* 82250D94h case   17:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82250D94h case   17:*/		return 0x82250D98;
	}
	return 0x82250D98;
} // Block from 82250D50h-82250D98h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82250D98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250D98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250D98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250D98);
		  /* 82250D98h */ case    0:  		/* addi R29, R29, 1 */
		/* 82250D98h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82250D98h case    0:*/		return 0x82250D9C;
		  /* 82250D9Ch */ case    1:  		/* addi R28, R28, 4 */
		/* 82250D9Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82250D9Ch case    1:*/		return 0x82250DA0;
		  /* 82250DA0h */ case    2:  		/* cmpw CR6, R29, R27 */
		/* 82250DA0h case    2:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R27);
		/* 82250DA0h case    2:*/		return 0x82250DA4;
		  /* 82250DA4h */ case    3:  		/* bc 4, CR6_GT, -68 */
		/* 82250DA4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82250D60;  }
		/* 82250DA4h case    3:*/		return 0x82250DA8;
	}
	return 0x82250DA8;
} // Block from 82250D98h-82250DA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82250DA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250DA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250DA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250DA8);
		  /* 82250DA8h */ case    0:  		/* lwz R11, <#[R31 + 228]> */
		/* 82250DA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82250DA8h case    0:*/		return 0x82250DAC;
		  /* 82250DACh */ case    1:  		/* rlwinm. R11, R11, 23, 31, 31 */
		/* 82250DACh case    1:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R11,regs.R11);
		/* 82250DACh case    1:*/		return 0x82250DB0;
		  /* 82250DB0h */ case    2:  		/* bc 12, CR0_EQ, 212 */
		/* 82250DB0h case    2:*/		if ( regs.CR[0].eq ) { return 0x82250E84;  }
		/* 82250DB0h case    2:*/		return 0x82250DB4;
		  /* 82250DB4h */ case    3:  		/* mr R3, R31 */
		/* 82250DB4h case    3:*/		regs.R3 = regs.R31;
		/* 82250DB4h case    3:*/		return 0x82250DB8;
		  /* 82250DB8h */ case    4:  		/* bl -110592 */
		/* 82250DB8h case    4:*/		regs.LR = 0x82250DBC; return 0x82235DB8;
		/* 82250DB8h case    4:*/		return 0x82250DBC;
		  /* 82250DBCh */ case    5:  		/* lwz R11, <#[R31 + 128]> */
		/* 82250DBCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 82250DBCh case    5:*/		return 0x82250DC0;
		  /* 82250DC0h */ case    6:  		/* stw R26, <#[R1 + 80]> */
		/* 82250DC0h case    6:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 82250DC0h case    6:*/		return 0x82250DC4;
		  /* 82250DC4h */ case    7:  		/* mr R30, R3 */
		/* 82250DC4h case    7:*/		regs.R30 = regs.R3;
		/* 82250DC4h case    7:*/		return 0x82250DC8;
		  /* 82250DC8h */ case    8:  		/* lwz R8, <#[R31 + 12]> */
		/* 82250DC8h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000000C) );
		/* 82250DC8h case    8:*/		return 0x82250DCC;
		  /* 82250DCCh */ case    9:  		/* mr R4, R8 */
		/* 82250DCCh case    9:*/		regs.R4 = regs.R8;
		/* 82250DCCh case    9:*/		return 0x82250DD0;
		  /* 82250DD0h */ case   10:  		/* stw R11, <#[R1 + 84]> */
		/* 82250DD0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82250DD0h case   10:*/		return 0x82250DD4;
		  /* 82250DD4h */ case   11:  		/* lbz R10, <#[R1 + 85]> */
		/* 82250DD4h case   11:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000055) );
		/* 82250DD4h case   11:*/		return 0x82250DD8;
		  /* 82250DD8h */ case   12:  		/* lbz R9, <#[R1 + 86]> */
		/* 82250DD8h case   12:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000056) );
		/* 82250DD8h case   12:*/		return 0x82250DDC;
		  /* 82250DDCh */ case   13:  		/* lbz R7, <#[R1 + 87]> */
		/* 82250DDCh case   13:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000057) );
		/* 82250DDCh case   13:*/		return 0x82250DE0;
		  /* 82250DE0h */ case   14:  		/* lbz R11, <#[R1 + 84]> */
		/* 82250DE0h case   14:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82250DE0h case   14:*/		return 0x82250DE4;
		  /* 82250DE4h */ case   15:  		/* addi R11, R11, -1 */
		/* 82250DE4h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82250DE4h case   15:*/		return 0x82250DE8;
		  /* 82250DE8h */ case   16:  		/* addic R6, R11, -1 */
		/* 82250DE8h case   16:*/		cpu::op::addic<0>(regs,&regs.R6,regs.R11,0xFFFFFFFF);
		/* 82250DE8h case   16:*/		return 0x82250DEC;
		  /* 82250DECh */ case   17:  		/* addi R10, R10, -1 */
		/* 82250DECh case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82250DECh case   17:*/		return 0x82250DF0;
	}
	return 0x82250DF0;
} // Block from 82250DA8h-82250DF0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82250DF0h
// Function '?CollapseAlgebraicCombinations@IRInst@XGRAPHICS@@QAAXPAVCFG@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250DF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250DF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250DF0);
		  /* 82250DF0h */ case    0:  		/* subfe R6, R6, R11 */
		/* 82250DF0h case    0:*/		cpu::op::subfe<0>(regs,&regs.R6,regs.R6,regs.R11);
		/* 82250DF0h case    0:*/		return 0x82250DF4;
		  /* 82250DF4h */ case    1:  		/* addic R5, R10, -1 */
		/* 82250DF4h case    1:*/		cpu::op::addic<0>(regs,&regs.R5,regs.R10,0xFFFFFFFF);
		/* 82250DF4h case    1:*/		return 0x82250DF8;
		  /* 82250DF8h */ case    2:  		/* addi R11, R9, -1 */
		/* 82250DF8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 82250DF8h case    2:*/		return 0x82250DFC;
		  /* 82250DFCh */ case    3:  		/* stb R6, <#[R1 + 80]> */
		/* 82250DFCh case    3:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 82250DFCh case    3:*/		return 0x82250E00;
		  /* 82250E00h */ case    4:  		/* mr R9, R7 */
		/* 82250E00h case    4:*/		regs.R9 = regs.R7;
		/* 82250E00h case    4:*/		return 0x82250E04;
		  /* 82250E04h */ case    5:  		/* subfe R7, R5, R10 */
		/* 82250E04h case    5:*/		cpu::op::subfe<0>(regs,&regs.R7,regs.R5,regs.R10);
		/* 82250E04h case    5:*/		return 0x82250E08;
		  /* 82250E08h */ case    6:  		/* addic R6, R11, -1 */
		/* 82250E08h case    6:*/		cpu::op::addic<0>(regs,&regs.R6,regs.R11,0xFFFFFFFF);
		/* 82250E08h case    6:*/		return 0x82250E0C;
		  /* 82250E0Ch */ case    7:  		/* addi R10, R9, -1 */
		/* 82250E0Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFFFFF);
		/* 82250E0Ch case    7:*/		return 0x82250E10;
		  /* 82250E10h */ case    8:  		/* stb R7, <#[R1 + 81]> */
		/* 82250E10h case    8:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R1 + 0x00000051) );
		/* 82250E10h case    8:*/		return 0x82250E14;
		  /* 82250E14h */ case    9:  		/* subfe R11, R6, R11 */
		/* 82250E14h case    9:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R6,regs.R11);
		/* 82250E14h case    9:*/		return 0x82250E18;
		  /* 82250E18h */ case   10:  		/* addic R9, R10, -1 */
		/* 82250E18h case   10:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 82250E18h case   10:*/		return 0x82250E1C;
		  /* 82250E1Ch */ case   11:  		/* stb R11, <#[R1 + 82]> */
		/* 82250E1Ch case   11:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000052) );
		/* 82250E1Ch case   11:*/		return 0x82250E20;
		  /* 82250E20h */ case   12:  		/* subfe R11, R9, R10 */
		/* 82250E20h case   12:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R9,regs.R10);
		/* 82250E20h case   12:*/		return 0x82250E24;
		  /* 82250E24h */ case   13:  		/* stb R11, <#[R1 + 83]> */
		/* 82250E24h case   13:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000053) );
		/* 82250E24h case   13:*/		return 0x82250E28;
		  /* 82250E28h */ case   14:  		/* lwz R9, <#[R1 + 80]> */
		/* 82250E28h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 82250E28h case   14:*/		return 0x82250E2C;
		  /* 82250E2Ch */ case   15:  		/* mr R3, R9 */
		/* 82250E2Ch case   15:*/		regs.R3 = regs.R9;
		/* 82250E2Ch case   15:*/		return 0x82250E30;
		  /* 82250E30h */ case   16:  		/* bl -5432 */
		/* 82250E30h case   16:*/		regs.LR = 0x82250E34; return 0x8224F8F8;
		/* 82250E30h case   16:*/		return 0x82250E34;
		  /* 82250E34h */ case   17:  		/* mr R31, R3 */
		/* 82250E34h case   17:*/		regs.R31 = regs.R3;
		/* 82250E34h case   17:*/		return 0x82250E38;
		  /* 82250E38h */ case   18:  		/* mr R3, R9 */
		/* 82250E38h case   18:*/		regs.R3 = regs.R9;
		/* 82250E38h case   18:*/		return 0x82250E3C;
		  /* 82250E3Ch */ case   19:  		/* bl -5308 */
		/* 82250E3Ch case   19:*/		regs.LR = 0x82250E40; return 0x8224F980;
		/* 82250E3Ch case   19:*/		return 0x82250E40;
		  /* 82250E40h */ case   20:  		/* cmplw CR6, R31, R3 */
		/* 82250E40h case   20:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R3);
		/* 82250E40h case   20:*/		return 0x82250E44;
		  /* 82250E44h */ case   21:  		/* bc 12, CR6_EQ, 28 */
		/* 82250E44h case   21:*/		if ( regs.CR[6].eq ) { return 0x82250E60;  }
		/* 82250E44h case   21:*/		return 0x82250E48;
		  /* 82250E48h */ case   22:  		/* mr R6, R22 */
		/* 82250E48h case   22:*/		regs.R6 = regs.R22;
		/* 82250E48h case   22:*/		return 0x82250E4C;
		  /* 82250E4Ch */ case   23:  		/* mr R5, R23 */
		/* 82250E4Ch case   23:*/		regs.R5 = regs.R23;
		/* 82250E4Ch case   23:*/		return 0x82250E50;
		  /* 82250E50h */ case   24:  		/* mr R4, R24 */
		/* 82250E50h case   24:*/		regs.R4 = regs.R24;
		/* 82250E50h case   24:*/		return 0x82250E54;
		  /* 82250E54h */ case   25:  		/* li R7, 843 */
		/* 82250E54h case   25:*/		cpu::op::li<0>(regs,&regs.R7,0x34B);
		/* 82250E54h case   25:*/		return 0x82250E58;
		  /* 82250E58h */ case   26:  		/* li R3, 0 */
		/* 82250E58h case   26:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82250E58h case   26:*/		return 0x82250E5C;
		  /* 82250E5Ch */ case   27:  		/* bl -1020500 */
		/* 82250E5Ch case   27:*/		regs.LR = 0x82250E60; return 0x82157C08;
		/* 82250E5Ch case   27:*/		return 0x82250E60;
	}
	return 0x82250E60;
} // Block from 82250DF0h-82250E60h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82250E60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250E60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250E60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250E60);
		  /* 82250E60h */ case    0:  		/* lwz R10, <#[R30 + 12]> */
		/* 82250E60h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000000C) );
		/* 82250E60h case    0:*/		return 0x82250E64;
		  /* 82250E64h */ case    1:  		/* or R11, R10, R31 */
		/* 82250E64h case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R31);
		/* 82250E64h case    1:*/		return 0x82250E68;
		  /* 82250E68h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 82250E68h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82250E68h case    2:*/		return 0x82250E6C;
		  /* 82250E6Ch */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 82250E6Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82250E84;  }
		/* 82250E6Ch case    3:*/		return 0x82250E70;
		  /* 82250E70h */ case    4:  		/* stw R11, <#[R30 + 12]> */
		/* 82250E70h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82250E70h case    4:*/		return 0x82250E74;
		  /* 82250E74h */ case    5:  		/* addi R3, R1, 96 */
		/* 82250E74h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82250E74h case    5:*/		return 0x82250E78;
		  /* 82250E78h */ case    6:  		/* lwz R4, <#[R1 + 100]> */
		/* 82250E78h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000064) );
		/* 82250E78h case    6:*/		return 0x82250E7C;
		  /* 82250E7Ch */ case    7:  		/* bl 11332 */
		/* 82250E7Ch case    7:*/		regs.LR = 0x82250E80; return 0x82253AC0;
		/* 82250E7Ch case    7:*/		return 0x82250E80;
		  /* 82250E80h */ case    8:  		/* stw R30, <#[R3]> */
		/* 82250E80h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82250E80h case    8:*/		return 0x82250E84;
	}
	return 0x82250E84;
} // Block from 82250E60h-82250E84h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82250E84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250E84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250E84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250E84);
		  /* 82250E84h */ case    0:  		/* lwz R8, <#[R1 + 100]> */
		/* 82250E84h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000064) );
		/* 82250E84h case    0:*/		return 0x82250E88;
		  /* 82250E88h */ case    1:  		/* cmplwi CR6, R8, 0 */
		/* 82250E88h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82250E88h case    1:*/		return 0x82250E8C;
		  /* 82250E8Ch */ case    2:  		/* bc 4, CR6_EQ, -372 */
		/* 82250E8Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82250D18;  }
		/* 82250E8Ch case    2:*/		return 0x82250E90;
		  /* 82250E90h */ case    3:  		/* lwz R8, <#[R25 + 136]> */
		/* 82250E90h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R25 + 0x00000088) );
		/* 82250E90h case    3:*/		return 0x82250E94;
		  /* 82250E94h */ case    4:  		/* b 132 */
		/* 82250E94h case    4:*/		return 0x82250F18;
		/* 82250E94h case    4:*/		return 0x82250E98;
		  /* 82250E98h */ case    5:  		/* lwz R11, <#[R8 + 28]> */
		/* 82250E98h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x0000001C) );
		/* 82250E98h case    5:*/		return 0x82250E9C;
		  /* 82250E9Ch */ case    6:  		/* b 108 */
		/* 82250E9Ch case    6:*/		return 0x82250F08;
		/* 82250E9Ch case    6:*/		return 0x82250EA0;
		  /* 82250EA0h */ case    7:  		/* lwz R10, <#[R11 + 228]> */
		/* 82250EA0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 82250EA0h case    7:*/		return 0x82250EA4;
		  /* 82250EA4h */ case    8:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82250EA4h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82250EA4h case    8:*/		return 0x82250EA8;
		  /* 82250EA8h */ case    9:  		/* bc 12, CR0_EQ, 92 */
		/* 82250EA8h case    9:*/		if ( regs.CR[0].eq ) { return 0x82250F04;  }
		/* 82250EA8h case    9:*/		return 0x82250EAC;
		  /* 82250EACh */ case   10:  		/* lwz R7, <#[R11 + 12]> */
		/* 82250EACh case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 82250EACh case   10:*/		return 0x82250EB0;
		  /* 82250EB0h */ case   11:  		/* li R9, 4 */
		/* 82250EB0h case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 82250EB0h case   11:*/		return 0x82250EB4;
		  /* 82250EB4h */ case   12:  		/* lwz R6, <#[R11 + 128]> */
		/* 82250EB4h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000080) );
		/* 82250EB4h case   12:*/		return 0x82250EB8;
		  /* 82250EB8h */ case   13:  		/* mr R10, R26 */
		/* 82250EB8h case   13:*/		regs.R10 = regs.R26;
		/* 82250EB8h case   13:*/		return 0x82250EBC;
		  /* 82250EBCh */ case   14:  		/* stw R7, <#[R1 + 80]> */
		/* 82250EBCh case   14:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 82250EBCh case   14:*/		return 0x82250EC0;
		  /* 82250EC0h */ case   15:  		/* mtspr CTR, R9 */
		/* 82250EC0h case   15:*/		regs.CTR = regs.R9;
		/* 82250EC0h case   15:*/		return 0x82250EC4;
		  /* 82250EC4h */ case   16:  		/* stw R6, <#[R1 + 84]> */
		/* 82250EC4h case   16:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 82250EC4h case   16:*/		return 0x82250EC8;
		  /* 82250EC8h */ case   17:  		/* addi R9, R1, 80 */
		/* 82250EC8h case   17:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 82250EC8h case   17:*/		return 0x82250ECC;
		  /* 82250ECCh */ case   18:  		/* lbzx R9, <#[R10 + R9]> */
		/* 82250ECCh case   18:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82250ECCh case   18:*/		return 0x82250ED0;
		  /* 82250ED0h */ case   19:  		/* cmplwi CR6, R9, 1 */
		/* 82250ED0h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 82250ED0h case   19:*/		return 0x82250ED4;
		  /* 82250ED4h */ case   20:  		/* bc 4, CR6_EQ, 16 */
		/* 82250ED4h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82250EE4;  }
		/* 82250ED4h case   20:*/		return 0x82250ED8;
		  /* 82250ED8h */ case   21:  		/* addi R9, R1, 84 */
		/* 82250ED8h case   21:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x54);
		/* 82250ED8h case   21:*/		return 0x82250EDC;
		  /* 82250EDCh */ case   22:  		/* lbzx R9, <#[R10 + R9]> */
		/* 82250EDCh case   22:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82250EDCh case   22:*/		return 0x82250EE0;
		  /* 82250EE0h */ case   23:  		/* b 8 */
		/* 82250EE0h case   23:*/		return 0x82250EE8;
		/* 82250EE0h case   23:*/		return 0x82250EE4;
	}
	return 0x82250EE4;
} // Block from 82250E84h-82250EE4h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82250EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250EE4);
		  /* 82250EE4h */ case    0:  		/* li R9, 1 */
		/* 82250EE4h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82250EE4h case    0:*/		return 0x82250EE8;
	}
	return 0x82250EE8;
} // Block from 82250EE4h-82250EE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82250EE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250EE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250EE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250EE8);
		  /* 82250EE8h */ case    0:  		/* addi R7, R1, 84 */
		/* 82250EE8h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x54);
		/* 82250EE8h case    0:*/		return 0x82250EEC;
		  /* 82250EECh */ case    1:  		/* rlwinm R9, R9, 0, 24, 31 */
		/* 82250EECh case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R9,regs.R9);
		/* 82250EECh case    1:*/		return 0x82250EF0;
		  /* 82250EF0h */ case    2:  		/* stbx R9, <#[R10 + R7]> */
		/* 82250EF0h case    2:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 82250EF0h case    2:*/		return 0x82250EF4;
		  /* 82250EF4h */ case    3:  		/* addi R10, R10, 1 */
		/* 82250EF4h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82250EF4h case    3:*/		return 0x82250EF8;
		  /* 82250EF8h */ case    4:  		/* bc 16, CR0_LT, -48 */
		/* 82250EF8h case    4:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82250EC8;  }
		/* 82250EF8h case    4:*/		return 0x82250EFC;
		  /* 82250EFCh */ case    5:  		/* lwz R10, <#[R1 + 84]> */
		/* 82250EFCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82250EFCh case    5:*/		return 0x82250F00;
		  /* 82250F00h */ case    6:  		/* stw R10, <#[R11 + 128]> */
		/* 82250F00h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000080) );
		/* 82250F00h case    6:*/		return 0x82250F04;
	}
	return 0x82250F04;
} // Block from 82250EE8h-82250F04h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82250F04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250F04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250F04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250F04);
		  /* 82250F04h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82250F04h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82250F04h case    0:*/		return 0x82250F08;
	}
	return 0x82250F08;
} // Block from 82250F04h-82250F08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82250F08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250F08);
		  /* 82250F08h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 82250F08h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82250F08h case    0:*/		return 0x82250F0C;
		  /* 82250F0Ch */ case    1:  		/* cmpwi CR6, R10, 0 */
		/* 82250F0Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82250F0Ch case    1:*/		return 0x82250F10;
		  /* 82250F10h */ case    2:  		/* bc 4, CR6_EQ, -112 */
		/* 82250F10h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82250EA0;  }
		/* 82250F10h case    2:*/		return 0x82250F14;
		  /* 82250F14h */ case    3:  		/* lwz R8, <#[R8 + 8]> */
		/* 82250F14h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000008) );
		/* 82250F14h case    3:*/		return 0x82250F18;
	}
	return 0x82250F18;
} // Block from 82250F08h-82250F18h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82250F18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82250F18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82250F18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82250F18);
		  /* 82250F18h */ case    0:  		/* lwz R11, <#[R8 + 8]> */
		/* 82250F18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000008) );
		/* 82250F18h case    0:*/		return 0x82250F1C;
		  /* 82250F1Ch */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82250F1Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82250F1Ch case    1:*/		return 0x82250F20;
		  /* 82250F20h */ case    2:  		/* bc 4, CR6_EQ, -136 */
		/* 82250F20h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82250E98;  }
		/* 82250F20h case    2:*/		return 0x82250F24;
		  /* 82250F24h */ case    3:  		/* lwz R25, <#[R25 + 136]> */
		/* 82250F24h case    3:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R25 + 0x00000088) );
		/* 82250F24h case    3:*/		return 0x82250F28;
		  /* 82250F28h */ case    4:  		/* lwz R11, <#[R25 + 8]> */
		/* 82250F28h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 82250F28h case    4:*/		return 0x82250F2C;
		  /* 82250F2Ch */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 82250F2Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82250F2Ch case    5:*/		return 0x82250F30;
		  /* 82250F30h */ case    6:  		/* bc 12, CR6_EQ, 648 */
		/* 82250F30h case    6:*/		if ( regs.CR[6].eq ) { return 0x822511B8;  }
		/* 82250F30h case    6:*/		return 0x82250F34;
		  /* 82250F34h */ case    7:  		/* lis R11, -32252 */
		/* 82250F34h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82250F34h case    7:*/		return 0x82250F38;
		  /* 82250F38h */ case    8:  		/* addi R27, R11, 15916 */
		/* 82250F38h case    8:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0x3E2C);
		/* 82250F38h case    8:*/		return 0x82250F3C;
		  /* 82250F3Ch */ case    9:  		/* lwz R31, <#[R25 + 28]> */
		/* 82250F3Ch case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R25 + 0x0000001C) );
		/* 82250F3Ch case    9:*/		return 0x82250F40;
		  /* 82250F40h */ case   10:  		/* b 604 */
		/* 82250F40h case   10:*/		return 0x8225119C;
		/* 82250F40h case   10:*/		return 0x82250F44;
		  /* 82250F44h */ case   11:  		/* lwz R11, <#[R31 + 228]> */
		/* 82250F44h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82250F44h case   11:*/		return 0x82250F48;
		  /* 82250F48h */ case   12:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82250F48h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82250F48h case   12:*/		return 0x82250F4C;
		  /* 82250F4Ch */ case   13:  		/* bc 12, CR0_EQ, 588 */
		/* 82250F4Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x82251198;  }
		/* 82250F4Ch case   13:*/		return 0x82250F50;
		  /* 82250F50h */ case   14:  		/* lwz R11, <#[R27 + 24]> */
		/* 82250F50h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000018) );
		/* 82250F50h case   14:*/		return 0x82250F54;
		  /* 82250F54h */ case   15:  		/* lwz R10, <#[R31 + 128]> */
		/* 82250F54h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000080) );
		/* 82250F54h case   15:*/		return 0x82250F58;
		  /* 82250F58h */ case   16:  		/* cmplw CR6, R10, R11 */
		/* 82250F58h case   16:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82250F58h case   16:*/		return 0x82250F5C;
		  /* 82250F5Ch */ case   17:  		/* bc 12, CR6_EQ, 568 */
		/* 82250F5Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x82251194;  }
		/* 82250F5Ch case   17:*/		return 0x82250F60;
		  /* 82250F60h */ case   18:  		/* lwz R11, <#[R31]> */
		/* 82250F60h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82250F60h case   18:*/		return 0x82250F64;
		  /* 82250F64h */ case   19:  		/* mr R3, R31 */
		/* 82250F64h case   19:*/		regs.R3 = regs.R31;
		/* 82250F64h case   19:*/		return 0x82250F68;
		  /* 82250F68h */ case   20:  		/* li R28, 1 */
		/* 82250F68h case   20:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 82250F68h case   20:*/		return 0x82250F6C;
		  /* 82250F6Ch */ case   21:  		/* lwz R11, <#[R11 + 4]> */
		/* 82250F6Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82250F6Ch case   21:*/		return 0x82250F70;
		  /* 82250F70h */ case   22:  		/* mtspr CTR, R11 */
		/* 82250F70h case   22:*/		regs.CTR = regs.R11;
		/* 82250F70h case   22:*/		return 0x82250F74;
		  /* 82250F74h */ case   23:  		/* bcctrl 20, CR0_LT */
		/* 82250F74h case   23:*/		if ( 1 ) { regs.LR = 0x82250F78; return (uint32)regs.CTR; }
		/* 82250F74h case   23:*/		return 0x82250F78;
		  /* 82250F78h */ case   24:  		/* cmpwi CR6, R3, 1 */
		/* 82250F78h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82250F78h case   24:*/		return 0x82250F7C;
		  /* 82250F7Ch */ case   25:  		/* bc 12, CR6_LT, 340 */
		/* 82250F7Ch case   25:*/		if ( regs.CR[6].lt ) { return 0x822510D0;  }
		/* 82250F7Ch case   25:*/		return 0x82250F80;
		  /* 82250F80h */ case   26:  		/* addi R30, R31, 132 */
		/* 82250F80h case   26:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x84);
		/* 82250F80h case   26:*/		return 0x82250F84;
		  /* 82250F84h */ case   27:  		/* lwz R3, <#[R30 + 104]> */
		/* 82250F84h case   27:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000068) );
		/* 82250F84h case   27:*/		return 0x82250F88;
		  /* 82250F88h */ case   28:  		/* li R11, 4 */
		/* 82250F88h case   28:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 82250F88h case   28:*/		return 0x82250F8C;
		  /* 82250F8Ch */ case   29:  		/* lwz R10, <#[R30]> */
		/* 82250F8Ch case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82250F8Ch case   29:*/		return 0x82250F90;
		  /* 82250F90h */ case   30:  		/* mr R29, R26 */
		/* 82250F90h case   30:*/		regs.R29 = regs.R26;
		/* 82250F90h case   30:*/		return 0x82250F94;
		  /* 82250F94h */ case   31:  		/* stw R26, <#[R1 + 80]> */
		/* 82250F94h case   31:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 82250F94h case   31:*/		return 0x82250F98;
		  /* 82250F98h */ case   32:  		/* mr R8, R26 */
		/* 82250F98h case   32:*/		regs.R8 = regs.R26;
		/* 82250F98h case   32:*/		return 0x82250F9C;
		  /* 82250F9Ch */ case   33:  		/* lwz R9, <#[R3 + 128]> */
		/* 82250F9Ch case   33:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000080) );
		/* 82250F9Ch case   33:*/		return 0x82250FA0;
		  /* 82250FA0h */ case   34:  		/* mtspr CTR, R11 */
		/* 82250FA0h case   34:*/		regs.CTR = regs.R11;
		/* 82250FA0h case   34:*/		return 0x82250FA4;
		  /* 82250FA4h */ case   35:  		/* stw R10, <#[R1 + 88]> */
		/* 82250FA4h case   35:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82250FA4h case   35:*/		return 0x82250FA8;
		  /* 82250FA8h */ case   36:  		/* stw R9, <#[R1 + 84]> */
		/* 82250FA8h case   36:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 82250FA8h case   36:*/		return 0x82250FAC;
		  /* 82250FACh */ case   37:  		/* lbz R9, <#[R1 + 86]> */
		/* 82250FACh case   37:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000056) );
		/* 82250FACh case   37:*/		return 0x82250FB0;
		  /* 82250FB0h */ case   38:  		/* lbz R10, <#[R1 + 85]> */
		/* 82250FB0h case   38:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000055) );
		/* 82250FB0h case   38:*/		return 0x82250FB4;
		  /* 82250FB4h */ case   39:  		/* addi R10, R10, -1 */
		/* 82250FB4h case   39:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82250FB4h case   39:*/		return 0x82250FB8;
		  /* 82250FB8h */ case   40:  		/* lbz R11, <#[R1 + 84]> */
		/* 82250FB8h case   40:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82250FB8h case   40:*/		return 0x82250FBC;
		  /* 82250FBCh */ case   41:  		/* lbz R7, <#[R1 + 87]> */
		/* 82250FBCh case   41:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000057) );
		/* 82250FBCh case   41:*/		return 0x82250FC0;
		  /* 82250FC0h */ case   42:  		/* addi R11, R11, -1 */
		/* 82250FC0h case   42:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82250FC0h case   42:*/		return 0x82250FC4;
		  /* 82250FC4h */ case   43:  		/* addic R6, R11, -1 */
		/* 82250FC4h case   43:*/		cpu::op::addic<0>(regs,&regs.R6,regs.R11,0xFFFFFFFF);
		/* 82250FC4h case   43:*/		return 0x82250FC8;
		  /* 82250FC8h */ case   44:  		/* subfe R6, R6, R11 */
		/* 82250FC8h case   44:*/		cpu::op::subfe<0>(regs,&regs.R6,regs.R6,regs.R11);
		/* 82250FC8h case   44:*/		return 0x82250FCC;
		  /* 82250FCCh */ case   45:  		/* addic R5, R10, -1 */
		/* 82250FCCh case   45:*/		cpu::op::addic<0>(regs,&regs.R5,regs.R10,0xFFFFFFFF);
		/* 82250FCCh case   45:*/		return 0x82250FD0;
		  /* 82250FD0h */ case   46:  		/* addi R11, R9, -1 */
		/* 82250FD0h case   46:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 82250FD0h case   46:*/		return 0x82250FD4;
		  /* 82250FD4h */ case   47:  		/* stb R6, <#[R1 + 80]> */
		/* 82250FD4h case   47:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 82250FD4h case   47:*/		return 0x82250FD8;
		  /* 82250FD8h */ case   48:  		/* subfe R10, R5, R10 */
		/* 82250FD8h case   48:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R5,regs.R10);
		/* 82250FD8h case   48:*/		return 0x82250FDC;
		  /* 82250FDCh */ case   49:  		/* addic R6, R11, -1 */
		/* 82250FDCh case   49:*/		cpu::op::addic<0>(regs,&regs.R6,regs.R11,0xFFFFFFFF);
		/* 82250FDCh case   49:*/		return 0x82250FE0;
		  /* 82250FE0h */ case   50:  		/* stb R10, <#[R1 + 81]> */
		/* 82250FE0h case   50:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0x00000051) );
		/* 82250FE0h case   50:*/		return 0x82250FE4;
		  /* 82250FE4h */ case   51:  		/* addi R10, R7, -1 */
		/* 82250FE4h case   51:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R7,0xFFFFFFFF);
		/* 82250FE4h case   51:*/		return 0x82250FE8;
		  /* 82250FE8h */ case   52:  		/* subfe R11, R6, R11 */
		/* 82250FE8h case   52:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R6,regs.R11);
		/* 82250FE8h case   52:*/		return 0x82250FEC;
		  /* 82250FECh */ case   53:  		/* mr R9, R7 */
		/* 82250FECh case   53:*/		regs.R9 = regs.R7;
		/* 82250FECh case   53:*/		return 0x82250FF0;
		  /* 82250FF0h */ case   54:  		/* stb R11, <#[R1 + 82]> */
		/* 82250FF0h case   54:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000052) );
		/* 82250FF0h case   54:*/		return 0x82250FF4;
		  /* 82250FF4h */ case   55:  		/* addic R11, R10, -1 */
		/* 82250FF4h case   55:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 82250FF4h case   55:*/		return 0x82250FF8;
		  /* 82250FF8h */ case   56:  		/* subfe R11, R11, R10 */
		/* 82250FF8h case   56:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82250FF8h case   56:*/		return 0x82250FFC;
		  /* 82250FFCh */ case   57:  		/* stb R11, <#[R1 + 83]> */
		/* 82250FFCh case   57:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000053) );
		/* 82250FFCh case   57:*/		return 0x82251000;
		  /* 82251000h */ case   58:  		/* lwz R11, <#[R1 + 80]> */
		/* 82251000h case   58:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82251000h case   58:*/		return 0x82251004;
		  /* 82251004h */ case   59:  		/* addi R10, R1, 88 */
		/* 82251004h case   59:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x58);
		/* 82251004h case   59:*/		return 0x82251008;
		  /* 82251008h */ case   60:  		/* lbzx R10, <#[R8 + R10]> */
		/* 82251008h case   60:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 82251008h case   60:*/		return 0x8225100C;
		  /* 8225100Ch */ case   61:  		/* addi R8, R8, 1 */
		/* 8225100Ch case   61:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8225100Ch case   61:*/		return 0x82251010;
		  /* 82251010h */ case   62:  		/* rlwinm R10, R10, 2, 0, 31 */
		/* 82251010h case   62:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R10,regs.R10);
		/* 82251010h case   62:*/		return 0x82251014;
		  /* 82251014h */ case   63:  		/* lwzx R10, <#[R10 + R27]> */
		/* 82251014h case   63:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 82251014h case   63:*/		return 0x82251018;
		  /* 82251018h */ case   64:  		/* or R29, R10, R29 */
		/* 82251018h case   64:*/		cpu::op::or<0>(regs,&regs.R29,regs.R10,regs.R29);
		/* 82251018h case   64:*/		return 0x8225101C;
		  /* 8225101Ch */ case   65:  		/* bc 16, CR0_LT, -24 */
		/* 8225101Ch case   65:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82251004;  }
		/* 8225101Ch case   65:*/		return 0x82251020;
		  /* 82251020h */ case   66:  		/* cmplwi CR6, R11, 0 */
		/* 82251020h case   66:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82251020h case   66:*/		return 0x82251024;
		  /* 82251024h */ case   67:  		/* bc 12, CR6_EQ, 12 */
		/* 82251024h case   67:*/		if ( regs.CR[6].eq ) { return 0x82251030;  }
		/* 82251024h case   67:*/		return 0x82251028;
		  /* 82251028h */ case   68:  		/* cmplwi CR6, R29, 0 */
		/* 82251028h case   68:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82251028h case   68:*/		return 0x8225102C;
		  /* 8225102Ch */ case   69:  		/* bc 4, CR6_EQ, 112 */
		/* 8225102Ch case   69:*/		if ( !regs.CR[6].eq ) { return 0x8225109C;  }
		/* 8225102Ch case   69:*/		return 0x82251030;
	}
	return 0x82251030;
} // Block from 82250F18h-82251030h (70 instructions)

//////////////////////////////////////////////////////
// Block at 82251030h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251030);
		  /* 82251030h */ case    0:  		/* bl -111224 */
		/* 82251030h case    0:*/		regs.LR = 0x82251034; return 0x82235DB8;
		/* 82251030h case    0:*/		return 0x82251034;
		  /* 82251034h */ case    1:  		/* lwz R11, <#[R3 + 128]> */
		/* 82251034h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000080) );
		/* 82251034h case    1:*/		return 0x82251038;
		  /* 82251038h */ case    2:  		/* stw R26, <#[R1 + 80]> */
		/* 82251038h case    2:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 82251038h case    2:*/		return 0x8225103C;
		  /* 8225103Ch */ case    3:  		/* stw R11, <#[R1 + 84]> */
		/* 8225103Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8225103Ch case    3:*/		return 0x82251040;
		  /* 82251040h */ case    4:  		/* lbz R9, <#[R1 + 86]> */
		/* 82251040h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000056) );
		/* 82251040h case    4:*/		return 0x82251044;
		  /* 82251044h */ case    5:  		/* lbz R11, <#[R1 + 84]> */
		/* 82251044h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82251044h case    5:*/		return 0x82251048;
	}
	return 0x82251048;
} // Block from 82251030h-82251048h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82251048h
// Function '?CollapseSimilarInstructions@IRInst@XGRAPHICS@@QAAXPAVCFG@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251048( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251048) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251048);
		  /* 82251048h */ case    0:  		/* addi R11, R11, -1 */
		/* 82251048h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82251048h case    0:*/		return 0x8225104C;
		  /* 8225104Ch */ case    1:  		/* lbz R10, <#[R1 + 85]> */
		/* 8225104Ch case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000055) );
		/* 8225104Ch case    1:*/		return 0x82251050;
		  /* 82251050h */ case    2:  		/* addic R7, R11, -1 */
		/* 82251050h case    2:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R11,0xFFFFFFFF);
		/* 82251050h case    2:*/		return 0x82251054;
		  /* 82251054h */ case    3:  		/* lbz R8, <#[R1 + 87]> */
		/* 82251054h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000057) );
		/* 82251054h case    3:*/		return 0x82251058;
		  /* 82251058h */ case    4:  		/* addi R10, R10, -1 */
		/* 82251058h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82251058h case    4:*/		return 0x8225105C;
		  /* 8225105Ch */ case    5:  		/* subfe R7, R7, R11 */
		/* 8225105Ch case    5:*/		cpu::op::subfe<0>(regs,&regs.R7,regs.R7,regs.R11);
		/* 8225105Ch case    5:*/		return 0x82251060;
		  /* 82251060h */ case    6:  		/* addic R6, R10, -1 */
		/* 82251060h case    6:*/		cpu::op::addic<0>(regs,&regs.R6,regs.R10,0xFFFFFFFF);
		/* 82251060h case    6:*/		return 0x82251064;
		  /* 82251064h */ case    7:  		/* addi R11, R9, -1 */
		/* 82251064h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 82251064h case    7:*/		return 0x82251068;
		  /* 82251068h */ case    8:  		/* stb R7, <#[R1 + 80]> */
		/* 82251068h case    8:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 82251068h case    8:*/		return 0x8225106C;
		  /* 8225106Ch */ case    9:  		/* subfe R9, R6, R10 */
		/* 8225106Ch case    9:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R6,regs.R10);
		/* 8225106Ch case    9:*/		return 0x82251070;
		  /* 82251070h */ case   10:  		/* mr R10, R8 */
		/* 82251070h case   10:*/		regs.R10 = regs.R8;
		/* 82251070h case   10:*/		return 0x82251074;
		  /* 82251074h */ case   11:  		/* addic R8, R11, -1 */
		/* 82251074h case   11:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R11,0xFFFFFFFF);
		/* 82251074h case   11:*/		return 0x82251078;
		  /* 82251078h */ case   12:  		/* stb R9, <#[R1 + 81]> */
		/* 82251078h case   12:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R1 + 0x00000051) );
		/* 82251078h case   12:*/		return 0x8225107C;
		  /* 8225107Ch */ case   13:  		/* addi R10, R10, -1 */
		/* 8225107Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8225107Ch case   13:*/		return 0x82251080;
		  /* 82251080h */ case   14:  		/* subfe R11, R8, R11 */
		/* 82251080h case   14:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82251080h case   14:*/		return 0x82251084;
		  /* 82251084h */ case   15:  		/* addic R9, R10, -1 */
		/* 82251084h case   15:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 82251084h case   15:*/		return 0x82251088;
		  /* 82251088h */ case   16:  		/* stb R11, <#[R1 + 82]> */
		/* 82251088h case   16:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000052) );
		/* 82251088h case   16:*/		return 0x8225108C;
		  /* 8225108Ch */ case   17:  		/* subfe R11, R9, R10 */
		/* 8225108Ch case   17:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R9,regs.R10);
		/* 8225108Ch case   17:*/		return 0x82251090;
		  /* 82251090h */ case   18:  		/* stb R11, <#[R1 + 83]> */
		/* 82251090h case   18:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000053) );
		/* 82251090h case   18:*/		return 0x82251094;
		  /* 82251094h */ case   19:  		/* lwz R11, <#[R1 + 80]> */
		/* 82251094h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82251094h case   19:*/		return 0x82251098;
		  /* 82251098h */ case   20:  		/* b -120 */
		/* 82251098h case   20:*/		return 0x82251020;
		/* 82251098h case   20:*/		return 0x8225109C;
	}
	return 0x8225109C;
} // Block from 82251048h-8225109Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8225109Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225109C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225109C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225109C);
		  /* 8225109Ch */ case    0:  		/* mr R5, R3 */
		/* 8225109Ch case    0:*/		regs.R5 = regs.R3;
		/* 8225109Ch case    0:*/		return 0x822510A0;
		  /* 822510A0h */ case    1:  		/* mr R4, R28 */
		/* 822510A0h case    1:*/		regs.R4 = regs.R28;
		/* 822510A0h case    1:*/		return 0x822510A4;
		  /* 822510A4h */ case    2:  		/* mr R3, R31 */
		/* 822510A4h case    2:*/		regs.R3 = regs.R31;
		/* 822510A4h case    2:*/		return 0x822510A8;
		  /* 822510A8h */ case    3:  		/* bl -110936 */
		/* 822510A8h case    3:*/		regs.LR = 0x822510AC; return 0x82235F50;
		/* 822510A8h case    3:*/		return 0x822510AC;
		  /* 822510ACh */ case    4:  		/* lwz R11, <#[R31]> */
		/* 822510ACh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822510ACh case    4:*/		return 0x822510B0;
		  /* 822510B0h */ case    5:  		/* mr R3, R31 */
		/* 822510B0h case    5:*/		regs.R3 = regs.R31;
		/* 822510B0h case    5:*/		return 0x822510B4;
		  /* 822510B4h */ case    6:  		/* addi R28, R28, 1 */
		/* 822510B4h case    6:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 822510B4h case    6:*/		return 0x822510B8;
		  /* 822510B8h */ case    7:  		/* addi R30, R30, 4 */
		/* 822510B8h case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 822510B8h case    7:*/		return 0x822510BC;
		  /* 822510BCh */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 822510BCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822510BCh case    8:*/		return 0x822510C0;
		  /* 822510C0h */ case    9:  		/* mtspr CTR, R11 */
		/* 822510C0h case    9:*/		regs.CTR = regs.R11;
		/* 822510C0h case    9:*/		return 0x822510C4;
		  /* 822510C4h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 822510C4h case   10:*/		if ( 1 ) { regs.LR = 0x822510C8; return (uint32)regs.CTR; }
		/* 822510C4h case   10:*/		return 0x822510C8;
		  /* 822510C8h */ case   11:  		/* cmpw CR6, R28, R3 */
		/* 822510C8h case   11:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R3);
		/* 822510C8h case   11:*/		return 0x822510CC;
		  /* 822510CCh */ case   12:  		/* bc 4, CR6_GT, -328 */
		/* 822510CCh case   12:*/		if ( !regs.CR[6].gt ) { return 0x82250F84;  }
		/* 822510CCh case   12:*/		return 0x822510D0;
	}
	return 0x822510D0;
} // Block from 8225109Ch-822510D0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 822510D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822510D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822510D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822510D0);
		  /* 822510D0h */ case    0:  		/* lwz R11, <#[R31 + 228]> */
		/* 822510D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 822510D0h case    0:*/		return 0x822510D4;
		  /* 822510D4h */ case    1:  		/* rlwinm. R11, R11, 23, 31, 31 */
		/* 822510D4h case    1:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R11,regs.R11);
		/* 822510D4h case    1:*/		return 0x822510D8;
		  /* 822510D8h */ case    2:  		/* bc 12, CR0_EQ, 188 */
		/* 822510D8h case    2:*/		if ( regs.CR[0].eq ) { return 0x82251194;  }
		/* 822510D8h case    2:*/		return 0x822510DC;
		  /* 822510DCh */ case    3:  		/* mr R3, R31 */
		/* 822510DCh case    3:*/		regs.R3 = regs.R31;
		/* 822510DCh case    3:*/		return 0x822510E0;
		  /* 822510E0h */ case    4:  		/* bl -111400 */
		/* 822510E0h case    4:*/		regs.LR = 0x822510E4; return 0x82235DB8;
		/* 822510E0h case    4:*/		return 0x822510E4;
		  /* 822510E4h */ case    5:  		/* lwz R11, <#[R31 + 128]> */
		/* 822510E4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 822510E4h case    5:*/		return 0x822510E8;
		  /* 822510E8h */ case    6:  		/* stw R26, <#[R1 + 80]> */
		/* 822510E8h case    6:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 822510E8h case    6:*/		return 0x822510EC;
		  /* 822510ECh */ case    7:  		/* lwz R7, <#[R31 + 12]> */
		/* 822510ECh case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 822510ECh case    7:*/		return 0x822510F0;
		  /* 822510F0h */ case    8:  		/* mr R4, R7 */
		/* 822510F0h case    8:*/		regs.R4 = regs.R7;
		/* 822510F0h case    8:*/		return 0x822510F4;
		  /* 822510F4h */ case    9:  		/* stw R11, <#[R1 + 84]> */
		/* 822510F4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 822510F4h case    9:*/		return 0x822510F8;
		  /* 822510F8h */ case   10:  		/* lbz R10, <#[R1 + 85]> */
		/* 822510F8h case   10:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000055) );
		/* 822510F8h case   10:*/		return 0x822510FC;
		  /* 822510FCh */ case   11:  		/* lbz R6, <#[R1 + 84]> */
		/* 822510FCh case   11:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 822510FCh case   11:*/		return 0x82251100;
		  /* 82251100h */ case   12:  		/* lbz R11, <#[R1 + 87]> */
		/* 82251100h case   12:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000057) );
		/* 82251100h case   12:*/		return 0x82251104;
		  /* 82251104h */ case   13:  		/* lbz R8, <#[R1 + 86]> */
		/* 82251104h case   13:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000056) );
		/* 82251104h case   13:*/		return 0x82251108;
		  /* 82251108h */ case   14:  		/* addi R9, R11, -1 */
		/* 82251108h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 82251108h case   14:*/		return 0x8225110C;
		  /* 8225110Ch */ case   15:  		/* mr R11, R6 */
		/* 8225110Ch case   15:*/		regs.R11 = regs.R6;
		/* 8225110Ch case   15:*/		return 0x82251110;
		  /* 82251110h */ case   16:  		/* addi R11, R11, -1 */
		/* 82251110h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82251110h case   16:*/		return 0x82251114;
		  /* 82251114h */ case   17:  		/* addi R10, R10, -1 */
		/* 82251114h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82251114h case   17:*/		return 0x82251118;
		  /* 82251118h */ case   18:  		/* addic R6, R11, -1 */
		/* 82251118h case   18:*/		cpu::op::addic<0>(regs,&regs.R6,regs.R11,0xFFFFFFFF);
		/* 82251118h case   18:*/		return 0x8225111C;
		  /* 8225111Ch */ case   19:  		/* subfe R11, R6, R11 */
		/* 8225111Ch case   19:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R6,regs.R11);
		/* 8225111Ch case   19:*/		return 0x82251120;
		  /* 82251120h */ case   20:  		/* addic R6, R10, -1 */
		/* 82251120h case   20:*/		cpu::op::addic<0>(regs,&regs.R6,regs.R10,0xFFFFFFFF);
		/* 82251120h case   20:*/		return 0x82251124;
		  /* 82251124h */ case   21:  		/* stb R11, <#[R1 + 80]> */
		/* 82251124h case   21:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82251124h case   21:*/		return 0x82251128;
		  /* 82251128h */ case   22:  		/* addi R11, R8, -1 */
		/* 82251128h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0xFFFFFFFF);
		/* 82251128h case   22:*/		return 0x8225112C;
		  /* 8225112Ch */ case   23:  		/* subfe R10, R6, R10 */
		/* 8225112Ch case   23:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R6,regs.R10);
		/* 8225112Ch case   23:*/		return 0x82251130;
		  /* 82251130h */ case   24:  		/* addic R8, R11, -1 */
		/* 82251130h case   24:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R11,0xFFFFFFFF);
		/* 82251130h case   24:*/		return 0x82251134;
		  /* 82251134h */ case   25:  		/* stb R10, <#[R1 + 81]> */
		/* 82251134h case   25:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0x00000051) );
		/* 82251134h case   25:*/		return 0x82251138;
		  /* 82251138h */ case   26:  		/* subfe R11, R8, R11 */
		/* 82251138h case   26:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82251138h case   26:*/		return 0x8225113C;
		  /* 8225113Ch */ case   27:  		/* addic R10, R9, -1 */
		/* 8225113Ch case   27:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R9,0xFFFFFFFF);
		/* 8225113Ch case   27:*/		return 0x82251140;
		  /* 82251140h */ case   28:  		/* stb R11, <#[R1 + 82]> */
		/* 82251140h case   28:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000052) );
		/* 82251140h case   28:*/		return 0x82251144;
		  /* 82251144h */ case   29:  		/* subfe R11, R10, R9 */
		/* 82251144h case   29:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R10,regs.R9);
		/* 82251144h case   29:*/		return 0x82251148;
		  /* 82251148h */ case   30:  		/* stb R11, <#[R1 + 83]> */
		/* 82251148h case   30:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000053) );
		/* 82251148h case   30:*/		return 0x8225114C;
		  /* 8225114Ch */ case   31:  		/* lwz R9, <#[R1 + 80]> */
		/* 8225114Ch case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 8225114Ch case   31:*/		return 0x82251150;
		  /* 82251150h */ case   32:  		/* mr R3, R9 */
		/* 82251150h case   32:*/		regs.R3 = regs.R9;
		/* 82251150h case   32:*/		return 0x82251154;
		  /* 82251154h */ case   33:  		/* bl -6236 */
		/* 82251154h case   33:*/		regs.LR = 0x82251158; return 0x8224F8F8;
		/* 82251154h case   33:*/		return 0x82251158;
		  /* 82251158h */ case   34:  		/* mr R30, R3 */
		/* 82251158h case   34:*/		regs.R30 = regs.R3;
		/* 82251158h case   34:*/		return 0x8225115C;
		  /* 8225115Ch */ case   35:  		/* mr R3, R9 */
		/* 8225115Ch case   35:*/		regs.R3 = regs.R9;
		/* 8225115Ch case   35:*/		return 0x82251160;
		  /* 82251160h */ case   36:  		/* bl -6112 */
		/* 82251160h case   36:*/		regs.LR = 0x82251164; return 0x8224F980;
		/* 82251160h case   36:*/		return 0x82251164;
		  /* 82251164h */ case   37:  		/* cmplw CR6, R30, R3 */
		/* 82251164h case   37:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R3);
		/* 82251164h case   37:*/		return 0x82251168;
		  /* 82251168h */ case   38:  		/* bc 12, CR6_EQ, 28 */
		/* 82251168h case   38:*/		if ( regs.CR[6].eq ) { return 0x82251184;  }
		/* 82251168h case   38:*/		return 0x8225116C;
		  /* 8225116Ch */ case   39:  		/* mr R6, R22 */
		/* 8225116Ch case   39:*/		regs.R6 = regs.R22;
		/* 8225116Ch case   39:*/		return 0x82251170;
		  /* 82251170h */ case   40:  		/* mr R5, R23 */
		/* 82251170h case   40:*/		regs.R5 = regs.R23;
		/* 82251170h case   40:*/		return 0x82251174;
		  /* 82251174h */ case   41:  		/* mr R4, R24 */
		/* 82251174h case   41:*/		regs.R4 = regs.R24;
		/* 82251174h case   41:*/		return 0x82251178;
		  /* 82251178h */ case   42:  		/* li R7, 897 */
		/* 82251178h case   42:*/		cpu::op::li<0>(regs,&regs.R7,0x381);
		/* 82251178h case   42:*/		return 0x8225117C;
		  /* 8225117Ch */ case   43:  		/* li R3, 0 */
		/* 8225117Ch case   43:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225117Ch case   43:*/		return 0x82251180;
		  /* 82251180h */ case   44:  		/* bl -1021304 */
		/* 82251180h case   44:*/		regs.LR = 0x82251184; return 0x82157C08;
		/* 82251180h case   44:*/		return 0x82251184;
	}
	return 0x82251184;
} // Block from 822510D0h-82251184h (45 instructions)

//////////////////////////////////////////////////////
// Block at 82251184h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251184( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251184) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251184);
		  /* 82251184h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 82251184h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82251184h case    0:*/		return 0x82251188;
		  /* 82251188h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82251188h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82251194;  }
		/* 82251188h case    1:*/		return 0x8225118C;
		  /* 8225118Ch */ case    2:  		/* mr R3, R31 */
		/* 8225118Ch case    2:*/		regs.R3 = regs.R31;
		/* 8225118Ch case    2:*/		return 0x82251190;
		  /* 82251190h */ case    3:  		/* bl -111472 */
		/* 82251190h case    3:*/		regs.LR = 0x82251194; return 0x82235E20;
		/* 82251190h case    3:*/		return 0x82251194;
	}
	return 0x82251194;
} // Block from 82251184h-82251194h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82251194h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251194( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251194) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251194);
		  /* 82251194h */ case    0:  		/* stw R26, <#[R31 + 12]> */
		/* 82251194h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x0000000C) );
		/* 82251194h case    0:*/		return 0x82251198;
	}
	return 0x82251198;
} // Block from 82251194h-82251198h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82251198h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251198);
		  /* 82251198h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 82251198h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 82251198h case    0:*/		return 0x8225119C;
	}
	return 0x8225119C;
} // Block from 82251198h-8225119Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225119Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225119C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225119C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225119C);
		  /* 8225119Ch */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8225119Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8225119Ch case    0:*/		return 0x822511A0;
		  /* 822511A0h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 822511A0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 822511A0h case    1:*/		return 0x822511A4;
		  /* 822511A4h */ case    2:  		/* bc 4, CR6_EQ, -608 */
		/* 822511A4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82250F44;  }
		/* 822511A4h case    2:*/		return 0x822511A8;
		  /* 822511A8h */ case    3:  		/* lwz R25, <#[R25 + 8]> */
		/* 822511A8h case    3:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R25 + 0x00000008) );
		/* 822511A8h case    3:*/		return 0x822511AC;
		  /* 822511ACh */ case    4:  		/* lwz R11, <#[R25 + 8]> */
		/* 822511ACh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 822511ACh case    4:*/		return 0x822511B0;
		  /* 822511B0h */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 822511B0h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 822511B0h case    5:*/		return 0x822511B4;
		  /* 822511B4h */ case    6:  		/* bc 4, CR6_EQ, -632 */
		/* 822511B4h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82250F3C;  }
		/* 822511B4h case    6:*/		return 0x822511B8;
	}
	return 0x822511B8;
} // Block from 8225119Ch-822511B8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822511B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822511B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822511B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822511B8);
		  /* 822511B8h */ case    0:  		/* lwz R4, <#[R1 + 104]> */
		/* 822511B8h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000068) );
		/* 822511B8h case    0:*/		return 0x822511BC;
		  /* 822511BCh */ case    1:  		/* lwz R3, <#[R1 + 108]> */
		/* 822511BCh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000006C) );
		/* 822511BCh case    1:*/		return 0x822511C0;
		  /* 822511C0h */ case    2:  		/* bl -215936 */
		/* 822511C0h case    2:*/		regs.LR = 0x822511C4; return 0x8221C640;
		/* 822511C0h case    2:*/		return 0x822511C4;
		  /* 822511C4h */ case    3:  		/* addi R1, R1, 208 */
		/* 822511C4h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 822511C4h case    3:*/		return 0x822511C8;
		  /* 822511C8h */ case    4:  		/* b -1834808 */
		/* 822511C8h case    4:*/		return 0x82091290;
		/* 822511C8h case    4:*/		return 0x822511CC;
		  /* 822511CCh */ case    5:  		/* nop */
		/* 822511CCh case    5:*/		cpu::op::nop();
		/* 822511CCh case    5:*/		return 0x822511D0;
	}
	return 0x822511D0;
} // Block from 822511B8h-822511D0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822511D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822511D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822511D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822511D0);
		  /* 822511D0h */ case    0:  		/* mfspr R12, LR */
		/* 822511D0h case    0:*/		regs.R12 = regs.LR;
		/* 822511D0h case    0:*/		return 0x822511D4;
		  /* 822511D4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822511D4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822511D4h case    1:*/		return 0x822511D8;
		  /* 822511D8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 822511D8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822511D8h case    2:*/		return 0x822511DC;
		  /* 822511DCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 822511DCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822511DCh case    3:*/		return 0x822511E0;
		  /* 822511E0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 822511E0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822511E0h case    4:*/		return 0x822511E4;
		  /* 822511E4h */ case    5:  		/* lwz R11, <#[R4 + 12]> */
		/* 822511E4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 822511E4h case    5:*/		return 0x822511E8;
		  /* 822511E8h */ case    6:  		/* mr R30, R3 */
		/* 822511E8h case    6:*/		regs.R30 = regs.R3;
		/* 822511E8h case    6:*/		return 0x822511EC;
		  /* 822511ECh */ case    7:  		/* mr R31, R4 */
		/* 822511ECh case    7:*/		regs.R31 = regs.R4;
		/* 822511ECh case    7:*/		return 0x822511F0;
		  /* 822511F0h */ case    8:  		/* lwz R11, <#[R11 + 2136]> */
		/* 822511F0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000858) );
		/* 822511F0h case    8:*/		return 0x822511F4;
		  /* 822511F4h */ case    9:  		/* rlwinm. R11, R11, 26, 31, 31 */
		/* 822511F4h case    9:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R11,regs.R11);
		/* 822511F4h case    9:*/		return 0x822511F8;
		  /* 822511F8h */ case   10:  		/* bc 12, CR0_EQ, 8 */
		/* 822511F8h case   10:*/		if ( regs.CR[0].eq ) { return 0x82251200;  }
		/* 822511F8h case   10:*/		return 0x822511FC;
		  /* 822511FCh */ case   11:  		/* bl -3868 */
		/* 822511FCh case   11:*/		regs.LR = 0x82251200; return 0x822502E0;
		/* 822511FCh case   11:*/		return 0x82251200;
	}
	return 0x82251200;
} // Block from 822511D0h-82251200h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82251200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251200);
		  /* 82251200h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82251200h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82251200h case    0:*/		return 0x82251204;
		  /* 82251204h */ case    1:  		/* lwz R11, <#[R11 + 2136]> */
		/* 82251204h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000858) );
		/* 82251204h case    1:*/		return 0x82251208;
		  /* 82251208h */ case    2:  		/* rlwinm. R11, R11, 25, 31, 31 */
		/* 82251208h case    2:*/		cpu::op::rlwinm<1,25,31,31>(regs,&regs.R11,regs.R11);
		/* 82251208h case    2:*/		return 0x8225120C;
		  /* 8225120Ch */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 8225120Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x8225121C;  }
		/* 8225120Ch case    3:*/		return 0x82251210;
		  /* 82251210h */ case    4:  		/* mr R4, R31 */
		/* 82251210h case    4:*/		regs.R4 = regs.R31;
		/* 82251210h case    4:*/		return 0x82251214;
		  /* 82251214h */ case    5:  		/* mr R3, R30 */
		/* 82251214h case    5:*/		regs.R3 = regs.R30;
		/* 82251214h case    5:*/		return 0x82251218;
		  /* 82251218h */ case    6:  		/* bl -3296 */
		/* 82251218h case    6:*/		regs.LR = 0x8225121C; return 0x82250538;
		/* 82251218h case    6:*/		return 0x8225121C;
	}
	return 0x8225121C;
} // Block from 82251200h-8225121Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225121Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225121C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225121C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225121C);
		  /* 8225121Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 8225121Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8225121Ch case    0:*/		return 0x82251220;
		  /* 82251220h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82251220h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82251220h case    1:*/		return 0x82251224;
		  /* 82251224h */ case    2:  		/* mtspr LR, R12 */
		/* 82251224h case    2:*/		regs.LR = regs.R12;
		/* 82251224h case    2:*/		return 0x82251228;
		  /* 82251228h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82251228h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82251228h case    3:*/		return 0x8225122C;
		  /* 8225122Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8225122Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225122Ch case    4:*/		return 0x82251230;
		  /* 82251230h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82251230h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82251230h case    5:*/		return 0x82251234;
	}
	return 0x82251234;
} // Block from 8225121Ch-82251234h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82251234h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251234);
		  /* 82251234h */ case    0:  		/* nop */
		/* 82251234h case    0:*/		cpu::op::nop();
		/* 82251234h case    0:*/		return 0x82251238;
	}
	return 0x82251238;
} // Block from 82251234h-82251238h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82251238h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251238);
		  /* 82251238h */ case    0:  		/* mfspr R12, LR */
		/* 82251238h case    0:*/		regs.R12 = regs.LR;
		/* 82251238h case    0:*/		return 0x8225123C;
		  /* 8225123Ch */ case    1:  		/* bl -1834996 */
		/* 8225123Ch case    1:*/		regs.LR = 0x82251240; return 0x82091248;
		/* 8225123Ch case    1:*/		return 0x82251240;
		  /* 82251240h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 82251240h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82251240h case    2:*/		return 0x82251244;
		  /* 82251244h */ case    3:  		/* mr R30, R3 */
		/* 82251244h case    3:*/		regs.R30 = regs.R3;
		/* 82251244h case    3:*/		return 0x82251248;
		  /* 82251248h */ case    4:  		/* lwz R11, <#[R3 + 2148]> */
		/* 82251248h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000864) );
		/* 82251248h case    4:*/		return 0x8225124C;
		  /* 8225124Ch */ case    5:  		/* addi R3, R1, 80 */
		/* 8225124Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8225124Ch case    5:*/		return 0x82251250;
		  /* 82251250h */ case    6:  		/* addi R11, R11, 1 */
		/* 82251250h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82251250h case    6:*/		return 0x82251254;
		  /* 82251254h */ case    7:  		/* lwz R10, <#[R30 + 2152]> */
		/* 82251254h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000868) );
		/* 82251254h case    7:*/		return 0x82251258;
		  /* 82251258h */ case    8:  		/* stw R11, <#[R30 + 2148]> */
		/* 82251258h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000864) );
		/* 82251258h case    8:*/		return 0x8225125C;
		  /* 8225125Ch */ case    9:  		/* addi R10, R10, 1 */
		/* 8225125Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8225125Ch case    9:*/		return 0x82251260;
		  /* 82251260h */ case   10:  		/* lwz R9, <#[R30 + 12]> */
		/* 82251260h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000000C) );
		/* 82251260h case   10:*/		return 0x82251264;
		  /* 82251264h */ case   11:  		/* stw R10, <#[R30 + 2152]> */
		/* 82251264h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000868) );
		/* 82251264h case   11:*/		return 0x82251268;
		  /* 82251268h */ case   12:  		/* lwz R4, <#[R9 + 1456]> */
		/* 82251268h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R9 + 0x000005B0) );
		/* 82251268h case   12:*/		return 0x8225126C;
		  /* 8225126Ch */ case   13:  		/* bl -111884 */
		/* 8225126Ch case   13:*/		regs.LR = 0x82251270; return 0x82235D60;
		/* 8225126Ch case   13:*/		return 0x82251270;
		  /* 82251270h */ case   14:  		/* lwz R29, <#[R30 + 136]> */
		/* 82251270h case   14:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000088) );
		/* 82251270h case   14:*/		return 0x82251274;
		  /* 82251274h */ case   15:  		/* b 136 */
		/* 82251274h case   15:*/		return 0x822512FC;
		/* 82251274h case   15:*/		return 0x82251278;
		  /* 82251278h */ case   16:  		/* lwz R31, <#[R29 + 28]> */
		/* 82251278h case   16:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x0000001C) );
		/* 82251278h case   16:*/		return 0x8225127C;
		  /* 8225127Ch */ case   17:  		/* b 112 */
		/* 8225127Ch case   17:*/		return 0x822512EC;
		/* 8225127Ch case   17:*/		return 0x82251280;
		  /* 82251280h */ case   18:  		/* lwz R11, <#[R31 + 228]> */
		/* 82251280h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82251280h case   18:*/		return 0x82251284;
		  /* 82251284h */ case   19:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82251284h case   19:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82251284h case   19:*/		return 0x82251288;
		  /* 82251288h */ case   20:  		/* bc 12, CR0_EQ, 96 */
		/* 82251288h case   20:*/		if ( regs.CR[0].eq ) { return 0x822512E8;  }
		/* 82251288h case   20:*/		return 0x8225128C;
		  /* 8225128Ch */ case   21:  		/* lwz R11, <#[R31]> */
		/* 8225128Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8225128Ch case   21:*/		return 0x82251290;
		  /* 82251290h */ case   22:  		/* mr R3, R31 */
		/* 82251290h case   22:*/		regs.R3 = regs.R31;
		/* 82251290h case   22:*/		return 0x82251294;
		  /* 82251294h */ case   23:  		/* lwz R11, <#[R11 + 36]> */
		/* 82251294h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82251294h case   23:*/		return 0x82251298;
		  /* 82251298h */ case   24:  		/* mtspr CTR, R11 */
		/* 82251298h case   24:*/		regs.CTR = regs.R11;
		/* 82251298h case   24:*/		return 0x8225129C;
		  /* 8225129Ch */ case   25:  		/* bcctrl 20, CR0_LT */
		/* 8225129Ch case   25:*/		if ( 1 ) { regs.LR = 0x822512A0; return (uint32)regs.CTR; }
		/* 8225129Ch case   25:*/		return 0x822512A0;
		  /* 822512A0h */ case   26:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822512A0h case   26:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822512A0h case   26:*/		return 0x822512A4;
		  /* 822512A4h */ case   27:  		/* bc 4, CR0_EQ, 32 */
		/* 822512A4h case   27:*/		if ( !regs.CR[0].eq ) { return 0x822512C4;  }
		/* 822512A4h case   27:*/		return 0x822512A8;
		  /* 822512A8h */ case   28:  		/* lwz R11, <#[R31]> */
		/* 822512A8h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822512A8h case   28:*/		return 0x822512AC;
		  /* 822512ACh */ case   29:  		/* mr R3, R31 */
		/* 822512ACh case   29:*/		regs.R3 = regs.R31;
		/* 822512ACh case   29:*/		return 0x822512B0;
		  /* 822512B0h */ case   30:  		/* lwz R11, <#[R11 + 40]> */
		/* 822512B0h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 822512B0h case   30:*/		return 0x822512B4;
		  /* 822512B4h */ case   31:  		/* mtspr CTR, R11 */
		/* 822512B4h case   31:*/		regs.CTR = regs.R11;
		/* 822512B4h case   31:*/		return 0x822512B8;
		  /* 822512B8h */ case   32:  		/* bcctrl 20, CR0_LT */
		/* 822512B8h case   32:*/		if ( 1 ) { regs.LR = 0x822512BC; return (uint32)regs.CTR; }
		/* 822512B8h case   32:*/		return 0x822512BC;
		  /* 822512BCh */ case   33:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822512BCh case   33:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822512BCh case   33:*/		return 0x822512C0;
		  /* 822512C0h */ case   34:  		/* bc 12, CR0_EQ, 40 */
		/* 822512C0h case   34:*/		if ( regs.CR[0].eq ) { return 0x822512E8;  }
		/* 822512C0h case   34:*/		return 0x822512C4;
	}
	return 0x822512C4;
} // Block from 82251238h-822512C4h (35 instructions)

//////////////////////////////////////////////////////
// Block at 822512C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822512C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822512C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822512C4);
		  /* 822512C4h */ case    0:  		/* lwz R11, <#[R30 + 2148]> */
		/* 822512C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000864) );
		/* 822512C4h case    0:*/		return 0x822512C8;
		  /* 822512C8h */ case    1:  		/* lwz R10, <#[R31 + 956]> */
		/* 822512C8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000003BC) );
		/* 822512C8h case    1:*/		return 0x822512CC;
		  /* 822512CCh */ case    2:  		/* stw R11, <#[R31 + 892]> */
		/* 822512CCh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000037C) );
		/* 822512CCh case    2:*/		return 0x822512D0;
		  /* 822512D0h */ case    3:  		/* lwz R11, <#[R30 + 2152]> */
		/* 822512D0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000868) );
		/* 822512D0h case    3:*/		return 0x822512D4;
		  /* 822512D4h */ case    4:  		/* cmpw CR6, R10, R11 */
		/* 822512D4h case    4:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 822512D4h case    4:*/		return 0x822512D8;
		  /* 822512D8h */ case    5:  		/* addi R11, R11, 1 */
		/* 822512D8h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822512D8h case    5:*/		return 0x822512DC;
		  /* 822512DCh */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 822512DCh case    6:*/		if ( !regs.CR[6].gt ) { return 0x822512E4;  }
		/* 822512DCh case    6:*/		return 0x822512E0;
		  /* 822512E0h */ case    7:  		/* addi R11, R10, 1 */
		/* 822512E0h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x1);
		/* 822512E0h case    7:*/		return 0x822512E4;
	}
	return 0x822512E4;
} // Block from 822512C4h-822512E4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822512E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822512E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822512E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822512E4);
		  /* 822512E4h */ case    0:  		/* stw R11, <#[R31 + 956]> */
		/* 822512E4h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000003BC) );
		/* 822512E4h case    0:*/		return 0x822512E8;
	}
	return 0x822512E8;
} // Block from 822512E4h-822512E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822512E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822512E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822512E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822512E8);
		  /* 822512E8h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 822512E8h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 822512E8h case    0:*/		return 0x822512EC;
	}
	return 0x822512EC;
} // Block from 822512E8h-822512ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822512ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822512EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822512EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822512EC);
		  /* 822512ECh */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 822512ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 822512ECh case    0:*/		return 0x822512F0;
		  /* 822512F0h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 822512F0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 822512F0h case    1:*/		return 0x822512F4;
		  /* 822512F4h */ case    2:  		/* bc 4, CR6_EQ, -116 */
		/* 822512F4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82251280;  }
		/* 822512F4h case    2:*/		return 0x822512F8;
		  /* 822512F8h */ case    3:  		/* lwz R29, <#[R29 + 8]> */
		/* 822512F8h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000008) );
		/* 822512F8h case    3:*/		return 0x822512FC;
	}
	return 0x822512FC;
} // Block from 822512ECh-822512FCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 822512FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822512FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822512FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822512FC);
		  /* 822512FCh */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 822512FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 822512FCh case    0:*/		return 0x82251300;
		  /* 82251300h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82251300h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82251300h case    1:*/		return 0x82251304;
		  /* 82251304h */ case    2:  		/* bc 4, CR6_EQ, -140 */
		/* 82251304h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82251278;  }
		/* 82251304h case    2:*/		return 0x82251308;
		  /* 82251308h */ case    3:  		/* li R26, 0 */
		/* 82251308h case    3:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82251308h case    3:*/		return 0x8225130C;
		  /* 8225130Ch */ case    4:  		/* li R25, 0 */
		/* 8225130Ch case    4:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 8225130Ch case    4:*/		return 0x82251310;
		  /* 82251310h */ case    5:  		/* li R24, 1 */
		/* 82251310h case    5:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 82251310h case    5:*/		return 0x82251314;
		  /* 82251314h */ case    6:  		/* lwz R11, <#[R30 + 2068]> */
		/* 82251314h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000814) );
		/* 82251314h case    6:*/		return 0x82251318;
		  /* 82251318h */ case    7:  		/* lwz R10, <#[R11 + 4]> */
		/* 82251318h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82251318h case    7:*/		return 0x8225131C;
		  /* 8225131Ch */ case    8:  		/* cmplw CR6, R24, R10 */
		/* 8225131Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R10);
		/* 8225131Ch case    8:*/		return 0x82251320;
		  /* 82251320h */ case    9:  		/* bc 4, CR6_GT, 12 */
		/* 82251320h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8225132C;  }
		/* 82251320h case    9:*/		return 0x82251324;
		  /* 82251324h */ case   10:  		/* li R11, 0 */
		/* 82251324h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82251324h case   10:*/		return 0x82251328;
		  /* 82251328h */ case   11:  		/* b 16 */
		/* 82251328h case   11:*/		return 0x82251338;
		/* 82251328h case   11:*/		return 0x8225132C;
	}
	return 0x8225132C;
} // Block from 822512FCh-8225132Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8225132Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225132C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225132C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225132C);
		  /* 8225132Ch */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 8225132Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8225132Ch case    0:*/		return 0x82251330;
		  /* 82251330h */ case    1:  		/* li R11, 1 */
		/* 82251330h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82251330h case    1:*/		return 0x82251334;
		  /* 82251334h */ case    2:  		/* lwzx R26, <#[R10 + R25]> */
		/* 82251334h case    2:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R10 + regs.R25 + 0x00000000) );
		/* 82251334h case    2:*/		return 0x82251338;
	}
	return 0x82251338;
} // Block from 8225132Ch-82251338h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82251338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251338);
		  /* 82251338h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82251338h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82251338h case    0:*/		return 0x8225133C;
		  /* 8225133Ch */ case    1:  		/* bc 12, CR0_EQ, 256 */
		/* 8225133Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8225143C;  }
		/* 8225133Ch case    1:*/		return 0x82251340;
		  /* 82251340h */ case    2:  		/* lwz R11, <#[R26 + 228]> */
		/* 82251340h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x000000E4) );
		/* 82251340h case    2:*/		return 0x82251344;
		  /* 82251344h */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82251344h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82251344h case    3:*/		return 0x82251348;
		  /* 82251348h */ case    4:  		/* bc 12, CR0_EQ, 232 */
		/* 82251348h case    4:*/		if ( regs.CR[0].eq ) { return 0x82251430;  }
		/* 82251348h case    4:*/		return 0x8225134C;
		  /* 8225134Ch */ case    5:  		/* lwz R11, <#[R30 + 2148]> */
		/* 8225134Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000864) );
		/* 8225134Ch case    5:*/		return 0x82251350;
		  /* 82251350h */ case    6:  		/* lwz R10, <#[R26 + 956]> */
		/* 82251350h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x000003BC) );
		/* 82251350h case    6:*/		return 0x82251354;
		  /* 82251354h */ case    7:  		/* stw R11, <#[R26 + 892]> */
		/* 82251354h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x0000037C) );
		/* 82251354h case    7:*/		return 0x82251358;
		  /* 82251358h */ case    8:  		/* lwz R11, <#[R30 + 2152]> */
		/* 82251358h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000868) );
		/* 82251358h case    8:*/		return 0x8225135C;
		  /* 8225135Ch */ case    9:  		/* cmpw CR6, R10, R11 */
		/* 8225135Ch case    9:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 8225135Ch case    9:*/		return 0x82251360;
		  /* 82251360h */ case   10:  		/* addi R11, R11, 1 */
		/* 82251360h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82251360h case   10:*/		return 0x82251364;
		  /* 82251364h */ case   11:  		/* bc 4, CR6_GT, 8 */
		/* 82251364h case   11:*/		if ( !regs.CR[6].gt ) { return 0x8225136C;  }
		/* 82251364h case   11:*/		return 0x82251368;
		  /* 82251368h */ case   12:  		/* addi R11, R10, 1 */
		/* 82251368h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x1);
		/* 82251368h case   12:*/		return 0x8225136C;
	}
	return 0x8225136C;
} // Block from 82251338h-8225136Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8225136Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225136C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225136C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225136C);
		  /* 8225136Ch */ case    0:  		/* stw R11, <#[R26 + 956]> */
		/* 8225136Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x000003BC) );
		/* 8225136Ch case    0:*/		return 0x82251370;
		  /* 82251370h */ case    1:  		/* addi R3, R1, 80 */
		/* 82251370h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82251370h case    1:*/		return 0x82251374;
		  /* 82251374h */ case    2:  		/* lwz R4, <#[R1 + 84]> */
		/* 82251374h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 82251374h case    2:*/		return 0x82251378;
		  /* 82251378h */ case    3:  		/* bl 10056 */
		/* 82251378h case    3:*/		regs.LR = 0x8225137C; return 0x82253AC0;
		/* 82251378h case    3:*/		return 0x8225137C;
		  /* 8225137Ch */ case    4:  		/* stw R26, <#[R3]> */
		/* 8225137Ch case    4:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x00000000) );
		/* 8225137Ch case    4:*/		return 0x82251380;
		  /* 82251380h */ case    5:  		/* addi R3, R1, 80 */
		/* 82251380h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82251380h case    5:*/		return 0x82251384;
		  /* 82251384h */ case    6:  		/* bl 39372 */
		/* 82251384h case    6:*/		regs.LR = 0x82251388; return 0x8225AD50;
		/* 82251384h case    6:*/		return 0x82251388;
		  /* 82251388h */ case    7:  		/* lwz R11, <#[R3 + 20]> */
		/* 82251388h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82251388h case    7:*/		return 0x8225138C;
		  /* 8225138Ch */ case    8:  		/* mr R28, R3 */
		/* 8225138Ch case    8:*/		regs.R28 = regs.R3;
		/* 8225138Ch case    8:*/		return 0x82251390;
		  /* 82251390h */ case    9:  		/* li R27, 1 */
		/* 82251390h case    9:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 82251390h case    9:*/		return 0x82251394;
		  /* 82251394h */ case   10:  		/* cmpwi CR6, R11, 1 */
		/* 82251394h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 82251394h case   10:*/		return 0x82251398;
		  /* 82251398h */ case   11:  		/* bc 12, CR6_LT, 140 */
		/* 82251398h case   11:*/		if ( regs.CR[6].lt ) { return 0x82251424;  }
		/* 82251398h case   11:*/		return 0x8225139C;
		  /* 8225139Ch */ case   12:  		/* addi R29, R3, 236 */
		/* 8225139Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R3,0xEC);
		/* 8225139Ch case   12:*/		return 0x822513A0;
		  /* 822513A0h */ case   13:  		/* lwz R31, <#[R29]> */
		/* 822513A0h case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000000) );
		/* 822513A0h case   13:*/		return 0x822513A4;
		  /* 822513A4h */ case   14:  		/* cmplwi CR6, R31, 0 */
		/* 822513A4h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 822513A4h case   14:*/		return 0x822513A8;
		  /* 822513A8h */ case   15:  		/* bc 12, CR6_EQ, 104 */
		/* 822513A8h case   15:*/		if ( regs.CR[6].eq ) { return 0x82251410;  }
		/* 822513A8h case   15:*/		return 0x822513AC;
		  /* 822513ACh */ case   16:  		/* mr R3, R31 */
		/* 822513ACh case   16:*/		regs.R3 = regs.R31;
		/* 822513ACh case   16:*/		return 0x822513B0;
		  /* 822513B0h */ case   17:  		/* bl 21720 */
		/* 822513B0h case   17:*/		regs.LR = 0x822513B4; return 0x82256888;
		/* 822513B0h case   17:*/		return 0x822513B4;
		  /* 822513B4h */ case   18:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822513B4h case   18:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822513B4h case   18:*/		return 0x822513B8;
		  /* 822513B8h */ case   19:  		/* bc 12, CR0_EQ, 16 */
		/* 822513B8h case   19:*/		if ( regs.CR[0].eq ) { return 0x822513C8;  }
		/* 822513B8h case   19:*/		return 0x822513BC;
		  /* 822513BCh */ case   20:  		/* lwz R31, <#[R31 + 236]> */
		/* 822513BCh case   20:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x000000EC) );
		/* 822513BCh case   20:*/		return 0x822513C0;
		  /* 822513C0h */ case   21:  		/* cmplwi CR6, R31, 0 */
		/* 822513C0h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 822513C0h case   21:*/		return 0x822513C4;
		  /* 822513C4h */ case   22:  		/* bc 4, CR6_EQ, -24 */
		/* 822513C4h case   22:*/		if ( !regs.CR[6].eq ) { return 0x822513AC;  }
		/* 822513C4h case   22:*/		return 0x822513C8;
	}
	return 0x822513C8;
} // Block from 8225136Ch-822513C8h (23 instructions)

//////////////////////////////////////////////////////
// Block at 822513C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822513C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822513C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822513C8);
		  /* 822513C8h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 822513C8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 822513C8h case    0:*/		return 0x822513CC;
		  /* 822513CCh */ case    1:  		/* bc 12, CR6_EQ, 68 */
		/* 822513CCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82251410;  }
		/* 822513CCh case    1:*/		return 0x822513D0;
		  /* 822513D0h */ case    2:  		/* lwz R11, <#[R30 + 2152]> */
		/* 822513D0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000868) );
		/* 822513D0h case    2:*/		return 0x822513D4;
		  /* 822513D4h */ case    3:  		/* lwz R10, <#[R31 + 956]> */
		/* 822513D4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000003BC) );
		/* 822513D4h case    3:*/		return 0x822513D8;
		  /* 822513D8h */ case    4:  		/* cmpw CR6, R10, R11 */
		/* 822513D8h case    4:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 822513D8h case    4:*/		return 0x822513DC;
		  /* 822513DCh */ case    5:  		/* addi R11, R11, 1 */
		/* 822513DCh case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822513DCh case    5:*/		return 0x822513E0;
		  /* 822513E0h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 822513E0h case    6:*/		if ( !regs.CR[6].gt ) { return 0x822513E8;  }
		/* 822513E0h case    6:*/		return 0x822513E4;
		  /* 822513E4h */ case    7:  		/* addi R11, R10, 1 */
		/* 822513E4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x1);
		/* 822513E4h case    7:*/		return 0x822513E8;
	}
	return 0x822513E8;
} // Block from 822513C8h-822513E8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822513E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822513E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822513E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822513E8);
		  /* 822513E8h */ case    0:  		/* lwz R10, <#[R31 + 892]> */
		/* 822513E8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000037C) );
		/* 822513E8h case    0:*/		return 0x822513EC;
		  /* 822513ECh */ case    1:  		/* stw R11, <#[R31 + 956]> */
		/* 822513ECh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000003BC) );
		/* 822513ECh case    1:*/		return 0x822513F0;
		  /* 822513F0h */ case    2:  		/* lwz R11, <#[R30 + 2148]> */
		/* 822513F0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000864) );
		/* 822513F0h case    2:*/		return 0x822513F4;
		  /* 822513F4h */ case    3:  		/* cmpw CR6, R10, R11 */
		/* 822513F4h case    3:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 822513F4h case    3:*/		return 0x822513F8;
		  /* 822513F8h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 822513F8h case    4:*/		if ( regs.CR[6].eq ) { return 0x82251410;  }
		/* 822513F8h case    4:*/		return 0x822513FC;
		  /* 822513FCh */ case    5:  		/* stw R11, <#[R31 + 892]> */
		/* 822513FCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000037C) );
		/* 822513FCh case    5:*/		return 0x82251400;
		  /* 82251400h */ case    6:  		/* addi R3, R1, 80 */
		/* 82251400h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82251400h case    6:*/		return 0x82251404;
		  /* 82251404h */ case    7:  		/* lwz R4, <#[R1 + 84]> */
		/* 82251404h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 82251404h case    7:*/		return 0x82251408;
		  /* 82251408h */ case    8:  		/* bl 9912 */
		/* 82251408h case    8:*/		regs.LR = 0x8225140C; return 0x82253AC0;
		/* 82251408h case    8:*/		return 0x8225140C;
		  /* 8225140Ch */ case    9:  		/* stw R31, <#[R3]> */
		/* 8225140Ch case    9:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 8225140Ch case    9:*/		return 0x82251410;
	}
	return 0x82251410;
} // Block from 822513E8h-82251410h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82251410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251410);
		  /* 82251410h */ case    0:  		/* lwz R11, <#[R28 + 20]> */
		/* 82251410h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 82251410h case    0:*/		return 0x82251414;
		  /* 82251414h */ case    1:  		/* addi R27, R27, 1 */
		/* 82251414h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82251414h case    1:*/		return 0x82251418;
		  /* 82251418h */ case    2:  		/* addi R29, R29, 4 */
		/* 82251418h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82251418h case    2:*/		return 0x8225141C;
		  /* 8225141Ch */ case    3:  		/* cmpw CR6, R27, R11 */
		/* 8225141Ch case    3:*/		cpu::op::cmpw<6>(regs,regs.R27,regs.R11);
		/* 8225141Ch case    3:*/		return 0x82251420;
		  /* 82251420h */ case    4:  		/* bc 4, CR6_GT, -128 */
		/* 82251420h case    4:*/		if ( !regs.CR[6].gt ) { return 0x822513A0;  }
		/* 82251420h case    4:*/		return 0x82251424;
	}
	return 0x82251424;
} // Block from 82251410h-82251424h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82251424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251424);
		  /* 82251424h */ case    0:  		/* lwz R11, <#[R1 + 84]> */
		/* 82251424h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82251424h case    0:*/		return 0x82251428;
		  /* 82251428h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82251428h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82251428h case    1:*/		return 0x8225142C;
		  /* 8225142Ch */ case    2:  		/* bc 4, CR6_EQ, -172 */
		/* 8225142Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82251380;  }
		/* 8225142Ch case    2:*/		return 0x82251430;
	}
	return 0x82251430;
} // Block from 82251424h-82251430h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82251430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251430);
		  /* 82251430h */ case    0:  		/* addi R24, R24, 1 */
		/* 82251430h case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 82251430h case    0:*/		return 0x82251434;
		  /* 82251434h */ case    1:  		/* addi R25, R25, 4 */
		/* 82251434h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 82251434h case    1:*/		return 0x82251438;
		  /* 82251438h */ case    2:  		/* b -292 */
		/* 82251438h case    2:*/		return 0x82251314;
		/* 82251438h case    2:*/		return 0x8225143C;
	}
	return 0x8225143C;
} // Block from 82251430h-8225143Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225143Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225143C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225143C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225143C);
		  /* 8225143Ch */ case    0:  		/* lwz R29, <#[R30 + 136]> */
		/* 8225143Ch case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000088) );
		/* 8225143Ch case    0:*/		return 0x82251440;
		  /* 82251440h */ case    1:  		/* li R28, 0 */
		/* 82251440h case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82251440h case    1:*/		return 0x82251444;
		  /* 82251444h */ case    2:  		/* li R27, 0 */
		/* 82251444h case    2:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82251444h case    2:*/		return 0x82251448;
		  /* 82251448h */ case    3:  		/* b 164 */
		/* 82251448h case    3:*/		return 0x822514EC;
		/* 82251448h case    3:*/		return 0x8225144C;
		  /* 8225144Ch */ case    4:  		/* lwz R31, <#[R29 + 28]> */
		/* 8225144Ch case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x0000001C) );
		/* 8225144Ch case    4:*/		return 0x82251450;
		  /* 82251450h */ case    5:  		/* b 140 */
		/* 82251450h case    5:*/		return 0x822514DC;
		/* 82251450h case    5:*/		return 0x82251454;
		  /* 82251454h */ case    6:  		/* lwz R11, <#[R31 + 228]> */
		/* 82251454h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82251454h case    6:*/		return 0x82251458;
		  /* 82251458h */ case    7:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82251458h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82251458h case    7:*/		return 0x8225145C;
		  /* 8225145Ch */ case    8:  		/* bc 12, CR0_EQ, 124 */
		/* 8225145Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x822514D8;  }
		/* 8225145Ch case    8:*/		return 0x82251460;
		  /* 82251460h */ case    9:  		/* lwz R11, <#[R31 + 892]> */
		/* 82251460h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000037C) );
		/* 82251460h case    9:*/		return 0x82251464;
		  /* 82251464h */ case   10:  		/* lwz R10, <#[R30 + 2148]> */
		/* 82251464h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000864) );
		/* 82251464h case   10:*/		return 0x82251468;
		  /* 82251468h */ case   11:  		/* cmpw CR6, R11, R10 */
		/* 82251468h case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82251468h case   11:*/		return 0x8225146C;
		  /* 8225146Ch */ case   12:  		/* bc 12, CR6_EQ, 108 */
		/* 8225146Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x822514D8;  }
		/* 8225146Ch case   12:*/		return 0x82251470;
		  /* 82251470h */ case   13:  		/* lwz R11, <#[R31]> */
		/* 82251470h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82251470h case   13:*/		return 0x82251474;
		  /* 82251474h */ case   14:  		/* mr R3, R31 */
		/* 82251474h case   14:*/		regs.R3 = regs.R31;
		/* 82251474h case   14:*/		return 0x82251478;
		  /* 82251478h */ case   15:  		/* lwz R11, <#[R11 + 48]> */
		/* 82251478h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82251478h case   15:*/		return 0x8225147C;
		  /* 8225147Ch */ case   16:  		/* mtspr CTR, R11 */
		/* 8225147Ch case   16:*/		regs.CTR = regs.R11;
		/* 8225147Ch case   16:*/		return 0x82251480;
		  /* 82251480h */ case   17:  		/* bcctrl 20, CR0_LT */
		/* 82251480h case   17:*/		if ( 1 ) { regs.LR = 0x82251484; return (uint32)regs.CTR; }
		/* 82251480h case   17:*/		return 0x82251484;
		  /* 82251484h */ case   18:  		/* cmplwi CR0, R3, 0 */
		/* 82251484h case   18:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82251484h case   18:*/		return 0x82251488;
		  /* 82251488h */ case   19:  		/* bc 12, CR0_EQ, 36 */
		/* 82251488h case   19:*/		if ( regs.CR[0].eq ) { return 0x822514AC;  }
		/* 82251488h case   19:*/		return 0x8225148C;
		  /* 8225148Ch */ case   20:  		/* lbz R11, <#[R30 + 2116]> */
		/* 8225148Ch case   20:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000844) );
		/* 8225148Ch case   20:*/		return 0x82251490;
		  /* 82251490h */ case   21:  		/* cmplwi CR0, R11, 0 */
		/* 82251490h case   21:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82251490h case   21:*/		return 0x82251494;
		  /* 82251494h */ case   22:  		/* bc 4, CR0_EQ, 24 */
		/* 82251494h case   22:*/		if ( !regs.CR[0].eq ) { return 0x822514AC;  }
		/* 82251494h case   22:*/		return 0x82251498;
		  /* 82251498h */ case   23:  		/* mr R4, R30 */
		/* 82251498h case   23:*/		regs.R4 = regs.R30;
		/* 82251498h case   23:*/		return 0x8225149C;
		  /* 8225149Ch */ case   24:  		/* lwz R6, <#[R31 + 56]> */
		/* 8225149Ch case   24:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000038) );
		/* 8225149Ch case   24:*/		return 0x822514A0;
		  /* 822514A0h */ case   25:  		/* addi R3, R30, 184 */
		/* 822514A0h case   25:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0xB8);
		/* 822514A0h case   25:*/		return 0x822514A4;
		  /* 822514A4h */ case   26:  		/* lwz R5, <#[R31 + 80]> */
		/* 822514A4h case   26:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000050) );
		/* 822514A4h case   26:*/		return 0x822514A8;
		  /* 822514A8h */ case   27:  		/* bl 3744 */
		/* 822514A8h case   27:*/		regs.LR = 0x822514AC; return 0x82252348;
		/* 822514A8h case   27:*/		return 0x822514AC;
	}
	return 0x822514AC;
} // Block from 8225143Ch-822514ACh (28 instructions)

//////////////////////////////////////////////////////
// Block at 822514ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822514AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822514AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822514AC);
		  /* 822514ACh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 822514ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822514ACh case    0:*/		return 0x822514B0;
		  /* 822514B0h */ case    1:  		/* mr R3, R31 */
		/* 822514B0h case    1:*/		regs.R3 = regs.R31;
		/* 822514B0h case    1:*/		return 0x822514B4;
		  /* 822514B4h */ case    2:  		/* lwz R11, <#[R11 + 96]> */
		/* 822514B4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000060) );
		/* 822514B4h case    2:*/		return 0x822514B8;
		  /* 822514B8h */ case    3:  		/* mtspr CTR, R11 */
		/* 822514B8h case    3:*/		regs.CTR = regs.R11;
		/* 822514B8h case    3:*/		return 0x822514BC;
		  /* 822514BCh */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 822514BCh case    4:*/		if ( 1 ) { regs.LR = 0x822514C0; return (uint32)regs.CTR; }
		/* 822514BCh case    4:*/		return 0x822514C0;
		  /* 822514C0h */ case    5:  		/* lwz R11, <#[R31 + 24]> */
		/* 822514C0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 822514C0h case    5:*/		return 0x822514C4;
		  /* 822514C4h */ case    6:  		/* cmpwi CR6, R11, 137 */
		/* 822514C4h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000089);
		/* 822514C4h case    6:*/		return 0x822514C8;
		  /* 822514C8h */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 822514C8h case    7:*/		if ( !regs.CR[6].eq ) { return 0x822514D4;  }
		/* 822514C8h case    7:*/		return 0x822514CC;
		  /* 822514CCh */ case    8:  		/* addi R27, R27, 1 */
		/* 822514CCh case    8:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 822514CCh case    8:*/		return 0x822514D0;
		  /* 822514D0h */ case    9:  		/* b 8 */
		/* 822514D0h case    9:*/		return 0x822514D8;
		/* 822514D0h case    9:*/		return 0x822514D4;
	}
	return 0x822514D4;
} // Block from 822514ACh-822514D4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822514D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822514D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822514D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822514D4);
		  /* 822514D4h */ case    0:  		/* addi R28, R28, 1 */
		/* 822514D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 822514D4h case    0:*/		return 0x822514D8;
	}
	return 0x822514D8;
} // Block from 822514D4h-822514D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822514D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822514D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822514D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822514D8);
		  /* 822514D8h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 822514D8h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 822514D8h case    0:*/		return 0x822514DC;
	}
	return 0x822514DC;
} // Block from 822514D8h-822514DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822514DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822514DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822514DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822514DC);
		  /* 822514DCh */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 822514DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 822514DCh case    0:*/		return 0x822514E0;
		  /* 822514E0h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 822514E0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 822514E0h case    1:*/		return 0x822514E4;
		  /* 822514E4h */ case    2:  		/* bc 4, CR6_EQ, -144 */
		/* 822514E4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82251454;  }
		/* 822514E4h case    2:*/		return 0x822514E8;
		  /* 822514E8h */ case    3:  		/* lwz R29, <#[R29 + 8]> */
		/* 822514E8h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000008) );
		/* 822514E8h case    3:*/		return 0x822514EC;
	}
	return 0x822514EC;
} // Block from 822514DCh-822514ECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 822514ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822514EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822514EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822514EC);
		  /* 822514ECh */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 822514ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 822514ECh case    0:*/		return 0x822514F0;
		  /* 822514F0h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 822514F0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 822514F0h case    1:*/		return 0x822514F4;
		  /* 822514F4h */ case    2:  		/* bc 4, CR6_EQ, -168 */
		/* 822514F4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8225144C;  }
		/* 822514F4h case    2:*/		return 0x822514F8;
		  /* 822514F8h */ case    3:  		/* mr R3, R30 */
		/* 822514F8h case    3:*/		regs.R3 = regs.R30;
		/* 822514F8h case    3:*/		return 0x822514FC;
		  /* 822514FCh */ case    4:  		/* bl -109388 */
		/* 822514FCh case    4:*/		regs.LR = 0x82251500; return 0x822369B0;
		/* 822514FCh case    4:*/		return 0x82251500;
		  /* 82251500h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82251500h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82251500h case    5:*/		return 0x82251504;
		  /* 82251504h */ case    6:  		/* bc 4, CR0_EQ, 40 */
		/* 82251504h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8225152C;  }
		/* 82251504h case    6:*/		return 0x82251508;
		  /* 82251508h */ case    7:  		/* lis R11, -32252 */
		/* 82251508h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82251508h case    7:*/		return 0x8225150C;
		  /* 8225150Ch */ case    8:  		/* lis R10, -32252 */
		/* 8225150Ch case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8225150Ch case    8:*/		return 0x82251510;
		  /* 82251510h */ case    9:  		/* lis R9, -32253 */
		/* 82251510h case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82251510h case    9:*/		return 0x82251514;
		  /* 82251514h */ case   10:  		/* addi R6, R11, 16232 */
		/* 82251514h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x3F68);
		/* 82251514h case   10:*/		return 0x82251518;
		  /* 82251518h */ case   11:  		/* addi R5, R10, 13900 */
		/* 82251518h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x364C);
		/* 82251518h case   11:*/		return 0x8225151C;
		  /* 8225151Ch */ case   12:  		/* addi R4, R9, 27460 */
		/* 8225151Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8225151Ch case   12:*/		return 0x82251520;
		  /* 82251520h */ case   13:  		/* li R7, 154 */
		/* 82251520h case   13:*/		cpu::op::li<0>(regs,&regs.R7,0x9A);
		/* 82251520h case   13:*/		return 0x82251524;
		  /* 82251524h */ case   14:  		/* li R3, 0 */
		/* 82251524h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82251524h case   14:*/		return 0x82251528;
		  /* 82251528h */ case   15:  		/* bl -1022240 */
		/* 82251528h case   15:*/		regs.LR = 0x8225152C; return 0x82157C08;
		/* 82251528h case   15:*/		return 0x8225152C;
	}
	return 0x8225152C;
} // Block from 822514ECh-8225152Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8225152Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225152C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225152C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225152C);
		  /* 8225152Ch */ case    0:  		/* cmpwi CR6, R28, 0 */
		/* 8225152Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 8225152Ch case    0:*/		return 0x82251530;
		  /* 82251530h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 82251530h case    1:*/		if ( regs.CR[6].eq ) { return 0x82251548;  }
		/* 82251530h case    1:*/		return 0x82251534;
		  /* 82251534h */ case    2:  		/* lis R11, -32252 */
		/* 82251534h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82251534h case    2:*/		return 0x82251538;
		  /* 82251538h */ case    3:  		/* lwz R3, <#[R30 + 12]> */
		/* 82251538h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000000C) );
		/* 82251538h case    3:*/		return 0x8225153C;
		  /* 8225153Ch */ case    4:  		/* mr R5, R28 */
		/* 8225153Ch case    4:*/		regs.R5 = regs.R28;
		/* 8225153Ch case    4:*/		return 0x82251540;
		  /* 82251540h */ case    5:  		/* addi R4, R11, 16568 */
		/* 82251540h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x40B8);
		/* 82251540h case    5:*/		return 0x82251544;
		  /* 82251544h */ case    6:  		/* bl -213380 */
		/* 82251544h case    6:*/		regs.LR = 0x82251548; return 0x8221D3C0;
		/* 82251544h case    6:*/		return 0x82251548;
	}
	return 0x82251548;
} // Block from 8225152Ch-82251548h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82251548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251548);
		  /* 82251548h */ case    0:  		/* cmpwi CR6, R27, 0 */
		/* 82251548h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 82251548h case    0:*/		return 0x8225154C;
		  /* 8225154Ch */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 8225154Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82251564;  }
		/* 8225154Ch case    1:*/		return 0x82251550;
		  /* 82251550h */ case    2:  		/* lis R11, -32252 */
		/* 82251550h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82251550h case    2:*/		return 0x82251554;
		  /* 82251554h */ case    3:  		/* lwz R3, <#[R30 + 12]> */
		/* 82251554h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000000C) );
		/* 82251554h case    3:*/		return 0x82251558;
		  /* 82251558h */ case    4:  		/* mr R5, R27 */
		/* 82251558h case    4:*/		regs.R5 = regs.R27;
		/* 82251558h case    4:*/		return 0x8225155C;
		  /* 8225155Ch */ case    5:  		/* addi R4, R11, 16504 */
		/* 8225155Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x4078);
		/* 8225155Ch case    5:*/		return 0x82251560;
		  /* 82251560h */ case    6:  		/* bl -213408 */
		/* 82251560h case    6:*/		regs.LR = 0x82251564; return 0x8221D3C0;
		/* 82251560h case    6:*/		return 0x82251564;
	}
	return 0x82251564;
} // Block from 82251548h-82251564h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82251564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251564);
		  /* 82251564h */ case    0:  		/* lwz R4, <#[R1 + 88]> */
		/* 82251564h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000058) );
		/* 82251564h case    0:*/		return 0x82251568;
		  /* 82251568h */ case    1:  		/* lwz R3, <#[R1 + 92]> */
		/* 82251568h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 82251568h case    1:*/		return 0x8225156C;
		  /* 8225156Ch */ case    2:  		/* bl -216876 */
		/* 8225156Ch case    2:*/		regs.LR = 0x82251570; return 0x8221C640;
		/* 8225156Ch case    2:*/		return 0x82251570;
		  /* 82251570h */ case    3:  		/* addi R1, R1, 176 */
		/* 82251570h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82251570h case    3:*/		return 0x82251574;
		  /* 82251574h */ case    4:  		/* b -1835740 */
		/* 82251574h case    4:*/		return 0x82091298;
		/* 82251574h case    4:*/		return 0x82251578;
	}
	return 0x82251578;
} // Block from 82251564h-82251578h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82251578h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251578);
		  /* 82251578h */ case    0:  		/* mfspr R12, LR */
		/* 82251578h case    0:*/		regs.R12 = regs.LR;
		/* 82251578h case    0:*/		return 0x8225157C;
		  /* 8225157Ch */ case    1:  		/* bl -1835820 */
		/* 8225157Ch case    1:*/		regs.LR = 0x82251580; return 0x82091250;
		/* 8225157Ch case    1:*/		return 0x82251580;
		  /* 82251580h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 82251580h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82251580h case    2:*/		return 0x82251584;
		  /* 82251584h */ case    3:  		/* lis R11, -32252 */
		/* 82251584h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82251584h case    3:*/		return 0x82251588;
		  /* 82251588h */ case    4:  		/* mr R29, R3 */
		/* 82251588h case    4:*/		regs.R29 = regs.R3;
		/* 82251588h case    4:*/		return 0x8225158C;
		  /* 8225158Ch */ case    5:  		/* lwz R3, <#[R3 + 12]> */
		/* 8225158Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000000C) );
		/* 8225158Ch case    5:*/		return 0x82251590;
		  /* 82251590h */ case    6:  		/* addi R4, R11, 16636 */
		/* 82251590h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x40FC);
		/* 82251590h case    6:*/		return 0x82251594;
		  /* 82251594h */ case    7:  		/* bl -213460 */
		/* 82251594h case    7:*/		regs.LR = 0x82251598; return 0x8221D3C0;
		/* 82251594h case    7:*/		return 0x82251598;
		  /* 82251598h */ case    8:  		/* lwz R11, <#[R29 + 2148]> */
		/* 82251598h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000864) );
		/* 82251598h case    8:*/		return 0x8225159C;
		  /* 8225159Ch */ case    9:  		/* addi R3, R1, 96 */
		/* 8225159Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8225159Ch case    9:*/		return 0x822515A0;
		  /* 822515A0h */ case   10:  		/* addi R11, R11, 1 */
		/* 822515A0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822515A0h case   10:*/		return 0x822515A4;
		  /* 822515A4h */ case   11:  		/* stw R11, <#[R29 + 2148]> */
		/* 822515A4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000864) );
		/* 822515A4h case   11:*/		return 0x822515A8;
		  /* 822515A8h */ case   12:  		/* lwz R11, <#[R29 + 12]> */
		/* 822515A8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 822515A8h case   12:*/		return 0x822515AC;
		  /* 822515ACh */ case   13:  		/* lwz R4, <#[R11 + 1456]> */
		/* 822515ACh case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 822515ACh case   13:*/		return 0x822515B0;
		  /* 822515B0h */ case   14:  		/* bl -112720 */
		/* 822515B0h case   14:*/		regs.LR = 0x822515B4; return 0x82235D60;
		/* 822515B0h case   14:*/		return 0x822515B4;
		  /* 822515B4h */ case   15:  		/* lwz R11, <#[R29 + 12]> */
		/* 822515B4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 822515B4h case   15:*/		return 0x822515B8;
		  /* 822515B8h */ case   16:  		/* addi R3, R1, 80 */
		/* 822515B8h case   16:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 822515B8h case   16:*/		return 0x822515BC;
		  /* 822515BCh */ case   17:  		/* lwz R4, <#[R11 + 1456]> */
		/* 822515BCh case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 822515BCh case   17:*/		return 0x822515C0;
		  /* 822515C0h */ case   18:  		/* bl -112736 */
		/* 822515C0h case   18:*/		regs.LR = 0x822515C4; return 0x82235D60;
		/* 822515C0h case   18:*/		return 0x822515C4;
		  /* 822515C4h */ case   19:  		/* li R26, 0 */
		/* 822515C4h case   19:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 822515C4h case   19:*/		return 0x822515C8;
		  /* 822515C8h */ case   20:  		/* li R27, 1 */
		/* 822515C8h case   20:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 822515C8h case   20:*/		return 0x822515CC;
		  /* 822515CCh */ case   21:  		/* mr R31, R26 */
		/* 822515CCh case   21:*/		regs.R31 = regs.R26;
		/* 822515CCh case   21:*/		return 0x822515D0;
		  /* 822515D0h */ case   22:  		/* mr R28, R26 */
		/* 822515D0h case   22:*/		regs.R28 = regs.R26;
		/* 822515D0h case   22:*/		return 0x822515D4;
		  /* 822515D4h */ case   23:  		/* lwz R11, <#[R29 + 2068]> */
		/* 822515D4h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000814) );
		/* 822515D4h case   23:*/		return 0x822515D8;
		  /* 822515D8h */ case   24:  		/* lwz R10, <#[R11 + 4]> */
		/* 822515D8h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 822515D8h case   24:*/		return 0x822515DC;
		  /* 822515DCh */ case   25:  		/* cmplw CR6, R27, R10 */
		/* 822515DCh case   25:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R10);
		/* 822515DCh case   25:*/		return 0x822515E0;
		  /* 822515E0h */ case   26:  		/* bc 4, CR6_GT, 12 */
		/* 822515E0h case   26:*/		if ( !regs.CR[6].gt ) { return 0x822515EC;  }
		/* 822515E0h case   26:*/		return 0x822515E4;
		  /* 822515E4h */ case   27:  		/* mr R11, R26 */
		/* 822515E4h case   27:*/		regs.R11 = regs.R26;
		/* 822515E4h case   27:*/		return 0x822515E8;
		  /* 822515E8h */ case   28:  		/* b 16 */
		/* 822515E8h case   28:*/		return 0x822515F8;
		/* 822515E8h case   28:*/		return 0x822515EC;
	}
	return 0x822515EC;
} // Block from 82251578h-822515ECh (29 instructions)

//////////////////////////////////////////////////////
// Block at 822515ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822515EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822515EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822515EC);
		  /* 822515ECh */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 822515ECh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 822515ECh case    0:*/		return 0x822515F0;
		  /* 822515F0h */ case    1:  		/* li R11, 1 */
		/* 822515F0h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822515F0h case    1:*/		return 0x822515F4;
		  /* 822515F4h */ case    2:  		/* lwzx R31, <#[R10 + R28]> */
		/* 822515F4h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 822515F4h case    2:*/		return 0x822515F8;
	}
	return 0x822515F8;
} // Block from 822515ECh-822515F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822515F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822515F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822515F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822515F8);
		  /* 822515F8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 822515F8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 822515F8h case    0:*/		return 0x822515FC;
		  /* 822515FCh */ case    1:  		/* bc 12, CR0_EQ, 344 */
		/* 822515FCh case    1:*/		if ( regs.CR[0].eq ) { return 0x82251754;  }
		/* 822515FCh case    1:*/		return 0x82251600;
		  /* 82251600h */ case    2:  		/* lwz R11, <#[R31 + 228]> */
		/* 82251600h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82251600h case    2:*/		return 0x82251604;
		  /* 82251604h */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82251604h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82251604h case    3:*/		return 0x82251608;
		  /* 82251608h */ case    4:  		/* bc 12, CR0_EQ, 320 */
		/* 82251608h case    4:*/		if ( regs.CR[0].eq ) { return 0x82251748;  }
		/* 82251608h case    4:*/		return 0x8225160C;
		  /* 8225160Ch */ case    5:  		/* stw R26, <#[R1 + 100]> */
		/* 8225160Ch case    5:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000064) );
		/* 8225160Ch case    5:*/		return 0x82251610;
		  /* 82251610h */ case    6:  		/* stw R26, <#[R1 + 84]> */
		/* 82251610h case    6:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000054) );
		/* 82251610h case    6:*/		return 0x82251614;
		  /* 82251614h */ case    7:  		/* li R30, 1 */
		/* 82251614h case    7:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82251614h case    7:*/		return 0x82251618;
		  /* 82251618h */ case    8:  		/* rlwinm. R11, R30, 0, 24, 31 */
		/* 82251618h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R30);
		/* 82251618h case    8:*/		return 0x8225161C;
		  /* 8225161Ch */ case    9:  		/* bc 12, CR0_EQ, 112 */
		/* 8225161Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x8225168C;  }
		/* 8225161Ch case    9:*/		return 0x82251620;
		  /* 82251620h */ case   10:  		/* cmplwi CR6, R31, 0 */
		/* 82251620h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82251620h case   10:*/		return 0x82251624;
		  /* 82251624h */ case   11:  		/* bc 12, CR6_EQ, 48 */
		/* 82251624h case   11:*/		if ( regs.CR[6].eq ) { return 0x82251654;  }
		/* 82251624h case   11:*/		return 0x82251628;
		  /* 82251628h */ case   12:  		/* lwz R11, <#[R29 + 2148]> */
		/* 82251628h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000864) );
		/* 82251628h case   12:*/		return 0x8225162C;
		  /* 8225162Ch */ case   13:  		/* lwz R10, <#[R31 + 892]> */
		/* 8225162Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000037C) );
		/* 8225162Ch case   13:*/		return 0x82251630;
		  /* 82251630h */ case   14:  		/* cmpw CR6, R10, R11 */
		/* 82251630h case   14:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 82251630h case   14:*/		return 0x82251634;
		  /* 82251634h */ case   15:  		/* bc 12, CR6_EQ, 32 */
		/* 82251634h case   15:*/		if ( regs.CR[6].eq ) { return 0x82251654;  }
		/* 82251634h case   15:*/		return 0x82251638;
		  /* 82251638h */ case   16:  		/* stw R11, <#[R31 + 892]> */
		/* 82251638h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000037C) );
		/* 82251638h case   16:*/		return 0x8225163C;
		  /* 8225163Ch */ case   17:  		/* lwz R11, <#[R31 + 236]> */
		/* 8225163Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000EC) );
		/* 8225163Ch case   17:*/		return 0x82251640;
		  /* 82251640h */ case   18:  		/* cmpwi CR6, R11, 0 */
		/* 82251640h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82251640h case   18:*/		return 0x82251644;
		  /* 82251644h */ case   19:  		/* bc 4, CR6_EQ, 24 */
		/* 82251644h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8225165C;  }
		/* 82251644h case   19:*/		return 0x82251648;
		  /* 82251648h */ case   20:  		/* mr R4, R29 */
		/* 82251648h case   20:*/		regs.R4 = regs.R29;
		/* 82251648h case   20:*/		return 0x8225164C;
		  /* 8225164Ch */ case   21:  		/* mr R3, R31 */
		/* 8225164Ch case   21:*/		regs.R3 = regs.R31;
		/* 8225164Ch case   21:*/		return 0x82251650;
		  /* 82251650h */ case   22:  		/* bl -1152 */
		/* 82251650h case   22:*/		regs.LR = 0x82251654; return 0x822511D0;
		/* 82251650h case   22:*/		return 0x82251654;
	}
	return 0x82251654;
} // Block from 822515F8h-82251654h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82251654h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251654( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251654) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251654);
		  /* 82251654h */ case    0:  		/* mr R30, R26 */
		/* 82251654h case    0:*/		regs.R30 = regs.R26;
		/* 82251654h case    0:*/		return 0x82251658;
		  /* 82251658h */ case    1:  		/* b -64 */
		/* 82251658h case    1:*/		return 0x82251618;
		/* 82251658h case    1:*/		return 0x8225165C;
	}
	return 0x8225165C;
} // Block from 82251654h-8225165Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225165Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225165C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225165C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225165C);
		  /* 8225165Ch */ case    0:  		/* addi R3, R1, 96 */
		/* 8225165Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8225165Ch case    0:*/		return 0x82251660;
		  /* 82251660h */ case    1:  		/* lwz R4, <#[R1 + 100]> */
		/* 82251660h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000064) );
		/* 82251660h case    1:*/		return 0x82251664;
		  /* 82251664h */ case    2:  		/* bl 9308 */
		/* 82251664h case    2:*/		regs.LR = 0x82251668; return 0x82253AC0;
		/* 82251664h case    2:*/		return 0x82251668;
		  /* 82251668h */ case    3:  		/* mr R11, R3 */
		/* 82251668h case    3:*/		regs.R11 = regs.R3;
		/* 82251668h case    3:*/		return 0x8225166C;
		  /* 8225166Ch */ case    4:  		/* addi R3, R1, 80 */
		/* 8225166Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8225166Ch case    4:*/		return 0x82251670;
		  /* 82251670h */ case    5:  		/* stw R31, <#[R11]> */
		/* 82251670h case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 82251670h case    5:*/		return 0x82251674;
		  /* 82251674h */ case    6:  		/* lwz R4, <#[R1 + 84]> */
		/* 82251674h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 82251674h case    6:*/		return 0x82251678;
		  /* 82251678h */ case    7:  		/* bl 9288 */
		/* 82251678h case    7:*/		regs.LR = 0x8225167C; return 0x82253AC0;
		/* 82251678h case    7:*/		return 0x8225167C;
		  /* 8225167Ch */ case    8:  		/* li R11, 1 */
		/* 8225167Ch case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8225167Ch case    8:*/		return 0x82251680;
		  /* 82251680h */ case    9:  		/* stw R11, <#[R3]> */
		/* 82251680h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82251680h case    9:*/		return 0x82251684;
		  /* 82251684h */ case   10:  		/* lwz R31, <#[R31 + 236]> */
		/* 82251684h case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x000000EC) );
		/* 82251684h case   10:*/		return 0x82251688;
		  /* 82251688h */ case   11:  		/* b -112 */
		/* 82251688h case   11:*/		return 0x82251618;
		/* 82251688h case   11:*/		return 0x8225168C;
	}
	return 0x8225168C;
} // Block from 8225165Ch-8225168Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8225168Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225168C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225168C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225168C);
		  /* 8225168Ch */ case    0:  		/* lwz R10, <#[R1 + 100]> */
		/* 8225168Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000064) );
		/* 8225168Ch case    0:*/		return 0x82251690;
		  /* 82251690h */ case    1:  		/* mr R9, R31 */
		/* 82251690h case    1:*/		regs.R9 = regs.R31;
		/* 82251690h case    1:*/		return 0x82251694;
		  /* 82251694h */ case    2:  		/* cmpwi CR6, R10, 0 */
		/* 82251694h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82251694h case    2:*/		return 0x82251698;
		  /* 82251698h */ case    3:  		/* bc 12, CR6_EQ, 176 */
		/* 82251698h case    3:*/		if ( regs.CR[6].eq ) { return 0x82251748;  }
		/* 82251698h case    3:*/		return 0x8225169C;
		  /* 8225169Ch */ case    4:  		/* addi R11, R10, -1 */
		/* 8225169Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 8225169Ch case    4:*/		return 0x822516A0;
		  /* 822516A0h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 822516A0h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 822516A0h case    5:*/		return 0x822516A4;
		  /* 822516A4h */ case    6:  		/* bc 4, CR6_LT, 20 */
		/* 822516A4h case    6:*/		if ( !regs.CR[6].lt ) { return 0x822516B8;  }
		/* 822516A4h case    6:*/		return 0x822516A8;
		  /* 822516A8h */ case    7:  		/* lwz R10, <#[R1 + 104]> */
		/* 822516A8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000068) );
		/* 822516A8h case    7:*/		return 0x822516AC;
		  /* 822516ACh */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822516ACh case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822516ACh case    8:*/		return 0x822516B0;
		  /* 822516B0h */ case    9:  		/* add R11, R11, R10 */
		/* 822516B0h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 822516B0h case    9:*/		return 0x822516B4;
		  /* 822516B4h */ case   10:  		/* b 8 */
		/* 822516B4h case   10:*/		return 0x822516BC;
		/* 822516B4h case   10:*/		return 0x822516B8;
	}
	return 0x822516B8;
} // Block from 8225168Ch-822516B8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 822516B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822516B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822516B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822516B8);
		  /* 822516B8h */ case    0:  		/* mr R11, R26 */
		/* 822516B8h case    0:*/		regs.R11 = regs.R26;
		/* 822516B8h case    0:*/		return 0x822516BC;
	}
	return 0x822516BC;
} // Block from 822516B8h-822516BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822516BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822516BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822516BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822516BC);
		  /* 822516BCh */ case    0:  		/* lwz R31, <#[R11]> */
		/* 822516BCh case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 822516BCh case    0:*/		return 0x822516C0;
		  /* 822516C0h */ case    1:  		/* cmplwi CR6, R9, 0 */
		/* 822516C0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 822516C0h case    1:*/		return 0x822516C4;
		  /* 822516C4h */ case    2:  		/* bc 12, CR6_EQ, 100 */
		/* 822516C4h case    2:*/		if ( regs.CR[6].eq ) { return 0x82251728;  }
		/* 822516C4h case    2:*/		return 0x822516C8;
		  /* 822516C8h */ case    3:  		/* lwz R10, <#[R1 + 84]> */
		/* 822516C8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 822516C8h case    3:*/		return 0x822516CC;
		  /* 822516CCh */ case    4:  		/* addi R11, R10, -1 */
		/* 822516CCh case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 822516CCh case    4:*/		return 0x822516D0;
		  /* 822516D0h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 822516D0h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 822516D0h case    5:*/		return 0x822516D4;
		  /* 822516D4h */ case    6:  		/* bc 4, CR6_LT, 20 */
		/* 822516D4h case    6:*/		if ( !regs.CR[6].lt ) { return 0x822516E8;  }
		/* 822516D4h case    6:*/		return 0x822516D8;
		  /* 822516D8h */ case    7:  		/* lwz R10, <#[R1 + 88]> */
		/* 822516D8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 822516D8h case    7:*/		return 0x822516DC;
		  /* 822516DCh */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822516DCh case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822516DCh case    8:*/		return 0x822516E0;
		  /* 822516E0h */ case    9:  		/* add R11, R11, R10 */
		/* 822516E0h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 822516E0h case    9:*/		return 0x822516E4;
		  /* 822516E4h */ case   10:  		/* b 8 */
		/* 822516E4h case   10:*/		return 0x822516EC;
		/* 822516E4h case   10:*/		return 0x822516E8;
	}
	return 0x822516E8;
} // Block from 822516BCh-822516E8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 822516E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822516E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822516E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822516E8);
		  /* 822516E8h */ case    0:  		/* mr R11, R26 */
		/* 822516E8h case    0:*/		regs.R11 = regs.R26;
		/* 822516E8h case    0:*/		return 0x822516EC;
	}
	return 0x822516EC;
} // Block from 822516E8h-822516ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822516ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822516EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822516EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822516EC);
		  /* 822516ECh */ case    0:  		/* lwz R11, <#[R11]> */
		/* 822516ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822516ECh case    0:*/		return 0x822516F0;
		  /* 822516F0h */ case    1:  		/* lwz R10, <#[R31 + 20]> */
		/* 822516F0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 822516F0h case    1:*/		return 0x822516F4;
		  /* 822516F4h */ case    2:  		/* cmpw CR6, R11, R10 */
		/* 822516F4h case    2:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 822516F4h case    2:*/		return 0x822516F8;
		  /* 822516F8h */ case    3:  		/* bc 12, CR6_EQ, 48 */
		/* 822516F8h case    3:*/		if ( regs.CR[6].eq ) { return 0x82251728;  }
		/* 822516F8h case    3:*/		return 0x822516FC;
		  /* 822516FCh */ case    4:  		/* addi R3, R1, 80 */
		/* 822516FCh case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 822516FCh case    4:*/		return 0x82251700;
		  /* 82251700h */ case    5:  		/* bl 38480 */
		/* 82251700h case    5:*/		regs.LR = 0x82251704; return 0x8225AD50;
		/* 82251700h case    5:*/		return 0x82251704;
		  /* 82251704h */ case    6:  		/* addi R30, R3, 1 */
		/* 82251704h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x1);
		/* 82251704h case    6:*/		return 0x82251708;
		  /* 82251708h */ case    7:  		/* addi R3, R1, 80 */
		/* 82251708h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82251708h case    7:*/		return 0x8225170C;
		  /* 8225170Ch */ case    8:  		/* lwz R4, <#[R1 + 84]> */
		/* 8225170Ch case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 8225170Ch case    8:*/		return 0x82251710;
	}
	return 0x82251710;
} // Block from 822516ECh-82251710h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82251710h
// Function '?RemoveUnnecessaryDependencies@CFG@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251710);
		  /* 82251710h */ case    0:  		/* bl 9136 */
		/* 82251710h case    0:*/		regs.LR = 0x82251714; return 0x82253AC0;
		/* 82251710h case    0:*/		return 0x82251714;
		  /* 82251714h */ case    1:  		/* addi R11, R30, 58 */
		/* 82251714h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x3A);
		/* 82251714h case    1:*/		return 0x82251718;
		  /* 82251718h */ case    2:  		/* stw R30, <#[R3]> */
		/* 82251718h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82251718h case    2:*/		return 0x8225171C;
		  /* 8225171Ch */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8225171Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8225171Ch case    3:*/		return 0x82251720;
		  /* 82251720h */ case    4:  		/* lwzx R31, <#[R11 + R31]> */
		/* 82251720h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82251720h case    4:*/		return 0x82251724;
		  /* 82251724h */ case    5:  		/* b -272 */
		/* 82251724h case    5:*/		return 0x82251614;
		/* 82251724h case    5:*/		return 0x82251728;
	}
	return 0x82251728;
} // Block from 82251710h-82251728h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82251728h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251728);
		  /* 82251728h */ case    0:  		/* mr R4, R29 */
		/* 82251728h case    0:*/		regs.R4 = regs.R29;
		/* 82251728h case    0:*/		return 0x8225172C;
		  /* 8225172Ch */ case    1:  		/* mr R3, R31 */
		/* 8225172Ch case    1:*/		regs.R3 = regs.R31;
		/* 8225172Ch case    1:*/		return 0x82251730;
		  /* 82251730h */ case    2:  		/* bl -1376 */
		/* 82251730h case    2:*/		regs.LR = 0x82251734; return 0x822511D0;
		/* 82251730h case    2:*/		return 0x82251734;
		  /* 82251734h */ case    3:  		/* addi R3, R1, 96 */
		/* 82251734h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82251734h case    3:*/		return 0x82251738;
		  /* 82251738h */ case    4:  		/* bl 38424 */
		/* 82251738h case    4:*/		regs.LR = 0x8225173C; return 0x8225AD50;
		/* 82251738h case    4:*/		return 0x8225173C;
		  /* 8225173Ch */ case    5:  		/* addi R3, R1, 80 */
		/* 8225173Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8225173Ch case    5:*/		return 0x82251740;
		  /* 82251740h */ case    6:  		/* bl 38416 */
		/* 82251740h case    6:*/		regs.LR = 0x82251744; return 0x8225AD50;
		/* 82251740h case    6:*/		return 0x82251744;
		  /* 82251744h */ case    7:  		/* b -300 */
		/* 82251744h case    7:*/		return 0x82251618;
		/* 82251744h case    7:*/		return 0x82251748;
	}
	return 0x82251748;
} // Block from 82251728h-82251748h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82251748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251748);
		  /* 82251748h */ case    0:  		/* addi R27, R27, 1 */
		/* 82251748h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82251748h case    0:*/		return 0x8225174C;
		  /* 8225174Ch */ case    1:  		/* addi R28, R28, 4 */
		/* 8225174Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 8225174Ch case    1:*/		return 0x82251750;
		  /* 82251750h */ case    2:  		/* b -380 */
		/* 82251750h case    2:*/		return 0x822515D4;
		/* 82251750h case    2:*/		return 0x82251754;
	}
	return 0x82251754;
} // Block from 82251748h-82251754h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82251754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251754);
		  /* 82251754h */ case    0:  		/* mr R3, R29 */
		/* 82251754h case    0:*/		regs.R3 = regs.R29;
		/* 82251754h case    0:*/		return 0x82251758;
		  /* 82251758h */ case    1:  		/* bl -2904 */
		/* 82251758h case    1:*/		regs.LR = 0x8225175C; return 0x82250C00;
		/* 82251758h case    1:*/		return 0x8225175C;
		  /* 8225175Ch */ case    2:  		/* mr R3, R29 */
		/* 8225175Ch case    2:*/		regs.R3 = regs.R29;
		/* 8225175Ch case    2:*/		return 0x82251760;
		  /* 82251760h */ case    3:  		/* bl -1320 */
		/* 82251760h case    3:*/		regs.LR = 0x82251764; return 0x82251238;
		/* 82251760h case    3:*/		return 0x82251764;
		  /* 82251764h */ case    4:  		/* lwz R4, <#[R1 + 88]> */
		/* 82251764h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000058) );
		/* 82251764h case    4:*/		return 0x82251768;
		  /* 82251768h */ case    5:  		/* lwz R3, <#[R1 + 92]> */
		/* 82251768h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 82251768h case    5:*/		return 0x8225176C;
		  /* 8225176Ch */ case    6:  		/* bl -217388 */
		/* 8225176Ch case    6:*/		regs.LR = 0x82251770; return 0x8221C640;
		/* 8225176Ch case    6:*/		return 0x82251770;
		  /* 82251770h */ case    7:  		/* lwz R4, <#[R1 + 104]> */
		/* 82251770h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000068) );
		/* 82251770h case    7:*/		return 0x82251774;
		  /* 82251774h */ case    8:  		/* lwz R3, <#[R1 + 108]> */
		/* 82251774h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000006C) );
		/* 82251774h case    8:*/		return 0x82251778;
		  /* 82251778h */ case    9:  		/* bl -217400 */
		/* 82251778h case    9:*/		regs.LR = 0x8225177C; return 0x8221C640;
		/* 82251778h case    9:*/		return 0x8225177C;
		  /* 8225177Ch */ case   10:  		/* addi R1, R1, 176 */
		/* 8225177Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 8225177Ch case   10:*/		return 0x82251780;
		  /* 82251780h */ case   11:  		/* b -1836256 */
		/* 82251780h case   11:*/		return 0x820912A0;
		/* 82251780h case   11:*/		return 0x82251784;
		  /* 82251784h */ case   12:  		/* nop */
		/* 82251784h case   12:*/		cpu::op::nop();
		/* 82251784h case   12:*/		return 0x82251788;
	}
	return 0x82251788;
} // Block from 82251754h-82251788h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82251788h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251788);
		  /* 82251788h */ case    0:  		/* mfspr R12, LR */
		/* 82251788h case    0:*/		regs.R12 = regs.LR;
		/* 82251788h case    0:*/		return 0x8225178C;
		  /* 8225178Ch */ case    1:  		/* bl -1836388 */
		/* 8225178Ch case    1:*/		regs.LR = 0x82251790; return 0x82091228;
		/* 8225178Ch case    1:*/		return 0x82251790;
		  /* 82251790h */ case    2:  		/* subfic R29, R3, -944 */
		/* 82251790h case    2:*/		cpu::op::subfic<0>(regs,&regs.R29,regs.R3,0xFFFFFC50);
		/* 82251790h case    2:*/		return 0x82251794;
		  /* 82251794h */ case    3:  		/* stw R4, <#[R3 + 1876]> */
		/* 82251794h case    3:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000754) );
		/* 82251794h case    3:*/		return 0x82251798;
		  /* 82251798h */ case    4:  		/* subfic R28, R3, -700 */
		/* 82251798h case    4:*/		cpu::op::subfic<0>(regs,&regs.R28,regs.R3,0xFFFFFD44);
		/* 82251798h case    4:*/		return 0x8225179C;
		  /* 8225179Ch */ case    5:  		/* li R10, 0 */
		/* 8225179Ch case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8225179Ch case    5:*/		return 0x822517A0;
		  /* 822517A0h */ case    6:  		/* subfic R27, R3, -880 */
		/* 822517A0h case    6:*/		cpu::op::subfic<0>(regs,&regs.R27,regs.R3,0xFFFFFC90);
		/* 822517A0h case    6:*/		return 0x822517A4;
		  /* 822517A4h */ case    7:  		/* subfic R26, R3, -636 */
		/* 822517A4h case    7:*/		cpu::op::subfic<0>(regs,&regs.R26,regs.R3,0xFFFFFD84);
		/* 822517A4h case    7:*/		return 0x822517A8;
		  /* 822517A8h */ case    8:  		/* stb R10, <#[R3 + 1872]> */
		/* 822517A8h case    8:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R3 + 0x00000750) );
		/* 822517A8h case    8:*/		return 0x822517AC;
		  /* 822517ACh */ case    9:  		/* subfic R25, R3, -816 */
		/* 822517ACh case    9:*/		cpu::op::subfic<0>(regs,&regs.R25,regs.R3,0xFFFFFCD0);
		/* 822517ACh case    9:*/		return 0x822517B0;
		  /* 822517B0h */ case   10:  		/* stb R10, <#[R3 + 1873]> */
		/* 822517B0h case   10:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R3 + 0x00000751) );
		/* 822517B0h case   10:*/		return 0x822517B4;
		  /* 822517B4h */ case   11:  		/* mr R8, R10 */
		/* 822517B4h case   11:*/		regs.R8 = regs.R10;
		/* 822517B4h case   11:*/		return 0x822517B8;
		  /* 822517B8h */ case   12:  		/* addi R11, R3, 976 */
		/* 822517B8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x3D0);
		/* 822517B8h case   12:*/		return 0x822517BC;
		  /* 822517BCh */ case   13:  		/* subfic R24, R3, -572 */
		/* 822517BCh case   13:*/		cpu::op::subfic<0>(regs,&regs.R24,regs.R3,0xFFFFFDC4);
		/* 822517BCh case   13:*/		return 0x822517C0;
		  /* 822517C0h */ case   14:  		/* addi R23, R3, 896 */
		/* 822517C0h case   14:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R3,0x380);
		/* 822517C0h case   14:*/		return 0x822517C4;
		  /* 822517C4h */ case   15:  		/* li R22, 19 */
		/* 822517C4h case   15:*/		cpu::op::li<0>(regs,&regs.R22,0x13);
		/* 822517C4h case   15:*/		return 0x822517C8;
		  /* 822517C8h */ case   16:  		/* li R7, 4 */
		/* 822517C8h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 822517C8h case   16:*/		return 0x822517CC;
		  /* 822517CCh */ case   17:  		/* stw R10, <#[R11 - 64]> */
		/* 822517CCh case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0xFFFFFFC0) );
		/* 822517CCh case   17:*/		return 0x822517D0;
		  /* 822517D0h */ case   18:  		/* stbx R10, <#[R23 + R8]> */
		/* 822517D0h case   18:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R23 + regs.R8 + 0x00000000) );
		/* 822517D0h case   18:*/		return 0x822517D4;
		  /* 822517D4h */ case   19:  		/* mr R9, R10 */
		/* 822517D4h case   19:*/		regs.R9 = regs.R10;
		/* 822517D4h case   19:*/		return 0x822517D8;
		  /* 822517D8h */ case   20:  		/* stw R10, <#[R11]> */
		/* 822517D8h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 822517D8h case   20:*/		return 0x822517DC;
		  /* 822517DCh */ case   21:  		/* add R6, R29, R11 */
		/* 822517DCh case   21:*/		cpu::op::add<0>(regs,&regs.R6,regs.R29,regs.R11);
		/* 822517DCh case   21:*/		return 0x822517E0;
		  /* 822517E0h */ case   22:  		/* stw R8, <#[R11 + 64]> */
		/* 822517E0h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000040) );
		/* 822517E0h case   22:*/		return 0x822517E4;
		  /* 822517E4h */ case   23:  		/* add R5, R28, R11 */
		/* 822517E4h case   23:*/		cpu::op::add<0>(regs,&regs.R5,regs.R28,regs.R11);
		/* 822517E4h case   23:*/		return 0x822517E8;
		  /* 822517E8h */ case   24:  		/* stw R10, <#[R11 - 976]> */
		/* 822517E8h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0xFFFFFC30) );
		/* 822517E8h case   24:*/		return 0x822517EC;
		  /* 822517ECh */ case   25:  		/* add R4, R27, R11 */
		/* 822517ECh case   25:*/		cpu::op::add<0>(regs,&regs.R4,regs.R27,regs.R11);
		/* 822517ECh case   25:*/		return 0x822517F0;
		  /* 822517F0h */ case   26:  		/* mtspr CTR, R7 */
		/* 822517F0h case   26:*/		regs.CTR = regs.R7;
		/* 822517F0h case   26:*/		return 0x822517F4;
		  /* 822517F4h */ case   27:  		/* stw R8, <#[R11 - 912]> */
		/* 822517F4h case   27:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0xFFFFFC70) );
		/* 822517F4h case   27:*/		return 0x822517F8;
		  /* 822517F8h */ case   28:  		/* add R31, R26, R11 */
		/* 822517F8h case   28:*/		cpu::op::add<0>(regs,&regs.R31,regs.R26,regs.R11);
		/* 822517F8h case   28:*/		return 0x822517FC;
		  /* 822517FCh */ case   29:  		/* add R7, R25, R11 */
		/* 822517FCh case   29:*/		cpu::op::add<0>(regs,&regs.R7,regs.R25,regs.R11);
		/* 822517FCh case   29:*/		return 0x82251800;
		  /* 82251800h */ case   30:  		/* add R30, R24, R11 */
		/* 82251800h case   30:*/		cpu::op::add<0>(regs,&regs.R30,regs.R24,regs.R11);
		/* 82251800h case   30:*/		return 0x82251804;
		  /* 82251804h */ case   31:  		/* add R21, R6, R9 */
		/* 82251804h case   31:*/		cpu::op::add<0>(regs,&regs.R21,regs.R6,regs.R9);
		/* 82251804h case   31:*/		return 0x82251808;
		  /* 82251808h */ case   32:  		/* add R20, R5, R9 */
		/* 82251808h case   32:*/		cpu::op::add<0>(regs,&regs.R20,regs.R5,regs.R9);
		/* 82251808h case   32:*/		return 0x8225180C;
		  /* 8225180Ch */ case   33:  		/* add R19, R4, R9 */
		/* 8225180Ch case   33:*/		cpu::op::add<0>(regs,&regs.R19,regs.R4,regs.R9);
		/* 8225180Ch case   33:*/		return 0x82251810;
		  /* 82251810h */ case   34:  		/* add R18, R31, R9 */
		/* 82251810h case   34:*/		cpu::op::add<0>(regs,&regs.R18,regs.R31,regs.R9);
		/* 82251810h case   34:*/		return 0x82251814;
		  /* 82251814h */ case   35:  		/* add R17, R7, R9 */
		/* 82251814h case   35:*/		cpu::op::add<0>(regs,&regs.R17,regs.R7,regs.R9);
		/* 82251814h case   35:*/		return 0x82251818;
		  /* 82251818h */ case   36:  		/* add R16, R30, R9 */
		/* 82251818h case   36:*/		cpu::op::add<0>(regs,&regs.R16,regs.R30,regs.R9);
		/* 82251818h case   36:*/		return 0x8225181C;
		  /* 8225181Ch */ case   37:  		/* rlwinm R21, R21, 2, 0, 29 */
		/* 8225181Ch case   37:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R21,regs.R21);
		/* 8225181Ch case   37:*/		return 0x82251820;
		  /* 82251820h */ case   38:  		/* rlwinm R20, R20, 2, 0, 29 */
		/* 82251820h case   38:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R20,regs.R20);
		/* 82251820h case   38:*/		return 0x82251824;
		  /* 82251824h */ case   39:  		/* rlwinm R19, R19, 2, 0, 29 */
		/* 82251824h case   39:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R19,regs.R19);
		/* 82251824h case   39:*/		return 0x82251828;
		  /* 82251828h */ case   40:  		/* rlwinm R18, R18, 2, 0, 29 */
		/* 82251828h case   40:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R18,regs.R18);
		/* 82251828h case   40:*/		return 0x8225182C;
		  /* 8225182Ch */ case   41:  		/* rlwinm R17, R17, 2, 0, 29 */
		/* 8225182Ch case   41:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R17,regs.R17);
		/* 8225182Ch case   41:*/		return 0x82251830;
		  /* 82251830h */ case   42:  		/* rlwinm R16, R16, 2, 0, 29 */
		/* 82251830h case   42:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R16,regs.R16);
		/* 82251830h case   42:*/		return 0x82251834;
		  /* 82251834h */ case   43:  		/* stwx R10, <#[R21 + R3]> */
		/* 82251834h case   43:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R21 + regs.R3 + 0x00000000) );
		/* 82251834h case   43:*/		return 0x82251838;
		  /* 82251838h */ case   44:  		/* stwx R10, <#[R20 + R3]> */
		/* 82251838h case   44:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R20 + regs.R3 + 0x00000000) );
		/* 82251838h case   44:*/		return 0x8225183C;
		  /* 8225183Ch */ case   45:  		/* addi R9, R9, 1 */
		/* 8225183Ch case   45:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8225183Ch case   45:*/		return 0x82251840;
		  /* 82251840h */ case   46:  		/* stwx R22, <#[R19 + R3]> */
		/* 82251840h case   46:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R19 + regs.R3 + 0x00000000) );
		/* 82251840h case   46:*/		return 0x82251844;
		  /* 82251844h */ case   47:  		/* stwx R22, <#[R18 + R3]> */
		/* 82251844h case   47:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R18 + regs.R3 + 0x00000000) );
		/* 82251844h case   47:*/		return 0x82251848;
		  /* 82251848h */ case   48:  		/* stwx R10, <#[R17 + R3]> */
		/* 82251848h case   48:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R17 + regs.R3 + 0x00000000) );
		/* 82251848h case   48:*/		return 0x8225184C;
		  /* 8225184Ch */ case   49:  		/* stwx R10, <#[R16 + R3]> */
		/* 8225184Ch case   49:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R16 + regs.R3 + 0x00000000) );
		/* 8225184Ch case   49:*/		return 0x82251850;
		  /* 82251850h */ case   50:  		/* bc 16, CR0_LT, -76 */
		/* 82251850h case   50:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82251804;  }
		/* 82251850h case   50:*/		return 0x82251854;
		  /* 82251854h */ case   51:  		/* addi R8, R8, 1 */
		/* 82251854h case   51:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82251854h case   51:*/		return 0x82251858;
		  /* 82251858h */ case   52:  		/* addi R11, R11, 4 */
		/* 82251858h case   52:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82251858h case   52:*/		return 0x8225185C;
		  /* 8225185Ch */ case   53:  		/* cmpwi CR6, R8, 16 */
		/* 8225185Ch case   53:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000010);
		/* 8225185Ch case   53:*/		return 0x82251860;
		  /* 82251860h */ case   54:  		/* bc 12, CR6_LT, -152 */
		/* 82251860h case   54:*/		if ( regs.CR[6].lt ) { return 0x822517C8;  }
		/* 82251860h case   54:*/		return 0x82251864;
		  /* 82251864h */ case   55:  		/* b -1836524 */
		/* 82251864h case   55:*/		return 0x82091278;
		/* 82251864h case   55:*/		return 0x82251868;
	}
	return 0x82251868;
} // Block from 82251788h-82251868h (56 instructions)

//////////////////////////////////////////////////////
// Block at 82251868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251868);
		  /* 82251868h */ case    0:  		/* mfspr R12, LR */
		/* 82251868h case    0:*/		regs.R12 = regs.LR;
		/* 82251868h case    0:*/		return 0x8225186C;
		  /* 8225186Ch */ case    1:  		/* bl -1836572 */
		/* 8225186Ch case    1:*/		regs.LR = 0x82251870; return 0x82091250;
		/* 8225186Ch case    1:*/		return 0x82251870;
		  /* 82251870h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82251870h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82251870h case    2:*/		return 0x82251874;
		  /* 82251874h */ case    3:  		/* mr R30, R3 */
		/* 82251874h case    3:*/		regs.R30 = regs.R3;
		/* 82251874h case    3:*/		return 0x82251878;
		  /* 82251878h */ case    4:  		/* mr R31, R4 */
		/* 82251878h case    4:*/		regs.R31 = regs.R4;
		/* 82251878h case    4:*/		return 0x8225187C;
		  /* 8225187Ch */ case    5:  		/* mr R29, R5 */
		/* 8225187Ch case    5:*/		regs.R29 = regs.R5;
		/* 8225187Ch case    5:*/		return 0x82251880;
		  /* 82251880h */ case    6:  		/* mr R27, R6 */
		/* 82251880h case    6:*/		regs.R27 = regs.R6;
		/* 82251880h case    6:*/		return 0x82251884;
		  /* 82251884h */ case    7:  		/* mr R28, R7 */
		/* 82251884h case    7:*/		regs.R28 = regs.R7;
		/* 82251884h case    7:*/		return 0x82251888;
		  /* 82251888h */ case    8:  		/* mr R26, R8 */
		/* 82251888h case    8:*/		regs.R26 = regs.R8;
		/* 82251888h case    8:*/		return 0x8225188C;
		  /* 8225188Ch */ case    9:  		/* cmpwi CR6, R7, 5 */
		/* 8225188Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000005);
		/* 8225188Ch case    9:*/		return 0x82251890;
		  /* 82251890h */ case   10:  		/* bc 12, CR6_EQ, 160 */
		/* 82251890h case   10:*/		if ( regs.CR[6].eq ) { return 0x82251930;  }
		/* 82251890h case   10:*/		return 0x82251894;
		  /* 82251894h */ case   11:  		/* cmpwi CR6, R7, 6 */
		/* 82251894h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000006);
		/* 82251894h case   11:*/		return 0x82251898;
		  /* 82251898h */ case   12:  		/* bc 12, CR6_EQ, 152 */
		/* 82251898h case   12:*/		if ( regs.CR[6].eq ) { return 0x82251930;  }
		/* 82251898h case   12:*/		return 0x8225189C;
		  /* 8225189Ch */ case   13:  		/* addi R11, R4, 244 */
		/* 8225189Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0xF4);
		/* 8225189Ch case   13:*/		return 0x822518A0;
		  /* 822518A0h */ case   14:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822518A0h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822518A0h case   14:*/		return 0x822518A4;
		  /* 822518A4h */ case   15:  		/* lwzx R11, <#[R11 + R3]> */
		/* 822518A4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 822518A4h case   15:*/		return 0x822518A8;
		  /* 822518A8h */ case   16:  		/* cmpwi CR6, R11, 33 */
		/* 822518A8h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000021);
		/* 822518A8h case   16:*/		return 0x822518AC;
		  /* 822518ACh */ case   17:  		/* bc 4, CR6_EQ, 68 */
		/* 822518ACh case   17:*/		if ( !regs.CR[6].eq ) { return 0x822518F0;  }
		/* 822518ACh case   17:*/		return 0x822518B0;
		  /* 822518B0h */ case   18:  		/* addi R11, R4, 69 */
		/* 822518B0h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x45);
		/* 822518B0h case   18:*/		return 0x822518B4;
		  /* 822518B4h */ case   19:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822518B4h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822518B4h case   19:*/		return 0x822518B8;
		  /* 822518B8h */ case   20:  		/* add R11, R11, R5 */
		/* 822518B8h case   20:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 822518B8h case   20:*/		return 0x822518BC;
		  /* 822518BCh */ case   21:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822518BCh case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822518BCh case   21:*/		return 0x822518C0;
		  /* 822518C0h */ case   22:  		/* lwzx R11, <#[R11 + R3]> */
		/* 822518C0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 822518C0h case   22:*/		return 0x822518C4;
		  /* 822518C4h */ case   23:  		/* cmpwi CR6, R11, 0 */
		/* 822518C4h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 822518C4h case   23:*/		return 0x822518C8;
		  /* 822518C8h */ case   24:  		/* bc 12, CR6_EQ, 40 */
		/* 822518C8h case   24:*/		if ( regs.CR[6].eq ) { return 0x822518F0;  }
		/* 822518C8h case   24:*/		return 0x822518CC;
		  /* 822518CCh */ case   25:  		/* lis R11, -32252 */
		/* 822518CCh case   25:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822518CCh case   25:*/		return 0x822518D0;
		  /* 822518D0h */ case   26:  		/* lis R10, -32252 */
		/* 822518D0h case   26:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 822518D0h case   26:*/		return 0x822518D4;
		  /* 822518D4h */ case   27:  		/* lis R9, -32253 */
		/* 822518D4h case   27:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 822518D4h case   27:*/		return 0x822518D8;
		  /* 822518D8h */ case   28:  		/* addi R6, R11, 16944 */
		/* 822518D8h case   28:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x4230);
		/* 822518D8h case   28:*/		return 0x822518DC;
		  /* 822518DCh */ case   29:  		/* addi R5, R10, 16808 */
		/* 822518DCh case   29:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x41A8);
		/* 822518DCh case   29:*/		return 0x822518E0;
		  /* 822518E0h */ case   30:  		/* addi R4, R9, 27460 */
		/* 822518E0h case   30:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 822518E0h case   30:*/		return 0x822518E4;
		  /* 822518E4h */ case   31:  		/* li R7, 138 */
		/* 822518E4h case   31:*/		cpu::op::li<0>(regs,&regs.R7,0x8A);
		/* 822518E4h case   31:*/		return 0x822518E8;
		  /* 822518E8h */ case   32:  		/* li R3, 0 */
		/* 822518E8h case   32:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822518E8h case   32:*/		return 0x822518EC;
		  /* 822518ECh */ case   33:  		/* bl -1023204 */
		/* 822518ECh case   33:*/		regs.LR = 0x822518F0; return 0x82157C08;
		/* 822518ECh case   33:*/		return 0x822518F0;
	}
	return 0x822518F0;
} // Block from 82251868h-822518F0h (34 instructions)

//////////////////////////////////////////////////////
// Block at 822518F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822518F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822518F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822518F0);
		  /* 822518F0h */ case    0:  		/* addi R11, R31, 69 */
		/* 822518F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x45);
		/* 822518F0h case    0:*/		return 0x822518F4;
		  /* 822518F4h */ case    1:  		/* addi R10, R31, 85 */
		/* 822518F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x55);
		/* 822518F4h case    1:*/		return 0x822518F8;
		  /* 822518F8h */ case    2:  		/* addi R9, R31, 101 */
		/* 822518F8h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x65);
		/* 822518F8h case    2:*/		return 0x822518FC;
		  /* 822518FCh */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822518FCh case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822518FCh case    3:*/		return 0x82251900;
		  /* 82251900h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82251900h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82251900h case    4:*/		return 0x82251904;
		  /* 82251904h */ case    5:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82251904h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82251904h case    5:*/		return 0x82251908;
		  /* 82251908h */ case    6:  		/* add R11, R11, R29 */
		/* 82251908h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 82251908h case    6:*/		return 0x8225190C;
		  /* 8225190Ch */ case    7:  		/* add R10, R10, R29 */
		/* 8225190Ch case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R29);
		/* 8225190Ch case    7:*/		return 0x82251910;
		  /* 82251910h */ case    8:  		/* add R9, R9, R29 */
		/* 82251910h case    8:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R29);
		/* 82251910h case    8:*/		return 0x82251914;
		  /* 82251914h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82251914h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82251914h case    9:*/		return 0x82251918;
		  /* 82251918h */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82251918h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82251918h case   10:*/		return 0x8225191C;
		  /* 8225191Ch */ case   11:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8225191Ch case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8225191Ch case   11:*/		return 0x82251920;
		  /* 82251920h */ case   12:  		/* stwx R27, <#[R11 + R30]> */
		/* 82251920h case   12:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82251920h case   12:*/		return 0x82251924;
		  /* 82251924h */ case   13:  		/* stwx R28, <#[R10 + R30]> */
		/* 82251924h case   13:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 82251924h case   13:*/		return 0x82251928;
		  /* 82251928h */ case   14:  		/* stwx R26, <#[R9 + R30]> */
		/* 82251928h case   14:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 82251928h case   14:*/		return 0x8225192C;
		  /* 8225192Ch */ case   15:  		/* b 224 */
		/* 8225192Ch case   15:*/		return 0x82251A0C;
		/* 8225192Ch case   15:*/		return 0x82251930;
	}
	return 0x82251930;
} // Block from 822518F0h-82251930h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82251930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251930);
		  /* 82251930h */ case    0:  		/* addi R11, R31, 228 */
		/* 82251930h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xE4);
		/* 82251930h case    0:*/		return 0x82251934;
		  /* 82251934h */ case    1:  		/* rlwinm R27, R11, 2, 0, 29 */
		/* 82251934h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R11);
		/* 82251934h case    1:*/		return 0x82251938;
		  /* 82251938h */ case    2:  		/* lwzx R11, <#[R27 + R30]> */
		/* 82251938h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + regs.R30 + 0x00000000) );
		/* 82251938h case    2:*/		return 0x8225193C;
		  /* 8225193Ch */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8225193Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8225193Ch case    3:*/		return 0x82251940;
		  /* 82251940h */ case    4:  		/* bc 12, CR6_EQ, 204 */
		/* 82251940h case    4:*/		if ( regs.CR[6].eq ) { return 0x82251A0C;  }
		/* 82251940h case    4:*/		return 0x82251944;
		  /* 82251944h */ case    5:  		/* addi R11, R31, 244 */
		/* 82251944h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xF4);
		/* 82251944h case    5:*/		return 0x82251948;
		  /* 82251948h */ case    6:  		/* rlwinm R28, R11, 2, 0, 29 */
		/* 82251948h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R11);
		/* 82251948h case    6:*/		return 0x8225194C;
		  /* 8225194Ch */ case    7:  		/* lwzx R11, <#[R28 + R30]> */
		/* 8225194Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R30 + 0x00000000) );
		/* 8225194Ch case    7:*/		return 0x82251950;
		  /* 82251950h */ case    8:  		/* cmpwi CR6, R11, 33 */
		/* 82251950h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000021);
		/* 82251950h case    8:*/		return 0x82251954;
		  /* 82251954h */ case    9:  		/* bc 4, CR6_EQ, 32 */
		/* 82251954h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82251974;  }
		/* 82251954h case    9:*/		return 0x82251958;
		  /* 82251958h */ case   10:  		/* addi R11, R31, 69 */
		/* 82251958h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x45);
		/* 82251958h case   10:*/		return 0x8225195C;
		  /* 8225195Ch */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8225195Ch case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8225195Ch case   11:*/		return 0x82251960;
		  /* 82251960h */ case   12:  		/* add R11, R11, R29 */
		/* 82251960h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 82251960h case   12:*/		return 0x82251964;
		  /* 82251964h */ case   13:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82251964h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82251964h case   13:*/		return 0x82251968;
		  /* 82251968h */ case   14:  		/* lwzx R11, <#[R11 + R30]> */
		/* 82251968h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82251968h case   14:*/		return 0x8225196C;
		  /* 8225196Ch */ case   15:  		/* cmpwi CR6, R11, 0 */
		/* 8225196Ch case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8225196Ch case   15:*/		return 0x82251970;
		  /* 82251970h */ case   16:  		/* bc 12, CR6_EQ, 40 */
		/* 82251970h case   16:*/		if ( regs.CR[6].eq ) { return 0x82251998;  }
		/* 82251970h case   16:*/		return 0x82251974;
	}
	return 0x82251974;
} // Block from 82251930h-82251974h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82251974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251974);
		  /* 82251974h */ case    0:  		/* lis R11, -32252 */
		/* 82251974h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82251974h case    0:*/		return 0x82251978;
		  /* 82251978h */ case    1:  		/* lis R10, -32252 */
		/* 82251978h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82251978h case    1:*/		return 0x8225197C;
		  /* 8225197Ch */ case    2:  		/* lis R9, -32253 */
		/* 8225197Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8225197Ch case    2:*/		return 0x82251980;
		  /* 82251980h */ case    3:  		/* addi R6, R11, 16944 */
		/* 82251980h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x4230);
		/* 82251980h case    3:*/		return 0x82251984;
		  /* 82251984h */ case    4:  		/* addi R5, R10, 16672 */
		/* 82251984h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x4120);
		/* 82251984h case    4:*/		return 0x82251988;
		  /* 82251988h */ case    5:  		/* addi R4, R9, 27460 */
		/* 82251988h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82251988h case    5:*/		return 0x8225198C;
		  /* 8225198Ch */ case    6:  		/* li R7, 122 */
		/* 8225198Ch case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x7A);
		/* 8225198Ch case    6:*/		return 0x82251990;
		  /* 82251990h */ case    7:  		/* li R3, 0 */
		/* 82251990h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82251990h case    7:*/		return 0x82251994;
		  /* 82251994h */ case    8:  		/* bl -1023372 */
		/* 82251994h case    8:*/		regs.LR = 0x82251998; return 0x82157C08;
		/* 82251994h case    8:*/		return 0x82251998;
	}
	return 0x82251998;
} // Block from 82251974h-82251998h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82251998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251998);
		  /* 82251998h */ case    0:  		/* addi R10, R31, 260 */
		/* 82251998h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x104);
		/* 82251998h case    0:*/		return 0x8225199C;
		  /* 8225199Ch */ case    1:  		/* add R8, R31, R30 */
		/* 8225199Ch case    1:*/		cpu::op::add<0>(regs,&regs.R8,regs.R31,regs.R30);
		/* 8225199Ch case    1:*/		return 0x822519A0;
		  /* 822519A0h */ case    2:  		/* rlwinm R7, R10, 2, 0, 29 */
		/* 822519A0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R10);
		/* 822519A0h case    2:*/		return 0x822519A4;
		  /* 822519A4h */ case    3:  		/* li R9, 4 */
		/* 822519A4h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 822519A4h case    3:*/		return 0x822519A8;
		  /* 822519A8h */ case    4:  		/* li R11, 0 */
		/* 822519A8h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822519A8h case    4:*/		return 0x822519AC;
		  /* 822519ACh */ case    5:  		/* addi R6, R31, 69 */
		/* 822519ACh case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x45);
		/* 822519ACh case    5:*/		return 0x822519B0;
		  /* 822519B0h */ case    6:  		/* stwx R11, <#[R27 + R30]> */
		/* 822519B0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + regs.R30 + 0x00000000) );
		/* 822519B0h case    6:*/		return 0x822519B4;
		  /* 822519B4h */ case    7:  		/* addi R5, R31, 85 */
		/* 822519B4h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x55);
		/* 822519B4h case    7:*/		return 0x822519B8;
		  /* 822519B8h */ case    8:  		/* addi R4, R31, 101 */
		/* 822519B8h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x65);
		/* 822519B8h case    8:*/		return 0x822519BC;
		  /* 822519BCh */ case    9:  		/* stb R11, <#[R8 + 896]> */
		/* 822519BCh case    9:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R8 + 0x00000380) );
		/* 822519BCh case    9:*/		return 0x822519C0;
		  /* 822519C0h */ case   10:  		/* mtspr CTR, R9 */
		/* 822519C0h case   10:*/		regs.CTR = regs.R9;
		/* 822519C0h case   10:*/		return 0x822519C4;
		  /* 822519C4h */ case   11:  		/* stwx R31, <#[R7 + R30]> */
		/* 822519C4h case   11:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R7 + regs.R30 + 0x00000000) );
		/* 822519C4h case   11:*/		return 0x822519C8;
		  /* 822519C8h */ case   12:  		/* stwx R11, <#[R28 + R30]> */
		/* 822519C8h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + regs.R30 + 0x00000000) );
		/* 822519C8h case   12:*/		return 0x822519CC;
		  /* 822519CCh */ case   13:  		/* mr R10, R11 */
		/* 822519CCh case   13:*/		regs.R10 = regs.R11;
		/* 822519CCh case   13:*/		return 0x822519D0;
		  /* 822519D0h */ case   14:  		/* rlwinm R9, R6, 2, 0, 29 */
		/* 822519D0h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R6);
		/* 822519D0h case   14:*/		return 0x822519D4;
		  /* 822519D4h */ case   15:  		/* rlwinm R8, R5, 2, 0, 29 */
		/* 822519D4h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R5);
		/* 822519D4h case   15:*/		return 0x822519D8;
		  /* 822519D8h */ case   16:  		/* rlwinm R7, R4, 2, 0, 29 */
		/* 822519D8h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R4);
		/* 822519D8h case   16:*/		return 0x822519DC;
		  /* 822519DCh */ case   17:  		/* add R6, R9, R10 */
		/* 822519DCh case   17:*/		cpu::op::add<0>(regs,&regs.R6,regs.R9,regs.R10);
		/* 822519DCh case   17:*/		return 0x822519E0;
		  /* 822519E0h */ case   18:  		/* add R5, R8, R10 */
		/* 822519E0h case   18:*/		cpu::op::add<0>(regs,&regs.R5,regs.R8,regs.R10);
		/* 822519E0h case   18:*/		return 0x822519E4;
		  /* 822519E4h */ case   19:  		/* add R4, R7, R10 */
		/* 822519E4h case   19:*/		cpu::op::add<0>(regs,&regs.R4,regs.R7,regs.R10);
		/* 822519E4h case   19:*/		return 0x822519E8;
		  /* 822519E8h */ case   20:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 822519E8h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 822519E8h case   20:*/		return 0x822519EC;
		  /* 822519ECh */ case   21:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 822519ECh case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 822519ECh case   21:*/		return 0x822519F0;
		  /* 822519F0h */ case   22:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 822519F0h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 822519F0h case   22:*/		return 0x822519F4;
		  /* 822519F4h */ case   23:  		/* li R3, 19 */
		/* 822519F4h case   23:*/		cpu::op::li<0>(regs,&regs.R3,0x13);
		/* 822519F4h case   23:*/		return 0x822519F8;
		  /* 822519F8h */ case   24:  		/* addi R10, R10, 1 */
		/* 822519F8h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 822519F8h case   24:*/		return 0x822519FC;
		  /* 822519FCh */ case   25:  		/* stwx R11, <#[R6 + R30]> */
		/* 822519FCh case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + regs.R30 + 0x00000000) );
		/* 822519FCh case   25:*/		return 0x82251A00;
		  /* 82251A00h */ case   26:  		/* stwx R3, <#[R5 + R30]> */
		/* 82251A00h case   26:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R5 + regs.R30 + 0x00000000) );
		/* 82251A00h case   26:*/		return 0x82251A04;
		  /* 82251A04h */ case   27:  		/* stwx R11, <#[R4 + R30]> */
		/* 82251A04h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + regs.R30 + 0x00000000) );
		/* 82251A04h case   27:*/		return 0x82251A08;
		  /* 82251A08h */ case   28:  		/* bc 16, CR0_LT, -44 */
		/* 82251A08h case   28:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x822519DC;  }
		/* 82251A08h case   28:*/		return 0x82251A0C;
	}
	return 0x82251A0C;
} // Block from 82251998h-82251A0Ch (29 instructions)

//////////////////////////////////////////////////////
// Block at 82251A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251A0C);
		  /* 82251A0Ch */ case    0:  		/* addi R1, R1, 144 */
		/* 82251A0Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82251A0Ch case    0:*/		return 0x82251A10;
		  /* 82251A10h */ case    1:  		/* b -1836912 */
		/* 82251A10h case    1:*/		return 0x820912A0;
		/* 82251A10h case    1:*/		return 0x82251A14;
		  /* 82251A14h */ case    2:  		/* nop */
		/* 82251A14h case    2:*/		cpu::op::nop();
		/* 82251A14h case    2:*/		return 0x82251A18;
	}
	return 0x82251A18;
} // Block from 82251A0Ch-82251A18h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82251A18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251A18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251A18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251A18);
		  /* 82251A18h */ case    0:  		/* mfspr R12, LR */
		/* 82251A18h case    0:*/		regs.R12 = regs.LR;
		/* 82251A18h case    0:*/		return 0x82251A1C;
		  /* 82251A1Ch */ case    1:  		/* bl -1837000 */
		/* 82251A1Ch case    1:*/		regs.LR = 0x82251A20; return 0x82091254;
		/* 82251A1Ch case    1:*/		return 0x82251A20;
		  /* 82251A20h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82251A20h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82251A20h case    2:*/		return 0x82251A24;
		  /* 82251A24h */ case    3:  		/* lis R11, -32252 */
		/* 82251A24h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82251A24h case    3:*/		return 0x82251A28;
		  /* 82251A28h */ case    4:  		/* mr R29, R3 */
		/* 82251A28h case    4:*/		regs.R29 = regs.R3;
		/* 82251A28h case    4:*/		return 0x82251A2C;
		  /* 82251A2Ch */ case    5:  		/* lwz R3, <#[R3 + 1876]> */
		/* 82251A2Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000754) );
		/* 82251A2Ch case    5:*/		return 0x82251A30;
		  /* 82251A30h */ case    6:  		/* addi R4, R11, 17084 */
		/* 82251A30h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x42BC);
		/* 82251A30h case    6:*/		return 0x82251A34;
		  /* 82251A34h */ case    7:  		/* bl -214644 */
		/* 82251A34h case    7:*/		regs.LR = 0x82251A38; return 0x8221D3C0;
		/* 82251A34h case    7:*/		return 0x82251A38;
		  /* 82251A38h */ case    8:  		/* lis R11, -32252 */
		/* 82251A38h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82251A38h case    8:*/		return 0x82251A3C;
		  /* 82251A3Ch */ case    9:  		/* lis R10, -32251 */
		/* 82251A3Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 82251A3Ch case    9:*/		return 0x82251A40;
		  /* 82251A40h */ case   10:  		/* li R30, 0 */
		/* 82251A40h case   10:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82251A40h case   10:*/		return 0x82251A44;
		  /* 82251A44h */ case   11:  		/* addi R31, R29, 1040 */
		/* 82251A44h case   11:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R29,0x410);
		/* 82251A44h case   11:*/		return 0x82251A48;
		  /* 82251A48h */ case   12:  		/* addi R28, R11, 17044 */
		/* 82251A48h case   12:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0x4294);
		/* 82251A48h case   12:*/		return 0x82251A4C;
		  /* 82251A4Ch */ case   13:  		/* addi R27, R10, -19064 */
		/* 82251A4Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R10,0xFFFFB588);
		/* 82251A4Ch case   13:*/		return 0x82251A50;
		  /* 82251A50h */ case   14:  		/* lwz R11, <#[R31 - 128]> */
		/* 82251A50h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0xFFFFFF80) );
		/* 82251A50h case   14:*/		return 0x82251A54;
		  /* 82251A54h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 82251A54h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82251A54h case   15:*/		return 0x82251A58;
		  /* 82251A58h */ case   16:  		/* bc 12, CR6_EQ, 36 */
		/* 82251A58h case   16:*/		if ( regs.CR[6].eq ) { return 0x82251A7C;  }
		/* 82251A58h case   16:*/		return 0x82251A5C;
		  /* 82251A5Ch */ case   17:  		/* lwz R11, <#[R31 - 64]> */
		/* 82251A5Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0xFFFFFFC0) );
		/* 82251A5Ch case   17:*/		return 0x82251A60;
		  /* 82251A60h */ case   18:  		/* mr R4, R28 */
		/* 82251A60h case   18:*/		regs.R4 = regs.R28;
		/* 82251A60h case   18:*/		return 0x82251A64;
		  /* 82251A64h */ case   19:  		/* mr R5, R30 */
		/* 82251A64h case   19:*/		regs.R5 = regs.R30;
		/* 82251A64h case   19:*/		return 0x82251A68;
		  /* 82251A68h */ case   20:  		/* lwz R7, <#[R31]> */
		/* 82251A68h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000000) );
		/* 82251A68h case   20:*/		return 0x82251A6C;
		  /* 82251A6Ch */ case   21:  		/* mulli R11, R11, 12 */
		/* 82251A6Ch case   21:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82251A6Ch case   21:*/		return 0x82251A70;
		  /* 82251A70h */ case   22:  		/* lwz R3, <#[R29 + 1876]> */
		/* 82251A70h case   22:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000754) );
		/* 82251A70h case   22:*/		return 0x82251A74;
		  /* 82251A74h */ case   23:  		/* lwzx R6, <#[R11 + R27]> */
		/* 82251A74h case   23:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 82251A74h case   23:*/		return 0x82251A78;
		  /* 82251A78h */ case   24:  		/* bl -214712 */
		/* 82251A78h case   24:*/		regs.LR = 0x82251A7C; return 0x8221D3C0;
		/* 82251A78h case   24:*/		return 0x82251A7C;
	}
	return 0x82251A7C;
} // Block from 82251A18h-82251A7Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 82251A7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251A7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251A7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251A7C);
		  /* 82251A7Ch */ case    0:  		/* addi R30, R30, 1 */
		/* 82251A7Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82251A7Ch case    0:*/		return 0x82251A80;
		  /* 82251A80h */ case    1:  		/* addi R31, R31, 4 */
		/* 82251A80h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82251A80h case    1:*/		return 0x82251A84;
		  /* 82251A84h */ case    2:  		/* cmpwi CR6, R30, 16 */
		/* 82251A84h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000010);
		/* 82251A84h case    2:*/		return 0x82251A88;
		  /* 82251A88h */ case    3:  		/* bc 12, CR6_LT, -56 */
		/* 82251A88h case    3:*/		if ( regs.CR[6].lt ) { return 0x82251A50;  }
		/* 82251A88h case    3:*/		return 0x82251A8C;
		  /* 82251A8Ch */ case    4:  		/* addi R1, R1, 128 */
		/* 82251A8Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82251A8Ch case    4:*/		return 0x82251A90;
		  /* 82251A90h */ case    5:  		/* b -1837036 */
		/* 82251A90h case    5:*/		return 0x820912A4;
		/* 82251A90h case    5:*/		return 0x82251A94;
		  /* 82251A94h */ case    6:  		/* nop */
		/* 82251A94h case    6:*/		cpu::op::nop();
		/* 82251A94h case    6:*/		return 0x82251A98;
		  /* 82251A98h */ case    7:  		/* addi R11, R4, 244 */
		/* 82251A98h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0xF4);
		/* 82251A98h case    7:*/		return 0x82251A9C;
		  /* 82251A9Ch */ case    8:  		/* addi R10, R5, 244 */
		/* 82251A9Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0xF4);
		/* 82251A9Ch case    8:*/		return 0x82251AA0;
		  /* 82251AA0h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82251AA0h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82251AA0h case    9:*/		return 0x82251AA4;
		  /* 82251AA4h */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82251AA4h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82251AA4h case   10:*/		return 0x82251AA8;
		  /* 82251AA8h */ case   11:  		/* lwzx R11, <#[R11 + R3]> */
		/* 82251AA8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82251AA8h case   11:*/		return 0x82251AAC;
		  /* 82251AACh */ case   12:  		/* lwzx R10, <#[R10 + R3]> */
		/* 82251AACh case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 82251AACh case   12:*/		return 0x82251AB0;
		  /* 82251AB0h */ case   13:  		/* cmpw CR6, R11, R10 */
		/* 82251AB0h case   13:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82251AB0h case   13:*/		return 0x82251AB4;
		  /* 82251AB4h */ case   14:  		/* bc 4, CR6_LT, 12 */
		/* 82251AB4h case   14:*/		if ( !regs.CR[6].lt ) { return 0x82251AC0;  }
		/* 82251AB4h case   14:*/		return 0x82251AB8;
		  /* 82251AB8h */ case   15:  		/* li R3, -1 */
		/* 82251AB8h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82251AB8h case   15:*/		return 0x82251ABC;
		  /* 82251ABCh */ case   16:  		/* bclr 20, CR0_LT */
		/* 82251ABCh case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82251ABCh case   16:*/		return 0x82251AC0;
	}
	return 0x82251AC0;
} // Block from 82251A7Ch-82251AC0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82251AC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251AC0);
		  /* 82251AC0h */ case    0:  		/* bc 4, CR6_GT, 12 */
		/* 82251AC0h case    0:*/		if ( !regs.CR[6].gt ) { return 0x82251ACC;  }
		/* 82251AC0h case    0:*/		return 0x82251AC4;
		  /* 82251AC4h */ case    1:  		/* li R3, 1 */
		/* 82251AC4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82251AC4h case    1:*/		return 0x82251AC8;
		  /* 82251AC8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82251AC8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82251AC8h case    2:*/		return 0x82251ACC;
	}
	return 0x82251ACC;
} // Block from 82251AC0h-82251ACCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82251ACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251ACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251ACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251ACC);
		  /* 82251ACCh */ case    0:  		/* addi R11, R4, 260 */
		/* 82251ACCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x104);
		/* 82251ACCh case    0:*/		return 0x82251AD0;
		  /* 82251AD0h */ case    1:  		/* addi R10, R5, 260 */
		/* 82251AD0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0x104);
		/* 82251AD0h case    1:*/		return 0x82251AD4;
		  /* 82251AD4h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82251AD4h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82251AD4h case    2:*/		return 0x82251AD8;
		  /* 82251AD8h */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82251AD8h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82251AD8h case    3:*/		return 0x82251ADC;
		  /* 82251ADCh */ case    4:  		/* lwzx R11, <#[R11 + R3]> */
		/* 82251ADCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82251ADCh case    4:*/		return 0x82251AE0;
		  /* 82251AE0h */ case    5:  		/* lwzx R10, <#[R10 + R3]> */
		/* 82251AE0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 82251AE0h case    5:*/		return 0x82251AE4;
		  /* 82251AE4h */ case    6:  		/* cmpw CR6, R11, R10 */
		/* 82251AE4h case    6:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82251AE4h case    6:*/		return 0x82251AE8;
		  /* 82251AE8h */ case    7:  		/* bc 12, CR6_GT, -48 */
		/* 82251AE8h case    7:*/		if ( regs.CR[6].gt ) { return 0x82251AB8;  }
		/* 82251AE8h case    7:*/		return 0x82251AEC;
		  /* 82251AECh */ case    8:  		/* subfc R9, R10, R11 */
		/* 82251AECh case    8:*/		cpu::op::subfc<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 82251AECh case    8:*/		return 0x82251AF0;
		  /* 82251AF0h */ case    9:  		/* eqv R11, R10, R11 */
		/* 82251AF0h case    9:*/		cpu::op::eqv<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82251AF0h case    9:*/		return 0x82251AF4;
		  /* 82251AF4h */ case   10:  		/* rlwinm R11, R11, 1, 31, 31 */
		/* 82251AF4h case   10:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R11);
		/* 82251AF4h case   10:*/		return 0x82251AF8;
		  /* 82251AF8h */ case   11:  		/* addze R11, R11 */
		/* 82251AF8h case   11:*/		cpu::op::addze<0>(regs,&regs.R11,regs.R11);
		/* 82251AF8h case   11:*/		return 0x82251AFC;
		  /* 82251AFCh */ case   12:  		/* rlwinm R3, R11, 0, 31, 31 */
		/* 82251AFCh case   12:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R11);
		/* 82251AFCh case   12:*/		return 0x82251B00;
		  /* 82251B00h */ case   13:  		/* bclr 20, CR0_LT */
		/* 82251B00h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82251B00h case   13:*/		return 0x82251B04;
	}
	return 0x82251B04;
} // Block from 82251ACCh-82251B04h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82251B04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251B04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251B04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251B04);
		  /* 82251B04h */ case    0:  		/* nop */
		/* 82251B04h case    0:*/		cpu::op::nop();
		/* 82251B04h case    0:*/		return 0x82251B08;
	}
	return 0x82251B08;
} // Block from 82251B04h-82251B08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82251B08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251B08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251B08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251B08);
		  /* 82251B08h */ case    0:  		/* mfspr R12, LR */
		/* 82251B08h case    0:*/		regs.R12 = regs.LR;
		/* 82251B08h case    0:*/		return 0x82251B0C;
		  /* 82251B0Ch */ case    1:  		/* bl -1837244 */
		/* 82251B0Ch case    1:*/		regs.LR = 0x82251B10; return 0x82091250;
		/* 82251B0Ch case    1:*/		return 0x82251B10;
		  /* 82251B10h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82251B10h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82251B10h case    2:*/		return 0x82251B14;
		  /* 82251B14h */ case    3:  		/* lbz R9, <#[R3 + 1873]> */
		/* 82251B14h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000751) );
		/* 82251B14h case    3:*/		return 0x82251B18;
		  /* 82251B18h */ case    4:  		/* lis R11, -32253 */
		/* 82251B18h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 82251B18h case    4:*/		return 0x82251B1C;
		  /* 82251B1Ch */ case    5:  		/* lis R10, -32252 */
		/* 82251B1Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82251B1Ch case    5:*/		return 0x82251B20;
		  /* 82251B20h */ case    6:  		/* mr R31, R3 */
		/* 82251B20h case    6:*/		regs.R31 = regs.R3;
		/* 82251B20h case    6:*/		return 0x82251B24;
		  /* 82251B24h */ case    7:  		/* mr R30, R4 */
		/* 82251B24h case    7:*/		regs.R30 = regs.R4;
		/* 82251B24h case    7:*/		return 0x82251B28;
		  /* 82251B28h */ case    8:  		/* mr R27, R5 */
		/* 82251B28h case    8:*/		regs.R27 = regs.R5;
		/* 82251B28h case    8:*/		return 0x82251B2C;
		  /* 82251B2Ch */ case    9:  		/* mr R26, R6 */
		/* 82251B2Ch case    9:*/		regs.R26 = regs.R6;
		/* 82251B2Ch case    9:*/		return 0x82251B30;
		  /* 82251B30h */ case   10:  		/* cmplwi CR0, R9, 0 */
		/* 82251B30h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 82251B30h case   10:*/		return 0x82251B34;
		  /* 82251B34h */ case   11:  		/* addi R29, R11, 27460 */
		/* 82251B34h case   11:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x6B44);
		/* 82251B34h case   11:*/		return 0x82251B38;
		  /* 82251B38h */ case   12:  		/* addi R28, R10, 16944 */
		/* 82251B38h case   12:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R10,0x4230);
		/* 82251B38h case   12:*/		return 0x82251B3C;
		  /* 82251B3Ch */ case   13:  		/* bc 12, CR0_EQ, 32 */
		/* 82251B3Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x82251B5C;  }
		/* 82251B3Ch case   13:*/		return 0x82251B40;
		  /* 82251B40h */ case   14:  		/* lis R11, -32252 */
		/* 82251B40h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82251B40h case   14:*/		return 0x82251B44;
		  /* 82251B44h */ case   15:  		/* mr R6, R28 */
		/* 82251B44h case   15:*/		regs.R6 = regs.R28;
		/* 82251B44h case   15:*/		return 0x82251B48;
		  /* 82251B48h */ case   16:  		/* addi R5, R11, 17120 */
		/* 82251B48h case   16:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x42E0);
		/* 82251B48h case   16:*/		return 0x82251B4C;
		  /* 82251B4Ch */ case   17:  		/* mr R4, R29 */
		/* 82251B4Ch case   17:*/		regs.R4 = regs.R29;
		/* 82251B4Ch case   17:*/		return 0x82251B50;
		  /* 82251B50h */ case   18:  		/* li R7, 482 */
		/* 82251B50h case   18:*/		cpu::op::li<0>(regs,&regs.R7,0x1E2);
		/* 82251B50h case   18:*/		return 0x82251B54;
		  /* 82251B54h */ case   19:  		/* li R3, 0 */
		/* 82251B54h case   19:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82251B54h case   19:*/		return 0x82251B58;
		  /* 82251B58h */ case   20:  		/* bl -1023824 */
		/* 82251B58h case   20:*/		regs.LR = 0x82251B5C; return 0x82157C08;
		/* 82251B58h case   20:*/		return 0x82251B5C;
	}
	return 0x82251B5C;
} // Block from 82251B08h-82251B5Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 82251B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251B5C);
		  /* 82251B5Ch */ case    0:  		/* li R3, 0 */
		/* 82251B5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82251B5Ch case    0:*/		return 0x82251B60;
		  /* 82251B60h */ case    1:  		/* addi R11, R31, 912 */
		/* 82251B60h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x390);
		/* 82251B60h case    1:*/		return 0x82251B64;
		  /* 82251B64h */ case    2:  		/* lwz R10, <#[R11]> */
		/* 82251B64h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82251B64h case    2:*/		return 0x82251B68;
		  /* 82251B68h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 82251B68h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82251B68h case    3:*/		return 0x82251B6C;
		  /* 82251B6Ch */ case    4:  		/* bc 12, CR6_EQ, 60 */
		/* 82251B6Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82251BA8;  }
		/* 82251B6Ch case    4:*/		return 0x82251B70;
		  /* 82251B70h */ case    5:  		/* addi R3, R3, 1 */
		/* 82251B70h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 82251B70h case    5:*/		return 0x82251B74;
		  /* 82251B74h */ case    6:  		/* addi R11, R11, 4 */
		/* 82251B74h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82251B74h case    6:*/		return 0x82251B78;
		  /* 82251B78h */ case    7:  		/* cmpwi CR6, R3, 16 */
		/* 82251B78h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000010);
		/* 82251B78h case    7:*/		return 0x82251B7C;
		  /* 82251B7Ch */ case    8:  		/* bc 12, CR6_LT, -24 */
		/* 82251B7Ch case    8:*/		if ( regs.CR[6].lt ) { return 0x82251B64;  }
		/* 82251B7Ch case    8:*/		return 0x82251B80;
		  /* 82251B80h */ case    9:  		/* lis R11, -32255 */
		/* 82251B80h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82251B80h case    9:*/		return 0x82251B84;
		  /* 82251B84h */ case   10:  		/* mr R6, R28 */
		/* 82251B84h case   10:*/		regs.R6 = regs.R28;
		/* 82251B84h case   10:*/		return 0x82251B88;
		  /* 82251B88h */ case   11:  		/* addi R5, R11, 5216 */
		/* 82251B88h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x1460);
		/* 82251B88h case   11:*/		return 0x82251B8C;
		  /* 82251B8Ch */ case   12:  		/* mr R4, R29 */
		/* 82251B8Ch case   12:*/		regs.R4 = regs.R29;
		/* 82251B8Ch case   12:*/		return 0x82251B90;
		  /* 82251B90h */ case   13:  		/* li R7, 499 */
		/* 82251B90h case   13:*/		cpu::op::li<0>(regs,&regs.R7,0x1F3);
		/* 82251B90h case   13:*/		return 0x82251B94;
		  /* 82251B94h */ case   14:  		/* li R3, 0 */
		/* 82251B94h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82251B94h case   14:*/		return 0x82251B98;
		  /* 82251B98h */ case   15:  		/* bl -1023888 */
		/* 82251B98h case   15:*/		regs.LR = 0x82251B9C; return 0x82157C08;
		/* 82251B98h case   15:*/		return 0x82251B9C;
		  /* 82251B9Ch */ case   16:  		/* li R3, 0 */
		/* 82251B9Ch case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82251B9Ch case   16:*/		return 0x82251BA0;
		  /* 82251BA0h */ case   17:  		/* addi R1, R1, 144 */
		/* 82251BA0h case   17:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82251BA0h case   17:*/		return 0x82251BA4;
		  /* 82251BA4h */ case   18:  		/* b -1837316 */
		/* 82251BA4h case   18:*/		return 0x820912A0;
		/* 82251BA4h case   18:*/		return 0x82251BA8;
	}
	return 0x82251BA8;
} // Block from 82251B5Ch-82251BA8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82251BA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251BA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251BA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251BA8);
		  /* 82251BA8h */ case    0:  		/* addi R11, R3, 244 */
		/* 82251BA8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0xF4);
		/* 82251BA8h case    0:*/		return 0x82251BAC;
		  /* 82251BACh */ case    1:  		/* addi R10, R3, 260 */
		/* 82251BACh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0x104);
		/* 82251BACh case    1:*/		return 0x82251BB0;
		  /* 82251BB0h */ case    2:  		/* addi R9, R3, 228 */
		/* 82251BB0h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0xE4);
		/* 82251BB0h case    2:*/		return 0x82251BB4;
		  /* 82251BB4h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82251BB4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82251BB4h case    3:*/		return 0x82251BB8;
		  /* 82251BB8h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82251BB8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82251BB8h case    4:*/		return 0x82251BBC;
		  /* 82251BBCh */ case    5:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82251BBCh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82251BBCh case    5:*/		return 0x82251BC0;
		  /* 82251BC0h */ case    6:  		/* cmpwi CR6, R30, 33 */
		/* 82251BC0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000021);
		/* 82251BC0h case    6:*/		return 0x82251BC4;
		  /* 82251BC4h */ case    7:  		/* stwx R30, <#[R11 + R31]> */
		/* 82251BC4h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82251BC4h case    7:*/		return 0x82251BC8;
		  /* 82251BC8h */ case    8:  		/* stwx R27, <#[R10 + R31]> */
		/* 82251BC8h case    8:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 82251BC8h case    8:*/		return 0x82251BCC;
		  /* 82251BCCh */ case    9:  		/* stwx R26, <#[R9 + R31]> */
		/* 82251BCCh case    9:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R9 + regs.R31 + 0x00000000) );
		/* 82251BCCh case    9:*/		return 0x82251BD0;
		  /* 82251BD0h */ case   10:  		/* bc 12, CR6_EQ, -48 */
		/* 82251BD0h case   10:*/		if ( regs.CR[6].eq ) { return 0x82251BA0;  }
		/* 82251BD0h case   10:*/		return 0x82251BD4;
		  /* 82251BD4h */ case   11:  		/* li R10, 4 */
		/* 82251BD4h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 82251BD4h case   11:*/		return 0x82251BD8;
		  /* 82251BD8h */ case   12:  		/* addi R9, R3, 69 */
		/* 82251BD8h case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x45);
		/* 82251BD8h case   12:*/		return 0x82251BDC;
		  /* 82251BDCh */ case   13:  		/* li R11, 0 */
		/* 82251BDCh case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82251BDCh case   13:*/		return 0x82251BE0;
		  /* 82251BE0h */ case   14:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82251BE0h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82251BE0h case   14:*/		return 0x82251BE4;
		  /* 82251BE4h */ case   15:  		/* mtspr CTR, R10 */
		/* 82251BE4h case   15:*/		regs.CTR = regs.R10;
		/* 82251BE4h case   15:*/		return 0x82251BE8;
		  /* 82251BE8h */ case   16:  		/* add R10, R9, R11 */
		/* 82251BE8h case   16:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R11);
		/* 82251BE8h case   16:*/		return 0x82251BEC;
		  /* 82251BECh */ case   17:  		/* li R8, 5 */
		/* 82251BECh case   17:*/		cpu::op::li<0>(regs,&regs.R8,0x5);
		/* 82251BECh case   17:*/		return 0x82251BF0;
		  /* 82251BF0h */ case   18:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82251BF0h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82251BF0h case   18:*/		return 0x82251BF4;
		  /* 82251BF4h */ case   19:  		/* addi R11, R11, 1 */
		/* 82251BF4h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82251BF4h case   19:*/		return 0x82251BF8;
		  /* 82251BF8h */ case   20:  		/* stwx R8, <#[R10 + R31]> */
		/* 82251BF8h case   20:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 82251BF8h case   20:*/		return 0x82251BFC;
		  /* 82251BFCh */ case   21:  		/* bc 16, CR0_LT, -20 */
		/* 82251BFCh case   21:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82251BE8;  }
		/* 82251BFCh case   21:*/		return 0x82251C00;
		  /* 82251C00h */ case   22:  		/* b -96 */
		/* 82251C00h case   22:*/		return 0x82251BA0;
		/* 82251C00h case   22:*/		return 0x82251C04;
		  /* 82251C04h */ case   23:  		/* nop */
		/* 82251C04h case   23:*/		cpu::op::nop();
		/* 82251C04h case   23:*/		return 0x82251C08;
	}
	return 0x82251C08;
} // Block from 82251BA8h-82251C08h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82251C08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251C08);
		  /* 82251C08h */ case    0:  		/* mfspr R12, LR */
		/* 82251C08h case    0:*/		regs.R12 = regs.LR;
		/* 82251C08h case    0:*/		return 0x82251C0C;
		  /* 82251C0Ch */ case    1:  		/* bl -1837508 */
		/* 82251C0Ch case    1:*/		regs.LR = 0x82251C10; return 0x82091248;
		/* 82251C0Ch case    1:*/		return 0x82251C10;
		  /* 82251C10h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82251C10h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82251C10h case    2:*/		return 0x82251C14;
		  /* 82251C14h */ case    3:  		/* add R9, R7, R3 */
		/* 82251C14h case    3:*/		cpu::op::add<0>(regs,&regs.R9,regs.R7,regs.R3);
		/* 82251C14h case    3:*/		return 0x82251C18;
		  /* 82251C18h */ case    4:  		/* li R8, 1 */
		/* 82251C18h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82251C18h case    4:*/		return 0x82251C1C;
		  /* 82251C1Ch */ case    5:  		/* lis R11, -32253 */
		/* 82251C1Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 82251C1Ch case    5:*/		return 0x82251C20;
		  /* 82251C20h */ case    6:  		/* lis R10, -32252 */
		/* 82251C20h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82251C20h case    6:*/		return 0x82251C24;
		  /* 82251C24h */ case    7:  		/* mr R31, R3 */
		/* 82251C24h case    7:*/		regs.R31 = regs.R3;
		/* 82251C24h case    7:*/		return 0x82251C28;
		  /* 82251C28h */ case    8:  		/* stb R8, <#[R9 + 896]> */
		/* 82251C28h case    8:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R9 + 0x00000380) );
		/* 82251C28h case    8:*/		return 0x82251C2C;
		  /* 82251C2Ch */ case    9:  		/* mr R29, R4 */
		/* 82251C2Ch case    9:*/		regs.R29 = regs.R4;
		/* 82251C2Ch case    9:*/		return 0x82251C30;
		  /* 82251C30h */ case   10:  		/* lbz R9, <#[R3 + 1872]> */
		/* 82251C30h case   10:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000750) );
		/* 82251C30h case   10:*/		return 0x82251C34;
		  /* 82251C34h */ case   11:  		/* mr R25, R5 */
		/* 82251C34h case   11:*/		regs.R25 = regs.R5;
		/* 82251C34h case   11:*/		return 0x82251C38;
		  /* 82251C38h */ case   12:  		/* mr R24, R6 */
		/* 82251C38h case   12:*/		regs.R24 = regs.R6;
		/* 82251C38h case   12:*/		return 0x82251C3C;
		  /* 82251C3Ch */ case   13:  		/* mr R30, R7 */
		/* 82251C3Ch case   13:*/		regs.R30 = regs.R7;
		/* 82251C3Ch case   13:*/		return 0x82251C40;
		  /* 82251C40h */ case   14:  		/* addi R28, R11, 27460 */
		/* 82251C40h case   14:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0x6B44);
		/* 82251C40h case   14:*/		return 0x82251C44;
		  /* 82251C44h */ case   15:  		/* addi R27, R10, 16944 */
		/* 82251C44h case   15:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R10,0x4230);
		/* 82251C44h case   15:*/		return 0x82251C48;
		  /* 82251C48h */ case   16:  		/* cmplwi CR0, R9, 0 */
		/* 82251C48h case   16:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 82251C48h case   16:*/		return 0x82251C4C;
		  /* 82251C4Ch */ case   17:  		/* bc 12, CR0_EQ, 32 */
		/* 82251C4Ch case   17:*/		if ( regs.CR[0].eq ) { return 0x82251C6C;  }
		/* 82251C4Ch case   17:*/		return 0x82251C50;
		  /* 82251C50h */ case   18:  		/* lis R11, -32252 */
		/* 82251C50h case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82251C50h case   18:*/		return 0x82251C54;
		  /* 82251C54h */ case   19:  		/* mr R6, R27 */
		/* 82251C54h case   19:*/		regs.R6 = regs.R27;
		/* 82251C54h case   19:*/		return 0x82251C58;
		  /* 82251C58h */ case   20:  		/* addi R5, R11, 17176 */
		/* 82251C58h case   20:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x4318);
		/* 82251C58h case   20:*/		return 0x82251C5C;
		  /* 82251C5Ch */ case   21:  		/* mr R4, R28 */
		/* 82251C5Ch case   21:*/		regs.R4 = regs.R28;
		/* 82251C5Ch case   21:*/		return 0x82251C60;
		  /* 82251C60h */ case   22:  		/* li R7, 512 */
		/* 82251C60h case   22:*/		cpu::op::li<0>(regs,&regs.R7,0x200);
		/* 82251C60h case   22:*/		return 0x82251C64;
		  /* 82251C64h */ case   23:  		/* li R3, 0 */
		/* 82251C64h case   23:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82251C64h case   23:*/		return 0x82251C68;
		  /* 82251C68h */ case   24:  		/* bl -1024096 */
		/* 82251C68h case   24:*/		regs.LR = 0x82251C6C; return 0x82157C08;
		/* 82251C68h case   24:*/		return 0x82251C6C;
	}
	return 0x82251C6C;
} // Block from 82251C08h-82251C6Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 82251C6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251C6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251C6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251C6C);
		  /* 82251C6Ch */ case    0:  		/* lbz R11, <#[R31 + 1873]> */
		/* 82251C6Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000751) );
		/* 82251C6Ch case    0:*/		return 0x82251C70;
		  /* 82251C70h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 82251C70h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82251C70h case    1:*/		return 0x82251C74;
		  /* 82251C74h */ case    2:  		/* bc 4, CR0_EQ, 32 */
		/* 82251C74h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82251C94;  }
		/* 82251C74h case    2:*/		return 0x82251C78;
		  /* 82251C78h */ case    3:  		/* lis R11, -32252 */
		/* 82251C78h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82251C78h case    3:*/		return 0x82251C7C;
		  /* 82251C7Ch */ case    4:  		/* mr R6, R27 */
		/* 82251C7Ch case    4:*/		regs.R6 = regs.R27;
		/* 82251C7Ch case    4:*/		return 0x82251C80;
		  /* 82251C80h */ case    5:  		/* addi R5, R11, 17156 */
		/* 82251C80h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x4304);
		/* 82251C80h case    5:*/		return 0x82251C84;
		  /* 82251C84h */ case    6:  		/* mr R4, R28 */
		/* 82251C84h case    6:*/		regs.R4 = regs.R28;
		/* 82251C84h case    6:*/		return 0x82251C88;
		  /* 82251C88h */ case    7:  		/* li R7, 514 */
		/* 82251C88h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x202);
		/* 82251C88h case    7:*/		return 0x82251C8C;
		  /* 82251C8Ch */ case    8:  		/* li R3, 0 */
		/* 82251C8Ch case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82251C8Ch case    8:*/		return 0x82251C90;
		  /* 82251C90h */ case    9:  		/* bl -1024136 */
		/* 82251C90h case    9:*/		regs.LR = 0x82251C94; return 0x82157C08;
		/* 82251C90h case    9:*/		return 0x82251C94;
	}
	return 0x82251C94;
} // Block from 82251C6Ch-82251C94h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82251C94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251C94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251C94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251C94);
		  /* 82251C94h */ case    0:  		/* addi R11, R30, 228 */
		/* 82251C94h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xE4);
		/* 82251C94h case    0:*/		return 0x82251C98;
		  /* 82251C98h */ case    1:  		/* rlwinm R26, R11, 2, 0, 29 */
		/* 82251C98h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R26,regs.R11);
		/* 82251C98h case    1:*/		return 0x82251C9C;
		  /* 82251C9Ch */ case    2:  		/* lwzx R11, <#[R26 + R31]> */
		/* 82251C9Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + regs.R31 + 0x00000000) );
		/* 82251C9Ch case    2:*/		return 0x82251CA0;
		  /* 82251CA0h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82251CA0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82251CA0h case    3:*/		return 0x82251CA4;
		  /* 82251CA4h */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 82251CA4h case    4:*/		if ( regs.CR[6].eq ) { return 0x82251CC4;  }
		/* 82251CA4h case    4:*/		return 0x82251CA8;
		  /* 82251CA8h */ case    5:  		/* lis R11, -32252 */
		/* 82251CA8h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82251CA8h case    5:*/		return 0x82251CAC;
		  /* 82251CACh */ case    6:  		/* mr R6, R27 */
		/* 82251CACh case    6:*/		regs.R6 = regs.R27;
		/* 82251CACh case    6:*/		return 0x82251CB0;
		  /* 82251CB0h */ case    7:  		/* addi R5, R11, 17140 */
		/* 82251CB0h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x42F4);
		/* 82251CB0h case    7:*/		return 0x82251CB4;
		  /* 82251CB4h */ case    8:  		/* mr R4, R28 */
		/* 82251CB4h case    8:*/		regs.R4 = regs.R28;
		/* 82251CB4h case    8:*/		return 0x82251CB8;
		  /* 82251CB8h */ case    9:  		/* li R7, 515 */
		/* 82251CB8h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x203);
		/* 82251CB8h case    9:*/		return 0x82251CBC;
		  /* 82251CBCh */ case   10:  		/* li R3, 0 */
		/* 82251CBCh case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82251CBCh case   10:*/		return 0x82251CC0;
		  /* 82251CC0h */ case   11:  		/* bl -1024184 */
		/* 82251CC0h case   11:*/		regs.LR = 0x82251CC4; return 0x82157C08;
		/* 82251CC0h case   11:*/		return 0x82251CC4;
	}
	return 0x82251CC4;
} // Block from 82251C94h-82251CC4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82251CC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251CC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251CC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251CC4);
		  /* 82251CC4h */ case    0:  		/* addi R11, R30, 244 */
		/* 82251CC4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xF4);
		/* 82251CC4h case    0:*/		return 0x82251CC8;
		  /* 82251CC8h */ case    1:  		/* stwx R24, <#[R26 + R31]> */
		/* 82251CC8h case    1:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R26 + regs.R31 + 0x00000000) );
		/* 82251CC8h case    1:*/		return 0x82251CCC;
		  /* 82251CCCh */ case    2:  		/* addi R10, R30, 260 */
		/* 82251CCCh case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x104);
		/* 82251CCCh case    2:*/		return 0x82251CD0;
		  /* 82251CD0h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82251CD0h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82251CD0h case    3:*/		return 0x82251CD4;
		  /* 82251CD4h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82251CD4h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82251CD4h case    4:*/		return 0x82251CD8;
		  /* 82251CD8h */ case    5:  		/* cmpwi CR6, R29, 33 */
		/* 82251CD8h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000021);
		/* 82251CD8h case    5:*/		return 0x82251CDC;
		  /* 82251CDCh */ case    6:  		/* stwx R29, <#[R11 + R31]> */
		/* 82251CDCh case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82251CDCh case    6:*/		return 0x82251CE0;
	}
	return 0x82251CE0;
} // Block from 82251CC4h-82251CE0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82251CE0h
// Function '?Rewrite@IRInst@XGRAPHICS@@QAAXPAVCFG@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251CE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251CE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251CE0);
		  /* 82251CE0h */ case    0:  		/* stwx R25, <#[R10 + R31]> */
		/* 82251CE0h case    0:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 82251CE0h case    0:*/		return 0x82251CE4;
		  /* 82251CE4h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 82251CE4h case    1:*/		if ( regs.CR[6].eq ) { return 0x82251D14;  }
		/* 82251CE4h case    1:*/		return 0x82251CE8;
		  /* 82251CE8h */ case    2:  		/* li R10, 4 */
		/* 82251CE8h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 82251CE8h case    2:*/		return 0x82251CEC;
		  /* 82251CECh */ case    3:  		/* addi R9, R30, 69 */
		/* 82251CECh case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0x45);
		/* 82251CECh case    3:*/		return 0x82251CF0;
		  /* 82251CF0h */ case    4:  		/* li R11, 0 */
		/* 82251CF0h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82251CF0h case    4:*/		return 0x82251CF4;
		  /* 82251CF4h */ case    5:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82251CF4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82251CF4h case    5:*/		return 0x82251CF8;
		  /* 82251CF8h */ case    6:  		/* mtspr CTR, R10 */
		/* 82251CF8h case    6:*/		regs.CTR = regs.R10;
		/* 82251CF8h case    6:*/		return 0x82251CFC;
		  /* 82251CFCh */ case    7:  		/* add R10, R9, R11 */
		/* 82251CFCh case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R11);
		/* 82251CFCh case    7:*/		return 0x82251D00;
		  /* 82251D00h */ case    8:  		/* li R8, 5 */
		/* 82251D00h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x5);
		/* 82251D00h case    8:*/		return 0x82251D04;
		  /* 82251D04h */ case    9:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82251D04h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82251D04h case    9:*/		return 0x82251D08;
		  /* 82251D08h */ case   10:  		/* addi R11, R11, 1 */
		/* 82251D08h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82251D08h case   10:*/		return 0x82251D0C;
		  /* 82251D0Ch */ case   11:  		/* stwx R8, <#[R10 + R31]> */
		/* 82251D0Ch case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 82251D0Ch case   11:*/		return 0x82251D10;
		  /* 82251D10h */ case   12:  		/* bc 16, CR0_LT, -20 */
		/* 82251D10h case   12:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82251CFC;  }
		/* 82251D10h case   12:*/		return 0x82251D14;
	}
	return 0x82251D14;
} // Block from 82251CE0h-82251D14h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82251D14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251D14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251D14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251D14);
		  /* 82251D14h */ case    0:  		/* mr R3, R30 */
		/* 82251D14h case    0:*/		regs.R3 = regs.R30;
		/* 82251D14h case    0:*/		return 0x82251D18;
		  /* 82251D18h */ case    1:  		/* addi R1, R1, 160 */
		/* 82251D18h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82251D18h case    1:*/		return 0x82251D1C;
		  /* 82251D1Ch */ case    2:  		/* b -1837700 */
		/* 82251D1Ch case    2:*/		return 0x82091298;
		/* 82251D1Ch case    2:*/		return 0x82251D20;
	}
	return 0x82251D20;
} // Block from 82251D14h-82251D20h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82251D20h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251D20);
		  /* 82251D20h */ case    0:  		/* mfspr R12, LR */
		/* 82251D20h case    0:*/		regs.R12 = regs.LR;
		/* 82251D20h case    0:*/		return 0x82251D24;
		  /* 82251D24h */ case    1:  		/* bl -1837772 */
		/* 82251D24h case    1:*/		regs.LR = 0x82251D28; return 0x82091258;
		/* 82251D24h case    1:*/		return 0x82251D28;
		  /* 82251D28h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82251D28h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82251D28h case    2:*/		return 0x82251D2C;
		  /* 82251D2Ch */ case    3:  		/* lis R11, -32252 */
		/* 82251D2Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82251D2Ch case    3:*/		return 0x82251D30;
		  /* 82251D30h */ case    4:  		/* mr R28, R3 */
		/* 82251D30h case    4:*/		regs.R28 = regs.R3;
		/* 82251D30h case    4:*/		return 0x82251D34;
		  /* 82251D34h */ case    5:  		/* lwz R3, <#[R3 + 1876]> */
		/* 82251D34h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000754) );
		/* 82251D34h case    5:*/		return 0x82251D38;
		  /* 82251D38h */ case    6:  		/* addi R4, R11, 17204 */
		/* 82251D38h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x4334);
		/* 82251D38h case    6:*/		return 0x82251D3C;
		  /* 82251D3Ch */ case    7:  		/* bl -215420 */
		/* 82251D3Ch case    7:*/		regs.LR = 0x82251D40; return 0x8221D3C0;
		/* 82251D3Ch case    7:*/		return 0x82251D40;
		  /* 82251D40h */ case    8:  		/* li R29, 0 */
		/* 82251D40h case    8:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82251D40h case    8:*/		return 0x82251D44;
		  /* 82251D44h */ case    9:  		/* addi R30, R28, 912 */
		/* 82251D44h case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R28,0x390);
		/* 82251D44h case    9:*/		return 0x82251D48;
	}
	return 0x82251D48;
} // Block from 82251D20h-82251D48h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82251D48h
// Function '?EliminateDeadCode@CFG@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251D48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251D48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251D48);
		  /* 82251D48h */ case    0:  		/* addi R31, R28, 1616 */
		/* 82251D48h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R28,0x650);
		/* 82251D48h case    0:*/		return 0x82251D4C;
		  /* 82251D4Ch */ case    1:  		/* lwz R11, <#[R30]> */
		/* 82251D4Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82251D4Ch case    1:*/		return 0x82251D50;
		  /* 82251D50h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82251D50h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82251D50h case    2:*/		return 0x82251D54;
		  /* 82251D54h */ case    3:  		/* bc 12, CR6_EQ, 48 */
		/* 82251D54h case    3:*/		if ( regs.CR[6].eq ) { return 0x82251D84;  }
		/* 82251D54h case    3:*/		return 0x82251D58;
		  /* 82251D58h */ case    4:  		/* lwz R5, <#[R30 + 64]> */
		/* 82251D58h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000040) );
		/* 82251D58h case    4:*/		return 0x82251D5C;
		  /* 82251D5Ch */ case    5:  		/* cmpwi CR6, R5, 18 */
		/* 82251D5Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000012);
		/* 82251D5Ch case    5:*/		return 0x82251D60;
		  /* 82251D60h */ case    6:  		/* bc 12, CR6_EQ, 36 */
		/* 82251D60h case    6:*/		if ( regs.CR[6].eq ) { return 0x82251D84;  }
		/* 82251D60h case    6:*/		return 0x82251D64;
		  /* 82251D64h */ case    7:  		/* addi R10, R31, -512 */
		/* 82251D64h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFE00);
		/* 82251D64h case    7:*/		return 0x82251D68;
		  /* 82251D68h */ case    8:  		/* lwz R6, <#[R30 + 128]> */
		/* 82251D68h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000080) );
		/* 82251D68h case    8:*/		return 0x82251D6C;
		  /* 82251D6Ch */ case    9:  		/* mr R9, R31 */
		/* 82251D6Ch case    9:*/		regs.R9 = regs.R31;
		/* 82251D6Ch case    9:*/		return 0x82251D70;
		  /* 82251D70h */ case   10:  		/* lwz R7, <#[R11 + 48]> */
		/* 82251D70h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000030) );
		/* 82251D70h case   10:*/		return 0x82251D74;
		  /* 82251D74h */ case   11:  		/* addi R8, R31, -256 */
		/* 82251D74h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0xFFFFFF00);
		/* 82251D74h case   11:*/		return 0x82251D78;
		  /* 82251D78h */ case   12:  		/* lwz R3, <#[R28 + 1876]> */
		/* 82251D78h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000754) );
		/* 82251D78h case   12:*/		return 0x82251D7C;
		  /* 82251D7Ch */ case   13:  		/* mr R4, R29 */
		/* 82251D7Ch case   13:*/		regs.R4 = regs.R29;
		/* 82251D7Ch case   13:*/		return 0x82251D80;
		  /* 82251D80h */ case   14:  		/* bl -219672 */
		/* 82251D80h case   14:*/		regs.LR = 0x82251D84; return 0x8221C368;
		/* 82251D80h case   14:*/		return 0x82251D84;
	}
	return 0x82251D84;
} // Block from 82251D48h-82251D84h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82251D84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251D84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251D84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251D84);
		  /* 82251D84h */ case    0:  		/* addi R29, R29, 1 */
		/* 82251D84h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82251D84h case    0:*/		return 0x82251D88;
		  /* 82251D88h */ case    1:  		/* addi R31, R31, 16 */
		/* 82251D88h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x10);
		/* 82251D88h case    1:*/		return 0x82251D8C;
		  /* 82251D8Ch */ case    2:  		/* addi R30, R30, 4 */
		/* 82251D8Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82251D8Ch case    2:*/		return 0x82251D90;
		  /* 82251D90h */ case    3:  		/* cmpwi CR6, R29, 16 */
		/* 82251D90h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000010);
		/* 82251D90h case    3:*/		return 0x82251D94;
		  /* 82251D94h */ case    4:  		/* bc 12, CR6_LT, -72 */
		/* 82251D94h case    4:*/		if ( regs.CR[6].lt ) { return 0x82251D4C;  }
		/* 82251D94h case    4:*/		return 0x82251D98;
		  /* 82251D98h */ case    5:  		/* addi R1, R1, 128 */
		/* 82251D98h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82251D98h case    5:*/		return 0x82251D9C;
		  /* 82251D9Ch */ case    6:  		/* b -1837812 */
		/* 82251D9Ch case    6:*/		return 0x820912A8;
		/* 82251D9Ch case    6:*/		return 0x82251DA0;
	}
	return 0x82251DA0;
} // Block from 82251D84h-82251DA0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82251DA0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251DA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251DA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251DA0);
		  /* 82251DA0h */ case    0:  		/* mfspr R12, LR */
		/* 82251DA0h case    0:*/		regs.R12 = regs.LR;
		/* 82251DA0h case    0:*/		return 0x82251DA4;
		  /* 82251DA4h */ case    1:  		/* bl -1837944 */
		/* 82251DA4h case    1:*/		regs.LR = 0x82251DA8; return 0x8209122C;
		/* 82251DA4h case    1:*/		return 0x82251DA8;
		  /* 82251DA8h */ case    2:  		/* subfic R28, R3, -700 */
		/* 82251DA8h case    2:*/		cpu::op::subfic<0>(regs,&regs.R28,regs.R3,0xFFFFFD44);
		/* 82251DA8h case    2:*/		return 0x82251DAC;
		  /* 82251DACh */ case    3:  		/* subfic R27, R3, -944 */
		/* 82251DACh case    3:*/		cpu::op::subfic<0>(regs,&regs.R27,regs.R3,0xFFFFFC50);
		/* 82251DACh case    3:*/		return 0x82251DB0;
		  /* 82251DB0h */ case    4:  		/* subfic R26, R3, -636 */
		/* 82251DB0h case    4:*/		cpu::op::subfic<0>(regs,&regs.R26,regs.R3,0xFFFFFD84);
		/* 82251DB0h case    4:*/		return 0x82251DB4;
		  /* 82251DB4h */ case    5:  		/* subfic R25, R3, -880 */
		/* 82251DB4h case    5:*/		cpu::op::subfic<0>(regs,&regs.R25,regs.R3,0xFFFFFC90);
		/* 82251DB4h case    5:*/		return 0x82251DB8;
		  /* 82251DB8h */ case    6:  		/* subfic R24, R3, -572 */
		/* 82251DB8h case    6:*/		cpu::op::subfic<0>(regs,&regs.R24,regs.R3,0xFFFFFDC4);
		/* 82251DB8h case    6:*/		return 0x82251DBC;
		  /* 82251DBCh */ case    7:  		/* mr R9, R4 */
		/* 82251DBCh case    7:*/		regs.R9 = regs.R4;
		/* 82251DBCh case    7:*/		return 0x82251DC0;
		  /* 82251DC0h */ case    8:  		/* addi R11, R3, 976 */
		/* 82251DC0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x3D0);
		/* 82251DC0h case    8:*/		return 0x82251DC4;
		  /* 82251DC4h */ case    9:  		/* subfic R23, R3, -816 */
		/* 82251DC4h case    9:*/		cpu::op::subfic<0>(regs,&regs.R23,regs.R3,0xFFFFFCD0);
		/* 82251DC4h case    9:*/		return 0x82251DC8;
		  /* 82251DC8h */ case   10:  		/* li R22, 16 */
		/* 82251DC8h case   10:*/		cpu::op::li<0>(regs,&regs.R22,0x10);
		/* 82251DC8h case   10:*/		return 0x82251DCC;
		  /* 82251DCCh */ case   11:  		/* lwz R31, <#[R11 + 64]> */
		/* 82251DCCh case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000040) );
		/* 82251DCCh case   11:*/		return 0x82251DD0;
		  /* 82251DD0h */ case   12:  		/* li R8, 4 */
		/* 82251DD0h case   12:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 82251DD0h case   12:*/		return 0x82251DD4;
		  /* 82251DD4h */ case   13:  		/* li R10, 0 */
		/* 82251DD4h case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82251DD4h case   13:*/		return 0x82251DD8;
		  /* 82251DD8h */ case   14:  		/* add R7, R28, R11 */
		/* 82251DD8h case   14:*/		cpu::op::add<0>(regs,&regs.R7,regs.R28,regs.R11);
		/* 82251DD8h case   14:*/		return 0x82251DDC;
		  /* 82251DDCh */ case   15:  		/* add R6, R27, R11 */
		/* 82251DDCh case   15:*/		cpu::op::add<0>(regs,&regs.R6,regs.R27,regs.R11);
		/* 82251DDCh case   15:*/		return 0x82251DE0;
		  /* 82251DE0h */ case   16:  		/* add R5, R26, R11 */
		/* 82251DE0h case   16:*/		cpu::op::add<0>(regs,&regs.R5,regs.R26,regs.R11);
		/* 82251DE0h case   16:*/		return 0x82251DE4;
		  /* 82251DE4h */ case   17:  		/* stw R31, <#[R9 + 64]> */
		/* 82251DE4h case   17:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R9 + 0x00000040) );
		/* 82251DE4h case   17:*/		return 0x82251DE8;
		  /* 82251DE8h */ case   18:  		/* add R31, R25, R11 */
		/* 82251DE8h case   18:*/		cpu::op::add<0>(regs,&regs.R31,regs.R25,regs.R11);
		/* 82251DE8h case   18:*/		return 0x82251DEC;
		  /* 82251DECh */ case   19:  		/* lwz R29, <#[R11]> */
		/* 82251DECh case   19:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82251DECh case   19:*/		return 0x82251DF0;
		  /* 82251DF0h */ case   20:  		/* add R30, R24, R11 */
		/* 82251DF0h case   20:*/		cpu::op::add<0>(regs,&regs.R30,regs.R24,regs.R11);
		/* 82251DF0h case   20:*/		return 0x82251DF4;
		  /* 82251DF4h */ case   21:  		/* stw R29, <#[R9]> */
		/* 82251DF4h case   21:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R9 + 0x00000000) );
		/* 82251DF4h case   21:*/		return 0x82251DF8;
		  /* 82251DF8h */ case   22:  		/* add R29, R23, R11 */
		/* 82251DF8h case   22:*/		cpu::op::add<0>(regs,&regs.R29,regs.R23,regs.R11);
		/* 82251DF8h case   22:*/		return 0x82251DFC;
		  /* 82251DFCh */ case   23:  		/* mtspr CTR, R8 */
		/* 82251DFCh case   23:*/		regs.CTR = regs.R8;
		/* 82251DFCh case   23:*/		return 0x82251E00;
		  /* 82251E00h */ case   24:  		/* add R8, R7, R10 */
		/* 82251E00h case   24:*/		cpu::op::add<0>(regs,&regs.R8,regs.R7,regs.R10);
		/* 82251E00h case   24:*/		return 0x82251E04;
		  /* 82251E04h */ case   25:  		/* add R21, R6, R10 */
		/* 82251E04h case   25:*/		cpu::op::add<0>(regs,&regs.R21,regs.R6,regs.R10);
		/* 82251E04h case   25:*/		return 0x82251E08;
		  /* 82251E08h */ case   26:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82251E08h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82251E08h case   26:*/		return 0x82251E0C;
		  /* 82251E0Ch */ case   27:  		/* add R20, R5, R10 */
		/* 82251E0Ch case   27:*/		cpu::op::add<0>(regs,&regs.R20,regs.R5,regs.R10);
		/* 82251E0Ch case   27:*/		return 0x82251E10;
		  /* 82251E10h */ case   28:  		/* add R19, R31, R10 */
		/* 82251E10h case   28:*/		cpu::op::add<0>(regs,&regs.R19,regs.R31,regs.R10);
		/* 82251E10h case   28:*/		return 0x82251E14;
		  /* 82251E14h */ case   29:  		/* add R18, R30, R10 */
		/* 82251E14h case   29:*/		cpu::op::add<0>(regs,&regs.R18,regs.R30,regs.R10);
		/* 82251E14h case   29:*/		return 0x82251E18;
		  /* 82251E18h */ case   30:  		/* rlwinm R21, R21, 2, 0, 29 */
		/* 82251E18h case   30:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R21,regs.R21);
		/* 82251E18h case   30:*/		return 0x82251E1C;
		  /* 82251E1Ch */ case   31:  		/* lwzx R8, <#[R8 + R3]> */
		/* 82251E1Ch case   31:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 82251E1Ch case   31:*/		return 0x82251E20;
		  /* 82251E20h */ case   32:  		/* add R17, R29, R10 */
		/* 82251E20h case   32:*/		cpu::op::add<0>(regs,&regs.R17,regs.R29,regs.R10);
		/* 82251E20h case   32:*/		return 0x82251E24;
		  /* 82251E24h */ case   33:  		/* rlwinm R20, R20, 2, 0, 29 */
		/* 82251E24h case   33:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R20,regs.R20);
		/* 82251E24h case   33:*/		return 0x82251E28;
		  /* 82251E28h */ case   34:  		/* rlwinm R19, R19, 2, 0, 29 */
		/* 82251E28h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R19,regs.R19);
		/* 82251E28h case   34:*/		return 0x82251E2C;
		  /* 82251E2Ch */ case   35:  		/* rlwinm R18, R18, 2, 0, 29 */
		/* 82251E2Ch case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R18,regs.R18);
		/* 82251E2Ch case   35:*/		return 0x82251E30;
		  /* 82251E30h */ case   36:  		/* rlwinm R17, R17, 2, 0, 29 */
		/* 82251E30h case   36:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R17,regs.R17);
		/* 82251E30h case   36:*/		return 0x82251E34;
		  /* 82251E34h */ case   37:  		/* stwx R8, <#[R21 + R4]> */
		/* 82251E34h case   37:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R21 + regs.R4 + 0x00000000) );
		/* 82251E34h case   37:*/		return 0x82251E38;
		  /* 82251E38h */ case   38:  		/* addi R10, R10, 1 */
		/* 82251E38h case   38:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82251E38h case   38:*/		return 0x82251E3C;
		  /* 82251E3Ch */ case   39:  		/* lwzx R8, <#[R20 + R3]> */
		/* 82251E3Ch case   39:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R20 + regs.R3 + 0x00000000) );
		/* 82251E3Ch case   39:*/		return 0x82251E40;
		  /* 82251E40h */ case   40:  		/* stwx R8, <#[R19 + R4]> */
		/* 82251E40h case   40:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R19 + regs.R4 + 0x00000000) );
		/* 82251E40h case   40:*/		return 0x82251E44;
		  /* 82251E44h */ case   41:  		/* lwzx R8, <#[R18 + R3]> */
		/* 82251E44h case   41:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R18 + regs.R3 + 0x00000000) );
		/* 82251E44h case   41:*/		return 0x82251E48;
		  /* 82251E48h */ case   42:  		/* stwx R8, <#[R17 + R4]> */
		/* 82251E48h case   42:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R17 + regs.R4 + 0x00000000) );
		/* 82251E48h case   42:*/		return 0x82251E4C;
		  /* 82251E4Ch */ case   43:  		/* bc 16, CR0_LT, -76 */
		/* 82251E4Ch case   43:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82251E00;  }
		/* 82251E4Ch case   43:*/		return 0x82251E50;
		  /* 82251E50h */ case   44:  		/* addic. R22, R22, -1 */
		/* 82251E50h case   44:*/		cpu::op::addic<1>(regs,&regs.R22,regs.R22,0xFFFFFFFF);
		/* 82251E50h case   44:*/		return 0x82251E54;
		  /* 82251E54h */ case   45:  		/* addi R11, R11, 4 */
		/* 82251E54h case   45:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82251E54h case   45:*/		return 0x82251E58;
		  /* 82251E58h */ case   46:  		/* addi R9, R9, 4 */
		/* 82251E58h case   46:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82251E58h case   46:*/		return 0x82251E5C;
		  /* 82251E5Ch */ case   47:  		/* bc 4, CR0_EQ, -144 */
		/* 82251E5Ch case   47:*/		if ( !regs.CR[0].eq ) { return 0x82251DCC;  }
		/* 82251E5Ch case   47:*/		return 0x82251E60;
		  /* 82251E60h */ case   48:  		/* li R11, 1 */
		/* 82251E60h case   48:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82251E60h case   48:*/		return 0x82251E64;
		  /* 82251E64h */ case   49:  		/* stb R11, <#[R4 + 1872]> */
		/* 82251E64h case   49:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R4 + 0x00000750) );
		/* 82251E64h case   49:*/		return 0x82251E68;
		  /* 82251E68h */ case   50:  		/* b -1838060 */
		/* 82251E68h case   50:*/		return 0x8209127C;
		/* 82251E68h case   50:*/		return 0x82251E6C;
		  /* 82251E6Ch */ case   51:  		/* nop */
		/* 82251E6Ch case   51:*/		cpu::op::nop();
		/* 82251E6Ch case   51:*/		return 0x82251E70;
	}
	return 0x82251E70;
} // Block from 82251DA0h-82251E70h (52 instructions)

//////////////////////////////////////////////////////
// Block at 82251E70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251E70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251E70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251E70);
		  /* 82251E70h */ case    0:  		/* mfspr R12, LR */
		/* 82251E70h case    0:*/		regs.R12 = regs.LR;
		/* 82251E70h case    0:*/		return 0x82251E74;
		  /* 82251E74h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82251E74h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82251E74h case    1:*/		return 0x82251E78;
		  /* 82251E78h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82251E78h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82251E78h case    2:*/		return 0x82251E7C;
		  /* 82251E7Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82251E7Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82251E7Ch case    3:*/		return 0x82251E80;
		  /* 82251E80h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82251E80h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82251E80h case    4:*/		return 0x82251E84;
		  /* 82251E84h */ case    5:  		/* lbz R11, <#[R3 + 1872]> */
		/* 82251E84h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000750) );
		/* 82251E84h case    5:*/		return 0x82251E88;
		  /* 82251E88h */ case    6:  		/* mr R31, R3 */
		/* 82251E88h case    6:*/		regs.R31 = regs.R3;
		/* 82251E88h case    6:*/		return 0x82251E8C;
		  /* 82251E8Ch */ case    7:  		/* mr R30, R4 */
		/* 82251E8Ch case    7:*/		regs.R30 = regs.R4;
		/* 82251E8Ch case    7:*/		return 0x82251E90;
		  /* 82251E90h */ case    8:  		/* cmplwi CR0, R11, 0 */
		/* 82251E90h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82251E90h case    8:*/		return 0x82251E94;
		  /* 82251E94h */ case    9:  		/* bc 4, CR0_EQ, 40 */
		/* 82251E94h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82251EBC;  }
		/* 82251E94h case    9:*/		return 0x82251E98;
		  /* 82251E98h */ case   10:  		/* lis R11, -32252 */
		/* 82251E98h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82251E98h case   10:*/		return 0x82251E9C;
		  /* 82251E9Ch */ case   11:  		/* lis R10, -32252 */
		/* 82251E9Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82251E9Ch case   11:*/		return 0x82251EA0;
		  /* 82251EA0h */ case   12:  		/* lis R9, -32253 */
		/* 82251EA0h case   12:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82251EA0h case   12:*/		return 0x82251EA4;
		  /* 82251EA4h */ case   13:  		/* addi R6, R11, 17264 */
		/* 82251EA4h case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x4370);
		/* 82251EA4h case   13:*/		return 0x82251EA8;
		  /* 82251EA8h */ case   14:  		/* addi R5, R10, 17232 */
		/* 82251EA8h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x4350);
		/* 82251EA8h case   14:*/		return 0x82251EAC;
		  /* 82251EACh */ case   15:  		/* addi R4, R9, 27460 */
		/* 82251EACh case   15:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82251EACh case   15:*/		return 0x82251EB0;
		  /* 82251EB0h */ case   16:  		/* li R7, 107 */
		/* 82251EB0h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x6B);
		/* 82251EB0h case   16:*/		return 0x82251EB4;
		  /* 82251EB4h */ case   17:  		/* li R3, 0 */
		/* 82251EB4h case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82251EB4h case   17:*/		return 0x82251EB8;
		  /* 82251EB8h */ case   18:  		/* bl -1024688 */
		/* 82251EB8h case   18:*/		regs.LR = 0x82251EBC; return 0x82157C08;
		/* 82251EB8h case   18:*/		return 0x82251EBC;
	}
	return 0x82251EBC;
} // Block from 82251E70h-82251EBCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 82251EBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251EBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251EBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251EBC);
		  /* 82251EBCh */ case    0:  		/* addi R11, R30, 8 */
		/* 82251EBCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x8);
		/* 82251EBCh case    0:*/		return 0x82251EC0;
		  /* 82251EC0h */ case    1:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 82251EC0h case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 82251EC0h case    1:*/		return 0x82251EC4;
		  /* 82251EC4h */ case    2:  		/* lwzx R11, <#[R11 + R31]> */
		/* 82251EC4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82251EC4h case    2:*/		return 0x82251EC8;
		  /* 82251EC8h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 82251EC8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82251EC8h case    3:*/		return 0x82251ECC;
		  /* 82251ECCh */ case    4:  		/* bc 4, CR6_EQ, 52 */
		/* 82251ECCh case    4:*/		if ( !regs.CR[6].eq ) { return 0x82251F00;  }
		/* 82251ECCh case    4:*/		return 0x82251ED0;
		  /* 82251ED0h */ case    5:  		/* rlwinm R11, R30, 4, 0, 27 */
		/* 82251ED0h case    5:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R30);
		/* 82251ED0h case    5:*/		return 0x82251ED4;
		  /* 82251ED4h */ case    6:  		/* add R11, R11, R31 */
		/* 82251ED4h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82251ED4h case    6:*/		return 0x82251ED8;
		  /* 82251ED8h */ case    7:  		/* lwz R10, <#[R11 + 132]> */
		/* 82251ED8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000084) );
		/* 82251ED8h case    7:*/		return 0x82251EDC;
		  /* 82251EDCh */ case    8:  		/* cmpwi CR6, R10, 0 */
		/* 82251EDCh case    8:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82251EDCh case    8:*/		return 0x82251EE0;
		  /* 82251EE0h */ case    9:  		/* bc 4, CR6_EQ, 32 */
		/* 82251EE0h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82251F00;  }
		/* 82251EE0h case    9:*/		return 0x82251EE4;
		  /* 82251EE4h */ case   10:  		/* lwz R10, <#[R11 + 136]> */
		/* 82251EE4h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000088) );
		/* 82251EE4h case   10:*/		return 0x82251EE8;
		  /* 82251EE8h */ case   11:  		/* cmpwi CR6, R10, 0 */
		/* 82251EE8h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82251EE8h case   11:*/		return 0x82251EEC;
		  /* 82251EECh */ case   12:  		/* bc 4, CR6_EQ, 20 */
		/* 82251EECh case   12:*/		if ( !regs.CR[6].eq ) { return 0x82251F00;  }
		/* 82251EECh case   12:*/		return 0x82251EF0;
		  /* 82251EF0h */ case   13:  		/* lwz R11, <#[R11 + 140]> */
		/* 82251EF0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000008C) );
		/* 82251EF0h case   13:*/		return 0x82251EF4;
		  /* 82251EF4h */ case   14:  		/* cmpwi CR6, R11, 0 */
		/* 82251EF4h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82251EF4h case   14:*/		return 0x82251EF8;
		  /* 82251EF8h */ case   15:  		/* li R11, 0 */
		/* 82251EF8h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82251EF8h case   15:*/		return 0x82251EFC;
		  /* 82251EFCh */ case   16:  		/* bc 12, CR6_EQ, 8 */
		/* 82251EFCh case   16:*/		if ( regs.CR[6].eq ) { return 0x82251F04;  }
		/* 82251EFCh case   16:*/		return 0x82251F00;
	}
	return 0x82251F00;
} // Block from 82251EBCh-82251F00h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82251F00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251F00);
		  /* 82251F00h */ case    0:  		/* li R11, 1 */
		/* 82251F00h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82251F00h case    0:*/		return 0x82251F04;
	}
	return 0x82251F04;
} // Block from 82251F00h-82251F04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82251F04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251F04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251F04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251F04);
		  /* 82251F04h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 82251F04h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 82251F04h case    0:*/		return 0x82251F08;
		  /* 82251F08h */ case    1:  		/* addi R1, R1, 112 */
		/* 82251F08h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82251F08h case    1:*/		return 0x82251F0C;
		  /* 82251F0Ch */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82251F0Ch case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82251F0Ch case    2:*/		return 0x82251F10;
		  /* 82251F10h */ case    3:  		/* mtspr LR, R12 */
		/* 82251F10h case    3:*/		regs.LR = regs.R12;
		/* 82251F10h case    3:*/		return 0x82251F14;
		  /* 82251F14h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 82251F14h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82251F14h case    4:*/		return 0x82251F18;
		  /* 82251F18h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 82251F18h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82251F18h case    5:*/		return 0x82251F1C;
		  /* 82251F1Ch */ case    6:  		/* bclr 20, CR0_LT */
		/* 82251F1Ch case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82251F1Ch case    6:*/		return 0x82251F20;
	}
	return 0x82251F20;
} // Block from 82251F04h-82251F20h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82251F20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251F20);
		  /* 82251F20h */ case    0:  		/* mfspr R12, LR */
		/* 82251F20h case    0:*/		regs.R12 = regs.LR;
		/* 82251F20h case    0:*/		return 0x82251F24;
		  /* 82251F24h */ case    1:  		/* bl -1838288 */
		/* 82251F24h case    1:*/		regs.LR = 0x82251F28; return 0x82091254;
		/* 82251F24h case    1:*/		return 0x82251F28;
		  /* 82251F28h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82251F28h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82251F28h case    2:*/		return 0x82251F2C;
		  /* 82251F2Ch */ case    3:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 82251F2Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 82251F2Ch case    3:*/		return 0x82251F30;
		  /* 82251F30h */ case    4:  		/* mr R11, R3 */
		/* 82251F30h case    4:*/		regs.R11 = regs.R3;
		/* 82251F30h case    4:*/		return 0x82251F34;
		  /* 82251F34h */ case    5:  		/* subfic R28, R3, -700 */
		/* 82251F34h case    5:*/		cpu::op::subfic<0>(regs,&regs.R28,regs.R3,0xFFFFFD44);
		/* 82251F34h case    5:*/		return 0x82251F38;
		  /* 82251F38h */ case    6:  		/* subfic R30, R3, -636 */
		/* 82251F38h case    6:*/		cpu::op::subfic<0>(regs,&regs.R30,regs.R3,0xFFFFFD84);
		/* 82251F38h case    6:*/		return 0x82251F3C;
		  /* 82251F3Ch */ case    7:  		/* addi R9, R11, 976 */
		/* 82251F3Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x3D0);
		/* 82251F3Ch case    7:*/		return 0x82251F40;
		  /* 82251F40h */ case    8:  		/* lwzx R27, <#[R10 + R3]> */
		/* 82251F40h case    8:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 82251F40h case    8:*/		return 0x82251F44;
		  /* 82251F44h */ case    9:  		/* li R3, 0 */
		/* 82251F44h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82251F44h case    9:*/		return 0x82251F48;
		  /* 82251F48h */ case   10:  		/* subfic R29, R11, -572 */
		/* 82251F48h case   10:*/		cpu::op::subfic<0>(regs,&regs.R29,regs.R11,0xFFFFFDC4);
		/* 82251F48h case   10:*/		return 0x82251F4C;
		  /* 82251F4Ch */ case   11:  		/* lwz R10, <#[R9]> */
		/* 82251F4Ch case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 82251F4Ch case   11:*/		return 0x82251F50;
		  /* 82251F50h */ case   12:  		/* cmpw CR6, R10, R27 */
		/* 82251F50h case   12:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R27);
		/* 82251F50h case   12:*/		return 0x82251F54;
		  /* 82251F54h */ case   13:  		/* bc 4, CR6_EQ, 228 */
		/* 82251F54h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82252038;  }
		/* 82251F54h case   13:*/		return 0x82251F58;
		  /* 82251F58h */ case   14:  		/* cmpwi CR6, R10, 33 */
		/* 82251F58h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000021);
		/* 82251F58h case   14:*/		return 0x82251F5C;
		  /* 82251F5Ch */ case   15:  		/* bc 12, CR6_EQ, 32 */
		/* 82251F5Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x82251F7C;  }
		/* 82251F5Ch case   15:*/		return 0x82251F60;
		  /* 82251F60h */ case   16:  		/* addi R10, R4, 16 */
		/* 82251F60h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x10);
		/* 82251F60h case   16:*/		return 0x82251F64;
		  /* 82251F64h */ case   17:  		/* lwz R8, <#[R9 + 64]> */
		/* 82251F64h case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000040) );
		/* 82251F64h case   17:*/		return 0x82251F68;
		  /* 82251F68h */ case   18:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82251F68h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82251F68h case   18:*/		return 0x82251F6C;
		  /* 82251F6Ch */ case   19:  		/* lwzx R10, <#[R10 + R11]> */
		/* 82251F6Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82251F6Ch case   19:*/		return 0x82251F70;
		  /* 82251F70h */ case   20:  		/* cmpw CR6, R8, R10 */
		/* 82251F70h case   20:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R10);
		/* 82251F70h case   20:*/		return 0x82251F74;
		  /* 82251F74h */ case   21:  		/* bc 12, CR6_EQ, 216 */
		/* 82251F74h case   21:*/		if ( regs.CR[6].eq ) { return 0x8225204C;  }
		/* 82251F74h case   21:*/		return 0x82251F78;
		  /* 82251F78h */ case   22:  		/* b 192 */
		/* 82251F78h case   22:*/		return 0x82252038;
		/* 82251F78h case   22:*/		return 0x82251F7C;
	}
	return 0x82251F7C;
} // Block from 82251F20h-82251F7Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 82251F7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82251F7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82251F7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82251F7C);
		  /* 82251F7Ch */ case    0:  		/* li R8, 4 */
		/* 82251F7Ch case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 82251F7Ch case    0:*/		return 0x82251F80;
		  /* 82251F80h */ case    1:  		/* addi R7, R4, 8 */
		/* 82251F80h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R4,0x8);
		/* 82251F80h case    1:*/		return 0x82251F84;
		  /* 82251F84h */ case    2:  		/* li R31, 0 */
		/* 82251F84h case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82251F84h case    2:*/		return 0x82251F88;
		  /* 82251F88h */ case    3:  		/* li R5, 0 */
		/* 82251F88h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82251F88h case    3:*/		return 0x82251F8C;
		  /* 82251F8Ch */ case    4:  		/* li R10, 0 */
		/* 82251F8Ch case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82251F8Ch case    4:*/		return 0x82251F90;
		  /* 82251F90h */ case    5:  		/* rlwinm R6, R7, 2, 0, 29 */
		/* 82251F90h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R7);
		/* 82251F90h case    5:*/		return 0x82251F94;
		  /* 82251F94h */ case    6:  		/* mtspr CTR, R8 */
		/* 82251F94h case    6:*/		regs.CTR = regs.R8;
		/* 82251F94h case    6:*/		return 0x82251F98;
		  /* 82251F98h */ case    7:  		/* add R8, R6, R10 */
		/* 82251F98h case    7:*/		cpu::op::add<0>(regs,&regs.R8,regs.R6,regs.R10);
		/* 82251F98h case    7:*/		return 0x82251F9C;
		  /* 82251F9Ch */ case    8:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82251F9Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82251F9Ch case    8:*/		return 0x82251FA0;
		  /* 82251FA0h */ case    9:  		/* lwzx R8, <#[R8 + R11]> */
		/* 82251FA0h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82251FA0h case    9:*/		return 0x82251FA4;
		  /* 82251FA4h */ case   10:  		/* cmpwi CR6, R8, 0 */
		/* 82251FA4h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 82251FA4h case   10:*/		return 0x82251FA8;
		  /* 82251FA8h */ case   11:  		/* bc 12, CR6_EQ, 128 */
		/* 82251FA8h case   11:*/		if ( regs.CR[6].eq ) { return 0x82252028;  }
		/* 82251FA8h case   11:*/		return 0x82251FAC;
		  /* 82251FACh */ case   12:  		/* add R8, R28, R9 */
		/* 82251FACh case   12:*/		cpu::op::add<0>(regs,&regs.R8,regs.R28,regs.R9);
		/* 82251FACh case   12:*/		return 0x82251FB0;
		  /* 82251FB0h */ case   13:  		/* add R8, R8, R10 */
		/* 82251FB0h case   13:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R10);
		/* 82251FB0h case   13:*/		return 0x82251FB4;
		  /* 82251FB4h */ case   14:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82251FB4h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82251FB4h case   14:*/		return 0x82251FB8;
		  /* 82251FB8h */ case   15:  		/* lwzx R8, <#[R8 + R11]> */
		/* 82251FB8h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82251FB8h case   15:*/		return 0x82251FBC;
		  /* 82251FBCh */ case   16:  		/* cmpwi CR6, R8, 0 */
		/* 82251FBCh case   16:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 82251FBCh case   16:*/		return 0x82251FC0;
		  /* 82251FC0h */ case   17:  		/* bc 12, CR6_EQ, 104 */
		/* 82251FC0h case   17:*/		if ( regs.CR[6].eq ) { return 0x82252028;  }
		/* 82251FC0h case   17:*/		return 0x82251FC4;
		  /* 82251FC4h */ case   18:  		/* addi R8, R4, 24 */
		/* 82251FC4h case   18:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R4,0x18);
		/* 82251FC4h case   18:*/		return 0x82251FC8;
		  /* 82251FC8h */ case   19:  		/* add R7, R30, R9 */
		/* 82251FC8h case   19:*/		cpu::op::add<0>(regs,&regs.R7,regs.R30,regs.R9);
		/* 82251FC8h case   19:*/		return 0x82251FCC;
		  /* 82251FCCh */ case   20:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82251FCCh case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82251FCCh case   20:*/		return 0x82251FD0;
		  /* 82251FD0h */ case   21:  		/* add R7, R7, R10 */
		/* 82251FD0h case   21:*/		cpu::op::add<0>(regs,&regs.R7,regs.R7,regs.R10);
		/* 82251FD0h case   21:*/		return 0x82251FD4;
		  /* 82251FD4h */ case   22:  		/* add R8, R8, R10 */
		/* 82251FD4h case   22:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R10);
		/* 82251FD4h case   22:*/		return 0x82251FD8;
		  /* 82251FD8h */ case   23:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82251FD8h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82251FD8h case   23:*/		return 0x82251FDC;
		  /* 82251FDCh */ case   24:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82251FDCh case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82251FDCh case   24:*/		return 0x82251FE0;
		  /* 82251FE0h */ case   25:  		/* lwzx R7, <#[R7 + R11]> */
		/* 82251FE0h case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 82251FE0h case   25:*/		return 0x82251FE4;
		  /* 82251FE4h */ case   26:  		/* lwzx R8, <#[R8 + R11]> */
		/* 82251FE4h case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82251FE4h case   26:*/		return 0x82251FE8;
		  /* 82251FE8h */ case   27:  		/* cmpw CR6, R8, R7 */
		/* 82251FE8h case   27:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R7);
		/* 82251FE8h case   27:*/		return 0x82251FEC;
		  /* 82251FECh */ case   28:  		/* bc 4, CR6_EQ, 56 */
		/* 82251FECh case   28:*/		if ( !regs.CR[6].eq ) { return 0x82252024;  }
		/* 82251FECh case   28:*/		return 0x82251FF0;
		  /* 82251FF0h */ case   29:  		/* addi R8, R4, 40 */
		/* 82251FF0h case   29:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R4,0x28);
		/* 82251FF0h case   29:*/		return 0x82251FF4;
		  /* 82251FF4h */ case   30:  		/* add R7, R29, R9 */
		/* 82251FF4h case   30:*/		cpu::op::add<0>(regs,&regs.R7,regs.R29,regs.R9);
		/* 82251FF4h case   30:*/		return 0x82251FF8;
		  /* 82251FF8h */ case   31:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82251FF8h case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82251FF8h case   31:*/		return 0x82251FFC;
		  /* 82251FFCh */ case   32:  		/* add R7, R7, R10 */
		/* 82251FFCh case   32:*/		cpu::op::add<0>(regs,&regs.R7,regs.R7,regs.R10);
		/* 82251FFCh case   32:*/		return 0x82252000;
		  /* 82252000h */ case   33:  		/* add R8, R8, R10 */
		/* 82252000h case   33:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R10);
		/* 82252000h case   33:*/		return 0x82252004;
		  /* 82252004h */ case   34:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82252004h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82252004h case   34:*/		return 0x82252008;
		  /* 82252008h */ case   35:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82252008h case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82252008h case   35:*/		return 0x8225200C;
		  /* 8225200Ch */ case   36:  		/* lwzx R7, <#[R7 + R11]> */
		/* 8225200Ch case   36:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 8225200Ch case   36:*/		return 0x82252010;
		  /* 82252010h */ case   37:  		/* lwzx R8, <#[R8 + R11]> */
		/* 82252010h case   37:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82252010h case   37:*/		return 0x82252014;
		  /* 82252014h */ case   38:  		/* cmpw CR6, R8, R7 */
		/* 82252014h case   38:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R7);
		/* 82252014h case   38:*/		return 0x82252018;
		  /* 82252018h */ case   39:  		/* bc 4, CR6_EQ, 12 */
		/* 82252018h case   39:*/		if ( !regs.CR[6].eq ) { return 0x82252024;  }
		/* 82252018h case   39:*/		return 0x8225201C;
		  /* 8225201Ch */ case   40:  		/* addi R5, R5, 1 */
		/* 8225201Ch case   40:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 8225201Ch case   40:*/		return 0x82252020;
		  /* 82252020h */ case   41:  		/* b 8 */
		/* 82252020h case   41:*/		return 0x82252028;
		/* 82252020h case   41:*/		return 0x82252024;
	}
	return 0x82252024;
} // Block from 82251F7Ch-82252024h (42 instructions)

//////////////////////////////////////////////////////
// Block at 82252024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252024);
		  /* 82252024h */ case    0:  		/* addi R31, R31, 1 */
		/* 82252024h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82252024h case    0:*/		return 0x82252028;
	}
	return 0x82252028;
} // Block from 82252024h-82252028h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82252028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252028);
		  /* 82252028h */ case    0:  		/* addi R10, R10, 1 */
		/* 82252028h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82252028h case    0:*/		return 0x8225202C;
		  /* 8225202Ch */ case    1:  		/* bc 16, CR0_LT, -148 */
		/* 8225202Ch case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82251F98;  }
		/* 8225202Ch case    1:*/		return 0x82252030;
		  /* 82252030h */ case    2:  		/* cmpwi CR6, R5, 0 */
		/* 82252030h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 82252030h case    2:*/		return 0x82252034;
		  /* 82252034h */ case    3:  		/* bc 12, CR6_GT, 32 */
		/* 82252034h case    3:*/		if ( regs.CR[6].gt ) { return 0x82252054;  }
		/* 82252034h case    3:*/		return 0x82252038;
	}
	return 0x82252038;
} // Block from 82252028h-82252038h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82252038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252038);
		  /* 82252038h */ case    0:  		/* addi R3, R3, 1 */
		/* 82252038h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 82252038h case    0:*/		return 0x8225203C;
		  /* 8225203Ch */ case    1:  		/* addi R9, R9, 4 */
		/* 8225203Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8225203Ch case    1:*/		return 0x82252040;
		  /* 82252040h */ case    2:  		/* cmpwi CR6, R3, 16 */
		/* 82252040h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000010);
		/* 82252040h case    2:*/		return 0x82252044;
		  /* 82252044h */ case    3:  		/* bc 12, CR6_LT, -248 */
		/* 82252044h case    3:*/		if ( regs.CR[6].lt ) { return 0x82251F4C;  }
		/* 82252044h case    3:*/		return 0x82252048;
		  /* 82252048h */ case    4:  		/* li R3, -1 */
		/* 82252048h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82252048h case    4:*/		return 0x8225204C;
	}
	return 0x8225204C;
} // Block from 82252038h-8225204Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225204Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225204C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225204C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225204C);
		  /* 8225204Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 8225204Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8225204Ch case    0:*/		return 0x82252050;
		  /* 82252050h */ case    1:  		/* b -1838508 */
		/* 82252050h case    1:*/		return 0x820912A4;
		/* 82252050h case    1:*/		return 0x82252054;
	}
	return 0x82252054;
} // Block from 8225204Ch-82252054h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252054h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252054( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252054) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252054);
		  /* 82252054h */ case    0:  		/* cmpwi CR6, R31, 0 */
		/* 82252054h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82252054h case    0:*/		return 0x82252058;
		  /* 82252058h */ case    1:  		/* bc 4, CR6_GT, -12 */
		/* 82252058h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8225204C;  }
		/* 82252058h case    1:*/		return 0x8225205C;
		  /* 8225205Ch */ case    2:  		/* lwz R11, <#[R11 + 1876]> */
		/* 8225205Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000754) );
		/* 8225205Ch case    2:*/		return 0x82252060;
		  /* 82252060h */ case    3:  		/* li R10, 24 */
		/* 82252060h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x18);
		/* 82252060h case    3:*/		return 0x82252064;
		  /* 82252064h */ case    4:  		/* li R4, 1 */
		/* 82252064h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82252064h case    4:*/		return 0x82252068;
		  /* 82252068h */ case    5:  		/* addi R3, R11, 16 */
		/* 82252068h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 82252068h case    5:*/		return 0x8225206C;
		  /* 8225206Ch */ case    6:  		/* stw R10, <#[R11 + 1364]> */
		/* 8225206Ch case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000554) );
		/* 8225206Ch case    6:*/		return 0x82252070;
		  /* 82252070h */ case    7:  		/* bl 93760 */
		/* 82252070h case    7:*/		regs.LR = 0x82252074; return 0x82268EB0;
		/* 82252070h case    7:*/		return 0x82252074;
		  /* 82252074h */ case    8:  		/* nop */
		/* 82252074h case    8:*/		cpu::op::nop();
		/* 82252074h case    8:*/		return 0x82252078;
	}
	return 0x82252078;
} // Block from 82252054h-82252078h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82252078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252078);
		  /* 82252078h */ case    0:  		/* mfspr R12, LR */
		/* 82252078h case    0:*/		regs.R12 = regs.LR;
		/* 82252078h case    0:*/		return 0x8225207C;
		  /* 8225207Ch */ case    1:  		/* bl -1838628 */
		/* 8225207Ch case    1:*/		regs.LR = 0x82252080; return 0x82091258;
		/* 8225207Ch case    1:*/		return 0x82252080;
		  /* 82252080h */ case    2:  		/* add R11, R5, R3 */
		/* 82252080h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R5,regs.R3);
		/* 82252080h case    2:*/		return 0x82252084;
		  /* 82252084h */ case    3:  		/* lbz R11, <#[R11 + 896]> */
		/* 82252084h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000380) );
		/* 82252084h case    3:*/		return 0x82252088;
	}
	return 0x82252088;
} // Block from 82252078h-82252088h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82252088h
// Function '?Rewrite@CFG@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252088);
		  /* 82252088h */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 82252088h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82252088h case    0:*/		return 0x8225208C;
		  /* 8225208Ch */ case    1:  		/* bc 4, CR0_EQ, 452 */
		/* 8225208Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x82252250;  }
		/* 8225208Ch case    1:*/		return 0x82252090;
		  /* 82252090h */ case    2:  		/* add R11, R6, R3 */
		/* 82252090h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R6,regs.R3);
		/* 82252090h case    2:*/		return 0x82252094;
		  /* 82252094h */ case    3:  		/* lbz R11, <#[R11 + 896]> */
		/* 82252094h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000380) );
		/* 82252094h case    3:*/		return 0x82252098;
		  /* 82252098h */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 82252098h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82252098h case    4:*/		return 0x8225209C;
		  /* 8225209Ch */ case    5:  		/* bc 4, CR0_EQ, 436 */
		/* 8225209Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x82252250;  }
		/* 8225209Ch case    5:*/		return 0x822520A0;
		  /* 822520A0h */ case    6:  		/* addi R11, R5, 244 */
		/* 822520A0h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0xF4);
		/* 822520A0h case    6:*/		return 0x822520A4;
		  /* 822520A4h */ case    7:  		/* addi R10, R6, 244 */
		/* 822520A4h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0xF4);
		/* 822520A4h case    7:*/		return 0x822520A8;
		  /* 822520A8h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822520A8h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822520A8h case    8:*/		return 0x822520AC;
		  /* 822520ACh */ case    9:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 822520ACh case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 822520ACh case    9:*/		return 0x822520B0;
		  /* 822520B0h */ case   10:  		/* addi R9, R6, 260 */
		/* 822520B0h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R6,0x104);
		/* 822520B0h case   10:*/		return 0x822520B4;
		  /* 822520B4h */ case   11:  		/* addi R8, R5, 260 */
		/* 822520B4h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R5,0x104);
		/* 822520B4h case   11:*/		return 0x822520B8;
		  /* 822520B8h */ case   12:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 822520B8h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 822520B8h case   12:*/		return 0x822520BC;
		  /* 822520BCh */ case   13:  		/* lwzx R31, <#[R11 + R3]> */
		/* 822520BCh case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 822520BCh case   13:*/		return 0x822520C0;
		  /* 822520C0h */ case   14:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 822520C0h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 822520C0h case   14:*/		return 0x822520C4;
		  /* 822520C4h */ case   15:  		/* lwzx R30, <#[R10 + R3]> */
		/* 822520C4h case   15:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 822520C4h case   15:*/		return 0x822520C8;
		  /* 822520C8h */ case   16:  		/* addi R29, R6, 69 */
		/* 822520C8h case   16:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R6,0x45);
		/* 822520C8h case   16:*/		return 0x822520CC;
		  /* 822520CCh */ case   17:  		/* li R7, 4 */
		/* 822520CCh case   17:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 822520CCh case   17:*/		return 0x822520D0;
		  /* 822520D0h */ case   18:  		/* addi R28, R5, 69 */
		/* 822520D0h case   18:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R5,0x45);
		/* 822520D0h case   18:*/		return 0x822520D4;
		  /* 822520D4h */ case   19:  		/* stwx R31, <#[R10 + R3]> */
		/* 822520D4h case   19:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 822520D4h case   19:*/		return 0x822520D8;
		  /* 822520D8h */ case   20:  		/* rlwinm R10, R29, 2, 0, 29 */
		/* 822520D8h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R29);
		/* 822520D8h case   20:*/		return 0x822520DC;
		  /* 822520DCh */ case   21:  		/* stwx R30, <#[R11 + R3]> */
		/* 822520DCh case   21:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 822520DCh case   21:*/		return 0x822520E0;
		  /* 822520E0h */ case   22:  		/* li R11, 0 */
		/* 822520E0h case   22:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822520E0h case   22:*/		return 0x822520E4;
		  /* 822520E4h */ case   23:  		/* lwzx R30, <#[R9 + R3]> */
		/* 822520E4h case   23:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 822520E4h case   23:*/		return 0x822520E8;
		  /* 822520E8h */ case   24:  		/* rlwinm R31, R28, 2, 0, 29 */
		/* 822520E8h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R28);
		/* 822520E8h case   24:*/		return 0x822520EC;
		  /* 822520ECh */ case   25:  		/* lwzx R29, <#[R8 + R3]> */
		/* 822520ECh case   25:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 822520ECh case   25:*/		return 0x822520F0;
		  /* 822520F0h */ case   26:  		/* mtspr CTR, R7 */
		/* 822520F0h case   26:*/		regs.CTR = regs.R7;
		/* 822520F0h case   26:*/		return 0x822520F4;
		  /* 822520F4h */ case   27:  		/* stwx R29, <#[R9 + R3]> */
		/* 822520F4h case   27:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 822520F4h case   27:*/		return 0x822520F8;
		  /* 822520F8h */ case   28:  		/* stwx R30, <#[R8 + R3]> */
		/* 822520F8h case   28:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 822520F8h case   28:*/		return 0x822520FC;
		  /* 822520FCh */ case   29:  		/* add R9, R31, R11 */
		/* 822520FCh case   29:*/		cpu::op::add<0>(regs,&regs.R9,regs.R31,regs.R11);
		/* 822520FCh case   29:*/		return 0x82252100;
		  /* 82252100h */ case   30:  		/* add R8, R10, R11 */
		/* 82252100h case   30:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R11);
		/* 82252100h case   30:*/		return 0x82252104;
		  /* 82252104h */ case   31:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82252104h case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82252104h case   31:*/		return 0x82252108;
		  /* 82252108h */ case   32:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82252108h case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82252108h case   32:*/		return 0x8225210C;
		  /* 8225210Ch */ case   33:  		/* addi R11, R11, 1 */
		/* 8225210Ch case   33:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8225210Ch case   33:*/		return 0x82252110;
		  /* 82252110h */ case   34:  		/* lwzx R7, <#[R9 + R3]> */
		/* 82252110h case   34:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 82252110h case   34:*/		return 0x82252114;
		  /* 82252114h */ case   35:  		/* lwzx R30, <#[R8 + R3]> */
		/* 82252114h case   35:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 82252114h case   35:*/		return 0x82252118;
		  /* 82252118h */ case   36:  		/* stwx R7, <#[R8 + R3]> */
		/* 82252118h case   36:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 82252118h case   36:*/		return 0x8225211C;
		  /* 8225211Ch */ case   37:  		/* stwx R30, <#[R9 + R3]> */
		/* 8225211Ch case   37:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8225211Ch case   37:*/		return 0x82252120;
		  /* 82252120h */ case   38:  		/* bc 16, CR0_LT, -36 */
		/* 82252120h case   38:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x822520FC;  }
		/* 82252120h case   38:*/		return 0x82252124;
		  /* 82252124h */ case   39:  		/* li R10, 4 */
		/* 82252124h case   39:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 82252124h case   39:*/		return 0x82252128;
		  /* 82252128h */ case   40:  		/* addi R9, R6, 85 */
		/* 82252128h case   40:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R6,0x55);
		/* 82252128h case   40:*/		return 0x8225212C;
		  /* 8225212Ch */ case   41:  		/* addi R7, R5, 85 */
		/* 8225212Ch case   41:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R5,0x55);
		/* 8225212Ch case   41:*/		return 0x82252130;
		  /* 82252130h */ case   42:  		/* li R11, 0 */
		/* 82252130h case   42:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82252130h case   42:*/		return 0x82252134;
		  /* 82252134h */ case   43:  		/* rlwinm R8, R9, 2, 0, 29 */
		/* 82252134h case   43:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R9);
		/* 82252134h case   43:*/		return 0x82252138;
		  /* 82252138h */ case   44:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82252138h case   44:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82252138h case   44:*/		return 0x8225213C;
		  /* 8225213Ch */ case   45:  		/* mtspr CTR, R10 */
		/* 8225213Ch case   45:*/		regs.CTR = regs.R10;
		/* 8225213Ch case   45:*/		return 0x82252140;
		  /* 82252140h */ case   46:  		/* add R10, R7, R11 */
		/* 82252140h case   46:*/		cpu::op::add<0>(regs,&regs.R10,regs.R7,regs.R11);
		/* 82252140h case   46:*/		return 0x82252144;
		  /* 82252144h */ case   47:  		/* add R31, R8, R11 */
		/* 82252144h case   47:*/		cpu::op::add<0>(regs,&regs.R31,regs.R8,regs.R11);
		/* 82252144h case   47:*/		return 0x82252148;
		  /* 82252148h */ case   48:  		/* rlwinm R9, R10, 2, 0, 29 */
		/* 82252148h case   48:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R10);
		/* 82252148h case   48:*/		return 0x8225214C;
		  /* 8225214Ch */ case   49:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 8225214Ch case   49:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 8225214Ch case   49:*/		return 0x82252150;
		  /* 82252150h */ case   50:  		/* addi R11, R11, 1 */
		/* 82252150h case   50:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82252150h case   50:*/		return 0x82252154;
		  /* 82252154h */ case   51:  		/* lwzx R31, <#[R9 + R3]> */
		/* 82252154h case   51:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 82252154h case   51:*/		return 0x82252158;
		  /* 82252158h */ case   52:  		/* lwzx R30, <#[R10 + R3]> */
		/* 82252158h case   52:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 82252158h case   52:*/		return 0x8225215C;
		  /* 8225215Ch */ case   53:  		/* stwx R31, <#[R10 + R3]> */
		/* 8225215Ch case   53:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 8225215Ch case   53:*/		return 0x82252160;
		  /* 82252160h */ case   54:  		/* stwx R30, <#[R9 + R3]> */
		/* 82252160h case   54:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 82252160h case   54:*/		return 0x82252164;
		  /* 82252164h */ case   55:  		/* bc 16, CR0_LT, -36 */
		/* 82252164h case   55:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82252140;  }
		/* 82252164h case   55:*/		return 0x82252168;
		  /* 82252168h */ case   56:  		/* li R10, 4 */
		/* 82252168h case   56:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 82252168h case   56:*/		return 0x8225216C;
		  /* 8225216Ch */ case   57:  		/* addi R9, R6, 101 */
		/* 8225216Ch case   57:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R6,0x65);
		/* 8225216Ch case   57:*/		return 0x82252170;
		  /* 82252170h */ case   58:  		/* addi R7, R5, 101 */
		/* 82252170h case   58:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R5,0x65);
		/* 82252170h case   58:*/		return 0x82252174;
		  /* 82252174h */ case   59:  		/* li R11, 0 */
		/* 82252174h case   59:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82252174h case   59:*/		return 0x82252178;
		  /* 82252178h */ case   60:  		/* rlwinm R8, R9, 2, 0, 29 */
		/* 82252178h case   60:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R9);
		/* 82252178h case   60:*/		return 0x8225217C;
		  /* 8225217Ch */ case   61:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 8225217Ch case   61:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 8225217Ch case   61:*/		return 0x82252180;
		  /* 82252180h */ case   62:  		/* mtspr CTR, R10 */
		/* 82252180h case   62:*/		regs.CTR = regs.R10;
		/* 82252180h case   62:*/		return 0x82252184;
		  /* 82252184h */ case   63:  		/* add R10, R7, R11 */
		/* 82252184h case   63:*/		cpu::op::add<0>(regs,&regs.R10,regs.R7,regs.R11);
		/* 82252184h case   63:*/		return 0x82252188;
		  /* 82252188h */ case   64:  		/* add R31, R8, R11 */
		/* 82252188h case   64:*/		cpu::op::add<0>(regs,&regs.R31,regs.R8,regs.R11);
		/* 82252188h case   64:*/		return 0x8225218C;
		  /* 8225218Ch */ case   65:  		/* rlwinm R9, R10, 2, 0, 29 */
		/* 8225218Ch case   65:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R10);
		/* 8225218Ch case   65:*/		return 0x82252190;
		  /* 82252190h */ case   66:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82252190h case   66:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82252190h case   66:*/		return 0x82252194;
		  /* 82252194h */ case   67:  		/* addi R11, R11, 1 */
		/* 82252194h case   67:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82252194h case   67:*/		return 0x82252198;
		  /* 82252198h */ case   68:  		/* lwzx R31, <#[R9 + R3]> */
		/* 82252198h case   68:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 82252198h case   68:*/		return 0x8225219C;
		  /* 8225219Ch */ case   69:  		/* lwzx R30, <#[R10 + R3]> */
		/* 8225219Ch case   69:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 8225219Ch case   69:*/		return 0x822521A0;
		  /* 822521A0h */ case   70:  		/* stwx R31, <#[R10 + R3]> */
		/* 822521A0h case   70:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 822521A0h case   70:*/		return 0x822521A4;
		  /* 822521A4h */ case   71:  		/* stwx R30, <#[R9 + R3]> */
		/* 822521A4h case   71:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 822521A4h case   71:*/		return 0x822521A8;
		  /* 822521A8h */ case   72:  		/* bc 16, CR0_LT, -36 */
		/* 822521A8h case   72:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82252184;  }
		/* 822521A8h case   72:*/		return 0x822521AC;
		  /* 822521ACh */ case   73:  		/* addi R11, R5, 228 */
		/* 822521ACh case   73:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0xE4);
		/* 822521ACh case   73:*/		return 0x822521B0;
		  /* 822521B0h */ case   74:  		/* addi R10, R6, 228 */
		/* 822521B0h case   74:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0xE4);
		/* 822521B0h case   74:*/		return 0x822521B4;
		  /* 822521B4h */ case   75:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 822521B4h case   75:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 822521B4h case   75:*/		return 0x822521B8;
		  /* 822521B8h */ case   76:  		/* rlwinm R9, R10, 2, 0, 29 */
		/* 822521B8h case   76:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R10);
		/* 822521B8h case   76:*/		return 0x822521BC;
		  /* 822521BCh */ case   77:  		/* lwzx R10, <#[R8 + R3]> */
		/* 822521BCh case   77:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 822521BCh case   77:*/		return 0x822521C0;
		  /* 822521C0h */ case   78:  		/* lwzx R11, <#[R9 + R3]> */
		/* 822521C0h case   78:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 822521C0h case   78:*/		return 0x822521C4;
		  /* 822521C4h */ case   79:  		/* cmplwi CR6, R11, 0 */
		/* 822521C4h case   79:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822521C4h case   79:*/		return 0x822521C8;
		  /* 822521C8h */ case   80:  		/* stwx R10, <#[R9 + R3]> */
		/* 822521C8h case   80:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 822521C8h case   80:*/		return 0x822521CC;
		  /* 822521CCh */ case   81:  		/* stwx R11, <#[R8 + R3]> */
		/* 822521CCh case   81:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 822521CCh case   81:*/		return 0x822521D0;
		  /* 822521D0h */ case   82:  		/* bc 12, CR6_EQ, 32 */
		/* 822521D0h case   82:*/		if ( regs.CR[6].eq ) { return 0x822521F0;  }
		/* 822521D0h case   82:*/		return 0x822521D4;
		  /* 822521D4h */ case   83:  		/* lwz R10, <#[R11 + 56]> */
		/* 822521D4h case   83:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000038) );
		/* 822521D4h case   83:*/		return 0x822521D8;
		  /* 822521D8h */ case   84:  		/* stw R5, <#[R11 + 16]> */
		/* 822521D8h case   84:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x00000010) );
		/* 822521D8h case   84:*/		return 0x822521DC;
		  /* 822521DCh */ case   85:  		/* cmplwi CR6, R10, 0 */
		/* 822521DCh case   85:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 822521DCh case   85:*/		return 0x822521E0;
		  /* 822521E0h */ case   86:  		/* bc 12, CR6_EQ, 16 */
		/* 822521E0h case   86:*/		if ( regs.CR[6].eq ) { return 0x822521F0;  }
		/* 822521E0h case   86:*/		return 0x822521E4;
		  /* 822521E4h */ case   87:  		/* lwz R11, <#[R11 + 32]> */
		/* 822521E4h case   87:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 822521E4h case   87:*/		return 0x822521E8;
		  /* 822521E8h */ case   88:  		/* stw R5, <#[R10 + 56]> */
		/* 822521E8h case   88:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x00000038) );
		/* 822521E8h case   88:*/		return 0x822521EC;
		  /* 822521ECh */ case   89:  		/* stw R11, <#[R10 + 80]> */
		/* 822521ECh case   89:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000050) );
		/* 822521ECh case   89:*/		return 0x822521F0;
	}
	return 0x822521F0;
} // Block from 82252088h-822521F0h (90 instructions)

//////////////////////////////////////////////////////
// Block at 822521F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822521F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822521F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822521F0);
		  /* 822521F0h */ case    0:  		/* lwzx R10, <#[R9 + R3]> */
		/* 822521F0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 822521F0h case    0:*/		return 0x822521F4;
		  /* 822521F4h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 822521F4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 822521F4h case    1:*/		return 0x822521F8;
		  /* 822521F8h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 822521F8h case    2:*/		if ( regs.CR[6].eq ) { return 0x82252218;  }
		/* 822521F8h case    2:*/		return 0x822521FC;
		  /* 822521FCh */ case    3:  		/* lwz R11, <#[R10 + 56]> */
		/* 822521FCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000038) );
		/* 822521FCh case    3:*/		return 0x82252200;
		  /* 82252200h */ case    4:  		/* stw R6, <#[R10 + 16]> */
		/* 82252200h case    4:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000010) );
		/* 82252200h case    4:*/		return 0x82252204;
		  /* 82252204h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82252204h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82252204h case    5:*/		return 0x82252208;
		  /* 82252208h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 82252208h case    6:*/		if ( regs.CR[6].eq ) { return 0x82252218;  }
		/* 82252208h case    6:*/		return 0x8225220C;
		  /* 8225220Ch */ case    7:  		/* lwz R10, <#[R10 + 32]> */
		/* 8225220Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000020) );
		/* 8225220Ch case    7:*/		return 0x82252210;
		  /* 82252210h */ case    8:  		/* stw R6, <#[R11 + 56]> */
		/* 82252210h case    8:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000038) );
		/* 82252210h case    8:*/		return 0x82252214;
		  /* 82252214h */ case    9:  		/* stw R10, <#[R11 + 80]> */
		/* 82252214h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000050) );
		/* 82252214h case    9:*/		return 0x82252218;
	}
	return 0x82252218;
} // Block from 822521F0h-82252218h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82252218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252218);
		  /* 82252218h */ case    0:  		/* lwzx R11, <#[R8 + R3]> */
		/* 82252218h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 82252218h case    0:*/		return 0x8225221C;
		  /* 8225221Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8225221Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8225221Ch case    1:*/		return 0x82252220;
		  /* 82252220h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 82252220h case    2:*/		if ( regs.CR[6].eq ) { return 0x82252234;  }
		/* 82252220h case    2:*/		return 0x82252224;
		  /* 82252224h */ case    3:  		/* lwz R11, <#[R11 + 32]> */
		/* 82252224h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 82252224h case    3:*/		return 0x82252228;
		  /* 82252228h */ case    4:  		/* cmpwi CR6, R11, 18 */
		/* 82252228h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000012);
		/* 82252228h case    4:*/		return 0x8225222C;
		  /* 8225222Ch */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 8225222Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x82252234;  }
		/* 8225222Ch case    5:*/		return 0x82252230;
		  /* 82252230h */ case    6:  		/* stw R5, <#[R4 + 2076]> */
		/* 82252230h case    6:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R4 + 0x0000081C) );
		/* 82252230h case    6:*/		return 0x82252234;
	}
	return 0x82252234;
} // Block from 82252218h-82252234h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82252234h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252234);
		  /* 82252234h */ case    0:  		/* lwzx R11, <#[R9 + R3]> */
		/* 82252234h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 82252234h case    0:*/		return 0x82252238;
		  /* 82252238h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82252238h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82252238h case    1:*/		return 0x8225223C;
		  /* 8225223Ch */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 8225223Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82252250;  }
		/* 8225223Ch case    2:*/		return 0x82252240;
		  /* 82252240h */ case    3:  		/* lwz R11, <#[R11 + 32]> */
		/* 82252240h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 82252240h case    3:*/		return 0x82252244;
		  /* 82252244h */ case    4:  		/* cmpwi CR6, R11, 18 */
		/* 82252244h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000012);
		/* 82252244h case    4:*/		return 0x82252248;
		  /* 82252248h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 82252248h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82252250;  }
		/* 82252248h case    5:*/		return 0x8225224C;
		  /* 8225224Ch */ case    6:  		/* stw R6, <#[R4 + 2076]> */
		/* 8225224Ch case    6:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R4 + 0x0000081C) );
		/* 8225224Ch case    6:*/		return 0x82252250;
	}
	return 0x82252250;
} // Block from 82252234h-82252250h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82252250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252250);
		  /* 82252250h */ case    0:  		/* b -1839016 */
		/* 82252250h case    0:*/		return 0x820912A8;
		/* 82252250h case    0:*/		return 0x82252254;
		  /* 82252254h */ case    1:  		/* nop */
		/* 82252254h case    1:*/		cpu::op::nop();
		/* 82252254h case    1:*/		return 0x82252258;
	}
	return 0x82252258;
} // Block from 82252250h-82252258h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252258h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252258);
		  /* 82252258h */ case    0:  		/* mfspr R12, LR */
		/* 82252258h case    0:*/		regs.R12 = regs.LR;
		/* 82252258h case    0:*/		return 0x8225225C;
		  /* 8225225Ch */ case    1:  		/* bl -1839116 */
		/* 8225225Ch case    1:*/		regs.LR = 0x82252260; return 0x82091250;
		/* 8225225Ch case    1:*/		return 0x82252260;
		  /* 82252260h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82252260h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82252260h case    2:*/		return 0x82252264;
		  /* 82252264h */ case    3:  		/* mr R29, R3 */
		/* 82252264h case    3:*/		regs.R29 = regs.R3;
		/* 82252264h case    3:*/		return 0x82252268;
		  /* 82252268h */ case    4:  		/* mr R28, R4 */
		/* 82252268h case    4:*/		regs.R28 = regs.R4;
		/* 82252268h case    4:*/		return 0x8225226C;
		  /* 8225226Ch */ case    5:  		/* mr R27, R5 */
		/* 8225226Ch case    5:*/		regs.R27 = regs.R5;
		/* 8225226Ch case    5:*/		return 0x82252270;
		  /* 82252270h */ case    6:  		/* mr R26, R6 */
		/* 82252270h case    6:*/		regs.R26 = regs.R6;
		/* 82252270h case    6:*/		return 0x82252274;
		  /* 82252274h */ case    7:  		/* cmpwi CR6, R4, 33 */
		/* 82252274h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000021);
		/* 82252274h case    7:*/		return 0x82252278;
		  /* 82252278h */ case    8:  		/* bc 4, CR6_EQ, 40 */
		/* 82252278h case    8:*/		if ( !regs.CR[6].eq ) { return 0x822522A0;  }
		/* 82252278h case    8:*/		return 0x8225227C;
		  /* 8225227Ch */ case    9:  		/* lis R11, -32252 */
		/* 8225227Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8225227Ch case    9:*/		return 0x82252280;
		  /* 82252280h */ case   10:  		/* lis R10, -32252 */
		/* 82252280h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82252280h case   10:*/		return 0x82252284;
		  /* 82252284h */ case   11:  		/* lis R9, -32253 */
		/* 82252284h case   11:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82252284h case   11:*/		return 0x82252288;
		  /* 82252288h */ case   12:  		/* addi R6, R11, 16944 */
		/* 82252288h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x4230);
		/* 82252288h case   12:*/		return 0x8225228C;
		  /* 8225228Ch */ case   13:  		/* addi R5, R10, 17364 */
		/* 8225228Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x43D4);
		/* 8225228Ch case   13:*/		return 0x82252290;
		  /* 82252290h */ case   14:  		/* addi R4, R9, 27460 */
		/* 82252290h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82252290h case   14:*/		return 0x82252294;
		  /* 82252294h */ case   15:  		/* li R7, 537 */
		/* 82252294h case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x219);
		/* 82252294h case   15:*/		return 0x82252298;
	}
	return 0x82252298;
} // Block from 82252258h-82252298h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82252298h
// Function '??0LinkageInfo@XGRAPHICS@@QAA@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252298);
		  /* 82252298h */ case    0:  		/* li R3, 0 */
		/* 82252298h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82252298h case    0:*/		return 0x8225229C;
		  /* 8225229Ch */ case    1:  		/* bl -1025684 */
		/* 8225229Ch case    1:*/		regs.LR = 0x822522A0; return 0x82157C08;
		/* 8225229Ch case    1:*/		return 0x822522A0;
	}
	return 0x822522A0;
} // Block from 82252298h-822522A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822522A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822522A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822522A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822522A0);
		  /* 822522A0h */ case    0:  		/* lbz R11, <#[R29 + 1872]> */
		/* 822522A0h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000750) );
		/* 822522A0h case    0:*/		return 0x822522A4;
		  /* 822522A4h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 822522A4h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 822522A4h case    1:*/		return 0x822522A8;
		  /* 822522A8h */ case    2:  		/* bc 12, CR0_EQ, 96 */
		/* 822522A8h case    2:*/		if ( regs.CR[0].eq ) { return 0x82252308;  }
		/* 822522A8h case    2:*/		return 0x822522AC;
		  /* 822522ACh */ case    3:  		/* li R31, 0 */
		/* 822522ACh case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 822522ACh case    3:*/		return 0x822522B0;
		  /* 822522B0h */ case    4:  		/* mr R30, R29 */
		/* 822522B0h case    4:*/		regs.R30 = regs.R29;
		/* 822522B0h case    4:*/		return 0x822522B4;
		  /* 822522B4h */ case    5:  		/* mr R4, R31 */
		/* 822522B4h case    5:*/		regs.R4 = regs.R31;
		/* 822522B4h case    5:*/		return 0x822522B8;
		  /* 822522B8h */ case    6:  		/* mr R3, R29 */
		/* 822522B8h case    6:*/		regs.R3 = regs.R29;
		/* 822522B8h case    6:*/		return 0x822522BC;
		  /* 822522BCh */ case    7:  		/* bl -1100 */
		/* 822522BCh case    7:*/		regs.LR = 0x822522C0; return 0x82251E70;
		/* 822522BCh case    7:*/		return 0x822522C0;
		  /* 822522C0h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822522C0h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822522C0h case    8:*/		return 0x822522C4;
		  /* 822522C4h */ case    9:  		/* bc 12, CR0_EQ, 28 */
		/* 822522C4h case    9:*/		if ( regs.CR[0].eq ) { return 0x822522E0;  }
		/* 822522C4h case    9:*/		return 0x822522C8;
		  /* 822522C8h */ case   10:  		/* lwz R11, <#[R30]> */
		/* 822522C8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822522C8h case   10:*/		return 0x822522CC;
		  /* 822522CCh */ case   11:  		/* cmpw CR6, R11, R28 */
		/* 822522CCh case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R28);
		/* 822522CCh case   11:*/		return 0x822522D0;
		  /* 822522D0h */ case   12:  		/* bc 4, CR6_EQ, 16 */
		/* 822522D0h case   12:*/		if ( !regs.CR[6].eq ) { return 0x822522E0;  }
		/* 822522D0h case   12:*/		return 0x822522D4;
		  /* 822522D4h */ case   13:  		/* lwz R11, <#[R30 + 64]> */
		/* 822522D4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000040) );
		/* 822522D4h case   13:*/		return 0x822522D8;
		  /* 822522D8h */ case   14:  		/* cmpw CR6, R11, R27 */
		/* 822522D8h case   14:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R27);
		/* 822522D8h case   14:*/		return 0x822522DC;
		  /* 822522DCh */ case   15:  		/* bc 12, CR6_EQ, 32 */
		/* 822522DCh case   15:*/		if ( regs.CR[6].eq ) { return 0x822522FC;  }
		/* 822522DCh case   15:*/		return 0x822522E0;
	}
	return 0x822522E0;
} // Block from 822522A0h-822522E0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822522E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822522E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822522E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822522E0);
		  /* 822522E0h */ case    0:  		/* addi R31, R31, 1 */
		/* 822522E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 822522E0h case    0:*/		return 0x822522E4;
		  /* 822522E4h */ case    1:  		/* addi R30, R30, 4 */
		/* 822522E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 822522E4h case    1:*/		return 0x822522E8;
		  /* 822522E8h */ case    2:  		/* cmpwi CR6, R31, 16 */
		/* 822522E8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000010);
		/* 822522E8h case    2:*/		return 0x822522EC;
		  /* 822522ECh */ case    3:  		/* bc 12, CR6_LT, -56 */
		/* 822522ECh case    3:*/		if ( regs.CR[6].lt ) { return 0x822522B4;  }
		/* 822522ECh case    3:*/		return 0x822522F0;
		  /* 822522F0h */ case    4:  		/* li R3, 0 */
		/* 822522F0h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822522F0h case    4:*/		return 0x822522F4;
		  /* 822522F4h */ case    5:  		/* addi R1, R1, 144 */
		/* 822522F4h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 822522F4h case    5:*/		return 0x822522F8;
		  /* 822522F8h */ case    6:  		/* b -1839192 */
		/* 822522F8h case    6:*/		return 0x820912A0;
		/* 822522F8h case    6:*/		return 0x822522FC;
	}
	return 0x822522FC;
} // Block from 822522E0h-822522FCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 822522FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822522FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822522FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822522FC);
		  /* 822522FCh */ case    0:  		/* stw R31, <#[R26]> */
		/* 822522FCh case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R26 + 0x00000000) );
		/* 822522FCh case    0:*/		return 0x82252300;
		  /* 82252300h */ case    1:  		/* li R3, 1 */
		/* 82252300h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82252300h case    1:*/		return 0x82252304;
		  /* 82252304h */ case    2:  		/* b -16 */
		/* 82252304h case    2:*/		return 0x822522F4;
		/* 82252304h case    2:*/		return 0x82252308;
	}
	return 0x82252308;
} // Block from 822522FCh-82252308h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82252308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252308);
		  /* 82252308h */ case    0:  		/* li R10, 0 */
		/* 82252308h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82252308h case    0:*/		return 0x8225230C;
		  /* 8225230Ch */ case    1:  		/* addi R11, R29, 1040 */
		/* 8225230Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x410);
		/* 8225230Ch case    1:*/		return 0x82252310;
		  /* 82252310h */ case    2:  		/* lwz R9, <#[R11 - 64]> */
		/* 82252310h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0xFFFFFFC0) );
		/* 82252310h case    2:*/		return 0x82252314;
		  /* 82252314h */ case    3:  		/* cmpw CR6, R9, R28 */
		/* 82252314h case    3:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R28);
		/* 82252314h case    3:*/		return 0x82252318;
		  /* 82252318h */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 82252318h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82252328;  }
		/* 82252318h case    4:*/		return 0x8225231C;
		  /* 8225231Ch */ case    5:  		/* lwz R9, <#[R11]> */
		/* 8225231Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8225231Ch case    5:*/		return 0x82252320;
		  /* 82252320h */ case    6:  		/* cmpw CR6, R9, R27 */
		/* 82252320h case    6:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R27);
		/* 82252320h case    6:*/		return 0x82252324;
		  /* 82252324h */ case    7:  		/* bc 12, CR6_EQ, 24 */
		/* 82252324h case    7:*/		if ( regs.CR[6].eq ) { return 0x8225233C;  }
		/* 82252324h case    7:*/		return 0x82252328;
	}
	return 0x82252328;
} // Block from 82252308h-82252328h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82252328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252328);
		  /* 82252328h */ case    0:  		/* addi R10, R10, 1 */
		/* 82252328h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82252328h case    0:*/		return 0x8225232C;
		  /* 8225232Ch */ case    1:  		/* addi R11, R11, 4 */
		/* 8225232Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8225232Ch case    1:*/		return 0x82252330;
		  /* 82252330h */ case    2:  		/* cmpwi CR6, R10, 16 */
		/* 82252330h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000010);
		/* 82252330h case    2:*/		return 0x82252334;
		  /* 82252334h */ case    3:  		/* bc 12, CR6_LT, -36 */
		/* 82252334h case    3:*/		if ( regs.CR[6].lt ) { return 0x82252310;  }
		/* 82252334h case    3:*/		return 0x82252338;
		  /* 82252338h */ case    4:  		/* b -72 */
		/* 82252338h case    4:*/		return 0x822522F0;
		/* 82252338h case    4:*/		return 0x8225233C;
	}
	return 0x8225233C;
} // Block from 82252328h-8225233Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225233Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225233C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225233C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225233C);
		  /* 8225233Ch */ case    0:  		/* stw R10, <#[R26]> */
		/* 8225233Ch case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 8225233Ch case    0:*/		return 0x82252340;
		  /* 82252340h */ case    1:  		/* b -64 */
		/* 82252340h case    1:*/		return 0x82252300;
		/* 82252340h case    1:*/		return 0x82252344;
		  /* 82252344h */ case    2:  		/* nop */
		/* 82252344h case    2:*/		cpu::op::nop();
		/* 82252344h case    2:*/		return 0x82252348;
	}
	return 0x82252348;
} // Block from 8225233Ch-82252348h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82252348h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252348);
		  /* 82252348h */ case    0:  		/* mfspr R12, LR */
		/* 82252348h case    0:*/		regs.R12 = regs.LR;
		/* 82252348h case    0:*/		return 0x8225234C;
		  /* 8225234Ch */ case    1:  		/* bl -1839400 */
		/* 8225234Ch case    1:*/		regs.LR = 0x82252350; return 0x82091224;
		/* 8225234Ch case    1:*/		return 0x82252350;
		  /* 82252350h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 82252350h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 82252350h case    2:*/		return 0x82252354;
		  /* 82252354h */ case    3:  		/* add R11, R6, R3 */
		/* 82252354h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R6,regs.R3);
		/* 82252354h case    3:*/		return 0x82252358;
		  /* 82252358h */ case    4:  		/* mr R31, R3 */
		/* 82252358h case    4:*/		regs.R31 = regs.R3;
		/* 82252358h case    4:*/		return 0x8225235C;
		  /* 8225235Ch */ case    5:  		/* mr R21, R4 */
		/* 8225235Ch case    5:*/		regs.R21 = regs.R4;
		/* 8225235Ch case    5:*/		return 0x82252360;
		  /* 82252360h */ case    6:  		/* mr R19, R5 */
		/* 82252360h case    6:*/		regs.R19 = regs.R5;
		/* 82252360h case    6:*/		return 0x82252364;
		  /* 82252364h */ case    7:  		/* mr R20, R6 */
		/* 82252364h case    7:*/		regs.R20 = regs.R6;
		/* 82252364h case    7:*/		return 0x82252368;
		  /* 82252368h */ case    8:  		/* lbz R11, <#[R11 + 896]> */
		/* 82252368h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000380) );
		/* 82252368h case    8:*/		return 0x8225236C;
		  /* 8225236Ch */ case    9:  		/* cmplwi CR0, R11, 0 */
		/* 8225236Ch case    9:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8225236Ch case    9:*/		return 0x82252370;
		  /* 82252370h */ case   10:  		/* bc 4, CR0_EQ, 552 */
		/* 82252370h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82252598;  }
		/* 82252370h case   10:*/		return 0x82252374;
		  /* 82252374h */ case   11:  		/* lis R11, -32251 */
		/* 82252374h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82252374h case   11:*/		return 0x82252378;
	}
	return 0x82252378;
} // Block from 82252348h-82252378h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82252378h
// Function '?SetInterpolatorComponentUsage@LinkageInfo@XGRAPHICS@@QAAXHHHW4RegType@R400Tables@@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252378);
		  /* 82252378h */ case    0:  		/* lwz R3, <#[R3 + 1876]> */
		/* 82252378h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000754) );
		/* 82252378h case    0:*/		return 0x8225237C;
		  /* 8225237Ch */ case    1:  		/* mulli R10, R5, 12 */
		/* 8225237Ch case    1:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R5,0xC);
		/* 8225237Ch case    1:*/		return 0x82252380;
		  /* 82252380h */ case    2:  		/* addi R11, R11, -19064 */
		/* 82252380h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFB588);
		/* 82252380h case    2:*/		return 0x82252384;
		  /* 82252384h */ case    3:  		/* lis R9, -32252 */
		/* 82252384h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 82252384h case    3:*/		return 0x82252388;
		  /* 82252388h */ case    4:  		/* mr R5, R6 */
		/* 82252388h case    4:*/		regs.R5 = regs.R6;
		/* 82252388h case    4:*/		return 0x8225238C;
		  /* 8225238Ch */ case    5:  		/* addi R4, R9, 17424 */
		/* 8225238Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x4410);
		/* 8225238Ch case    5:*/		return 0x82252390;
		  /* 82252390h */ case    6:  		/* lwzx R6, <#[R10 + R11]> */
		/* 82252390h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82252390h case    6:*/		return 0x82252394;
		  /* 82252394h */ case    7:  		/* bl -217044 */
		/* 82252394h case    7:*/		regs.LR = 0x82252398; return 0x8221D3C0;
		/* 82252394h case    7:*/		return 0x82252398;
		  /* 82252398h */ case    8:  		/* li R22, 0 */
		/* 82252398h case    8:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 82252398h case    8:*/		return 0x8225239C;
		  /* 8225239Ch */ case    9:  		/* cmpwi CR6, R20, 15 */
		/* 8225239Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x0000000F);
		/* 8225239Ch case    9:*/		return 0x822523A0;
		  /* 822523A0h */ case   10:  		/* bc 4, CR6_LT, 200 */
		/* 822523A0h case   10:*/		if ( !regs.CR[6].lt ) { return 0x82252468;  }
		/* 822523A0h case   10:*/		return 0x822523A4;
		  /* 822523A4h */ case   11:  		/* addi R11, R20, 228 */
		/* 822523A4h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R20,0xE4);
		/* 822523A4h case   11:*/		return 0x822523A8;
		  /* 822523A8h */ case   12:  		/* subfic R29, R31, -632 */
		/* 822523A8h case   12:*/		cpu::op::subfic<0>(regs,&regs.R29,regs.R31,0xFFFFFD88);
		/* 822523A8h case   12:*/		return 0x822523AC;
		  /* 822523ACh */ case   13:  		/* subfic R28, R31, -636 */
		/* 822523ACh case   13:*/		cpu::op::subfic<0>(regs,&regs.R28,regs.R31,0xFFFFFD84);
		/* 822523ACh case   13:*/		return 0x822523B0;
		  /* 822523B0h */ case   14:  		/* subfic R27, R31, -568 */
		/* 822523B0h case   14:*/		cpu::op::subfic<0>(regs,&regs.R27,regs.R31,0xFFFFFDC8);
		/* 822523B0h case   14:*/		return 0x822523B4;
		  /* 822523B4h */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822523B4h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822523B4h case   15:*/		return 0x822523B8;
		  /* 822523B8h */ case   16:  		/* subfic R26, R31, -572 */
		/* 822523B8h case   16:*/		cpu::op::subfic<0>(regs,&regs.R26,regs.R31,0xFFFFFDC4);
		/* 822523B8h case   16:*/		return 0x822523BC;
		  /* 822523BCh */ case   17:  		/* subfic R25, R31, -504 */
		/* 822523BCh case   17:*/		cpu::op::subfic<0>(regs,&regs.R25,regs.R31,0xFFFFFE08);
		/* 822523BCh case   17:*/		return 0x822523C0;
		  /* 822523C0h */ case   18:  		/* subfic R24, R31, -508 */
		/* 822523C0h case   18:*/		cpu::op::subfic<0>(regs,&regs.R24,regs.R31,0xFFFFFE04);
		/* 822523C0h case   18:*/		return 0x822523C4;
		  /* 822523C4h */ case   19:  		/* add R11, R11, R31 */
		/* 822523C4h case   19:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 822523C4h case   19:*/		return 0x822523C8;
		  /* 822523C8h */ case   20:  		/* subfic R23, R20, 15 */
		/* 822523C8h case   20:*/		cpu::op::subfic<0>(regs,&regs.R23,regs.R20,0xF);
		/* 822523C8h case   20:*/		return 0x822523CC;
		  /* 822523CCh */ case   21:  		/* lwz R4, <#[R11 + 68]> */
		/* 822523CCh case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000044) );
		/* 822523CCh case   21:*/		return 0x822523D0;
		  /* 822523D0h */ case   22:  		/* li R9, 4 */
		/* 822523D0h case   22:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 822523D0h case   22:*/		return 0x822523D4;
		  /* 822523D4h */ case   23:  		/* lwz R3, <#[R11 + 132]> */
		/* 822523D4h case   23:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000084) );
		/* 822523D4h case   23:*/		return 0x822523D8;
		  /* 822523D8h */ case   24:  		/* addi R8, R11, 4 */
		/* 822523D8h case   24:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x4);
		/* 822523D8h case   24:*/		return 0x822523DC;
		  /* 822523DCh */ case   25:  		/* lwz R18, <#[R11 + 4]> */
		/* 822523DCh case   25:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R11 + 0x00000004) );
		/* 822523DCh case   25:*/		return 0x822523E0;
		  /* 822523E0h */ case   26:  		/* mr R10, R22 */
		/* 822523E0h case   26:*/		regs.R10 = regs.R22;
		/* 822523E0h case   26:*/		return 0x822523E4;
		  /* 822523E4h */ case   27:  		/* add R7, R29, R11 */
		/* 822523E4h case   27:*/		cpu::op::add<0>(regs,&regs.R7,regs.R29,regs.R11);
		/* 822523E4h case   27:*/		return 0x822523E8;
		  /* 822523E8h */ case   28:  		/* add R6, R28, R11 */
		/* 822523E8h case   28:*/		cpu::op::add<0>(regs,&regs.R6,regs.R28,regs.R11);
		/* 822523E8h case   28:*/		return 0x822523EC;
		  /* 822523ECh */ case   29:  		/* stw R4, <#[R11 + 64]> */
		/* 822523ECh case   29:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000040) );
		/* 822523ECh case   29:*/		return 0x822523F0;
		  /* 822523F0h */ case   30:  		/* add R5, R27, R11 */
		/* 822523F0h case   30:*/		cpu::op::add<0>(regs,&regs.R5,regs.R27,regs.R11);
		/* 822523F0h case   30:*/		return 0x822523F4;
		  /* 822523F4h */ case   31:  		/* stw R3, <#[R11 + 128]> */
		/* 822523F4h case   31:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000080) );
		/* 822523F4h case   31:*/		return 0x822523F8;
		  /* 822523F8h */ case   32:  		/* add R4, R26, R11 */
		/* 822523F8h case   32:*/		cpu::op::add<0>(regs,&regs.R4,regs.R26,regs.R11);
		/* 822523F8h case   32:*/		return 0x822523FC;
		  /* 822523FCh */ case   33:  		/* add R3, R25, R11 */
		/* 822523FCh case   33:*/		cpu::op::add<0>(regs,&regs.R3,regs.R25,regs.R11);
		/* 822523FCh case   33:*/		return 0x82252400;
		  /* 82252400h */ case   34:  		/* mtspr CTR, R9 */
		/* 82252400h case   34:*/		regs.CTR = regs.R9;
		/* 82252400h case   34:*/		return 0x82252404;
		  /* 82252404h */ case   35:  		/* add R30, R24, R11 */
		/* 82252404h case   35:*/		cpu::op::add<0>(regs,&regs.R30,regs.R24,regs.R11);
		/* 82252404h case   35:*/		return 0x82252408;
		  /* 82252408h */ case   36:  		/* stw R18, <#[R11]> */
		/* 82252408h case   36:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R11 + 0x00000000) );
		/* 82252408h case   36:*/		return 0x8225240C;
		  /* 8225240Ch */ case   37:  		/* add R11, R7, R10 */
		/* 8225240Ch case   37:*/		cpu::op::add<0>(regs,&regs.R11,regs.R7,regs.R10);
		/* 8225240Ch case   37:*/		return 0x82252410;
		  /* 82252410h */ case   38:  		/* add R9, R5, R10 */
		/* 82252410h case   38:*/		cpu::op::add<0>(regs,&regs.R9,regs.R5,regs.R10);
		/* 82252410h case   38:*/		return 0x82252414;
		  /* 82252414h */ case   39:  		/* add R18, R3, R10 */
		/* 82252414h case   39:*/		cpu::op::add<0>(regs,&regs.R18,regs.R3,regs.R10);
		/* 82252414h case   39:*/		return 0x82252418;
		  /* 82252418h */ case   40:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82252418h case   40:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82252418h case   40:*/		return 0x8225241C;
		  /* 8225241Ch */ case   41:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8225241Ch case   41:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8225241Ch case   41:*/		return 0x82252420;
		  /* 82252420h */ case   42:  		/* rlwinm R18, R18, 2, 0, 29 */
		/* 82252420h case   42:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R18,regs.R18);
		/* 82252420h case   42:*/		return 0x82252424;
		  /* 82252424h */ case   43:  		/* add R17, R6, R10 */
		/* 82252424h case   43:*/		cpu::op::add<0>(regs,&regs.R17,regs.R6,regs.R10);
		/* 82252424h case   43:*/		return 0x82252428;
		  /* 82252428h */ case   44:  		/* add R16, R4, R10 */
		/* 82252428h case   44:*/		cpu::op::add<0>(regs,&regs.R16,regs.R4,regs.R10);
		/* 82252428h case   44:*/		return 0x8225242C;
		  /* 8225242Ch */ case   45:  		/* add R15, R30, R10 */
		/* 8225242Ch case   45:*/		cpu::op::add<0>(regs,&regs.R15,regs.R30,regs.R10);
		/* 8225242Ch case   45:*/		return 0x82252430;
		  /* 82252430h */ case   46:  		/* lwzx R11, <#[R11 + R31]> */
		/* 82252430h case   46:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82252430h case   46:*/		return 0x82252434;
		  /* 82252434h */ case   47:  		/* lwzx R9, <#[R9 + R31]> */
		/* 82252434h case   47:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R31 + 0x00000000) );
		/* 82252434h case   47:*/		return 0x82252438;
		  /* 82252438h */ case   48:  		/* rlwinm R17, R17, 2, 0, 29 */
		/* 82252438h case   48:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R17,regs.R17);
		/* 82252438h case   48:*/		return 0x8225243C;
		  /* 8225243Ch */ case   49:  		/* lwzx R18, <#[R18 + R31]> */
		/* 8225243Ch case   49:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R18 + regs.R31 + 0x00000000) );
		/* 8225243Ch case   49:*/		return 0x82252440;
		  /* 82252440h */ case   50:  		/* rlwinm R16, R16, 2, 0, 29 */
		/* 82252440h case   50:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R16,regs.R16);
		/* 82252440h case   50:*/		return 0x82252444;
		  /* 82252444h */ case   51:  		/* rlwinm R15, R15, 2, 0, 29 */
		/* 82252444h case   51:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R15,regs.R15);
		/* 82252444h case   51:*/		return 0x82252448;
		  /* 82252448h */ case   52:  		/* addi R10, R10, 1 */
		/* 82252448h case   52:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82252448h case   52:*/		return 0x8225244C;
		  /* 8225244Ch */ case   53:  		/* stwx R11, <#[R17 + R31]> */
		/* 8225244Ch case   53:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R17 + regs.R31 + 0x00000000) );
		/* 8225244Ch case   53:*/		return 0x82252450;
		  /* 82252450h */ case   54:  		/* stwx R9, <#[R16 + R31]> */
		/* 82252450h case   54:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R16 + regs.R31 + 0x00000000) );
		/* 82252450h case   54:*/		return 0x82252454;
		  /* 82252454h */ case   55:  		/* stwx R18, <#[R15 + R31]> */
		/* 82252454h case   55:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R15 + regs.R31 + 0x00000000) );
		/* 82252454h case   55:*/		return 0x82252458;
		  /* 82252458h */ case   56:  		/* bc 16, CR0_LT, -76 */
		/* 82252458h case   56:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8225240C;  }
		/* 82252458h case   56:*/		return 0x8225245C;
		  /* 8225245Ch */ case   57:  		/* addic. R23, R23, -1 */
		/* 8225245Ch case   57:*/		cpu::op::addic<1>(regs,&regs.R23,regs.R23,0xFFFFFFFF);
		/* 8225245Ch case   57:*/		return 0x82252460;
		  /* 82252460h */ case   58:  		/* mr R11, R8 */
		/* 82252460h case   58:*/		regs.R11 = regs.R8;
		/* 82252460h case   58:*/		return 0x82252464;
		  /* 82252464h */ case   59:  		/* bc 4, CR0_EQ, -152 */
		/* 82252464h case   59:*/		if ( !regs.CR[0].eq ) { return 0x822523CC;  }
		/* 82252464h case   59:*/		return 0x82252468;
	}
	return 0x82252468;
} // Block from 82252378h-82252468h (60 instructions)

//////////////////////////////////////////////////////
// Block at 82252468h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252468);
		  /* 82252468h */ case    0:  		/* li R10, 4 */
		/* 82252468h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 82252468h case    0:*/		return 0x8225246C;
		  /* 8225246Ch */ case    1:  		/* stw R22, <#[R31 + 972]> */
		/* 8225246Ch case    1:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x000003CC) );
		/* 8225246Ch case    1:*/		return 0x82252470;
		  /* 82252470h */ case    2:  		/* li R9, 15 */
		/* 82252470h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0xF);
		/* 82252470h case    2:*/		return 0x82252474;
		  /* 82252474h */ case    3:  		/* stw R22, <#[R31 + 1036]> */
		/* 82252474h case    3:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x0000040C) );
		/* 82252474h case    3:*/		return 0x82252478;
		  /* 82252478h */ case    4:  		/* addi R11, R31, 1852 */
		/* 82252478h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x73C);
		/* 82252478h case    4:*/		return 0x8225247C;
		  /* 8225247Ch */ case    5:  		/* stw R9, <#[R31 + 1100]> */
		/* 8225247Ch case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x0000044C) );
		/* 8225247Ch case    5:*/		return 0x82252480;
		  /* 82252480h */ case    6:  		/* mtspr CTR, R10 */
		/* 82252480h case    6:*/		regs.CTR = regs.R10;
		/* 82252480h case    6:*/		return 0x82252484;
		  /* 82252484h */ case    7:  		/* li R10, 19 */
		/* 82252484h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x13);
		/* 82252484h case    7:*/		return 0x82252488;
		  /* 82252488h */ case    8:  		/* stw R22, <#[R11 - 508]> */
		/* 82252488h case    8:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R11 + 0xFFFFFE04) );
		/* 82252488h case    8:*/		return 0x8225248C;
		  /* 8225248Ch */ case    9:  		/* stw R10, <#[R11 - 252]> */
		/* 8225248Ch case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0xFFFFFF04) );
		/* 8225248Ch case    9:*/		return 0x82252490;
		  /* 82252490h */ case   10:  		/* stwu R22, <#[R11 + 4]> */
		/* 82252490h case   10:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82252490h case   10:*/		return 0x82252494;
		  /* 82252494h */ case   11:  		/* bc 16, CR0_LT, -16 */
		/* 82252494h case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82252484;  }
		/* 82252494h case   11:*/		return 0x82252498;
		  /* 82252498h */ case   12:  		/* lbz R11, <#[R21 + 2072]> */
		/* 82252498h case   12:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000818) );
		/* 82252498h case   12:*/		return 0x8225249C;
		  /* 8225249Ch */ case   13:  		/* cmplwi CR0, R11, 0 */
		/* 8225249Ch case   13:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8225249Ch case   13:*/		return 0x822524A0;
		  /* 822524A0h */ case   14:  		/* bc 12, CR0_EQ, 48 */
		/* 822524A0h case   14:*/		if ( regs.CR[0].eq ) { return 0x822524D0;  }
		/* 822524A0h case   14:*/		return 0x822524A4;
		  /* 822524A4h */ case   15:  		/* cmpwi CR6, R19, 18 */
		/* 822524A4h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000012);
		/* 822524A4h case   15:*/		return 0x822524A8;
		  /* 822524A8h */ case   16:  		/* bc 12, CR6_EQ, 40 */
		/* 822524A8h case   16:*/		if ( regs.CR[6].eq ) { return 0x822524D0;  }
		/* 822524A8h case   16:*/		return 0x822524AC;
		  /* 822524ACh */ case   17:  		/* lwz R4, <#[R21 + 2084]> */
		/* 822524ACh case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R21 + 0x00000824) );
		/* 822524ACh case   17:*/		return 0x822524B0;
		  /* 822524B0h */ case   18:  		/* mr R3, R21 */
		/* 822524B0h case   18:*/		regs.R3 = regs.R21;
		/* 822524B0h case   18:*/		return 0x822524B4;
		  /* 822524B4h */ case   19:  		/* addi R11, R4, -1 */
		/* 822524B4h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0xFFFFFFFF);
		/* 822524B4h case   19:*/		return 0x822524B8;
		  /* 822524B8h */ case   20:  		/* stw R11, <#[R21 + 2084]> */
		/* 822524B8h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R21 + 0x00000824) );
		/* 822524B8h case   20:*/		return 0x822524BC;
		  /* 822524BCh */ case   21:  		/* bl -44220 */
		/* 822524BCh case   21:*/		regs.LR = 0x822524C0; return 0x82247800;
		/* 822524BCh case   21:*/		return 0x822524C0;
		  /* 822524C0h */ case   22:  		/* lwz R11, <#[R21 + 2076]> */
		/* 822524C0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x0000081C) );
		/* 822524C0h case   22:*/		return 0x822524C4;
		  /* 822524C4h */ case   23:  		/* addi R11, R11, -1 */
		/* 822524C4h case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 822524C4h case   23:*/		return 0x822524C8;
		  /* 822524C8h */ case   24:  		/* stw R11, <#[R21 + 2076]> */
		/* 822524C8h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R21 + 0x0000081C) );
		/* 822524C8h case   24:*/		return 0x822524CC;
		  /* 822524CCh */ case   25:  		/* b 60 */
		/* 822524CCh case   25:*/		return 0x82252508;
		/* 822524CCh case   25:*/		return 0x822524D0;
	}
	return 0x822524D0;
} // Block from 82252468h-822524D0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 822524D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822524D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822524D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822524D0);
		  /* 822524D0h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 822524D0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822524D0h case    0:*/		return 0x822524D4;
		  /* 822524D4h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 822524D4h case    1:*/		if ( regs.CR[6].eq ) { return 0x822524F4;  }
		/* 822524D4h case    1:*/		return 0x822524D8;
		  /* 822524D8h */ case    2:  		/* cmpwi CR6, R19, 18 */
		/* 822524D8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000012);
		/* 822524D8h case    2:*/		return 0x822524DC;
		  /* 822524DCh */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 822524DCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x822524F4;  }
		/* 822524DCh case    3:*/		return 0x822524E0;
		  /* 822524E0h */ case    4:  		/* lwz R4, <#[R21 + 2084]> */
		/* 822524E0h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R21 + 0x00000824) );
		/* 822524E0h case    4:*/		return 0x822524E4;
		  /* 822524E4h */ case    5:  		/* stb R22, <#[R21 + 2072]> */
		/* 822524E4h case    5:*/		cpu::mem::store8( regs, regs.R22, (uint32)(regs.R21 + 0x00000818) );
		/* 822524E4h case    5:*/		return 0x822524E8;
		  /* 822524E8h */ case    6:  		/* stb R22, <#[R21 + 2073]> */
		/* 822524E8h case    6:*/		cpu::mem::store8( regs, regs.R22, (uint32)(regs.R21 + 0x00000819) );
		/* 822524E8h case    6:*/		return 0x822524EC;
		  /* 822524ECh */ case    7:  		/* stw R22, <#[R21 + 2076]> */
		/* 822524ECh case    7:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R21 + 0x0000081C) );
		/* 822524ECh case    7:*/		return 0x822524F0;
		  /* 822524F0h */ case    8:  		/* b 16 */
		/* 822524F0h case    8:*/		return 0x82252500;
		/* 822524F0h case    8:*/		return 0x822524F4;
	}
	return 0x822524F4;
} // Block from 822524D0h-822524F4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 822524F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822524F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822524F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822524F4);
		  /* 822524F4h */ case    0:  		/* lwz R11, <#[R21 + 2084]> */
		/* 822524F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000824) );
		/* 822524F4h case    0:*/		return 0x822524F8;
		  /* 822524F8h */ case    1:  		/* addi R4, R11, -1 */
		/* 822524F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFF);
		/* 822524F8h case    1:*/		return 0x822524FC;
		  /* 822524FCh */ case    2:  		/* stw R4, <#[R21 + 2084]> */
		/* 822524FCh case    2:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R21 + 0x00000824) );
		/* 822524FCh case    2:*/		return 0x82252500;
	}
	return 0x82252500;
} // Block from 822524F4h-82252500h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82252500h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252500);
		  /* 82252500h */ case    0:  		/* mr R3, R21 */
		/* 82252500h case    0:*/		regs.R3 = regs.R21;
		/* 82252500h case    0:*/		return 0x82252504;
		  /* 82252504h */ case    1:  		/* bl -44292 */
		/* 82252504h case    1:*/		regs.LR = 0x82252508; return 0x82247800;
		/* 82252504h case    1:*/		return 0x82252508;
	}
	return 0x82252508;
} // Block from 82252500h-82252508h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252508);
		  /* 82252508h */ case    0:  		/* lwz R11, <#[R21 + 164]> */
		/* 82252508h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x000000A4) );
		/* 82252508h case    0:*/		return 0x8225250C;
		  /* 8225250Ch */ case    1:  		/* lwz R30, <#[R11 + 28]> */
		/* 8225250Ch case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x0000001C) );
		/* 8225250Ch case    1:*/		return 0x82252510;
		  /* 82252510h */ case    2:  		/* b 100 */
		/* 82252510h case    2:*/		return 0x82252574;
		/* 82252510h case    2:*/		return 0x82252514;
		  /* 82252514h */ case    3:  		/* lwz R11, <#[R30 + 228]> */
		/* 82252514h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000E4) );
		/* 82252514h case    3:*/		return 0x82252518;
		  /* 82252518h */ case    4:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82252518h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82252518h case    4:*/		return 0x8225251C;
		  /* 8225251Ch */ case    5:  		/* bc 12, CR0_EQ, 84 */
		/* 8225251Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x82252570;  }
		/* 8225251Ch case    5:*/		return 0x82252520;
		  /* 82252520h */ case    6:  		/* lwz R11, <#[R30]> */
		/* 82252520h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82252520h case    6:*/		return 0x82252524;
		  /* 82252524h */ case    7:  		/* mr R3, R30 */
		/* 82252524h case    7:*/		regs.R3 = regs.R30;
		/* 82252524h case    7:*/		return 0x82252528;
	}
	return 0x82252528;
} // Block from 82252508h-82252528h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82252528h
// Function '?ShowInterpolatorAssignments@LinkageInfo@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252528);
		  /* 82252528h */ case    0:  		/* lwz R11, <#[R11 + 48]> */
		/* 82252528h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82252528h case    0:*/		return 0x8225252C;
		  /* 8225252Ch */ case    1:  		/* mtspr CTR, R11 */
		/* 8225252Ch case    1:*/		regs.CTR = regs.R11;
		/* 8225252Ch case    1:*/		return 0x82252530;
		  /* 82252530h */ case    2:  		/* bcctrl 20, CR0_LT */
		/* 82252530h case    2:*/		if ( 1 ) { regs.LR = 0x82252534; return (uint32)regs.CTR; }
		/* 82252530h case    2:*/		return 0x82252534;
		  /* 82252534h */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 82252534h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82252534h case    3:*/		return 0x82252538;
		  /* 82252538h */ case    4:  		/* bc 12, CR0_EQ, 56 */
		/* 82252538h case    4:*/		if ( regs.CR[0].eq ) { return 0x82252570;  }
		/* 82252538h case    4:*/		return 0x8225253C;
		  /* 8225253Ch */ case    5:  		/* lwz R11, <#[R30 + 16]> */
		/* 8225253Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8225253Ch case    5:*/		return 0x82252540;
		  /* 82252540h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 82252540h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82252540h case    6:*/		return 0x82252544;
		  /* 82252544h */ case    7:  		/* bc 12, CR6_EQ, 44 */
		/* 82252544h case    7:*/		if ( regs.CR[6].eq ) { return 0x82252570;  }
		/* 82252544h case    7:*/		return 0x82252548;
		  /* 82252548h */ case    8:  		/* lwz R11, <#[R30 + 20]> */
		/* 82252548h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 82252548h case    8:*/		return 0x8225254C;
		  /* 8225254Ch */ case    9:  		/* cmpwi CR6, R11, 0 */
		/* 8225254Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8225254Ch case    9:*/		return 0x82252550;
		  /* 82252550h */ case   10:  		/* bc 4, CR6_EQ, 32 */
		/* 82252550h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82252570;  }
		/* 82252550h case   10:*/		return 0x82252554;
		  /* 82252554h */ case   11:  		/* lwz R11, <#[R30 + 56]> */
		/* 82252554h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000038) );
		/* 82252554h case   11:*/		return 0x82252558;
		  /* 82252558h */ case   12:  		/* cmpw CR6, R11, R20 */
		/* 82252558h case   12:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R20);
		/* 82252558h case   12:*/		return 0x8225255C;
		  /* 8225255Ch */ case   13:  		/* bc 4, CR6_GT, 20 */
		/* 8225255Ch case   13:*/		if ( !regs.CR[6].gt ) { return 0x82252570;  }
		/* 8225255Ch case   13:*/		return 0x82252560;
		  /* 82252560h */ case   14:  		/* lwz R10, <#[R30 + 80]> */
		/* 82252560h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000050) );
		/* 82252560h case   14:*/		return 0x82252564;
		  /* 82252564h */ case   15:  		/* addi R11, R11, -1 */
		/* 82252564h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82252564h case   15:*/		return 0x82252568;
		  /* 82252568h */ case   16:  		/* stw R11, <#[R30 + 56]> */
		/* 82252568h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000038) );
		/* 82252568h case   16:*/		return 0x8225256C;
		  /* 8225256Ch */ case   17:  		/* stw R10, <#[R30 + 80]> */
		/* 8225256Ch case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000050) );
		/* 8225256Ch case   17:*/		return 0x82252570;
	}
	return 0x82252570;
} // Block from 82252528h-82252570h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82252570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252570);
		  /* 82252570h */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 82252570h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 82252570h case    0:*/		return 0x82252574;
	}
	return 0x82252574;
} // Block from 82252570h-82252574h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82252574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252574);
		  /* 82252574h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 82252574h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82252574h case    0:*/		return 0x82252578;
		  /* 82252578h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82252578h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82252578h case    1:*/		return 0x8225257C;
		  /* 8225257Ch */ case    2:  		/* bc 4, CR6_EQ, -104 */
		/* 8225257Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82252514;  }
		/* 8225257Ch case    2:*/		return 0x82252580;
		  /* 82252580h */ case    3:  		/* lis R11, -32252 */
		/* 82252580h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82252580h case    3:*/		return 0x82252584;
		  /* 82252584h */ case    4:  		/* lwz R3, <#[R31 + 1876]> */
		/* 82252584h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000754) );
		/* 82252584h case    4:*/		return 0x82252588;
		  /* 82252588h */ case    5:  		/* addi R4, R11, 17392 */
		/* 82252588h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x43F0);
		/* 82252588h case    5:*/		return 0x8225258C;
		  /* 8225258Ch */ case    6:  		/* bl -217548 */
		/* 8225258Ch case    6:*/		regs.LR = 0x82252590; return 0x8221D3C0;
		/* 8225258Ch case    6:*/		return 0x82252590;
		  /* 82252590h */ case    7:  		/* mr R3, R31 */
		/* 82252590h case    7:*/		regs.R3 = regs.R31;
		/* 82252590h case    7:*/		return 0x82252594;
		  /* 82252594h */ case    8:  		/* bl -2940 */
		/* 82252594h case    8:*/		regs.LR = 0x82252598; return 0x82251A18;
		/* 82252594h case    8:*/		return 0x82252598;
	}
	return 0x82252598;
} // Block from 82252574h-82252598h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82252598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252598);
		  /* 82252598h */ case    0:  		/* addi R1, R1, 224 */
		/* 82252598h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 82252598h case    0:*/		return 0x8225259C;
		  /* 8225259Ch */ case    1:  		/* b -1839912 */
		/* 8225259Ch case    1:*/		return 0x82091274;
		/* 8225259Ch case    1:*/		return 0x822525A0;
	}
	return 0x822525A0;
} // Block from 82252598h-822525A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822525A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822525A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822525A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822525A0);
		  /* 822525A0h */ case    0:  		/* mfspr R12, LR */
		/* 822525A0h case    0:*/		regs.R12 = regs.LR;
		/* 822525A0h case    0:*/		return 0x822525A4;
		  /* 822525A4h */ case    1:  		/* bl -1839996 */
		/* 822525A4h case    1:*/		regs.LR = 0x822525A8; return 0x82091228;
		/* 822525A4h case    1:*/		return 0x822525A8;
	}
	return 0x822525A8;
} // Block from 822525A0h-822525A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822525A8h
// Function '?Compare@LinkageInfo@XGRAPHICS@@AAAHHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822525A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822525A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822525A8);
		  /* 822525A8h */ case    0:  		/* stwu R1, <#[R1 - 256]> */
		/* 822525A8h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 822525A8h case    0:*/		return 0x822525AC;
		  /* 822525ACh */ case    1:  		/* lbz R11, <#[R3 + 1872]> */
		/* 822525ACh case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000750) );
		/* 822525ACh case    1:*/		return 0x822525B0;
		  /* 822525B0h */ case    2:  		/* mr R26, R3 */
		/* 822525B0h case    2:*/		regs.R26 = regs.R3;
		/* 822525B0h case    2:*/		return 0x822525B4;
		  /* 822525B4h */ case    3:  		/* mr R18, R4 */
		/* 822525B4h case    3:*/		regs.R18 = regs.R4;
		/* 822525B4h case    3:*/		return 0x822525B8;
		  /* 822525B8h */ case    4:  		/* li R17, 0 */
		/* 822525B8h case    4:*/		cpu::op::li<0>(regs,&regs.R17,0x0);
		/* 822525B8h case    4:*/		return 0x822525BC;
		  /* 822525BCh */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 822525BCh case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 822525BCh case    5:*/		return 0x822525C0;
		  /* 822525C0h */ case    6:  		/* bc 12, CR0_EQ, 1096 */
		/* 822525C0h case    6:*/		if ( regs.CR[0].eq ) { return 0x82252A08;  }
		/* 822525C0h case    6:*/		return 0x822525C4;
		  /* 822525C4h */ case    7:  		/* li R11, 16 */
		/* 822525C4h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x10);
		/* 822525C4h case    7:*/		return 0x822525C8;
		  /* 822525C8h */ case    8:  		/* addi R10, R1, 95 */
		/* 822525C8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x5F);
		/* 822525C8h case    8:*/		return 0x822525CC;
		  /* 822525CCh */ case    9:  		/* li R19, 0 */
		/* 822525CCh case    9:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 822525CCh case    9:*/		return 0x822525D0;
		  /* 822525D0h */ case   10:  		/* addi R8, R3, 1040 */
		/* 822525D0h case   10:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R3,0x410);
		/* 822525D0h case   10:*/		return 0x822525D4;
		  /* 822525D4h */ case   11:  		/* li R9, 0 */
		/* 822525D4h case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 822525D4h case   11:*/		return 0x822525D8;
		  /* 822525D8h */ case   12:  		/* mtspr CTR, R11 */
		/* 822525D8h case   12:*/		regs.CTR = regs.R11;
		/* 822525D8h case   12:*/		return 0x822525DC;
		  /* 822525DCh */ case   13:  		/* stbu R9, <#[R10 + 1]> */
		/* 822525DCh case   13:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + 0x00000001) );
		regs.R10 = (uint32)(regs.R10 + 0x00000001);
		/* 822525DCh case   13:*/		return 0x822525E0;
		  /* 822525E0h */ case   14:  		/* bc 16, CR0_LT, -4 */
		/* 822525E0h case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x822525DC;  }
		/* 822525E0h case   14:*/		return 0x822525E4;
		  /* 822525E4h */ case   15:  		/* li R11, 16 */
		/* 822525E4h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x10);
		/* 822525E4h case   15:*/		return 0x822525E8;
		  /* 822525E8h */ case   16:  		/* mtspr CTR, R11 */
		/* 822525E8h case   16:*/		regs.CTR = regs.R11;
		/* 822525E8h case   16:*/		return 0x822525EC;
		  /* 822525ECh */ case   17:  		/* lwz R11, <#[R8 - 64]> */
		/* 822525ECh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0xFFFFFFC0) );
		/* 822525ECh case   17:*/		return 0x822525F0;
		  /* 822525F0h */ case   18:  		/* cmpwi CR6, R11, 33 */
		/* 822525F0h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000021);
		/* 822525F0h case   18:*/		return 0x822525F4;
		  /* 822525F4h */ case   19:  		/* bc 4, CR6_EQ, 24 */
		/* 822525F4h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8225260C;  }
		/* 822525F4h case   19:*/		return 0x822525F8;
		  /* 822525F8h */ case   20:  		/* lwz R11, <#[R8]> */
		/* 822525F8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 822525F8h case   20:*/		return 0x822525FC;
		  /* 822525FCh */ case   21:  		/* addi R11, R11, 1 */
		/* 822525FCh case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822525FCh case   21:*/		return 0x82252600;
		  /* 82252600h */ case   22:  		/* cmpw CR6, R11, R19 */
		/* 82252600h case   22:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R19);
		/* 82252600h case   22:*/		return 0x82252604;
		  /* 82252604h */ case   23:  		/* bc 4, CR6_GT, 8 */
		/* 82252604h case   23:*/		if ( !regs.CR[6].gt ) { return 0x8225260C;  }
		/* 82252604h case   23:*/		return 0x82252608;
		  /* 82252608h */ case   24:  		/* mr R19, R11 */
		/* 82252608h case   24:*/		regs.R19 = regs.R11;
		/* 82252608h case   24:*/		return 0x8225260C;
	}
	return 0x8225260C;
} // Block from 822525A8h-8225260Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 8225260Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225260C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225260C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225260C);
		  /* 8225260Ch */ case    0:  		/* addi R8, R8, 4 */
		/* 8225260Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 8225260Ch case    0:*/		return 0x82252610;
		  /* 82252610h */ case    1:  		/* bc 16, CR0_LT, -36 */
		/* 82252610h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x822525EC;  }
		/* 82252610h case    1:*/		return 0x82252614;
		  /* 82252614h */ case    2:  		/* lis R11, -32252 */
		/* 82252614h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82252614h case    2:*/		return 0x82252618;
	}
	return 0x82252618;
} // Block from 8225260Ch-82252618h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82252618h
// Function '?AssignInterpolator@LinkageInfo@XGRAPHICS@@QAAHW4RegType@R400Tables@@HPAVInterpolator@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252618);
		  /* 82252618h */ case    0:  		/* lis R10, -32253 */
		/* 82252618h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8203);
		/* 82252618h case    0:*/		return 0x8225261C;
		  /* 8225261Ch */ case    1:  		/* lis R9, -32252 */
		/* 8225261Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 8225261Ch case    1:*/		return 0x82252620;
		  /* 82252620h */ case    2:  		/* lis R8, -32252 */
		/* 82252620h case    2:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8204);
		/* 82252620h case    2:*/		return 0x82252624;
		  /* 82252624h */ case    3:  		/* li R30, 0 */
		/* 82252624h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82252624h case    3:*/		return 0x82252628;
		  /* 82252628h */ case    4:  		/* addi R29, R11, 17748 */
		/* 82252628h case    4:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x4554);
		/* 82252628h case    4:*/		return 0x8225262C;
		  /* 8225262Ch */ case    5:  		/* addi R21, R10, 27460 */
		/* 8225262Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R10,0x6B44);
		/* 8225262Ch case    5:*/		return 0x82252630;
		  /* 82252630h */ case    6:  		/* addi R28, R9, 17728 */
		/* 82252630h case    6:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R9,0x4540);
		/* 82252630h case    6:*/		return 0x82252634;
		  /* 82252634h */ case    7:  		/* addi R20, R8, 16944 */
		/* 82252634h case    7:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R8,0x4230);
		/* 82252634h case    7:*/		return 0x82252638;
		  /* 82252638h */ case    8:  		/* mr R4, R30 */
		/* 82252638h case    8:*/		regs.R4 = regs.R30;
		/* 82252638h case    8:*/		return 0x8225263C;
		  /* 8225263Ch */ case    9:  		/* mr R3, R26 */
		/* 8225263Ch case    9:*/		regs.R3 = regs.R26;
		/* 8225263Ch case    9:*/		return 0x82252640;
		  /* 82252640h */ case   10:  		/* bl -2000 */
		/* 82252640h case   10:*/		regs.LR = 0x82252644; return 0x82251E70;
		/* 82252640h case   10:*/		return 0x82252644;
		  /* 82252644h */ case   11:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82252644h case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82252644h case   11:*/		return 0x82252648;
		  /* 82252648h */ case   12:  		/* bc 12, CR0_EQ, 168 */
		/* 82252648h case   12:*/		if ( regs.CR[0].eq ) { return 0x822526F0;  }
		/* 82252648h case   12:*/		return 0x8225264C;
		  /* 8225264Ch */ case   13:  		/* addi R27, R1, 96 */
		/* 8225264Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R1,0x60);
		/* 8225264Ch case   13:*/		return 0x82252650;
		  /* 82252650h */ case   14:  		/* lbzx R11, <#[R30 + R27]> */
		/* 82252650h case   14:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + regs.R27 + 0x00000000) );
		/* 82252650h case   14:*/		return 0x82252654;
		  /* 82252654h */ case   15:  		/* cmplwi CR0, R11, 0 */
		/* 82252654h case   15:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82252654h case   15:*/		return 0x82252658;
		  /* 82252658h */ case   16:  		/* bc 12, CR0_EQ, 28 */
		/* 82252658h case   16:*/		if ( regs.CR[0].eq ) { return 0x82252674;  }
		/* 82252658h case   16:*/		return 0x8225265C;
		  /* 8225265Ch */ case   17:  		/* mr R6, R20 */
		/* 8225265Ch case   17:*/		regs.R6 = regs.R20;
		/* 8225265Ch case   17:*/		return 0x82252660;
		  /* 82252660h */ case   18:  		/* mr R5, R28 */
		/* 82252660h case   18:*/		regs.R5 = regs.R28;
		/* 82252660h case   18:*/		return 0x82252664;
		  /* 82252664h */ case   19:  		/* mr R4, R21 */
		/* 82252664h case   19:*/		regs.R4 = regs.R21;
		/* 82252664h case   19:*/		return 0x82252668;
		  /* 82252668h */ case   20:  		/* li R7, 210 */
		/* 82252668h case   20:*/		cpu::op::li<0>(regs,&regs.R7,0xD2);
		/* 82252668h case   20:*/		return 0x8225266C;
		  /* 8225266Ch */ case   21:  		/* li R3, 0 */
		/* 8225266Ch case   21:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225266Ch case   21:*/		return 0x82252670;
		  /* 82252670h */ case   22:  		/* bl -1026664 */
		/* 82252670h case   22:*/		regs.LR = 0x82252674; return 0x82157C08;
		/* 82252670h case   22:*/		return 0x82252674;
	}
	return 0x82252674;
} // Block from 82252618h-82252674h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82252674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252674);
		  /* 82252674h */ case    0:  		/* mr R4, R30 */
		/* 82252674h case    0:*/		regs.R4 = regs.R30;
		/* 82252674h case    0:*/		return 0x82252678;
		  /* 82252678h */ case    1:  		/* mr R3, R26 */
		/* 82252678h case    1:*/		regs.R3 = regs.R26;
		/* 82252678h case    1:*/		return 0x8225267C;
		  /* 8225267Ch */ case    2:  		/* bl -1884 */
		/* 8225267Ch case    2:*/		regs.LR = 0x82252680; return 0x82251F20;
		/* 8225267Ch case    2:*/		return 0x82252680;
		  /* 82252680h */ case    3:  		/* or. R31, R3, R3 */
		/* 82252680h case    3:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 82252680h case    3:*/		return 0x82252684;
		  /* 82252684h */ case    4:  		/* bc 12, CR0_LT, 108 */
		/* 82252684h case    4:*/		if ( regs.CR[0].lt ) { return 0x822526F0;  }
		/* 82252684h case    4:*/		return 0x82252688;
		  /* 82252688h */ case    5:  		/* addi R11, R1, 96 */
		/* 82252688h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 82252688h case    5:*/		return 0x8225268C;
		  /* 8225268Ch */ case    6:  		/* lbzx R11, <#[R31 + R11]> */
		/* 8225268Ch case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8225268Ch case    6:*/		return 0x82252690;
		  /* 82252690h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 82252690h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82252690h case    7:*/		return 0x82252694;
		  /* 82252694h */ case    8:  		/* bc 4, CR0_EQ, 348 */
		/* 82252694h case    8:*/		if ( !regs.CR[0].eq ) { return 0x822527F0;  }
		/* 82252694h case    8:*/		return 0x82252698;
		  /* 82252698h */ case    9:  		/* cmpw CR6, R31, R30 */
		/* 82252698h case    9:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R30);
		/* 82252698h case    9:*/		return 0x8225269C;
		  /* 8225269Ch */ case   10:  		/* bc 12, CR6_EQ, 76 */
		/* 8225269Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x822526E8;  }
		/* 8225269Ch case   10:*/		return 0x822526A0;
		  /* 822526A0h */ case   11:  		/* addi R11, R26, 896 */
		/* 822526A0h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x380);
		/* 822526A0h case   11:*/		return 0x822526A4;
		  /* 822526A4h */ case   12:  		/* lbzx R10, <#[R11 + R30]> */
		/* 822526A4h case   12:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 822526A4h case   12:*/		return 0x822526A8;
		  /* 822526A8h */ case   13:  		/* cmplwi CR0, R10, 0 */
		/* 822526A8h case   13:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 822526A8h case   13:*/		return 0x822526AC;
		  /* 822526ACh */ case   14:  		/* bc 4, CR0_EQ, 16 */
		/* 822526ACh case   14:*/		if ( !regs.CR[0].eq ) { return 0x822526BC;  }
		/* 822526ACh case   14:*/		return 0x822526B0;
		  /* 822526B0h */ case   15:  		/* lbzx R11, <#[R11 + R31]> */
		/* 822526B0h case   15:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 822526B0h case   15:*/		return 0x822526B4;
		  /* 822526B4h */ case   16:  		/* cmplwi CR0, R11, 0 */
		/* 822526B4h case   16:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 822526B4h case   16:*/		return 0x822526B8;
		  /* 822526B8h */ case   17:  		/* bc 12, CR0_EQ, 28 */
		/* 822526B8h case   17:*/		if ( regs.CR[0].eq ) { return 0x822526D4;  }
		/* 822526B8h case   17:*/		return 0x822526BC;
	}
	return 0x822526BC;
} // Block from 82252674h-822526BCh (18 instructions)

//////////////////////////////////////////////////////
// Block at 822526BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822526BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822526BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822526BC);
		  /* 822526BCh */ case    0:  		/* mr R6, R20 */
		/* 822526BCh case    0:*/		regs.R6 = regs.R20;
		/* 822526BCh case    0:*/		return 0x822526C0;
		  /* 822526C0h */ case    1:  		/* mr R5, R29 */
		/* 822526C0h case    1:*/		regs.R5 = regs.R29;
		/* 822526C0h case    1:*/		return 0x822526C4;
		  /* 822526C4h */ case    2:  		/* mr R4, R21 */
		/* 822526C4h case    2:*/		regs.R4 = regs.R21;
		/* 822526C4h case    2:*/		return 0x822526C8;
		  /* 822526C8h */ case    3:  		/* li R7, 217 */
		/* 822526C8h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0xD9);
		/* 822526C8h case    3:*/		return 0x822526CC;
		  /* 822526CCh */ case    4:  		/* li R3, 0 */
		/* 822526CCh case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822526CCh case    4:*/		return 0x822526D0;
		  /* 822526D0h */ case    5:  		/* bl -1026760 */
		/* 822526D0h case    5:*/		regs.LR = 0x822526D4; return 0x82157C08;
		/* 822526D0h case    5:*/		return 0x822526D4;
	}
	return 0x822526D4;
} // Block from 822526BCh-822526D4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822526D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822526D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822526D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822526D4);
		  /* 822526D4h */ case    0:  		/* mr R6, R31 */
		/* 822526D4h case    0:*/		regs.R6 = regs.R31;
		/* 822526D4h case    0:*/		return 0x822526D8;
		  /* 822526D8h */ case    1:  		/* mr R5, R30 */
		/* 822526D8h case    1:*/		regs.R5 = regs.R30;
		/* 822526D8h case    1:*/		return 0x822526DC;
		  /* 822526DCh */ case    2:  		/* mr R4, R18 */
		/* 822526DCh case    2:*/		regs.R4 = regs.R18;
		/* 822526DCh case    2:*/		return 0x822526E0;
		  /* 822526E0h */ case    3:  		/* mr R3, R26 */
		/* 822526E0h case    3:*/		regs.R3 = regs.R26;
		/* 822526E0h case    3:*/		return 0x822526E4;
		  /* 822526E4h */ case    4:  		/* bl -1644 */
		/* 822526E4h case    4:*/		regs.LR = 0x822526E8; return 0x82252078;
		/* 822526E4h case    4:*/		return 0x822526E8;
	}
	return 0x822526E8;
} // Block from 822526D4h-822526E8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822526E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822526E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822526E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822526E8);
		  /* 822526E8h */ case    0:  		/* li R11, 1 */
		/* 822526E8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822526E8h case    0:*/		return 0x822526EC;
		  /* 822526ECh */ case    1:  		/* stbx R11, <#[R30 + R27]> */
		/* 822526ECh case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + regs.R27 + 0x00000000) );
		/* 822526ECh case    1:*/		return 0x822526F0;
	}
	return 0x822526F0;
} // Block from 822526E8h-822526F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822526F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822526F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822526F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822526F0);
		  /* 822526F0h */ case    0:  		/* addi R30, R30, 1 */
		/* 822526F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 822526F0h case    0:*/		return 0x822526F4;
		  /* 822526F4h */ case    1:  		/* cmpwi CR6, R30, 16 */
		/* 822526F4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000010);
		/* 822526F4h case    1:*/		return 0x822526F8;
		  /* 822526F8h */ case    2:  		/* bc 12, CR6_LT, -192 */
		/* 822526F8h case    2:*/		if ( regs.CR[6].lt ) { return 0x82252638;  }
		/* 822526F8h case    2:*/		return 0x822526FC;
		  /* 822526FCh */ case    3:  		/* lis R11, -32252 */
		/* 822526FCh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822526FCh case    3:*/		return 0x82252700;
		  /* 82252700h */ case    4:  		/* lis R10, -32252 */
		/* 82252700h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82252700h case    4:*/		return 0x82252704;
		  /* 82252704h */ case    5:  		/* lis R9, -32252 */
		/* 82252704h case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 82252704h case    5:*/		return 0x82252708;
		  /* 82252708h */ case    6:  		/* lis R8, -32252 */
		/* 82252708h case    6:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8204);
		/* 82252708h case    6:*/		return 0x8225270C;
		  /* 8225270Ch */ case    7:  		/* li R29, 0 */
		/* 8225270Ch case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8225270Ch case    7:*/		return 0x82252710;
		  /* 82252710h */ case    8:  		/* addi R30, R26, 912 */
		/* 82252710h case    8:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R26,0x390);
		/* 82252710h case    8:*/		return 0x82252714;
		  /* 82252714h */ case    9:  		/* subfic R28, R26, -880 */
		/* 82252714h case    9:*/		cpu::op::subfic<0>(regs,&regs.R28,regs.R26,0xFFFFFC90);
		/* 82252714h case    9:*/		return 0x82252718;
	}
	return 0x82252718;
} // Block from 822526F0h-82252718h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82252718h
// Function '?AssignInterpolator@LinkageInfo@XGRAPHICS@@QAAHW4RegType@R400Tables@@HPAVInterpolator@2@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252718);
		  /* 82252718h */ case    0:  		/* li R27, 2 */
		/* 82252718h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x2);
		/* 82252718h case    0:*/		return 0x8225271C;
		  /* 8225271Ch */ case    1:  		/* addi R25, R11, 17716 */
		/* 8225271Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R11,0x4534);
		/* 8225271Ch case    1:*/		return 0x82252720;
		  /* 82252720h */ case    2:  		/* addi R24, R10, 17700 */
		/* 82252720h case    2:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R10,0x4524);
		/* 82252720h case    2:*/		return 0x82252724;
		  /* 82252724h */ case    3:  		/* addi R23, R9, 17624 */
		/* 82252724h case    3:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R9,0x44D8);
		/* 82252724h case    3:*/		return 0x82252728;
		  /* 82252728h */ case    4:  		/* addi R22, R8, 17544 */
		/* 82252728h case    4:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R8,0x4488);
		/* 82252728h case    4:*/		return 0x8225272C;
		  /* 8225272Ch */ case    5:  		/* addi R11, R1, 96 */
		/* 8225272Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 8225272Ch case    5:*/		return 0x82252730;
		  /* 82252730h */ case    6:  		/* lbzx R31, <#[R29 + R11]> */
		/* 82252730h case    6:*/		cpu::mem::load8z( regs, &regs.R31, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 82252730h case    6:*/		return 0x82252734;
		  /* 82252734h */ case    7:  		/* cmplwi CR0, R31, 0 */
		/* 82252734h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 82252734h case    7:*/		return 0x82252738;
		  /* 82252738h */ case    8:  		/* bc 4, CR0_EQ, 52 */
		/* 82252738h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8225276C;  }
		/* 82252738h case    8:*/		return 0x8225273C;
		  /* 8225273Ch */ case    9:  		/* lwz R11, <#[R30]> */
		/* 8225273Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225273Ch case    9:*/		return 0x82252740;
		  /* 82252740h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 82252740h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82252740h case   10:*/		return 0x82252744;
		  /* 82252744h */ case   11:  		/* bc 12, CR6_EQ, 40 */
		/* 82252744h case   11:*/		if ( regs.CR[6].eq ) { return 0x8225276C;  }
		/* 82252744h case   11:*/		return 0x82252748;
		  /* 82252748h */ case   12:  		/* lwz R3, <#[R11 + 56]> */
		/* 82252748h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000038) );
		/* 82252748h case   12:*/		return 0x8225274C;
		  /* 8225274Ch */ case   13:  		/* cmpwi CR6, R3, 0 */
		/* 8225274Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8225274Ch case   13:*/		return 0x82252750;
		  /* 82252750h */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 82252750h case   14:*/		if ( regs.CR[6].eq ) { return 0x82252764;  }
		/* 82252750h case   14:*/		return 0x82252754;
		  /* 82252754h */ case   15:  		/* lwz R11, <#[R3]> */
		/* 82252754h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82252754h case   15:*/		return 0x82252758;
		  /* 82252758h */ case   16:  		/* lwz R11, <#[R11 + 96]> */
		/* 82252758h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000060) );
		/* 82252758h case   16:*/		return 0x8225275C;
		  /* 8225275Ch */ case   17:  		/* mtspr CTR, R11 */
		/* 8225275Ch case   17:*/		regs.CTR = regs.R11;
		/* 8225275Ch case   17:*/		return 0x82252760;
		  /* 82252760h */ case   18:  		/* bcctrl 20, CR0_LT */
		/* 82252760h case   18:*/		if ( 1 ) { regs.LR = 0x82252764; return (uint32)regs.CTR; }
		/* 82252760h case   18:*/		return 0x82252764;
	}
	return 0x82252764;
} // Block from 82252718h-82252764h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82252764h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252764( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252764) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252764);
		  /* 82252764h */ case    0:  		/* li R11, 0 */
		/* 82252764h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82252764h case    0:*/		return 0x82252768;
		  /* 82252768h */ case    1:  		/* stw R11, <#[R30]> */
		/* 82252768h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82252768h case    1:*/		return 0x8225276C;
	}
	return 0x8225276C;
} // Block from 82252764h-8225276Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225276Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225276C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225276C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225276C);
		  /* 8225276Ch */ case    0:  		/* mr R4, R29 */
		/* 8225276Ch case    0:*/		regs.R4 = regs.R29;
		/* 8225276Ch case    0:*/		return 0x82252770;
		  /* 82252770h */ case    1:  		/* mr R3, R26 */
		/* 82252770h case    1:*/		regs.R3 = regs.R26;
		/* 82252770h case    1:*/		return 0x82252774;
		  /* 82252774h */ case    2:  		/* bl -2308 */
		/* 82252774h case    2:*/		regs.LR = 0x82252778; return 0x82251E70;
		/* 82252774h case    2:*/		return 0x82252778;
		  /* 82252778h */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82252778h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82252778h case    3:*/		return 0x8225277C;
		  /* 8225277Ch */ case    4:  		/* bc 12, CR0_EQ, 632 */
		/* 8225277Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x822529F4;  }
		/* 8225277Ch case    4:*/		return 0x82252780;
		  /* 82252780h */ case    5:  		/* lwz R4, <#[R30 - 912]> */
		/* 82252780h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0xFFFFFC70) );
		/* 82252780h case    5:*/		return 0x82252784;
		  /* 82252784h */ case    6:  		/* cmpwi CR6, R4, 18 */
		/* 82252784h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000012);
		/* 82252784h case    6:*/		return 0x82252788;
		  /* 82252788h */ case    7:  		/* bc 12, CR6_EQ, 8 */
		/* 82252788h case    7:*/		if ( regs.CR[6].eq ) { return 0x82252790;  }
		/* 82252788h case    7:*/		return 0x8225278C;
		  /* 8225278Ch */ case    8:  		/* mr R17, R29 */
		/* 8225278Ch case    8:*/		regs.R17 = regs.R29;
		/* 8225278Ch case    8:*/		return 0x82252790;
	}
	return 0x82252790;
} // Block from 8225276Ch-82252790h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82252790h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252790);
		  /* 82252790h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82252790h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82252790h case    0:*/		return 0x82252794;
		  /* 82252794h */ case    1:  		/* bc 4, CR6_EQ, 396 */
		/* 82252794h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82252920;  }
		/* 82252794h case    1:*/		return 0x82252798;
		  /* 82252798h */ case    2:  		/* li R10, 4 */
		/* 82252798h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 82252798h case    2:*/		return 0x8225279C;
		  /* 8225279Ch */ case    3:  		/* li R9, 0 */
		/* 8225279Ch case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8225279Ch case    3:*/		return 0x822527A0;
		  /* 822527A0h */ case    4:  		/* li R11, 0 */
		/* 822527A0h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822527A0h case    4:*/		return 0x822527A4;
		  /* 822527A4h */ case    5:  		/* add R8, R28, R30 */
		/* 822527A4h case    5:*/		cpu::op::add<0>(regs,&regs.R8,regs.R28,regs.R30);
		/* 822527A4h case    5:*/		return 0x822527A8;
		  /* 822527A8h */ case    6:  		/* mtspr CTR, R10 */
		/* 822527A8h case    6:*/		regs.CTR = regs.R10;
		/* 822527A8h case    6:*/		return 0x822527AC;
		  /* 822527ACh */ case    7:  		/* add R10, R8, R11 */
		/* 822527ACh case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R11);
		/* 822527ACh case    7:*/		return 0x822527B0;
		  /* 822527B0h */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 822527B0h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 822527B0h case    8:*/		return 0x822527B4;
		  /* 822527B4h */ case    9:  		/* lwzx R10, <#[R10 + R26]> */
		/* 822527B4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R26 + 0x00000000) );
		/* 822527B4h case    9:*/		return 0x822527B8;
		  /* 822527B8h */ case   10:  		/* cmpwi CR6, R10, 2 */
		/* 822527B8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000002);
		/* 822527B8h case   10:*/		return 0x822527BC;
		  /* 822527BCh */ case   11:  		/* bc 4, CR6_EQ, 76 */
		/* 822527BCh case   11:*/		if ( !regs.CR[6].eq ) { return 0x82252808;  }
		/* 822527BCh case   11:*/		return 0x822527C0;
		  /* 822527C0h */ case   12:  		/* li R9, 1 */
		/* 822527C0h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 822527C0h case   12:*/		return 0x822527C4;
		  /* 822527C4h */ case   13:  		/* addi R10, R1, 80 */
		/* 822527C4h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 822527C4h case   13:*/		return 0x822527C8;
		  /* 822527C8h */ case   14:  		/* stbx R27, <#[R11 + R10]> */
		/* 822527C8h case   14:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 822527C8h case   14:*/		return 0x822527CC;
		  /* 822527CCh */ case   15:  		/* addi R11, R11, 1 */
		/* 822527CCh case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822527CCh case   15:*/		return 0x822527D0;
		  /* 822527D0h */ case   16:  		/* bc 16, CR0_LT, -36 */
		/* 822527D0h case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x822527AC;  }
		/* 822527D0h case   16:*/		return 0x822527D4;
		  /* 822527D4h */ case   17:  		/* rlwinm. R11, R9, 0, 24, 31 */
		/* 822527D4h case   17:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R9);
		/* 822527D4h case   17:*/		return 0x822527D8;
		  /* 822527D8h */ case   18:  		/* bc 12, CR0_EQ, 540 */
		/* 822527D8h case   18:*/		if ( regs.CR[0].eq ) { return 0x822529F4;  }
		/* 822527D8h case   18:*/		return 0x822527DC;
		  /* 822527DCh */ case   19:  		/* cmpwi CR6, R4, 33 */
		/* 822527DCh case   19:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000021);
		/* 822527DCh case   19:*/		return 0x822527E0;
		  /* 822527E0h */ case   20:  		/* bc 4, CR6_EQ, 68 */
		/* 822527E0h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82252824;  }
		/* 822527E0h case   20:*/		return 0x822527E4;
		  /* 822527E4h */ case   21:  		/* mr R31, R19 */
		/* 822527E4h case   21:*/		regs.R31 = regs.R19;
		/* 822527E4h case   21:*/		return 0x822527E8;
		  /* 822527E8h */ case   22:  		/* addi R19, R19, 1 */
		/* 822527E8h case   22:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x1);
		/* 822527E8h case   22:*/		return 0x822527EC;
		  /* 822527ECh */ case   23:  		/* b 60 */
		/* 822527ECh case   23:*/		return 0x82252828;
		/* 822527ECh case   23:*/		return 0x822527F0;
	}
	return 0x822527F0;
} // Block from 82252790h-822527F0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 822527F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822527F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822527F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822527F0);
		  /* 822527F0h */ case    0:  		/* lwz R11, <#[R26 + 1876]> */
		/* 822527F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000754) );
		/* 822527F0h case    0:*/		return 0x822527F4;
		  /* 822527F4h */ case    1:  		/* li R10, 24 */
		/* 822527F4h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x18);
		/* 822527F4h case    1:*/		return 0x822527F8;
		  /* 822527F8h */ case    2:  		/* li R4, 1 */
		/* 822527F8h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822527F8h case    2:*/		return 0x822527FC;
		  /* 822527FCh */ case    3:  		/* addi R3, R11, 16 */
		/* 822527FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 822527FCh case    3:*/		return 0x82252800;
		  /* 82252800h */ case    4:  		/* stw R10, <#[R11 + 1364]> */
		/* 82252800h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000554) );
		/* 82252800h case    4:*/		return 0x82252804;
		  /* 82252804h */ case    5:  		/* bl 91820 */
		/* 82252804h case    5:*/		regs.LR = 0x82252808; return 0x82268EB0;
		/* 82252804h case    5:*/		return 0x82252808;
	}
	return 0x82252808;
} // Block from 822527F0h-82252808h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82252808h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252808);
		  /* 82252808h */ case    0:  		/* cmpwi CR6, R10, 4 */
		/* 82252808h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000004);
		/* 82252808h case    0:*/		return 0x8225280C;
		  /* 8225280Ch */ case    1:  		/* bc 4, CR6_EQ, -72 */
		/* 8225280Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x822527C4;  }
		/* 8225280Ch case    1:*/		return 0x82252810;
		  /* 82252810h */ case    2:  		/* addi R10, R1, 80 */
		/* 82252810h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82252810h case    2:*/		return 0x82252814;
		  /* 82252814h */ case    3:  		/* li R7, 3 */
		/* 82252814h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 82252814h case    3:*/		return 0x82252818;
		  /* 82252818h */ case    4:  		/* li R9, 1 */
		/* 82252818h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82252818h case    4:*/		return 0x8225281C;
		  /* 8225281Ch */ case    5:  		/* stbx R7, <#[R11 + R10]> */
		/* 8225281Ch case    5:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8225281Ch case    5:*/		return 0x82252820;
		  /* 82252820h */ case    6:  		/* b -84 */
		/* 82252820h case    6:*/		return 0x822527CC;
		/* 82252820h case    6:*/		return 0x82252824;
	}
	return 0x82252824;
} // Block from 82252808h-82252824h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82252824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252824);
		  /* 82252824h */ case    0:  		/* lwz R31, <#[R30 - 848]> */
		/* 82252824h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0xFFFFFCB0) );
		/* 82252824h case    0:*/		return 0x82252828;
	}
	return 0x82252828;
} // Block from 82252824h-82252828h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82252828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252828);
		  /* 82252828h */ case    0:  		/* mr R5, R31 */
		/* 82252828h case    0:*/		regs.R5 = regs.R31;
		/* 82252828h case    0:*/		return 0x8225282C;
		  /* 8225282Ch */ case    1:  		/* lwz R3, <#[R18 + 172]> */
		/* 8225282Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R18 + 0x000000AC) );
		/* 8225282Ch case    1:*/		return 0x82252830;
	}
	return 0x82252830;
} // Block from 82252828h-82252830h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252830h
// Function '?EstablishInterpolatorUsage@LinkageInfo@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252830);
		  /* 82252830h */ case    0:  		/* bl -55592 */
		/* 82252830h case    0:*/		regs.LR = 0x82252834; return 0x82244F08;
		/* 82252830h case    0:*/		return 0x82252834;
		  /* 82252834h */ case    1:  		/* cmplwi CR0, R3, 0 */
		/* 82252834h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82252834h case    1:*/		return 0x82252838;
		  /* 82252838h */ case    2:  		/* bc 12, CR0_EQ, 28 */
		/* 82252838h case    2:*/		if ( regs.CR[0].eq ) { return 0x82252854;  }
		/* 82252838h case    2:*/		return 0x8225283C;
		  /* 8225283Ch */ case    3:  		/* mr R6, R20 */
		/* 8225283Ch case    3:*/		regs.R6 = regs.R20;
		/* 8225283Ch case    3:*/		return 0x82252840;
		  /* 82252840h */ case    4:  		/* mr R5, R22 */
		/* 82252840h case    4:*/		regs.R5 = regs.R22;
		/* 82252840h case    4:*/		return 0x82252844;
		  /* 82252844h */ case    5:  		/* mr R4, R21 */
		/* 82252844h case    5:*/		regs.R4 = regs.R21;
		/* 82252844h case    5:*/		return 0x82252848;
		  /* 82252848h */ case    6:  		/* li R7, 282 */
		/* 82252848h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x11A);
		/* 82252848h case    6:*/		return 0x8225284C;
		  /* 8225284Ch */ case    7:  		/* li R3, 0 */
		/* 8225284Ch case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225284Ch case    7:*/		return 0x82252850;
		  /* 82252850h */ case    8:  		/* bl -1027144 */
		/* 82252850h case    8:*/		regs.LR = 0x82252854; return 0x82157C08;
		/* 82252850h case    8:*/		return 0x82252854;
	}
	return 0x82252854;
} // Block from 82252830h-82252854h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82252854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252854);
		  /* 82252854h */ case    0:  		/* mr R5, R31 */
		/* 82252854h case    0:*/		regs.R5 = regs.R31;
		/* 82252854h case    0:*/		return 0x82252858;
		  /* 82252858h */ case    1:  		/* lwz R3, <#[R18 + 172]> */
		/* 82252858h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R18 + 0x000000AC) );
		/* 82252858h case    1:*/		return 0x8225285C;
		  /* 8225285Ch */ case    2:  		/* lwz R4, <#[R30 - 912]> */
		/* 8225285Ch case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0xFFFFFC70) );
		/* 8225285Ch case    2:*/		return 0x82252860;
		  /* 82252860h */ case    3:  		/* bl -55608 */
		/* 82252860h case    3:*/		regs.LR = 0x82252864; return 0x82244F28;
		/* 82252860h case    3:*/		return 0x82252864;
		  /* 82252864h */ case    4:  		/* lwz R11, <#[R3 + 16]> */
		/* 82252864h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82252864h case    4:*/		return 0x82252868;
		  /* 82252868h */ case    5:  		/* mr R31, R3 */
		/* 82252868h case    5:*/		regs.R31 = regs.R3;
		/* 82252868h case    5:*/		return 0x8225286C;
		  /* 8225286Ch */ case    6:  		/* cmpw CR6, R11, R29 */
		/* 8225286Ch case    6:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R29);
		/* 8225286Ch case    6:*/		return 0x82252870;
		  /* 82252870h */ case    7:  		/* bc 12, CR6_EQ, 80 */
		/* 82252870h case    7:*/		if ( regs.CR[6].eq ) { return 0x822528C0;  }
		/* 82252870h case    7:*/		return 0x82252874;
		  /* 82252874h */ case    8:  		/* add R10, R29, R26 */
		/* 82252874h case    8:*/		cpu::op::add<0>(regs,&regs.R10,regs.R29,regs.R26);
		/* 82252874h case    8:*/		return 0x82252878;
		  /* 82252878h */ case    9:  		/* lbz R10, <#[R10 + 896]> */
		/* 82252878h case    9:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000380) );
		/* 82252878h case    9:*/		return 0x8225287C;
		  /* 8225287Ch */ case   10:  		/* cmplwi CR0, R10, 0 */
		/* 8225287Ch case   10:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 8225287Ch case   10:*/		return 0x82252880;
		  /* 82252880h */ case   11:  		/* bc 4, CR0_EQ, 20 */
		/* 82252880h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82252894;  }
		/* 82252880h case   11:*/		return 0x82252884;
		  /* 82252884h */ case   12:  		/* add R11, R11, R26 */
		/* 82252884h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R26);
		/* 82252884h case   12:*/		return 0x82252888;
		  /* 82252888h */ case   13:  		/* lbz R11, <#[R11 + 896]> */
		/* 82252888h case   13:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000380) );
		/* 82252888h case   13:*/		return 0x8225288C;
		  /* 8225288Ch */ case   14:  		/* cmplwi CR0, R11, 0 */
		/* 8225288Ch case   14:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8225288Ch case   14:*/		return 0x82252890;
		  /* 82252890h */ case   15:  		/* bc 12, CR0_EQ, 28 */
		/* 82252890h case   15:*/		if ( regs.CR[0].eq ) { return 0x822528AC;  }
		/* 82252890h case   15:*/		return 0x82252894;
	}
	return 0x82252894;
} // Block from 82252854h-82252894h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82252894h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252894( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252894) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252894);
		  /* 82252894h */ case    0:  		/* mr R6, R20 */
		/* 82252894h case    0:*/		regs.R6 = regs.R20;
		/* 82252894h case    0:*/		return 0x82252898;
		  /* 82252898h */ case    1:  		/* mr R5, R23 */
		/* 82252898h case    1:*/		regs.R5 = regs.R23;
		/* 82252898h case    1:*/		return 0x8225289C;
		  /* 8225289Ch */ case    2:  		/* mr R4, R21 */
		/* 8225289Ch case    2:*/		regs.R4 = regs.R21;
		/* 8225289Ch case    2:*/		return 0x822528A0;
		  /* 822528A0h */ case    3:  		/* li R7, 288 */
		/* 822528A0h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x120);
		/* 822528A0h case    3:*/		return 0x822528A4;
		  /* 822528A4h */ case    4:  		/* li R3, 0 */
		/* 822528A4h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822528A4h case    4:*/		return 0x822528A8;
		  /* 822528A8h */ case    5:  		/* bl -1027232 */
		/* 822528A8h case    5:*/		regs.LR = 0x822528AC; return 0x82157C08;
		/* 822528A8h case    5:*/		return 0x822528AC;
	}
	return 0x822528AC;
} // Block from 82252894h-822528ACh (6 instructions)

//////////////////////////////////////////////////////
// Block at 822528ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822528AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822528AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822528AC);
		  /* 822528ACh */ case    0:  		/* mr R5, R29 */
		/* 822528ACh case    0:*/		regs.R5 = regs.R29;
		/* 822528ACh case    0:*/		return 0x822528B0;
	}
	return 0x822528B0;
} // Block from 822528ACh-822528B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822528B0h
// Function '?BuildOutputLinkage@LinkageInfo@XGRAPHICS@@QAAXAAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822528B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822528B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822528B0);
		  /* 822528B0h */ case    0:  		/* lwz R6, <#[R31 + 16]> */
		/* 822528B0h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000010) );
		/* 822528B0h case    0:*/		return 0x822528B4;
		  /* 822528B4h */ case    1:  		/* mr R4, R18 */
		/* 822528B4h case    1:*/		regs.R4 = regs.R18;
		/* 822528B4h case    1:*/		return 0x822528B8;
		  /* 822528B8h */ case    2:  		/* mr R3, R26 */
		/* 822528B8h case    2:*/		regs.R3 = regs.R26;
		/* 822528B8h case    2:*/		return 0x822528BC;
		  /* 822528BCh */ case    3:  		/* bl -2116 */
		/* 822528BCh case    3:*/		regs.LR = 0x822528C0; return 0x82252078;
		/* 822528BCh case    3:*/		return 0x822528C0;
	}
	return 0x822528C0;
} // Block from 822528B0h-822528C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822528C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822528C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822528C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822528C0);
		  /* 822528C0h */ case    0:  		/* lwz R11, <#[R26 + 1876]> */
		/* 822528C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000754) );
		/* 822528C0h case    0:*/		return 0x822528C4;
		  /* 822528C4h */ case    1:  		/* li R4, 964 */
		/* 822528C4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 822528C4h case    1:*/		return 0x822528C8;
		  /* 822528C8h */ case    2:  		/* lwz R16, <#[R11 + 1452]> */
		/* 822528C8h case    2:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R11 + 0x000005AC) );
		/* 822528C8h case    2:*/		return 0x822528CC;
		  /* 822528CCh */ case    3:  		/* mr R3, R16 */
		/* 822528CCh case    3:*/		regs.R3 = regs.R16;
		/* 822528CCh case    3:*/		return 0x822528D0;
		  /* 822528D0h */ case    4:  		/* bl -222232 */
		/* 822528D0h case    4:*/		regs.LR = 0x822528D4; return 0x8221C4B8;
		/* 822528D0h case    4:*/		return 0x822528D4;
		  /* 822528D4h */ case    5:  		/* mr R11, R3 */
		/* 822528D4h case    5:*/		regs.R11 = regs.R3;
		/* 822528D4h case    5:*/		return 0x822528D8;
		  /* 822528D8h */ case    6:  		/* addic. R3, R3, 4 */
		/* 822528D8h case    6:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 822528D8h case    6:*/		return 0x822528DC;
		  /* 822528DCh */ case    7:  		/* stw R16, <#[R11]> */
		/* 822528DCh case    7:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R11 + 0x00000000) );
		/* 822528DCh case    7:*/		return 0x822528E0;
		  /* 822528E0h */ case    8:  		/* bc 12, CR0_EQ, 28 */
		/* 822528E0h case    8:*/		if ( regs.CR[0].eq ) { return 0x822528FC;  }
		/* 822528E0h case    8:*/		return 0x822528E4;
		  /* 822528E4h */ case    9:  		/* mr R4, R31 */
		/* 822528E4h case    9:*/		regs.R4 = regs.R31;
		/* 822528E4h case    9:*/		return 0x822528E8;
		  /* 822528E8h */ case   10:  		/* lwz R5, <#[R1 + 80]> */
		/* 822528E8h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 822528E8h case   10:*/		return 0x822528EC;
		  /* 822528ECh */ case   11:  		/* lwz R6, <#[R26 + 1876]> */
		/* 822528ECh case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R26 + 0x00000754) );
		/* 822528ECh case   11:*/		return 0x822528F0;
		  /* 822528F0h */ case   12:  		/* bl 18696 */
		/* 822528F0h case   12:*/		regs.LR = 0x822528F4; return 0x822571F8;
		/* 822528F0h case   12:*/		return 0x822528F4;
		  /* 822528F4h */ case   13:  		/* mr R31, R3 */
		/* 822528F4h case   13:*/		regs.R31 = regs.R3;
		/* 822528F4h case   13:*/		return 0x822528F8;
		  /* 822528F8h */ case   14:  		/* b 8 */
		/* 822528F8h case   14:*/		return 0x82252900;
		/* 822528F8h case   14:*/		return 0x822528FC;
	}
	return 0x822528FC;
} // Block from 822528C0h-822528FCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 822528FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822528FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822528FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822528FC);
		  /* 822528FCh */ case    0:  		/* li R31, 0 */
		/* 822528FCh case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 822528FCh case    0:*/		return 0x82252900;
	}
	return 0x82252900;
} // Block from 822528FCh-82252900h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82252900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252900);
		  /* 82252900h */ case    0:  		/* mr R4, R31 */
		/* 82252900h case    0:*/		regs.R4 = regs.R31;
		/* 82252900h case    0:*/		return 0x82252904;
		  /* 82252904h */ case    1:  		/* lwz R3, <#[R18 + 168]> */
		/* 82252904h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R18 + 0x000000A8) );
		/* 82252904h case    1:*/		return 0x82252908;
		  /* 82252908h */ case    2:  		/* bl 26152 */
		/* 82252908h case    2:*/		regs.LR = 0x8225290C; return 0x82258F30;
		/* 82252908h case    2:*/		return 0x8225290C;
		  /* 8225290Ch */ case    3:  		/* lwz R3, <#[R18 + 96]> */
		/* 8225290Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R18 + 0x00000060) );
		/* 8225290Ch case    3:*/		return 0x82252910;
		  /* 82252910h */ case    4:  		/* lwz R4, <#[R3 + 4]> */
		/* 82252910h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82252910h case    4:*/		return 0x82252914;
		  /* 82252914h */ case    5:  		/* bl 4524 */
		/* 82252914h case    5:*/		regs.LR = 0x82252918; return 0x82253AC0;
		/* 82252914h case    5:*/		return 0x82252918;
		  /* 82252918h */ case    6:  		/* stw R31, <#[R3]> */
		/* 82252918h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82252918h case    6:*/		return 0x8225291C;
		  /* 8225291Ch */ case    7:  		/* b 216 */
		/* 8225291Ch case    7:*/		return 0x822529F4;
		/* 8225291Ch case    7:*/		return 0x82252920;
	}
	return 0x82252920;
} // Block from 82252900h-82252920h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82252920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252920);
		  /* 82252920h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82252920h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82252920h case    0:*/		return 0x82252924;
		  /* 82252924h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82252924h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82252924h case    1:*/		return 0x82252928;
		  /* 82252928h */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 82252928h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82252944;  }
		/* 82252928h case    2:*/		return 0x8225292C;
		  /* 8225292Ch */ case    3:  		/* mr R6, R20 */
		/* 8225292Ch case    3:*/		regs.R6 = regs.R20;
		/* 8225292Ch case    3:*/		return 0x82252930;
		  /* 82252930h */ case    4:  		/* mr R5, R24 */
		/* 82252930h case    4:*/		regs.R5 = regs.R24;
		/* 82252930h case    4:*/		return 0x82252934;
		  /* 82252934h */ case    5:  		/* mr R4, R21 */
		/* 82252934h case    5:*/		regs.R4 = regs.R21;
		/* 82252934h case    5:*/		return 0x82252938;
		  /* 82252938h */ case    6:  		/* li R7, 297 */
		/* 82252938h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x129);
		/* 82252938h case    6:*/		return 0x8225293C;
		  /* 8225293Ch */ case    7:  		/* li R3, 0 */
		/* 8225293Ch case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225293Ch case    7:*/		return 0x82252940;
		  /* 82252940h */ case    8:  		/* bl -1027384 */
		/* 82252940h case    8:*/		regs.LR = 0x82252944; return 0x82157C08;
		/* 82252940h case    8:*/		return 0x82252944;
	}
	return 0x82252944;
} // Block from 82252920h-82252944h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82252944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252944);
		  /* 82252944h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82252944h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82252944h case    0:*/		return 0x82252948;
		  /* 82252948h */ case    1:  		/* lwz R31, <#[R11 + 56]> */
		/* 82252948h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000038) );
		/* 82252948h case    1:*/		return 0x8225294C;
		  /* 8225294Ch */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 8225294Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8225294Ch case    2:*/		return 0x82252950;
		  /* 82252950h */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 82252950h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8225296C;  }
		/* 82252950h case    3:*/		return 0x82252954;
		  /* 82252954h */ case    4:  		/* mr R6, R20 */
		/* 82252954h case    4:*/		regs.R6 = regs.R20;
		/* 82252954h case    4:*/		return 0x82252958;
		  /* 82252958h */ case    5:  		/* mr R5, R25 */
		/* 82252958h case    5:*/		regs.R5 = regs.R25;
		/* 82252958h case    5:*/		return 0x8225295C;
		  /* 8225295Ch */ case    6:  		/* mr R4, R21 */
		/* 8225295Ch case    6:*/		regs.R4 = regs.R21;
		/* 8225295Ch case    6:*/		return 0x82252960;
		  /* 82252960h */ case    7:  		/* li R7, 301 */
		/* 82252960h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x12D);
		/* 82252960h case    7:*/		return 0x82252964;
		  /* 82252964h */ case    8:  		/* li R3, 0 */
		/* 82252964h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82252964h case    8:*/		return 0x82252968;
		  /* 82252968h */ case    9:  		/* bl -1027424 */
		/* 82252968h case    9:*/		regs.LR = 0x8225296C; return 0x82157C08;
		/* 82252968h case    9:*/		return 0x8225296C;
	}
	return 0x8225296C;
} // Block from 82252944h-8225296Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8225296Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225296C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225296C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225296C);
		  /* 8225296Ch */ case    0:  		/* lwz R9, <#[R31 + 128]> */
		/* 8225296Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000080) );
		/* 8225296Ch case    0:*/		return 0x82252970;
		  /* 82252970h */ case    1:  		/* li R10, 4 */
		/* 82252970h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 82252970h case    1:*/		return 0x82252974;
		  /* 82252974h */ case    2:  		/* li R11, 0 */
		/* 82252974h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82252974h case    2:*/		return 0x82252978;
		  /* 82252978h */ case    3:  		/* mtspr CTR, R10 */
		/* 82252978h case    3:*/		regs.CTR = regs.R10;
		/* 82252978h case    3:*/		return 0x8225297C;
		  /* 8225297Ch */ case    4:  		/* stw R9, <#[R1 + 84]> */
		/* 8225297Ch case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 8225297Ch case    4:*/		return 0x82252980;
	}
	return 0x82252980;
} // Block from 8225296Ch-82252980h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82252980h
// Function '?IsRequired@LinkageInfo@XGRAPHICS@@AAA_NH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252980);
		  /* 82252980h */ case    0:  		/* addi R9, R1, 84 */
		/* 82252980h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x54);
		/* 82252980h case    0:*/		return 0x82252984;
		  /* 82252984h */ case    1:  		/* lbzx R10, <#[R11 + R9]> */
		/* 82252984h case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82252984h case    1:*/		return 0x82252988;
		  /* 82252988h */ case    2:  		/* cmplwi CR6, R10, 1 */
		/* 82252988h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 82252988h case    2:*/		return 0x8225298C;
		  /* 8225298Ch */ case    3:  		/* bc 4, CR6_EQ, 52 */
		/* 8225298Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x822529C0;  }
		/* 8225298Ch case    3:*/		return 0x82252990;
		  /* 82252990h */ case    4:  		/* add R10, R28, R30 */
		/* 82252990h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R28,regs.R30);
		/* 82252990h case    4:*/		return 0x82252994;
		  /* 82252994h */ case    5:  		/* add R10, R10, R11 */
		/* 82252994h case    5:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82252994h case    5:*/		return 0x82252998;
		  /* 82252998h */ case    6:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82252998h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82252998h case    6:*/		return 0x8225299C;
		  /* 8225299Ch */ case    7:  		/* lwzx R10, <#[R10 + R26]> */
		/* 8225299Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R26 + 0x00000000) );
		/* 8225299Ch case    7:*/		return 0x822529A0;
		  /* 822529A0h */ case    8:  		/* cmpwi CR6, R10, 2 */
		/* 822529A0h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000002);
		/* 822529A0h case    8:*/		return 0x822529A4;
		  /* 822529A4h */ case    9:  		/* bc 12, CR6_EQ, 60 */
		/* 822529A4h case    9:*/		if ( regs.CR[6].eq ) { return 0x822529E0;  }
		/* 822529A4h case    9:*/		return 0x822529A8;
		  /* 822529A8h */ case   10:  		/* addi R10, R10, -4 */
		/* 822529A8h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 822529A8h case   10:*/		return 0x822529AC;
		  /* 822529ACh */ case   11:  		/* cntlzw R10, R10 */
		/* 822529ACh case   11:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 822529ACh case   11:*/		return 0x822529B0;
		  /* 822529B0h */ case   12:  		/* rlwinm R10, R10, 27, 31, 31 */
		/* 822529B0h case   12:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R10);
		/* 822529B0h case   12:*/		return 0x822529B4;
		  /* 822529B4h */ case   13:  		/* addi R10, R10, 2 */
		/* 822529B4h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 822529B4h case   13:*/		return 0x822529B8;
		  /* 822529B8h */ case   14:  		/* stbx R10, <#[R11 + R9]> */
		/* 822529B8h case   14:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 822529B8h case   14:*/		return 0x822529BC;
		  /* 822529BCh */ case   15:  		/* b 40 */
		/* 822529BCh case   15:*/		return 0x822529E4;
		/* 822529BCh case   15:*/		return 0x822529C0;
	}
	return 0x822529C0;
} // Block from 82252980h-822529C0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822529C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822529C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822529C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822529C0);
		  /* 822529C0h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 822529C0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 822529C0h case    0:*/		return 0x822529C4;
		  /* 822529C4h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 822529C4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x822529E4;  }
		/* 822529C4h case    1:*/		return 0x822529C8;
		  /* 822529C8h */ case    2:  		/* add R10, R28, R30 */
		/* 822529C8h case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R28,regs.R30);
		/* 822529C8h case    2:*/		return 0x822529CC;
		  /* 822529CCh */ case    3:  		/* add R10, R10, R11 */
		/* 822529CCh case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 822529CCh case    3:*/		return 0x822529D0;
		  /* 822529D0h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 822529D0h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 822529D0h case    4:*/		return 0x822529D4;
		  /* 822529D4h */ case    5:  		/* lwzx R10, <#[R10 + R26]> */
		/* 822529D4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R26 + 0x00000000) );
		/* 822529D4h case    5:*/		return 0x822529D8;
		  /* 822529D8h */ case    6:  		/* cmpwi CR6, R10, 0 */
		/* 822529D8h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 822529D8h case    6:*/		return 0x822529DC;
		  /* 822529DCh */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 822529DCh case    7:*/		if ( !regs.CR[6].eq ) { return 0x822529E4;  }
		/* 822529DCh case    7:*/		return 0x822529E0;
	}
	return 0x822529E0;
} // Block from 822529C0h-822529E0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822529E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822529E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822529E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822529E0);
		  /* 822529E0h */ case    0:  		/* stbx R27, <#[R11 + R9]> */
		/* 822529E0h case    0:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 822529E0h case    0:*/		return 0x822529E4;
	}
	return 0x822529E4;
} // Block from 822529E0h-822529E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822529E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822529E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822529E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822529E4);
		  /* 822529E4h */ case    0:  		/* addi R11, R11, 1 */
		/* 822529E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822529E4h case    0:*/		return 0x822529E8;
		  /* 822529E8h */ case    1:  		/* bc 16, CR0_LT, -104 */
		/* 822529E8h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82252980;  }
		/* 822529E8h case    1:*/		return 0x822529EC;
		  /* 822529ECh */ case    2:  		/* lwz R11, <#[R1 + 84]> */
		/* 822529ECh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 822529ECh case    2:*/		return 0x822529F0;
		  /* 822529F0h */ case    3:  		/* stw R11, <#[R31 + 128]> */
		/* 822529F0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 822529F0h case    3:*/		return 0x822529F4;
	}
	return 0x822529F4;
} // Block from 822529E4h-822529F4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822529F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822529F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822529F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822529F4);
		  /* 822529F4h */ case    0:  		/* addi R29, R29, 1 */
		/* 822529F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 822529F4h case    0:*/		return 0x822529F8;
		  /* 822529F8h */ case    1:  		/* addi R30, R30, 4 */
		/* 822529F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 822529F8h case    1:*/		return 0x822529FC;
		  /* 822529FCh */ case    2:  		/* cmpwi CR6, R29, 16 */
		/* 822529FCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000010);
		/* 822529FCh case    2:*/		return 0x82252A00;
		  /* 82252A00h */ case    3:  		/* bc 12, CR6_LT, -724 */
		/* 82252A00h case    3:*/		if ( regs.CR[6].lt ) { return 0x8225272C;  }
		/* 82252A00h case    3:*/		return 0x82252A04;
		  /* 82252A04h */ case    4:  		/* b 320 */
		/* 82252A04h case    4:*/		return 0x82252B44;
		/* 82252A04h case    4:*/		return 0x82252A08;
	}
	return 0x82252A08;
} // Block from 822529F4h-82252A08h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82252A08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252A08);
		  /* 82252A08h */ case    0:  		/* cmpw CR6, R6, R7 */
		/* 82252A08h case    0:*/		cpu::op::cmpw<6>(regs,regs.R6,regs.R7);
		/* 82252A08h case    0:*/		return 0x82252A0C;
		  /* 82252A0Ch */ case    1:  		/* bc 4, CR6_LT, 192 */
		/* 82252A0Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x82252ACC;  }
		/* 82252A0Ch case    1:*/		return 0x82252A10;
		  /* 82252A10h */ case    2:  		/* cmpwi CR6, R5, 19 */
		/* 82252A10h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000013);
		/* 82252A10h case    2:*/		return 0x82252A14;
		  /* 82252A14h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82252A14h case    3:*/		if ( regs.CR[6].eq ) { return 0x82252A20;  }
		/* 82252A14h case    3:*/		return 0x82252A18;
		  /* 82252A18h */ case    4:  		/* cmpwi CR6, R5, 33 */
		/* 82252A18h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000021);
		/* 82252A18h case    4:*/		return 0x82252A1C;
		  /* 82252A1Ch */ case    5:  		/* bc 4, CR6_EQ, 176 */
		/* 82252A1Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x82252ACC;  }
		/* 82252A1Ch case    5:*/		return 0x82252A20;
	}
	return 0x82252A20;
} // Block from 82252A08h-82252A20h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82252A20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252A20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252A20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252A20);
		  /* 82252A20h */ case    0:  		/* li R31, 0 */
		/* 82252A20h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82252A20h case    0:*/		return 0x82252A24;
		  /* 82252A24h */ case    1:  		/* addi R11, R26, 1040 */
		/* 82252A24h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x410);
		/* 82252A24h case    1:*/		return 0x82252A28;
		  /* 82252A28h */ case    2:  		/* lwz R10, <#[R11 - 64]> */
		/* 82252A28h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0xFFFFFFC0) );
		/* 82252A28h case    2:*/		return 0x82252A2C;
		  /* 82252A2Ch */ case    3:  		/* cmpw CR6, R10, R5 */
		/* 82252A2Ch case    3:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R5);
		/* 82252A2Ch case    3:*/		return 0x82252A30;
	}
	return 0x82252A30;
} // Block from 82252A20h-82252A30h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82252A30h
// Function '?FindMatchForRequired@LinkageInfo@XGRAPHICS@@AAAHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252A30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252A30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252A30);
		  /* 82252A30h */ case    0:  		/* bc 4, CR6_EQ, 24 */
		/* 82252A30h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82252A48;  }
		/* 82252A30h case    0:*/		return 0x82252A34;
		  /* 82252A34h */ case    1:  		/* lwz R10, <#[R11]> */
		/* 82252A34h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82252A34h case    1:*/		return 0x82252A38;
		  /* 82252A38h */ case    2:  		/* cmpw CR6, R10, R6 */
		/* 82252A38h case    2:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R6);
		/* 82252A38h case    2:*/		return 0x82252A3C;
		  /* 82252A3Ch */ case    3:  		/* bc 12, CR6_LT, 12 */
		/* 82252A3Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82252A48;  }
		/* 82252A3Ch case    3:*/		return 0x82252A40;
		  /* 82252A40h */ case    4:  		/* cmpw CR6, R10, R7 */
		/* 82252A40h case    4:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R7);
		/* 82252A40h case    4:*/		return 0x82252A44;
		  /* 82252A44h */ case    5:  		/* bc 12, CR6_LT, 24 */
		/* 82252A44h case    5:*/		if ( regs.CR[6].lt ) { return 0x82252A5C;  }
		/* 82252A44h case    5:*/		return 0x82252A48;
	}
	return 0x82252A48;
} // Block from 82252A30h-82252A48h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82252A48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252A48);
		  /* 82252A48h */ case    0:  		/* addi R31, R31, 1 */
		/* 82252A48h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82252A48h case    0:*/		return 0x82252A4C;
		  /* 82252A4Ch */ case    1:  		/* addi R11, R11, 4 */
		/* 82252A4Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82252A4Ch case    1:*/		return 0x82252A50;
		  /* 82252A50h */ case    2:  		/* cmpwi CR6, R31, 16 */
		/* 82252A50h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000010);
		/* 82252A50h case    2:*/		return 0x82252A54;
		  /* 82252A54h */ case    3:  		/* bc 12, CR6_LT, -44 */
		/* 82252A54h case    3:*/		if ( regs.CR[6].lt ) { return 0x82252A28;  }
		/* 82252A54h case    3:*/		return 0x82252A58;
		  /* 82252A58h */ case    4:  		/* b 116 */
		/* 82252A58h case    4:*/		return 0x82252ACC;
		/* 82252A58h case    4:*/		return 0x82252A5C;
	}
	return 0x82252A5C;
} // Block from 82252A48h-82252A5Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82252A5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252A5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252A5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252A5C);
		  /* 82252A5Ch */ case    0:  		/* addi R11, R31, 260 */
		/* 82252A5Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x104);
		/* 82252A5Ch case    0:*/		return 0x82252A60;
		  /* 82252A60h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82252A60h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82252A60h case    1:*/		return 0x82252A64;
		  /* 82252A64h */ case    2:  		/* lwzx R11, <#[R11 + R26]> */
		/* 82252A64h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 82252A64h case    2:*/		return 0x82252A68;
		  /* 82252A68h */ case    3:  		/* subf R30, R6, R11 */
		/* 82252A68h case    3:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R6,regs.R11);
		/* 82252A68h case    3:*/		return 0x82252A6C;
		  /* 82252A6Ch */ case    4:  		/* add R29, R30, R26 */
		/* 82252A6Ch case    4:*/		cpu::op::add<0>(regs,&regs.R29,regs.R30,regs.R26);
		/* 82252A6Ch case    4:*/		return 0x82252A70;
		  /* 82252A70h */ case    5:  		/* lbz R11, <#[R29 + 896]> */
		/* 82252A70h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000380) );
		/* 82252A70h case    5:*/		return 0x82252A74;
		  /* 82252A74h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 82252A74h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82252A74h case    6:*/		return 0x82252A78;
		  /* 82252A78h */ case    7:  		/* bc 4, CR0_EQ, 20 */
		/* 82252A78h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82252A8C;  }
		/* 82252A78h case    7:*/		return 0x82252A7C;
		  /* 82252A7Ch */ case    8:  		/* add R11, R31, R26 */
		/* 82252A7Ch case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R26);
		/* 82252A7Ch case    8:*/		return 0x82252A80;
		  /* 82252A80h */ case    9:  		/* lbz R11, <#[R11 + 896]> */
		/* 82252A80h case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000380) );
		/* 82252A80h case    9:*/		return 0x82252A84;
		  /* 82252A84h */ case   10:  		/* cmplwi CR0, R11, 0 */
		/* 82252A84h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82252A84h case   10:*/		return 0x82252A88;
		  /* 82252A88h */ case   11:  		/* bc 12, CR0_EQ, 40 */
		/* 82252A88h case   11:*/		if ( regs.CR[0].eq ) { return 0x82252AB0;  }
		/* 82252A88h case   11:*/		return 0x82252A8C;
	}
	return 0x82252A8C;
} // Block from 82252A5Ch-82252A8Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 82252A8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252A8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252A8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252A8C);
		  /* 82252A8Ch */ case    0:  		/* lis R11, -32252 */
		/* 82252A8Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82252A8Ch case    0:*/		return 0x82252A90;
		  /* 82252A90h */ case    1:  		/* lis R10, -32252 */
		/* 82252A90h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82252A90h case    1:*/		return 0x82252A94;
		  /* 82252A94h */ case    2:  		/* lis R9, -32253 */
		/* 82252A94h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82252A94h case    2:*/		return 0x82252A98;
		  /* 82252A98h */ case    3:  		/* addi R6, R11, 16944 */
		/* 82252A98h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x4230);
		/* 82252A98h case    3:*/		return 0x82252A9C;
		  /* 82252A9Ch */ case    4:  		/* addi R5, R10, 17480 */
		/* 82252A9Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x4448);
		/* 82252A9Ch case    4:*/		return 0x82252AA0;
		  /* 82252AA0h */ case    5:  		/* addi R4, R9, 27460 */
		/* 82252AA0h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82252AA0h case    5:*/		return 0x82252AA4;
		  /* 82252AA4h */ case    6:  		/* li R7, 336 */
		/* 82252AA4h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x150);
		/* 82252AA4h case    6:*/		return 0x82252AA8;
		  /* 82252AA8h */ case    7:  		/* li R3, 0 */
		/* 82252AA8h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82252AA8h case    7:*/		return 0x82252AAC;
		  /* 82252AACh */ case    8:  		/* bl -1027748 */
		/* 82252AACh case    8:*/		regs.LR = 0x82252AB0; return 0x82157C08;
		/* 82252AACh case    8:*/		return 0x82252AB0;
	}
	return 0x82252AB0;
} // Block from 82252A8Ch-82252AB0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82252AB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252AB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252AB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252AB0);
		  /* 82252AB0h */ case    0:  		/* mr R6, R30 */
		/* 82252AB0h case    0:*/		regs.R6 = regs.R30;
		/* 82252AB0h case    0:*/		return 0x82252AB4;
		  /* 82252AB4h */ case    1:  		/* mr R5, R31 */
		/* 82252AB4h case    1:*/		regs.R5 = regs.R31;
		/* 82252AB4h case    1:*/		return 0x82252AB8;
		  /* 82252AB8h */ case    2:  		/* mr R4, R18 */
		/* 82252AB8h case    2:*/		regs.R4 = regs.R18;
		/* 82252AB8h case    2:*/		return 0x82252ABC;
		  /* 82252ABCh */ case    3:  		/* mr R3, R26 */
		/* 82252ABCh case    3:*/		regs.R3 = regs.R26;
		/* 82252ABCh case    3:*/		return 0x82252AC0;
		  /* 82252AC0h */ case    4:  		/* bl -2632 */
		/* 82252AC0h case    4:*/		regs.LR = 0x82252AC4; return 0x82252078;
		/* 82252AC0h case    4:*/		return 0x82252AC4;
		  /* 82252AC4h */ case    5:  		/* li R11, 1 */
		/* 82252AC4h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82252AC4h case    5:*/		return 0x82252AC8;
		  /* 82252AC8h */ case    6:  		/* stb R11, <#[R29 + 896]> */
		/* 82252AC8h case    6:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R29 + 0x00000380) );
		/* 82252AC8h case    6:*/		return 0x82252ACC;
	}
	return 0x82252ACC;
} // Block from 82252AB0h-82252ACCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 82252ACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252ACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252ACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252ACC);
		  /* 82252ACCh */ case    0:  		/* li R31, 0 */
		/* 82252ACCh case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82252ACCh case    0:*/		return 0x82252AD0;
		  /* 82252AD0h */ case    1:  		/* addi R29, R26, 976 */
		/* 82252AD0h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R26,0x3D0);
		/* 82252AD0h case    1:*/		return 0x82252AD4;
		  /* 82252AD4h */ case    2:  		/* addi R30, R31, 1 */
		/* 82252AD4h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x1);
		/* 82252AD4h case    2:*/		return 0x82252AD8;
		  /* 82252AD8h */ case    3:  		/* mr R6, R30 */
		/* 82252AD8h case    3:*/		regs.R6 = regs.R30;
		/* 82252AD8h case    3:*/		return 0x82252ADC;
		  /* 82252ADCh */ case    4:  		/* cmpwi CR6, R30, 16 */
		/* 82252ADCh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000010);
		/* 82252ADCh case    4:*/		return 0x82252AE0;
		  /* 82252AE0h */ case    5:  		/* bc 4, CR6_LT, 56 */
		/* 82252AE0h case    5:*/		if ( !regs.CR[6].lt ) { return 0x82252B18;  }
		/* 82252AE0h case    5:*/		return 0x82252AE4;
		  /* 82252AE4h */ case    6:  		/* mr R5, R6 */
		/* 82252AE4h case    6:*/		regs.R5 = regs.R6;
		/* 82252AE4h case    6:*/		return 0x82252AE8;
		  /* 82252AE8h */ case    7:  		/* mr R4, R31 */
		/* 82252AE8h case    7:*/		regs.R4 = regs.R31;
		/* 82252AE8h case    7:*/		return 0x82252AEC;
		  /* 82252AECh */ case    8:  		/* mr R3, R26 */
		/* 82252AECh case    8:*/		regs.R3 = regs.R26;
		/* 82252AECh case    8:*/		return 0x82252AF0;
		  /* 82252AF0h */ case    9:  		/* bl -4184 */
		/* 82252AF0h case    9:*/		regs.LR = 0x82252AF4; return 0x82251A98;
		/* 82252AF0h case    9:*/		return 0x82252AF4;
		  /* 82252AF4h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 82252AF4h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82252AF4h case   10:*/		return 0x82252AF8;
		  /* 82252AF8h */ case   11:  		/* bc 4, CR0_LT, 20 */
		/* 82252AF8h case   11:*/		if ( !regs.CR[0].lt ) { return 0x82252B0C;  }
		/* 82252AF8h case   11:*/		return 0x82252AFC;
		  /* 82252AFCh */ case   12:  		/* mr R5, R31 */
		/* 82252AFCh case   12:*/		regs.R5 = regs.R31;
		/* 82252AFCh case   12:*/		return 0x82252B00;
		  /* 82252B00h */ case   13:  		/* mr R4, R18 */
		/* 82252B00h case   13:*/		regs.R4 = regs.R18;
		/* 82252B00h case   13:*/		return 0x82252B04;
		  /* 82252B04h */ case   14:  		/* mr R3, R26 */
		/* 82252B04h case   14:*/		regs.R3 = regs.R26;
		/* 82252B04h case   14:*/		return 0x82252B08;
		  /* 82252B08h */ case   15:  		/* bl -2704 */
		/* 82252B08h case   15:*/		regs.LR = 0x82252B0C; return 0x82252078;
		/* 82252B08h case   15:*/		return 0x82252B0C;
	}
	return 0x82252B0C;
} // Block from 82252ACCh-82252B0Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 82252B0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252B0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252B0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252B0C);
		  /* 82252B0Ch */ case    0:  		/* addi R6, R6, 1 */
		/* 82252B0Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82252B0Ch case    0:*/		return 0x82252B10;
		  /* 82252B10h */ case    1:  		/* cmpwi CR6, R6, 16 */
		/* 82252B10h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000010);
		/* 82252B10h case    1:*/		return 0x82252B14;
		  /* 82252B14h */ case    2:  		/* bc 12, CR6_LT, -48 */
		/* 82252B14h case    2:*/		if ( regs.CR[6].lt ) { return 0x82252AE4;  }
		/* 82252B14h case    2:*/		return 0x82252B18;
	}
	return 0x82252B18;
} // Block from 82252B0Ch-82252B18h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82252B18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252B18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252B18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252B18);
		  /* 82252B18h */ case    0:  		/* lwz R11, <#[R29 - 64]> */
		/* 82252B18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0xFFFFFFC0) );
		/* 82252B18h case    0:*/		return 0x82252B1C;
		  /* 82252B1Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82252B1Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82252B1Ch case    1:*/		return 0x82252B20;
		  /* 82252B20h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 82252B20h case    2:*/		if ( regs.CR[6].eq ) { return 0x82252B34;  }
		/* 82252B20h case    2:*/		return 0x82252B24;
		  /* 82252B24h */ case    3:  		/* lwz R11, <#[R29]> */
		/* 82252B24h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82252B24h case    3:*/		return 0x82252B28;
		  /* 82252B28h */ case    4:  		/* cmpwi CR6, R11, 18 */
		/* 82252B28h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000012);
		/* 82252B28h case    4:*/		return 0x82252B2C;
		  /* 82252B2Ch */ case    5:  		/* bc 12, CR6_EQ, 8 */
		/* 82252B2Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82252B34;  }
		/* 82252B2Ch case    5:*/		return 0x82252B30;
		  /* 82252B30h */ case    6:  		/* mr R17, R31 */
		/* 82252B30h case    6:*/		regs.R17 = regs.R31;
		/* 82252B30h case    6:*/		return 0x82252B34;
	}
	return 0x82252B34;
} // Block from 82252B18h-82252B34h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82252B34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252B34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252B34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252B34);
		  /* 82252B34h */ case    0:  		/* mr R31, R30 */
		/* 82252B34h case    0:*/		regs.R31 = regs.R30;
		/* 82252B34h case    0:*/		return 0x82252B38;
		  /* 82252B38h */ case    1:  		/* addi R29, R29, 4 */
		/* 82252B38h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82252B38h case    1:*/		return 0x82252B3C;
		  /* 82252B3Ch */ case    2:  		/* cmpwi CR6, R30, 15 */
		/* 82252B3Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x0000000F);
		/* 82252B3Ch case    2:*/		return 0x82252B40;
		  /* 82252B40h */ case    3:  		/* bc 12, CR6_LT, -108 */
		/* 82252B40h case    3:*/		if ( regs.CR[6].lt ) { return 0x82252AD4;  }
		/* 82252B40h case    3:*/		return 0x82252B44;
	}
	return 0x82252B44;
} // Block from 82252B34h-82252B44h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82252B44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252B44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252B44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252B44);
		  /* 82252B44h */ case    0:  		/* mr R3, R17 */
		/* 82252B44h case    0:*/		regs.R3 = regs.R17;
		/* 82252B44h case    0:*/		return 0x82252B48;
		  /* 82252B48h */ case    1:  		/* addi R1, R1, 256 */
		/* 82252B48h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 82252B48h case    1:*/		return 0x82252B4C;
		  /* 82252B4Ch */ case    2:  		/* b -1841364 */
		/* 82252B4Ch case    2:*/		return 0x82091278;
		/* 82252B4Ch case    2:*/		return 0x82252B50;
		  /* 82252B50h */ case    3:  		/* cmplwi CR6, R3, 61 */
		/* 82252B50h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x0000003D);
		/* 82252B50h case    3:*/		return 0x82252B54;
		  /* 82252B54h */ case    4:  		/* bc 12, CR6_GT, 92 */
		/* 82252B54h case    4:*/		if ( regs.CR[6].gt ) { return 0x82252BB0;  }
		/* 82252B54h case    4:*/		return 0x82252B58;
		  /* 82252B58h */ case    5:  		/* lis R12, -32252 */
		/* 82252B58h case    5:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8204);
		/* 82252B58h case    5:*/		return 0x82252B5C;
		  /* 82252B5Ch */ case    6:  		/* addi R12, R12, 17896 */
		/* 82252B5Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x45E8);
		/* 82252B5Ch case    6:*/		return 0x82252B60;
		  /* 82252B60h */ case    7:  		/* lbzx R0, <#[R12 + R3]> */
		/* 82252B60h case    7:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R3 + 0x00000000) );
		/* 82252B60h case    7:*/		return 0x82252B64;
		  /* 82252B64h */ case    8:  		/* lis R12, -32219 */
		/* 82252B64h case    8:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8225);
		/* 82252B64h case    8:*/		return 0x82252B68;
		  /* 82252B68h */ case    9:  		/* ori R0, R0, 0 */
		/* 82252B68h case    9:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82252B68h case    9:*/		return 0x82252B6C;
		  /* 82252B6Ch */ case   10:  		/* addi R12, R12, 11136 */
		/* 82252B6Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x2B80);
		/* 82252B6Ch case   10:*/		return 0x82252B70;
		  /* 82252B70h */ case   11:  		/* ori R0, R0, 0 */
		/* 82252B70h case   11:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82252B70h case   11:*/		return 0x82252B74;
		  /* 82252B74h */ case   12:  		/* add R12, R12, R0 */
		/* 82252B74h case   12:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 82252B74h case   12:*/		return 0x82252B78;
		  /* 82252B78h */ case   13:  		/* mtspr CTR, R12 */
		/* 82252B78h case   13:*/		regs.CTR = regs.R12;
		/* 82252B78h case   13:*/		return 0x82252B7C;
		  /* 82252B7Ch */ case   14:  		/* bcctr 20, CR0_LT */
		/* 82252B7Ch case   14:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82252B7Ch case   14:*/		return 0x82252B80;
		  /* 82252B80h */ case   15:  		/* li R3, 1 */
		/* 82252B80h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82252B80h case   15:*/		return 0x82252B84;
		  /* 82252B84h */ case   16:  		/* bclr 20, CR0_LT */
		/* 82252B84h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252B84h case   16:*/		return 0x82252B88;
	}
	return 0x82252B88;
} // Block from 82252B44h-82252B88h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82252B88h
// Function '?Reorder@LinkageInfo@XGRAPHICS@@AAAXPAVCFG@2@HH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252B88);
		  /* 82252B88h */ case    0:  		/* li R3, 2 */
		/* 82252B88h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 82252B88h case    0:*/		return 0x82252B8C;
		  /* 82252B8Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 82252B8Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252B8Ch case    1:*/		return 0x82252B90;
	}
	return 0x82252B90;
} // Block from 82252B88h-82252B90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252B90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252B90);
		  /* 82252B90h */ case    0:  		/* li R3, 4 */
		/* 82252B90h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x4);
		/* 82252B90h case    0:*/		return 0x82252B94;
		  /* 82252B94h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82252B94h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252B94h case    1:*/		return 0x82252B98;
	}
	return 0x82252B98;
} // Block from 82252B90h-82252B98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252B98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252B98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252B98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252B98);
		  /* 82252B98h */ case    0:  		/* li R3, 8 */
		/* 82252B98h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x8);
		/* 82252B98h case    0:*/		return 0x82252B9C;
		  /* 82252B9Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 82252B9Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252B9Ch case    1:*/		return 0x82252BA0;
	}
	return 0x82252BA0;
} // Block from 82252B98h-82252BA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252BA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252BA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252BA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252BA0);
		  /* 82252BA0h */ case    0:  		/* li R3, 16 */
		/* 82252BA0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x10);
		/* 82252BA0h case    0:*/		return 0x82252BA4;
		  /* 82252BA4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82252BA4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252BA4h case    1:*/		return 0x82252BA8;
	}
	return 0x82252BA8;
} // Block from 82252BA0h-82252BA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252BA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252BA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252BA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252BA8);
		  /* 82252BA8h */ case    0:  		/* li R3, 12 */
		/* 82252BA8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xC);
		/* 82252BA8h case    0:*/		return 0x82252BAC;
		  /* 82252BACh */ case    1:  		/* bclr 20, CR0_LT */
		/* 82252BACh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252BACh case    1:*/		return 0x82252BB0;
	}
	return 0x82252BB0;
} // Block from 82252BA8h-82252BB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252BB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252BB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252BB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252BB0);
		  /* 82252BB0h */ case    0:  		/* li R3, 0 */
		/* 82252BB0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82252BB0h case    0:*/		return 0x82252BB4;
		  /* 82252BB4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82252BB4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252BB4h case    1:*/		return 0x82252BB8;
	}
	return 0x82252BB8;
} // Block from 82252BB0h-82252BB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252BB8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252BB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252BB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252BB8);
		  /* 82252BB8h */ case    0:  		/* addi R11, R3, -2 */
		/* 82252BB8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0xFFFFFFFE);
		/* 82252BB8h case    0:*/		return 0x82252BBC;
		  /* 82252BBCh */ case    1:  		/* cmplwi CR6, R11, 36 */
		/* 82252BBCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000024);
		/* 82252BBCh case    1:*/		return 0x82252BC0;
		  /* 82252BC0h */ case    2:  		/* bc 12, CR6_GT, 84 */
		/* 82252BC0h case    2:*/		if ( regs.CR[6].gt ) { return 0x82252C14;  }
		/* 82252BC0h case    2:*/		return 0x82252BC4;
		  /* 82252BC4h */ case    3:  		/* lis R12, -32252 */
		/* 82252BC4h case    3:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8204);
		/* 82252BC4h case    3:*/		return 0x82252BC8;
		  /* 82252BC8h */ case    4:  		/* addi R12, R12, 17960 */
		/* 82252BC8h case    4:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x4628);
		/* 82252BC8h case    4:*/		return 0x82252BCC;
		  /* 82252BCCh */ case    5:  		/* lbzx R0, <#[R12 + R11]> */
		/* 82252BCCh case    5:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R11 + 0x00000000) );
		/* 82252BCCh case    5:*/		return 0x82252BD0;
		  /* 82252BD0h */ case    6:  		/* lis R12, -32219 */
		/* 82252BD0h case    6:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8225);
		/* 82252BD0h case    6:*/		return 0x82252BD4;
		  /* 82252BD4h */ case    7:  		/* ori R0, R0, 0 */
		/* 82252BD4h case    7:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82252BD4h case    7:*/		return 0x82252BD8;
		  /* 82252BD8h */ case    8:  		/* addi R12, R12, 11244 */
		/* 82252BD8h case    8:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x2BEC);
		/* 82252BD8h case    8:*/		return 0x82252BDC;
		  /* 82252BDCh */ case    9:  		/* ori R0, R0, 0 */
		/* 82252BDCh case    9:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82252BDCh case    9:*/		return 0x82252BE0;
		  /* 82252BE0h */ case   10:  		/* add R12, R12, R0 */
		/* 82252BE0h case   10:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 82252BE0h case   10:*/		return 0x82252BE4;
		  /* 82252BE4h */ case   11:  		/* mtspr CTR, R12 */
		/* 82252BE4h case   11:*/		regs.CTR = regs.R12;
		/* 82252BE4h case   11:*/		return 0x82252BE8;
		  /* 82252BE8h */ case   12:  		/* bcctr 20, CR0_LT */
		/* 82252BE8h case   12:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82252BE8h case   12:*/		return 0x82252BEC;
		  /* 82252BECh */ case   13:  		/* li R3, 1 */
		/* 82252BECh case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82252BECh case   13:*/		return 0x82252BF0;
		  /* 82252BF0h */ case   14:  		/* bclr 20, CR0_LT */
		/* 82252BF0h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252BF0h case   14:*/		return 0x82252BF4;
	}
	return 0x82252BF4;
} // Block from 82252BB8h-82252BF4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82252BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252BF4);
		  /* 82252BF4h */ case    0:  		/* li R3, 2 */
		/* 82252BF4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 82252BF4h case    0:*/		return 0x82252BF8;
		  /* 82252BF8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82252BF8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252BF8h case    1:*/		return 0x82252BFC;
	}
	return 0x82252BFC;
} // Block from 82252BF4h-82252BFCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252BFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252BFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252BFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252BFC);
		  /* 82252BFCh */ case    0:  		/* li R3, 4 */
		/* 82252BFCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x4);
		/* 82252BFCh case    0:*/		return 0x82252C00;
		  /* 82252C00h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82252C00h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252C00h case    1:*/		return 0x82252C04;
	}
	return 0x82252C04;
} // Block from 82252BFCh-82252C04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252C04);
		  /* 82252C04h */ case    0:  		/* li R3, 8 */
		/* 82252C04h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x8);
		/* 82252C04h case    0:*/		return 0x82252C08;
		  /* 82252C08h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82252C08h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252C08h case    1:*/		return 0x82252C0C;
	}
	return 0x82252C0C;
} // Block from 82252C04h-82252C0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252C0C);
		  /* 82252C0Ch */ case    0:  		/* li R3, 16 */
		/* 82252C0Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x10);
		/* 82252C0Ch case    0:*/		return 0x82252C10;
		  /* 82252C10h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82252C10h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252C10h case    1:*/		return 0x82252C14;
	}
	return 0x82252C14;
} // Block from 82252C0Ch-82252C14h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252C14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252C14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252C14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252C14);
		  /* 82252C14h */ case    0:  		/* li R3, 0 */
		/* 82252C14h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82252C14h case    0:*/		return 0x82252C18;
		  /* 82252C18h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82252C18h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252C18h case    1:*/		return 0x82252C1C;
	}
	return 0x82252C1C;
} // Block from 82252C14h-82252C1Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252C1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252C1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252C1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252C1C);
		  /* 82252C1Ch */ case    0:  		/* nop */
		/* 82252C1Ch case    0:*/		cpu::op::nop();
		/* 82252C1Ch case    0:*/		return 0x82252C20;
		  /* 82252C20h */ case    1:  		/* addi R11, R3, -2 */
		/* 82252C20h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0xFFFFFFFE);
		/* 82252C20h case    1:*/		return 0x82252C24;
		  /* 82252C24h */ case    2:  		/* cmplwi CR6, R11, 36 */
		/* 82252C24h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000024);
		/* 82252C24h case    2:*/		return 0x82252C28;
		  /* 82252C28h */ case    3:  		/* bc 12, CR6_GT, 76 */
		/* 82252C28h case    3:*/		if ( regs.CR[6].gt ) { return 0x82252C74;  }
		/* 82252C28h case    3:*/		return 0x82252C2C;
		  /* 82252C2Ch */ case    4:  		/* lis R12, -32252 */
		/* 82252C2Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8204);
		/* 82252C2Ch case    4:*/		return 0x82252C30;
		  /* 82252C30h */ case    5:  		/* addi R12, R12, 18064 */
		/* 82252C30h case    5:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x4690);
		/* 82252C30h case    5:*/		return 0x82252C34;
		  /* 82252C34h */ case    6:  		/* lbzx R0, <#[R12 + R11]> */
		/* 82252C34h case    6:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R11 + 0x00000000) );
		/* 82252C34h case    6:*/		return 0x82252C38;
		  /* 82252C38h */ case    7:  		/* lis R12, -32219 */
		/* 82252C38h case    7:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8225);
		/* 82252C38h case    7:*/		return 0x82252C3C;
		  /* 82252C3Ch */ case    8:  		/* ori R0, R0, 0 */
		/* 82252C3Ch case    8:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82252C3Ch case    8:*/		return 0x82252C40;
		  /* 82252C40h */ case    9:  		/* addi R12, R12, 11348 */
		/* 82252C40h case    9:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x2C54);
		/* 82252C40h case    9:*/		return 0x82252C44;
		  /* 82252C44h */ case   10:  		/* ori R0, R0, 0 */
		/* 82252C44h case   10:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82252C44h case   10:*/		return 0x82252C48;
		  /* 82252C48h */ case   11:  		/* add R12, R12, R0 */
		/* 82252C48h case   11:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 82252C48h case   11:*/		return 0x82252C4C;
		  /* 82252C4Ch */ case   12:  		/* mtspr CTR, R12 */
		/* 82252C4Ch case   12:*/		regs.CTR = regs.R12;
		/* 82252C4Ch case   12:*/		return 0x82252C50;
		  /* 82252C50h */ case   13:  		/* bcctr 20, CR0_LT */
		/* 82252C50h case   13:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82252C50h case   13:*/		return 0x82252C54;
		  /* 82252C54h */ case   14:  		/* li R3, 4 */
		/* 82252C54h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x4);
		/* 82252C54h case   14:*/		return 0x82252C58;
		  /* 82252C58h */ case   15:  		/* bclr 20, CR0_LT */
		/* 82252C58h case   15:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252C58h case   15:*/		return 0x82252C5C;
	}
	return 0x82252C5C;
} // Block from 82252C1Ch-82252C5Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 82252C5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252C5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252C5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252C5C);
		  /* 82252C5Ch */ case    0:  		/* li R3, 3 */
		/* 82252C5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 82252C5Ch case    0:*/		return 0x82252C60;
		  /* 82252C60h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82252C60h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252C60h case    1:*/		return 0x82252C64;
	}
	return 0x82252C64;
} // Block from 82252C5Ch-82252C64h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252C64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252C64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252C64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252C64);
		  /* 82252C64h */ case    0:  		/* li R3, 2 */
		/* 82252C64h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 82252C64h case    0:*/		return 0x82252C68;
		  /* 82252C68h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82252C68h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252C68h case    1:*/		return 0x82252C6C;
	}
	return 0x82252C6C;
} // Block from 82252C64h-82252C6Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252C6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252C6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252C6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252C6C);
		  /* 82252C6Ch */ case    0:  		/* li R3, 1 */
		/* 82252C6Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82252C6Ch case    0:*/		return 0x82252C70;
		  /* 82252C70h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82252C70h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252C70h case    1:*/		return 0x82252C74;
	}
	return 0x82252C74;
} // Block from 82252C6Ch-82252C74h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252C74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252C74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252C74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252C74);
		  /* 82252C74h */ case    0:  		/* li R3, 0 */
		/* 82252C74h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82252C74h case    0:*/		return 0x82252C78;
		  /* 82252C78h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82252C78h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252C78h case    1:*/		return 0x82252C7C;
	}
	return 0x82252C7C;
} // Block from 82252C74h-82252C7Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252C7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252C7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252C7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252C7C);
		  /* 82252C7Ch */ case    0:  		/* nop */
		/* 82252C7Ch case    0:*/		cpu::op::nop();
		/* 82252C7Ch case    0:*/		return 0x82252C80;
		  /* 82252C80h */ case    1:  		/* mr R11, R3 */
		/* 82252C80h case    1:*/		regs.R11 = regs.R3;
		/* 82252C80h case    1:*/		return 0x82252C84;
		  /* 82252C84h */ case    2:  		/* cmplwi CR6, R4, 61 */
		/* 82252C84h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000003D);
		/* 82252C84h case    2:*/		return 0x82252C88;
		  /* 82252C88h */ case    3:  		/* bc 12, CR6_GT, 372 */
		/* 82252C88h case    3:*/		if ( regs.CR[6].gt ) { return 0x82252DFC;  }
		/* 82252C88h case    3:*/		return 0x82252C8C;
		  /* 82252C8Ch */ case    4:  		/* lis R12, -32252 */
		/* 82252C8Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8204);
		/* 82252C8Ch case    4:*/		return 0x82252C90;
		  /* 82252C90h */ case    5:  		/* addi R12, R12, 18104 */
		/* 82252C90h case    5:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x46B8);
		/* 82252C90h case    5:*/		return 0x82252C94;
		  /* 82252C94h */ case    6:  		/* lbzx R0, <#[R12 + R4]> */
		/* 82252C94h case    6:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R4 + 0x00000000) );
		/* 82252C94h case    6:*/		return 0x82252C98;
		  /* 82252C98h */ case    7:  		/* rlwinm R0, R0, 2, 0, 29 */
		/* 82252C98h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R0,regs.R0);
		/* 82252C98h case    7:*/		return 0x82252C9C;
		  /* 82252C9Ch */ case    8:  		/* lis R12, -32219 */
		/* 82252C9Ch case    8:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8225);
		/* 82252C9Ch case    8:*/		return 0x82252CA0;
		  /* 82252CA0h */ case    9:  		/* ori R0, R0, 0 */
		/* 82252CA0h case    9:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82252CA0h case    9:*/		return 0x82252CA4;
		  /* 82252CA4h */ case   10:  		/* addi R12, R12, 11444 */
		/* 82252CA4h case   10:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x2CB4);
		/* 82252CA4h case   10:*/		return 0x82252CA8;
		  /* 82252CA8h */ case   11:  		/* add R12, R12, R0 */
		/* 82252CA8h case   11:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 82252CA8h case   11:*/		return 0x82252CAC;
		  /* 82252CACh */ case   12:  		/* mtspr CTR, R12 */
		/* 82252CACh case   12:*/		regs.CTR = regs.R12;
		/* 82252CACh case   12:*/		return 0x82252CB0;
		  /* 82252CB0h */ case   13:  		/* bcctr 20, CR0_LT */
		/* 82252CB0h case   13:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82252CB0h case   13:*/		return 0x82252CB4;
		  /* 82252CB4h */ case   14:  		/* li R9, 8 */
		/* 82252CB4h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 82252CB4h case   14:*/		return 0x82252CB8;
		  /* 82252CB8h */ case   15:  		/* li R10, 0 */
		/* 82252CB8h case   15:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82252CB8h case   15:*/		return 0x82252CBC;
		  /* 82252CBCh */ case   16:  		/* stw R9, <#[R11]> */
		/* 82252CBCh case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82252CBCh case   16:*/		return 0x82252CC0;
		  /* 82252CC0h */ case   17:  		/* li R3, 1 */
		/* 82252CC0h case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82252CC0h case   17:*/		return 0x82252CC4;
		  /* 82252CC4h */ case   18:  		/* b 324 */
		/* 82252CC4h case   18:*/		return 0x82252E08;
		/* 82252CC4h case   18:*/		return 0x82252CC8;
		  /* 82252CC8h */ case   19:  		/* li R10, 5 */
		/* 82252CC8h case   19:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 82252CC8h case   19:*/		return 0x82252CCC;
		  /* 82252CCCh */ case   20:  		/* li R9, 1 */
		/* 82252CCCh case   20:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82252CCCh case   20:*/		return 0x82252CD0;
		  /* 82252CD0h */ case   21:  		/* stw R10, <#[R11]> */
		/* 82252CD0h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82252CD0h case   21:*/		return 0x82252CD4;
		  /* 82252CD4h */ case   22:  		/* li R3, 4 */
		/* 82252CD4h case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x4);
		/* 82252CD4h case   22:*/		return 0x82252CD8;
		  /* 82252CD8h */ case   23:  		/* stw R9, <#[R11 + 12]> */
		/* 82252CD8h case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82252CD8h case   23:*/		return 0x82252CDC;
		  /* 82252CDCh */ case   24:  		/* b 304 */
		/* 82252CDCh case   24:*/		return 0x82252E0C;
		/* 82252CDCh case   24:*/		return 0x82252CE0;
		  /* 82252CE0h */ case   25:  		/* li R10, 5 */
		/* 82252CE0h case   25:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 82252CE0h case   25:*/		return 0x82252CE4;
		  /* 82252CE4h */ case   26:  		/* li R9, 6 */
		/* 82252CE4h case   26:*/		cpu::op::li<0>(regs,&regs.R9,0x6);
		/* 82252CE4h case   26:*/		return 0x82252CE8;
		  /* 82252CE8h */ case   27:  		/* li R8, 0 */
		/* 82252CE8h case   27:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82252CE8h case   27:*/		return 0x82252CEC;
		  /* 82252CECh */ case   28:  		/* stw R10, <#[R11]> */
		/* 82252CECh case   28:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82252CECh case   28:*/		return 0x82252CF0;
		  /* 82252CF0h */ case   29:  		/* stw R9, <#[R11 + 4]> */
		/* 82252CF0h case   29:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82252CF0h case   29:*/		return 0x82252CF4;
		  /* 82252CF4h */ case   30:  		/* li R3, 3 */
		/* 82252CF4h case   30:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 82252CF4h case   30:*/		return 0x82252CF8;
		  /* 82252CF8h */ case   31:  		/* stw R8, <#[R11 + 12]> */
		/* 82252CF8h case   31:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 82252CF8h case   31:*/		return 0x82252CFC;
		  /* 82252CFCh */ case   32:  		/* b 276 */
		/* 82252CFCh case   32:*/		return 0x82252E10;
		/* 82252CFCh case   32:*/		return 0x82252D00;
		  /* 82252D00h */ case   33:  		/* li R10, 5 */
		/* 82252D00h case   33:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 82252D00h case   33:*/		return 0x82252D04;
		  /* 82252D04h */ case   34:  		/* li R9, 6 */
		/* 82252D04h case   34:*/		cpu::op::li<0>(regs,&regs.R9,0x6);
		/* 82252D04h case   34:*/		return 0x82252D08;
		  /* 82252D08h */ case   35:  		/* li R8, 0 */
		/* 82252D08h case   35:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82252D08h case   35:*/		return 0x82252D0C;
		  /* 82252D0Ch */ case   36:  		/* stw R10, <#[R11]> */
		/* 82252D0Ch case   36:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82252D0Ch case   36:*/		return 0x82252D10;
		  /* 82252D10h */ case   37:  		/* stw R10, <#[R11 + 4]> */
		/* 82252D10h case   37:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82252D10h case   37:*/		return 0x82252D14;
		  /* 82252D14h */ case   38:  		/* li R3, 3 */
		/* 82252D14h case   38:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 82252D14h case   38:*/		return 0x82252D18;
		  /* 82252D18h */ case   39:  		/* stw R9, <#[R11 + 8]> */
		/* 82252D18h case   39:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82252D18h case   39:*/		return 0x82252D1C;
		  /* 82252D1Ch */ case   40:  		/* stw R8, <#[R11 + 12]> */
		/* 82252D1Ch case   40:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 82252D1Ch case   40:*/		return 0x82252D20;
		  /* 82252D20h */ case   41:  		/* bclr 20, CR0_LT */
		/* 82252D20h case   41:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252D20h case   41:*/		return 0x82252D24;
	}
	return 0x82252D24;
} // Block from 82252C7Ch-82252D24h (42 instructions)

//////////////////////////////////////////////////////
// Block at 82252D24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252D24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252D24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252D24);
		  /* 82252D24h */ case    0:  		/* li R9, 8 */
		/* 82252D24h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 82252D24h case    0:*/		return 0x82252D28;
		  /* 82252D28h */ case    1:  		/* stw R9, <#[R11 + 4]> */
		/* 82252D28h case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82252D28h case    1:*/		return 0x82252D2C;
		  /* 82252D2Ch */ case    2:  		/* li R10, 0 */
		/* 82252D2Ch case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82252D2Ch case    2:*/		return 0x82252D30;
		  /* 82252D30h */ case    3:  		/* stw R9, <#[R11]> */
		/* 82252D30h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82252D30h case    3:*/		return 0x82252D34;
		  /* 82252D34h */ case    4:  		/* li R3, 2 */
		/* 82252D34h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 82252D34h case    4:*/		return 0x82252D38;
		  /* 82252D38h */ case    5:  		/* stw R10, <#[R11 + 12]> */
		/* 82252D38h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82252D38h case    5:*/		return 0x82252D3C;
		  /* 82252D3Ch */ case    6:  		/* b 212 */
		/* 82252D3Ch case    6:*/		return 0x82252E10;
		/* 82252D3Ch case    6:*/		return 0x82252D40;
		  /* 82252D40h */ case    7:  		/* li R10, 4 */
		/* 82252D40h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 82252D40h case    7:*/		return 0x82252D44;
		  /* 82252D44h */ case    8:  		/* li R3, 4 */
		/* 82252D44h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x4);
		/* 82252D44h case    8:*/		return 0x82252D48;
		  /* 82252D48h */ case    9:  		/* b 188 */
		/* 82252D48h case    9:*/		return 0x82252E04;
		/* 82252D48h case    9:*/		return 0x82252D4C;
		  /* 82252D4Ch */ case   10:  		/* li R9, 16 */
		/* 82252D4Ch case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 82252D4Ch case   10:*/		return 0x82252D50;
		  /* 82252D50h */ case   11:  		/* b -152 */
		/* 82252D50h case   11:*/		return 0x82252CB8;
		/* 82252D50h case   11:*/		return 0x82252D54;
		  /* 82252D54h */ case   12:  		/* li R9, 8 */
		/* 82252D54h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 82252D54h case   12:*/		return 0x82252D58;
		  /* 82252D58h */ case   13:  		/* li R3, 4 */
		/* 82252D58h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x4);
		/* 82252D58h case   13:*/		return 0x82252D5C;
		  /* 82252D5Ch */ case   14:  		/* stw R9, <#[R11]> */
		/* 82252D5Ch case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82252D5Ch case   14:*/		return 0x82252D60;
		  /* 82252D60h */ case   15:  		/* stw R9, <#[R11 + 4]> */
		/* 82252D60h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82252D60h case   15:*/		return 0x82252D64;
		  /* 82252D64h */ case   16:  		/* stw R9, <#[R11 + 8]> */
		/* 82252D64h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82252D64h case   16:*/		return 0x82252D68;
	}
	return 0x82252D68;
} // Block from 82252D24h-82252D68h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82252D68h
// Function '?IsRequired@LinkageInfo@XGRAPHICS@@QAA_NW4RegType@R400Tables@@HPAH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252D68);
		  /* 82252D68h */ case    0:  		/* stw R9, <#[R11 + 12]> */
		/* 82252D68h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82252D68h case    0:*/		return 0x82252D6C;
		  /* 82252D6Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 82252D6Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252D6Ch case    1:*/		return 0x82252D70;
	}
	return 0x82252D70;
} // Block from 82252D68h-82252D70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252D70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252D70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252D70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252D70);
		  /* 82252D70h */ case    0:  		/* li R10, 10 */
		/* 82252D70h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0xA);
		/* 82252D70h case    0:*/		return 0x82252D74;
		  /* 82252D74h */ case    1:  		/* li R9, 2 */
		/* 82252D74h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 82252D74h case    1:*/		return 0x82252D78;
		  /* 82252D78h */ case    2:  		/* b -168 */
		/* 82252D78h case    2:*/		return 0x82252CD0;
		/* 82252D78h case    2:*/		return 0x82252D7C;
		  /* 82252D7Ch */ case    3:  		/* li R10, 11 */
		/* 82252D7Ch case    3:*/		cpu::op::li<0>(regs,&regs.R10,0xB);
		/* 82252D7Ch case    3:*/		return 0x82252D80;
		  /* 82252D80h */ case    4:  		/* li R9, 10 */
		/* 82252D80h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0xA);
		/* 82252D80h case    4:*/		return 0x82252D84;
		  /* 82252D84h */ case    5:  		/* b -124 */
		/* 82252D84h case    5:*/		return 0x82252D08;
		/* 82252D84h case    5:*/		return 0x82252D88;
		  /* 82252D88h */ case    6:  		/* li R9, 10 */
		/* 82252D88h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0xA);
		/* 82252D88h case    6:*/		return 0x82252D8C;
		  /* 82252D8Ch */ case    7:  		/* li R8, 0 */
		/* 82252D8Ch case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82252D8Ch case    7:*/		return 0x82252D90;
		  /* 82252D90h */ case    8:  		/* li R10, 11 */
		/* 82252D90h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0xB);
		/* 82252D90h case    8:*/		return 0x82252D94;
		  /* 82252D94h */ case    9:  		/* stw R9, <#[R11]> */
		/* 82252D94h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82252D94h case    9:*/		return 0x82252D98;
		  /* 82252D98h */ case   10:  		/* li R3, 3 */
		/* 82252D98h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 82252D98h case   10:*/		return 0x82252D9C;
		  /* 82252D9Ch */ case   11:  		/* stw R8, <#[R11 + 12]> */
		/* 82252D9Ch case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 82252D9Ch case   11:*/		return 0x82252DA0;
		  /* 82252DA0h */ case   12:  		/* b 108 */
		/* 82252DA0h case   12:*/		return 0x82252E0C;
		/* 82252DA0h case   12:*/		return 0x82252DA4;
		  /* 82252DA4h */ case   13:  		/* li R9, 16 */
		/* 82252DA4h case   13:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 82252DA4h case   13:*/		return 0x82252DA8;
		  /* 82252DA8h */ case   14:  		/* b -128 */
		/* 82252DA8h case   14:*/		return 0x82252D28;
		/* 82252DA8h case   14:*/		return 0x82252DAC;
		  /* 82252DACh */ case   15:  		/* li R9, 32 */
		/* 82252DACh case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x20);
		/* 82252DACh case   15:*/		return 0x82252DB0;
		  /* 82252DB0h */ case   16:  		/* b -248 */
		/* 82252DB0h case   16:*/		return 0x82252CB8;
		/* 82252DB0h case   16:*/		return 0x82252DB4;
		  /* 82252DB4h */ case   17:  		/* li R8, 24 */
		/* 82252DB4h case   17:*/		cpu::op::li<0>(regs,&regs.R8,0x18);
		/* 82252DB4h case   17:*/		return 0x82252DB8;
		  /* 82252DB8h */ case   18:  		/* li R9, 8 */
		/* 82252DB8h case   18:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 82252DB8h case   18:*/		return 0x82252DBC;
		  /* 82252DBCh */ case   19:  		/* stw R8, <#[R11 + 4]> */
		/* 82252DBCh case   19:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82252DBCh case   19:*/		return 0x82252DC0;
		  /* 82252DC0h */ case   20:  		/* b -148 */
		/* 82252DC0h case   20:*/		return 0x82252D2C;
		/* 82252DC0h case   20:*/		return 0x82252DC4;
		  /* 82252DC4h */ case   21:  		/* li R9, 16 */
		/* 82252DC4h case   21:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 82252DC4h case   21:*/		return 0x82252DC8;
		  /* 82252DC8h */ case   22:  		/* b -112 */
		/* 82252DC8h case   22:*/		return 0x82252D58;
		/* 82252DC8h case   22:*/		return 0x82252DCC;
		  /* 82252DCCh */ case   23:  		/* li R9, 32 */
		/* 82252DCCh case   23:*/		cpu::op::li<0>(regs,&regs.R9,0x20);
		/* 82252DCCh case   23:*/		return 0x82252DD0;
		  /* 82252DD0h */ case   24:  		/* b -168 */
		/* 82252DD0h case   24:*/		return 0x82252D28;
		/* 82252DD0h case   24:*/		return 0x82252DD4;
		  /* 82252DD4h */ case   25:  		/* li R9, 32 */
		/* 82252DD4h case   25:*/		cpu::op::li<0>(regs,&regs.R9,0x20);
		/* 82252DD4h case   25:*/		return 0x82252DD8;
		  /* 82252DD8h */ case   26:  		/* b -128 */
		/* 82252DD8h case   26:*/		return 0x82252D58;
		/* 82252DD8h case   26:*/		return 0x82252DDC;
		  /* 82252DDCh */ case   27:  		/* li R9, 32 */
		/* 82252DDCh case   27:*/		cpu::op::li<0>(regs,&regs.R9,0x20);
		/* 82252DDCh case   27:*/		return 0x82252DE0;
		  /* 82252DE0h */ case   28:  		/* li R10, 0 */
		/* 82252DE0h case   28:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82252DE0h case   28:*/		return 0x82252DE4;
		  /* 82252DE4h */ case   29:  		/* stw R9, <#[R11]> */
		/* 82252DE4h case   29:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82252DE4h case   29:*/		return 0x82252DE8;
		  /* 82252DE8h */ case   30:  		/* li R3, 3 */
		/* 82252DE8h case   30:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 82252DE8h case   30:*/		return 0x82252DEC;
		  /* 82252DECh */ case   31:  		/* stw R9, <#[R11 + 4]> */
		/* 82252DECh case   31:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82252DECh case   31:*/		return 0x82252DF0;
		  /* 82252DF0h */ case   32:  		/* stw R9, <#[R11 + 8]> */
		/* 82252DF0h case   32:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82252DF0h case   32:*/		return 0x82252DF4;
		  /* 82252DF4h */ case   33:  		/* stw R10, <#[R11 + 12]> */
		/* 82252DF4h case   33:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82252DF4h case   33:*/		return 0x82252DF8;
		  /* 82252DF8h */ case   34:  		/* bclr 20, CR0_LT */
		/* 82252DF8h case   34:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252DF8h case   34:*/		return 0x82252DFC;
	}
	return 0x82252DFC;
} // Block from 82252D70h-82252DFCh (35 instructions)

//////////////////////////////////////////////////////
// Block at 82252DFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252DFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252DFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252DFC);
		  /* 82252DFCh */ case    0:  		/* li R10, 0 */
		/* 82252DFCh case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82252DFCh case    0:*/		return 0x82252E00;
		  /* 82252E00h */ case    1:  		/* li R3, 0 */
		/* 82252E00h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82252E00h case    1:*/		return 0x82252E04;
	}
	return 0x82252E04;
} // Block from 82252DFCh-82252E04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252E04);
		  /* 82252E04h */ case    0:  		/* stw R10, <#[R11]> */
		/* 82252E04h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82252E04h case    0:*/		return 0x82252E08;
	}
	return 0x82252E08;
} // Block from 82252E04h-82252E08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82252E08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252E08);
		  /* 82252E08h */ case    0:  		/* stw R10, <#[R11 + 12]> */
		/* 82252E08h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82252E08h case    0:*/		return 0x82252E0C;
	}
	return 0x82252E0C;
} // Block from 82252E08h-82252E0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82252E0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252E0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252E0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252E0C);
		  /* 82252E0Ch */ case    0:  		/* stw R10, <#[R11 + 4]> */
		/* 82252E0Ch case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82252E0Ch case    0:*/		return 0x82252E10;
	}
	return 0x82252E10;
} // Block from 82252E0Ch-82252E10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82252E10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252E10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252E10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252E10);
		  /* 82252E10h */ case    0:  		/* stw R10, <#[R11 + 8]> */
		/* 82252E10h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82252E10h case    0:*/		return 0x82252E14;
		  /* 82252E14h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82252E14h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252E14h case    1:*/		return 0x82252E18;
	}
	return 0x82252E18;
} // Block from 82252E10h-82252E18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252E18h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252E18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252E18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252E18);
		  /* 82252E18h */ case    0:  		/* addi R10, R4, -2 */
		/* 82252E18h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0xFFFFFFFE);
		/* 82252E18h case    0:*/		return 0x82252E1C;
		  /* 82252E1Ch */ case    1:  		/* mr R11, R3 */
		/* 82252E1Ch case    1:*/		regs.R11 = regs.R3;
		/* 82252E1Ch case    1:*/		return 0x82252E20;
		  /* 82252E20h */ case    2:  		/* cmplwi CR6, R10, 36 */
		/* 82252E20h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000024);
		/* 82252E20h case    2:*/		return 0x82252E24;
		  /* 82252E24h */ case    3:  		/* bc 12, CR6_GT, 324 */
		/* 82252E24h case    3:*/		if ( regs.CR[6].gt ) { return 0x82252F68;  }
		/* 82252E24h case    3:*/		return 0x82252E28;
		  /* 82252E28h */ case    4:  		/* lis R12, -32252 */
		/* 82252E28h case    4:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8204);
		/* 82252E28h case    4:*/		return 0x82252E2C;
		  /* 82252E2Ch */ case    5:  		/* addi R12, R12, 18168 */
		/* 82252E2Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x46F8);
		/* 82252E2Ch case    5:*/		return 0x82252E30;
		  /* 82252E30h */ case    6:  		/* lbzx R0, <#[R12 + R10]> */
		/* 82252E30h case    6:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R10 + 0x00000000) );
		/* 82252E30h case    6:*/		return 0x82252E34;
		  /* 82252E34h */ case    7:  		/* rlwinm R0, R0, 2, 0, 29 */
		/* 82252E34h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R0,regs.R0);
		/* 82252E34h case    7:*/		return 0x82252E38;
		  /* 82252E38h */ case    8:  		/* lis R12, -32219 */
		/* 82252E38h case    8:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8225);
		/* 82252E38h case    8:*/		return 0x82252E3C;
		  /* 82252E3Ch */ case    9:  		/* ori R0, R0, 0 */
		/* 82252E3Ch case    9:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82252E3Ch case    9:*/		return 0x82252E40;
		  /* 82252E40h */ case   10:  		/* addi R12, R12, 11856 */
		/* 82252E40h case   10:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x2E50);
		/* 82252E40h case   10:*/		return 0x82252E44;
		  /* 82252E44h */ case   11:  		/* add R12, R12, R0 */
		/* 82252E44h case   11:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 82252E44h case   11:*/		return 0x82252E48;
		  /* 82252E48h */ case   12:  		/* mtspr CTR, R12 */
		/* 82252E48h case   12:*/		regs.CTR = regs.R12;
		/* 82252E48h case   12:*/		return 0x82252E4C;
		  /* 82252E4Ch */ case   13:  		/* bcctr 20, CR0_LT */
		/* 82252E4Ch case   13:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82252E4Ch case   13:*/		return 0x82252E50;
		  /* 82252E50h */ case   14:  		/* li R9, 8 */
		/* 82252E50h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 82252E50h case   14:*/		return 0x82252E54;
		  /* 82252E54h */ case   15:  		/* li R10, 0 */
		/* 82252E54h case   15:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82252E54h case   15:*/		return 0x82252E58;
	}
	return 0x82252E58;
} // Block from 82252E18h-82252E58h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82252E58h
// Function '?RemoveInterpolator@LinkageInfo@XGRAPHICS@@QAAXPAVCFG@2@W4RegType@R400Tables@@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252E58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252E58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252E58);
		  /* 82252E58h */ case    0:  		/* stw R9, <#[R11]> */
		/* 82252E58h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82252E58h case    0:*/		return 0x82252E5C;
		  /* 82252E5Ch */ case    1:  		/* li R3, 1 */
		/* 82252E5Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82252E5Ch case    1:*/		return 0x82252E60;
		  /* 82252E60h */ case    2:  		/* b 276 */
		/* 82252E60h case    2:*/		return 0x82252F74;
		/* 82252E60h case    2:*/		return 0x82252E64;
		  /* 82252E64h */ case    3:  		/* li R10, 5 */
		/* 82252E64h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 82252E64h case    3:*/		return 0x82252E68;
		  /* 82252E68h */ case    4:  		/* li R9, 1 */
		/* 82252E68h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82252E68h case    4:*/		return 0x82252E6C;
		  /* 82252E6Ch */ case    5:  		/* stw R10, <#[R11]> */
		/* 82252E6Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82252E6Ch case    5:*/		return 0x82252E70;
		  /* 82252E70h */ case    6:  		/* li R3, 4 */
		/* 82252E70h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x4);
		/* 82252E70h case    6:*/		return 0x82252E74;
		  /* 82252E74h */ case    7:  		/* stw R9, <#[R11 + 12]> */
		/* 82252E74h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82252E74h case    7:*/		return 0x82252E78;
		  /* 82252E78h */ case    8:  		/* b 256 */
		/* 82252E78h case    8:*/		return 0x82252F78;
		/* 82252E78h case    8:*/		return 0x82252E7C;
		  /* 82252E7Ch */ case    9:  		/* li R10, 5 */
		/* 82252E7Ch case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 82252E7Ch case    9:*/		return 0x82252E80;
		  /* 82252E80h */ case   10:  		/* li R9, 6 */
		/* 82252E80h case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x6);
		/* 82252E80h case   10:*/		return 0x82252E84;
		  /* 82252E84h */ case   11:  		/* li R8, 0 */
		/* 82252E84h case   11:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82252E84h case   11:*/		return 0x82252E88;
		  /* 82252E88h */ case   12:  		/* stw R10, <#[R11]> */
		/* 82252E88h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82252E88h case   12:*/		return 0x82252E8C;
		  /* 82252E8Ch */ case   13:  		/* stw R9, <#[R11 + 4]> */
		/* 82252E8Ch case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82252E8Ch case   13:*/		return 0x82252E90;
		  /* 82252E90h */ case   14:  		/* li R3, 3 */
		/* 82252E90h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 82252E90h case   14:*/		return 0x82252E94;
		  /* 82252E94h */ case   15:  		/* stw R8, <#[R11 + 12]> */
		/* 82252E94h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 82252E94h case   15:*/		return 0x82252E98;
		  /* 82252E98h */ case   16:  		/* b 228 */
		/* 82252E98h case   16:*/		return 0x82252F7C;
		/* 82252E98h case   16:*/		return 0x82252E9C;
		  /* 82252E9Ch */ case   17:  		/* li R10, 5 */
		/* 82252E9Ch case   17:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 82252E9Ch case   17:*/		return 0x82252EA0;
		  /* 82252EA0h */ case   18:  		/* li R9, 6 */
		/* 82252EA0h case   18:*/		cpu::op::li<0>(regs,&regs.R9,0x6);
		/* 82252EA0h case   18:*/		return 0x82252EA4;
		  /* 82252EA4h */ case   19:  		/* li R8, 0 */
		/* 82252EA4h case   19:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82252EA4h case   19:*/		return 0x82252EA8;
		  /* 82252EA8h */ case   20:  		/* stw R10, <#[R11]> */
		/* 82252EA8h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82252EA8h case   20:*/		return 0x82252EAC;
		  /* 82252EACh */ case   21:  		/* stw R10, <#[R11 + 4]> */
		/* 82252EACh case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82252EACh case   21:*/		return 0x82252EB0;
		  /* 82252EB0h */ case   22:  		/* li R3, 3 */
		/* 82252EB0h case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 82252EB0h case   22:*/		return 0x82252EB4;
		  /* 82252EB4h */ case   23:  		/* stw R9, <#[R11 + 8]> */
		/* 82252EB4h case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82252EB4h case   23:*/		return 0x82252EB8;
		  /* 82252EB8h */ case   24:  		/* stw R8, <#[R11 + 12]> */
		/* 82252EB8h case   24:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 82252EB8h case   24:*/		return 0x82252EBC;
		  /* 82252EBCh */ case   25:  		/* bclr 20, CR0_LT */
		/* 82252EBCh case   25:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252EBCh case   25:*/		return 0x82252EC0;
	}
	return 0x82252EC0;
} // Block from 82252E58h-82252EC0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82252EC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252EC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252EC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252EC0);
		  /* 82252EC0h */ case    0:  		/* li R9, 8 */
		/* 82252EC0h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 82252EC0h case    0:*/		return 0x82252EC4;
		  /* 82252EC4h */ case    1:  		/* li R10, 0 */
		/* 82252EC4h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82252EC4h case    1:*/		return 0x82252EC8;
		  /* 82252EC8h */ case    2:  		/* stw R9, <#[R11]> */
		/* 82252EC8h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82252EC8h case    2:*/		return 0x82252ECC;
		  /* 82252ECCh */ case    3:  		/* li R3, 2 */
		/* 82252ECCh case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 82252ECCh case    3:*/		return 0x82252ED0;
		  /* 82252ED0h */ case    4:  		/* stw R9, <#[R11 + 4]> */
		/* 82252ED0h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82252ED0h case    4:*/		return 0x82252ED4;
		  /* 82252ED4h */ case    5:  		/* stw R10, <#[R11 + 12]> */
		/* 82252ED4h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82252ED4h case    5:*/		return 0x82252ED8;
		  /* 82252ED8h */ case    6:  		/* b 164 */
		/* 82252ED8h case    6:*/		return 0x82252F7C;
		/* 82252ED8h case    6:*/		return 0x82252EDC;
		  /* 82252EDCh */ case    7:  		/* li R10, 4 */
		/* 82252EDCh case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 82252EDCh case    7:*/		return 0x82252EE0;
		  /* 82252EE0h */ case    8:  		/* li R3, 4 */
		/* 82252EE0h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x4);
		/* 82252EE0h case    8:*/		return 0x82252EE4;
		  /* 82252EE4h */ case    9:  		/* b 140 */
		/* 82252EE4h case    9:*/		return 0x82252F70;
		/* 82252EE4h case    9:*/		return 0x82252EE8;
		  /* 82252EE8h */ case   10:  		/* li R9, 16 */
		/* 82252EE8h case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 82252EE8h case   10:*/		return 0x82252EEC;
		  /* 82252EECh */ case   11:  		/* b -152 */
		/* 82252EECh case   11:*/		return 0x82252E54;
		/* 82252EECh case   11:*/		return 0x82252EF0;
		  /* 82252EF0h */ case   12:  		/* li R9, 8 */
		/* 82252EF0h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 82252EF0h case   12:*/		return 0x82252EF4;
		  /* 82252EF4h */ case   13:  		/* li R3, 4 */
		/* 82252EF4h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x4);
		/* 82252EF4h case   13:*/		return 0x82252EF8;
		  /* 82252EF8h */ case   14:  		/* stw R9, <#[R11]> */
		/* 82252EF8h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82252EF8h case   14:*/		return 0x82252EFC;
		  /* 82252EFCh */ case   15:  		/* stw R9, <#[R11 + 4]> */
		/* 82252EFCh case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82252EFCh case   15:*/		return 0x82252F00;
		  /* 82252F00h */ case   16:  		/* stw R9, <#[R11 + 8]> */
		/* 82252F00h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82252F00h case   16:*/		return 0x82252F04;
		  /* 82252F04h */ case   17:  		/* stw R9, <#[R11 + 12]> */
		/* 82252F04h case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82252F04h case   17:*/		return 0x82252F08;
		  /* 82252F08h */ case   18:  		/* bclr 20, CR0_LT */
		/* 82252F08h case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252F08h case   18:*/		return 0x82252F0C;
	}
	return 0x82252F0C;
} // Block from 82252EC0h-82252F0Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 82252F0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252F0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252F0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252F0C);
		  /* 82252F0Ch */ case    0:  		/* li R10, 10 */
		/* 82252F0Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0xA);
		/* 82252F0Ch case    0:*/		return 0x82252F10;
		  /* 82252F10h */ case    1:  		/* li R9, 2 */
		/* 82252F10h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 82252F10h case    1:*/		return 0x82252F14;
		  /* 82252F14h */ case    2:  		/* b -168 */
		/* 82252F14h case    2:*/		return 0x82252E6C;
		/* 82252F14h case    2:*/		return 0x82252F18;
		  /* 82252F18h */ case    3:  		/* li R10, 11 */
		/* 82252F18h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0xB);
		/* 82252F18h case    3:*/		return 0x82252F1C;
		  /* 82252F1Ch */ case    4:  		/* li R9, 10 */
		/* 82252F1Ch case    4:*/		cpu::op::li<0>(regs,&regs.R9,0xA);
		/* 82252F1Ch case    4:*/		return 0x82252F20;
		  /* 82252F20h */ case    5:  		/* b -124 */
		/* 82252F20h case    5:*/		return 0x82252EA4;
		/* 82252F20h case    5:*/		return 0x82252F24;
		  /* 82252F24h */ case    6:  		/* li R9, 10 */
		/* 82252F24h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0xA);
		/* 82252F24h case    6:*/		return 0x82252F28;
		  /* 82252F28h */ case    7:  		/* li R8, 0 */
		/* 82252F28h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82252F28h case    7:*/		return 0x82252F2C;
		  /* 82252F2Ch */ case    8:  		/* li R10, 11 */
		/* 82252F2Ch case    8:*/		cpu::op::li<0>(regs,&regs.R10,0xB);
		/* 82252F2Ch case    8:*/		return 0x82252F30;
		  /* 82252F30h */ case    9:  		/* stw R9, <#[R11]> */
		/* 82252F30h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82252F30h case    9:*/		return 0x82252F34;
		  /* 82252F34h */ case   10:  		/* li R3, 3 */
		/* 82252F34h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 82252F34h case   10:*/		return 0x82252F38;
		  /* 82252F38h */ case   11:  		/* stw R8, <#[R11 + 12]> */
		/* 82252F38h case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 82252F38h case   11:*/		return 0x82252F3C;
		  /* 82252F3Ch */ case   12:  		/* b 60 */
		/* 82252F3Ch case   12:*/		return 0x82252F78;
		/* 82252F3Ch case   12:*/		return 0x82252F40;
		  /* 82252F40h */ case   13:  		/* li R9, 16 */
		/* 82252F40h case   13:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 82252F40h case   13:*/		return 0x82252F44;
		  /* 82252F44h */ case   14:  		/* b -128 */
		/* 82252F44h case   14:*/		return 0x82252EC4;
		/* 82252F44h case   14:*/		return 0x82252F48;
		  /* 82252F48h */ case   15:  		/* li R9, 32 */
		/* 82252F48h case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x20);
		/* 82252F48h case   15:*/		return 0x82252F4C;
		  /* 82252F4Ch */ case   16:  		/* b -248 */
		/* 82252F4Ch case   16:*/		return 0x82252E54;
		/* 82252F4Ch case   16:*/		return 0x82252F50;
		  /* 82252F50h */ case   17:  		/* li R9, 16 */
		/* 82252F50h case   17:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 82252F50h case   17:*/		return 0x82252F54;
		  /* 82252F54h */ case   18:  		/* b -96 */
		/* 82252F54h case   18:*/		return 0x82252EF4;
		/* 82252F54h case   18:*/		return 0x82252F58;
		  /* 82252F58h */ case   19:  		/* li R9, 32 */
		/* 82252F58h case   19:*/		cpu::op::li<0>(regs,&regs.R9,0x20);
		/* 82252F58h case   19:*/		return 0x82252F5C;
		  /* 82252F5Ch */ case   20:  		/* b -152 */
		/* 82252F5Ch case   20:*/		return 0x82252EC4;
		/* 82252F5Ch case   20:*/		return 0x82252F60;
		  /* 82252F60h */ case   21:  		/* li R9, 32 */
		/* 82252F60h case   21:*/		cpu::op::li<0>(regs,&regs.R9,0x20);
		/* 82252F60h case   21:*/		return 0x82252F64;
		  /* 82252F64h */ case   22:  		/* b -112 */
		/* 82252F64h case   22:*/		return 0x82252EF4;
		/* 82252F64h case   22:*/		return 0x82252F68;
	}
	return 0x82252F68;
} // Block from 82252F0Ch-82252F68h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82252F68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252F68);
		  /* 82252F68h */ case    0:  		/* li R10, 0 */
		/* 82252F68h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82252F68h case    0:*/		return 0x82252F6C;
		  /* 82252F6Ch */ case    1:  		/* li R3, 0 */
		/* 82252F6Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82252F6Ch case    1:*/		return 0x82252F70;
	}
	return 0x82252F70;
} // Block from 82252F68h-82252F70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252F70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252F70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252F70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252F70);
		  /* 82252F70h */ case    0:  		/* stw R10, <#[R11]> */
		/* 82252F70h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82252F70h case    0:*/		return 0x82252F74;
	}
	return 0x82252F74;
} // Block from 82252F70h-82252F74h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82252F74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252F74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252F74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252F74);
		  /* 82252F74h */ case    0:  		/* stw R10, <#[R11 + 12]> */
		/* 82252F74h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82252F74h case    0:*/		return 0x82252F78;
	}
	return 0x82252F78;
} // Block from 82252F74h-82252F78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82252F78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252F78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252F78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252F78);
		  /* 82252F78h */ case    0:  		/* stw R10, <#[R11 + 4]> */
		/* 82252F78h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82252F78h case    0:*/		return 0x82252F7C;
	}
	return 0x82252F7C;
} // Block from 82252F78h-82252F7Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82252F7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252F7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252F7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252F7C);
		  /* 82252F7Ch */ case    0:  		/* stw R10, <#[R11 + 8]> */
		/* 82252F7Ch case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82252F7Ch case    0:*/		return 0x82252F80;
		  /* 82252F80h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82252F80h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82252F80h case    1:*/		return 0x82252F84;
	}
	return 0x82252F84;
} // Block from 82252F7Ch-82252F84h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82252F84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252F84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252F84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252F84);
		  /* 82252F84h */ case    0:  		/* nop */
		/* 82252F84h case    0:*/		cpu::op::nop();
		/* 82252F84h case    0:*/		return 0x82252F88;
	}
	return 0x82252F88;
} // Block from 82252F84h-82252F88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82252F88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252F88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252F88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252F88);
		  /* 82252F88h */ case    0:  		/* mfspr R12, LR */
		/* 82252F88h case    0:*/		regs.R12 = regs.LR;
		/* 82252F88h case    0:*/		return 0x82252F8C;
		  /* 82252F8Ch */ case    1:  		/* bl -1842488 */
		/* 82252F8Ch case    1:*/		regs.LR = 0x82252F90; return 0x82091254;
		/* 82252F8Ch case    1:*/		return 0x82252F90;
		  /* 82252F90h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82252F90h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82252F90h case    2:*/		return 0x82252F94;
		  /* 82252F94h */ case    3:  		/* mr R7, R3 */
		/* 82252F94h case    3:*/		regs.R7 = regs.R3;
		/* 82252F94h case    3:*/		return 0x82252F98;
		  /* 82252F98h */ case    4:  		/* mr R3, R5 */
		/* 82252F98h case    4:*/		regs.R3 = regs.R5;
		/* 82252F98h case    4:*/		return 0x82252F9C;
		  /* 82252F9Ch */ case    5:  		/* mr R28, R4 */
		/* 82252F9Ch case    5:*/		regs.R28 = regs.R4;
		/* 82252F9Ch case    5:*/		return 0x82252FA0;
		  /* 82252FA0h */ case    6:  		/* bl -1104 */
		/* 82252FA0h case    6:*/		regs.LR = 0x82252FA4; return 0x82252B50;
		/* 82252FA0h case    6:*/		return 0x82252FA4;
		  /* 82252FA4h */ case    7:  		/* or. R29, R3, R3 */
		/* 82252FA4h case    7:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 82252FA4h case    7:*/		return 0x82252FA8;
		  /* 82252FA8h */ case    8:  		/* bc 4, CR0_EQ, 12 */
		/* 82252FA8h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82252FB4;  }
		/* 82252FA8h case    8:*/		return 0x82252FAC;
		  /* 82252FACh */ case    9:  		/* li R3, 0 */
		/* 82252FACh case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82252FACh case    9:*/		return 0x82252FB0;
		  /* 82252FB0h */ case   10:  		/* b 328 */
		/* 82252FB0h case   10:*/		return 0x822530F8;
		/* 82252FB0h case   10:*/		return 0x82252FB4;
	}
	return 0x82252FB4;
} // Block from 82252F88h-82252FB4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82252FB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82252FB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82252FB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82252FB4);
		  /* 82252FB4h */ case    0:  		/* mr R4, R5 */
		/* 82252FB4h case    0:*/		regs.R4 = regs.R5;
		/* 82252FB4h case    0:*/		return 0x82252FB8;
		  /* 82252FB8h */ case    1:  		/* addi R3, R1, 80 */
		/* 82252FB8h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82252FB8h case    1:*/		return 0x82252FBC;
		  /* 82252FBCh */ case    2:  		/* bl -828 */
		/* 82252FBCh case    2:*/		regs.LR = 0x82252FC0; return 0x82252C80;
		/* 82252FBCh case    2:*/		return 0x82252FC0;
		  /* 82252FC0h */ case    3:  		/* cmpwi CR6, R29, 4 */
		/* 82252FC0h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000004);
		/* 82252FC0h case    3:*/		return 0x82252FC4;
		  /* 82252FC4h */ case    4:  		/* bc 4, CR6_GT, 112 */
		/* 82252FC4h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82253034;  }
		/* 82252FC4h case    4:*/		return 0x82252FC8;
		  /* 82252FC8h */ case    5:  		/* li R4, 0 */
		/* 82252FC8h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82252FC8h case    5:*/		return 0x82252FCC;
		  /* 82252FCCh */ case    6:  		/* cmpwi CR6, R3, 0 */
		/* 82252FCCh case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82252FCCh case    6:*/		return 0x82252FD0;
		  /* 82252FD0h */ case    7:  		/* bc 4, CR6_GT, 240 */
		/* 82252FD0h case    7:*/		if ( !regs.CR[6].gt ) { return 0x822530C0;  }
		/* 82252FD0h case    7:*/		return 0x82252FD4;
		  /* 82252FD4h */ case    8:  		/* addi R11, R1, 80 */
		/* 82252FD4h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 82252FD4h case    8:*/		return 0x82252FD8;
		  /* 82252FD8h */ case    9:  		/* mr R9, R7 */
		/* 82252FD8h case    9:*/		regs.R9 = regs.R7;
		/* 82252FD8h case    9:*/		return 0x82252FDC;
		  /* 82252FDCh */ case   10:  		/* subf R30, R7, R11 */
		/* 82252FDCh case   10:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R7,regs.R11);
		/* 82252FDCh case   10:*/		return 0x82252FE0;
		  /* 82252FE0h */ case   11:  		/* mr R31, R3 */
		/* 82252FE0h case   11:*/		regs.R31 = regs.R3;
		/* 82252FE0h case   11:*/		return 0x82252FE4;
		  /* 82252FE4h */ case   12:  		/* lwzx R11, <#[R30 + R9]> */
		/* 82252FE4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R9 + 0x00000000) );
		/* 82252FE4h case   12:*/		return 0x82252FE8;
		  /* 82252FE8h */ case   13:  		/* li R8, 0 */
		/* 82252FE8h case   13:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82252FE8h case   13:*/		return 0x82252FEC;
		  /* 82252FECh */ case   14:  		/* lwz R5, <#[R9]> */
		/* 82252FECh case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000000) );
		/* 82252FECh case   14:*/		return 0x82252FF0;
		  /* 82252FF0h */ case   15:  		/* srawi. R10, R11, 3 */
		/* 82252FF0h case   15:*/		cpu::op::srawi<1,3>(regs,&regs.R10,regs.R11);
		/* 82252FF0h case   15:*/		return 0x82252FF4;
		  /* 82252FF4h */ case   16:  		/* bc 4, CR0_GT, 44 */
		/* 82252FF4h case   16:*/		if ( !regs.CR[0].gt ) { return 0x82253020;  }
		/* 82252FF4h case   16:*/		return 0x82252FF8;
		  /* 82252FF8h */ case   17:  		/* addi R7, R1, 96 */
		/* 82252FF8h case   17:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 82252FF8h case   17:*/		return 0x82252FFC;
		  /* 82252FFCh */ case   18:  		/* mtspr CTR, R10 */
		/* 82252FFCh case   18:*/		regs.CTR = regs.R10;
		/* 82252FFCh case   18:*/		return 0x82253000;
		  /* 82253000h */ case   19:  		/* li R11, 0 */
		/* 82253000h case   19:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82253000h case   19:*/		return 0x82253004;
		  /* 82253004h */ case   20:  		/* add R7, R4, R7 */
		/* 82253004h case   20:*/		cpu::op::add<0>(regs,&regs.R7,regs.R4,regs.R7);
		/* 82253004h case   20:*/		return 0x82253008;
		  /* 82253008h */ case   21:  		/* sraw R27, R5, R11 */
		/* 82253008h case   21:*/		cpu::op::sraw<0>(regs,&regs.R27,regs.R5,regs.R11);
		/* 82253008h case   21:*/		return 0x8225300C;
		  /* 8225300Ch */ case   22:  		/* extsb R27, R27 */
		/* 8225300Ch case   22:*/		cpu::op::extsb<0>(regs,&regs.R27,regs.R27);
		/* 8225300Ch case   22:*/		return 0x82253010;
		  /* 82253010h */ case   23:  		/* addi R11, R11, 8 */
		/* 82253010h case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 82253010h case   23:*/		return 0x82253014;
		  /* 82253014h */ case   24:  		/* stbx R27, <#[R7 + R8]> */
		/* 82253014h case   24:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 82253014h case   24:*/		return 0x82253018;
		  /* 82253018h */ case   25:  		/* addi R8, R8, 1 */
		/* 82253018h case   25:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82253018h case   25:*/		return 0x8225301C;
		  /* 8225301Ch */ case   26:  		/* bc 16, CR0_LT, -20 */
		/* 8225301Ch case   26:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82253008;  }
		/* 8225301Ch case   26:*/		return 0x82253020;
	}
	return 0x82253020;
} // Block from 82252FB4h-82253020h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82253020h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253020);
		  /* 82253020h */ case    0:  		/* addic. R31, R31, -1 */
		/* 82253020h case    0:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82253020h case    0:*/		return 0x82253024;
		  /* 82253024h */ case    1:  		/* add R4, R10, R4 */
		/* 82253024h case    1:*/		cpu::op::add<0>(regs,&regs.R4,regs.R10,regs.R4);
		/* 82253024h case    1:*/		return 0x82253028;
		  /* 82253028h */ case    2:  		/* addi R9, R9, 4 */
		/* 82253028h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82253028h case    2:*/		return 0x8225302C;
		  /* 8225302Ch */ case    3:  		/* bc 4, CR0_EQ, -72 */
		/* 8225302Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x82252FE4;  }
		/* 8225302Ch case    3:*/		return 0x82253030;
		  /* 82253030h */ case    4:  		/* b 144 */
		/* 82253030h case    4:*/		return 0x822530C0;
		/* 82253030h case    4:*/		return 0x82253034;
	}
	return 0x82253034;
} // Block from 82253020h-82253034h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82253034h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253034( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253034) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253034);
		  /* 82253034h */ case    0:  		/* li R5, 0 */
		/* 82253034h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82253034h case    0:*/		return 0x82253038;
		  /* 82253038h */ case    1:  		/* li R8, 0 */
		/* 82253038h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82253038h case    1:*/		return 0x8225303C;
		  /* 8225303Ch */ case    2:  		/* cmpwi CR6, R3, 0 */
		/* 8225303Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8225303Ch case    2:*/		return 0x82253040;
		  /* 82253040h */ case    3:  		/* bc 4, CR6_GT, 80 */
		/* 82253040h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82253090;  }
		/* 82253040h case    3:*/		return 0x82253044;
		  /* 82253044h */ case    4:  		/* addi R10, R1, 80 */
		/* 82253044h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82253044h case    4:*/		return 0x82253048;
		  /* 82253048h */ case    5:  		/* mtspr CTR, R3 */
		/* 82253048h case    5:*/		regs.CTR = regs.R3;
		/* 82253048h case    5:*/		return 0x8225304C;
		  /* 8225304Ch */ case    6:  		/* mr R11, R7 */
		/* 8225304Ch case    6:*/		regs.R11 = regs.R7;
		/* 8225304Ch case    6:*/		return 0x82253050;
		  /* 82253050h */ case    7:  		/* subf R7, R7, R10 */
		/* 82253050h case    7:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R7,regs.R10);
		/* 82253050h case    7:*/		return 0x82253054;
		  /* 82253054h */ case    8:  		/* lwzx R10, <#[R11 + R7]> */
		/* 82253054h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82253054h case    8:*/		return 0x82253058;
		  /* 82253058h */ case    9:  		/* cmpwi CR6, R10, 32 */
		/* 82253058h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000020);
		/* 82253058h case    9:*/		return 0x8225305C;
		  /* 8225305Ch */ case   10:  		/* bc 4, CR6_LT, 20 */
		/* 8225305Ch case   10:*/		if ( !regs.CR[6].lt ) { return 0x82253070;  }
		/* 8225305Ch case   10:*/		return 0x82253060;
		  /* 82253060h */ case   11:  		/* li R9, 1 */
		/* 82253060h case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82253060h case   11:*/		return 0x82253064;
		  /* 82253064h */ case   12:  		/* slw R9, R9, R10 */
		/* 82253064h case   12:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 82253064h case   12:*/		return 0x82253068;
		  /* 82253068h */ case   13:  		/* addi R9, R9, -1 */
		/* 82253068h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82253068h case   13:*/		return 0x8225306C;
		  /* 8225306Ch */ case   14:  		/* b 8 */
		/* 8225306Ch case   14:*/		return 0x82253074;
		/* 8225306Ch case   14:*/		return 0x82253070;
	}
	return 0x82253070;
} // Block from 82253034h-82253070h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82253070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253070);
		  /* 82253070h */ case    0:  		/* li R9, -1 */
		/* 82253070h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 82253070h case    0:*/		return 0x82253074;
	}
	return 0x82253074;
} // Block from 82253070h-82253074h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82253074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253074);
		  /* 82253074h */ case    0:  		/* lwz R4, <#[R11]> */
		/* 82253074h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 82253074h case    0:*/		return 0x82253078;
		  /* 82253078h */ case    1:  		/* addi R11, R11, 4 */
		/* 82253078h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82253078h case    1:*/		return 0x8225307C;
		  /* 8225307Ch */ case    2:  		/* and R9, R4, R9 */
		/* 8225307Ch case    2:*/		cpu::op::and<0>(regs,&regs.R9,regs.R4,regs.R9);
		/* 8225307Ch case    2:*/		return 0x82253080;
		  /* 82253080h */ case    3:  		/* slw R9, R9, R8 */
		/* 82253080h case    3:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82253080h case    3:*/		return 0x82253084;
		  /* 82253084h */ case    4:  		/* or R5, R9, R5 */
		/* 82253084h case    4:*/		cpu::op::or<0>(regs,&regs.R5,regs.R9,regs.R5);
		/* 82253084h case    4:*/		return 0x82253088;
		  /* 82253088h */ case    5:  		/* add R8, R10, R8 */
		/* 82253088h case    5:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R8);
		/* 82253088h case    5:*/		return 0x8225308C;
		  /* 8225308Ch */ case    6:  		/* bc 16, CR0_LT, -56 */
		/* 8225308Ch case    6:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82253054;  }
		/* 8225308Ch case    6:*/		return 0x82253090;
	}
	return 0x82253090;
} // Block from 82253074h-82253090h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82253090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253090);
		  /* 82253090h */ case    0:  		/* li R10, 0 */
		/* 82253090h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82253090h case    0:*/		return 0x82253094;
		  /* 82253094h */ case    1:  		/* cmpwi CR6, R29, 0 */
		/* 82253094h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82253094h case    1:*/		return 0x82253098;
		  /* 82253098h */ case    2:  		/* bc 4, CR6_GT, 40 */
		/* 82253098h case    2:*/		if ( !regs.CR[6].gt ) { return 0x822530C0;  }
		/* 82253098h case    2:*/		return 0x8225309C;
		  /* 8225309Ch */ case    3:  		/* li R11, 0 */
		/* 8225309Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225309Ch case    3:*/		return 0x822530A0;
		  /* 822530A0h */ case    4:  		/* mtspr CTR, R29 */
		/* 822530A0h case    4:*/		regs.CTR = regs.R29;
		/* 822530A0h case    4:*/		return 0x822530A4;
		  /* 822530A4h */ case    5:  		/* sraw R9, R5, R11 */
		/* 822530A4h case    5:*/		cpu::op::sraw<0>(regs,&regs.R9,regs.R5,regs.R11);
		/* 822530A4h case    5:*/		return 0x822530A8;
		  /* 822530A8h */ case    6:  		/* addi R8, R1, 96 */
		/* 822530A8h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 822530A8h case    6:*/		return 0x822530AC;
		  /* 822530ACh */ case    7:  		/* extsb R9, R9 */
		/* 822530ACh case    7:*/		cpu::op::extsb<0>(regs,&regs.R9,regs.R9);
		/* 822530ACh case    7:*/		return 0x822530B0;
	}
	return 0x822530B0;
} // Block from 82253090h-822530B0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822530B0h
// Function '?ReallyAssignInterpolators@LinkageInfo@XGRAPHICS@@QAAHPAVCFG@2@W4RegType@R400Tables@@HH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822530B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822530B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822530B0);
		  /* 822530B0h */ case    0:  		/* addi R11, R11, 8 */
		/* 822530B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 822530B0h case    0:*/		return 0x822530B4;
		  /* 822530B4h */ case    1:  		/* stbx R9, <#[R10 + R8]> */
		/* 822530B4h case    1:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 822530B4h case    1:*/		return 0x822530B8;
		  /* 822530B8h */ case    2:  		/* addi R10, R10, 1 */
		/* 822530B8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 822530B8h case    2:*/		return 0x822530BC;
		  /* 822530BCh */ case    3:  		/* bc 16, CR0_LT, -24 */
		/* 822530BCh case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x822530A4;  }
		/* 822530BCh case    3:*/		return 0x822530C0;
	}
	return 0x822530C0;
} // Block from 822530B0h-822530C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822530C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822530C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822530C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822530C0);
		  /* 822530C0h */ case    0:  		/* lis R11, -32216 */
		/* 822530C0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 822530C0h case    0:*/		return 0x822530C4;
		  /* 822530C4h */ case    1:  		/* rlwinm R10, R6, 2, 0, 29 */
		/* 822530C4h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R6);
		/* 822530C4h case    1:*/		return 0x822530C8;
		  /* 822530C8h */ case    2:  		/* addi R9, R11, 11992 */
		/* 822530C8h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x2ED8);
		/* 822530C8h case    2:*/		return 0x822530CC;
		  /* 822530CCh */ case    3:  		/* li R11, 0 */
		/* 822530CCh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822530CCh case    3:*/		return 0x822530D0;
		  /* 822530D0h */ case    4:  		/* cmpwi CR6, R29, 0 */
		/* 822530D0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 822530D0h case    4:*/		return 0x822530D4;
		  /* 822530D4h */ case    5:  		/* lwzx R10, <#[R10 + R9]> */
		/* 822530D4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 822530D4h case    5:*/		return 0x822530D8;
		  /* 822530D8h */ case    6:  		/* bc 4, CR6_GT, 32 */
		/* 822530D8h case    6:*/		if ( !regs.CR[6].gt ) { return 0x822530F8;  }
		/* 822530D8h case    6:*/		return 0x822530DC;
		  /* 822530DCh */ case    7:  		/* mtspr CTR, R29 */
		/* 822530DCh case    7:*/		regs.CTR = regs.R29;
		/* 822530DCh case    7:*/		return 0x822530E0;
		  /* 822530E0h */ case    8:  		/* addi R9, R1, 96 */
		/* 822530E0h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 822530E0h case    8:*/		return 0x822530E4;
		  /* 822530E4h */ case    9:  		/* xor R8, R10, R11 */
		/* 822530E4h case    9:*/		cpu::op::xor<0>(regs,&regs.R8,regs.R10,regs.R11);
		/* 822530E4h case    9:*/		return 0x822530E8;
		  /* 822530E8h */ case   10:  		/* lbzx R9, <#[R11 + R9]> */
		/* 822530E8h case   10:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 822530E8h case   10:*/		return 0x822530EC;
		  /* 822530ECh */ case   11:  		/* addi R11, R11, 1 */
		/* 822530ECh case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822530ECh case   11:*/		return 0x822530F0;
		  /* 822530F0h */ case   12:  		/* stbx R9, <#[R8 + R28]> */
		/* 822530F0h case   12:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R8 + regs.R28 + 0x00000000) );
		/* 822530F0h case   12:*/		return 0x822530F4;
		  /* 822530F4h */ case   13:  		/* bc 16, CR0_LT, -20 */
		/* 822530F4h case   13:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x822530E0;  }
		/* 822530F4h case   13:*/		return 0x822530F8;
	}
	return 0x822530F8;
} // Block from 822530C0h-822530F8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822530F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822530F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822530F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822530F8);
		  /* 822530F8h */ case    0:  		/* addi R1, R1, 160 */
		/* 822530F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 822530F8h case    0:*/		return 0x822530FC;
		  /* 822530FCh */ case    1:  		/* b -1842776 */
		/* 822530FCh case    1:*/		return 0x820912A4;
		/* 822530FCh case    1:*/		return 0x82253100;
	}
	return 0x82253100;
} // Block from 822530F8h-82253100h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82253100h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253100);
		  /* 82253100h */ case    0:  		/* mfspr R12, LR */
		/* 82253100h case    0:*/		regs.R12 = regs.LR;
		/* 82253100h case    0:*/		return 0x82253104;
		  /* 82253104h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82253104h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82253104h case    1:*/		return 0x82253108;
		  /* 82253108h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82253108h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82253108h case    2:*/		return 0x8225310C;
		  /* 8225310Ch */ case    3:  		/* mr R10, R3 */
		/* 8225310Ch case    3:*/		regs.R10 = regs.R3;
		/* 8225310Ch case    3:*/		return 0x82253110;
		  /* 82253110h */ case    4:  		/* mr R3, R5 */
		/* 82253110h case    4:*/		regs.R3 = regs.R5;
		/* 82253110h case    4:*/		return 0x82253114;
		  /* 82253114h */ case    5:  		/* bl -1372 */
		/* 82253114h case    5:*/		regs.LR = 0x82253118; return 0x82252BB8;
		/* 82253114h case    5:*/		return 0x82253118;
		  /* 82253118h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 82253118h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82253118h case    6:*/		return 0x8225311C;
		  /* 8225311Ch */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 8225311Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x82253128;  }
		/* 8225311Ch case    7:*/		return 0x82253120;
		  /* 82253120h */ case    8:  		/* mr R3, R10 */
		/* 82253120h case    8:*/		regs.R3 = regs.R10;
		/* 82253120h case    8:*/		return 0x82253124;
		  /* 82253124h */ case    9:  		/* bl -412 */
		/* 82253124h case    9:*/		regs.LR = 0x82253128; return 0x82252F88;
		/* 82253124h case    9:*/		return 0x82253128;
	}
	return 0x82253128;
} // Block from 82253100h-82253128h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82253128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253128);
		  /* 82253128h */ case    0:  		/* addi R1, R1, 96 */
		/* 82253128h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82253128h case    0:*/		return 0x8225312C;
		  /* 8225312Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8225312Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225312Ch case    1:*/		return 0x82253130;
		  /* 82253130h */ case    2:  		/* mtspr LR, R12 */
		/* 82253130h case    2:*/		regs.LR = regs.R12;
		/* 82253130h case    2:*/		return 0x82253134;
		  /* 82253134h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82253134h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82253134h case    3:*/		return 0x82253138;
	}
	return 0x82253138;
} // Block from 82253128h-82253138h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82253138h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253138);
		  /* 82253138h */ case    0:  		/* mfspr R12, LR */
		/* 82253138h case    0:*/		regs.R12 = regs.LR;
		/* 82253138h case    0:*/		return 0x8225313C;
		  /* 8225313Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225313Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225313Ch case    1:*/		return 0x82253140;
		  /* 82253140h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82253140h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82253140h case    2:*/		return 0x82253144;
		  /* 82253144h */ case    3:  		/* mr R10, R3 */
		/* 82253144h case    3:*/		regs.R10 = regs.R3;
		/* 82253144h case    3:*/		return 0x82253148;
		  /* 82253148h */ case    4:  		/* cmpwi CR6, R5, 1 */
		/* 82253148h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000001);
		/* 82253148h case    4:*/		return 0x8225314C;
		  /* 8225314Ch */ case    5:  		/* bc 4, CR6_EQ, 68 */
		/* 8225314Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x82253190;  }
		/* 8225314Ch case    5:*/		return 0x82253150;
		  /* 82253150h */ case    6:  		/* mr R3, R4 */
		/* 82253150h case    6:*/		regs.R3 = regs.R4;
		/* 82253150h case    6:*/		return 0x82253154;
		  /* 82253154h */ case    7:  		/* bl -1332 */
		/* 82253154h case    7:*/		regs.LR = 0x82253158; return 0x82252C20;
		/* 82253154h case    7:*/		return 0x82253158;
		  /* 82253158h */ case    8:  		/* cmpwi CR6, R3, 3 */
		/* 82253158h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000003);
		/* 82253158h case    8:*/		return 0x8225315C;
		  /* 8225315Ch */ case    9:  		/* bc 12, CR6_LT, 24 */
		/* 8225315Ch case    9:*/		if ( regs.CR[6].lt ) { return 0x82253174;  }
		/* 8225315Ch case    9:*/		return 0x82253160;
		  /* 82253160h */ case   10:  		/* lwz R11, <#[R10]> */
		/* 82253160h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82253160h case   10:*/		return 0x82253164;
		  /* 82253164h */ case   11:  		/* lwz R9, <#[R10 + 8]> */
		/* 82253164h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 82253164h case   11:*/		return 0x82253168;
		  /* 82253168h */ case   12:  		/* stw R11, <#[R10 + 8]> */
		/* 82253168h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82253168h case   12:*/		return 0x8225316C;
		  /* 8225316Ch */ case   13:  		/* stw R9, <#[R10]> */
		/* 8225316Ch case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8225316Ch case   13:*/		return 0x82253170;
		  /* 82253170h */ case   14:  		/* b 32 */
		/* 82253170h case   14:*/		return 0x82253190;
		/* 82253170h case   14:*/		return 0x82253174;
	}
	return 0x82253174;
} // Block from 82253138h-82253174h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82253174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253174);
		  /* 82253174h */ case    0:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 82253174h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 82253174h case    0:*/		return 0x82253178;
		  /* 82253178h */ case    1:  		/* lwz R8, <#[R10 + 12]> */
		/* 82253178h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x0000000C) );
		/* 82253178h case    1:*/		return 0x8225317C;
		  /* 8225317Ch */ case    2:  		/* add R11, R11, R10 */
		/* 8225317Ch case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8225317Ch case    2:*/		return 0x82253180;
		  /* 82253180h */ case    3:  		/* addi R9, R11, -4 */
		/* 82253180h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFC);
		/* 82253180h case    3:*/		return 0x82253184;
		  /* 82253184h */ case    4:  		/* lwz R9, <#[R11 - 4]> */
		/* 82253184h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 82253184h case    4:*/		return 0x82253188;
		  /* 82253188h */ case    5:  		/* stw R8, <#[R11 - 4]> */
		/* 82253188h case    5:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 82253188h case    5:*/		return 0x8225318C;
		  /* 8225318Ch */ case    6:  		/* stw R9, <#[R10 + 12]> */
		/* 8225318Ch case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 8225318Ch case    6:*/		return 0x82253190;
	}
	return 0x82253190;
} // Block from 82253174h-82253190h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82253190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253190);
		  /* 82253190h */ case    0:  		/* addi R1, R1, 96 */
		/* 82253190h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82253190h case    0:*/		return 0x82253194;
		  /* 82253194h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82253194h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82253194h case    1:*/		return 0x82253198;
		  /* 82253198h */ case    2:  		/* mtspr LR, R12 */
		/* 82253198h case    2:*/		regs.LR = regs.R12;
		/* 82253198h case    2:*/		return 0x8225319C;
		  /* 8225319Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 8225319Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225319Ch case    3:*/		return 0x822531A0;
	}
	return 0x822531A0;
} // Block from 82253190h-822531A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822531A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822531A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822531A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822531A0);
		  /* 822531A0h */ case    0:  		/* extsw R11, R4 */
		/* 822531A0h case    0:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R4);
		/* 822531A0h case    0:*/		return 0x822531A4;
		  /* 822531A4h */ case    1:  		/* lis R10, 20096 */
		/* 822531A4h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x4E80);
		/* 822531A4h case    1:*/		return 0x822531A8;
		  /* 822531A8h */ case    2:  		/* std R11, <#[R1 - 16]> */
		/* 822531A8h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822531A8h case    2:*/		return 0x822531AC;
		  /* 822531ACh */ case    3:  		/* lfd FR0, <#[R1 - 16]> */
		/* 822531ACh case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822531ACh case    3:*/		return 0x822531B0;
		  /* 822531B0h */ case    4:  		/* fcfid FR0, FR0 */
		/* 822531B0h case    4:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 822531B0h case    4:*/		return 0x822531B4;
		  /* 822531B4h */ case    5:  		/* frsp FR0, FR0 */
		/* 822531B4h case    5:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 822531B4h case    5:*/		return 0x822531B8;
		  /* 822531B8h */ case    6:  		/* fmuls FR0, FR0, FR1 */
		/* 822531B8h case    6:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR0,regs.FR1);
		/* 822531B8h case    6:*/		return 0x822531BC;
		  /* 822531BCh */ case    7:  		/* stfs FR0, <#[R1 - 16]> */
		/* 822531BCh case    7:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822531BCh case    7:*/		return 0x822531C0;
		  /* 822531C0h */ case    8:  		/* lwz R11, <#[R1 - 16]> */
		/* 822531C0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822531C0h case    8:*/		return 0x822531C4;
		  /* 822531C4h */ case    9:  		/* rlwinm R9, R11, 0, 1, 8 */
		/* 822531C4h case    9:*/		cpu::op::rlwinm<0,0,1,8>(regs,&regs.R9,regs.R11);
		/* 822531C4h case    9:*/		return 0x822531C8;
		  /* 822531C8h */ case   10:  		/* cmpw CR6, R9, R10 */
		/* 822531C8h case   10:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R10);
		/* 822531C8h case   10:*/		return 0x822531CC;
		  /* 822531CCh */ case   11:  		/* bc 4, CR6_GT, 32 */
		/* 822531CCh case   11:*/		if ( !regs.CR[6].gt ) { return 0x822531EC;  }
		/* 822531CCh case   11:*/		return 0x822531D0;
		  /* 822531D0h */ case   12:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 822531D0h case   12:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 822531D0h case   12:*/		return 0x822531D4;
		  /* 822531D4h */ case   13:  		/* bc 12, CR0_EQ, 12 */
		/* 822531D4h case   13:*/		if ( regs.CR[0].eq ) { return 0x822531E0;  }
		/* 822531D4h case   13:*/		return 0x822531D8;
		  /* 822531D8h */ case   14:  		/* lis R3, -32768 */
		/* 822531D8h case   14:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 822531D8h case   14:*/		return 0x822531DC;
		  /* 822531DCh */ case   15:  		/* bclr 20, CR0_LT */
		/* 822531DCh case   15:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822531DCh case   15:*/		return 0x822531E0;
	}
	return 0x822531E0;
} // Block from 822531A0h-822531E0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822531E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822531E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822531E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822531E0);
		  /* 822531E0h */ case    0:  		/* lis R3, 32767 */
		/* 822531E0h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0x7FFF);
		/* 822531E0h case    0:*/		return 0x822531E4;
		  /* 822531E4h */ case    1:  		/* ori R3, R3, 65535 */
		/* 822531E4h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xFFFF);
		/* 822531E4h case    1:*/		return 0x822531E8;
		  /* 822531E8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 822531E8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822531E8h case    2:*/		return 0x822531EC;
	}
	return 0x822531EC;
} // Block from 822531E0h-822531ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 822531ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822531EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822531EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822531EC);
		  /* 822531ECh */ case    0:  		/* fctiwz FR0, FR0 */
		/* 822531ECh case    0:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 822531ECh case    0:*/		return 0x822531F0;
		  /* 822531F0h */ case    1:  		/* stfd FR0, <#[R1 - 16]> */
		/* 822531F0h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822531F0h case    1:*/		return 0x822531F4;
		  /* 822531F4h */ case    2:  		/* lwz R3, <#[R1 - 12]> */
		/* 822531F4h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 822531F4h case    2:*/		return 0x822531F8;
		  /* 822531F8h */ case    3:  		/* bclr 20, CR0_LT */
		/* 822531F8h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822531F8h case    3:*/		return 0x822531FC;
	}
	return 0x822531FC;
} // Block from 822531ECh-822531FCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 822531FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822531FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822531FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822531FC);
		  /* 822531FCh */ case    0:  		/* nop */
		/* 822531FCh case    0:*/		cpu::op::nop();
		/* 822531FCh case    0:*/		return 0x82253200;
	}
	return 0x82253200;
} // Block from 822531FCh-82253200h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82253200h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253200);
		  /* 82253200h */ case    0:  		/* lis R11, -32256 */
		/* 82253200h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82253200h case    0:*/		return 0x82253204;
		  /* 82253204h */ case    1:  		/* lfs FR0, <#[R11 + 2964]> */
		/* 82253204h case    1:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000B94) );
		/* 82253204h case    1:*/		return 0x82253208;
		  /* 82253208h */ case    2:  		/* fcmpu CR6, FR1, FR0 */
		/* 82253208h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82253208h case    2:*/		return 0x8225320C;
		  /* 8225320Ch */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 8225320Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8225321C;  }
		/* 8225320Ch case    3:*/		return 0x82253210;
		  /* 82253210h */ case    4:  		/* lis R3, 2047 */
		/* 82253210h case    4:*/		cpu::op::lis<0>(regs,&regs.R3,0x7FF);
		/* 82253210h case    4:*/		return 0x82253214;
		  /* 82253214h */ case    5:  		/* ori R3, R3, 65534 */
		/* 82253214h case    5:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xFFFE);
		/* 82253214h case    5:*/		return 0x82253218;
		  /* 82253218h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82253218h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82253218h case    6:*/		return 0x8225321C;
	}
	return 0x8225321C;
} // Block from 82253200h-8225321Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225321Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225321C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225321C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225321C);
		  /* 8225321Ch */ case    0:  		/* lis R11, -32256 */
		/* 8225321Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8225321Ch case    0:*/		return 0x82253220;
		  /* 82253220h */ case    1:  		/* lfs FR0, <#[R11 + 2984]> */
		/* 82253220h case    1:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000BA8) );
		/* 82253220h case    1:*/		return 0x82253224;
		  /* 82253224h */ case    2:  		/* fcmpu CR6, FR1, FR0 */
		/* 82253224h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82253224h case    2:*/		return 0x82253228;
		  /* 82253228h */ case    3:  		/* bc 12, CR6_GT, 12 */
		/* 82253228h case    3:*/		if ( regs.CR[6].gt ) { return 0x82253234;  }
		/* 82253228h case    3:*/		return 0x8225322C;
		  /* 8225322Ch */ case    4:  		/* lis R3, 2048 */
		/* 8225322Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R3,0x800);
		/* 8225322Ch case    4:*/		return 0x82253230;
		  /* 82253230h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82253230h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82253230h case    5:*/		return 0x82253234;
	}
	return 0x82253234;
} // Block from 8225321Ch-82253234h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82253234h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253234);
		  /* 82253234h */ case    0:  		/* stfs FR1, <#[R1 - 16]> */
		/* 82253234h case    0:*/		cpu::mem::store32f( regs, regs.FR1, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82253234h case    0:*/		return 0x82253238;
		  /* 82253238h */ case    1:  		/* lwz R11, <#[R1 - 16]> */
		/* 82253238h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82253238h case    1:*/		return 0x8225323C;
		  /* 8225323Ch */ case    2:  		/* srawi R11, R11, 23 */
		/* 8225323Ch case    2:*/		cpu::op::srawi<0,23>(regs,&regs.R11,regs.R11);
		/* 8225323Ch case    2:*/		return 0x82253240;
		  /* 82253240h */ case    3:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 82253240h case    3:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82253240h case    3:*/		return 0x82253244;
		  /* 82253244h */ case    4:  		/* subfic R11, R11, 129 */
		/* 82253244h case    4:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x81);
		/* 82253244h case    4:*/		return 0x82253248;
		  /* 82253248h */ case    5:  		/* cmpwi CR6, R11, 15 */
		/* 82253248h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000F);
		/* 82253248h case    5:*/		return 0x8225324C;
		  /* 8225324Ch */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 8225324Ch case    6:*/		if ( !regs.CR[6].gt ) { return 0x82253254;  }
		/* 8225324Ch case    6:*/		return 0x82253250;
		  /* 82253250h */ case    7:  		/* li R11, 15 */
		/* 82253250h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0xF);
		/* 82253250h case    7:*/		return 0x82253254;
	}
	return 0x82253254;
} // Block from 82253234h-82253254h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82253254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253254);
		  /* 82253254h */ case    0:  		/* addi R10, R11, 25 */
		/* 82253254h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x19);
		/* 82253254h case    0:*/		return 0x82253258;
		  /* 82253258h */ case    1:  		/* li R9, 1 */
		/* 82253258h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82253258h case    1:*/		return 0x8225325C;
		  /* 8225325Ch */ case    2:  		/* extsw R8, R10 */
		/* 8225325Ch case    2:*/		cpu::op::extsw<0>(regs,&regs.R8,regs.R10);
		/* 8225325Ch case    2:*/		return 0x82253260;
		  /* 82253260h */ case    3:  		/* rlwinm R10, R11, 28, 0, 3 */
		/* 82253260h case    3:*/		cpu::op::rlwinm<0,28,0,3>(regs,&regs.R10,regs.R11);
		/* 82253260h case    3:*/		return 0x82253264;
		  /* 82253264h */ case    4:  		/* sld R11, R9, R8 */
		/* 82253264h case    4:*/		cpu::op::sld<0>(regs,&regs.R11,regs.R9,regs.R8);
		/* 82253264h case    4:*/		return 0x82253268;
		  /* 82253268h */ case    5:  		/* std R11, <#[R1 - 16]> */
		/* 82253268h case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82253268h case    5:*/		return 0x8225326C;
		  /* 8225326Ch */ case    6:  		/* lfd FR0, <#[R1 - 16]> */
		/* 8225326Ch case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225326Ch case    6:*/		return 0x82253270;
		  /* 82253270h */ case    7:  		/* fcfid FR0, FR0 */
		/* 82253270h case    7:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82253270h case    7:*/		return 0x82253274;
		  /* 82253274h */ case    8:  		/* frsp FR0, FR0 */
		/* 82253274h case    8:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 82253274h case    8:*/		return 0x82253278;
		  /* 82253278h */ case    9:  		/* fmuls FR0, FR0, FR1 */
		/* 82253278h case    9:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR0,regs.FR1);
		/* 82253278h case    9:*/		return 0x8225327C;
		  /* 8225327Ch */ case   10:  		/* fctiwz FR0, FR0 */
		/* 8225327Ch case   10:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 8225327Ch case   10:*/		return 0x82253280;
		  /* 82253280h */ case   11:  		/* stfd FR0, <#[R1 - 16]> */
		/* 82253280h case   11:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82253280h case   11:*/		return 0x82253284;
		  /* 82253284h */ case   12:  		/* lwz R11, <#[R1 - 12]> */
		/* 82253284h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 82253284h case   12:*/		return 0x82253288;
		  /* 82253288h */ case   13:  		/* addi R11, R11, 1 */
		/* 82253288h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82253288h case   13:*/		return 0x8225328C;
		  /* 8225328Ch */ case   14:  		/* srawi R11, R11, 1 */
		/* 8225328Ch case   14:*/		cpu::op::srawi<0,1>(regs,&regs.R11,regs.R11);
		/* 8225328Ch case   14:*/		return 0x82253290;
		  /* 82253290h */ case   15:  		/* rlwinm R11, R11, 0, 4, 31 */
		/* 82253290h case   15:*/		cpu::op::rlwinm<0,0,4,31>(regs,&regs.R11,regs.R11);
		/* 82253290h case   15:*/		return 0x82253294;
		  /* 82253294h */ case   16:  		/* add R3, R11, R10 */
		/* 82253294h case   16:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82253294h case   16:*/		return 0x82253298;
		  /* 82253298h */ case   17:  		/* bclr 20, CR0_LT */
		/* 82253298h case   17:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82253298h case   17:*/		return 0x8225329C;
	}
	return 0x8225329C;
} // Block from 82253254h-8225329Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 8225329Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225329C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225329C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225329C);
		  /* 8225329Ch */ case    0:  		/* nop */
		/* 8225329Ch case    0:*/		cpu::op::nop();
		/* 8225329Ch case    0:*/		return 0x822532A0;
	}
	return 0x822532A0;
} // Block from 8225329Ch-822532A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822532A0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822532A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822532A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822532A0);
		  /* 822532A0h */ case    0:  		/* mfspr R12, LR */
		/* 822532A0h case    0:*/		regs.R12 = regs.LR;
		/* 822532A0h case    0:*/		return 0x822532A4;
		  /* 822532A4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822532A4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822532A4h case    1:*/		return 0x822532A8;
		  /* 822532A8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 822532A8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822532A8h case    2:*/		return 0x822532AC;
		  /* 822532ACh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 822532ACh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822532ACh case    3:*/		return 0x822532B0;
		  /* 822532B0h */ case    4:  		/* stfd FR31, <#[R1 - 32]> */
		/* 822532B0h case    4:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 822532B0h case    4:*/		return 0x822532B4;
		  /* 822532B4h */ case    5:  		/* stwu R1, <#[R1 - 128]> */
		/* 822532B4h case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822532B4h case    5:*/		return 0x822532B8;
		  /* 822532B8h */ case    6:  		/* fmr FR31, FR1 */
		/* 822532B8h case    6:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 822532B8h case    6:*/		return 0x822532BC;
		  /* 822532BCh */ case    7:  		/* mr R30, R4 */
		/* 822532BCh case    7:*/		regs.R30 = regs.R4;
		/* 822532BCh case    7:*/		return 0x822532C0;
		  /* 822532C0h */ case    8:  		/* mr R31, R5 */
		/* 822532C0h case    8:*/		regs.R31 = regs.R5;
		/* 822532C0h case    8:*/		return 0x822532C4;
		  /* 822532C4h */ case    9:  		/* cmpwi CR6, R5, 1 */
		/* 822532C4h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000001);
		/* 822532C4h case    9:*/		return 0x822532C8;
		  /* 822532C8h */ case   10:  		/* bc 12, CR6_GT, 72 */
		/* 822532C8h case   10:*/		if ( regs.CR[6].gt ) { return 0x82253310;  }
		/* 822532C8h case   10:*/		return 0x822532CC;
		  /* 822532CCh */ case   11:  		/* cmpwi CR6, R5, 0 */
		/* 822532CCh case   11:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 822532CCh case   11:*/		return 0x822532D0;
		  /* 822532D0h */ case   12:  		/* bc 4, CR6_EQ, 12 */
		/* 822532D0h case   12:*/		if ( !regs.CR[6].eq ) { return 0x822532DC;  }
		/* 822532D0h case   12:*/		return 0x822532D4;
		  /* 822532D4h */ case   13:  		/* li R3, 0 */
		/* 822532D4h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822532D4h case   13:*/		return 0x822532D8;
		  /* 822532D8h */ case   14:  		/* b 1164 */
		/* 822532D8h case   14:*/		return 0x82253764;
		/* 822532D8h case   14:*/		return 0x822532DC;
	}
	return 0x822532DC;
} // Block from 822532A0h-822532DCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 822532DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822532DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822532DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822532DC);
		  /* 822532DCh */ case    0:  		/* extsw R11, R30 */
		/* 822532DCh case    0:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R30);
		/* 822532DCh case    0:*/		return 0x822532E0;
		  /* 822532E0h */ case    1:  		/* lis R10, -32252 */
		/* 822532E0h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 822532E0h case    1:*/		return 0x822532E4;
		  /* 822532E4h */ case    2:  		/* std R11, <#[R1 + 80]> */
		/* 822532E4h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 822532E4h case    2:*/		return 0x822532E8;
		  /* 822532E8h */ case    3:  		/* lfd FR0, <#[R1 + 80]> */
		/* 822532E8h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 822532E8h case    3:*/		return 0x822532EC;
		  /* 822532ECh */ case    4:  		/* fcfid FR12, FR0 */
		/* 822532ECh case    4:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR0);
		/* 822532ECh case    4:*/		return 0x822532F0;
		  /* 822532F0h */ case    5:  		/* lis R11, -32256 */
		/* 822532F0h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 822532F0h case    5:*/		return 0x822532F4;
		  /* 822532F4h */ case    6:  		/* lfd FR0, <#[R10 + 18320]> */
		/* 822532F4h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00004790) );
		/* 822532F4h case    6:*/		return 0x822532F8;
		  /* 822532F8h */ case    7:  		/* li R3, 1 */
		/* 822532F8h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 822532F8h case    7:*/		return 0x822532FC;
		  /* 822532FCh */ case    8:  		/* lfd FR13, <#[R11 + 1848]> */
		/* 822532FCh case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000738) );
		/* 822532FCh case    8:*/		return 0x82253300;
		  /* 82253300h */ case    9:  		/* fnmsub FR0, FR12, FR0, FR13 */
		/* 82253300h case    9:*/		cpu::op::fnmsub<0>(regs,&regs.FR0,regs.FR12,regs.FR0,regs.FR13);
		/* 82253300h case    9:*/		return 0x82253304;
		  /* 82253304h */ case   10:  		/* fcmpu CR6, FR31, FR0 */
		/* 82253304h case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 82253304h case   10:*/		return 0x82253308;
		  /* 82253308h */ case   11:  		/* bc 4, CR6_LT, 1116 */
		/* 82253308h case   11:*/		if ( !regs.CR[6].lt ) { return 0x82253764;  }
		/* 82253308h case   11:*/		return 0x8225330C;
		  /* 8225330Ch */ case   12:  		/* b -56 */
		/* 8225330Ch case   12:*/		return 0x822532D4;
		/* 8225330Ch case   12:*/		return 0x82253310;
	}
	return 0x82253310;
} // Block from 822532DCh-82253310h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82253310h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253310( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253310) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253310);
		  /* 82253310h */ case    0:  		/* cmplwi CR6, R6, 1 */
		/* 82253310h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000001);
		/* 82253310h case    0:*/		return 0x82253314;
		  /* 82253314h */ case    1:  		/* bc 12, CR6_LT, 404 */
		/* 82253314h case    1:*/		if ( regs.CR[6].lt ) { return 0x822534A8;  }
		/* 82253314h case    1:*/		return 0x82253318;
		  /* 82253318h */ case    2:  		/* bc 12, CR6_EQ, 860 */
		/* 82253318h case    2:*/		if ( regs.CR[6].eq ) { return 0x82253674;  }
		/* 82253318h case    2:*/		return 0x8225331C;
		  /* 8225331Ch */ case    3:  		/* cmplwi CR6, R6, 3 */
		/* 8225331Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000003);
		/* 8225331Ch case    3:*/		return 0x82253320;
		  /* 82253320h */ case    4:  		/* bc 12, CR6_LT, 748 */
		/* 82253320h case    4:*/		if ( regs.CR[6].lt ) { return 0x8225360C;  }
		/* 82253320h case    4:*/		return 0x82253324;
		  /* 82253324h */ case    5:  		/* bc 12, CR6_EQ, 560 */
		/* 82253324h case    5:*/		if ( regs.CR[6].eq ) { return 0x82253554;  }
		/* 82253324h case    5:*/		return 0x82253328;
		  /* 82253328h */ case    6:  		/* cmplwi CR6, R6, 5 */
		/* 82253328h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000005);
		/* 82253328h case    6:*/		return 0x8225332C;
		  /* 8225332Ch */ case    7:  		/* bc 12, CR6_LT, 348 */
		/* 8225332Ch case    7:*/		if ( regs.CR[6].lt ) { return 0x82253488;  }
		/* 8225332Ch case    7:*/		return 0x82253330;
		  /* 82253330h */ case    8:  		/* bc 12, CR6_EQ, 268 */
		/* 82253330h case    8:*/		if ( regs.CR[6].eq ) { return 0x8225343C;  }
		/* 82253330h case    8:*/		return 0x82253334;
		  /* 82253334h */ case    9:  		/* cmplwi CR6, R6, 7 */
		/* 82253334h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000007);
		/* 82253334h case    9:*/		return 0x82253338;
		  /* 82253338h */ case   10:  		/* bc 4, CR6_EQ, -100 */
		/* 82253338h case   10:*/		if ( !regs.CR[6].eq ) { return 0x822532D4;  }
		/* 82253338h case   10:*/		return 0x8225333C;
		  /* 8225333Ch */ case   11:  		/* stfs FR31, <#[R1 + 80]> */
		/* 8225333Ch case   11:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R1 + 0x00000050) );
		/* 8225333Ch case   11:*/		return 0x82253340;
		  /* 82253340h */ case   12:  		/* cmpwi CR6, R31, 32 */
		/* 82253340h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000020);
		/* 82253340h case   12:*/		return 0x82253344;
		  /* 82253344h */ case   13:  		/* bc 4, CR6_EQ, 12 */
		/* 82253344h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82253350;  }
		/* 82253344h case   13:*/		return 0x82253348;
		  /* 82253348h */ case   14:  		/* lwz R3, <#[R1 + 80]> */
		/* 82253348h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 82253348h case   14:*/		return 0x8225334C;
		  /* 8225334Ch */ case   15:  		/* b 1048 */
		/* 8225334Ch case   15:*/		return 0x82253764;
		/* 8225334Ch case   15:*/		return 0x82253350;
	}
	return 0x82253350;
} // Block from 82253310h-82253350h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82253350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253350);
		  /* 82253350h */ case    0:  		/* cmpwi CR6, R31, 16 */
		/* 82253350h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000010);
		/* 82253350h case    0:*/		return 0x82253354;
		  /* 82253354h */ case    1:  		/* bc 4, CR6_EQ, 104 */
		/* 82253354h case    1:*/		if ( !regs.CR[6].eq ) { return 0x822533BC;  }
		/* 82253354h case    1:*/		return 0x82253358;
		  /* 82253358h */ case    2:  		/* lis R10, -32252 */
		/* 82253358h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82253358h case    2:*/		return 0x8225335C;
		  /* 8225335Ch */ case    3:  		/* rlwinm R11, R30, 5, 0, 26 */
		/* 8225335Ch case    3:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R30);
		/* 8225335Ch case    3:*/		return 0x82253360;
		  /* 82253360h */ case    4:  		/* lfd FR0, <#[R10 + 18296]> */
		/* 82253360h case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00004778) );
		/* 82253360h case    4:*/		return 0x82253364;
		  /* 82253364h */ case    5:  		/* fmul FR0, FR31, FR0 */
		/* 82253364h case    5:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR31,regs.FR0);
		/* 82253364h case    5:*/		return 0x82253368;
		  /* 82253368h */ case    6:  		/* frsp FR0, FR0 */
		/* 82253368h case    6:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 82253368h case    6:*/		return 0x8225336C;
		  /* 8225336Ch */ case    7:  		/* stfs FR0, <#[R1 + 80]> */
		/* 8225336Ch case    7:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 8225336Ch case    7:*/		return 0x82253370;
		  /* 82253370h */ case    8:  		/* lwz R10, <#[R1 + 80]> */
		/* 82253370h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82253370h case    8:*/		return 0x82253374;
		  /* 82253374h */ case    9:  		/* add R11, R11, R10 */
		/* 82253374h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82253374h case    9:*/		return 0x82253378;
		  /* 82253378h */ case   10:  		/* rlwinm. R10, R11, 0, 1, 3 */
		/* 82253378h case   10:*/		cpu::op::rlwinm<1,0,1,3>(regs,&regs.R10,regs.R11);
		/* 82253378h case   10:*/		return 0x8225337C;
		  /* 8225337Ch */ case   11:  		/* bc 12, CR0_EQ, 40 */
		/* 8225337Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x822533A4;  }
		/* 8225337Ch case   11:*/		return 0x82253380;
		  /* 82253380h */ case   12:  		/* lis R11, -32256 */
		/* 82253380h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82253380h case   12:*/		return 0x82253384;
		  /* 82253384h */ case   13:  		/* lfs FR0, <#[R11 + 1816]> */
		/* 82253384h case   13:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000718) );
		/* 82253384h case   13:*/		return 0x82253388;
		  /* 82253388h */ case   14:  		/* fcmpu CR6, FR31, FR0 */
		/* 82253388h case   14:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 82253388h case   14:*/		return 0x8225338C;
		  /* 8225338Ch */ case   15:  		/* bc 4, CR6_LT, 16 */
		/* 8225338Ch case   15:*/		if ( !regs.CR[6].lt ) { return 0x8225339C;  }
		/* 8225338Ch case   15:*/		return 0x82253390;
		  /* 82253390h */ case   16:  		/* lis R3, 0 */
		/* 82253390h case   16:*/		cpu::op::lis<0>(regs,&regs.R3,0x0);
		/* 82253390h case   16:*/		return 0x82253394;
		  /* 82253394h */ case   17:  		/* ori R3, R3, 65535 */
		/* 82253394h case   17:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xFFFF);
		/* 82253394h case   17:*/		return 0x82253398;
		  /* 82253398h */ case   18:  		/* b 972 */
		/* 82253398h case   18:*/		return 0x82253764;
		/* 82253398h case   18:*/		return 0x8225339C;
	}
	return 0x8225339C;
} // Block from 82253350h-8225339Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8225339Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225339C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225339C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225339C);
		  /* 8225339Ch */ case    0:  		/* li R3, 32767 */
		/* 8225339Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x7FFF);
		/* 8225339Ch case    0:*/		return 0x822533A0;
		  /* 822533A0h */ case    1:  		/* b 964 */
		/* 822533A0h case    1:*/		return 0x82253764;
		/* 822533A0h case    1:*/		return 0x822533A4;
	}
	return 0x822533A4;
} // Block from 8225339Ch-822533A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822533A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822533A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822533A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822533A4);
		  /* 822533A4h */ case    0:  		/* srawi. R11, R11, 13 */
		/* 822533A4h case    0:*/		cpu::op::srawi<1,13>(regs,&regs.R11,regs.R11);
		/* 822533A4h case    0:*/		return 0x822533A8;
		  /* 822533A8h */ case    1:  		/* bc 4, CR0_LT, 12 */
		/* 822533A8h case    1:*/		if ( !regs.CR[0].lt ) { return 0x822533B4;  }
		/* 822533A8h case    1:*/		return 0x822533AC;
		  /* 822533ACh */ case    2:  		/* rlwinm R11, R11, 0, 17, 31 */
		/* 822533ACh case    2:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R11,regs.R11);
		/* 822533ACh case    2:*/		return 0x822533B0;
		  /* 822533B0h */ case    3:  		/* ori R11, R11, 32768 */
		/* 822533B0h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 822533B0h case    3:*/		return 0x822533B4;
	}
	return 0x822533B4;
} // Block from 822533A4h-822533B4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822533B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822533B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822533B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822533B4);
		  /* 822533B4h */ case    0:  		/* mr R3, R11 */
		/* 822533B4h case    0:*/		regs.R3 = regs.R11;
		/* 822533B4h case    0:*/		return 0x822533B8;
		  /* 822533B8h */ case    1:  		/* b 940 */
		/* 822533B8h case    1:*/		return 0x82253764;
		/* 822533B8h case    1:*/		return 0x822533BC;
	}
	return 0x822533BC;
} // Block from 822533B4h-822533BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822533BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822533BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822533BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822533BC);
		  /* 822533BCh */ case    0:  		/* cmpwi CR6, R31, 10 */
		/* 822533BCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x0000000A);
		/* 822533BCh case    0:*/		return 0x822533C0;
		  /* 822533C0h */ case    1:  		/* bc 12, CR6_LT, -236 */
		/* 822533C0h case    1:*/		if ( regs.CR[6].lt ) { return 0x822532D4;  }
		/* 822533C0h case    1:*/		return 0x822533C4;
		  /* 822533C4h */ case    2:  		/* li R4, -124 */
		/* 822533C4h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0xFFFFFF84);
		/* 822533C4h case    2:*/		return 0x822533C8;
		  /* 822533C8h */ case    3:  		/* fmr FR1, FR31 */
		/* 822533C8h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 822533C8h case    3:*/		return 0x822533CC;
		  /* 822533CCh */ case    4:  		/* bl -1837140 */
		/* 822533CCh case    4:*/		regs.LR = 0x822533D0; return 0x82092B78;
		/* 822533CCh case    4:*/		return 0x822533D0;
		  /* 822533D0h */ case    5:  		/* frsp FR0, FR1 */
		/* 822533D0h case    5:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR1);
		/* 822533D0h case    5:*/		return 0x822533D4;
		  /* 822533D4h */ case    6:  		/* stfs FR0, <#[R1 + 80]> */
		/* 822533D4h case    6:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 822533D4h case    6:*/		return 0x822533D8;
		  /* 822533D8h */ case    7:  		/* subfic R11, R31, 18 */
		/* 822533D8h case    7:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R31,0x12);
		/* 822533D8h case    7:*/		return 0x822533DC;
		  /* 822533DCh */ case    8:  		/* slw R11, R30, R11 */
		/* 822533DCh case    8:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 822533DCh case    8:*/		return 0x822533E0;
		  /* 822533E0h */ case    9:  		/* lwz R10, <#[R1 + 80]> */
		/* 822533E0h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 822533E0h case    9:*/		return 0x822533E4;
		  /* 822533E4h */ case   10:  		/* add R11, R11, R10 */
		/* 822533E4h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 822533E4h case   10:*/		return 0x822533E8;
		  /* 822533E8h */ case   11:  		/* rlwinm. R10, R11, 0, 1, 5 */
		/* 822533E8h case   11:*/		cpu::op::rlwinm<1,0,1,5>(regs,&regs.R10,regs.R11);
		/* 822533E8h case   11:*/		return 0x822533EC;
		  /* 822533ECh */ case   12:  		/* bc 12, CR0_EQ, 52 */
		/* 822533ECh case   12:*/		if ( regs.CR[0].eq ) { return 0x82253420;  }
		/* 822533ECh case   12:*/		return 0x822533F0;
		  /* 822533F0h */ case   13:  		/* lis R11, -32256 */
		/* 822533F0h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 822533F0h case   13:*/		return 0x822533F4;
		  /* 822533F4h */ case   14:  		/* lfs FR0, <#[R11 + 1816]> */
		/* 822533F4h case   14:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000718) );
		/* 822533F4h case   14:*/		return 0x822533F8;
		  /* 822533F8h */ case   15:  		/* fcmpu CR6, FR31, FR0 */
		/* 822533F8h case   15:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 822533F8h case   15:*/		return 0x822533FC;
		  /* 822533FCh */ case   16:  		/* bc 4, CR6_LT, 16 */
		/* 822533FCh case   16:*/		if ( !regs.CR[6].lt ) { return 0x8225340C;  }
		/* 822533FCh case   16:*/		return 0x82253400;
		  /* 82253400h */ case   17:  		/* li R11, 1 */
		/* 82253400h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82253400h case   17:*/		return 0x82253404;
		  /* 82253404h */ case   18:  		/* slw R11, R11, R31 */
		/* 82253404h case   18:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82253404h case   18:*/		return 0x82253408;
		  /* 82253408h */ case   19:  		/* b 16 */
		/* 82253408h case   19:*/		return 0x82253418;
		/* 82253408h case   19:*/		return 0x8225340C;
	}
	return 0x8225340C;
} // Block from 822533BCh-8225340Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 8225340Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225340C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225340C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225340C);
		  /* 8225340Ch */ case    0:  		/* addi R11, R31, -1 */
		/* 8225340Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFF);
		/* 8225340Ch case    0:*/		return 0x82253410;
		  /* 82253410h */ case    1:  		/* li R10, 1 */
		/* 82253410h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82253410h case    1:*/		return 0x82253414;
		  /* 82253414h */ case    2:  		/* slw R11, R10, R11 */
		/* 82253414h case    2:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82253414h case    2:*/		return 0x82253418;
	}
	return 0x82253418;
} // Block from 8225340Ch-82253418h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82253418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253418);
		  /* 82253418h */ case    0:  		/* addi R3, R11, -1 */
		/* 82253418h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFFF);
		/* 82253418h case    0:*/		return 0x8225341C;
		  /* 8225341Ch */ case    1:  		/* b 840 */
		/* 8225341Ch case    1:*/		return 0x82253764;
		/* 8225341Ch case    1:*/		return 0x82253420;
	}
	return 0x82253420;
} // Block from 82253418h-82253420h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82253420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253420);
		  /* 82253420h */ case    0:  		/* li R10, 1 */
		/* 82253420h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82253420h case    0:*/		return 0x82253424;
		  /* 82253424h */ case    1:  		/* subfic R9, R31, 26 */
		/* 82253424h case    1:*/		cpu::op::subfic<0>(regs,&regs.R9,regs.R31,0x1A);
		/* 82253424h case    1:*/		return 0x82253428;
		  /* 82253428h */ case    2:  		/* slw R10, R10, R31 */
		/* 82253428h case    2:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R31);
		/* 82253428h case    2:*/		return 0x8225342C;
		  /* 8225342Ch */ case    3:  		/* sraw R11, R11, R9 */
		/* 8225342Ch case    3:*/		cpu::op::sraw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8225342Ch case    3:*/		return 0x82253430;
		  /* 82253430h */ case    4:  		/* addi R10, R10, -1 */
		/* 82253430h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82253430h case    4:*/		return 0x82253434;
		  /* 82253434h */ case    5:  		/* and R3, R11, R10 */
		/* 82253434h case    5:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82253434h case    5:*/		return 0x82253438;
		  /* 82253438h */ case    6:  		/* b 812 */
		/* 82253438h case    6:*/		return 0x82253764;
		/* 82253438h case    6:*/		return 0x8225343C;
	}
	return 0x8225343C;
} // Block from 82253420h-8225343Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225343Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225343C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225343C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225343C);
		  /* 8225343Ch */ case    0:  		/* lis R11, -32256 */
		/* 8225343Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8225343Ch case    0:*/		return 0x82253440;
		  /* 82253440h */ case    1:  		/* lis R10, -32256 */
		/* 82253440h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82253440h case    1:*/		return 0x82253444;
		  /* 82253444h */ case    2:  		/* lfs FR0, <#[R11 + 8440]> */
		/* 82253444h case    2:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x000020F8) );
		/* 82253444h case    2:*/		return 0x82253448;
		  /* 82253448h */ case    3:  		/* lis R11, -32256 */
		/* 82253448h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82253448h case    3:*/		return 0x8225344C;
		  /* 8225344Ch */ case    4:  		/* fmuls FR0, FR31, FR0 */
		/* 8225344Ch case    4:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR31,regs.FR0);
		/* 8225344Ch case    4:*/		return 0x82253450;
		  /* 82253450h */ case    5:  		/* lfs FR13, <#[R10 + 1816]> */
		/* 82253450h case    5:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000718) );
		/* 82253450h case    5:*/		return 0x82253454;
		  /* 82253454h */ case    6:  		/* fcmpu CR6, FR0, FR13 */
		/* 82253454h case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82253454h case    6:*/		return 0x82253458;
		  /* 82253458h */ case    7:  		/* lfd FR13, <#[R11 + 4736]> */
		/* 82253458h case    7:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00001280) );
		/* 82253458h case    7:*/		return 0x8225345C;
		  /* 8225345Ch */ case    8:  		/* bc 4, CR6_GT, 24 */
		/* 8225345Ch case    8:*/		if ( !regs.CR[6].gt ) { return 0x82253474;  }
		/* 8225345Ch case    8:*/		return 0x82253460;
		  /* 82253460h */ case    9:  		/* fadd FR0, FR0, FR13 */
		/* 82253460h case    9:*/		cpu::op::fadd<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 82253460h case    9:*/		return 0x82253464;
		  /* 82253464h */ case   10:  		/* fctiwz FR0, FR0 */
		/* 82253464h case   10:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 82253464h case   10:*/		return 0x82253468;
		  /* 82253468h */ case   11:  		/* stfd FR0, <#[R1 + 80]> */
		/* 82253468h case   11:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82253468h case   11:*/		return 0x8225346C;
		  /* 8225346Ch */ case   12:  		/* lwz R3, <#[R1 + 84]> */
		/* 8225346Ch case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 8225346Ch case   12:*/		return 0x82253470;
		  /* 82253470h */ case   13:  		/* b 756 */
		/* 82253470h case   13:*/		return 0x82253764;
		/* 82253470h case   13:*/		return 0x82253474;
	}
	return 0x82253474;
} // Block from 8225343Ch-82253474h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82253474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253474);
		  /* 82253474h */ case    0:  		/* fsub FR0, FR0, FR13 */
		/* 82253474h case    0:*/		cpu::op::fsub<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 82253474h case    0:*/		return 0x82253478;
		  /* 82253478h */ case    1:  		/* fctiwz FR0, FR0 */
		/* 82253478h case    1:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 82253478h case    1:*/		return 0x8225347C;
		  /* 8225347Ch */ case    2:  		/* stfd FR0, <#[R1 + 80]> */
		/* 8225347Ch case    2:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 8225347Ch case    2:*/		return 0x82253480;
		  /* 82253480h */ case    3:  		/* lwz R3, <#[R1 + 84]> */
		/* 82253480h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 82253480h case    3:*/		return 0x82253484;
		  /* 82253484h */ case    4:  		/* b 736 */
		/* 82253484h case    4:*/		return 0x82253764;
		/* 82253484h case    4:*/		return 0x82253488;
	}
	return 0x82253488;
} // Block from 82253474h-82253488h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82253488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253488);
		  /* 82253488h */ case    0:  		/* lis R11, -32252 */
		/* 82253488h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82253488h case    0:*/		return 0x8225348C;
		  /* 8225348Ch */ case    1:  		/* fmr FR1, FR31 */
		/* 8225348Ch case    1:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8225348Ch case    1:*/		return 0x82253490;
		  /* 82253490h */ case    2:  		/* lfd FR0, <#[R11 + 18312]> */
		/* 82253490h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00004788) );
		/* 82253490h case    2:*/		return 0x82253494;
		  /* 82253494h */ case    3:  		/* fcmpu CR6, FR31, FR0 */
		/* 82253494h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 82253494h case    3:*/		return 0x82253498;
		  /* 82253498h */ case    4:  		/* bc 12, CR6_GT, 144 */
		/* 82253498h case    4:*/		if ( regs.CR[6].gt ) { return 0x82253528;  }
		/* 82253498h case    4:*/		return 0x8225349C;
		  /* 8225349Ch */ case    5:  		/* lis R11, -32256 */
		/* 8225349Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8225349Ch case    5:*/		return 0x822534A0;
		  /* 822534A0h */ case    6:  		/* lfs FR0, <#[R11 + 4608]> */
		/* 822534A0h case    6:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001200) );
		/* 822534A0h case    6:*/		return 0x822534A4;
		  /* 822534A4h */ case    7:  		/* fmuls FR31, FR31, FR0 */
		/* 822534A4h case    7:*/		cpu::op::fmuls<0>(regs,&regs.FR31,regs.FR31,regs.FR0);
		/* 822534A4h case    7:*/		return 0x822534A8;
	}
	return 0x822534A8;
} // Block from 82253488h-822534A8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822534A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822534A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822534A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822534A8);
		  /* 822534A8h */ case    0:  		/* extsw R11, R30 */
		/* 822534A8h case    0:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R30);
		/* 822534A8h case    0:*/		return 0x822534AC;
		  /* 822534ACh */ case    1:  		/* li R10, 1 */
		/* 822534ACh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 822534ACh case    1:*/		return 0x822534B0;
		  /* 822534B0h */ case    2:  		/* std R11, <#[R1 + 88]> */
		/* 822534B0h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 822534B0h case    2:*/		return 0x822534B4;
		  /* 822534B4h */ case    3:  		/* lis R9, -32252 */
		/* 822534B4h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 822534B4h case    3:*/		return 0x822534B8;
		  /* 822534B8h */ case    4:  		/* slw R11, R10, R31 */
		/* 822534B8h case    4:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R10,regs.R31);
		/* 822534B8h case    4:*/		return 0x822534BC;
		  /* 822534BCh */ case    5:  		/* addi R8, R11, -1 */
		/* 822534BCh case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFFF);
		/* 822534BCh case    5:*/		return 0x822534C0;
		  /* 822534C0h */ case    6:  		/* lfd FR0, <#[R9 + 18320]> */
		/* 822534C0h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00004790) );
		/* 822534C0h case    6:*/		return 0x822534C4;
		  /* 822534C4h */ case    7:  		/* li R4, 1 */
		/* 822534C4h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822534C4h case    7:*/		return 0x822534C8;
		  /* 822534C8h */ case    8:  		/* extsw R11, R8 */
		/* 822534C8h case    8:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R8);
		/* 822534C8h case    8:*/		return 0x822534CC;
		  /* 822534CCh */ case    9:  		/* lfd FR13, <#[R1 + 88]> */
		/* 822534CCh case    9:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 822534CCh case    9:*/		return 0x822534D0;
		  /* 822534D0h */ case   10:  		/* fcfid FR13, FR13 */
		/* 822534D0h case   10:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 822534D0h case   10:*/		return 0x822534D4;
		  /* 822534D4h */ case   11:  		/* std R11, <#[R1 + 88]> */
		/* 822534D4h case   11:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 822534D4h case   11:*/		return 0x822534D8;
		  /* 822534D8h */ case   12:  		/* lfd FR12, <#[R1 + 88]> */
		/* 822534D8h case   12:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R1 + 0x00000058) );
		/* 822534D8h case   12:*/		return 0x822534DC;
		  /* 822534DCh */ case   13:  		/* fcfid FR12, FR12 */
		/* 822534DCh case   13:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR12);
		/* 822534DCh case   13:*/		return 0x822534E0;
		  /* 822534E0h */ case   14:  		/* fmul FR0, FR13, FR0 */
		/* 822534E0h case   14:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 822534E0h case   14:*/		return 0x822534E4;
		  /* 822534E4h */ case   15:  		/* frsp FR13, FR12 */
		/* 822534E4h case   15:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR12);
		/* 822534E4h case   15:*/		return 0x822534E8;
		  /* 822534E8h */ case   16:  		/* frsp FR0, FR0 */
		/* 822534E8h case   16:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 822534E8h case   16:*/		return 0x822534EC;
		  /* 822534ECh */ case   17:  		/* fmadds FR1, FR13, FR31, FR0 */
		/* 822534ECh case   17:*/		cpu::op::fmadds<0>(regs,&regs.FR1,regs.FR13,regs.FR31,regs.FR0);
		/* 822534ECh case   17:*/		return 0x822534F0;
		  /* 822534F0h */ case   18:  		/* bl -848 */
		/* 822534F0h case   18:*/		regs.LR = 0x822534F4; return 0x822531A0;
		/* 822534F0h case   18:*/		return 0x822534F4;
		  /* 822534F4h */ case   19:  		/* extsw R11, R3 */
		/* 822534F4h case   19:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R3);
		/* 822534F4h case   19:*/		return 0x822534F8;
		  /* 822534F8h */ case   20:  		/* lis R10, -32256 */
		/* 822534F8h case   20:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 822534F8h case   20:*/		return 0x822534FC;
		  /* 822534FCh */ case   21:  		/* std R11, <#[R1 + 88]> */
		/* 822534FCh case   21:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 822534FCh case   21:*/		return 0x82253500;
		  /* 82253500h */ case   22:  		/* lfd FR0, <#[R1 + 88]> */
		/* 82253500h case   22:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82253500h case   22:*/		return 0x82253504;
		  /* 82253504h */ case   23:  		/* fcfid FR0, FR0 */
		/* 82253504h case   23:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82253504h case   23:*/		return 0x82253508;
		  /* 82253508h */ case   24:  		/* frsp FR0, FR0 */
		/* 82253508h case   24:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 82253508h case   24:*/		return 0x8225350C;
		  /* 8225350Ch */ case   25:  		/* lfs FR12, <#[R10 + 1816]> */
		/* 8225350Ch case   25:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R10 + 0x00000718) );
		/* 8225350Ch case   25:*/		return 0x82253510;
		  /* 82253510h */ case   26:  		/* fcmpu CR6, FR0, FR12 */
		/* 82253510h case   26:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR12);
		/* 82253510h case   26:*/		return 0x82253514;
		  /* 82253514h */ case   27:  		/* bc 4, CR6_GT, -576 */
		/* 82253514h case   27:*/		if ( !regs.CR[6].gt ) { return 0x822532D4;  }
		/* 82253514h case   27:*/		return 0x82253518;
		  /* 82253518h */ case   28:  		/* fcmpu CR6, FR0, FR13 */
		/* 82253518h case   28:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82253518h case   28:*/		return 0x8225351C;
		  /* 8225351Ch */ case   29:  		/* bc 12, CR6_LT, 572 */
		/* 8225351Ch case   29:*/		if ( regs.CR[6].lt ) { return 0x82253758;  }
		/* 8225351Ch case   29:*/		return 0x82253520;
		  /* 82253520h */ case   30:  		/* mr R3, R8 */
		/* 82253520h case   30:*/		regs.R3 = regs.R8;
		/* 82253520h case   30:*/		return 0x82253524;
		  /* 82253524h */ case   31:  		/* b 576 */
		/* 82253524h case   31:*/		return 0x82253764;
		/* 82253524h case   31:*/		return 0x82253528;
	}
	return 0x82253528;
} // Block from 822534A8h-82253528h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82253528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253528);
		  /* 82253528h */ case    0:  		/* lis R11, -32256 */
		/* 82253528h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82253528h case    0:*/		return 0x8225352C;
		  /* 8225352Ch */ case    1:  		/* lfd FR2, <#[R11 + 4600]> */
		/* 8225352Ch case    1:*/		cpu::mem::load64f( regs, &regs.FR2, (uint32)(regs.R11 + 0x000011F8) );
		/* 8225352Ch case    1:*/		return 0x82253530;
		  /* 82253530h */ case    2:  		/* bl -1838968 */
		/* 82253530h case    2:*/		regs.LR = 0x82253534; return 0x820925B8;
		/* 82253530h case    2:*/		return 0x82253534;
		  /* 82253534h */ case    3:  		/* frsp FR12, FR1 */
		/* 82253534h case    3:*/		cpu::op::frsp<0>(regs,&regs.FR12,regs.FR1);
		/* 82253534h case    3:*/		return 0x82253538;
		  /* 82253538h */ case    4:  		/* lis R11, -32252 */
		/* 82253538h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82253538h case    4:*/		return 0x8225353C;
		  /* 8225353Ch */ case    5:  		/* lis R10, -32252 */
		/* 8225353Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8225353Ch case    5:*/		return 0x82253540;
		  /* 82253540h */ case    6:  		/* lfd FR0, <#[R11 + 18304]> */
		/* 82253540h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00004780) );
		/* 82253540h case    6:*/		return 0x82253544;
		  /* 82253544h */ case    7:  		/* lfd FR13, <#[R10 + 18288]> */
		/* 82253544h case    7:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00004770) );
		/* 82253544h case    7:*/		return 0x82253548;
		  /* 82253548h */ case    8:  		/* fmsub FR0, FR12, FR0, FR13 */
		/* 82253548h case    8:*/		cpu::op::fmsub<0>(regs,&regs.FR0,regs.FR12,regs.FR0,regs.FR13);
		/* 82253548h case    8:*/		return 0x8225354C;
		  /* 8225354Ch */ case    9:  		/* frsp FR31, FR0 */
		/* 8225354Ch case    9:*/		cpu::op::frsp<0>(regs,&regs.FR31,regs.FR0);
		/* 8225354Ch case    9:*/		return 0x82253550;
		  /* 82253550h */ case   10:  		/* b -168 */
		/* 82253550h case   10:*/		return 0x822534A8;
		/* 82253550h case   10:*/		return 0x82253554;
	}
	return 0x82253554;
} // Block from 82253528h-82253554h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82253554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253554);
		  /* 82253554h */ case    0:  		/* lis R10, -32256 */
		/* 82253554h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82253554h case    0:*/		return 0x82253558;
		  /* 82253558h */ case    1:  		/* addi R11, R31, -1 */
		/* 82253558h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFF);
		/* 82253558h case    1:*/		return 0x8225355C;
		  /* 8225355Ch */ case    2:  		/* li R9, 1 */
		/* 8225355Ch case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8225355Ch case    2:*/		return 0x82253560;
		  /* 82253560h */ case    3:  		/* slw R11, R9, R11 */
		/* 82253560h case    3:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82253560h case    3:*/		return 0x82253564;
		  /* 82253564h */ case    4:  		/* lfs FR0, <#[R10 + 1816]> */
		/* 82253564h case    4:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000718) );
		/* 82253564h case    4:*/		return 0x82253568;
		  /* 82253568h */ case    5:  		/* srawi R10, R30, 8 */
		/* 82253568h case    5:*/		cpu::op::srawi<0,8>(regs,&regs.R10,regs.R30);
		/* 82253568h case    5:*/		return 0x8225356C;
		  /* 8225356Ch */ case    6:  		/* fcmpu CR6, FR31, FR0 */
		/* 8225356Ch case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 8225356Ch case    6:*/		return 0x82253570;
		  /* 82253570h */ case    7:  		/* bc 12, CR6_LT, 80 */
		/* 82253570h case    7:*/		if ( regs.CR[6].lt ) { return 0x822535C0;  }
		/* 82253570h case    7:*/		return 0x82253574;
		  /* 82253574h */ case    8:  		/* addi R3, R11, -1 */
		/* 82253574h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFFF);
		/* 82253574h case    8:*/		return 0x82253578;
		  /* 82253578h */ case    9:  		/* addze R11, R10 */
		/* 82253578h case    9:*/		cpu::op::addze<0>(regs,&regs.R11,regs.R10);
		/* 82253578h case    9:*/		return 0x8225357C;
		  /* 8225357Ch */ case   10:  		/* extsw R10, R3 */
		/* 8225357Ch case   10:*/		cpu::op::extsw<0>(regs,&regs.R10,regs.R3);
		/* 8225357Ch case   10:*/		return 0x82253580;
		  /* 82253580h */ case   11:  		/* extsw R11, R11 */
		/* 82253580h case   11:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 82253580h case   11:*/		return 0x82253584;
		  /* 82253584h */ case   12:  		/* std R10, <#[R1 + 80]> */
		/* 82253584h case   12:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82253584h case   12:*/		return 0x82253588;
		  /* 82253588h */ case   13:  		/* lfd FR0, <#[R1 + 80]> */
		/* 82253588h case   13:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82253588h case   13:*/		return 0x8225358C;
		  /* 8225358Ch */ case   14:  		/* std R11, <#[R1 + 80]> */
		/* 8225358Ch case   14:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8225358Ch case   14:*/		return 0x82253590;
		  /* 82253590h */ case   15:  		/* lfd FR13, <#[R1 + 80]> */
		/* 82253590h case   15:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 82253590h case   15:*/		return 0x82253594;
		  /* 82253594h */ case   16:  		/* fcfid FR0, FR0 */
		/* 82253594h case   16:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82253594h case   16:*/		return 0x82253598;
		  /* 82253598h */ case   17:  		/* fcfid FR13, FR13 */
		/* 82253598h case   17:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 82253598h case   17:*/		return 0x8225359C;
		  /* 8225359Ch */ case   18:  		/* frsp FR12, FR0 */
		/* 8225359Ch case   18:*/		cpu::op::frsp<0>(regs,&regs.FR12,regs.FR0);
		/* 8225359Ch case   18:*/		return 0x822535A0;
		  /* 822535A0h */ case   19:  		/* frsp FR0, FR13 */
		/* 822535A0h case   19:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR13);
		/* 822535A0h case   19:*/		return 0x822535A4;
		  /* 822535A4h */ case   20:  		/* fadds FR0, FR0, FR31 */
		/* 822535A4h case   20:*/		cpu::op::fadds<0>(regs,&regs.FR0,regs.FR0,regs.FR31);
		/* 822535A4h case   20:*/		return 0x822535A8;
		  /* 822535A8h */ case   21:  		/* fcmpu CR6, FR0, FR12 */
		/* 822535A8h case   21:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR12);
		/* 822535A8h case   21:*/		return 0x822535AC;
		  /* 822535ACh */ case   22:  		/* bc 4, CR6_LT, 440 */
		/* 822535ACh case   22:*/		if ( !regs.CR[6].lt ) { return 0x82253764;  }
		/* 822535ACh case   22:*/		return 0x822535B0;
		  /* 822535B0h */ case   23:  		/* fctiwz FR0, FR0 */
		/* 822535B0h case   23:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 822535B0h case   23:*/		return 0x822535B4;
		  /* 822535B4h */ case   24:  		/* stfd FR0, <#[R1 + 80]> */
		/* 822535B4h case   24:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 822535B4h case   24:*/		return 0x822535B8;
		  /* 822535B8h */ case   25:  		/* lwz R3, <#[R1 + 84]> */
		/* 822535B8h case   25:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 822535B8h case   25:*/		return 0x822535BC;
		  /* 822535BCh */ case   26:  		/* b 424 */
		/* 822535BCh case   26:*/		return 0x82253764;
		/* 822535BCh case   26:*/		return 0x822535C0;
	}
	return 0x822535C0;
} // Block from 82253554h-822535C0h (27 instructions)

//////////////////////////////////////////////////////
// Block at 822535C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822535C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822535C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822535C0);
		  /* 822535C0h */ case    0:  		/* neg R3, R11 */
		/* 822535C0h case    0:*/		cpu::op::neg<0>(regs,&regs.R3,regs.R11);
		/* 822535C0h case    0:*/		return 0x822535C4;
		  /* 822535C4h */ case    1:  		/* addze R11, R10 */
		/* 822535C4h case    1:*/		cpu::op::addze<0>(regs,&regs.R11,regs.R10);
		/* 822535C4h case    1:*/		return 0x822535C8;
		  /* 822535C8h */ case    2:  		/* extsw R10, R3 */
		/* 822535C8h case    2:*/		cpu::op::extsw<0>(regs,&regs.R10,regs.R3);
		/* 822535C8h case    2:*/		return 0x822535CC;
		  /* 822535CCh */ case    3:  		/* extsw R11, R11 */
		/* 822535CCh case    3:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 822535CCh case    3:*/		return 0x822535D0;
		  /* 822535D0h */ case    4:  		/* std R10, <#[R1 + 80]> */
		/* 822535D0h case    4:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 822535D0h case    4:*/		return 0x822535D4;
		  /* 822535D4h */ case    5:  		/* lfd FR0, <#[R1 + 80]> */
		/* 822535D4h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 822535D4h case    5:*/		return 0x822535D8;
		  /* 822535D8h */ case    6:  		/* std R11, <#[R1 + 88]> */
		/* 822535D8h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 822535D8h case    6:*/		return 0x822535DC;
		  /* 822535DCh */ case    7:  		/* lfd FR13, <#[R1 + 88]> */
		/* 822535DCh case    7:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 822535DCh case    7:*/		return 0x822535E0;
		  /* 822535E0h */ case    8:  		/* fcfid FR0, FR0 */
		/* 822535E0h case    8:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 822535E0h case    8:*/		return 0x822535E4;
		  /* 822535E4h */ case    9:  		/* fcfid FR13, FR13 */
		/* 822535E4h case    9:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 822535E4h case    9:*/		return 0x822535E8;
		  /* 822535E8h */ case   10:  		/* frsp FR12, FR0 */
		/* 822535E8h case   10:*/		cpu::op::frsp<0>(regs,&regs.FR12,regs.FR0);
		/* 822535E8h case   10:*/		return 0x822535EC;
		  /* 822535ECh */ case   11:  		/* frsp FR0, FR13 */
		/* 822535ECh case   11:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR13);
		/* 822535ECh case   11:*/		return 0x822535F0;
		  /* 822535F0h */ case   12:  		/* fsubs FR0, FR31, FR0 */
		/* 822535F0h case   12:*/		cpu::op::fsubs<0>(regs,&regs.FR0,regs.FR31,regs.FR0);
		/* 822535F0h case   12:*/		return 0x822535F4;
		  /* 822535F4h */ case   13:  		/* fcmpu CR6, FR0, FR12 */
		/* 822535F4h case   13:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR12);
		/* 822535F4h case   13:*/		return 0x822535F8;
		  /* 822535F8h */ case   14:  		/* bc 4, CR6_GT, 364 */
		/* 822535F8h case   14:*/		if ( !regs.CR[6].gt ) { return 0x82253764;  }
		/* 822535F8h case   14:*/		return 0x822535FC;
		  /* 822535FCh */ case   15:  		/* fctiwz FR0, FR0 */
		/* 822535FCh case   15:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 822535FCh case   15:*/		return 0x82253600;
		  /* 82253600h */ case   16:  		/* stfd FR0, <#[R1 + 88]> */
		/* 82253600h case   16:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82253600h case   16:*/		return 0x82253604;
		  /* 82253604h */ case   17:  		/* lwz R3, <#[R1 + 92]> */
		/* 82253604h case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 82253604h case   17:*/		return 0x82253608;
		  /* 82253608h */ case   18:  		/* b 348 */
		/* 82253608h case   18:*/		return 0x82253764;
		/* 82253608h case   18:*/		return 0x8225360C;
	}
	return 0x8225360C;
} // Block from 822535C0h-8225360Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8225360Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225360C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225360C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225360C);
		  /* 8225360Ch */ case    0:  		/* srawi R11, R30, 8 */
		/* 8225360Ch case    0:*/		cpu::op::srawi<0,8>(regs,&regs.R11,regs.R30);
		/* 8225360Ch case    0:*/		return 0x82253610;
		  /* 82253610h */ case    1:  		/* lis R10, -32256 */
		/* 82253610h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82253610h case    1:*/		return 0x82253614;
		  /* 82253614h */ case    2:  		/* addze R11, R11 */
		/* 82253614h case    2:*/		cpu::op::addze<0>(regs,&regs.R11,regs.R11);
		/* 82253614h case    2:*/		return 0x82253618;
		  /* 82253618h */ case    3:  		/* li R9, 1 */
		/* 82253618h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82253618h case    3:*/		return 0x8225361C;
		  /* 8225361Ch */ case    4:  		/* extsw R8, R11 */
		/* 8225361Ch case    4:*/		cpu::op::extsw<0>(regs,&regs.R8,regs.R11);
		/* 8225361Ch case    4:*/		return 0x82253620;
		  /* 82253620h */ case    5:  		/* slw R11, R9, R31 */
		/* 82253620h case    5:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R9,regs.R31);
		/* 82253620h case    5:*/		return 0x82253624;
		  /* 82253624h */ case    6:  		/* std R8, <#[R1 + 88]> */
		/* 82253624h case    6:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000058) );
		/* 82253624h case    6:*/		return 0x82253628;
		  /* 82253628h */ case    7:  		/* lfs FR13, <#[R10 + 1816]> */
		/* 82253628h case    7:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000718) );
		/* 82253628h case    7:*/		return 0x8225362C;
		  /* 8225362Ch */ case    8:  		/* addi R3, R11, -1 */
		/* 8225362Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFFF);
		/* 8225362Ch case    8:*/		return 0x82253630;
		  /* 82253630h */ case    9:  		/* lfd FR0, <#[R1 + 88]> */
		/* 82253630h case    9:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82253630h case    9:*/		return 0x82253634;
		  /* 82253634h */ case   10:  		/* fcfid FR0, FR0 */
		/* 82253634h case   10:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82253634h case   10:*/		return 0x82253638;
		  /* 82253638h */ case   11:  		/* frsp FR0, FR0 */
		/* 82253638h case   11:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 82253638h case   11:*/		return 0x8225363C;
		  /* 8225363Ch */ case   12:  		/* fadds FR0, FR0, FR31 */
		/* 8225363Ch case   12:*/		cpu::op::fadds<0>(regs,&regs.FR0,regs.FR0,regs.FR31);
		/* 8225363Ch case   12:*/		return 0x82253640;
		  /* 82253640h */ case   13:  		/* fcmpu CR6, FR0, FR13 */
		/* 82253640h case   13:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82253640h case   13:*/		return 0x82253644;
		  /* 82253644h */ case   14:  		/* bc 4, CR6_GT, -880 */
		/* 82253644h case   14:*/		if ( !regs.CR[6].gt ) { return 0x822532D4;  }
		/* 82253644h case   14:*/		return 0x82253648;
		  /* 82253648h */ case   15:  		/* extsw R11, R3 */
		/* 82253648h case   15:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R3);
		/* 82253648h case   15:*/		return 0x8225364C;
		  /* 8225364Ch */ case   16:  		/* std R11, <#[R1 + 88]> */
		/* 8225364Ch case   16:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8225364Ch case   16:*/		return 0x82253650;
		  /* 82253650h */ case   17:  		/* lfd FR13, <#[R1 + 88]> */
		/* 82253650h case   17:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 82253650h case   17:*/		return 0x82253654;
		  /* 82253654h */ case   18:  		/* fcfid FR13, FR13 */
		/* 82253654h case   18:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 82253654h case   18:*/		return 0x82253658;
		  /* 82253658h */ case   19:  		/* frsp FR13, FR13 */
		/* 82253658h case   19:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 82253658h case   19:*/		return 0x8225365C;
		  /* 8225365Ch */ case   20:  		/* fcmpu CR6, FR0, FR13 */
		/* 8225365Ch case   20:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 8225365Ch case   20:*/		return 0x82253660;
	}
	return 0x82253660;
} // Block from 8225360Ch-82253660h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82253660h
// Function 'r400BytesPerDataElement'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253660);
		  /* 82253660h */ case    0:  		/* bc 4, CR6_LT, 260 */
		/* 82253660h case    0:*/		if ( !regs.CR[6].lt ) { return 0x82253764;  }
		/* 82253660h case    0:*/		return 0x82253664;
		  /* 82253664h */ case    1:  		/* fctiwz FR0, FR0 */
		/* 82253664h case    1:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 82253664h case    1:*/		return 0x82253668;
		  /* 82253668h */ case    2:  		/* stfd FR0, <#[R1 + 88]> */
		/* 82253668h case    2:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82253668h case    2:*/		return 0x8225366C;
		  /* 8225366Ch */ case    3:  		/* lwz R3, <#[R1 + 92]> */
		/* 8225366Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 8225366Ch case    3:*/		return 0x82253670;
		  /* 82253670h */ case    4:  		/* b 244 */
		/* 82253670h case    4:*/		return 0x82253764;
		/* 82253670h case    4:*/		return 0x82253674;
	}
	return 0x82253674;
} // Block from 82253660h-82253674h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82253674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253674);
		  /* 82253674h */ case    0:  		/* addi R11, R31, -1 */
		/* 82253674h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFF);
		/* 82253674h case    0:*/		return 0x82253678;
		  /* 82253678h */ case    1:  		/* li R9, 1 */
		/* 82253678h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82253678h case    1:*/		return 0x8225367C;
		  /* 8225367Ch */ case    2:  		/* lis R10, -32256 */
		/* 8225367Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8225367Ch case    2:*/		return 0x82253680;
		  /* 82253680h */ case    3:  		/* slw R11, R9, R11 */
		/* 82253680h case    3:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82253680h case    3:*/		return 0x82253684;
		  /* 82253684h */ case    4:  		/* addi R3, R11, -1 */
		/* 82253684h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFFF);
		/* 82253684h case    4:*/		return 0x82253688;
		  /* 82253688h */ case    5:  		/* lfs FR0, <#[R10 + 1816]> */
		/* 82253688h case    5:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000718) );
		/* 82253688h case    5:*/		return 0x8225368C;
		  /* 8225368Ch */ case    6:  		/* rlwinm R11, R30, 1, 0, 31 */
		/* 8225368Ch case    6:*/		cpu::op::rlwinm<0,1,0,31>(regs,&regs.R11,regs.R30);
		/* 8225368Ch case    6:*/		return 0x82253690;
		  /* 82253690h */ case    7:  		/* fcmpu CR6, FR31, FR0 */
		/* 82253690h case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 82253690h case    7:*/		return 0x82253694;
		  /* 82253694h */ case    8:  		/* divw R10, R30, R3 */
		/* 82253694h case    8:*/		cpu::op::divw<0>(regs,&regs.R10,regs.R30,regs.R3);
		/* 82253694h case    8:*/		return 0x82253698;
		  /* 82253698h */ case    9:  		/* addi R11, R11, -1 */
		/* 82253698h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82253698h case    9:*/		return 0x8225369C;
		  /* 8225369Ch */ case   10:  		/* srawi R10, R10, 8 */
		/* 8225369Ch case   10:*/		cpu::op::srawi<0,8>(regs,&regs.R10,regs.R10);
		/* 8225369Ch case   10:*/		return 0x822536A0;
		  /* 822536A0h */ case   11:  		/* andc R11, R3, R11 */
		/* 822536A0h case   11:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 822536A0h case   11:*/		return 0x822536A4;
		  /* 822536A4h */ case   12:  		/* addze R10, R10 */
		/* 822536A4h case   12:*/		cpu::op::addze<0>(regs,&regs.R10,regs.R10);
		/* 822536A4h case   12:*/		return 0x822536A8;
		  /* 822536A8h */ case   13:  		/* twi 6, R3, 0 */
		/* 822536A8h case   13:*/		cpu::op::tw<6>(regs, 0x822536A8, regs.R3, 0x00000000);
		/* 822536A8h case   13:*/		return 0x822536AC;
		  /* 822536ACh */ case   14:  		/* extsw R10, R10 */
		/* 822536ACh case   14:*/		cpu::op::extsw<0>(regs,&regs.R10,regs.R10);
		/* 822536ACh case   14:*/		return 0x822536B0;
		  /* 822536B0h */ case   15:  		/* twi 5, R11, -1 */
		/* 822536B0h case   15:*/		cpu::op::tw<5>(regs, 0x822536B0, regs.R11, 0xFFFFFFFF);
		/* 822536B0h case   15:*/		return 0x822536B4;
		  /* 822536B4h */ case   16:  		/* bc 12, CR6_LT, 80 */
		/* 822536B4h case   16:*/		if ( regs.CR[6].lt ) { return 0x82253704;  }
		/* 822536B4h case   16:*/		return 0x822536B8;
		  /* 822536B8h */ case   17:  		/* std R10, <#[R1 + 88]> */
		/* 822536B8h case   17:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 822536B8h case   17:*/		return 0x822536BC;
		  /* 822536BCh */ case   18:  		/* lis R9, -32256 */
		/* 822536BCh case   18:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 822536BCh case   18:*/		return 0x822536C0;
		  /* 822536C0h */ case   19:  		/* lfs FR13, <#[R9 + 1792]> */
		/* 822536C0h case   19:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R9 + 0x00000700) );
		/* 822536C0h case   19:*/		return 0x822536C4;
		  /* 822536C4h */ case   20:  		/* lfd FR0, <#[R1 + 88]> */
		/* 822536C4h case   20:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 822536C4h case   20:*/		return 0x822536C8;
	}
	return 0x822536C8;
} // Block from 82253674h-822536C8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 822536C8h
// Function 'r400BytesPerColorElement'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822536C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822536C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822536C8);
		  /* 822536C8h */ case    0:  		/* fcfid FR0, FR0 */
		/* 822536C8h case    0:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 822536C8h case    0:*/		return 0x822536CC;
		  /* 822536CCh */ case    1:  		/* frsp FR0, FR0 */
		/* 822536CCh case    1:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 822536CCh case    1:*/		return 0x822536D0;
		  /* 822536D0h */ case    2:  		/* fadds FR0, FR0, FR31 */
		/* 822536D0h case    2:*/		cpu::op::fadds<0>(regs,&regs.FR0,regs.FR0,regs.FR31);
		/* 822536D0h case    2:*/		return 0x822536D4;
		  /* 822536D4h */ case    3:  		/* fcmpu CR6, FR0, FR13 */
		/* 822536D4h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 822536D4h case    3:*/		return 0x822536D8;
		  /* 822536D8h */ case    4:  		/* bc 4, CR6_LT, 140 */
		/* 822536D8h case    4:*/		if ( !regs.CR[6].lt ) { return 0x82253764;  }
		/* 822536D8h case    4:*/		return 0x822536DC;
		  /* 822536DCh */ case    5:  		/* extsw R11, R3 */
		/* 822536DCh case    5:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R3);
		/* 822536DCh case    5:*/		return 0x822536E0;
		  /* 822536E0h */ case    6:  		/* std R11, <#[R1 + 88]> */
		/* 822536E0h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 822536E0h case    6:*/		return 0x822536E4;
		  /* 822536E4h */ case    7:  		/* lfd FR13, <#[R1 + 88]> */
		/* 822536E4h case    7:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 822536E4h case    7:*/		return 0x822536E8;
		  /* 822536E8h */ case    8:  		/* fcfid FR13, FR13 */
		/* 822536E8h case    8:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 822536E8h case    8:*/		return 0x822536EC;
		  /* 822536ECh */ case    9:  		/* frsp FR13, FR13 */
		/* 822536ECh case    9:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 822536ECh case    9:*/		return 0x822536F0;
		  /* 822536F0h */ case   10:  		/* fmuls FR0, FR13, FR0 */
		/* 822536F0h case   10:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 822536F0h case   10:*/		return 0x822536F4;
		  /* 822536F4h */ case   11:  		/* fctiwz FR0, FR0 */
		/* 822536F4h case   11:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 822536F4h case   11:*/		return 0x822536F8;
		  /* 822536F8h */ case   12:  		/* stfd FR0, <#[R1 + 88]> */
		/* 822536F8h case   12:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 822536F8h case   12:*/		return 0x822536FC;
		  /* 822536FCh */ case   13:  		/* lwz R3, <#[R1 + 92]> */
		/* 822536FCh case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 822536FCh case   13:*/		return 0x82253700;
		  /* 82253700h */ case   14:  		/* b 100 */
		/* 82253700h case   14:*/		return 0x82253764;
		/* 82253700h case   14:*/		return 0x82253704;
	}
	return 0x82253704;
} // Block from 822536C8h-82253704h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82253704h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253704( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253704) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253704);
		  /* 82253704h */ case    0:  		/* std R10, <#[R1 + 88]> */
		/* 82253704h case    0:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82253704h case    0:*/		return 0x82253708;
		  /* 82253708h */ case    1:  		/* lis R9, -32256 */
		/* 82253708h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 82253708h case    1:*/		return 0x8225370C;
		  /* 8225370Ch */ case    2:  		/* lfs FR13, <#[R9 + 8792]> */
		/* 8225370Ch case    2:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R9 + 0x00002258) );
		/* 8225370Ch case    2:*/		return 0x82253710;
		  /* 82253710h */ case    3:  		/* lfd FR0, <#[R1 + 88]> */
		/* 82253710h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82253710h case    3:*/		return 0x82253714;
		  /* 82253714h */ case    4:  		/* fcfid FR0, FR0 */
		/* 82253714h case    4:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82253714h case    4:*/		return 0x82253718;
		  /* 82253718h */ case    5:  		/* frsp FR0, FR0 */
		/* 82253718h case    5:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 82253718h case    5:*/		return 0x8225371C;
		  /* 8225371Ch */ case    6:  		/* fsubs FR0, FR31, FR0 */
		/* 8225371Ch case    6:*/		cpu::op::fsubs<0>(regs,&regs.FR0,regs.FR31,regs.FR0);
		/* 8225371Ch case    6:*/		return 0x82253720;
		  /* 82253720h */ case    7:  		/* fcmpu CR6, FR0, FR13 */
		/* 82253720h case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82253720h case    7:*/		return 0x82253724;
		  /* 82253724h */ case    8:  		/* bc 12, CR6_GT, 12 */
		/* 82253724h case    8:*/		if ( regs.CR[6].gt ) { return 0x82253730;  }
		/* 82253724h case    8:*/		return 0x82253728;
		  /* 82253728h */ case    9:  		/* neg R3, R3 */
		/* 82253728h case    9:*/		cpu::op::neg<0>(regs,&regs.R3,regs.R3);
		/* 82253728h case    9:*/		return 0x8225372C;
		  /* 8225372Ch */ case   10:  		/* b 56 */
		/* 8225372Ch case   10:*/		return 0x82253764;
		/* 8225372Ch case   10:*/		return 0x82253730;
	}
	return 0x82253730;
} // Block from 82253704h-82253730h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82253730h
// Function 'r400ChannelsPerColorElement'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253730);
		  /* 82253730h */ case    0:  		/* extsw R11, R3 */
		/* 82253730h case    0:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R3);
		/* 82253730h case    0:*/		return 0x82253734;
		  /* 82253734h */ case    1:  		/* std R11, <#[R1 + 88]> */
		/* 82253734h case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82253734h case    1:*/		return 0x82253738;
		  /* 82253738h */ case    2:  		/* lfd FR13, <#[R1 + 88]> */
		/* 82253738h case    2:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 82253738h case    2:*/		return 0x8225373C;
		  /* 8225373Ch */ case    3:  		/* fcfid FR13, FR13 */
		/* 8225373Ch case    3:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 8225373Ch case    3:*/		return 0x82253740;
		  /* 82253740h */ case    4:  		/* frsp FR13, FR13 */
		/* 82253740h case    4:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 82253740h case    4:*/		return 0x82253744;
		  /* 82253744h */ case    5:  		/* fmuls FR0, FR13, FR0 */
		/* 82253744h case    5:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 82253744h case    5:*/		return 0x82253748;
		  /* 82253748h */ case    6:  		/* fctiwz FR0, FR0 */
		/* 82253748h case    6:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 82253748h case    6:*/		return 0x8225374C;
		  /* 8225374Ch */ case    7:  		/* stfd FR0, <#[R1 + 88]> */
		/* 8225374Ch case    7:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 8225374Ch case    7:*/		return 0x82253750;
		  /* 82253750h */ case    8:  		/* lwz R3, <#[R1 + 92]> */
		/* 82253750h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 82253750h case    8:*/		return 0x82253754;
		  /* 82253754h */ case    9:  		/* b 16 */
		/* 82253754h case    9:*/		return 0x82253764;
		/* 82253754h case    9:*/		return 0x82253758;
	}
	return 0x82253758;
} // Block from 82253730h-82253758h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82253758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253758);
		  /* 82253758h */ case    0:  		/* fctiwz FR0, FR0 */
		/* 82253758h case    0:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 82253758h case    0:*/		return 0x8225375C;
		  /* 8225375Ch */ case    1:  		/* stfd FR0, <#[R1 + 88]> */
		/* 8225375Ch case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 8225375Ch case    1:*/		return 0x82253760;
		  /* 82253760h */ case    2:  		/* lwz R3, <#[R1 + 92]> */
		/* 82253760h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 82253760h case    2:*/		return 0x82253764;
	}
	return 0x82253764;
} // Block from 82253758h-82253764h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82253764h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253764( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253764) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253764);
		  /* 82253764h */ case    0:  		/* addi R1, R1, 128 */
		/* 82253764h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82253764h case    0:*/		return 0x82253768;
		  /* 82253768h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82253768h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82253768h case    1:*/		return 0x8225376C;
		  /* 8225376Ch */ case    2:  		/* mtspr LR, R12 */
		/* 8225376Ch case    2:*/		regs.LR = regs.R12;
		/* 8225376Ch case    2:*/		return 0x82253770;
		  /* 82253770h */ case    3:  		/* lfd FR31, <#[R1 - 32]> */
		/* 82253770h case    3:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 82253770h case    3:*/		return 0x82253774;
		  /* 82253774h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 82253774h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82253774h case    4:*/		return 0x82253778;
		  /* 82253778h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 82253778h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82253778h case    5:*/		return 0x8225377C;
		  /* 8225377Ch */ case    6:  		/* bclr 20, CR0_LT */
		/* 8225377Ch case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225377Ch case    6:*/		return 0x82253780;
	}
	return 0x82253780;
} // Block from 82253764h-82253780h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82253780h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253780);
		  /* 82253780h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82253780h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82253780h case    0:*/		return 0x82253784;
		  /* 82253784h */ case    1:  		/* addi R10, R3, 12 */
		/* 82253784h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0xC);
		/* 82253784h case    1:*/		return 0x82253788;
		  /* 82253788h */ case    2:  		/* subf R11, R11, R10 */
		/* 82253788h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82253788h case    2:*/		return 0x8225378C;
		  /* 8225378Ch */ case    3:  		/* cntlzw R11, R11 */
		/* 8225378Ch case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8225378Ch case    3:*/		return 0x82253790;
	}
	return 0x82253790;
} // Block from 82253780h-82253790h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82253790h
// Function 'r400BitsPerDataChannel'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253790);
		  /* 82253790h */ case    0:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 82253790h case    0:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 82253790h case    0:*/		return 0x82253794;
		  /* 82253794h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82253794h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82253794h case    1:*/		return 0x82253798;
	}
	return 0x82253798;
} // Block from 82253790h-82253798h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82253798h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253798);
		  /* 82253798h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82253798h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82253798h case    0:*/		return 0x8225379C;
		  /* 8225379Ch */ case    1:  		/* li R4, 1 */
		/* 8225379Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225379Ch case    1:*/		return 0x822537A0;
		  /* 822537A0h */ case    2:  		/* lwz R10, <#[R3 + 4]> */
		/* 822537A0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 822537A0h case    2:*/		return 0x822537A4;
		  /* 822537A4h */ case    3:  		/* stw R10, <#[R11 + 4]> */
		/* 822537A4h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 822537A4h case    3:*/		return 0x822537A8;
		  /* 822537A8h */ case    4:  		/* lwz R11, <#[R3 + 4]> */
		/* 822537A8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 822537A8h case    4:*/		return 0x822537AC;
		  /* 822537ACh */ case    5:  		/* lwz R10, <#[R3 + 8]> */
		/* 822537ACh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 822537ACh case    5:*/		return 0x822537B0;
		  /* 822537B0h */ case    6:  		/* stw R10, <#[R11 + 8]> */
		/* 822537B0h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 822537B0h case    6:*/		return 0x822537B4;
		  /* 822537B4h */ case    7:  		/* lwz R11, <#[R3]> */
		/* 822537B4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822537B4h case    7:*/		return 0x822537B8;
		  /* 822537B8h */ case    8:  		/* lwz R11, <#[R11]> */
		/* 822537B8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822537B8h case    8:*/		return 0x822537BC;
		  /* 822537BCh */ case    9:  		/* mtspr CTR, R11 */
		/* 822537BCh case    9:*/		regs.CTR = regs.R11;
		/* 822537BCh case    9:*/		return 0x822537C0;
		  /* 822537C0h */ case   10:  		/* bcctr 20, CR0_LT */
		/* 822537C0h case   10:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 822537C0h case   10:*/		return 0x822537C4;
		  /* 822537C4h */ case   11:  		/* nop */
		/* 822537C4h case   11:*/		cpu::op::nop();
		/* 822537C4h case   11:*/		return 0x822537C8;
	}
	return 0x822537C8;
} // Block from 82253798h-822537C8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822537C8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822537C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822537C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822537C8);
		  /* 822537C8h */ case    0:  		/* lwz R11, <#[R4 + 4]> */
		/* 822537C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 822537C8h case    0:*/		return 0x822537CC;
		  /* 822537CCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 822537CCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822537CCh case    1:*/		return 0x822537D0;
		  /* 822537D0h */ case    2:  		/* stw R11, <#[R3 + 4]> */
		/* 822537D0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 822537D0h case    2:*/		return 0x822537D4;
		  /* 822537D4h */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 822537D4h case    3:*/		if ( regs.CR[6].eq ) { return 0x822537DC;  }
		/* 822537D4h case    3:*/		return 0x822537D8;
		  /* 822537D8h */ case    4:  		/* stw R3, <#[R11 + 8]> */
		/* 822537D8h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000008) );
		/* 822537D8h case    4:*/		return 0x822537DC;
	}
	return 0x822537DC;
} // Block from 822537C8h-822537DCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 822537DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822537DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822537DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822537DC);
		  /* 822537DCh */ case    0:  		/* stw R4, <#[R3 + 8]> */
		/* 822537DCh case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000008) );
		/* 822537DCh case    0:*/		return 0x822537E0;
		  /* 822537E0h */ case    1:  		/* stw R3, <#[R4 + 4]> */
		/* 822537E0h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R4 + 0x00000004) );
		/* 822537E0h case    1:*/		return 0x822537E4;
		  /* 822537E4h */ case    2:  		/* bclr 20, CR0_LT */
		/* 822537E4h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822537E4h case    2:*/		return 0x822537E8;
	}
	return 0x822537E8;
} // Block from 822537DCh-822537E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822537E8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822537E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822537E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822537E8);
		  /* 822537E8h */ case    0:  		/* lwz R11, <#[R4 + 8]> */
		/* 822537E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 822537E8h case    0:*/		return 0x822537EC;
		  /* 822537ECh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 822537ECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822537ECh case    1:*/		return 0x822537F0;
		  /* 822537F0h */ case    2:  		/* stw R11, <#[R3 + 8]> */
		/* 822537F0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 822537F0h case    2:*/		return 0x822537F4;
		  /* 822537F4h */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 822537F4h case    3:*/		if ( regs.CR[6].eq ) { return 0x822537FC;  }
		/* 822537F4h case    3:*/		return 0x822537F8;
		  /* 822537F8h */ case    4:  		/* stw R3, <#[R11 + 4]> */
		/* 822537F8h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000004) );
		/* 822537F8h case    4:*/		return 0x822537FC;
	}
	return 0x822537FC;
} // Block from 822537E8h-822537FCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 822537FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822537FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822537FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822537FC);
		  /* 822537FCh */ case    0:  		/* stw R4, <#[R3 + 4]> */
		/* 822537FCh case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 822537FCh case    0:*/		return 0x82253800;
		  /* 82253800h */ case    1:  		/* stw R3, <#[R4 + 8]> */
		/* 82253800h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R4 + 0x00000008) );
		/* 82253800h case    1:*/		return 0x82253804;
		  /* 82253804h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82253804h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82253804h case    2:*/		return 0x82253808;
	}
	return 0x82253808;
} // Block from 822537FCh-82253808h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82253808h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253808);
		  /* 82253808h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 82253808h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82253808h case    0:*/		return 0x8225380C;
		  /* 8225380Ch */ case    1:  		/* lwz R10, <#[R3 + 8]> */
		/* 8225380Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 8225380Ch case    1:*/		return 0x82253810;
		  /* 82253810h */ case    2:  		/* stw R10, <#[R11 + 8]> */
		/* 82253810h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82253810h case    2:*/		return 0x82253814;
		  /* 82253814h */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 82253814h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82253814h case    3:*/		return 0x82253818;
		  /* 82253818h */ case    4:  		/* lwz R10, <#[R3 + 4]> */
		/* 82253818h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 82253818h case    4:*/		return 0x8225381C;
		  /* 8225381Ch */ case    5:  		/* stw R10, <#[R11 + 4]> */
		/* 8225381Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8225381Ch case    5:*/		return 0x82253820;
		  /* 82253820h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82253820h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82253820h case    6:*/		return 0x82253824;
	}
	return 0x82253824;
} // Block from 82253808h-82253824h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82253824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253824);
		  /* 82253824h */ case    0:  		/* nop */
		/* 82253824h case    0:*/		cpu::op::nop();
		/* 82253824h case    0:*/		return 0x82253828;
	}
	return 0x82253828;
} // Block from 82253824h-82253828h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82253828h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253828);
		  /* 82253828h */ case    0:  		/* lis R10, -32252 */
		/* 82253828h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82253828h case    0:*/		return 0x8225382C;
		  /* 8225382Ch */ case    1:  		/* li R11, 0 */
		/* 8225382Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225382Ch case    1:*/		return 0x82253830;
		  /* 82253830h */ case    2:  		/* addi R9, R10, 14380 */
		/* 82253830h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x382C);
		/* 82253830h case    2:*/		return 0x82253834;
		  /* 82253834h */ case    3:  		/* addi R10, R3, 12 */
		/* 82253834h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0xC);
		/* 82253834h case    3:*/		return 0x82253838;
		  /* 82253838h */ case    4:  		/* stw R9, <#[R3]> */
		/* 82253838h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 82253838h case    4:*/		return 0x8225383C;
		  /* 8225383Ch */ case    5:  		/* stw R9, <#[R3 + 12]> */
		/* 8225383Ch case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x0000000C) );
		/* 8225383Ch case    5:*/		return 0x82253840;
		  /* 82253840h */ case    6:  		/* stw R11, <#[R3 + 16]> */
		/* 82253840h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82253840h case    6:*/		return 0x82253844;
		  /* 82253844h */ case    7:  		/* stw R11, <#[R3 + 20]> */
		/* 82253844h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82253844h case    7:*/		return 0x82253848;
		  /* 82253848h */ case    8:  		/* stw R10, <#[R3 + 8]> */
		/* 82253848h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82253848h case    8:*/		return 0x8225384C;
		  /* 8225384Ch */ case    9:  		/* stw R11, <#[R3 + 4]> */
		/* 8225384Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8225384Ch case    9:*/		return 0x82253850;
		  /* 82253850h */ case   10:  		/* stw R3, <#[R3 + 16]> */
		/* 82253850h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R3 + 0x00000010) );
		/* 82253850h case   10:*/		return 0x82253854;
		  /* 82253854h */ case   11:  		/* stw R11, <#[R3 + 20]> */
		/* 82253854h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82253854h case   11:*/		return 0x82253858;
		  /* 82253858h */ case   12:  		/* bclr 20, CR0_LT */
		/* 82253858h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82253858h case   12:*/		return 0x8225385C;
	}
	return 0x8225385C;
} // Block from 82253828h-8225385Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8225385Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225385C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225385C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225385C);
		  /* 8225385Ch */ case    0:  		/* nop */
		/* 8225385Ch case    0:*/		cpu::op::nop();
		/* 8225385Ch case    0:*/		return 0x82253860;
	}
	return 0x82253860;
} // Block from 8225385Ch-82253860h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82253860h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253860);
		  /* 82253860h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82253860h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82253860h case    0:*/		return 0x82253864;
		  /* 82253864h */ case    1:  		/* addi R10, R3, 12 */
		/* 82253864h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0xC);
		/* 82253864h case    1:*/		return 0x82253868;
		  /* 82253868h */ case    2:  		/* li R3, 0 */
		/* 82253868h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82253868h case    2:*/		return 0x8225386C;
		  /* 8225386Ch */ case    3:  		/* b 12 */
		/* 8225386Ch case    3:*/		return 0x82253878;
		/* 8225386Ch case    3:*/		return 0x82253870;
		  /* 82253870h */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 82253870h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82253870h case    4:*/		return 0x82253874;
		  /* 82253874h */ case    5:  		/* addi R3, R3, 1 */
		/* 82253874h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 82253874h case    5:*/		return 0x82253878;
	}
	return 0x82253878;
} // Block from 82253860h-82253878h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82253878h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253878);
		  /* 82253878h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 82253878h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82253878h case    0:*/		return 0x8225387C;
		  /* 8225387Ch */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 8225387Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82253870;  }
		/* 8225387Ch case    1:*/		return 0x82253880;
		  /* 82253880h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82253880h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82253880h case    2:*/		return 0x82253884;
	}
	return 0x82253884;
} // Block from 82253878h-82253884h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82253884h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253884( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253884) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253884);
		  /* 82253884h */ case    0:  		/* nop */
		/* 82253884h case    0:*/		cpu::op::nop();
		/* 82253884h case    0:*/		return 0x82253888;
	}
	return 0x82253888;
} // Block from 82253884h-82253888h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82253888h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253888);
		  /* 82253888h */ case    0:  		/* lwz R11, <#[R3 + 16]> */
		/* 82253888h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82253888h case    0:*/		return 0x8225388C;
		  /* 8225388Ch */ case    1:  		/* addi R10, R3, 12 */
		/* 8225388Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0xC);
		/* 8225388Ch case    1:*/		return 0x82253890;
		  /* 82253890h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82253890h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82253890h case    2:*/		return 0x82253894;
		  /* 82253894h */ case    3:  		/* stw R11, <#[R4 + 4]> */
		/* 82253894h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 82253894h case    3:*/		return 0x82253898;
		  /* 82253898h */ case    4:  		/* bc 12, CR6_EQ, 8 */
		/* 82253898h case    4:*/		if ( regs.CR[6].eq ) { return 0x822538A0;  }
		/* 82253898h case    4:*/		return 0x8225389C;
		  /* 8225389Ch */ case    5:  		/* stw R4, <#[R11 + 8]> */
		/* 8225389Ch case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000008) );
		/* 8225389Ch case    5:*/		return 0x822538A0;
	}
	return 0x822538A0;
} // Block from 82253888h-822538A0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822538A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822538A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822538A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822538A0);
		  /* 822538A0h */ case    0:  		/* stw R10, <#[R4 + 8]> */
		/* 822538A0h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 822538A0h case    0:*/		return 0x822538A4;
		  /* 822538A4h */ case    1:  		/* stw R4, <#[R10 + 4]> */
		/* 822538A4h case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R10 + 0x00000004) );
		/* 822538A4h case    1:*/		return 0x822538A8;
		  /* 822538A8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 822538A8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822538A8h case    2:*/		return 0x822538AC;
	}
	return 0x822538AC;
} // Block from 822538A0h-822538ACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 822538ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822538AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822538AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822538AC);
		  /* 822538ACh */ case    0:  		/* nop */
		/* 822538ACh case    0:*/		cpu::op::nop();
		/* 822538ACh case    0:*/		return 0x822538B0;
	}
	return 0x822538B0;
} // Block from 822538ACh-822538B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822538B0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822538B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822538B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822538B0);
		  /* 822538B0h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 822538B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 822538B0h case    0:*/		return 0x822538B4;
		  /* 822538B4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 822538B4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822538B4h case    1:*/		return 0x822538B8;
		  /* 822538B8h */ case    2:  		/* stw R11, <#[R4 + 8]> */
		/* 822538B8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 822538B8h case    2:*/		return 0x822538BC;
		  /* 822538BCh */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 822538BCh case    3:*/		if ( regs.CR[6].eq ) { return 0x822538C4;  }
		/* 822538BCh case    3:*/		return 0x822538C0;
		  /* 822538C0h */ case    4:  		/* stw R4, <#[R11 + 4]> */
		/* 822538C0h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 822538C0h case    4:*/		return 0x822538C4;
	}
	return 0x822538C4;
} // Block from 822538B0h-822538C4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822538C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822538C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822538C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822538C4);
		  /* 822538C4h */ case    0:  		/* stw R3, <#[R4 + 4]> */
		/* 822538C4h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R4 + 0x00000004) );
		/* 822538C4h case    0:*/		return 0x822538C8;
		  /* 822538C8h */ case    1:  		/* stw R4, <#[R3 + 8]> */
		/* 822538C8h case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000008) );
		/* 822538C8h case    1:*/		return 0x822538CC;
		  /* 822538CCh */ case    2:  		/* bclr 20, CR0_LT */
		/* 822538CCh case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822538CCh case    2:*/		return 0x822538D0;
	}
	return 0x822538D0;
} // Block from 822538C4h-822538D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822538D0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822538D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822538D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822538D0);
		  /* 822538D0h */ case    0:  		/* mfspr R12, LR */
		/* 822538D0h case    0:*/		regs.R12 = regs.LR;
		/* 822538D0h case    0:*/		return 0x822538D4;
		  /* 822538D4h */ case    1:  		/* bl -1844856 */
		/* 822538D4h case    1:*/		regs.LR = 0x822538D8; return 0x8209125C;
		/* 822538D4h case    1:*/		return 0x822538D8;
		  /* 822538D8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 822538D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822538D8h case    2:*/		return 0x822538DC;
		  /* 822538DCh */ case    3:  		/* addi R30, R3, 12 */
		/* 822538DCh case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0xC);
		/* 822538DCh case    3:*/		return 0x822538E0;
		  /* 822538E0h */ case    4:  		/* mr R31, R3 */
		/* 822538E0h case    4:*/		regs.R31 = regs.R3;
		/* 822538E0h case    4:*/		return 0x822538E4;
		  /* 822538E4h */ case    5:  		/* lwz R3, <#[R3 + 8]> */
		/* 822538E4h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000008) );
		/* 822538E4h case    5:*/		return 0x822538E8;
		  /* 822538E8h */ case    6:  		/* cmplw CR6, R3, R30 */
		/* 822538E8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R30);
		/* 822538E8h case    6:*/		return 0x822538EC;
		  /* 822538ECh */ case    7:  		/* bc 12, CR6_EQ, 40 */
		/* 822538ECh case    7:*/		if ( regs.CR[6].eq ) { return 0x82253914;  }
		/* 822538ECh case    7:*/		return 0x822538F0;
		  /* 822538F0h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 822538F0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822538F0h case    8:*/		return 0x822538F4;
		  /* 822538F4h */ case    9:  		/* li R4, 1 */
		/* 822538F4h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822538F4h case    9:*/		return 0x822538F8;
		  /* 822538F8h */ case   10:  		/* lwz R29, <#[R3 + 8]> */
		/* 822538F8h case   10:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000008) );
		/* 822538F8h case   10:*/		return 0x822538FC;
		  /* 822538FCh */ case   11:  		/* lwz R11, <#[R11]> */
		/* 822538FCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822538FCh case   11:*/		return 0x82253900;
		  /* 82253900h */ case   12:  		/* mtspr CTR, R11 */
		/* 82253900h case   12:*/		regs.CTR = regs.R11;
		/* 82253900h case   12:*/		return 0x82253904;
		  /* 82253904h */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 82253904h case   13:*/		if ( 1 ) { regs.LR = 0x82253908; return (uint32)regs.CTR; }
		/* 82253904h case   13:*/		return 0x82253908;
		  /* 82253908h */ case   14:  		/* mr R3, R29 */
		/* 82253908h case   14:*/		regs.R3 = regs.R29;
		/* 82253908h case   14:*/		return 0x8225390C;
		  /* 8225390Ch */ case   15:  		/* cmplw CR6, R29, R30 */
		/* 8225390Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R30);
		/* 8225390Ch case   15:*/		return 0x82253910;
		  /* 82253910h */ case   16:  		/* bc 4, CR6_EQ, -32 */
		/* 82253910h case   16:*/		if ( !regs.CR[6].eq ) { return 0x822538F0;  }
		/* 82253910h case   16:*/		return 0x82253914;
	}
	return 0x82253914;
} // Block from 822538D0h-82253914h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82253914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253914);
		  /* 82253914h */ case    0:  		/* stw R30, <#[R31 + 8]> */
		/* 82253914h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000008) );
		/* 82253914h case    0:*/		return 0x82253918;
		  /* 82253918h */ case    1:  		/* stw R31, <#[R31 + 16]> */
		/* 82253918h case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R31 + 0x00000010) );
		/* 82253918h case    1:*/		return 0x8225391C;
		  /* 8225391Ch */ case    2:  		/* addi R1, R1, 112 */
		/* 8225391Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8225391Ch case    2:*/		return 0x82253920;
		  /* 82253920h */ case    3:  		/* b -1844852 */
		/* 82253920h case    3:*/		return 0x820912AC;
		/* 82253920h case    3:*/		return 0x82253924;
		  /* 82253924h */ case    4:  		/* nop */
		/* 82253924h case    4:*/		cpu::op::nop();
		/* 82253924h case    4:*/		return 0x82253928;
	}
	return 0x82253928;
} // Block from 82253914h-82253928h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82253928h
// Function 'r400BitsPerColorChannel'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253928);
		  /* 82253928h */ case    0:  		/* mfspr R12, LR */
		/* 82253928h case    0:*/		regs.R12 = regs.LR;
		/* 82253928h case    0:*/		return 0x8225392C;
		  /* 8225392Ch */ case    1:  		/* bl -1844984 */
		/* 8225392Ch case    1:*/		regs.LR = 0x82253930; return 0x82091234;
		/* 8225392Ch case    1:*/		return 0x82253930;
		  /* 82253930h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82253930h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82253930h case    2:*/		return 0x82253934;
		  /* 82253934h */ case    3:  		/* lwz R22, <#[R3 + 8]> */
		/* 82253934h case    3:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R3 + 0x00000008) );
		/* 82253934h case    3:*/		return 0x82253938;
		  /* 82253938h */ case    4:  		/* mr R21, R3 */
		/* 82253938h case    4:*/		regs.R21 = regs.R3;
		/* 82253938h case    4:*/		return 0x8225393C;
		  /* 8225393Ch */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 8225393Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8225393Ch case    5:*/		return 0x82253940;
		  /* 82253940h */ case    6:  		/* mr R19, R4 */
		/* 82253940h case    6:*/		regs.R19 = regs.R4;
		/* 82253940h case    6:*/		return 0x82253944;
		  /* 82253944h */ case    7:  		/* li R10, 1 */
		/* 82253944h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82253944h case    7:*/		return 0x82253948;
		  /* 82253948h */ case    8:  		/* mulli R10, R10, 3 */
		/* 82253948h case    8:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x3);
		/* 82253948h case    8:*/		return 0x8225394C;
		  /* 8225394Ch */ case    9:  		/* addi R10, R10, 1 */
		/* 8225394Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8225394Ch case    9:*/		return 0x82253950;
		  /* 82253950h */ case   10:  		/* cmplw CR6, R10, R11 */
		/* 82253950h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82253950h case   10:*/		return 0x82253954;
		  /* 82253954h */ case   11:  		/* bc 12, CR6_LT, -12 */
		/* 82253954h case   11:*/		if ( regs.CR[6].lt ) { return 0x82253948;  }
		/* 82253954h case   11:*/		return 0x82253958;
		  /* 82253958h */ case   12:  		/* li R20, 3 */
		/* 82253958h case   12:*/		cpu::op::li<0>(regs,&regs.R20,0x3);
		/* 82253958h case   12:*/		return 0x8225395C;
		  /* 8225395Ch */ case   13:  		/* divwu. R31, R10, R20 */
		/* 8225395Ch case   13:*/		cpu::op::divwu<1>(regs,&regs.R31,regs.R10,regs.R20);
		/* 8225395Ch case   13:*/		return 0x82253960;
		  /* 82253960h */ case   14:  		/* bc 12, CR0_EQ, 148 */
		/* 82253960h case   14:*/		if ( regs.CR[0].eq ) { return 0x822539F4;  }
		/* 82253960h case   14:*/		return 0x82253964;
		  /* 82253964h */ case   15:  		/* cmplw CR6, R31, R11 */
		/* 82253964h case   15:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82253964h case   15:*/		return 0x82253968;
		  /* 82253968h */ case   16:  		/* bc 4, CR6_LT, 132 */
		/* 82253968h case   16:*/		if ( !regs.CR[6].lt ) { return 0x822539EC;  }
		/* 82253968h case   16:*/		return 0x8225396C;
		  /* 8225396Ch */ case   17:  		/* rlwinm R24, R31, 2, 0, 29 */
		/* 8225396Ch case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R24,regs.R31);
		/* 8225396Ch case   17:*/		return 0x82253970;
		  /* 82253970h */ case   18:  		/* li R30, 0 */
		/* 82253970h case   18:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82253970h case   18:*/		return 0x82253974;
		  /* 82253974h */ case   19:  		/* add R29, R24, R22 */
		/* 82253974h case   19:*/		cpu::op::add<0>(regs,&regs.R29,regs.R24,regs.R22);
		/* 82253974h case   19:*/		return 0x82253978;
		  /* 82253978h */ case   20:  		/* mr R26, R22 */
		/* 82253978h case   20:*/		regs.R26 = regs.R22;
		/* 82253978h case   20:*/		return 0x8225397C;
		  /* 8225397Ch */ case   21:  		/* lwz R23, <#[R29]> */
		/* 8225397Ch case   21:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R29 + 0x00000000) );
		/* 8225397Ch case   21:*/		return 0x82253980;
		  /* 82253980h */ case   22:  		/* mr R27, R30 */
		/* 82253980h case   22:*/		regs.R27 = regs.R30;
		/* 82253980h case   22:*/		return 0x82253984;
		  /* 82253984h */ case   23:  		/* cmpwi CR6, R30, 0 */
		/* 82253984h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82253984h case   23:*/		return 0x82253988;
		  /* 82253988h */ case   24:  		/* bc 12, CR6_LT, 60 */
		/* 82253988h case   24:*/		if ( regs.CR[6].lt ) { return 0x822539C4;  }
		/* 82253988h case   24:*/		return 0x8225398C;
		  /* 8225398Ch */ case   25:  		/* mr R28, R26 */
		/* 8225398Ch case   25:*/		regs.R28 = regs.R26;
		/* 8225398Ch case   25:*/		return 0x82253990;
		  /* 82253990h */ case   26:  		/* add R25, R29, R24 */
		/* 82253990h case   26:*/		cpu::op::add<0>(regs,&regs.R25,regs.R29,regs.R24);
		/* 82253990h case   26:*/		return 0x82253994;
		  /* 82253994h */ case   27:  		/* mr R4, R23 */
		/* 82253994h case   27:*/		regs.R4 = regs.R23;
		/* 82253994h case   27:*/		return 0x82253998;
		  /* 82253998h */ case   28:  		/* lwz R3, <#[R28]> */
		/* 82253998h case   28:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000000) );
		/* 82253998h case   28:*/		return 0x8225399C;
		  /* 8225399Ch */ case   29:  		/* mtspr CTR, R19 */
		/* 8225399Ch case   29:*/		regs.CTR = regs.R19;
		/* 8225399Ch case   29:*/		return 0x822539A0;
		  /* 822539A0h */ case   30:  		/* bcctrl 20, CR0_LT */
		/* 822539A0h case   30:*/		if ( 1 ) { regs.LR = 0x822539A4; return (uint32)regs.CTR; }
		/* 822539A0h case   30:*/		return 0x822539A4;
		  /* 822539A4h */ case   31:  		/* cmpwi CR0, R3, 0 */
		/* 822539A4h case   31:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 822539A4h case   31:*/		return 0x822539A8;
		  /* 822539A8h */ case   32:  		/* bc 4, CR0_GT, 28 */
		/* 822539A8h case   32:*/		if ( !regs.CR[0].gt ) { return 0x822539C4;  }
		/* 822539A8h case   32:*/		return 0x822539AC;
		  /* 822539ACh */ case   33:  		/* lwz R11, <#[R28]> */
		/* 822539ACh case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 822539ACh case   33:*/		return 0x822539B0;
		  /* 822539B0h */ case   34:  		/* subf R25, R24, R25 */
		/* 822539B0h case   34:*/		cpu::op::subf<0>(regs,&regs.R25,regs.R24,regs.R25);
		/* 822539B0h case   34:*/		return 0x822539B4;
		  /* 822539B4h */ case   35:  		/* subf. R27, R31, R27 */
		/* 822539B4h case   35:*/		cpu::op::subf<1>(regs,&regs.R27,regs.R31,regs.R27);
		/* 822539B4h case   35:*/		return 0x822539B8;
		  /* 822539B8h */ case   36:  		/* subf R28, R24, R28 */
		/* 822539B8h case   36:*/		cpu::op::subf<0>(regs,&regs.R28,regs.R24,regs.R28);
		/* 822539B8h case   36:*/		return 0x822539BC;
		  /* 822539BCh */ case   37:  		/* stw R11, <#[R25]> */
		/* 822539BCh case   37:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 822539BCh case   37:*/		return 0x822539C0;
		  /* 822539C0h */ case   38:  		/* bc 4, CR0_LT, -44 */
		/* 822539C0h case   38:*/		if ( !regs.CR[0].lt ) { return 0x82253994;  }
		/* 822539C0h case   38:*/		return 0x822539C4;
	}
	return 0x822539C4;
} // Block from 82253928h-822539C4h (39 instructions)

//////////////////////////////////////////////////////
// Block at 822539C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822539C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822539C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822539C4);
		  /* 822539C4h */ case    0:  		/* add R11, R27, R31 */
		/* 822539C4h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R27,regs.R31);
		/* 822539C4h case    0:*/		return 0x822539C8;
		  /* 822539C8h */ case    1:  		/* addi R30, R30, 1 */
		/* 822539C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 822539C8h case    1:*/		return 0x822539CC;
		  /* 822539CCh */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822539CCh case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822539CCh case    2:*/		return 0x822539D0;
		  /* 822539D0h */ case    3:  		/* add R10, R30, R31 */
		/* 822539D0h case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R30,regs.R31);
		/* 822539D0h case    3:*/		return 0x822539D4;
		  /* 822539D4h */ case    4:  		/* addi R29, R29, 4 */
		/* 822539D4h case    4:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 822539D4h case    4:*/		return 0x822539D8;
		  /* 822539D8h */ case    5:  		/* addi R26, R26, 4 */
		/* 822539D8h case    5:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 822539D8h case    5:*/		return 0x822539DC;
		  /* 822539DCh */ case    6:  		/* stwx R23, <#[R11 + R22]> */
		/* 822539DCh case    6:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + regs.R22 + 0x00000000) );
		/* 822539DCh case    6:*/		return 0x822539E0;
		  /* 822539E0h */ case    7:  		/* lwz R11, <#[R21 + 4]> */
		/* 822539E0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 822539E0h case    7:*/		return 0x822539E4;
		  /* 822539E4h */ case    8:  		/* cmplw CR6, R10, R11 */
		/* 822539E4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 822539E4h case    8:*/		return 0x822539E8;
		  /* 822539E8h */ case    9:  		/* bc 12, CR6_LT, -108 */
		/* 822539E8h case    9:*/		if ( regs.CR[6].lt ) { return 0x8225397C;  }
		/* 822539E8h case    9:*/		return 0x822539EC;
	}
	return 0x822539EC;
} // Block from 822539C4h-822539ECh (10 instructions)

//////////////////////////////////////////////////////
// Block at 822539ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822539EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822539EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822539EC);
		  /* 822539ECh */ case    0:  		/* divwu. R31, R31, R20 */
		/* 822539ECh case    0:*/		cpu::op::divwu<1>(regs,&regs.R31,regs.R31,regs.R20);
		/* 822539ECh case    0:*/		return 0x822539F0;
		  /* 822539F0h */ case    1:  		/* bc 4, CR0_EQ, -140 */
		/* 822539F0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82253964;  }
		/* 822539F0h case    1:*/		return 0x822539F4;
	}
	return 0x822539F4;
} // Block from 822539ECh-822539F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822539F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822539F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822539F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822539F4);
		  /* 822539F4h */ case    0:  		/* addi R1, R1, 192 */
		/* 822539F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 822539F4h case    0:*/		return 0x822539F8;
		  /* 822539F8h */ case    1:  		/* b -1845108 */
		/* 822539F8h case    1:*/		return 0x82091284;
		/* 822539F8h case    1:*/		return 0x822539FC;
		  /* 822539FCh */ case    2:  		/* nop */
		/* 822539FCh case    2:*/		cpu::op::nop();
		/* 822539FCh case    2:*/		return 0x82253A00;
	}
	return 0x82253A00;
} // Block from 822539F4h-82253A00h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82253A00h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253A00);
		  /* 82253A00h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 82253A00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82253A00h case    0:*/		return 0x82253A04;
		  /* 82253A04h */ case    1:  		/* cmplw CR6, R4, R11 */
		/* 82253A04h case    1:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 82253A04h case    1:*/		return 0x82253A08;
		  /* 82253A08h */ case    2:  		/* bclr 4, CR6_LT */
		/* 82253A08h case    2:*/		if ( !regs.CR[6].lt ) { return (uint32)regs.LR; }
		/* 82253A08h case    2:*/		return 0x82253A0C;
	}
	return 0x82253A0C;
} // Block from 82253A00h-82253A0Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82253A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253A0C);
		  /* 82253A0Ch */ case    0:  		/* addi R11, R11, -1 */
		/* 82253A0Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82253A0Ch case    0:*/		return 0x82253A10;
		  /* 82253A10h */ case    1:  		/* lwz R9, <#[R3 + 8]> */
		/* 82253A10h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 82253A10h case    1:*/		return 0x82253A14;
		  /* 82253A14h */ case    2:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 82253A14h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 82253A14h case    2:*/		return 0x82253A18;
		  /* 82253A18h */ case    3:  		/* stw R11, <#[R3 + 4]> */
		/* 82253A18h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82253A18h case    3:*/		return 0x82253A1C;
		  /* 82253A1Ch */ case    4:  		/* subf R11, R4, R11 */
		/* 82253A1Ch case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R4,regs.R11);
		/* 82253A1Ch case    4:*/		return 0x82253A20;
		  /* 82253A20h */ case    5:  		/* add R3, R10, R9 */
		/* 82253A20h case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R9);
		/* 82253A20h case    5:*/		return 0x82253A24;
		  /* 82253A24h */ case    6:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82253A24h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82253A24h case    6:*/		return 0x82253A28;
		  /* 82253A28h */ case    7:  		/* addi R4, R3, 4 */
		/* 82253A28h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0x4);
		/* 82253A28h case    7:*/		return 0x82253A2C;
		  /* 82253A2Ch */ case    8:  		/* b -1843324 */
		/* 82253A2Ch case    8:*/		return 0x820919B0;
		/* 82253A2Ch case    8:*/		return 0x82253A30;
		  /* 82253A30h */ case    9:  		/* bclr 20, CR0_LT */
		/* 82253A30h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82253A30h case    9:*/		return 0x82253A34;
	}
	return 0x82253A34;
} // Block from 82253A0Ch-82253A34h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82253A34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253A34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253A34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253A34);
		  /* 82253A34h */ case    0:  		/* nop */
		/* 82253A34h case    0:*/		cpu::op::nop();
		/* 82253A34h case    0:*/		return 0x82253A38;
	}
	return 0x82253A38;
} // Block from 82253A34h-82253A38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82253A38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253A38);
		  /* 82253A38h */ case    0:  		/* mfspr R12, LR */
		/* 82253A38h case    0:*/		regs.R12 = regs.LR;
		/* 82253A38h case    0:*/		return 0x82253A3C;
		  /* 82253A3Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82253A3Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82253A3Ch case    1:*/		return 0x82253A40;
		  /* 82253A40h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82253A40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82253A40h case    2:*/		return 0x82253A44;
		  /* 82253A44h */ case    3:  		/* lwz R10, <#[R3 + 4]> */
		/* 82253A44h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 82253A44h case    3:*/		return 0x82253A48;
		  /* 82253A48h */ case    4:  		/* li R11, 0 */
		/* 82253A48h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82253A48h case    4:*/		return 0x82253A4C;
		  /* 82253A4Ch */ case    5:  		/* lwz R8, <#[R3 + 8]> */
		/* 82253A4Ch case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000008) );
		/* 82253A4Ch case    5:*/		return 0x82253A50;
		  /* 82253A50h */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 82253A50h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82253A50h case    6:*/		return 0x82253A54;
		  /* 82253A54h */ case    7:  		/* bc 12, CR6_EQ, 40 */
		/* 82253A54h case    7:*/		if ( regs.CR[6].eq ) { return 0x82253A7C;  }
		/* 82253A54h case    7:*/		return 0x82253A58;
		  /* 82253A58h */ case    8:  		/* mr R9, R8 */
		/* 82253A58h case    8:*/		regs.R9 = regs.R8;
		/* 82253A58h case    8:*/		return 0x82253A5C;
		  /* 82253A5Ch */ case    9:  		/* lwz R7, <#[R9]> */
		/* 82253A5Ch case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 82253A5Ch case    9:*/		return 0x82253A60;
		  /* 82253A60h */ case   10:  		/* cmplw CR6, R4, R7 */
		/* 82253A60h case   10:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R7);
		/* 82253A60h case   10:*/		return 0x82253A64;
		  /* 82253A64h */ case   11:  		/* bc 12, CR6_EQ, 44 */
		/* 82253A64h case   11:*/		if ( regs.CR[6].eq ) { return 0x82253A90;  }
		/* 82253A64h case   11:*/		return 0x82253A68;
		  /* 82253A68h */ case   12:  		/* lwz R7, <#[R3 + 4]> */
		/* 82253A68h case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000004) );
		/* 82253A68h case   12:*/		return 0x82253A6C;
		  /* 82253A6Ch */ case   13:  		/* addi R11, R11, 1 */
		/* 82253A6Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82253A6Ch case   13:*/		return 0x82253A70;
		  /* 82253A70h */ case   14:  		/* addi R9, R9, 4 */
		/* 82253A70h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82253A70h case   14:*/		return 0x82253A74;
		  /* 82253A74h */ case   15:  		/* cmplw CR6, R11, R7 */
		/* 82253A74h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 82253A74h case   15:*/		return 0x82253A78;
		  /* 82253A78h */ case   16:  		/* bc 12, CR6_LT, -28 */
		/* 82253A78h case   16:*/		if ( regs.CR[6].lt ) { return 0x82253A5C;  }
		/* 82253A78h case   16:*/		return 0x82253A7C;
	}
	return 0x82253A7C;
} // Block from 82253A38h-82253A7Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 82253A7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253A7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253A7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253A7C);
		  /* 82253A7Ch */ case    0:  		/* li R3, 0 */
		/* 82253A7Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82253A7Ch case    0:*/		return 0x82253A80;
		  /* 82253A80h */ case    1:  		/* addi R1, R1, 96 */
		/* 82253A80h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82253A80h case    1:*/		return 0x82253A84;
		  /* 82253A84h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82253A84h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82253A84h case    2:*/		return 0x82253A88;
		  /* 82253A88h */ case    3:  		/* mtspr LR, R12 */
		/* 82253A88h case    3:*/		regs.LR = regs.R12;
		/* 82253A88h case    3:*/		return 0x82253A8C;
		  /* 82253A8Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 82253A8Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82253A8Ch case    4:*/		return 0x82253A90;
	}
	return 0x82253A90;
} // Block from 82253A7Ch-82253A90h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82253A90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253A90);
		  /* 82253A90h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 82253A90h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82253A90h case    0:*/		return 0x82253A94;
		  /* 82253A94h */ case    1:  		/* bc 4, CR6_LT, 36 */
		/* 82253A94h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82253AB8;  }
		/* 82253A94h case    1:*/		return 0x82253A98;
	}
	return 0x82253A98;
} // Block from 82253A90h-82253A98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82253A98h
// Function 'r400ArrayToDataElement'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253A98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253A98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253A98);
		  /* 82253A98h */ case    0:  		/* addi R10, R10, -1 */
		/* 82253A98h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82253A98h case    0:*/		return 0x82253A9C;
		  /* 82253A9Ch */ case    1:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 82253A9Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 82253A9Ch case    1:*/		return 0x82253AA0;
		  /* 82253AA0h */ case    2:  		/* stw R10, <#[R3 + 4]> */
		/* 82253AA0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 82253AA0h case    2:*/		return 0x82253AA4;
		  /* 82253AA4h */ case    3:  		/* subf R11, R11, R10 */
		/* 82253AA4h case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82253AA4h case    3:*/		return 0x82253AA8;
		  /* 82253AA8h */ case    4:  		/* add R3, R9, R8 */
		/* 82253AA8h case    4:*/		cpu::op::add<0>(regs,&regs.R3,regs.R9,regs.R8);
		/* 82253AA8h case    4:*/		return 0x82253AAC;
		  /* 82253AACh */ case    5:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82253AACh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82253AACh case    5:*/		return 0x82253AB0;
		  /* 82253AB0h */ case    6:  		/* addi R4, R3, 4 */
		/* 82253AB0h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0x4);
		/* 82253AB0h case    6:*/		return 0x82253AB4;
		  /* 82253AB4h */ case    7:  		/* bl -1843460 */
		/* 82253AB4h case    7:*/		regs.LR = 0x82253AB8; return 0x820919B0;
		/* 82253AB4h case    7:*/		return 0x82253AB8;
	}
	return 0x82253AB8;
} // Block from 82253A98h-82253AB8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82253AB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253AB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253AB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253AB8);
		  /* 82253AB8h */ case    0:  		/* li R3, 1 */
		/* 82253AB8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82253AB8h case    0:*/		return 0x82253ABC;
		  /* 82253ABCh */ case    1:  		/* b -60 */
		/* 82253ABCh case    1:*/		return 0x82253A80;
		/* 82253ABCh case    1:*/		return 0x82253AC0;
	}
	return 0x82253AC0;
} // Block from 82253AB8h-82253AC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82253AC0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253AC0);
		  /* 82253AC0h */ case    0:  		/* mfspr R12, LR */
		/* 82253AC0h case    0:*/		regs.R12 = regs.LR;
		/* 82253AC0h case    0:*/		return 0x82253AC4;
		  /* 82253AC4h */ case    1:  		/* bl -1845352 */
		/* 82253AC4h case    1:*/		regs.LR = 0x82253AC8; return 0x8209125C;
		/* 82253AC4h case    1:*/		return 0x82253AC8;
		  /* 82253AC8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82253AC8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82253AC8h case    2:*/		return 0x82253ACC;
		  /* 82253ACCh */ case    3:  		/* lwz R10, <#[R3 + 4]> */
		/* 82253ACCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 82253ACCh case    3:*/		return 0x82253AD0;
		  /* 82253AD0h */ case    4:  		/* addi R11, R4, 1 */
		/* 82253AD0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x1);
		/* 82253AD0h case    4:*/		return 0x82253AD4;
		  /* 82253AD4h */ case    5:  		/* mr R31, R3 */
		/* 82253AD4h case    5:*/		regs.R31 = regs.R3;
		/* 82253AD4h case    5:*/		return 0x82253AD8;
		  /* 82253AD8h */ case    6:  		/* mr R30, R4 */
		/* 82253AD8h case    6:*/		regs.R30 = regs.R4;
		/* 82253AD8h case    6:*/		return 0x82253ADC;
		  /* 82253ADCh */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 82253ADCh case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82253ADCh case    7:*/		return 0x82253AE0;
		  /* 82253AE0h */ case    8:  		/* bc 4, CR6_GT, 20 */
		/* 82253AE0h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82253AF4;  }
		/* 82253AE0h case    8:*/		return 0x82253AE4;
		  /* 82253AE4h */ case    9:  		/* stw R11, <#[R3 + 4]> */
		/* 82253AE4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82253AE4h case    9:*/		return 0x82253AE8;
		  /* 82253AE8h */ case   10:  		/* b 12 */
		/* 82253AE8h case   10:*/		return 0x82253AF4;
		/* 82253AE8h case   10:*/		return 0x82253AEC;
		  /* 82253AECh */ case   11:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 82253AECh case   11:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 82253AECh case   11:*/		return 0x82253AF0;
		  /* 82253AF0h */ case   12:  		/* stw R11, <#[R31]> */
		/* 82253AF0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82253AF0h case   12:*/		return 0x82253AF4;
	}
	return 0x82253AF4;
} // Block from 82253AC0h-82253AF4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82253AF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253AF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253AF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253AF4);
		  /* 82253AF4h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82253AF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82253AF4h case    0:*/		return 0x82253AF8;
		  /* 82253AF8h */ case    1:  		/* cmplw CR6, R30, R11 */
		/* 82253AF8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82253AF8h case    1:*/		return 0x82253AFC;
		  /* 82253AFCh */ case    2:  		/* bc 4, CR6_LT, -16 */
		/* 82253AFCh case    2:*/		if ( !regs.CR[6].lt ) { return 0x82253AEC;  }
		/* 82253AFCh case    2:*/		return 0x82253B00;
		  /* 82253B00h */ case    3:  		/* rlwinm R4, R11, 2, 0, 29 */
		/* 82253B00h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R11);
		/* 82253B00h case    3:*/		return 0x82253B04;
		  /* 82253B04h */ case    4:  		/* lwz R29, <#[R31 + 8]> */
		/* 82253B04h case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000008) );
		/* 82253B04h case    4:*/		return 0x82253B08;
		  /* 82253B08h */ case    5:  		/* lwz R3, <#[R31 + 12]> */
		/* 82253B08h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 82253B08h case    5:*/		return 0x82253B0C;
		  /* 82253B0Ch */ case    6:  		/* bl -226900 */
		/* 82253B0Ch case    6:*/		regs.LR = 0x82253B10; return 0x8221C4B8;
		/* 82253B0Ch case    6:*/		return 0x82253B10;
		  /* 82253B10h */ case    7:  		/* stw R3, <#[R31 + 8]> */
		/* 82253B10h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 82253B10h case    7:*/		return 0x82253B14;
		  /* 82253B14h */ case    8:  		/* lwz R11, <#[R31 + 4]> */
		/* 82253B14h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82253B14h case    8:*/		return 0x82253B18;
		  /* 82253B18h */ case    9:  		/* mr R4, R29 */
		/* 82253B18h case    9:*/		regs.R4 = regs.R29;
		/* 82253B18h case    9:*/		return 0x82253B1C;
		  /* 82253B1Ch */ case   10:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82253B1Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82253B1Ch case   10:*/		return 0x82253B20;
		  /* 82253B20h */ case   11:  		/* bl -1843568 */
		/* 82253B20h case   11:*/		regs.LR = 0x82253B24; return 0x820919B0;
		/* 82253B20h case   11:*/		return 0x82253B24;
		  /* 82253B24h */ case   12:  		/* mr R4, R29 */
		/* 82253B24h case   12:*/		regs.R4 = regs.R29;
		/* 82253B24h case   12:*/		return 0x82253B28;
		  /* 82253B28h */ case   13:  		/* lwz R3, <#[R31 + 12]> */
		/* 82253B28h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 82253B28h case   13:*/		return 0x82253B2C;
		  /* 82253B2Ch */ case   14:  		/* bl -226540 */
		/* 82253B2Ch case   14:*/		regs.LR = 0x82253B30; return 0x8221C640;
		/* 82253B2Ch case   14:*/		return 0x82253B30;
		  /* 82253B30h */ case   15:  		/* lwz R11, <#[R31 + 8]> */
		/* 82253B30h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82253B30h case   15:*/		return 0x82253B34;
		  /* 82253B34h */ case   16:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 82253B34h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 82253B34h case   16:*/		return 0x82253B38;
		  /* 82253B38h */ case   17:  		/* add R3, R10, R11 */
		/* 82253B38h case   17:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82253B38h case   17:*/		return 0x82253B3C;
		  /* 82253B3Ch */ case   18:  		/* addi R1, R1, 112 */
		/* 82253B3Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82253B3Ch case   18:*/		return 0x82253B40;
		  /* 82253B40h */ case   19:  		/* b -1845396 */
		/* 82253B40h case   19:*/		return 0x820912AC;
		/* 82253B40h case   19:*/		return 0x82253B44;
		  /* 82253B44h */ case   20:  		/* nop */
		/* 82253B44h case   20:*/		cpu::op::nop();
		/* 82253B44h case   20:*/		return 0x82253B48;
	}
	return 0x82253B48;
} // Block from 82253AF4h-82253B48h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82253B48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253B48);
		  /* 82253B48h */ case    0:  		/* mfspr R12, LR */
		/* 82253B48h case    0:*/		regs.R12 = regs.LR;
		/* 82253B48h case    0:*/		return 0x82253B4C;
		  /* 82253B4Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82253B4Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82253B4Ch case    1:*/		return 0x82253B50;
		  /* 82253B50h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82253B50h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82253B50h case    2:*/		return 0x82253B54;
		  /* 82253B54h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82253B54h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82253B54h case    3:*/		return 0x82253B58;
		  /* 82253B58h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82253B58h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82253B58h case    4:*/		return 0x82253B5C;
		  /* 82253B5Ch */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 82253B5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82253B5Ch case    5:*/		return 0x82253B60;
		  /* 82253B60h */ case    6:  		/* mr R31, R3 */
		/* 82253B60h case    6:*/		regs.R31 = regs.R3;
		/* 82253B60h case    6:*/		return 0x82253B64;
		  /* 82253B64h */ case    7:  		/* mr R30, R4 */
		/* 82253B64h case    7:*/		regs.R30 = regs.R4;
		/* 82253B64h case    7:*/		return 0x82253B68;
		  /* 82253B68h */ case    8:  		/* cmplw CR6, R4, R11 */
		/* 82253B68h case    8:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 82253B68h case    8:*/		return 0x82253B6C;
		  /* 82253B6Ch */ case    9:  		/* bc 4, CR6_GT, 8 */
		/* 82253B6Ch case    9:*/		if ( !regs.CR[6].gt ) { return 0x82253B74;  }
		/* 82253B6Ch case    9:*/		return 0x82253B70;
		  /* 82253B70h */ case   10:  		/* stw R4, <#[R3 + 4]> */
		/* 82253B70h case   10:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82253B70h case   10:*/		return 0x82253B74;
	}
	return 0x82253B74;
} // Block from 82253B48h-82253B74h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82253B74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253B74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253B74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253B74);
		  /* 82253B74h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82253B74h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82253B74h case    0:*/		return 0x82253B78;
		  /* 82253B78h */ case    1:  		/* lwz R10, <#[R31]> */
		/* 82253B78h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82253B78h case    1:*/		return 0x82253B7C;
		  /* 82253B7Ch */ case    2:  		/* addi R11, R11, 1 */
		/* 82253B7Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82253B7Ch case    2:*/		return 0x82253B80;
		  /* 82253B80h */ case    3:  		/* stw R11, <#[R31 + 4]> */
		/* 82253B80h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82253B80h case    3:*/		return 0x82253B84;
		  /* 82253B84h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 82253B84h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82253B84h case    4:*/		return 0x82253B88;
		  /* 82253B88h */ case    5:  		/* bc 4, CR6_GT, 16 */
		/* 82253B88h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82253B98;  }
		/* 82253B88h case    5:*/		return 0x82253B8C;
		  /* 82253B8Ch */ case    6:  		/* addi R4, R11, -1 */
		/* 82253B8Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFF);
		/* 82253B8Ch case    6:*/		return 0x82253B90;
		  /* 82253B90h */ case    7:  		/* mr R3, R31 */
		/* 82253B90h case    7:*/		regs.R3 = regs.R31;
		/* 82253B90h case    7:*/		return 0x82253B94;
		  /* 82253B94h */ case    8:  		/* bl -212 */
		/* 82253B94h case    8:*/		regs.LR = 0x82253B98; return 0x82253AC0;
		/* 82253B94h case    8:*/		return 0x82253B98;
	}
	return 0x82253B98;
} // Block from 82253B74h-82253B98h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82253B98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253B98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253B98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253B98);
		  /* 82253B98h */ case    0:  		/* lwz R9, <#[R31 + 4]> */
		/* 82253B98h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 82253B98h case    0:*/		return 0x82253B9C;
		  /* 82253B9Ch */ case    1:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 82253B9Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 82253B9Ch case    1:*/		return 0x82253BA0;
		  /* 82253BA0h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 82253BA0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82253BA0h case    2:*/		return 0x82253BA4;
		  /* 82253BA4h */ case    3:  		/* subf R9, R30, R9 */
		/* 82253BA4h case    3:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R30,regs.R9);
		/* 82253BA4h case    3:*/		return 0x82253BA8;
		  /* 82253BA8h */ case    4:  		/* add R3, R11, R10 */
		/* 82253BA8h case    4:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82253BA8h case    4:*/		return 0x82253BAC;
		  /* 82253BACh */ case    5:  		/* addic. R11, R9, -1 */
		/* 82253BACh case    5:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 82253BACh case    5:*/		return 0x82253BB0;
		  /* 82253BB0h */ case    6:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 82253BB0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 82253BB0h case    6:*/		return 0x82253BB4;
		  /* 82253BB4h */ case    7:  		/* add R10, R10, R3 */
		/* 82253BB4h case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 82253BB4h case    7:*/		return 0x82253BB8;
		  /* 82253BB8h */ case    8:  		/* bc 12, CR0_EQ, 28 */
		/* 82253BB8h case    8:*/		if ( regs.CR[0].eq ) { return 0x82253BD4;  }
		/* 82253BB8h case    8:*/		return 0x82253BBC;
		  /* 82253BBCh */ case    9:  		/* mtspr CTR, R11 */
		/* 82253BBCh case    9:*/		regs.CTR = regs.R11;
		/* 82253BBCh case    9:*/		return 0x82253BC0;
		  /* 82253BC0h */ case   10:  		/* lwz R9, <#[R10 - 4]> */
		/* 82253BC0h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 82253BC0h case   10:*/		return 0x82253BC4;
		  /* 82253BC4h */ case   11:  		/* addi R11, R10, -4 */
		/* 82253BC4h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFC);
		/* 82253BC4h case   11:*/		return 0x82253BC8;
		  /* 82253BC8h */ case   12:  		/* stw R9, <#[R10]> */
		/* 82253BC8h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82253BC8h case   12:*/		return 0x82253BCC;
		  /* 82253BCCh */ case   13:  		/* mr R10, R11 */
		/* 82253BCCh case   13:*/		regs.R10 = regs.R11;
		/* 82253BCCh case   13:*/		return 0x82253BD0;
		  /* 82253BD0h */ case   14:  		/* bc 16, CR0_LT, -16 */
		/* 82253BD0h case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82253BC0;  }
		/* 82253BD0h case   14:*/		return 0x82253BD4;
	}
	return 0x82253BD4;
} // Block from 82253B98h-82253BD4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82253BD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253BD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253BD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253BD4);
		  /* 82253BD4h */ case    0:  		/* li R11, 0 */
		/* 82253BD4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82253BD4h case    0:*/		return 0x82253BD8;
		  /* 82253BD8h */ case    1:  		/* stw R11, <#[R10]> */
		/* 82253BD8h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82253BD8h case    1:*/		return 0x82253BDC;
		  /* 82253BDCh */ case    2:  		/* addi R1, R1, 112 */
		/* 82253BDCh case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82253BDCh case    2:*/		return 0x82253BE0;
		  /* 82253BE0h */ case    3:  		/* lwz R12, <#[R1 - 8]> */
		/* 82253BE0h case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82253BE0h case    3:*/		return 0x82253BE4;
		  /* 82253BE4h */ case    4:  		/* mtspr LR, R12 */
		/* 82253BE4h case    4:*/		regs.LR = regs.R12;
		/* 82253BE4h case    4:*/		return 0x82253BE8;
		  /* 82253BE8h */ case    5:  		/* ld R30, <#[R1 - 24]> */
		/* 82253BE8h case    5:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82253BE8h case    5:*/		return 0x82253BEC;
		  /* 82253BECh */ case    6:  		/* ld R31, <#[R1 - 16]> */
		/* 82253BECh case    6:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82253BECh case    6:*/		return 0x82253BF0;
		  /* 82253BF0h */ case    7:  		/* bclr 20, CR0_LT */
		/* 82253BF0h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82253BF0h case    7:*/		return 0x82253BF4;
	}
	return 0x82253BF4;
} // Block from 82253BD4h-82253BF4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82253BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253BF4);
		  /* 82253BF4h */ case    0:  		/* nop */
		/* 82253BF4h case    0:*/		cpu::op::nop();
		/* 82253BF4h case    0:*/		return 0x82253BF8;
	}
	return 0x82253BF8;
} // Block from 82253BF4h-82253BF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82253BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253BF8);
		  /* 82253BF8h */ case    0:  		/* mfspr R12, LR */
		/* 82253BF8h case    0:*/		regs.R12 = regs.LR;
		/* 82253BF8h case    0:*/		return 0x82253BFC;
		  /* 82253BFCh */ case    1:  		/* bl -1845700 */
		/* 82253BFCh case    1:*/		regs.LR = 0x82253C00; return 0x82091238;
		/* 82253BFCh case    1:*/		return 0x82253C00;
		  /* 82253C00h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82253C00h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82253C00h case    2:*/		return 0x82253C04;
		  /* 82253C04h */ case    3:  		/* lwz R22, <#[R3]> */
		/* 82253C04h case    3:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R3 + 0x00000000) );
		/* 82253C04h case    3:*/		return 0x82253C08;
		  /* 82253C08h */ case    4:  		/* mr R30, R3 */
		/* 82253C08h case    4:*/		regs.R30 = regs.R3;
		/* 82253C08h case    4:*/		return 0x82253C0C;
		  /* 82253C0Ch */ case    5:  		/* lwz R3, <#[R3 + 20]> */
		/* 82253C0Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000014) );
		/* 82253C0Ch case    5:*/		return 0x82253C10;
	}
	return 0x82253C10;
} // Block from 82253BF8h-82253C10h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82253C10h
// Function 'r400ArrayToColorElement'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253C10);
		  /* 82253C10h */ case    0:  		/* rlwinm R11, R22, 1, 0, 30 */
		/* 82253C10h case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R22);
		/* 82253C10h case    0:*/		return 0x82253C14;
		  /* 82253C14h */ case    1:  		/* rlwinm R4, R22, 3, 0, 28 */
		/* 82253C14h case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R4,regs.R22);
		/* 82253C14h case    1:*/		return 0x82253C18;
		  /* 82253C18h */ case    2:  		/* stw R11, <#[R30]> */
		/* 82253C18h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82253C18h case    2:*/		return 0x82253C1C;
		  /* 82253C1Ch */ case    3:  		/* bl -227172 */
		/* 82253C1Ch case    3:*/		regs.LR = 0x82253C20; return 0x8221C4B8;
		/* 82253C1Ch case    3:*/		return 0x82253C20;
		  /* 82253C20h */ case    4:  		/* lwz R11, <#[R30]> */
		/* 82253C20h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82253C20h case    4:*/		return 0x82253C24;
		  /* 82253C24h */ case    5:  		/* li R4, 0 */
		/* 82253C24h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82253C24h case    5:*/		return 0x82253C28;
		  /* 82253C28h */ case    6:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82253C28h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82253C28h case    6:*/		return 0x82253C2C;
		  /* 82253C2Ch */ case    7:  		/* mr R23, R3 */
		/* 82253C2Ch case    7:*/		regs.R23 = regs.R3;
		/* 82253C2Ch case    7:*/		return 0x82253C30;
		  /* 82253C30h */ case    8:  		/* bl -1845488 */
		/* 82253C30h case    8:*/		regs.LR = 0x82253C34; return 0x82091340;
		/* 82253C30h case    8:*/		return 0x82253C34;
		  /* 82253C34h */ case    9:  		/* li R20, 0 */
		/* 82253C34h case    9:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 82253C34h case    9:*/		return 0x82253C38;
		  /* 82253C38h */ case   10:  		/* cmpwi CR6, R22, 0 */
		/* 82253C38h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000000);
		/* 82253C38h case   10:*/		return 0x82253C3C;
		  /* 82253C3Ch */ case   11:  		/* bc 4, CR6_GT, 304 */
		/* 82253C3Ch case   11:*/		if ( !regs.CR[6].gt ) { return 0x82253D6C;  }
		/* 82253C3Ch case   11:*/		return 0x82253C40;
		  /* 82253C40h */ case   12:  		/* rlwinm R11, R22, 2, 0, 29 */
		/* 82253C40h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R22);
		/* 82253C40h case   12:*/		return 0x82253C44;
		  /* 82253C44h */ case   13:  		/* li R26, 0 */
		/* 82253C44h case   13:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82253C44h case   13:*/		return 0x82253C48;
	}
	return 0x82253C48;
} // Block from 82253C10h-82253C48h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82253C48h
// Function 'r400AbgrToColorArray'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253C48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253C48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253C48);
		  /* 82253C48h */ case    0:  		/* add R21, R11, R23 */
		/* 82253C48h case    0:*/		cpu::op::add<0>(regs,&regs.R21,regs.R11,regs.R23);
		/* 82253C48h case    0:*/		return 0x82253C4C;
		  /* 82253C4Ch */ case    1:  		/* lwz R11, <#[R30 + 8]> */
		/* 82253C4Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82253C4Ch case    1:*/		return 0x82253C50;
		  /* 82253C50h */ case    2:  		/* lwzx R25, <#[R26 + R11]> */
		/* 82253C50h case    2:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 82253C50h case    2:*/		return 0x82253C54;
		  /* 82253C54h */ case    3:  		/* cmplwi CR6, R25, 0 */
		/* 82253C54h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82253C54h case    3:*/		return 0x82253C58;
		  /* 82253C58h */ case    4:  		/* bc 12, CR6_EQ, 256 */
		/* 82253C58h case    4:*/		if ( regs.CR[6].eq ) { return 0x82253D58;  }
		/* 82253C58h case    4:*/		return 0x82253C5C;
		  /* 82253C5Ch */ case    5:  		/* lwz R29, <#[R30 + 20]> */
		/* 82253C5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000014) );
		/* 82253C5Ch case    5:*/		return 0x82253C60;
		  /* 82253C60h */ case    6:  		/* li R4, 20 */
		/* 82253C60h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82253C60h case    6:*/		return 0x82253C64;
		  /* 82253C64h */ case    7:  		/* mr R3, R29 */
		/* 82253C64h case    7:*/		regs.R3 = regs.R29;
		/* 82253C64h case    7:*/		return 0x82253C68;
		  /* 82253C68h */ case    8:  		/* bl -227248 */
		/* 82253C68h case    8:*/		regs.LR = 0x82253C6C; return 0x8221C4B8;
		/* 82253C68h case    8:*/		return 0x82253C6C;
		  /* 82253C6Ch */ case    9:  		/* addic. R31, R3, 4 */
		/* 82253C6Ch case    9:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R3,0x4);
		/* 82253C6Ch case    9:*/		return 0x82253C70;
		  /* 82253C70h */ case   10:  		/* stw R29, <#[R3]> */
		/* 82253C70h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82253C70h case   10:*/		return 0x82253C74;
		  /* 82253C74h */ case   11:  		/* bc 12, CR0_EQ, 24 */
		/* 82253C74h case   11:*/		if ( regs.CR[0].eq ) { return 0x82253C8C;  }
		/* 82253C74h case   11:*/		return 0x82253C78;
		  /* 82253C78h */ case   12:  		/* mr R3, R31 */
		/* 82253C78h case   12:*/		regs.R3 = regs.R31;
		/* 82253C78h case   12:*/		return 0x82253C7C;
		  /* 82253C7Ch */ case   13:  		/* lwz R4, <#[R30 + 20]> */
		/* 82253C7Ch case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000014) );
		/* 82253C7Ch case   13:*/		return 0x82253C80;
		  /* 82253C80h */ case   14:  		/* bl -122656 */
		/* 82253C80h case   14:*/		regs.LR = 0x82253C84; return 0x82235D60;
		/* 82253C80h case   14:*/		return 0x82253C84;
		  /* 82253C84h */ case   15:  		/* mr R11, R31 */
		/* 82253C84h case   15:*/		regs.R11 = regs.R31;
		/* 82253C84h case   15:*/		return 0x82253C88;
		  /* 82253C88h */ case   16:  		/* b 8 */
		/* 82253C88h case   16:*/		return 0x82253C90;
		/* 82253C88h case   16:*/		return 0x82253C8C;
	}
	return 0x82253C8C;
} // Block from 82253C48h-82253C8Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 82253C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253C8C);
		  /* 82253C8Ch */ case    0:  		/* li R11, 0 */
		/* 82253C8Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82253C8Ch case    0:*/		return 0x82253C90;
	}
	return 0x82253C90;
} // Block from 82253C8Ch-82253C90h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82253C90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253C90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253C90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253C90);
		  /* 82253C90h */ case    0:  		/* stwx R11, <#[R26 + R23]> */
		/* 82253C90h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + regs.R23 + 0x00000000) );
		/* 82253C90h case    0:*/		return 0x82253C94;
		  /* 82253C94h */ case    1:  		/* li R4, 20 */
		/* 82253C94h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82253C94h case    1:*/		return 0x82253C98;
		  /* 82253C98h */ case    2:  		/* lwz R29, <#[R30 + 20]> */
		/* 82253C98h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000014) );
		/* 82253C98h case    2:*/		return 0x82253C9C;
		  /* 82253C9Ch */ case    3:  		/* mr R3, R29 */
		/* 82253C9Ch case    3:*/		regs.R3 = regs.R29;
		/* 82253C9Ch case    3:*/		return 0x82253CA0;
		  /* 82253CA0h */ case    4:  		/* bl -227304 */
		/* 82253CA0h case    4:*/		regs.LR = 0x82253CA4; return 0x8221C4B8;
		/* 82253CA0h case    4:*/		return 0x82253CA4;
		  /* 82253CA4h */ case    5:  		/* addic. R31, R3, 4 */
		/* 82253CA4h case    5:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R3,0x4);
		/* 82253CA4h case    5:*/		return 0x82253CA8;
		  /* 82253CA8h */ case    6:  		/* stw R29, <#[R3]> */
		/* 82253CA8h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82253CA8h case    6:*/		return 0x82253CAC;
		  /* 82253CACh */ case    7:  		/* bc 12, CR0_EQ, 24 */
		/* 82253CACh case    7:*/		if ( regs.CR[0].eq ) { return 0x82253CC4;  }
		/* 82253CACh case    7:*/		return 0x82253CB0;
	}
	return 0x82253CB0;
} // Block from 82253C90h-82253CB0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82253CB0h
// Function '?r400FloatScale@XGRAPHICS@@YAHMH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253CB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253CB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253CB0);
		  /* 82253CB0h */ case    0:  		/* mr R3, R31 */
		/* 82253CB0h case    0:*/		regs.R3 = regs.R31;
		/* 82253CB0h case    0:*/		return 0x82253CB4;
		  /* 82253CB4h */ case    1:  		/* lwz R4, <#[R30 + 20]> */
		/* 82253CB4h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000014) );
		/* 82253CB4h case    1:*/		return 0x82253CB8;
		  /* 82253CB8h */ case    2:  		/* bl -122712 */
		/* 82253CB8h case    2:*/		regs.LR = 0x82253CBC; return 0x82235D60;
		/* 82253CB8h case    2:*/		return 0x82253CBC;
		  /* 82253CBCh */ case    3:  		/* mr R27, R31 */
		/* 82253CBCh case    3:*/		regs.R27 = regs.R31;
		/* 82253CBCh case    3:*/		return 0x82253CC0;
		  /* 82253CC0h */ case    4:  		/* b 8 */
		/* 82253CC0h case    4:*/		return 0x82253CC8;
		/* 82253CC0h case    4:*/		return 0x82253CC4;
	}
	return 0x82253CC4;
} // Block from 82253CB0h-82253CC4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82253CC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253CC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253CC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253CC4);
		  /* 82253CC4h */ case    0:  		/* li R27, 0 */
		/* 82253CC4h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82253CC4h case    0:*/		return 0x82253CC8;
	}
	return 0x82253CC8;
} // Block from 82253CC4h-82253CC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82253CC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253CC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253CC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253CC8);
		  /* 82253CC8h */ case    0:  		/* stw R27, <#[R21]> */
		/* 82253CC8h case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R21 + 0x00000000) );
		/* 82253CC8h case    0:*/		return 0x82253CCC;
		  /* 82253CCCh */ case    1:  		/* lwz R31, <#[R25 + 4]> */
		/* 82253CCCh case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R25 + 0x00000004) );
		/* 82253CCCh case    1:*/		return 0x82253CD0;
		  /* 82253CD0h */ case    2:  		/* cmpwi CR6, R31, 0 */
		/* 82253CD0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82253CD0h case    2:*/		return 0x82253CD4;
		  /* 82253CD4h */ case    3:  		/* lwzx R24, <#[R26 + R23]> */
		/* 82253CD4h case    3:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R26 + regs.R23 + 0x00000000) );
		/* 82253CD4h case    3:*/		return 0x82253CD8;
		  /* 82253CD8h */ case    4:  		/* bc 12, CR6_EQ, 128 */
		/* 82253CD8h case    4:*/		if ( regs.CR[6].eq ) { return 0x82253D58;  }
		/* 82253CD8h case    4:*/		return 0x82253CDC;
		  /* 82253CDCh */ case    5:  		/* rlwinm R28, R31, 2, 0, 29 */
		/* 82253CDCh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R31);
		/* 82253CDCh case    5:*/		return 0x82253CE0;
		  /* 82253CE0h */ case    6:  		/* lwz R11, <#[R25 + 4]> */
		/* 82253CE0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 82253CE0h case    6:*/		return 0x82253CE4;
		  /* 82253CE4h */ case    7:  		/* addi R31, R31, -1 */
		/* 82253CE4h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82253CE4h case    7:*/		return 0x82253CE8;
		  /* 82253CE8h */ case    8:  		/* addi R28, R28, -4 */
		/* 82253CE8h case    8:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0xFFFFFFFC);
		/* 82253CE8h case    8:*/		return 0x82253CEC;
		  /* 82253CECh */ case    9:  		/* cmplw CR6, R31, R11 */
		/* 82253CECh case    9:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82253CECh case    9:*/		return 0x82253CF0;
		  /* 82253CF0h */ case   10:  		/* bc 4, CR6_LT, 16 */
		/* 82253CF0h case   10:*/		if ( !regs.CR[6].lt ) { return 0x82253D00;  }
		/* 82253CF0h case   10:*/		return 0x82253CF4;
		  /* 82253CF4h */ case   11:  		/* lwz R11, <#[R25 + 8]> */
		/* 82253CF4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 82253CF4h case   11:*/		return 0x82253CF8;
		  /* 82253CF8h */ case   12:  		/* add R3, R11, R28 */
		/* 82253CF8h case   12:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R28);
		/* 82253CF8h case   12:*/		return 0x82253CFC;
		  /* 82253CFCh */ case   13:  		/* b 16 */
		/* 82253CFCh case   13:*/		return 0x82253D0C;
		/* 82253CFCh case   13:*/		return 0x82253D00;
	}
	return 0x82253D00;
} // Block from 82253CC8h-82253D00h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82253D00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253D00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253D00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253D00);
		  /* 82253D00h */ case    0:  		/* mr R4, R31 */
		/* 82253D00h case    0:*/		regs.R4 = regs.R31;
		/* 82253D00h case    0:*/		return 0x82253D04;
		  /* 82253D04h */ case    1:  		/* mr R3, R25 */
		/* 82253D04h case    1:*/		regs.R3 = regs.R25;
		/* 82253D04h case    1:*/		return 0x82253D08;
		  /* 82253D08h */ case    2:  		/* bl -584 */
		/* 82253D08h case    2:*/		regs.LR = 0x82253D0C; return 0x82253AC0;
		/* 82253D08h case    2:*/		return 0x82253D0C;
	}
	return 0x82253D0C;
} // Block from 82253D00h-82253D0Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82253D0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253D0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253D0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253D0C);
		  /* 82253D0Ch */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 82253D0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82253D0Ch case    0:*/		return 0x82253D10;
	}
	return 0x82253D10;
} // Block from 82253D0Ch-82253D10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82253D10h
// Function 'r400ZconstFromFloat'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253D10);
		  /* 82253D10h */ case    0:  		/* lwz R29, <#[R3]> */
		/* 82253D10h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82253D10h case    0:*/		return 0x82253D14;
		  /* 82253D14h */ case    1:  		/* mr R3, R29 */
		/* 82253D14h case    1:*/		regs.R3 = regs.R29;
		/* 82253D14h case    1:*/		return 0x82253D18;
		  /* 82253D18h */ case    2:  		/* mtspr CTR, R11 */
		/* 82253D18h case    2:*/		regs.CTR = regs.R11;
		/* 82253D18h case    2:*/		return 0x82253D1C;
		  /* 82253D1Ch */ case    3:  		/* bcctrl 20, CR0_LT */
		/* 82253D1Ch case    3:*/		if ( 1 ) { regs.LR = 0x82253D20; return (uint32)regs.CTR; }
		/* 82253D1Ch case    3:*/		return 0x82253D20;
		  /* 82253D20h */ case    4:  		/* lwz R11, <#[R30]> */
		/* 82253D20h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82253D20h case    4:*/		return 0x82253D24;
		  /* 82253D24h */ case    5:  		/* addi R11, R11, -1 */
		/* 82253D24h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82253D24h case    5:*/		return 0x82253D28;
		  /* 82253D28h */ case    6:  		/* and R11, R3, R11 */
		/* 82253D28h case    6:*/		cpu::op::and<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 82253D28h case    6:*/		return 0x82253D2C;
		  /* 82253D2Ch */ case    7:  		/* cmplw CR6, R11, R20 */
		/* 82253D2Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R20);
		/* 82253D2Ch case    7:*/		return 0x82253D30;
		  /* 82253D30h */ case    8:  		/* bc 4, CR6_EQ, 16 */
		/* 82253D30h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82253D40;  }
		/* 82253D30h case    8:*/		return 0x82253D34;
		  /* 82253D34h */ case    9:  		/* lwz R4, <#[R24 + 4]> */
		/* 82253D34h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R24 + 0x00000004) );
		/* 82253D34h case    9:*/		return 0x82253D38;
		  /* 82253D38h */ case   10:  		/* mr R3, R24 */
		/* 82253D38h case   10:*/		regs.R3 = regs.R24;
		/* 82253D38h case   10:*/		return 0x82253D3C;
		  /* 82253D3Ch */ case   11:  		/* b 12 */
		/* 82253D3Ch case   11:*/		return 0x82253D48;
		/* 82253D3Ch case   11:*/		return 0x82253D40;
	}
	return 0x82253D40;
} // Block from 82253D10h-82253D40h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82253D40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253D40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253D40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253D40);
		  /* 82253D40h */ case    0:  		/* lwz R4, <#[R27 + 4]> */
		/* 82253D40h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x00000004) );
		/* 82253D40h case    0:*/		return 0x82253D44;
		  /* 82253D44h */ case    1:  		/* mr R3, R27 */
		/* 82253D44h case    1:*/		regs.R3 = regs.R27;
		/* 82253D44h case    1:*/		return 0x82253D48;
	}
	return 0x82253D48;
} // Block from 82253D40h-82253D48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82253D48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253D48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253D48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253D48);
		  /* 82253D48h */ case    0:  		/* bl -648 */
		/* 82253D48h case    0:*/		regs.LR = 0x82253D4C; return 0x82253AC0;
		/* 82253D48h case    0:*/		return 0x82253D4C;
		  /* 82253D4Ch */ case    1:  		/* stw R29, <#[R3]> */
		/* 82253D4Ch case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82253D4Ch case    1:*/		return 0x82253D50;
		  /* 82253D50h */ case    2:  		/* cmpwi CR6, R31, 0 */
		/* 82253D50h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82253D50h case    2:*/		return 0x82253D54;
		  /* 82253D54h */ case    3:  		/* bc 4, CR6_EQ, -116 */
		/* 82253D54h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82253CE0;  }
		/* 82253D54h case    3:*/		return 0x82253D58;
	}
	return 0x82253D58;
} // Block from 82253D48h-82253D58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82253D58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253D58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253D58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253D58);
		  /* 82253D58h */ case    0:  		/* addi R20, R20, 1 */
		/* 82253D58h case    0:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0x1);
		/* 82253D58h case    0:*/		return 0x82253D5C;
		  /* 82253D5Ch */ case    1:  		/* addi R26, R26, 4 */
		/* 82253D5Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 82253D5Ch case    1:*/		return 0x82253D60;
		  /* 82253D60h */ case    2:  		/* addi R21, R21, 4 */
		/* 82253D60h case    2:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x4);
		/* 82253D60h case    2:*/		return 0x82253D64;
		  /* 82253D64h */ case    3:  		/* cmpw CR6, R20, R22 */
		/* 82253D64h case    3:*/		cpu::op::cmpw<6>(regs,regs.R20,regs.R22);
		/* 82253D64h case    3:*/		return 0x82253D68;
		  /* 82253D68h */ case    4:  		/* bc 12, CR6_LT, -284 */
		/* 82253D68h case    4:*/		if ( regs.CR[6].lt ) { return 0x82253C4C;  }
		/* 82253D68h case    4:*/		return 0x82253D6C;
	}
	return 0x82253D6C;
} // Block from 82253D58h-82253D6Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82253D6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253D6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253D6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253D6C);
		  /* 82253D6Ch */ case    0:  		/* stw R23, <#[R30 + 8]> */
		/* 82253D6Ch case    0:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R30 + 0x00000008) );
		/* 82253D6Ch case    0:*/		return 0x82253D70;
		  /* 82253D70h */ case    1:  		/* addi R1, R1, 192 */
		/* 82253D70h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 82253D70h case    1:*/		return 0x82253D74;
		  /* 82253D74h */ case    2:  		/* b -1845996 */
		/* 82253D74h case    2:*/		return 0x82091288;
		/* 82253D74h case    2:*/		return 0x82253D78;
	}
	return 0x82253D78;
} // Block from 82253D6Ch-82253D78h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82253D78h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253D78);
		  /* 82253D78h */ case    0:  		/* mfspr R12, LR */
		/* 82253D78h case    0:*/		regs.R12 = regs.LR;
		/* 82253D78h case    0:*/		return 0x82253D7C;
		  /* 82253D7Ch */ case    1:  		/* bl -1846060 */
		/* 82253D7Ch case    1:*/		regs.LR = 0x82253D80; return 0x82091250;
		/* 82253D7Ch case    1:*/		return 0x82253D80;
		  /* 82253D80h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82253D80h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82253D80h case    2:*/		return 0x82253D84;
		  /* 82253D84h */ case    3:  		/* lwz R11, <#[R3 + 16]> */
		/* 82253D84h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82253D84h case    3:*/		return 0x82253D88;
		  /* 82253D88h */ case    4:  		/* mr R27, R3 */
		/* 82253D88h case    4:*/		regs.R27 = regs.R3;
		/* 82253D88h case    4:*/		return 0x82253D8C;
		  /* 82253D8Ch */ case    5:  		/* mr R3, R4 */
		/* 82253D8Ch case    5:*/		regs.R3 = regs.R4;
		/* 82253D8Ch case    5:*/		return 0x82253D90;
		  /* 82253D90h */ case    6:  		/* mr R26, R4 */
		/* 82253D90h case    6:*/		regs.R26 = regs.R4;
		/* 82253D90h case    6:*/		return 0x82253D94;
		  /* 82253D94h */ case    7:  		/* mtspr CTR, R11 */
		/* 82253D94h case    7:*/		regs.CTR = regs.R11;
		/* 82253D94h case    7:*/		return 0x82253D98;
		  /* 82253D98h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 82253D98h case    8:*/		if ( 1 ) { regs.LR = 0x82253D9C; return (uint32)regs.CTR; }
		/* 82253D98h case    8:*/		return 0x82253D9C;
		  /* 82253D9Ch */ case    9:  		/* lwz R11, <#[R27]> */
		/* 82253D9Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82253D9Ch case    9:*/		return 0x82253DA0;
		  /* 82253DA0h */ case   10:  		/* lwz R10, <#[R27 + 8]> */
		/* 82253DA0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000008) );
		/* 82253DA0h case   10:*/		return 0x82253DA4;
		  /* 82253DA4h */ case   11:  		/* addi R11, R11, -1 */
		/* 82253DA4h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82253DA4h case   11:*/		return 0x82253DA8;
		  /* 82253DA8h */ case   12:  		/* and R11, R11, R3 */
		/* 82253DA8h case   12:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82253DA8h case   12:*/		return 0x82253DAC;
		  /* 82253DACh */ case   13:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82253DACh case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82253DACh case   13:*/		return 0x82253DB0;
	}
	return 0x82253DB0;
} // Block from 82253D78h-82253DB0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82253DB0h
// Function 'r400FloatToColorInt'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253DB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253DB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253DB0);
		  /* 82253DB0h */ case    0:  		/* lwzx R31, <#[R11 + R10]> */
		/* 82253DB0h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82253DB0h case    0:*/		return 0x82253DB4;
		  /* 82253DB4h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 82253DB4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82253DB4h case    1:*/		return 0x82253DB8;
		  /* 82253DB8h */ case    2:  		/* bc 12, CR6_EQ, 108 */
		/* 82253DB8h case    2:*/		if ( regs.CR[6].eq ) { return 0x82253E24;  }
		/* 82253DB8h case    2:*/		return 0x82253DBC;
		  /* 82253DBCh */ case    3:  		/* lwz R11, <#[R31 + 4]> */
		/* 82253DBCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82253DBCh case    3:*/		return 0x82253DC0;
		  /* 82253DC0h */ case    4:  		/* li R30, 0 */
		/* 82253DC0h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82253DC0h case    4:*/		return 0x82253DC4;
		  /* 82253DC4h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82253DC4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82253DC4h case    5:*/		return 0x82253DC8;
		  /* 82253DC8h */ case    6:  		/* bc 12, CR6_EQ, 92 */
		/* 82253DC8h case    6:*/		if ( regs.CR[6].eq ) { return 0x82253E24;  }
		/* 82253DC8h case    6:*/		return 0x82253DCC;
		  /* 82253DCCh */ case    7:  		/* li R28, 0 */
		/* 82253DCCh case    7:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82253DCCh case    7:*/		return 0x82253DD0;
		  /* 82253DD0h */ case    8:  		/* cmplw CR6, R30, R11 */
		/* 82253DD0h case    8:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82253DD0h case    8:*/		return 0x82253DD4;
		  /* 82253DD4h */ case    9:  		/* bc 4, CR6_LT, 16 */
		/* 82253DD4h case    9:*/		if ( !regs.CR[6].lt ) { return 0x82253DE4;  }
		/* 82253DD4h case    9:*/		return 0x82253DD8;
		  /* 82253DD8h */ case   10:  		/* lwz R11, <#[R31 + 8]> */
		/* 82253DD8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82253DD8h case   10:*/		return 0x82253DDC;
		  /* 82253DDCh */ case   11:  		/* add R3, R11, R28 */
		/* 82253DDCh case   11:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R28);
		/* 82253DDCh case   11:*/		return 0x82253DE0;
		  /* 82253DE0h */ case   12:  		/* b 16 */
		/* 82253DE0h case   12:*/		return 0x82253DF0;
		/* 82253DE0h case   12:*/		return 0x82253DE4;
	}
	return 0x82253DE4;
} // Block from 82253DB0h-82253DE4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82253DE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253DE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253DE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253DE4);
		  /* 82253DE4h */ case    0:  		/* mr R4, R30 */
		/* 82253DE4h case    0:*/		regs.R4 = regs.R30;
		/* 82253DE4h case    0:*/		return 0x82253DE8;
		  /* 82253DE8h */ case    1:  		/* mr R3, R31 */
		/* 82253DE8h case    1:*/		regs.R3 = regs.R31;
		/* 82253DE8h case    1:*/		return 0x82253DEC;
		  /* 82253DECh */ case    2:  		/* bl -812 */
		/* 82253DECh case    2:*/		regs.LR = 0x82253DF0; return 0x82253AC0;
		/* 82253DECh case    2:*/		return 0x82253DF0;
	}
	return 0x82253DF0;
} // Block from 82253DE4h-82253DF0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82253DF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253DF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253DF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253DF0);
		  /* 82253DF0h */ case    0:  		/* lwz R11, <#[R27 + 12]> */
		/* 82253DF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 82253DF0h case    0:*/		return 0x82253DF4;
		  /* 82253DF4h */ case    1:  		/* mr R4, R26 */
		/* 82253DF4h case    1:*/		regs.R4 = regs.R26;
		/* 82253DF4h case    1:*/		return 0x82253DF8;
		  /* 82253DF8h */ case    2:  		/* lwz R29, <#[R3]> */
		/* 82253DF8h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82253DF8h case    2:*/		return 0x82253DFC;
		  /* 82253DFCh */ case    3:  		/* mr R3, R29 */
		/* 82253DFCh case    3:*/		regs.R3 = regs.R29;
		/* 82253DFCh case    3:*/		return 0x82253E00;
		  /* 82253E00h */ case    4:  		/* mtspr CTR, R11 */
		/* 82253E00h case    4:*/		regs.CTR = regs.R11;
		/* 82253E00h case    4:*/		return 0x82253E04;
		  /* 82253E04h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 82253E04h case    5:*/		if ( 1 ) { regs.LR = 0x82253E08; return (uint32)regs.CTR; }
		/* 82253E04h case    5:*/		return 0x82253E08;
		  /* 82253E08h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 82253E08h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82253E08h case    6:*/		return 0x82253E0C;
		  /* 82253E0Ch */ case    7:  		/* bc 12, CR0_EQ, 36 */
		/* 82253E0Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x82253E30;  }
		/* 82253E0Ch case    7:*/		return 0x82253E10;
		  /* 82253E10h */ case    8:  		/* lwz R11, <#[R31 + 4]> */
		/* 82253E10h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82253E10h case    8:*/		return 0x82253E14;
		  /* 82253E14h */ case    9:  		/* addi R30, R30, 1 */
		/* 82253E14h case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82253E14h case    9:*/		return 0x82253E18;
		  /* 82253E18h */ case   10:  		/* addi R28, R28, 4 */
		/* 82253E18h case   10:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82253E18h case   10:*/		return 0x82253E1C;
		  /* 82253E1Ch */ case   11:  		/* cmplw CR6, R30, R11 */
		/* 82253E1Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82253E1Ch case   11:*/		return 0x82253E20;
		  /* 82253E20h */ case   12:  		/* bc 12, CR6_LT, -72 */
		/* 82253E20h case   12:*/		if ( regs.CR[6].lt ) { return 0x82253DD8;  }
		/* 82253E20h case   12:*/		return 0x82253E24;
	}
	return 0x82253E24;
} // Block from 82253DF0h-82253E24h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82253E24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253E24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253E24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253E24);
		  /* 82253E24h */ case    0:  		/* li R3, 0 */
		/* 82253E24h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82253E24h case    0:*/		return 0x82253E28;
		  /* 82253E28h */ case    1:  		/* addi R1, R1, 144 */
		/* 82253E28h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82253E28h case    1:*/		return 0x82253E2C;
		  /* 82253E2Ch */ case    2:  		/* b -1846156 */
		/* 82253E2Ch case    2:*/		return 0x820912A0;
		/* 82253E2Ch case    2:*/		return 0x82253E30;
	}
	return 0x82253E30;
} // Block from 82253E24h-82253E30h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82253E30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253E30);
		  /* 82253E30h */ case    0:  		/* mr R3, R29 */
		/* 82253E30h case    0:*/		regs.R3 = regs.R29;
		/* 82253E30h case    0:*/		return 0x82253E34;
		  /* 82253E34h */ case    1:  		/* b -12 */
		/* 82253E34h case    1:*/		return 0x82253E28;
		/* 82253E34h case    1:*/		return 0x82253E38;
	}
	return 0x82253E38;
} // Block from 82253E30h-82253E38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82253E38h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253E38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253E38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253E38);
		  /* 82253E38h */ case    0:  		/* mfspr R12, LR */
		/* 82253E38h case    0:*/		regs.R12 = regs.LR;
		/* 82253E38h case    0:*/		return 0x82253E3C;
		  /* 82253E3Ch */ case    1:  		/* bl -1846248 */
		/* 82253E3Ch case    1:*/		regs.LR = 0x82253E40; return 0x82091254;
		/* 82253E3Ch case    1:*/		return 0x82253E40;
		  /* 82253E40h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82253E40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82253E40h case    2:*/		return 0x82253E44;
		  /* 82253E44h */ case    3:  		/* lwz R11, <#[R3 + 16]> */
		/* 82253E44h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82253E44h case    3:*/		return 0x82253E48;
		  /* 82253E48h */ case    4:  		/* mr R31, R3 */
		/* 82253E48h case    4:*/		regs.R31 = regs.R3;
		/* 82253E48h case    4:*/		return 0x82253E4C;
		  /* 82253E4Ch */ case    5:  		/* mr R3, R4 */
		/* 82253E4Ch case    5:*/		regs.R3 = regs.R4;
		/* 82253E4Ch case    5:*/		return 0x82253E50;
		  /* 82253E50h */ case    6:  		/* mr R28, R4 */
		/* 82253E50h case    6:*/		regs.R28 = regs.R4;
		/* 82253E50h case    6:*/		return 0x82253E54;
		  /* 82253E54h */ case    7:  		/* mtspr CTR, R11 */
		/* 82253E54h case    7:*/		regs.CTR = regs.R11;
		/* 82253E54h case    7:*/		return 0x82253E58;
		  /* 82253E58h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 82253E58h case    8:*/		if ( 1 ) { regs.LR = 0x82253E5C; return (uint32)regs.CTR; }
		/* 82253E58h case    8:*/		return 0x82253E5C;
		  /* 82253E5Ch */ case    9:  		/* lwz R11, <#[R31]> */
		/* 82253E5Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82253E5Ch case    9:*/		return 0x82253E60;
		  /* 82253E60h */ case   10:  		/* lwz R10, <#[R31 + 8]> */
		/* 82253E60h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82253E60h case   10:*/		return 0x82253E64;
		  /* 82253E64h */ case   11:  		/* addi R11, R11, -1 */
		/* 82253E64h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82253E64h case   11:*/		return 0x82253E68;
		  /* 82253E68h */ case   12:  		/* and R11, R11, R3 */
		/* 82253E68h case   12:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82253E68h case   12:*/		return 0x82253E6C;
		  /* 82253E6Ch */ case   13:  		/* rlwinm R29, R11, 2, 0, 29 */
		/* 82253E6Ch case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R11);
		/* 82253E6Ch case   13:*/		return 0x82253E70;
		  /* 82253E70h */ case   14:  		/* lwzx R11, <#[R10 + R29]> */
		/* 82253E70h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 82253E70h case   14:*/		return 0x82253E74;
		  /* 82253E74h */ case   15:  		/* cmpwi CR6, R11, 0 */
		/* 82253E74h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82253E74h case   15:*/		return 0x82253E78;
		  /* 82253E78h */ case   16:  		/* bc 4, CR6_EQ, 60 */
		/* 82253E78h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82253EB4;  }
		/* 82253E78h case   16:*/		return 0x82253E7C;
		  /* 82253E7Ch */ case   17:  		/* lwz R27, <#[R31 + 20]> */
		/* 82253E7Ch case   17:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R31 + 0x00000014) );
		/* 82253E7Ch case   17:*/		return 0x82253E80;
		  /* 82253E80h */ case   18:  		/* li R4, 20 */
		/* 82253E80h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82253E80h case   18:*/		return 0x82253E84;
		  /* 82253E84h */ case   19:  		/* mr R3, R27 */
		/* 82253E84h case   19:*/		regs.R3 = regs.R27;
		/* 82253E84h case   19:*/		return 0x82253E88;
		  /* 82253E88h */ case   20:  		/* bl -227792 */
		/* 82253E88h case   20:*/		regs.LR = 0x82253E8C; return 0x8221C4B8;
		/* 82253E88h case   20:*/		return 0x82253E8C;
		  /* 82253E8Ch */ case   21:  		/* addic. R30, R3, 4 */
		/* 82253E8Ch case   21:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 82253E8Ch case   21:*/		return 0x82253E90;
		  /* 82253E90h */ case   22:  		/* stw R27, <#[R3]> */
		/* 82253E90h case   22:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 82253E90h case   22:*/		return 0x82253E94;
		  /* 82253E94h */ case   23:  		/* bc 12, CR0_EQ, 20 */
		/* 82253E94h case   23:*/		if ( regs.CR[0].eq ) { return 0x82253EA8;  }
		/* 82253E94h case   23:*/		return 0x82253E98;
		  /* 82253E98h */ case   24:  		/* mr R3, R30 */
		/* 82253E98h case   24:*/		regs.R3 = regs.R30;
		/* 82253E98h case   24:*/		return 0x82253E9C;
		  /* 82253E9Ch */ case   25:  		/* lwz R4, <#[R31 + 20]> */
		/* 82253E9Ch case   25:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000014) );
		/* 82253E9Ch case   25:*/		return 0x82253EA0;
		  /* 82253EA0h */ case   26:  		/* bl -123200 */
		/* 82253EA0h case   26:*/		regs.LR = 0x82253EA4; return 0x82235D60;
		/* 82253EA0h case   26:*/		return 0x82253EA4;
		  /* 82253EA4h */ case   27:  		/* b 8 */
		/* 82253EA4h case   27:*/		return 0x82253EAC;
		/* 82253EA4h case   27:*/		return 0x82253EA8;
	}
	return 0x82253EA8;
} // Block from 82253E38h-82253EA8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82253EA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253EA8);
		  /* 82253EA8h */ case    0:  		/* li R30, 0 */
		/* 82253EA8h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82253EA8h case    0:*/		return 0x82253EAC;
	}
	return 0x82253EAC;
} // Block from 82253EA8h-82253EACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82253EACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253EAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253EAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253EAC);
		  /* 82253EACh */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82253EACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82253EACh case    0:*/		return 0x82253EB0;
		  /* 82253EB0h */ case    1:  		/* stwx R30, <#[R11 + R29]> */
		/* 82253EB0h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82253EB0h case    1:*/		return 0x82253EB4;
	}
	return 0x82253EB4;
} // Block from 82253EACh-82253EB4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82253EB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253EB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253EB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253EB4);
		  /* 82253EB4h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82253EB4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82253EB4h case    0:*/		return 0x82253EB8;
		  /* 82253EB8h */ case    1:  		/* li R4, 0 */
		/* 82253EB8h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82253EB8h case    1:*/		return 0x82253EBC;
		  /* 82253EBCh */ case    2:  		/* lwzx R30, <#[R11 + R29]> */
		/* 82253EBCh case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82253EBCh case    2:*/		return 0x82253EC0;
		  /* 82253EC0h */ case    3:  		/* mr R3, R30 */
		/* 82253EC0h case    3:*/		regs.R3 = regs.R30;
		/* 82253EC0h case    3:*/		return 0x82253EC4;
		  /* 82253EC4h */ case    4:  		/* bl -892 */
		/* 82253EC4h case    4:*/		regs.LR = 0x82253EC8; return 0x82253B48;
		/* 82253EC4h case    4:*/		return 0x82253EC8;
		  /* 82253EC8h */ case    5:  		/* stw R28, <#[R3]> */
		/* 82253EC8h case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 82253EC8h case    5:*/		return 0x82253ECC;
		  /* 82253ECCh */ case    6:  		/* lwz R11, <#[R30 + 4]> */
		/* 82253ECCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82253ECCh case    6:*/		return 0x82253ED0;
		  /* 82253ED0h */ case    7:  		/* lwz R10, <#[R31]> */
		/* 82253ED0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82253ED0h case    7:*/		return 0x82253ED4;
		  /* 82253ED4h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 82253ED4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82253ED4h case    8:*/		return 0x82253ED8;
		  /* 82253ED8h */ case    9:  		/* bc 4, CR6_GT, 12 */
		/* 82253ED8h case    9:*/		if ( !regs.CR[6].gt ) { return 0x82253EE4;  }
		/* 82253ED8h case    9:*/		return 0x82253EDC;
		  /* 82253EDCh */ case   10:  		/* mr R3, R31 */
		/* 82253EDCh case   10:*/		regs.R3 = regs.R31;
		/* 82253EDCh case   10:*/		return 0x82253EE0;
		  /* 82253EE0h */ case   11:  		/* bl -744 */
		/* 82253EE0h case   11:*/		regs.LR = 0x82253EE4; return 0x82253BF8;
		/* 82253EE0h case   11:*/		return 0x82253EE4;
	}
	return 0x82253EE4;
} // Block from 82253EB4h-82253EE4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82253EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253EE4);
		  /* 82253EE4h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82253EE4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82253EE4h case    0:*/		return 0x82253EE8;
		  /* 82253EE8h */ case    1:  		/* addi R11, R11, 1 */
		/* 82253EE8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82253EE8h case    1:*/		return 0x82253EEC;
		  /* 82253EECh */ case    2:  		/* stw R11, <#[R31 + 4]> */
		/* 82253EECh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82253EECh case    2:*/		return 0x82253EF0;
		  /* 82253EF0h */ case    3:  		/* addi R1, R1, 128 */
		/* 82253EF0h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82253EF0h case    3:*/		return 0x82253EF4;
		  /* 82253EF4h */ case    4:  		/* b -1846352 */
		/* 82253EF4h case    4:*/		return 0x820912A4;
		/* 82253EF4h case    4:*/		return 0x82253EF8;
	}
	return 0x82253EF8;
} // Block from 82253EE4h-82253EF8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82253EF8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253EF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253EF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253EF8);
		  /* 82253EF8h */ case    0:  		/* mfspr R12, LR */
		/* 82253EF8h case    0:*/		regs.R12 = regs.LR;
		/* 82253EF8h case    0:*/		return 0x82253EFC;
		  /* 82253EFCh */ case    1:  		/* bl -1846440 */
		/* 82253EFCh case    1:*/		regs.LR = 0x82253F00; return 0x82091254;
		/* 82253EFCh case    1:*/		return 0x82253F00;
		  /* 82253F00h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82253F00h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82253F00h case    2:*/		return 0x82253F04;
		  /* 82253F04h */ case    3:  		/* lwz R11, <#[R3 + 16]> */
		/* 82253F04h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82253F04h case    3:*/		return 0x82253F08;
		  /* 82253F08h */ case    4:  		/* mr R28, R3 */
		/* 82253F08h case    4:*/		regs.R28 = regs.R3;
		/* 82253F08h case    4:*/		return 0x82253F0C;
		  /* 82253F0Ch */ case    5:  		/* mr R3, R4 */
		/* 82253F0Ch case    5:*/		regs.R3 = regs.R4;
		/* 82253F0Ch case    5:*/		return 0x82253F10;
		  /* 82253F10h */ case    6:  		/* mr R27, R4 */
		/* 82253F10h case    6:*/		regs.R27 = regs.R4;
		/* 82253F10h case    6:*/		return 0x82253F14;
		  /* 82253F14h */ case    7:  		/* mtspr CTR, R11 */
		/* 82253F14h case    7:*/		regs.CTR = regs.R11;
		/* 82253F14h case    7:*/		return 0x82253F18;
		  /* 82253F18h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 82253F18h case    8:*/		if ( 1 ) { regs.LR = 0x82253F1C; return (uint32)regs.CTR; }
		/* 82253F18h case    8:*/		return 0x82253F1C;
		  /* 82253F1Ch */ case    9:  		/* lwz R11, <#[R28]> */
		/* 82253F1Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82253F1Ch case    9:*/		return 0x82253F20;
		  /* 82253F20h */ case   10:  		/* lwz R10, <#[R28 + 8]> */
		/* 82253F20h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 82253F20h case   10:*/		return 0x82253F24;
		  /* 82253F24h */ case   11:  		/* addi R11, R11, -1 */
		/* 82253F24h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82253F24h case   11:*/		return 0x82253F28;
		  /* 82253F28h */ case   12:  		/* and R11, R11, R3 */
		/* 82253F28h case   12:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82253F28h case   12:*/		return 0x82253F2C;
		  /* 82253F2Ch */ case   13:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82253F2Ch case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82253F2Ch case   13:*/		return 0x82253F30;
		  /* 82253F30h */ case   14:  		/* lwzx R31, <#[R11 + R10]> */
		/* 82253F30h case   14:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82253F30h case   14:*/		return 0x82253F34;
		  /* 82253F34h */ case   15:  		/* cmplwi CR6, R31, 0 */
		/* 82253F34h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82253F34h case   15:*/		return 0x82253F38;
		  /* 82253F38h */ case   16:  		/* bc 12, CR6_EQ, 156 */
		/* 82253F38h case   16:*/		if ( regs.CR[6].eq ) { return 0x82253FD4;  }
		/* 82253F38h case   16:*/		return 0x82253F3C;
		  /* 82253F3Ch */ case   17:  		/* lwz R11, <#[R31 + 4]> */
		/* 82253F3Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82253F3Ch case   17:*/		return 0x82253F40;
		  /* 82253F40h */ case   18:  		/* li R30, 0 */
		/* 82253F40h case   18:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82253F40h case   18:*/		return 0x82253F44;
		  /* 82253F44h */ case   19:  		/* cmplwi CR6, R11, 0 */
		/* 82253F44h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82253F44h case   19:*/		return 0x82253F48;
		  /* 82253F48h */ case   20:  		/* bc 4, CR6_GT, 140 */
		/* 82253F48h case   20:*/		if ( !regs.CR[6].gt ) { return 0x82253FD4;  }
		/* 82253F48h case   20:*/		return 0x82253F4C;
		  /* 82253F4Ch */ case   21:  		/* li R29, 0 */
		/* 82253F4Ch case   21:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82253F4Ch case   21:*/		return 0x82253F50;
		  /* 82253F50h */ case   22:  		/* lwz R11, <#[R31 + 4]> */
		/* 82253F50h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82253F50h case   22:*/		return 0x82253F54;
		  /* 82253F54h */ case   23:  		/* cmplw CR6, R30, R11 */
		/* 82253F54h case   23:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82253F54h case   23:*/		return 0x82253F58;
		  /* 82253F58h */ case   24:  		/* bc 4, CR6_LT, 16 */
		/* 82253F58h case   24:*/		if ( !regs.CR[6].lt ) { return 0x82253F68;  }
		/* 82253F58h case   24:*/		return 0x82253F5C;
		  /* 82253F5Ch */ case   25:  		/* lwz R11, <#[R31 + 8]> */
		/* 82253F5Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82253F5Ch case   25:*/		return 0x82253F60;
		  /* 82253F60h */ case   26:  		/* add R3, R11, R29 */
		/* 82253F60h case   26:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 82253F60h case   26:*/		return 0x82253F64;
		  /* 82253F64h */ case   27:  		/* b 16 */
		/* 82253F64h case   27:*/		return 0x82253F74;
		/* 82253F64h case   27:*/		return 0x82253F68;
	}
	return 0x82253F68;
} // Block from 82253EF8h-82253F68h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82253F68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253F68);
		  /* 82253F68h */ case    0:  		/* mr R4, R30 */
		/* 82253F68h case    0:*/		regs.R4 = regs.R30;
		/* 82253F68h case    0:*/		return 0x82253F6C;
		  /* 82253F6Ch */ case    1:  		/* mr R3, R31 */
		/* 82253F6Ch case    1:*/		regs.R3 = regs.R31;
		/* 82253F6Ch case    1:*/		return 0x82253F70;
		  /* 82253F70h */ case    2:  		/* bl -1200 */
		/* 82253F70h case    2:*/		regs.LR = 0x82253F74; return 0x82253AC0;
		/* 82253F70h case    2:*/		return 0x82253F74;
	}
	return 0x82253F74;
} // Block from 82253F68h-82253F74h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82253F74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253F74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253F74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253F74);
		  /* 82253F74h */ case    0:  		/* lwz R11, <#[R28 + 12]> */
		/* 82253F74h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000000C) );
		/* 82253F74h case    0:*/		return 0x82253F78;
		  /* 82253F78h */ case    1:  		/* mr R4, R27 */
		/* 82253F78h case    1:*/		regs.R4 = regs.R27;
		/* 82253F78h case    1:*/		return 0x82253F7C;
		  /* 82253F7Ch */ case    2:  		/* lwz R3, <#[R3]> */
		/* 82253F7Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 82253F7Ch case    2:*/		return 0x82253F80;
		  /* 82253F80h */ case    3:  		/* mtspr CTR, R11 */
		/* 82253F80h case    3:*/		regs.CTR = regs.R11;
		/* 82253F80h case    3:*/		return 0x82253F84;
		  /* 82253F84h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 82253F84h case    4:*/		if ( 1 ) { regs.LR = 0x82253F88; return (uint32)regs.CTR; }
		/* 82253F84h case    4:*/		return 0x82253F88;
		  /* 82253F88h */ case    5:  		/* lwz R11, <#[R31 + 4]> */
		/* 82253F88h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82253F88h case    5:*/		return 0x82253F8C;
		  /* 82253F8Ch */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 82253F8Ch case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82253F8Ch case    6:*/		return 0x82253F90;
		  /* 82253F90h */ case    7:  		/* bc 12, CR0_EQ, 24 */
		/* 82253F90h case    7:*/		if ( regs.CR[0].eq ) { return 0x82253FA8;  }
		/* 82253F90h case    7:*/		return 0x82253F94;
		  /* 82253F94h */ case    8:  		/* addi R30, R30, 1 */
		/* 82253F94h case    8:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82253F94h case    8:*/		return 0x82253F98;
		  /* 82253F98h */ case    9:  		/* addi R29, R29, 4 */
		/* 82253F98h case    9:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82253F98h case    9:*/		return 0x82253F9C;
		  /* 82253F9Ch */ case   10:  		/* cmplw CR6, R30, R11 */
		/* 82253F9Ch case   10:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82253F9Ch case   10:*/		return 0x82253FA0;
		  /* 82253FA0h */ case   11:  		/* bc 12, CR6_LT, -80 */
		/* 82253FA0h case   11:*/		if ( regs.CR[6].lt ) { return 0x82253F50;  }
		/* 82253FA0h case   11:*/		return 0x82253FA4;
		  /* 82253FA4h */ case   12:  		/* b 48 */
		/* 82253FA4h case   12:*/		return 0x82253FD4;
		/* 82253FA4h case   12:*/		return 0x82253FA8;
	}
	return 0x82253FA8;
} // Block from 82253F74h-82253FA8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82253FA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253FA8);
		  /* 82253FA8h */ case    0:  		/* cmplw CR6, R30, R11 */
		/* 82253FA8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82253FA8h case    0:*/		return 0x82253FAC;
		  /* 82253FACh */ case    1:  		/* bc 4, CR6_LT, 40 */
		/* 82253FACh case    1:*/		if ( !regs.CR[6].lt ) { return 0x82253FD4;  }
		/* 82253FACh case    1:*/		return 0x82253FB0;
		  /* 82253FB0h */ case    2:  		/* addi R11, R11, -1 */
		/* 82253FB0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82253FB0h case    2:*/		return 0x82253FB4;
		  /* 82253FB4h */ case    3:  		/* lwz R9, <#[R31 + 8]> */
		/* 82253FB4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82253FB4h case    3:*/		return 0x82253FB8;
		  /* 82253FB8h */ case    4:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 82253FB8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 82253FB8h case    4:*/		return 0x82253FBC;
		  /* 82253FBCh */ case    5:  		/* stw R11, <#[R31 + 4]> */
		/* 82253FBCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82253FBCh case    5:*/		return 0x82253FC0;
		  /* 82253FC0h */ case    6:  		/* subf R11, R30, R11 */
		/* 82253FC0h case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 82253FC0h case    6:*/		return 0x82253FC4;
		  /* 82253FC4h */ case    7:  		/* add R3, R10, R9 */
		/* 82253FC4h case    7:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R9);
		/* 82253FC4h case    7:*/		return 0x82253FC8;
		  /* 82253FC8h */ case    8:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82253FC8h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82253FC8h case    8:*/		return 0x82253FCC;
		  /* 82253FCCh */ case    9:  		/* addi R4, R3, 4 */
		/* 82253FCCh case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0x4);
		/* 82253FCCh case    9:*/		return 0x82253FD0;
		  /* 82253FD0h */ case   10:  		/* bl -1844768 */
		/* 82253FD0h case   10:*/		regs.LR = 0x82253FD4; return 0x820919B0;
		/* 82253FD0h case   10:*/		return 0x82253FD4;
	}
	return 0x82253FD4;
} // Block from 82253FA8h-82253FD4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82253FD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253FD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253FD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253FD4);
		  /* 82253FD4h */ case    0:  		/* addi R1, R1, 128 */
		/* 82253FD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82253FD4h case    0:*/		return 0x82253FD8;
		  /* 82253FD8h */ case    1:  		/* b -1846580 */
		/* 82253FD8h case    1:*/		return 0x820912A4;
		/* 82253FD8h case    1:*/		return 0x82253FDC;
		  /* 82253FDCh */ case    2:  		/* nop */
		/* 82253FDCh case    2:*/		cpu::op::nop();
		/* 82253FDCh case    2:*/		return 0x82253FE0;
	}
	return 0x82253FE0;
} // Block from 82253FD4h-82253FE0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82253FE0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82253FE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82253FE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82253FE0);
		  /* 82253FE0h */ case    0:  		/* mfspr R12, LR */
		/* 82253FE0h case    0:*/		regs.R12 = regs.LR;
		/* 82253FE0h case    0:*/		return 0x82253FE4;
		  /* 82253FE4h */ case    1:  		/* bl -1846664 */
		/* 82253FE4h case    1:*/		regs.LR = 0x82253FE8; return 0x8209125C;
		/* 82253FE4h case    1:*/		return 0x82253FE8;
		  /* 82253FE8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82253FE8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82253FE8h case    2:*/		return 0x82253FEC;
		  /* 82253FECh */ case    3:  		/* lwz R11, <#[R3]> */
		/* 82253FECh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82253FECh case    3:*/		return 0x82253FF0;
		  /* 82253FF0h */ case    4:  		/* mr R30, R3 */
		/* 82253FF0h case    4:*/		regs.R30 = regs.R3;
		/* 82253FF0h case    4:*/		return 0x82253FF4;
		  /* 82253FF4h */ case    5:  		/* li R29, 0 */
		/* 82253FF4h case    5:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82253FF4h case    5:*/		return 0x82253FF8;
		  /* 82253FF8h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82253FF8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82253FF8h case    6:*/		return 0x82253FFC;
		  /* 82253FFCh */ case    7:  		/* bc 4, CR6_GT, 64 */
		/* 82253FFCh case    7:*/		if ( !regs.CR[6].gt ) { return 0x8225403C;  }
		/* 82253FFCh case    7:*/		return 0x82254000;
		  /* 82254000h */ case    8:  		/* li R31, 0 */
		/* 82254000h case    8:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82254000h case    8:*/		return 0x82254004;
		  /* 82254004h */ case    9:  		/* lwz R11, <#[R30 + 8]> */
		/* 82254004h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82254004h case    9:*/		return 0x82254008;
		  /* 82254008h */ case   10:  		/* lwzx R10, <#[R31 + R11]> */
		/* 82254008h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 82254008h case   10:*/		return 0x8225400C;
		  /* 8225400Ch */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 8225400Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8225400Ch case   11:*/		return 0x82254010;
		  /* 82254010h */ case   12:  		/* bc 12, CR6_EQ, 24 */
		/* 82254010h case   12:*/		if ( regs.CR[6].eq ) { return 0x82254028;  }
		/* 82254010h case   12:*/		return 0x82254014;
		  /* 82254014h */ case   13:  		/* rlwinm R3, R10, 0, 0, 31 */
		/* 82254014h case   13:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R10);
		/* 82254014h case   13:*/		return 0x82254018;
		  /* 82254018h */ case   14:  		/* cmplwi CR6, R3, 0 */
		/* 82254018h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82254018h case   14:*/		return 0x8225401C;
		  /* 8225401Ch */ case   15:  		/* bc 12, CR6_EQ, 12 */
		/* 8225401Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x82254028;  }
		/* 8225401Ch case   15:*/		return 0x82254020;
		  /* 82254020h */ case   16:  		/* li R4, 1 */
		/* 82254020h case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82254020h case   16:*/		return 0x82254024;
		  /* 82254024h */ case   17:  		/* bl -83084 */
		/* 82254024h case   17:*/		regs.LR = 0x82254028; return 0x8223FB98;
		/* 82254024h case   17:*/		return 0x82254028;
	}
	return 0x82254028;
} // Block from 82253FE0h-82254028h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82254028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254028);
		  /* 82254028h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82254028h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82254028h case    0:*/		return 0x8225402C;
		  /* 8225402Ch */ case    1:  		/* addi R29, R29, 1 */
		/* 8225402Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8225402Ch case    1:*/		return 0x82254030;
		  /* 82254030h */ case    2:  		/* addi R31, R31, 4 */
		/* 82254030h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82254030h case    2:*/		return 0x82254034;
		  /* 82254034h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 82254034h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82254034h case    3:*/		return 0x82254038;
		  /* 82254038h */ case    4:  		/* bc 12, CR6_LT, -52 */
		/* 82254038h case    4:*/		if ( regs.CR[6].lt ) { return 0x82254004;  }
		/* 82254038h case    4:*/		return 0x8225403C;
	}
	return 0x8225403C;
} // Block from 82254028h-8225403Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225403Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225403C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225403C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225403C);
		  /* 8225403Ch */ case    0:  		/* lwz R4, <#[R30 + 8]> */
		/* 8225403Ch case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000008) );
		/* 8225403Ch case    0:*/		return 0x82254040;
		  /* 82254040h */ case    1:  		/* lwz R3, <#[R30 + 20]> */
		/* 82254040h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000014) );
		/* 82254040h case    1:*/		return 0x82254044;
		  /* 82254044h */ case    2:  		/* bl -227844 */
		/* 82254044h case    2:*/		regs.LR = 0x82254048; return 0x8221C640;
		/* 82254044h case    2:*/		return 0x82254048;
		  /* 82254048h */ case    3:  		/* addi R1, R1, 112 */
		/* 82254048h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82254048h case    3:*/		return 0x8225404C;
		  /* 8225404Ch */ case    4:  		/* b -1846688 */
		/* 8225404Ch case    4:*/		return 0x820912AC;
		/* 8225404Ch case    4:*/		return 0x82254050;
	}
	return 0x82254050;
} // Block from 8225403Ch-82254050h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82254050h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254050);
		  /* 82254050h */ case    0:  		/* mfspr R12, LR */
		/* 82254050h case    0:*/		regs.R12 = regs.LR;
		/* 82254050h case    0:*/		return 0x82254054;
		  /* 82254054h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82254054h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82254054h case    1:*/		return 0x82254058;
		  /* 82254058h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82254058h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82254058h case    2:*/		return 0x8225405C;
		  /* 8225405Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8225405Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8225405Ch case    3:*/		return 0x82254060;
		  /* 82254060h */ case    4:  		/* lwz R4, <#[R3 + 12]> */
		/* 82254060h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x0000000C) );
		/* 82254060h case    4:*/		return 0x82254064;
		  /* 82254064h */ case    5:  		/* mr R31, R3 */
		/* 82254064h case    5:*/		regs.R31 = regs.R3;
		/* 82254064h case    5:*/		return 0x82254068;
		  /* 82254068h */ case    6:  		/* cmpwi CR6, R4, 0 */
		/* 82254068h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 82254068h case    6:*/		return 0x8225406C;
		  /* 8225406Ch */ case    7:  		/* bc 12, CR6_LT, 56 */
		/* 8225406Ch case    7:*/		if ( regs.CR[6].lt ) { return 0x822540A4;  }
		/* 8225406Ch case    7:*/		return 0x82254070;
		  /* 82254070h */ case    8:  		/* lwz R3, <#[R31 + 8]> */
		/* 82254070h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 82254070h case    8:*/		return 0x82254074;
		  /* 82254074h */ case    9:  		/* addi R11, R4, -1 */
		/* 82254074h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0xFFFFFFFF);
		/* 82254074h case    9:*/		return 0x82254078;
		  /* 82254078h */ case   10:  		/* stw R11, <#[R31 + 12]> */
		/* 82254078h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82254078h case   10:*/		return 0x8225407C;
		  /* 8225407Ch */ case   11:  		/* lwz R11, <#[R3 + 4]> */
		/* 8225407Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8225407Ch case   11:*/		return 0x82254080;
		  /* 82254080h */ case   12:  		/* cmplw CR6, R4, R11 */
		/* 82254080h case   12:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 82254080h case   12:*/		return 0x82254084;
		  /* 82254084h */ case   13:  		/* bc 4, CR6_LT, 20 */
		/* 82254084h case   13:*/		if ( !regs.CR[6].lt ) { return 0x82254098;  }
		/* 82254084h case   13:*/		return 0x82254088;
		  /* 82254088h */ case   14:  		/* lwz R10, <#[R3 + 8]> */
		/* 82254088h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82254088h case   14:*/		return 0x8225408C;
		  /* 8225408Ch */ case   15:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 8225408Ch case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 8225408Ch case   15:*/		return 0x82254090;
		  /* 82254090h */ case   16:  		/* add R3, R11, R10 */
		/* 82254090h case   16:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82254090h case   16:*/		return 0x82254094;
		  /* 82254094h */ case   17:  		/* b 8 */
		/* 82254094h case   17:*/		return 0x8225409C;
		/* 82254094h case   17:*/		return 0x82254098;
	}
	return 0x82254098;
} // Block from 82254050h-82254098h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82254098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254098);
		  /* 82254098h */ case    0:  		/* bl -1496 */
		/* 82254098h case    0:*/		regs.LR = 0x8225409C; return 0x82253AC0;
		/* 82254098h case    0:*/		return 0x8225409C;
	}
	return 0x8225409C;
} // Block from 82254098h-8225409Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225409Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225409C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225409C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225409C);
		  /* 8225409Ch */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8225409Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8225409Ch case    0:*/		return 0x822540A0;
		  /* 822540A0h */ case    1:  		/* b 80 */
		/* 822540A0h case    1:*/		return 0x822540F0;
		/* 822540A0h case    1:*/		return 0x822540A4;
	}
	return 0x822540A4;
} // Block from 8225409Ch-822540A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822540A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822540A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822540A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822540A4);
		  /* 822540A4h */ case    0:  		/* lwz R10, <#[R31]> */
		/* 822540A4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 822540A4h case    0:*/		return 0x822540A8;
		  /* 822540A8h */ case    1:  		/* lwz R11, <#[R31 + 4]> */
		/* 822540A8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 822540A8h case    1:*/		return 0x822540AC;
		  /* 822540ACh */ case    2:  		/* addi R11, R11, 1 */
		/* 822540ACh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822540ACh case    2:*/		return 0x822540B0;
		  /* 822540B0h */ case    3:  		/* stw R11, <#[R31 + 4]> */
		/* 822540B0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 822540B0h case    3:*/		return 0x822540B4;
		  /* 822540B4h */ case    4:  		/* lwz R9, <#[R10]> */
		/* 822540B4h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 822540B4h case    4:*/		return 0x822540B8;
		  /* 822540B8h */ case    5:  		/* cmplw CR6, R11, R9 */
		/* 822540B8h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 822540B8h case    5:*/		return 0x822540BC;
		  /* 822540BCh */ case    6:  		/* bc 4, CR6_LT, 48 */
		/* 822540BCh case    6:*/		if ( !regs.CR[6].lt ) { return 0x822540EC;  }
		/* 822540BCh case    6:*/		return 0x822540C0;
		  /* 822540C0h */ case    7:  		/* lwz R9, <#[R10 + 8]> */
		/* 822540C0h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 822540C0h case    7:*/		return 0x822540C4;
		  /* 822540C4h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822540C4h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822540C4h case    8:*/		return 0x822540C8;
		  /* 822540C8h */ case    9:  		/* lwzx R11, <#[R9 + R11]> */
		/* 822540C8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 822540C8h case    9:*/		return 0x822540CC;
		  /* 822540CCh */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 822540CCh case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822540CCh case   10:*/		return 0x822540D0;
		  /* 822540D0h */ case   11:  		/* stw R11, <#[R31 + 8]> */
		/* 822540D0h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 822540D0h case   11:*/		return 0x822540D4;
		  /* 822540D4h */ case   12:  		/* bc 12, CR6_EQ, -44 */
		/* 822540D4h case   12:*/		if ( regs.CR[6].eq ) { return 0x822540A8;  }
		/* 822540D4h case   12:*/		return 0x822540D8;
		  /* 822540D8h */ case   13:  		/* lwz R11, <#[R11 + 4]> */
		/* 822540D8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822540D8h case   13:*/		return 0x822540DC;
		  /* 822540DCh */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 822540DCh case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822540DCh case   14:*/		return 0x822540E0;
		  /* 822540E0h */ case   15:  		/* bc 12, CR6_EQ, -56 */
		/* 822540E0h case   15:*/		if ( regs.CR[6].eq ) { return 0x822540A8;  }
		/* 822540E0h case   15:*/		return 0x822540E4;
		  /* 822540E4h */ case   16:  		/* addi R4, R11, -1 */
		/* 822540E4h case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFF);
		/* 822540E4h case   16:*/		return 0x822540E8;
		  /* 822540E8h */ case   17:  		/* b -120 */
		/* 822540E8h case   17:*/		return 0x82254070;
		/* 822540E8h case   17:*/		return 0x822540EC;
	}
	return 0x822540EC;
} // Block from 822540A4h-822540ECh (18 instructions)

//////////////////////////////////////////////////////
// Block at 822540ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822540EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822540EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822540EC);
		  /* 822540ECh */ case    0:  		/* li R11, 0 */
		/* 822540ECh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822540ECh case    0:*/		return 0x822540F0;
	}
	return 0x822540F0;
} // Block from 822540ECh-822540F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822540F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822540F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822540F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822540F0);
		  /* 822540F0h */ case    0:  		/* stw R11, <#[R31 + 16]> */
		/* 822540F0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 822540F0h case    0:*/		return 0x822540F4;
		  /* 822540F4h */ case    1:  		/* addi R1, R1, 96 */
		/* 822540F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 822540F4h case    1:*/		return 0x822540F8;
		  /* 822540F8h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 822540F8h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822540F8h case    2:*/		return 0x822540FC;
		  /* 822540FCh */ case    3:  		/* mtspr LR, R12 */
		/* 822540FCh case    3:*/		regs.LR = regs.R12;
		/* 822540FCh case    3:*/		return 0x82254100;
		  /* 82254100h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82254100h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82254100h case    4:*/		return 0x82254104;
		  /* 82254104h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82254104h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82254104h case    5:*/		return 0x82254108;
	}
	return 0x82254108;
} // Block from 822540F0h-82254108h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82254108h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254108);
		  /* 82254108h */ case    0:  		/* li R11, -1 */
		/* 82254108h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 82254108h case    0:*/		return 0x8225410C;
		  /* 8225410Ch */ case    1:  		/* stw R4, <#[R3]> */
		/* 8225410Ch case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000000) );
		/* 8225410Ch case    1:*/		return 0x82254110;
		  /* 82254110h */ case    2:  		/* li R10, -1 */
		/* 82254110h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 82254110h case    2:*/		return 0x82254114;
		  /* 82254114h */ case    3:  		/* stw R11, <#[R3 + 4]> */
		/* 82254114h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82254114h case    3:*/		return 0x82254118;
		  /* 82254118h */ case    4:  		/* stw R10, <#[R3 + 12]> */
		/* 82254118h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 82254118h case    4:*/		return 0x8225411C;
		  /* 8225411Ch */ case    5:  		/* b -204 */
		/* 8225411Ch case    5:*/		return 0x82254050;
		/* 8225411Ch case    5:*/		return 0x82254120;
	}
	return 0x82254120;
} // Block from 82254108h-82254120h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82254120h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254120);
		  /* 82254120h */ case    0:  		/* lis R11, -32251 */
		/* 82254120h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82254120h case    0:*/		return 0x82254124;
		  /* 82254124h */ case    1:  		/* mulli R10, R4, 12 */
		/* 82254124h case    1:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R4,0xC);
		/* 82254124h case    1:*/		return 0x82254128;
		  /* 82254128h */ case    2:  		/* addi R11, R11, -19064 */
		/* 82254128h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFB588);
		/* 82254128h case    2:*/		return 0x8225412C;
		  /* 8225412Ch */ case    3:  		/* addi R11, R11, 8 */
		/* 8225412Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8225412Ch case    3:*/		return 0x82254130;
		  /* 82254130h */ case    4:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82254130h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82254130h case    4:*/		return 0x82254134;
		  /* 82254134h */ case    5:  		/* mtspr CTR, R11 */
		/* 82254134h case    5:*/		regs.CTR = regs.R11;
		/* 82254134h case    5:*/		return 0x82254138;
		  /* 82254138h */ case    6:  		/* bcctr 20, CR0_LT */
		/* 82254138h case    6:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82254138h case    6:*/		return 0x8225413C;
		  /* 8225413Ch */ case    7:  		/* nop */
		/* 8225413Ch case    7:*/		cpu::op::nop();
		/* 8225413Ch case    7:*/		return 0x82254140;
	}
	return 0x82254140;
} // Block from 82254120h-82254140h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82254140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254140);
		  /* 82254140h */ case    0:  		/* mfspr R12, LR */
		/* 82254140h case    0:*/		regs.R12 = regs.LR;
		/* 82254140h case    0:*/		return 0x82254144;
		  /* 82254144h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82254144h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82254144h case    1:*/		return 0x82254148;
		  /* 82254148h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82254148h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82254148h case    2:*/		return 0x8225414C;
		  /* 8225414Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8225414Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225414Ch case    3:*/		return 0x82254150;
		  /* 82254150h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82254150h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82254150h case    4:*/		return 0x82254154;
		  /* 82254154h */ case    5:  		/* mr R30, R3 */
		/* 82254154h case    5:*/		regs.R30 = regs.R3;
		/* 82254154h case    5:*/		return 0x82254158;
		  /* 82254158h */ case    6:  		/* stw R4, <#[R1 + 140]> */
		/* 82254158h case    6:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000008C) );
		/* 82254158h case    6:*/		return 0x8225415C;
		  /* 8225415Ch */ case    7:  		/* li R31, 0 */
		/* 8225415Ch case    7:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8225415Ch case    7:*/		return 0x82254160;
		  /* 82254160h */ case    8:  		/* addi R11, R1, 140 */
		/* 82254160h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x8C);
		/* 82254160h case    8:*/		return 0x82254164;
		  /* 82254164h */ case    9:  		/* lbzx R11, <#[R31 + R11]> */
		/* 82254164h case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 82254164h case    9:*/		return 0x82254168;
		  /* 82254168h */ case   10:  		/* cmplwi CR0, R11, 0 */
		/* 82254168h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82254168h case   10:*/		return 0x8225416C;
		  /* 8225416Ch */ case   11:  		/* bc 4, CR0_EQ, 36 */
		/* 8225416Ch case   11:*/		if ( !regs.CR[0].eq ) { return 0x82254190;  }
		/* 8225416Ch case   11:*/		return 0x82254170;
		  /* 82254170h */ case   12:  		/* lwz R3, <#[R30 + 48]> */
		/* 82254170h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 82254170h case   12:*/		return 0x82254174;
		  /* 82254174h */ case   13:  		/* li R6, 0 */
		/* 82254174h case   13:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82254174h case   13:*/		return 0x82254178;
		  /* 82254178h */ case   14:  		/* mr R5, R31 */
		/* 82254178h case   14:*/		regs.R5 = regs.R31;
		/* 82254178h case   14:*/		return 0x8225417C;
		  /* 8225417Ch */ case   15:  		/* li R4, 0 */
		/* 8225417Ch case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225417Ch case   15:*/		return 0x82254180;
		  /* 82254180h */ case   16:  		/* lwz R11, <#[R3]> */
		/* 82254180h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82254180h case   16:*/		return 0x82254184;
		  /* 82254184h */ case   17:  		/* lwz R11, <#[R11 + 84]> */
		/* 82254184h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 82254184h case   17:*/		return 0x82254188;
		  /* 82254188h */ case   18:  		/* mtspr CTR, R11 */
		/* 82254188h case   18:*/		regs.CTR = regs.R11;
		/* 82254188h case   18:*/		return 0x8225418C;
		  /* 8225418Ch */ case   19:  		/* bcctrl 20, CR0_LT */
		/* 8225418Ch case   19:*/		if ( 1 ) { regs.LR = 0x82254190; return (uint32)regs.CTR; }
		/* 8225418Ch case   19:*/		return 0x82254190;
	}
	return 0x82254190;
} // Block from 82254140h-82254190h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82254190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254190);
		  /* 82254190h */ case    0:  		/* addi R31, R31, 1 */
		/* 82254190h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82254190h case    0:*/		return 0x82254194;
		  /* 82254194h */ case    1:  		/* cmpwi CR6, R31, 4 */
		/* 82254194h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000004);
		/* 82254194h case    1:*/		return 0x82254198;
		  /* 82254198h */ case    2:  		/* bc 12, CR6_LT, -56 */
		/* 82254198h case    2:*/		if ( regs.CR[6].lt ) { return 0x82254160;  }
		/* 82254198h case    2:*/		return 0x8225419C;
		  /* 8225419Ch */ case    3:  		/* lwz R3, <#[R30 + 52]> */
		/* 8225419Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000034) );
		/* 8225419Ch case    3:*/		return 0x822541A0;
		  /* 822541A0h */ case    4:  		/* addi R1, R1, 112 */
		/* 822541A0h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822541A0h case    4:*/		return 0x822541A4;
		  /* 822541A4h */ case    5:  		/* lwz R12, <#[R1 - 8]> */
		/* 822541A4h case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822541A4h case    5:*/		return 0x822541A8;
		  /* 822541A8h */ case    6:  		/* mtspr LR, R12 */
		/* 822541A8h case    6:*/		regs.LR = regs.R12;
		/* 822541A8h case    6:*/		return 0x822541AC;
		  /* 822541ACh */ case    7:  		/* ld R30, <#[R1 - 24]> */
		/* 822541ACh case    7:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822541ACh case    7:*/		return 0x822541B0;
		  /* 822541B0h */ case    8:  		/* ld R31, <#[R1 - 16]> */
		/* 822541B0h case    8:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822541B0h case    8:*/		return 0x822541B4;
		  /* 822541B4h */ case    9:  		/* bclr 20, CR0_LT */
		/* 822541B4h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822541B4h case    9:*/		return 0x822541B8;
	}
	return 0x822541B8;
} // Block from 82254190h-822541B8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822541B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822541B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822541B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822541B8);
		  /* 822541B8h */ case    0:  		/* mfspr R12, LR */
		/* 822541B8h case    0:*/		regs.R12 = regs.LR;
		/* 822541B8h case    0:*/		return 0x822541BC;
		  /* 822541BCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822541BCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822541BCh case    1:*/		return 0x822541C0;
		  /* 822541C0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 822541C0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822541C0h case    2:*/		return 0x822541C4;
		  /* 822541C4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 822541C4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822541C4h case    3:*/		return 0x822541C8;
		  /* 822541C8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 822541C8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822541C8h case    4:*/		return 0x822541CC;
		  /* 822541CCh */ case    5:  		/* mr R30, R3 */
		/* 822541CCh case    5:*/		regs.R30 = regs.R3;
		/* 822541CCh case    5:*/		return 0x822541D0;
		  /* 822541D0h */ case    6:  		/* stw R4, <#[R1 + 140]> */
		/* 822541D0h case    6:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000008C) );
		/* 822541D0h case    6:*/		return 0x822541D4;
		  /* 822541D4h */ case    7:  		/* mr R3, R5 */
		/* 822541D4h case    7:*/		regs.R3 = regs.R5;
		/* 822541D4h case    7:*/		return 0x822541D8;
		  /* 822541D8h */ case    8:  		/* bl -124192 */
		/* 822541D8h case    8:*/		regs.LR = 0x822541DC; return 0x82235CB8;
		/* 822541D8h case    8:*/		return 0x822541DC;
		  /* 822541DCh */ case    9:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822541DCh case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822541DCh case    9:*/		return 0x822541E0;
		  /* 822541E0h */ case   10:  		/* bc 12, CR0_EQ, 76 */
		/* 822541E0h case   10:*/		if ( regs.CR[0].eq ) { return 0x8225422C;  }
		/* 822541E0h case   10:*/		return 0x822541E4;
		  /* 822541E4h */ case   11:  		/* li R31, 0 */
		/* 822541E4h case   11:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 822541E4h case   11:*/		return 0x822541E8;
		  /* 822541E8h */ case   12:  		/* addi R11, R1, 140 */
		/* 822541E8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x8C);
		/* 822541E8h case   12:*/		return 0x822541EC;
		  /* 822541ECh */ case   13:  		/* lbzx R11, <#[R31 + R11]> */
		/* 822541ECh case   13:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 822541ECh case   13:*/		return 0x822541F0;
		  /* 822541F0h */ case   14:  		/* cmplwi CR0, R11, 0 */
		/* 822541F0h case   14:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 822541F0h case   14:*/		return 0x822541F4;
		  /* 822541F4h */ case   15:  		/* bc 4, CR0_EQ, 36 */
		/* 822541F4h case   15:*/		if ( !regs.CR[0].eq ) { return 0x82254218;  }
		/* 822541F4h case   15:*/		return 0x822541F8;
		  /* 822541F8h */ case   16:  		/* lwz R3, <#[R30 + 56]> */
		/* 822541F8h case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000038) );
		/* 822541F8h case   16:*/		return 0x822541FC;
		  /* 822541FCh */ case   17:  		/* li R6, 0 */
		/* 822541FCh case   17:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 822541FCh case   17:*/		return 0x82254200;
		  /* 82254200h */ case   18:  		/* mr R5, R31 */
		/* 82254200h case   18:*/		regs.R5 = regs.R31;
		/* 82254200h case   18:*/		return 0x82254204;
		  /* 82254204h */ case   19:  		/* li R4, 0 */
		/* 82254204h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82254204h case   19:*/		return 0x82254208;
		  /* 82254208h */ case   20:  		/* lwz R11, <#[R3]> */
		/* 82254208h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82254208h case   20:*/		return 0x8225420C;
		  /* 8225420Ch */ case   21:  		/* lwz R11, <#[R11 + 84]> */
		/* 8225420Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 8225420Ch case   21:*/		return 0x82254210;
		  /* 82254210h */ case   22:  		/* mtspr CTR, R11 */
		/* 82254210h case   22:*/		regs.CTR = regs.R11;
		/* 82254210h case   22:*/		return 0x82254214;
		  /* 82254214h */ case   23:  		/* bcctrl 20, CR0_LT */
		/* 82254214h case   23:*/		if ( 1 ) { regs.LR = 0x82254218; return (uint32)regs.CTR; }
		/* 82254214h case   23:*/		return 0x82254218;
	}
	return 0x82254218;
} // Block from 822541B8h-82254218h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82254218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254218);
		  /* 82254218h */ case    0:  		/* addi R31, R31, 1 */
		/* 82254218h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82254218h case    0:*/		return 0x8225421C;
		  /* 8225421Ch */ case    1:  		/* cmpwi CR6, R31, 4 */
		/* 8225421Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000004);
		/* 8225421Ch case    1:*/		return 0x82254220;
		  /* 82254220h */ case    2:  		/* bc 12, CR6_LT, -56 */
		/* 82254220h case    2:*/		if ( regs.CR[6].lt ) { return 0x822541E8;  }
		/* 82254220h case    2:*/		return 0x82254224;
		  /* 82254224h */ case    3:  		/* lwz R3, <#[R30 + 60]> */
		/* 82254224h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000003C) );
		/* 82254224h case    3:*/		return 0x82254228;
		  /* 82254228h */ case    4:  		/* b 8 */
		/* 82254228h case    4:*/		return 0x82254230;
		/* 82254228h case    4:*/		return 0x8225422C;
	}
	return 0x8225422C;
} // Block from 82254218h-8225422Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225422Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225422C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225422C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225422C);
		  /* 8225422Ch */ case    0:  		/* mr R3, R30 */
		/* 8225422Ch case    0:*/		regs.R3 = regs.R30;
		/* 8225422Ch case    0:*/		return 0x82254230;
	}
	return 0x82254230;
} // Block from 8225422Ch-82254230h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82254230h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254230);
		  /* 82254230h */ case    0:  		/* addi R1, R1, 112 */
		/* 82254230h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82254230h case    0:*/		return 0x82254234;
		  /* 82254234h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82254234h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82254234h case    1:*/		return 0x82254238;
		  /* 82254238h */ case    2:  		/* mtspr LR, R12 */
		/* 82254238h case    2:*/		regs.LR = regs.R12;
		/* 82254238h case    2:*/		return 0x8225423C;
		  /* 8225423Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8225423Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8225423Ch case    3:*/		return 0x82254240;
		  /* 82254240h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82254240h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82254240h case    4:*/		return 0x82254244;
		  /* 82254244h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82254244h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82254244h case    5:*/		return 0x82254248;
	}
	return 0x82254248;
} // Block from 82254230h-82254248h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82254248h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254248);
		  /* 82254248h */ case    0:  		/* mfspr R12, LR */
		/* 82254248h case    0:*/		regs.R12 = regs.LR;
		/* 82254248h case    0:*/		return 0x8225424C;
		  /* 8225424Ch */ case    1:  		/* bl -1847284 */
		/* 8225424Ch case    1:*/		regs.LR = 0x82254250; return 0x82091258;
		/* 8225424Ch case    1:*/		return 0x82254250;
		  /* 82254250h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82254250h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82254250h case    2:*/		return 0x82254254;
		  /* 82254254h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 82254254h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82254254h case    3:*/		return 0x82254258;
		  /* 82254258h */ case    4:  		/* mr R29, R3 */
		/* 82254258h case    4:*/		regs.R29 = regs.R3;
		/* 82254258h case    4:*/		return 0x8225425C;
		  /* 8225425Ch */ case    5:  		/* mr R31, R4 */
		/* 8225425Ch case    5:*/		regs.R31 = regs.R4;
		/* 8225425Ch case    5:*/		return 0x82254260;
		  /* 82254260h */ case    6:  		/* li R4, 16 */
		/* 82254260h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x10);
		/* 82254260h case    6:*/		return 0x82254264;
		  /* 82254264h */ case    7:  		/* mr R30, R5 */
		/* 82254264h case    7:*/		regs.R30 = regs.R5;
		/* 82254264h case    7:*/		return 0x82254268;
		  /* 82254268h */ case    8:  		/* lwz R28, <#[R11 + 1452]> */
		/* 82254268h case    8:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x000005AC) );
		/* 82254268h case    8:*/		return 0x8225426C;
		  /* 8225426Ch */ case    9:  		/* mr R3, R28 */
		/* 8225426Ch case    9:*/		regs.R3 = regs.R28;
		/* 8225426Ch case    9:*/		return 0x82254270;
		  /* 82254270h */ case   10:  		/* bl -228792 */
		/* 82254270h case   10:*/		regs.LR = 0x82254274; return 0x8221C4B8;
		/* 82254270h case   10:*/		return 0x82254274;
		  /* 82254274h */ case   11:  		/* addic. R11, R3, 4 */
		/* 82254274h case   11:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R3,0x4);
		/* 82254274h case   11:*/		return 0x82254278;
		  /* 82254278h */ case   12:  		/* stw R28, <#[R3]> */
		/* 82254278h case   12:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 82254278h case   12:*/		return 0x8225427C;
		  /* 8225427Ch */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 8225427Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x82254294;  }
		/* 8225427Ch case   13:*/		return 0x82254280;
		  /* 82254280h */ case   14:  		/* li R10, 0 */
		/* 82254280h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82254280h case   14:*/		return 0x82254284;
		  /* 82254284h */ case   15:  		/* stw R30, <#[R11]> */
		/* 82254284h case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82254284h case   15:*/		return 0x82254288;
		  /* 82254288h */ case   16:  		/* stw R31, <#[R11 + 4]> */
		/* 82254288h case   16:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 82254288h case   16:*/		return 0x8225428C;
		  /* 8225428Ch */ case   17:  		/* stw R10, <#[R11 + 8]> */
		/* 8225428Ch case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8225428Ch case   17:*/		return 0x82254290;
	}
	return 0x82254290;
} // Block from 82254248h-82254290h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82254290h
// Function '?IsEmpty@DList@XGRAPHICS@@QBA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254290);
		  /* 82254290h */ case    0:  		/* b 8 */
		/* 82254290h case    0:*/		return 0x82254298;
		/* 82254290h case    0:*/		return 0x82254294;
	}
	return 0x82254294;
} // Block from 82254290h-82254294h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82254294h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254294( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254294) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254294);
		  /* 82254294h */ case    0:  		/* li R11, 0 */
		/* 82254294h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82254294h case    0:*/		return 0x82254298;
	}
	return 0x82254298;
} // Block from 82254294h-82254298h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82254298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254298);
		  /* 82254298h */ case    0:  		/* lwz R10, <#[R29 + 4]> */
		/* 82254298h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 82254298h case    0:*/		return 0x8225429C;
		  /* 8225429Ch */ case    1:  		/* stw R10, <#[R11 + 8]> */
		/* 8225429Ch case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8225429Ch case    1:*/		return 0x822542A0;
		  /* 822542A0h */ case    2:  		/* stw R11, <#[R29 + 4]> */
		/* 822542A0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 822542A0h case    2:*/		return 0x822542A4;
		  /* 822542A4h */ case    3:  		/* addi R1, R1, 128 */
		/* 822542A4h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822542A4h case    3:*/		return 0x822542A8;
	}
	return 0x822542A8;
} // Block from 82254298h-822542A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822542A8h
// Function '?RemoveAndDelete@DListNode@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822542A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822542A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822542A8);
		  /* 822542A8h */ case    0:  		/* b -1847296 */
		/* 822542A8h case    0:*/		return 0x820912A8;
		/* 822542A8h case    0:*/		return 0x822542AC;
		  /* 822542ACh */ case    1:  		/* nop */
		/* 822542ACh case    1:*/		cpu::op::nop();
		/* 822542ACh case    1:*/		return 0x822542B0;
		  /* 822542B0h */ case    2:  		/* lwz R10, <#[R3 + 44]> */
		/* 822542B0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000002C) );
		/* 822542B0h case    2:*/		return 0x822542B4;
		  /* 822542B4h */ case    3:  		/* lwz R11, <#[R10 + 4]> */
		/* 822542B4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 822542B4h case    3:*/		return 0x822542B8;
		  /* 822542B8h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 822542B8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822542B8h case    4:*/		return 0x822542BC;
		  /* 822542BCh */ case    5:  		/* bclr 12, CR6_EQ */
		/* 822542BCh case    5:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 822542BCh case    5:*/		return 0x822542C0;
	}
	return 0x822542C0;
} // Block from 822542A8h-822542C0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822542C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822542C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822542C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822542C0);
		  /* 822542C0h */ case    0:  		/* lwz R9, <#[R11 + 8]> */
		/* 822542C0h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 822542C0h case    0:*/		return 0x822542C4;
		  /* 822542C4h */ case    1:  		/* addi R4, R11, -4 */
		/* 822542C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 822542C4h case    1:*/		return 0x822542C8;
		  /* 822542C8h */ case    2:  		/* stw R9, <#[R10 + 4]> */
		/* 822542C8h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 822542C8h case    2:*/		return 0x822542CC;
		  /* 822542CCh */ case    3:  		/* lwz R3, <#[R11 - 4]> */
		/* 822542CCh case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 822542CCh case    3:*/		return 0x822542D0;
		  /* 822542D0h */ case    4:  		/* b -228496 */
		/* 822542D0h case    4:*/		return 0x8221C640;
		/* 822542D0h case    4:*/		return 0x822542D4;
		  /* 822542D4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 822542D4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822542D4h case    5:*/		return 0x822542D8;
	}
	return 0x822542D8;
} // Block from 822542C0h-822542D8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822542D8h
// Function '?InsertBefore@DListNode@XGRAPHICS@@QAAXPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822542D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822542D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822542D8);
		  /* 822542D8h */ case    0:  		/* lwz R3, <#[R3 + 44]> */
		/* 822542D8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000002C) );
		/* 822542D8h case    0:*/		return 0x822542DC;
		  /* 822542DCh */ case    1:  		/* lwz R11, <#[R3 + 4]> */
		/* 822542DCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 822542DCh case    1:*/		return 0x822542E0;
		  /* 822542E0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 822542E0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822542E0h case    2:*/		return 0x822542E4;
		  /* 822542E4h */ case    3:  		/* bc 4, CR6_EQ, 8 */
		/* 822542E4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x822542EC;  }
		/* 822542E4h case    3:*/		return 0x822542E8;
		  /* 822542E8h */ case    4:  		/* b -160 */
		/* 822542E8h case    4:*/		return 0x82254248;
		/* 822542E8h case    4:*/		return 0x822542EC;
	}
	return 0x822542EC;
} // Block from 822542D8h-822542ECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 822542ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822542EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822542EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822542EC);
		  /* 822542ECh */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 822542ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 822542ECh case    0:*/		return 0x822542F0;
		  /* 822542F0h */ case    1:  		/* lwz R10, <#[R11 + 4]> */
		/* 822542F0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 822542F0h case    1:*/		return 0x822542F4;
		  /* 822542F4h */ case    2:  		/* cmpw CR6, R4, R10 */
		/* 822542F4h case    2:*/		cpu::op::cmpw<6>(regs,regs.R4,regs.R10);
		/* 822542F4h case    2:*/		return 0x822542F8;
	}
	return 0x822542F8;
} // Block from 822542ECh-822542F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822542F8h
// Function '?InsertAfter@DListNode@XGRAPHICS@@QAAXPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822542F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822542F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822542F8);
		  /* 822542F8h */ case    0:  		/* bc 4, CR6_EQ, 12 */
		/* 822542F8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82254304;  }
		/* 822542F8h case    0:*/		return 0x822542FC;
		  /* 822542FCh */ case    1:  		/* stw R5, <#[R11]> */
		/* 822542FCh case    1:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 822542FCh case    1:*/		return 0x82254300;
		  /* 82254300h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82254300h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82254300h case    2:*/		return 0x82254304;
	}
	return 0x82254304;
} // Block from 822542F8h-82254304h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82254304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254304);
		  /* 82254304h */ case    0:  		/* b -188 */
		/* 82254304h case    0:*/		return 0x82254248;
		/* 82254304h case    0:*/		return 0x82254308;
	}
	return 0x82254308;
} // Block from 82254304h-82254308h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82254308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254308);
		  /* 82254308h */ case    0:  		/* mfspr R12, LR */
		/* 82254308h case    0:*/		regs.R12 = regs.LR;
		/* 82254308h case    0:*/		return 0x8225430C;
		  /* 8225430Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225430Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225430Ch case    1:*/		return 0x82254310;
		  /* 82254310h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82254310h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82254310h case    2:*/		return 0x82254314;
		  /* 82254314h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82254314h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82254314h case    3:*/		return 0x82254318;
	}
	return 0x82254318;
} // Block from 82254308h-82254318h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82254318h
// Function '?Remove@DListNode@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254318);
		  /* 82254318h */ case    0:  		/* mr R31, R3 */
		/* 82254318h case    0:*/		regs.R31 = regs.R3;
		/* 82254318h case    0:*/		return 0x8225431C;
		  /* 8225431Ch */ case    1:  		/* b 36 */
		/* 8225431Ch case    1:*/		return 0x82254340;
		/* 8225431Ch case    1:*/		return 0x82254320;
		  /* 82254320h */ case    2:  		/* lwz R11, <#[R31 + 4]> */
		/* 82254320h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82254320h case    2:*/		return 0x82254324;
		  /* 82254324h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82254324h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82254324h case    3:*/		return 0x82254328;
		  /* 82254328h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 82254328h case    4:*/		if ( regs.CR[6].eq ) { return 0x82254340;  }
		/* 82254328h case    4:*/		return 0x8225432C;
		  /* 8225432Ch */ case    5:  		/* lwz R10, <#[R11 + 8]> */
		/* 8225432Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8225432Ch case    5:*/		return 0x82254330;
		  /* 82254330h */ case    6:  		/* addi R4, R11, -4 */
		/* 82254330h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 82254330h case    6:*/		return 0x82254334;
		  /* 82254334h */ case    7:  		/* stw R10, <#[R31 + 4]> */
		/* 82254334h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82254334h case    7:*/		return 0x82254338;
	}
	return 0x82254338;
} // Block from 82254318h-82254338h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82254338h
// Function '??0DList@XGRAPHICS@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254338);
		  /* 82254338h */ case    0:  		/* lwz R3, <#[R11 - 4]> */
		/* 82254338h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 82254338h case    0:*/		return 0x8225433C;
		  /* 8225433Ch */ case    1:  		/* bl -228604 */
		/* 8225433Ch case    1:*/		regs.LR = 0x82254340; return 0x8221C640;
		/* 8225433Ch case    1:*/		return 0x82254340;
	}
	return 0x82254340;
} // Block from 82254338h-82254340h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82254340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254340);
		  /* 82254340h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82254340h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82254340h case    0:*/		return 0x82254344;
		  /* 82254344h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82254344h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82254344h case    1:*/		return 0x82254348;
		  /* 82254348h */ case    2:  		/* bc 4, CR6_EQ, -40 */
		/* 82254348h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82254320;  }
		/* 82254348h case    2:*/		return 0x8225434C;
		  /* 8225434Ch */ case    3:  		/* addi R1, R1, 96 */
		/* 8225434Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8225434Ch case    3:*/		return 0x82254350;
		  /* 82254350h */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 82254350h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82254350h case    4:*/		return 0x82254354;
		  /* 82254354h */ case    5:  		/* mtspr LR, R12 */
		/* 82254354h case    5:*/		regs.LR = regs.R12;
		/* 82254354h case    5:*/		return 0x82254358;
		  /* 82254358h */ case    6:  		/* ld R31, <#[R1 - 16]> */
		/* 82254358h case    6:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82254358h case    6:*/		return 0x8225435C;
		  /* 8225435Ch */ case    7:  		/* bclr 20, CR0_LT */
		/* 8225435Ch case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225435Ch case    7:*/		return 0x82254360;
	}
	return 0x82254360;
} // Block from 82254340h-82254360h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82254360h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254360);
		  /* 82254360h */ case    0:  		/* mfspr R12, LR */
		/* 82254360h case    0:*/		regs.R12 = regs.LR;
		/* 82254360h case    0:*/		return 0x82254364;
		  /* 82254364h */ case    1:  		/* bl -1847568 */
		/* 82254364h case    1:*/		regs.LR = 0x82254368; return 0x82091254;
		/* 82254364h case    1:*/		return 0x82254368;
		  /* 82254368h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82254368h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82254368h case    2:*/		return 0x8225436C;
		  /* 8225436Ch */ case    3:  		/* lis R11, -32252 */
		/* 8225436Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8225436Ch case    3:*/		return 0x82254370;
	}
	return 0x82254370;
} // Block from 82254360h-82254370h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82254370h
// Function '?Length@DList@XGRAPHICS@@QBAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254370);
		  /* 82254370h */ case    0:  		/* stw R4, <#[R3 + 12]> */
		/* 82254370h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x0000000C) );
		/* 82254370h case    0:*/		return 0x82254374;
		  /* 82254374h */ case    1:  		/* li R29, 0 */
		/* 82254374h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82254374h case    1:*/		return 0x82254378;
		  /* 82254378h */ case    2:  		/* stw R5, <#[R3 + 32]> */
		/* 82254378h case    2:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000020) );
		/* 82254378h case    2:*/		return 0x8225437C;
		  /* 8225437Ch */ case    3:  		/* addi R11, R11, 27280 */
		/* 8225437Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6A90);
		/* 8225437Ch case    3:*/		return 0x82254380;
		  /* 82254380h */ case    4:  		/* li R10, -1 */
		/* 82254380h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 82254380h case    4:*/		return 0x82254384;
		  /* 82254384h */ case    5:  		/* stb R29, <#[R3 + 4]> */
		/* 82254384h case    5:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R3 + 0x00000004) );
		/* 82254384h case    5:*/		return 0x82254388;
		  /* 82254388h */ case    6:  		/* stw R11, <#[R3]> */
		/* 82254388h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82254388h case    6:*/		return 0x8225438C;
		  /* 8225438Ch */ case    7:  		/* mr R31, R3 */
		/* 8225438Ch case    7:*/		regs.R31 = regs.R3;
		/* 8225438Ch case    7:*/		return 0x82254390;
		  /* 82254390h */ case    8:  		/* stb R29, <#[R3 + 5]> */
		/* 82254390h case    8:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R3 + 0x00000005) );
		/* 82254390h case    8:*/		return 0x82254394;
		  /* 82254394h */ case    9:  		/* li R4, 12 */
		/* 82254394h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0xC);
		/* 82254394h case    9:*/		return 0x82254398;
	}
	return 0x82254398;
} // Block from 82254370h-82254398h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82254398h
// Function '?Append@DList@XGRAPHICS@@QAAXAAVDListNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254398);
		  /* 82254398h */ case    0:  		/* stw R10, <#[R3 + 16]> */
		/* 82254398h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82254398h case    0:*/		return 0x8225439C;
		  /* 8225439Ch */ case    1:  		/* mr R30, R6 */
		/* 8225439Ch case    1:*/		regs.R30 = regs.R6;
		/* 8225439Ch case    1:*/		return 0x822543A0;
		  /* 822543A0h */ case    2:  		/* stw R29, <#[R3 + 20]> */
		/* 822543A0h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000014) );
		/* 822543A0h case    2:*/		return 0x822543A4;
		  /* 822543A4h */ case    3:  		/* stw R29, <#[R3 + 24]> */
		/* 822543A4h case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000018) );
		/* 822543A4h case    3:*/		return 0x822543A8;
		  /* 822543A8h */ case    4:  		/* stb R29, <#[R3 + 28]> */
		/* 822543A8h case    4:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R3 + 0x0000001C) );
		/* 822543A8h case    4:*/		return 0x822543AC;
		  /* 822543ACh */ case    5:  		/* stb R29, <#[R3 + 29]> */
		/* 822543ACh case    5:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R3 + 0x0000001D) );
		/* 822543ACh case    5:*/		return 0x822543B0;
		  /* 822543B0h */ case    6:  		/* lwz R28, <#[R6 + 1452]> */
		/* 822543B0h case    6:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R6 + 0x000005AC) );
		/* 822543B0h case    6:*/		return 0x822543B4;
		  /* 822543B4h */ case    7:  		/* mr R3, R28 */
		/* 822543B4h case    7:*/		regs.R3 = regs.R28;
		/* 822543B4h case    7:*/		return 0x822543B8;
		  /* 822543B8h */ case    8:  		/* bl -229120 */
		/* 822543B8h case    8:*/		regs.LR = 0x822543BC; return 0x8221C4B8;
		/* 822543B8h case    8:*/		return 0x822543BC;
		  /* 822543BCh */ case    9:  		/* addic. R11, R3, 4 */
		/* 822543BCh case    9:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R3,0x4);
		/* 822543BCh case    9:*/		return 0x822543C0;
	}
	return 0x822543C0;
} // Block from 82254398h-822543C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822543C0h
// Function '?Insert@DList@XGRAPHICS@@QAAXAAVDListNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822543C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822543C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822543C0);
		  /* 822543C0h */ case    0:  		/* stw R28, <#[R3]> */
		/* 822543C0h case    0:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 822543C0h case    0:*/		return 0x822543C4;
		  /* 822543C4h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 822543C4h case    1:*/		if ( regs.CR[0].eq ) { return 0x822543D4;  }
		/* 822543C4h case    1:*/		return 0x822543C8;
		  /* 822543C8h */ case    2:  		/* stw R30, <#[R11]> */
		/* 822543C8h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 822543C8h case    2:*/		return 0x822543CC;
		  /* 822543CCh */ case    3:  		/* stw R29, <#[R11 + 4]> */
		/* 822543CCh case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000004) );
		/* 822543CCh case    3:*/		return 0x822543D0;
		  /* 822543D0h */ case    4:  		/* b 8 */
		/* 822543D0h case    4:*/		return 0x822543D8;
		/* 822543D0h case    4:*/		return 0x822543D4;
	}
	return 0x822543D4;
} // Block from 822543C0h-822543D4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822543D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822543D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822543D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822543D4);
		  /* 822543D4h */ case    0:  		/* mr R11, R29 */
		/* 822543D4h case    0:*/		regs.R11 = regs.R29;
		/* 822543D4h case    0:*/		return 0x822543D8;
	}
	return 0x822543D8;
} // Block from 822543D4h-822543D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822543D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822543D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822543D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822543D8);
		  /* 822543D8h */ case    0:  		/* stw R11, <#[R31 + 44]> */
		/* 822543D8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 822543D8h case    0:*/		return 0x822543DC;
		  /* 822543DCh */ case    1:  		/* li R4, 20 */
		/* 822543DCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 822543DCh case    1:*/		return 0x822543E0;
	}
	return 0x822543E0;
} // Block from 822543D8h-822543E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822543E0h
// Function '?Free@DList@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822543E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822543E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822543E0);
		  /* 822543E0h */ case    0:  		/* lwz R27, <#[R30 + 1452]> */
		/* 822543E0h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R30 + 0x000005AC) );
		/* 822543E0h case    0:*/		return 0x822543E4;
		  /* 822543E4h */ case    1:  		/* mr R3, R27 */
		/* 822543E4h case    1:*/		regs.R3 = regs.R27;
		/* 822543E4h case    1:*/		return 0x822543E8;
		  /* 822543E8h */ case    2:  		/* bl -229168 */
		/* 822543E8h case    2:*/		regs.LR = 0x822543EC; return 0x8221C4B8;
		/* 822543E8h case    2:*/		return 0x822543EC;
		  /* 822543ECh */ case    3:  		/* addic. R28, R3, 4 */
		/* 822543ECh case    3:*/		cpu::op::addic<1>(regs,&regs.R28,regs.R3,0x4);
		/* 822543ECh case    3:*/		return 0x822543F0;
		  /* 822543F0h */ case    4:  		/* stw R27, <#[R3]> */
		/* 822543F0h case    4:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 822543F0h case    4:*/		return 0x822543F4;
		  /* 822543F4h */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 822543F4h case    5:*/		if ( regs.CR[0].eq ) { return 0x82254408;  }
		/* 822543F4h case    5:*/		return 0x822543F8;
		  /* 822543F8h */ case    6:  		/* mr R3, R28 */
		/* 822543F8h case    6:*/		regs.R3 = regs.R28;
		/* 822543F8h case    6:*/		return 0x822543FC;
		  /* 822543FCh */ case    7:  		/* lwz R4, <#[R30 + 1452]> */
		/* 822543FCh case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x000005AC) );
		/* 822543FCh case    7:*/		return 0x82254400;
		  /* 82254400h */ case    8:  		/* bl -124576 */
		/* 82254400h case    8:*/		regs.LR = 0x82254404; return 0x82235D60;
		/* 82254400h case    8:*/		return 0x82254404;
		  /* 82254404h */ case    9:  		/* b 8 */
		/* 82254404h case    9:*/		return 0x8225440C;
		/* 82254404h case    9:*/		return 0x82254408;
	}
	return 0x82254408;
} // Block from 822543E0h-82254408h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82254408h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254408);
		  /* 82254408h */ case    0:  		/* mr R28, R29 */
		/* 82254408h case    0:*/		regs.R28 = regs.R29;
		/* 82254408h case    0:*/		return 0x8225440C;
	}
	return 0x8225440C;
} // Block from 82254408h-8225440Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225440Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225440C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225440C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225440C);
		  /* 8225440Ch */ case    0:  		/* stw R28, <#[R31 + 36]> */
		/* 8225440Ch case    0:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000024) );
		/* 8225440Ch case    0:*/		return 0x82254410;
		  /* 82254410h */ case    1:  		/* li R4, 20 */
		/* 82254410h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82254410h case    1:*/		return 0x82254414;
		  /* 82254414h */ case    2:  		/* lwz R27, <#[R30 + 1452]> */
		/* 82254414h case    2:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R30 + 0x000005AC) );
		/* 82254414h case    2:*/		return 0x82254418;
		  /* 82254418h */ case    3:  		/* mr R3, R27 */
		/* 82254418h case    3:*/		regs.R3 = regs.R27;
		/* 82254418h case    3:*/		return 0x8225441C;
		  /* 8225441Ch */ case    4:  		/* bl -229220 */
		/* 8225441Ch case    4:*/		regs.LR = 0x82254420; return 0x8221C4B8;
		/* 8225441Ch case    4:*/		return 0x82254420;
		  /* 82254420h */ case    5:  		/* addic. R28, R3, 4 */
		/* 82254420h case    5:*/		cpu::op::addic<1>(regs,&regs.R28,regs.R3,0x4);
		/* 82254420h case    5:*/		return 0x82254424;
		  /* 82254424h */ case    6:  		/* stw R27, <#[R3]> */
		/* 82254424h case    6:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 82254424h case    6:*/		return 0x82254428;
		  /* 82254428h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 82254428h case    7:*/		if ( regs.CR[0].eq ) { return 0x8225443C;  }
		/* 82254428h case    7:*/		return 0x8225442C;
		  /* 8225442Ch */ case    8:  		/* mr R3, R28 */
		/* 8225442Ch case    8:*/		regs.R3 = regs.R28;
		/* 8225442Ch case    8:*/		return 0x82254430;
		  /* 82254430h */ case    9:  		/* lwz R4, <#[R30 + 1452]> */
		/* 82254430h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x000005AC) );
		/* 82254430h case    9:*/		return 0x82254434;
		  /* 82254434h */ case   10:  		/* bl -124628 */
		/* 82254434h case   10:*/		regs.LR = 0x82254438; return 0x82235D60;
		/* 82254434h case   10:*/		return 0x82254438;
	}
	return 0x82254438;
} // Block from 8225440Ch-82254438h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82254438h
// Function '?Sort@InternalVector@XGRAPHICS@@IAAXP6AHPAX0@Z@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254438);
		  /* 82254438h */ case    0:  		/* mr R29, R28 */
		/* 82254438h case    0:*/		regs.R29 = regs.R28;
		/* 82254438h case    0:*/		return 0x8225443C;
	}
	return 0x8225443C;
} // Block from 82254438h-8225443Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225443Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225443C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225443C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225443C);
		  /* 8225443Ch */ case    0:  		/* stw R29, <#[R31 + 40]> */
		/* 8225443Ch case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000028) );
		/* 8225443Ch case    0:*/		return 0x82254440;
		  /* 82254440h */ case    1:  		/* mr R3, R31 */
		/* 82254440h case    1:*/		regs.R3 = regs.R31;
		/* 82254440h case    1:*/		return 0x82254444;
		  /* 82254444h */ case    2:  		/* lwz R11, <#[R30 + 1432]> */
		/* 82254444h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000598) );
		/* 82254444h case    2:*/		return 0x82254448;
		  /* 82254448h */ case    3:  		/* stw R11, <#[R31 + 8]> */
		/* 82254448h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82254448h case    3:*/		return 0x8225444C;
		  /* 8225444Ch */ case    4:  		/* lwz R11, <#[R30 + 1432]> */
		/* 8225444Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000598) );
		/* 8225444Ch case    4:*/		return 0x82254450;
		  /* 82254450h */ case    5:  		/* addi R11, R11, 1 */
		/* 82254450h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82254450h case    5:*/		return 0x82254454;
		  /* 82254454h */ case    6:  		/* stw R11, <#[R30 + 1432]> */
		/* 82254454h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000598) );
		/* 82254454h case    6:*/		return 0x82254458;
		  /* 82254458h */ case    7:  		/* addi R1, R1, 128 */
		/* 82254458h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82254458h case    7:*/		return 0x8225445C;
		  /* 8225445Ch */ case    8:  		/* b -1847736 */
		/* 8225445Ch case    8:*/		return 0x820912A4;
		/* 8225445Ch case    8:*/		return 0x82254460;
	}
	return 0x82254460;
} // Block from 8225443Ch-82254460h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82254460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254460);
		  /* 82254460h */ case    0:  		/* stb R4, <#[R3 + 4]> */
		/* 82254460h case    0:*/		cpu::mem::store8( regs, regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82254460h case    0:*/		return 0x82254464;
		  /* 82254464h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82254464h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82254464h case    1:*/		return 0x82254468;
	}
	return 0x82254468;
} // Block from 82254460h-82254468h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82254468h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254468);
		  /* 82254468h */ case    0:  		/* mfspr R12, LR */
		/* 82254468h case    0:*/		regs.R12 = regs.LR;
		/* 82254468h case    0:*/		return 0x8225446C;
		  /* 8225446Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225446Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225446Ch case    1:*/		return 0x82254470;
		  /* 82254470h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82254470h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82254470h case    2:*/		return 0x82254474;
		  /* 82254474h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82254474h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82254474h case    3:*/		return 0x82254478;
		  /* 82254478h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82254478h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82254478h case    4:*/		return 0x8225447C;
		  /* 8225447Ch */ case    5:  		/* mr R31, R3 */
		/* 8225447Ch case    5:*/		regs.R31 = regs.R3;
		/* 8225447Ch case    5:*/		return 0x82254480;
		  /* 82254480h */ case    6:  		/* lwz R3, <#[R3 + 40]> */
		/* 82254480h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000028) );
		/* 82254480h case    6:*/		return 0x82254484;
		  /* 82254484h */ case    7:  		/* mr R30, R4 */
		/* 82254484h case    7:*/		regs.R30 = regs.R4;
		/* 82254484h case    7:*/		return 0x82254488;
		  /* 82254488h */ case    8:  		/* lwz R4, <#[R3 + 4]> */
		/* 82254488h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82254488h case    8:*/		return 0x8225448C;
		  /* 8225448Ch */ case    9:  		/* bl -2508 */
		/* 8225448Ch case    9:*/		regs.LR = 0x82254490; return 0x82253AC0;
		/* 8225448Ch case    9:*/		return 0x82254490;
		  /* 82254490h */ case   10:  		/* stw R30, <#[R3]> */
		/* 82254490h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82254490h case   10:*/		return 0x82254494;
		  /* 82254494h */ case   11:  		/* lwz R11, <#[R31 + 24]> */
		/* 82254494h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82254494h case   11:*/		return 0x82254498;
		  /* 82254498h */ case   12:  		/* addi R11, R11, 1 */
		/* 82254498h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82254498h case   12:*/		return 0x8225449C;
		  /* 8225449Ch */ case   13:  		/* stw R11, <#[R31 + 24]> */
		/* 8225449Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8225449Ch case   13:*/		return 0x822544A0;
		  /* 822544A0h */ case   14:  		/* addi R1, R1, 112 */
		/* 822544A0h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822544A0h case   14:*/		return 0x822544A4;
		  /* 822544A4h */ case   15:  		/* lwz R12, <#[R1 - 8]> */
		/* 822544A4h case   15:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822544A4h case   15:*/		return 0x822544A8;
		  /* 822544A8h */ case   16:  		/* mtspr LR, R12 */
		/* 822544A8h case   16:*/		regs.LR = regs.R12;
		/* 822544A8h case   16:*/		return 0x822544AC;
		  /* 822544ACh */ case   17:  		/* ld R30, <#[R1 - 24]> */
		/* 822544ACh case   17:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822544ACh case   17:*/		return 0x822544B0;
		  /* 822544B0h */ case   18:  		/* ld R31, <#[R1 - 16]> */
		/* 822544B0h case   18:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822544B0h case   18:*/		return 0x822544B4;
		  /* 822544B4h */ case   19:  		/* bclr 20, CR0_LT */
		/* 822544B4h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822544B4h case   19:*/		return 0x822544B8;
	}
	return 0x822544B8;
} // Block from 82254468h-822544B8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 822544B8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822544B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822544B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822544B8);
		  /* 822544B8h */ case    0:  		/* mfspr R12, LR */
		/* 822544B8h case    0:*/		regs.R12 = regs.LR;
		/* 822544B8h case    0:*/		return 0x822544BC;
		  /* 822544BCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822544BCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822544BCh case    1:*/		return 0x822544C0;
		  /* 822544C0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 822544C0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822544C0h case    2:*/		return 0x822544C4;
		  /* 822544C4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 822544C4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822544C4h case    3:*/		return 0x822544C8;
		  /* 822544C8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 822544C8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822544C8h case    4:*/		return 0x822544CC;
		  /* 822544CCh */ case    5:  		/* mr R31, R3 */
		/* 822544CCh case    5:*/		regs.R31 = regs.R3;
		/* 822544CCh case    5:*/		return 0x822544D0;
		  /* 822544D0h */ case    6:  		/* mr R30, R5 */
		/* 822544D0h case    6:*/		regs.R30 = regs.R5;
		/* 822544D0h case    6:*/		return 0x822544D4;
		  /* 822544D4h */ case    7:  		/* li R10, 1 */
		/* 822544D4h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 822544D4h case    7:*/		return 0x822544D8;
		  /* 822544D8h */ case    8:  		/* cmpwi CR6, R4, 1 */
		/* 822544D8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000001);
		/* 822544D8h case    8:*/		return 0x822544DC;
		  /* 822544DCh */ case    9:  		/* bc 4, CR6_GT, 36 */
		/* 822544DCh case    9:*/		if ( !regs.CR[6].gt ) { return 0x82254500;  }
		/* 822544DCh case    9:*/		return 0x822544E0;
		  /* 822544E0h */ case   10:  		/* addi R11, R5, 32 */
		/* 822544E0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0x20);
		/* 822544E0h case   10:*/		return 0x822544E4;
		  /* 822544E4h */ case   11:  		/* lwz R9, <#[R11]> */
		/* 822544E4h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 822544E4h case   11:*/		return 0x822544E8;
		  /* 822544E8h */ case   12:  		/* cmplw CR6, R9, R31 */
		/* 822544E8h case   12:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R31);
		/* 822544E8h case   12:*/		return 0x822544EC;
		  /* 822544ECh */ case   13:  		/* bc 12, CR6_EQ, 48 */
		/* 822544ECh case   13:*/		if ( regs.CR[6].eq ) { return 0x8225451C;  }
		/* 822544ECh case   13:*/		return 0x822544F0;
		  /* 822544F0h */ case   14:  		/* addi R10, R10, 1 */
		/* 822544F0h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 822544F0h case   14:*/		return 0x822544F4;
		  /* 822544F4h */ case   15:  		/* addi R11, R11, 4 */
		/* 822544F4h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 822544F4h case   15:*/		return 0x822544F8;
		  /* 822544F8h */ case   16:  		/* cmpw CR6, R10, R4 */
		/* 822544F8h case   16:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R4);
		/* 822544F8h case   16:*/		return 0x822544FC;
		  /* 822544FCh */ case   17:  		/* bc 12, CR6_LT, -24 */
		/* 822544FCh case   17:*/		if ( regs.CR[6].lt ) { return 0x822544E4;  }
		/* 822544FCh case   17:*/		return 0x82254500;
	}
	return 0x82254500;
} // Block from 822544B8h-82254500h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82254500h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254500);
		  /* 82254500h */ case    0:  		/* lwz R3, <#[R31 + 36]> */
		/* 82254500h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000024) );
		/* 82254500h case    0:*/		return 0x82254504;
		  /* 82254504h */ case    1:  		/* lwz R4, <#[R3 + 4]> */
		/* 82254504h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82254504h case    1:*/		return 0x82254508;
		  /* 82254508h */ case    2:  		/* bl -2632 */
		/* 82254508h case    2:*/		regs.LR = 0x8225450C; return 0x82253AC0;
		/* 82254508h case    2:*/		return 0x8225450C;
		  /* 8225450Ch */ case    3:  		/* stw R30, <#[R3]> */
		/* 8225450Ch case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8225450Ch case    3:*/		return 0x82254510;
	}
	return 0x82254510;
} // Block from 82254500h-82254510h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82254510h
// Function '?Remove@InternalVector@XGRAPHICS@@IAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254510);
		  /* 82254510h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 82254510h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82254510h case    0:*/		return 0x82254514;
		  /* 82254514h */ case    1:  		/* addi R11, R11, 1 */
		/* 82254514h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82254514h case    1:*/		return 0x82254518;
		  /* 82254518h */ case    2:  		/* stw R11, <#[R31 + 20]> */
		/* 82254518h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82254518h case    2:*/		return 0x8225451C;
	}
	return 0x8225451C;
} // Block from 82254510h-8225451Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225451Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225451C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225451C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225451C);
		  /* 8225451Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 8225451Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8225451Ch case    0:*/		return 0x82254520;
		  /* 82254520h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82254520h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82254520h case    1:*/		return 0x82254524;
		  /* 82254524h */ case    2:  		/* mtspr LR, R12 */
		/* 82254524h case    2:*/		regs.LR = regs.R12;
		/* 82254524h case    2:*/		return 0x82254528;
		  /* 82254528h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82254528h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82254528h case    3:*/		return 0x8225452C;
		  /* 8225452Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8225452Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225452Ch case    4:*/		return 0x82254530;
		  /* 82254530h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82254530h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82254530h case    5:*/		return 0x82254534;
	}
	return 0x82254534;
} // Block from 8225451Ch-82254534h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82254534h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254534( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254534) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254534);
		  /* 82254534h */ case    0:  		/* nop */
		/* 82254534h case    0:*/		cpu::op::nop();
		/* 82254534h case    0:*/		return 0x82254538;
	}
	return 0x82254538;
} // Block from 82254534h-82254538h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82254538h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254538);
		  /* 82254538h */ case    0:  		/* mfspr R12, LR */
		/* 82254538h case    0:*/		regs.R12 = regs.LR;
		/* 82254538h case    0:*/		return 0x8225453C;
		  /* 8225453Ch */ case    1:  		/* bl -1848056 */
		/* 8225453Ch case    1:*/		regs.LR = 0x82254540; return 0x82091244;
		/* 8225453Ch case    1:*/		return 0x82254540;
		  /* 82254540h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82254540h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82254540h case    2:*/		return 0x82254544;
		  /* 82254544h */ case    3:  		/* lwz R11, <#[R3 + 44]> */
		/* 82254544h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 82254544h case    3:*/		return 0x82254548;
	}
	return 0x82254548;
} // Block from 82254538h-82254548h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82254548h
// Function '?RemoveOneByValue@InternalVector@XGRAPHICS@@IAA_NPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254548);
		  /* 82254548h */ case    0:  		/* mr R26, R3 */
		/* 82254548h case    0:*/		regs.R26 = regs.R3;
		/* 82254548h case    0:*/		return 0x8225454C;
		  /* 8225454Ch */ case    1:  		/* mr R24, R4 */
		/* 8225454Ch case    1:*/		regs.R24 = regs.R4;
		/* 8225454Ch case    1:*/		return 0x82254550;
		  /* 82254550h */ case    2:  		/* mr R28, R5 */
		/* 82254550h case    2:*/		regs.R28 = regs.R5;
		/* 82254550h case    2:*/		return 0x82254554;
		  /* 82254554h */ case    3:  		/* lwz R10, <#[R11 + 4]> */
		/* 82254554h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82254554h case    3:*/		return 0x82254558;
		  /* 82254558h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 82254558h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82254558h case    4:*/		return 0x8225455C;
		  /* 8225455Ch */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 8225455Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x8225456C;  }
		/* 8225455Ch case    5:*/		return 0x82254560;
		  /* 82254560h */ case    6:  		/* rlwinm R11, R10, 0, 0, 31 */
		/* 82254560h case    6:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R10);
		/* 82254560h case    6:*/		return 0x82254564;
		  /* 82254564h */ case    7:  		/* lwz R3, <#[R11]> */
		/* 82254564h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 82254564h case    7:*/		return 0x82254568;
		  /* 82254568h */ case    8:  		/* b 672 */
		/* 82254568h case    8:*/		return 0x82254808;
		/* 82254568h case    8:*/		return 0x8225456C;
	}
	return 0x8225456C;
} // Block from 82254548h-8225456Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225456Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225456C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225456C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225456C);
		  /* 8225456Ch */ case    0:  		/* lwz R11, <#[R26]> */
		/* 8225456Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8225456Ch case    0:*/		return 0x82254570;
		  /* 82254570h */ case    1:  		/* mr R3, R26 */
		/* 82254570h case    1:*/		regs.R3 = regs.R26;
		/* 82254570h case    1:*/		return 0x82254574;
		  /* 82254574h */ case    2:  		/* lwz R11, <#[R11 + 16]> */
		/* 82254574h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 82254574h case    2:*/		return 0x82254578;
		  /* 82254578h */ case    3:  		/* mtspr CTR, R11 */
		/* 82254578h case    3:*/		regs.CTR = regs.R11;
		/* 82254578h case    3:*/		return 0x8225457C;
		  /* 8225457Ch */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8225457Ch case    4:*/		if ( 1 ) { regs.LR = 0x82254580; return (uint32)regs.CTR; }
		/* 8225457Ch case    4:*/		return 0x82254580;
		  /* 82254580h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82254580h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82254580h case    5:*/		return 0x82254584;
		  /* 82254584h */ case    6:  		/* li R25, 0 */
		/* 82254584h case    6:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82254584h case    6:*/		return 0x82254588;
		  /* 82254588h */ case    7:  		/* li R27, 3 */
		/* 82254588h case    7:*/		cpu::op::li<0>(regs,&regs.R27,0x3);
		/* 82254588h case    7:*/		return 0x8225458C;
		  /* 8225458Ch */ case    8:  		/* bc 12, CR0_EQ, 272 */
		/* 8225458Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x8225469C;  }
		/* 8225458Ch case    8:*/		return 0x82254590;
		  /* 82254590h */ case    9:  		/* mr R4, R28 */
		/* 82254590h case    9:*/		regs.R4 = regs.R28;
		/* 82254590h case    9:*/		return 0x82254594;
		  /* 82254594h */ case   10:  		/* li R3, 49 */
		/* 82254594h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 82254594h case   10:*/		return 0x82254598;
		  /* 82254598h */ case   11:  		/* bl 14288 */
		/* 82254598h case   11:*/		regs.LR = 0x8225459C; return 0x82257D68;
		/* 82254598h case   11:*/		return 0x8225459C;
		  /* 8225459Ch */ case   12:  		/* lis R11, -32256 */
		/* 8225459Ch case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8225459Ch case   12:*/		return 0x822545A0;
		  /* 822545A0h */ case   13:  		/* lis R10, -32256 */
		/* 822545A0h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 822545A0h case   13:*/		return 0x822545A4;
		  /* 822545A4h */ case   14:  		/* lwz R4, <#[R28 + 2736]> */
		/* 822545A4h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000AB0) );
		/* 822545A4h case   14:*/		return 0x822545A8;
		  /* 822545A8h */ case   15:  		/* li R5, 1 */
		/* 822545A8h case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 822545A8h case   15:*/		return 0x822545AC;
		  /* 822545ACh */ case   16:  		/* mr R31, R3 */
		/* 822545ACh case   16:*/		regs.R31 = regs.R3;
		/* 822545ACh case   16:*/		return 0x822545B0;
		  /* 822545B0h */ case   17:  		/* lfs FR3, <#[R11 + 1816]> */
		/* 822545B0h case   17:*/		cpu::mem::load32f( regs, &regs.FR3, (uint32)(regs.R11 + 0x00000718) );
		/* 822545B0h case   17:*/		return 0x822545B4;
		  /* 822545B4h */ case   18:  		/* lfs FR4, <#[R10 + 1792]> */
		/* 822545B4h case   18:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R10 + 0x00000700) );
		/* 822545B4h case   18:*/		return 0x822545B8;
		  /* 822545B8h */ case   19:  		/* fmr FR2, FR3 */
		/* 822545B8h case   19:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR3);
		/* 822545B8h case   19:*/		return 0x822545BC;
		  /* 822545BCh */ case   20:  		/* fmr FR1, FR3 */
		/* 822545BCh case   20:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR3);
		/* 822545BCh case   20:*/		return 0x822545C0;
		  /* 822545C0h */ case   21:  		/* bl 10584 */
		/* 822545C0h case   21:*/		regs.LR = 0x822545C4; return 0x82256F18;
		/* 822545C0h case   21:*/		return 0x822545C4;
		  /* 822545C4h */ case   22:  		/* lwz R11, <#[R31 + 224]> */
		/* 822545C4h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E0) );
		/* 822545C4h case   22:*/		return 0x822545C8;
		  /* 822545C8h */ case   23:  		/* lwz R10, <#[R31 + 32]> */
		/* 822545C8h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000020) );
		/* 822545C8h case   23:*/		return 0x822545CC;
		  /* 822545CCh */ case   24:  		/* stw R11, <#[R31 + 56]> */
		/* 822545CCh case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 822545CCh case   24:*/		return 0x822545D0;
	}
	return 0x822545D0;
} // Block from 8225456Ch-822545D0h (25 instructions)

//////////////////////////////////////////////////////
// Block at 822545D0h
// Function '?Grow@InternalVector@XGRAPHICS@@IAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822545D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822545D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822545D0);
		  /* 822545D0h */ case    0:  		/* lwz R3, <#[R10 + 40]> */
		/* 822545D0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x00000028) );
		/* 822545D0h case    0:*/		return 0x822545D4;
		  /* 822545D4h */ case    1:  		/* lwz R11, <#[R3 + 4]> */
		/* 822545D4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 822545D4h case    1:*/		return 0x822545D8;
		  /* 822545D8h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 822545D8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822545D8h case    2:*/		return 0x822545DC;
		  /* 822545DCh */ case    3:  		/* bc 4, CR6_GT, 12 */
		/* 822545DCh case    3:*/		if ( !regs.CR[6].gt ) { return 0x822545E8;  }
		/* 822545DCh case    3:*/		return 0x822545E0;
		  /* 822545E0h */ case    4:  		/* lwz R3, <#[R3 + 8]> */
		/* 822545E0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000008) );
		/* 822545E0h case    4:*/		return 0x822545E4;
		  /* 822545E4h */ case    5:  		/* b 12 */
		/* 822545E4h case    5:*/		return 0x822545F0;
		/* 822545E4h case    5:*/		return 0x822545E8;
	}
	return 0x822545E8;
} // Block from 822545D0h-822545E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822545E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822545E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822545E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822545E8);
		  /* 822545E8h */ case    0:  		/* li R4, 0 */
		/* 822545E8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822545E8h case    0:*/		return 0x822545EC;
		  /* 822545ECh */ case    1:  		/* bl -2860 */
		/* 822545ECh case    1:*/		regs.LR = 0x822545F0; return 0x82253AC0;
		/* 822545ECh case    1:*/		return 0x822545F0;
	}
	return 0x822545F0;
} // Block from 822545E8h-822545F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822545F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822545F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822545F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822545F0);
		  /* 822545F0h */ case    0:  		/* lwz R30, <#[R3]> */
		/* 822545F0h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 822545F0h case    0:*/		return 0x822545F4;
		  /* 822545F4h */ case    1:  		/* li R4, 1 */
		/* 822545F4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822545F4h case    1:*/		return 0x822545F8;
		  /* 822545F8h */ case    2:  		/* mr R3, R31 */
		/* 822545F8h case    2:*/		regs.R3 = regs.R31;
		/* 822545F8h case    2:*/		return 0x822545FC;
		  /* 822545FCh */ case    3:  		/* mr R5, R30 */
		/* 822545FCh case    3:*/		regs.R5 = regs.R30;
		/* 822545FCh case    3:*/		return 0x82254600;
		  /* 82254600h */ case    4:  		/* bl -124592 */
		/* 82254600h case    4:*/		regs.LR = 0x82254604; return 0x82235F50;
		/* 82254600h case    4:*/		return 0x82254604;
		  /* 82254604h */ case    5:  		/* lwz R29, <#[R30 + 28]> */
		/* 82254604h case    5:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x0000001C) );
		/* 82254604h case    5:*/		return 0x82254608;
		  /* 82254608h */ case    6:  		/* lwz R11, <#[R29 + 44]> */
		/* 82254608h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000002C) );
		/* 82254608h case    6:*/		return 0x8225460C;
		  /* 8225460Ch */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225460Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225460Ch case    7:*/		return 0x82254610;
		  /* 82254610h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 82254610h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82254610h case    8:*/		return 0x82254614;
		  /* 82254614h */ case    9:  		/* bc 4, CR6_EQ, 256 */
		/* 82254614h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82254714;  }
		/* 82254614h case    9:*/		return 0x82254618;
		  /* 82254618h */ case   10:  		/* lwz R23, <#[R28 + 1456]> */
		/* 82254618h case   10:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R28 + 0x000005B0) );
		/* 82254618h case   10:*/		return 0x8225461C;
		  /* 8225461Ch */ case   11:  		/* li R4, 272 */
		/* 8225461Ch case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x110);
		/* 8225461Ch case   11:*/		return 0x82254620;
		  /* 82254620h */ case   12:  		/* mr R3, R23 */
		/* 82254620h case   12:*/		regs.R3 = regs.R23;
		/* 82254620h case   12:*/		return 0x82254624;
		  /* 82254624h */ case   13:  		/* bl -229740 */
		/* 82254624h case   13:*/		regs.LR = 0x82254628; return 0x8221C4B8;
		/* 82254624h case   13:*/		return 0x82254628;
		  /* 82254628h */ case   14:  		/* addic. R11, R3, 4 */
		/* 82254628h case   14:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R3,0x4);
		/* 82254628h case   14:*/		return 0x8225462C;
		  /* 8225462Ch */ case   15:  		/* stw R23, <#[R3]> */
		/* 8225462Ch case   15:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R3 + 0x00000000) );
		/* 8225462Ch case   15:*/		return 0x82254630;
		  /* 82254630h */ case   16:  		/* bc 12, CR0_EQ, 40 */
		/* 82254630h case   16:*/		if ( regs.CR[0].eq ) { return 0x82254658;  }
		/* 82254630h case   16:*/		return 0x82254634;
		  /* 82254634h */ case   17:  		/* stw R30, <#[R11 + 16]> */
		/* 82254634h case   17:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000010) );
		/* 82254634h case   17:*/		return 0x82254638;
		  /* 82254638h */ case   18:  		/* mr R30, R11 */
		/* 82254638h case   18:*/		regs.R30 = regs.R11;
		/* 82254638h case   18:*/		return 0x8225463C;
		  /* 8225463Ch */ case   19:  		/* stw R28, <#[R11 + 260]> */
		/* 8225463Ch case   19:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000104) );
		/* 8225463Ch case   19:*/		return 0x82254640;
		  /* 82254640h */ case   20:  		/* stb R25, <#[R11 + 264]> */
		/* 82254640h case   20:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R11 + 0x00000108) );
		/* 82254640h case   20:*/		return 0x82254644;
		  /* 82254644h */ case   21:  		/* stw R27, <#[R11]> */
		/* 82254644h case   21:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000000) );
		/* 82254644h case   21:*/		return 0x82254648;
		  /* 82254648h */ case   22:  		/* stw R27, <#[R11 + 4]> */
		/* 82254648h case   22:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000004) );
		/* 82254648h case   22:*/		return 0x8225464C;
		  /* 8225464Ch */ case   23:  		/* stw R27, <#[R11 + 8]> */
		/* 8225464Ch case   23:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000008) );
		/* 8225464Ch case   23:*/		return 0x82254650;
		  /* 82254650h */ case   24:  		/* stw R27, <#[R11 + 12]> */
		/* 82254650h case   24:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x0000000C) );
		/* 82254650h case   24:*/		return 0x82254654;
		  /* 82254654h */ case   25:  		/* b 8 */
		/* 82254654h case   25:*/		return 0x8225465C;
		/* 82254654h case   25:*/		return 0x82254658;
	}
	return 0x82254658;
} // Block from 822545F0h-82254658h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82254658h
// Function '?Insert@InternalVector@XGRAPHICS@@IAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254658);
		  /* 82254658h */ case    0:  		/* mr R30, R25 */
		/* 82254658h case    0:*/		regs.R30 = regs.R25;
		/* 82254658h case    0:*/		return 0x8225465C;
	}
	return 0x8225465C;
} // Block from 82254658h-8225465Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225465Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225465C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225465C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225465C);
		  /* 8225465Ch */ case    0:  		/* mr R3, R30 */
		/* 8225465Ch case    0:*/		regs.R3 = regs.R30;
		/* 8225465Ch case    0:*/		return 0x82254660;
		  /* 82254660h */ case    1:  		/* bl -47864 */
		/* 82254660h case    1:*/		regs.LR = 0x82254664; return 0x82248B68;
		/* 82254660h case    1:*/		return 0x82254664;
		  /* 82254664h */ case    2:  		/* lwz R3, <#[R29 + 44]> */
		/* 82254664h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 82254664h case    2:*/		return 0x82254668;
		  /* 82254668h */ case    3:  		/* lwz R4, <#[R24 + 48]> */
		/* 82254668h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R24 + 0x00000030) );
		/* 82254668h case    3:*/		return 0x8225466C;
		  /* 8225466Ch */ case    4:  		/* lwz R11, <#[R3 + 4]> */
		/* 8225466Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8225466Ch case    4:*/		return 0x82254670;
		  /* 82254670h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82254670h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82254670h case    5:*/		return 0x82254674;
		  /* 82254674h */ case    6:  		/* bc 12, CR6_EQ, 28 */
		/* 82254674h case    6:*/		if ( regs.CR[6].eq ) { return 0x82254690;  }
		/* 82254674h case    6:*/		return 0x82254678;
		  /* 82254678h */ case    7:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 82254678h case    7:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 82254678h case    7:*/		return 0x8225467C;
		  /* 8225467Ch */ case    8:  		/* lwz R10, <#[R11 + 4]> */
		/* 8225467Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8225467Ch case    8:*/		return 0x82254680;
		  /* 82254680h */ case    9:  		/* cmpw CR6, R4, R10 */
		/* 82254680h case    9:*/		cpu::op::cmpw<6>(regs,regs.R4,regs.R10);
		/* 82254680h case    9:*/		return 0x82254684;
		  /* 82254684h */ case   10:  		/* bc 4, CR6_EQ, 12 */
		/* 82254684h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82254690;  }
		/* 82254684h case   10:*/		return 0x82254688;
		  /* 82254688h */ case   11:  		/* stw R30, <#[R11]> */
		/* 82254688h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82254688h case   11:*/		return 0x8225468C;
		  /* 8225468Ch */ case   12:  		/* b 136 */
		/* 8225468Ch case   12:*/		return 0x82254714;
		/* 8225468Ch case   12:*/		return 0x82254690;
	}
	return 0x82254690;
} // Block from 8225465Ch-82254690h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82254690h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254690);
		  /* 82254690h */ case    0:  		/* mr R5, R30 */
		/* 82254690h case    0:*/		regs.R5 = regs.R30;
		/* 82254690h case    0:*/		return 0x82254694;
		  /* 82254694h */ case    1:  		/* bl -1100 */
		/* 82254694h case    1:*/		regs.LR = 0x82254698; return 0x82254248;
		/* 82254694h case    1:*/		return 0x82254698;
		  /* 82254698h */ case    2:  		/* b 124 */
		/* 82254698h case    2:*/		return 0x82254714;
		/* 82254698h case    2:*/		return 0x8225469C;
	}
	return 0x8225469C;
} // Block from 82254690h-8225469Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225469Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225469C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225469C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225469C);
		  /* 8225469Ch */ case    0:  		/* lwz R11, <#[R26]> */
		/* 8225469Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8225469Ch case    0:*/		return 0x822546A0;
		  /* 822546A0h */ case    1:  		/* mr R3, R26 */
		/* 822546A0h case    1:*/		regs.R3 = regs.R26;
		/* 822546A0h case    1:*/		return 0x822546A4;
		  /* 822546A4h */ case    2:  		/* lwz R11, <#[R11 + 24]> */
		/* 822546A4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 822546A4h case    2:*/		return 0x822546A8;
		  /* 822546A8h */ case    3:  		/* mtspr CTR, R11 */
		/* 822546A8h case    3:*/		regs.CTR = regs.R11;
		/* 822546A8h case    3:*/		return 0x822546AC;
		  /* 822546ACh */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 822546ACh case    4:*/		if ( 1 ) { regs.LR = 0x822546B0; return (uint32)regs.CTR; }
		/* 822546ACh case    4:*/		return 0x822546B0;
		  /* 822546B0h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822546B0h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822546B0h case    5:*/		return 0x822546B4;
		  /* 822546B4h */ case    6:  		/* bc 4, CR0_EQ, 40 */
		/* 822546B4h case    6:*/		if ( !regs.CR[0].eq ) { return 0x822546DC;  }
		/* 822546B4h case    6:*/		return 0x822546B8;
		  /* 822546B8h */ case    7:  		/* lis R11, -32252 */
		/* 822546B8h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822546B8h case    7:*/		return 0x822546BC;
		  /* 822546BCh */ case    8:  		/* lis R10, -32255 */
		/* 822546BCh case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 822546BCh case    8:*/		return 0x822546C0;
		  /* 822546C0h */ case    9:  		/* lis R9, -32253 */
		/* 822546C0h case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 822546C0h case    9:*/		return 0x822546C4;
		  /* 822546C4h */ case   10:  		/* addi R6, R11, 26984 */
		/* 822546C4h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x6968);
		/* 822546C4h case   10:*/		return 0x822546C8;
		  /* 822546C8h */ case   11:  		/* addi R5, R10, 5216 */
		/* 822546C8h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x1460);
		/* 822546C8h case   11:*/		return 0x822546CC;
		  /* 822546CCh */ case   12:  		/* addi R4, R9, 27460 */
		/* 822546CCh case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 822546CCh case   12:*/		return 0x822546D0;
		  /* 822546D0h */ case   13:  		/* li R7, 236 */
		/* 822546D0h case   13:*/		cpu::op::li<0>(regs,&regs.R7,0xEC);
		/* 822546D0h case   13:*/		return 0x822546D4;
		  /* 822546D4h */ case   14:  		/* li R3, 0 */
		/* 822546D4h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822546D4h case   14:*/		return 0x822546D8;
		  /* 822546D8h */ case   15:  		/* bl -1034960 */
		/* 822546D8h case   15:*/		regs.LR = 0x822546DC; return 0x82157C08;
		/* 822546D8h case   15:*/		return 0x822546DC;
	}
	return 0x822546DC;
} // Block from 8225469Ch-822546DCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 822546DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822546DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822546DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822546DC);
		  /* 822546DCh */ case    0:  		/* lwz R31, <#[R28 + 1452]> */
		/* 822546DCh case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x000005AC) );
		/* 822546DCh case    0:*/		return 0x822546E0;
		  /* 822546E0h */ case    1:  		/* li R4, 964 */
		/* 822546E0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 822546E0h case    1:*/		return 0x822546E4;
		  /* 822546E4h */ case    2:  		/* mr R3, R31 */
		/* 822546E4h case    2:*/		regs.R3 = regs.R31;
		/* 822546E4h case    2:*/		return 0x822546E8;
		  /* 822546E8h */ case    3:  		/* bl -229936 */
		/* 822546E8h case    3:*/		regs.LR = 0x822546EC; return 0x8221C4B8;
		/* 822546E8h case    3:*/		return 0x822546EC;
		  /* 822546ECh */ case    4:  		/* mr R11, R3 */
		/* 822546ECh case    4:*/		regs.R11 = regs.R3;
		/* 822546ECh case    4:*/		return 0x822546F0;
		  /* 822546F0h */ case    5:  		/* stw R31, <#[R3]> */
		/* 822546F0h case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 822546F0h case    5:*/		return 0x822546F4;
		  /* 822546F4h */ case    6:  		/* addic. R3, R3, 4 */
		/* 822546F4h case    6:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 822546F4h case    6:*/		return 0x822546F8;
		  /* 822546F8h */ case    7:  		/* bc 12, CR0_EQ, 24 */
		/* 822546F8h case    7:*/		if ( regs.CR[0].eq ) { return 0x82254710;  }
		/* 822546F8h case    7:*/		return 0x822546FC;
		  /* 822546FCh */ case    8:  		/* mr R5, R28 */
		/* 822546FCh case    8:*/		regs.R5 = regs.R28;
		/* 822546FCh case    8:*/		return 0x82254700;
		  /* 82254700h */ case    9:  		/* mr R4, R26 */
		/* 82254700h case    9:*/		regs.R4 = regs.R26;
		/* 82254700h case    9:*/		return 0x82254704;
		  /* 82254704h */ case   10:  		/* bl 11620 */
		/* 82254704h case   10:*/		regs.LR = 0x82254708; return 0x82257468;
		/* 82254704h case   10:*/		return 0x82254708;
	}
	return 0x82254708;
} // Block from 822546DCh-82254708h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82254708h
// Function '?Grow@InternalHashTable@XGRAPHICS@@IAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254708);
		  /* 82254708h */ case    0:  		/* mr R31, R3 */
		/* 82254708h case    0:*/		regs.R31 = regs.R3;
		/* 82254708h case    0:*/		return 0x8225470C;
		  /* 8225470Ch */ case    1:  		/* b 8 */
		/* 8225470Ch case    1:*/		return 0x82254714;
		/* 8225470Ch case    1:*/		return 0x82254710;
	}
	return 0x82254710;
} // Block from 82254708h-82254710h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82254710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254710);
		  /* 82254710h */ case    0:  		/* mr R31, R25 */
		/* 82254710h case    0:*/		regs.R31 = regs.R25;
		/* 82254710h case    0:*/		return 0x82254714;
	}
	return 0x82254714;
} // Block from 82254710h-82254714h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82254714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254714);
		  /* 82254714h */ case    0:  		/* stw R26, <#[R31 + 28]> */
		/* 82254714h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x0000001C) );
		/* 82254714h case    0:*/		return 0x82254718;
		  /* 82254718h */ case    1:  		/* mr R4, R31 */
		/* 82254718h case    1:*/		regs.R4 = regs.R31;
		/* 82254718h case    1:*/		return 0x8225471C;
		  /* 8225471Ch */ case    2:  		/* mr R3, R26 */
		/* 8225471Ch case    2:*/		regs.R3 = regs.R26;
		/* 8225471Ch case    2:*/		return 0x82254720;
		  /* 82254720h */ case    3:  		/* bl -696 */
		/* 82254720h case    3:*/		regs.LR = 0x82254724; return 0x82254468;
		/* 82254720h case    3:*/		return 0x82254724;
		  /* 82254724h */ case    4:  		/* lwz R11, <#[R24]> */
		/* 82254724h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 82254724h case    4:*/		return 0x82254728;
		  /* 82254728h */ case    5:  		/* mr R4, R31 */
		/* 82254728h case    5:*/		regs.R4 = regs.R31;
		/* 82254728h case    5:*/		return 0x8225472C;
		  /* 8225472Ch */ case    6:  		/* mr R3, R24 */
		/* 8225472Ch case    6:*/		regs.R3 = regs.R24;
		/* 8225472Ch case    6:*/		return 0x82254730;
		  /* 82254730h */ case    7:  		/* lwz R11, <#[R11 + 40]> */
		/* 82254730h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82254730h case    7:*/		return 0x82254734;
		  /* 82254734h */ case    8:  		/* mtspr CTR, R11 */
		/* 82254734h case    8:*/		regs.CTR = regs.R11;
		/* 82254734h case    8:*/		return 0x82254738;
		  /* 82254738h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 82254738h case    9:*/		if ( 1 ) { regs.LR = 0x8225473C; return (uint32)regs.CTR; }
		/* 82254738h case    9:*/		return 0x8225473C;
		  /* 8225473Ch */ case   10:  		/* lbz R11, <#[R26 + 5]> */
		/* 8225473Ch case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000005) );
		/* 8225473Ch case   10:*/		return 0x82254740;
		  /* 82254740h */ case   11:  		/* cmplwi CR0, R11, 0 */
		/* 82254740h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82254740h case   11:*/		return 0x82254744;
		  /* 82254744h */ case   12:  		/* bc 12, CR0_EQ, 36 */
		/* 82254744h case   12:*/		if ( regs.CR[0].eq ) { return 0x82254768;  }
		/* 82254744h case   12:*/		return 0x82254748;
		  /* 82254748h */ case   13:  		/* lwz R11, <#[R26 + 32]> */
		/* 82254748h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000020) );
		/* 82254748h case   13:*/		return 0x8225474C;
		  /* 8225474Ch */ case   14:  		/* lwz R10, <#[R26 + 16]> */
		/* 8225474Ch case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000010) );
		/* 8225474Ch case   14:*/		return 0x82254750;
		  /* 82254750h */ case   15:  		/* lwz R9, <#[R31 + 228]> */
		/* 82254750h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x000000E4) );
		/* 82254750h case   15:*/		return 0x82254754;
		  /* 82254754h */ case   16:  		/* ori R9, R9, 64 */
		/* 82254754h case   16:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x40);
		/* 82254754h case   16:*/		return 0x82254758;
		  /* 82254758h */ case   17:  		/* stw R11, <#[R31 + 80]> */
		/* 82254758h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 82254758h case   17:*/		return 0x8225475C;
		  /* 8225475Ch */ case   18:  		/* stw R10, <#[R31 + 56]> */
		/* 8225475Ch case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 8225475Ch case   18:*/		return 0x82254760;
		  /* 82254760h */ case   19:  		/* stw R9, <#[R31 + 228]> */
		/* 82254760h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x000000E4) );
		/* 82254760h case   19:*/		return 0x82254764;
		  /* 82254764h */ case   20:  		/* b 44 */
		/* 82254764h case   20:*/		return 0x82254790;
		/* 82254764h case   20:*/		return 0x82254768;
	}
	return 0x82254768;
} // Block from 82254714h-82254768h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82254768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254768);
		  /* 82254768h */ case    0:  		/* lwz R11, <#[R26]> */
		/* 82254768h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82254768h case    0:*/		return 0x8225476C;
		  /* 8225476Ch */ case    1:  		/* mr R3, R26 */
		/* 8225476Ch case    1:*/		regs.R3 = regs.R26;
		/* 8225476Ch case    1:*/		return 0x82254770;
		  /* 82254770h */ case    2:  		/* lwz R11, <#[R11 + 16]> */
		/* 82254770h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 82254770h case    2:*/		return 0x82254774;
		  /* 82254774h */ case    3:  		/* mtspr CTR, R11 */
		/* 82254774h case    3:*/		regs.CTR = regs.R11;
		/* 82254774h case    3:*/		return 0x82254778;
		  /* 82254778h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 82254778h case    4:*/		if ( 1 ) { regs.LR = 0x8225477C; return (uint32)regs.CTR; }
		/* 82254778h case    4:*/		return 0x8225477C;
		  /* 8225477Ch */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225477Ch case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225477Ch case    5:*/		return 0x82254780;
		  /* 82254780h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 82254780h case    6:*/		if ( regs.CR[0].eq ) { return 0x82254790;  }
		/* 82254780h case    6:*/		return 0x82254784;
		  /* 82254784h */ case    7:  		/* lwz R11, <#[R31 + 224]> */
		/* 82254784h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E0) );
		/* 82254784h case    7:*/		return 0x82254788;
		  /* 82254788h */ case    8:  		/* stw R25, <#[R31 + 80]> */
		/* 82254788h case    8:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x00000050) );
		/* 82254788h case    8:*/		return 0x8225478C;
		  /* 8225478Ch */ case    9:  		/* stw R11, <#[R31 + 56]> */
		/* 8225478Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 8225478Ch case    9:*/		return 0x82254790;
	}
	return 0x82254790;
} // Block from 82254768h-82254790h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82254790h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254790);
		  /* 82254790h */ case    0:  		/* lbz R11, <#[R26 + 4]> */
		/* 82254790h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 82254790h case    0:*/		return 0x82254794;
		  /* 82254794h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 82254794h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82254794h case    1:*/		return 0x82254798;
		  /* 82254798h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 82254798h case    2:*/		if ( regs.CR[0].eq ) { return 0x822547A8;  }
		/* 82254798h case    2:*/		return 0x8225479C;
		  /* 8225479Ch */ case    3:  		/* lwz R11, <#[R31 + 228]> */
		/* 8225479Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8225479Ch case    3:*/		return 0x822547A0;
		  /* 822547A0h */ case    4:  		/* ori R11, R11, 32 */
		/* 822547A0h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 822547A0h case    4:*/		return 0x822547A4;
		  /* 822547A4h */ case    5:  		/* stw R11, <#[R31 + 228]> */
		/* 822547A4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 822547A4h case    5:*/		return 0x822547A8;
	}
	return 0x822547A8;
} // Block from 82254790h-822547A8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822547A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822547A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822547A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822547A8);
		  /* 822547A8h */ case    0:  		/* lwz R30, <#[R28 + 1456]> */
		/* 822547A8h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x000005B0) );
		/* 822547A8h case    0:*/		return 0x822547AC;
		  /* 822547ACh */ case    1:  		/* li R4, 272 */
		/* 822547ACh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x110);
		/* 822547ACh case    1:*/		return 0x822547B0;
		  /* 822547B0h */ case    2:  		/* mr R3, R30 */
		/* 822547B0h case    2:*/		regs.R3 = regs.R30;
		/* 822547B0h case    2:*/		return 0x822547B4;
		  /* 822547B4h */ case    3:  		/* bl -230140 */
		/* 822547B4h case    3:*/		regs.LR = 0x822547B8; return 0x8221C4B8;
		/* 822547B4h case    3:*/		return 0x822547B8;
		  /* 822547B8h */ case    4:  		/* addic. R11, R3, 4 */
		/* 822547B8h case    4:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R3,0x4);
		/* 822547B8h case    4:*/		return 0x822547BC;
		  /* 822547BCh */ case    5:  		/* stw R30, <#[R3]> */
		/* 822547BCh case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 822547BCh case    5:*/		return 0x822547C0;
		  /* 822547C0h */ case    6:  		/* bc 12, CR0_EQ, 40 */
		/* 822547C0h case    6:*/		if ( regs.CR[0].eq ) { return 0x822547E8;  }
		/* 822547C0h case    6:*/		return 0x822547C4;
		  /* 822547C4h */ case    7:  		/* stw R31, <#[R11 + 16]> */
		/* 822547C4h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000010) );
		/* 822547C4h case    7:*/		return 0x822547C8;
		  /* 822547C8h */ case    8:  		/* mr R31, R11 */
		/* 822547C8h case    8:*/		regs.R31 = regs.R11;
		/* 822547C8h case    8:*/		return 0x822547CC;
		  /* 822547CCh */ case    9:  		/* stw R28, <#[R11 + 260]> */
		/* 822547CCh case    9:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000104) );
		/* 822547CCh case    9:*/		return 0x822547D0;
		  /* 822547D0h */ case   10:  		/* stb R25, <#[R11 + 264]> */
		/* 822547D0h case   10:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R11 + 0x00000108) );
		/* 822547D0h case   10:*/		return 0x822547D4;
		  /* 822547D4h */ case   11:  		/* stw R27, <#[R11]> */
		/* 822547D4h case   11:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000000) );
		/* 822547D4h case   11:*/		return 0x822547D8;
		  /* 822547D8h */ case   12:  		/* stw R27, <#[R11 + 4]> */
		/* 822547D8h case   12:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000004) );
		/* 822547D8h case   12:*/		return 0x822547DC;
		  /* 822547DCh */ case   13:  		/* stw R27, <#[R11 + 8]> */
		/* 822547DCh case   13:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000008) );
		/* 822547DCh case   13:*/		return 0x822547E0;
		  /* 822547E0h */ case   14:  		/* stw R27, <#[R11 + 12]> */
		/* 822547E0h case   14:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x0000000C) );
		/* 822547E0h case   14:*/		return 0x822547E4;
		  /* 822547E4h */ case   15:  		/* b 8 */
		/* 822547E4h case   15:*/		return 0x822547EC;
		/* 822547E4h case   15:*/		return 0x822547E8;
	}
	return 0x822547E8;
} // Block from 822547A8h-822547E8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822547E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822547E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822547E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822547E8);
		  /* 822547E8h */ case    0:  		/* mr R31, R25 */
		/* 822547E8h case    0:*/		regs.R31 = regs.R25;
		/* 822547E8h case    0:*/		return 0x822547EC;
	}
	return 0x822547EC;
} // Block from 822547E8h-822547ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822547ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822547EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822547EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822547EC);
		  /* 822547ECh */ case    0:  		/* mr R3, R31 */
		/* 822547ECh case    0:*/		regs.R3 = regs.R31;
		/* 822547ECh case    0:*/		return 0x822547F0;
		  /* 822547F0h */ case    1:  		/* bl -48264 */
		/* 822547F0h case    1:*/		regs.LR = 0x822547F4; return 0x82248B68;
		/* 822547F0h case    1:*/		return 0x822547F4;
		  /* 822547F4h */ case    2:  		/* mr R5, R31 */
		/* 822547F4h case    2:*/		regs.R5 = regs.R31;
		/* 822547F4h case    2:*/		return 0x822547F8;
		  /* 822547F8h */ case    3:  		/* mr R4, R26 */
		/* 822547F8h case    3:*/		regs.R4 = regs.R26;
		/* 822547F8h case    3:*/		return 0x822547FC;
		  /* 822547FCh */ case    4:  		/* mr R3, R24 */
		/* 822547FCh case    4:*/		regs.R3 = regs.R24;
		/* 822547FCh case    4:*/		return 0x82254800;
		  /* 82254800h */ case    5:  		/* bl 21336 */
		/* 82254800h case    5:*/		regs.LR = 0x82254804; return 0x82259B58;
		/* 82254800h case    5:*/		return 0x82254804;
		  /* 82254804h */ case    6:  		/* mr R3, R31 */
		/* 82254804h case    6:*/		regs.R3 = regs.R31;
		/* 82254804h case    6:*/		return 0x82254808;
	}
	return 0x82254808;
} // Block from 822547ECh-82254808h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82254808h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254808);
		  /* 82254808h */ case    0:  		/* addi R1, R1, 160 */
		/* 82254808h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82254808h case    0:*/		return 0x8225480C;
		  /* 8225480Ch */ case    1:  		/* b -1848696 */
		/* 8225480Ch case    1:*/		return 0x82091294;
		/* 8225480Ch case    1:*/		return 0x82254810;
	}
	return 0x82254810;
} // Block from 82254808h-82254810h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82254810h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254810);
		  /* 82254810h */ case    0:  		/* mfspr R12, LR */
		/* 82254810h case    0:*/		regs.R12 = regs.LR;
		/* 82254810h case    0:*/		return 0x82254814;
		  /* 82254814h */ case    1:  		/* bl -1848768 */
		/* 82254814h case    1:*/		regs.LR = 0x82254818; return 0x82091254;
		/* 82254814h case    1:*/		return 0x82254818;
		  /* 82254818h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82254818h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82254818h case    2:*/		return 0x8225481C;
		  /* 8225481Ch */ case    3:  		/* mr R29, R3 */
		/* 8225481Ch case    3:*/		regs.R29 = regs.R3;
		/* 8225481Ch case    3:*/		return 0x82254820;
		  /* 82254820h */ case    4:  		/* lwz R3, <#[R3 + 36]> */
		/* 82254820h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000024) );
		/* 82254820h case    4:*/		return 0x82254824;
		  /* 82254824h */ case    5:  		/* mr R28, R4 */
		/* 82254824h case    5:*/		regs.R28 = regs.R4;
		/* 82254824h case    5:*/		return 0x82254828;
		  /* 82254828h */ case    6:  		/* mr R27, R5 */
		/* 82254828h case    6:*/		regs.R27 = regs.R5;
		/* 82254828h case    6:*/		return 0x8225482C;
		  /* 8225482Ch */ case    7:  		/* li R31, 0 */
		/* 8225482Ch case    7:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8225482Ch case    7:*/		return 0x82254830;
		  /* 82254830h */ case    8:  		/* lwz R11, <#[R3 + 4]> */
		/* 82254830h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82254830h case    8:*/		return 0x82254834;
		  /* 82254834h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82254834h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82254834h case    9:*/		return 0x82254838;
		  /* 82254838h */ case   10:  		/* bc 4, CR6_GT, 116 */
		/* 82254838h case   10:*/		if ( !regs.CR[6].gt ) { return 0x822548AC;  }
		/* 82254838h case   10:*/		return 0x8225483C;
		  /* 8225483Ch */ case   11:  		/* li R30, 0 */
		/* 8225483Ch case   11:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8225483Ch case   11:*/		return 0x82254840;
		  /* 82254840h */ case   12:  		/* lwz R11, <#[R3 + 4]> */
		/* 82254840h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82254840h case   12:*/		return 0x82254844;
		  /* 82254844h */ case   13:  		/* cmplw CR6, R31, R11 */
		/* 82254844h case   13:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82254844h case   13:*/		return 0x82254848;
		  /* 82254848h */ case   14:  		/* bc 4, CR6_LT, 16 */
		/* 82254848h case   14:*/		if ( !regs.CR[6].lt ) { return 0x82254858;  }
		/* 82254848h case   14:*/		return 0x8225484C;
		  /* 8225484Ch */ case   15:  		/* lwz R11, <#[R3 + 8]> */
		/* 8225484Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8225484Ch case   15:*/		return 0x82254850;
		  /* 82254850h */ case   16:  		/* add R3, R11, R30 */
		/* 82254850h case   16:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R30);
		/* 82254850h case   16:*/		return 0x82254854;
		  /* 82254854h */ case   17:  		/* b 12 */
		/* 82254854h case   17:*/		return 0x82254860;
		/* 82254854h case   17:*/		return 0x82254858;
	}
	return 0x82254858;
} // Block from 82254810h-82254858h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82254858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254858);
		  /* 82254858h */ case    0:  		/* mr R4, R31 */
		/* 82254858h case    0:*/		regs.R4 = regs.R31;
		/* 82254858h case    0:*/		return 0x8225485C;
		  /* 8225485Ch */ case    1:  		/* bl -3484 */
		/* 8225485Ch case    1:*/		regs.LR = 0x82254860; return 0x82253AC0;
		/* 8225485Ch case    1:*/		return 0x82254860;
	}
	return 0x82254860;
} // Block from 82254858h-82254860h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82254860h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254860);
		  /* 82254860h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82254860h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82254860h case    0:*/		return 0x82254864;
		  /* 82254864h */ case    1:  		/* lwz R3, <#[R29 + 36]> */
		/* 82254864h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000024) );
		/* 82254864h case    1:*/		return 0x82254868;
		  /* 82254868h */ case    2:  		/* cmplw CR6, R11, R28 */
		/* 82254868h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 82254868h case    2:*/		return 0x8225486C;
		  /* 8225486Ch */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 8225486Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8225486Ch case    3:*/		return 0x82254870;
		  /* 82254870h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 82254870h case    4:*/		if ( regs.CR[6].eq ) { return 0x82254888;  }
		/* 82254870h case    4:*/		return 0x82254874;
		  /* 82254874h */ case    5:  		/* addi R31, R31, 1 */
		/* 82254874h case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82254874h case    5:*/		return 0x82254878;
		  /* 82254878h */ case    6:  		/* addi R30, R30, 4 */
		/* 82254878h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82254878h case    6:*/		return 0x8225487C;
		  /* 8225487Ch */ case    7:  		/* cmplw CR6, R31, R11 */
		/* 8225487Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8225487Ch case    7:*/		return 0x82254880;
		  /* 82254880h */ case    8:  		/* bc 12, CR6_LT, -64 */
		/* 82254880h case    8:*/		if ( regs.CR[6].lt ) { return 0x82254840;  }
		/* 82254880h case    8:*/		return 0x82254884;
		  /* 82254884h */ case    9:  		/* b 40 */
		/* 82254884h case    9:*/		return 0x822548AC;
		/* 82254884h case    9:*/		return 0x82254888;
	}
	return 0x82254888;
} // Block from 82254860h-82254888h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82254888h
// Function '?Lookup@InternalHashTable@XGRAPHICS@@IAAPAXPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254888);
		  /* 82254888h */ case    0:  		/* cmplw CR6, R31, R11 */
		/* 82254888h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82254888h case    0:*/		return 0x8225488C;
		  /* 8225488Ch */ case    1:  		/* bc 4, CR6_LT, 20 */
		/* 8225488Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x822548A0;  }
		/* 8225488Ch case    1:*/		return 0x82254890;
		  /* 82254890h */ case    2:  		/* lwz R11, <#[R3 + 8]> */
		/* 82254890h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82254890h case    2:*/		return 0x82254894;
		  /* 82254894h */ case    3:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82254894h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82254894h case    3:*/		return 0x82254898;
		  /* 82254898h */ case    4:  		/* add R3, R11, R10 */
		/* 82254898h case    4:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82254898h case    4:*/		return 0x8225489C;
		  /* 8225489Ch */ case    5:  		/* b 12 */
		/* 8225489Ch case    5:*/		return 0x822548A8;
		/* 8225489Ch case    5:*/		return 0x822548A0;
	}
	return 0x822548A0;
} // Block from 82254888h-822548A0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822548A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822548A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822548A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822548A0);
		  /* 822548A0h */ case    0:  		/* mr R4, R31 */
		/* 822548A0h case    0:*/		regs.R4 = regs.R31;
		/* 822548A0h case    0:*/		return 0x822548A4;
		  /* 822548A4h */ case    1:  		/* bl -3556 */
		/* 822548A4h case    1:*/		regs.LR = 0x822548A8; return 0x82253AC0;
		/* 822548A4h case    1:*/		return 0x822548A8;
	}
	return 0x822548A8;
} // Block from 822548A0h-822548A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822548A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822548A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822548A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822548A8);
		  /* 822548A8h */ case    0:  		/* stw R27, <#[R3]> */
		/* 822548A8h case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 822548A8h case    0:*/		return 0x822548AC;
	}
	return 0x822548AC;
} // Block from 822548A8h-822548ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822548ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822548AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822548AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822548AC);
		  /* 822548ACh */ case    0:  		/* addi R1, R1, 128 */
		/* 822548ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822548ACh case    0:*/		return 0x822548B0;
		  /* 822548B0h */ case    1:  		/* b -1848844 */
		/* 822548B0h case    1:*/		return 0x820912A4;
		/* 822548B0h case    1:*/		return 0x822548B4;
		  /* 822548B4h */ case    2:  		/* nop */
		/* 822548B4h case    2:*/		cpu::op::nop();
		/* 822548B4h case    2:*/		return 0x822548B8;
	}
	return 0x822548B8;
} // Block from 822548ACh-822548B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822548B8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822548B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822548B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822548B8);
		  /* 822548B8h */ case    0:  		/* mfspr R12, LR */
		/* 822548B8h case    0:*/		regs.R12 = regs.LR;
		/* 822548B8h case    0:*/		return 0x822548BC;
		  /* 822548BCh */ case    1:  		/* bl -1848932 */
		/* 822548BCh case    1:*/		regs.LR = 0x822548C0; return 0x82091258;
		/* 822548BCh case    1:*/		return 0x822548C0;
		  /* 822548C0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 822548C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822548C0h case    2:*/		return 0x822548C4;
		  /* 822548C4h */ case    3:  		/* mr R29, R3 */
		/* 822548C4h case    3:*/		regs.R29 = regs.R3;
		/* 822548C4h case    3:*/		return 0x822548C8;
		  /* 822548C8h */ case    4:  		/* lwz R3, <#[R3 + 36]> */
		/* 822548C8h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000024) );
		/* 822548C8h case    4:*/		return 0x822548CC;
		  /* 822548CCh */ case    5:  		/* mr R28, R4 */
		/* 822548CCh case    5:*/		regs.R28 = regs.R4;
		/* 822548CCh case    5:*/		return 0x822548D0;
		  /* 822548D0h */ case    6:  		/* li R31, 0 */
		/* 822548D0h case    6:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 822548D0h case    6:*/		return 0x822548D4;
		  /* 822548D4h */ case    7:  		/* lwz R11, <#[R3 + 4]> */
		/* 822548D4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 822548D4h case    7:*/		return 0x822548D8;
		  /* 822548D8h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 822548D8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822548D8h case    8:*/		return 0x822548DC;
		  /* 822548DCh */ case    9:  		/* bc 4, CR6_GT, 88 */
		/* 822548DCh case    9:*/		if ( !regs.CR[6].gt ) { return 0x82254934;  }
		/* 822548DCh case    9:*/		return 0x822548E0;
		  /* 822548E0h */ case   10:  		/* li R30, 0 */
		/* 822548E0h case   10:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 822548E0h case   10:*/		return 0x822548E4;
		  /* 822548E4h */ case   11:  		/* lwz R11, <#[R3 + 4]> */
		/* 822548E4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 822548E4h case   11:*/		return 0x822548E8;
		  /* 822548E8h */ case   12:  		/* cmplw CR6, R31, R11 */
		/* 822548E8h case   12:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 822548E8h case   12:*/		return 0x822548EC;
		  /* 822548ECh */ case   13:  		/* bc 4, CR6_LT, 16 */
		/* 822548ECh case   13:*/		if ( !regs.CR[6].lt ) { return 0x822548FC;  }
		/* 822548ECh case   13:*/		return 0x822548F0;
		  /* 822548F0h */ case   14:  		/* lwz R11, <#[R3 + 8]> */
		/* 822548F0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 822548F0h case   14:*/		return 0x822548F4;
		  /* 822548F4h */ case   15:  		/* add R3, R11, R30 */
		/* 822548F4h case   15:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R30);
		/* 822548F4h case   15:*/		return 0x822548F8;
		  /* 822548F8h */ case   16:  		/* b 12 */
		/* 822548F8h case   16:*/		return 0x82254904;
		/* 822548F8h case   16:*/		return 0x822548FC;
	}
	return 0x822548FC;
} // Block from 822548B8h-822548FCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 822548FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822548FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822548FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822548FC);
		  /* 822548FCh */ case    0:  		/* mr R4, R31 */
		/* 822548FCh case    0:*/		regs.R4 = regs.R31;
		/* 822548FCh case    0:*/		return 0x82254900;
		  /* 82254900h */ case    1:  		/* bl -3648 */
		/* 82254900h case    1:*/		regs.LR = 0x82254904; return 0x82253AC0;
		/* 82254900h case    1:*/		return 0x82254904;
	}
	return 0x82254904;
} // Block from 822548FCh-82254904h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82254904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254904);
		  /* 82254904h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82254904h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82254904h case    0:*/		return 0x82254908;
		  /* 82254908h */ case    1:  		/* lwz R3, <#[R29 + 36]> */
		/* 82254908h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000024) );
		/* 82254908h case    1:*/		return 0x8225490C;
		  /* 8225490Ch */ case    2:  		/* cmplw CR6, R11, R28 */
		/* 8225490Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 8225490Ch case    2:*/		return 0x82254910;
		  /* 82254910h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 82254910h case    3:*/		if ( regs.CR[6].eq ) { return 0x8225492C;  }
		/* 82254910h case    3:*/		return 0x82254914;
		  /* 82254914h */ case    4:  		/* lwz R11, <#[R3 + 4]> */
		/* 82254914h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82254914h case    4:*/		return 0x82254918;
		  /* 82254918h */ case    5:  		/* addi R31, R31, 1 */
		/* 82254918h case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82254918h case    5:*/		return 0x8225491C;
		  /* 8225491Ch */ case    6:  		/* addi R30, R30, 4 */
		/* 8225491Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8225491Ch case    6:*/		return 0x82254920;
		  /* 82254920h */ case    7:  		/* cmplw CR6, R31, R11 */
		/* 82254920h case    7:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82254920h case    7:*/		return 0x82254924;
		  /* 82254924h */ case    8:  		/* bc 12, CR6_LT, -64 */
		/* 82254924h case    8:*/		if ( regs.CR[6].lt ) { return 0x822548E4;  }
		/* 82254924h case    8:*/		return 0x82254928;
		  /* 82254928h */ case    9:  		/* b 12 */
		/* 82254928h case    9:*/		return 0x82254934;
		/* 82254928h case    9:*/		return 0x8225492C;
	}
	return 0x8225492C;
} // Block from 82254904h-8225492Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8225492Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225492C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225492C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225492C);
		  /* 8225492Ch */ case    0:  		/* mr R4, R31 */
		/* 8225492Ch case    0:*/		regs.R4 = regs.R31;
		/* 8225492Ch case    0:*/		return 0x82254930;
		  /* 82254930h */ case    1:  		/* bl -3888 */
		/* 82254930h case    1:*/		regs.LR = 0x82254934; return 0x82253A00;
		/* 82254930h case    1:*/		return 0x82254934;
	}
	return 0x82254934;
} // Block from 8225492Ch-82254934h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82254934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254934);
		  /* 82254934h */ case    0:  		/* addi R1, R1, 128 */
		/* 82254934h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82254934h case    0:*/		return 0x82254938;
		  /* 82254938h */ case    1:  		/* b -1848976 */
		/* 82254938h case    1:*/		return 0x820912A8;
		/* 82254938h case    1:*/		return 0x8225493C;
		  /* 8225493Ch */ case    2:  		/* nop */
		/* 8225493Ch case    2:*/		cpu::op::nop();
		/* 8225493Ch case    2:*/		return 0x82254940;
	}
	return 0x82254940;
} // Block from 82254934h-82254940h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82254940h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254940);
		  /* 82254940h */ case    0:  		/* mfspr R12, LR */
		/* 82254940h case    0:*/		regs.R12 = regs.LR;
		/* 82254940h case    0:*/		return 0x82254944;
		  /* 82254944h */ case    1:  		/* bl -1849084 */
		/* 82254944h case    1:*/		regs.LR = 0x82254948; return 0x82091248;
		/* 82254944h case    1:*/		return 0x82254948;
	}
	return 0x82254948;
} // Block from 82254940h-82254948h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82254948h
// Function '?Insert@InternalHashTable@XGRAPHICS@@IAAXPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254948( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254948) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254948);
		  /* 82254948h */ case    0:  		/* stwu R1, <#[R1 - 160]> */
		/* 82254948h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82254948h case    0:*/		return 0x8225494C;
		  /* 8225494Ch */ case    1:  		/* lwz R11, <#[R3 + 52]> */
		/* 8225494Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000034) );
		/* 8225494Ch case    1:*/		return 0x82254950;
		  /* 82254950h */ case    2:  		/* mr R29, R3 */
		/* 82254950h case    2:*/		regs.R29 = regs.R3;
		/* 82254950h case    2:*/		return 0x82254954;
		  /* 82254954h */ case    3:  		/* mr R27, R4 */
		/* 82254954h case    3:*/		regs.R27 = regs.R4;
		/* 82254954h case    3:*/		return 0x82254958;
		  /* 82254958h */ case    4:  		/* mr R30, R5 */
		/* 82254958h case    4:*/		regs.R30 = regs.R5;
		/* 82254958h case    4:*/		return 0x8225495C;
		  /* 8225495Ch */ case    5:  		/* mr R31, R6 */
		/* 8225495Ch case    5:*/		regs.R31 = regs.R6;
		/* 8225495Ch case    5:*/		return 0x82254960;
		  /* 82254960h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82254960h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82254960h case    6:*/		return 0x82254964;
		  /* 82254964h */ case    7:  		/* bc 4, CR6_EQ, 32 */
		/* 82254964h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82254984;  }
		/* 82254964h case    7:*/		return 0x82254968;
		  /* 82254968h */ case    8:  		/* lwz R11, <#[R6 + 1508]> */
		/* 82254968h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x000005E4) );
		/* 82254968h case    8:*/		return 0x8225496C;
		  /* 8225496Ch */ case    9:  		/* li R4, 0 */
		/* 8225496Ch case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225496Ch case    9:*/		return 0x82254970;
		  /* 82254970h */ case   10:  		/* addi R5, R11, -1 */
		/* 82254970h case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 82254970h case   10:*/		return 0x82254974;
		  /* 82254974h */ case   11:  		/* stw R5, <#[R6 + 1508]> */
		/* 82254974h case   11:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R6 + 0x000005E4) );
		/* 82254974h case   11:*/		return 0x82254978;
		  /* 82254978h */ case   12:  		/* lwz R3, <#[R30 + 172]> */
		/* 82254978h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000000AC) );
		/* 82254978h case   12:*/		return 0x8225497C;
		  /* 8225497Ch */ case   13:  		/* bl -64084 */
		/* 8225497Ch case   13:*/		regs.LR = 0x82254980; return 0x82244F28;
		/* 8225497Ch case   13:*/		return 0x82254980;
		  /* 82254980h */ case   14:  		/* stw R3, <#[R29 + 52]> */
		/* 82254980h case   14:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000034) );
		/* 82254980h case   14:*/		return 0x82254984;
	}
	return 0x82254984;
} // Block from 82254948h-82254984h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82254984h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254984( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254984) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254984);
		  /* 82254984h */ case    0:  		/* lwz R31, <#[R31 + 1452]> */
		/* 82254984h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x000005AC) );
		/* 82254984h case    0:*/		return 0x82254988;
		  /* 82254988h */ case    1:  		/* li R4, 964 */
		/* 82254988h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82254988h case    1:*/		return 0x8225498C;
		  /* 8225498Ch */ case    2:  		/* lwz R24, <#[R29 + 52]> */
		/* 8225498Ch case    2:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R29 + 0x00000034) );
		/* 8225498Ch case    2:*/		return 0x82254990;
		  /* 82254990h */ case    3:  		/* mr R3, R31 */
		/* 82254990h case    3:*/		regs.R3 = regs.R31;
		/* 82254990h case    3:*/		return 0x82254994;
		  /* 82254994h */ case    4:  		/* bl -230620 */
		/* 82254994h case    4:*/		regs.LR = 0x82254998; return 0x8221C4B8;
		/* 82254994h case    4:*/		return 0x82254998;
		  /* 82254998h */ case    5:  		/* mr R11, R3 */
		/* 82254998h case    5:*/		regs.R11 = regs.R3;
		/* 82254998h case    5:*/		return 0x8225499C;
		  /* 8225499Ch */ case    6:  		/* addic. R3, R3, 4 */
		/* 8225499Ch case    6:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 8225499Ch case    6:*/		return 0x822549A0;
		  /* 822549A0h */ case    7:  		/* stw R31, <#[R11]> */
		/* 822549A0h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 822549A0h case    7:*/		return 0x822549A4;
		  /* 822549A4h */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 822549A4h case    8:*/		if ( regs.CR[0].eq ) { return 0x822549B8;  }
		/* 822549A4h case    8:*/		return 0x822549A8;
		  /* 822549A8h */ case    9:  		/* lwz R4, <#[R30 + 12]> */
		/* 822549A8h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000000C) );
		/* 822549A8h case    9:*/		return 0x822549AC;
		  /* 822549ACh */ case   10:  		/* bl 10188 */
		/* 822549ACh case   10:*/		regs.LR = 0x822549B0; return 0x82257178;
		/* 822549ACh case   10:*/		return 0x822549B0;
		  /* 822549B0h */ case   11:  		/* mr R31, R3 */
		/* 822549B0h case   11:*/		regs.R31 = regs.R3;
		/* 822549B0h case   11:*/		return 0x822549B4;
		  /* 822549B4h */ case   12:  		/* b 8 */
		/* 822549B4h case   12:*/		return 0x822549BC;
		/* 822549B4h case   12:*/		return 0x822549B8;
	}
	return 0x822549B8;
} // Block from 82254984h-822549B8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 822549B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822549B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822549B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822549B8);
		  /* 822549B8h */ case    0:  		/* li R31, 0 */
		/* 822549B8h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 822549B8h case    0:*/		return 0x822549BC;
	}
	return 0x822549BC;
} // Block from 822549B8h-822549BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822549BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822549BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822549BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822549BC);
		  /* 822549BCh */ case    0:  		/* mr R5, R29 */
		/* 822549BCh case    0:*/		regs.R5 = regs.R29;
		/* 822549BCh case    0:*/		return 0x822549C0;
		  /* 822549C0h */ case    1:  		/* li R4, 0 */
		/* 822549C0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822549C0h case    1:*/		return 0x822549C4;
		  /* 822549C4h */ case    2:  		/* mr R3, R31 */
		/* 822549C4h case    2:*/		regs.R3 = regs.R31;
		/* 822549C4h case    2:*/		return 0x822549C8;
		  /* 822549C8h */ case    3:  		/* bl 6608 */
		/* 822549C8h case    3:*/		regs.LR = 0x822549CC; return 0x82256398;
		/* 822549C8h case    3:*/		return 0x822549CC;
		  /* 822549CCh */ case    4:  		/* lwz R11, <#[R29 + 32]> */
		/* 822549CCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000020) );
		/* 822549CCh case    4:*/		return 0x822549D0;
		  /* 822549D0h */ case    5:  		/* stw R31, <#[R29 + 48]> */
		/* 822549D0h case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R29 + 0x00000030) );
		/* 822549D0h case    5:*/		return 0x822549D4;
		  /* 822549D4h */ case    6:  		/* cmpwi CR6, R11, 5 */
		/* 822549D4h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000005);
		/* 822549D4h case    6:*/		return 0x822549D8;
		  /* 822549D8h */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 822549D8h case    7:*/		if ( !regs.CR[6].eq ) { return 0x822549E0;  }
		/* 822549D8h case    7:*/		return 0x822549DC;
		  /* 822549DCh */ case    8:  		/* stw R31, <#[R30 + 116]> */
		/* 822549DCh case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000074) );
		/* 822549DCh case    8:*/		return 0x822549E0;
	}
	return 0x822549E0;
} // Block from 822549BCh-822549E0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 822549E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822549E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822549E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822549E0);
		  /* 822549E0h */ case    0:  		/* lwz R11, <#[R29 + 32]> */
		/* 822549E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000020) );
		/* 822549E0h case    0:*/		return 0x822549E4;
		  /* 822549E4h */ case    1:  		/* cmpwi CR6, R11, 6 */
		/* 822549E4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 822549E4h case    1:*/		return 0x822549E8;
		  /* 822549E8h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 822549E8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x822549F8;  }
		/* 822549E8h case    2:*/		return 0x822549EC;
		  /* 822549ECh */ case    3:  		/* li R11, 1 */
		/* 822549ECh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822549ECh case    3:*/		return 0x822549F0;
		  /* 822549F0h */ case    4:  		/* stw R31, <#[R30 + 120]> */
		/* 822549F0h case    4:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000078) );
		/* 822549F0h case    4:*/		return 0x822549F4;
		  /* 822549F4h */ case    5:  		/* stb R11, <#[R30 + 126]> */
		/* 822549F4h case    5:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x0000007E) );
		/* 822549F4h case    5:*/		return 0x822549F8;
	}
	return 0x822549F8;
} // Block from 822549E0h-822549F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822549F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822549F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822549F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822549F8);
		  /* 822549F8h */ case    0:  		/* lwz R10, <#[R29 + 32]> */
		/* 822549F8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000020) );
		/* 822549F8h case    0:*/		return 0x822549FC;
		  /* 822549FCh */ case    1:  		/* lis R11, -32252 */
		/* 822549FCh case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822549FCh case    1:*/		return 0x82254A00;
		  /* 82254A00h */ case    2:  		/* cmpwi CR6, R10, 7 */
		/* 82254A00h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000007);
		/* 82254A00h case    2:*/		return 0x82254A04;
		  /* 82254A04h */ case    3:  		/* addi R28, R11, 26976 */
		/* 82254A04h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0x6960);
		/* 82254A04h case    3:*/		return 0x82254A08;
	}
	return 0x82254A08;
} // Block from 822549F8h-82254A08h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82254A08h
// Function '?Remove@InternalHashTable@XGRAPHICS@@IAAXPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254A08);
		  /* 82254A08h */ case    0:  		/* bc 4, CR6_EQ, 32 */
		/* 82254A08h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82254A28;  }
		/* 82254A08h case    0:*/		return 0x82254A0C;
		  /* 82254A0Ch */ case    1:  		/* lwz R11, <#[R28 + 4]> */
		/* 82254A0Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82254A0Ch case    1:*/		return 0x82254A10;
		  /* 82254A10h */ case    2:  		/* stw R11, <#[R31 + 132]> */
		/* 82254A10h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 82254A10h case    2:*/		return 0x82254A14;
		  /* 82254A14h */ case    3:  		/* stw R31, <#[R30 + 112]> */
		/* 82254A14h case    3:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000070) );
		/* 82254A14h case    3:*/		return 0x82254A18;
		  /* 82254A18h */ case    4:  		/* lwz R3, <#[R30 + 96]> */
		/* 82254A18h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000060) );
		/* 82254A18h case    4:*/		return 0x82254A1C;
		  /* 82254A1Ch */ case    5:  		/* lwz R4, <#[R3 + 4]> */
		/* 82254A1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82254A1Ch case    5:*/		return 0x82254A20;
		  /* 82254A20h */ case    6:  		/* bl -3936 */
		/* 82254A20h case    6:*/		regs.LR = 0x82254A24; return 0x82253AC0;
		/* 82254A20h case    6:*/		return 0x82254A24;
		  /* 82254A24h */ case    7:  		/* stw R31, <#[R3]> */
		/* 82254A24h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82254A24h case    7:*/		return 0x82254A28;
	}
	return 0x82254A28;
} // Block from 82254A08h-82254A28h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82254A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254A28);
		  /* 82254A28h */ case    0:  		/* lwz R11, <#[R29 + 32]> */
		/* 82254A28h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000020) );
		/* 82254A28h case    0:*/		return 0x82254A2C;
		  /* 82254A2Ch */ case    1:  		/* cmpwi CR6, R11, 8 */
		/* 82254A2Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000008);
		/* 82254A2Ch case    1:*/		return 0x82254A30;
		  /* 82254A30h */ case    2:  		/* bc 4, CR6_EQ, 24 */
		/* 82254A30h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82254A48;  }
		/* 82254A30h case    2:*/		return 0x82254A34;
		  /* 82254A34h */ case    3:  		/* stw R31, <#[R30 + 108]> */
		/* 82254A34h case    3:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x0000006C) );
		/* 82254A34h case    3:*/		return 0x82254A38;
		  /* 82254A38h */ case    4:  		/* lwz R3, <#[R30 + 96]> */
		/* 82254A38h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000060) );
		/* 82254A38h case    4:*/		return 0x82254A3C;
		  /* 82254A3Ch */ case    5:  		/* lwz R4, <#[R3 + 4]> */
		/* 82254A3Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82254A3Ch case    5:*/		return 0x82254A40;
		  /* 82254A40h */ case    6:  		/* bl -3968 */
		/* 82254A40h case    6:*/		regs.LR = 0x82254A44; return 0x82253AC0;
		/* 82254A40h case    6:*/		return 0x82254A44;
		  /* 82254A44h */ case    7:  		/* stw R31, <#[R3]> */
		/* 82254A44h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82254A44h case    7:*/		return 0x82254A48;
	}
	return 0x82254A48;
} // Block from 82254A28h-82254A48h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82254A48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254A48);
		  /* 82254A48h */ case    0:  		/* mr R5, R24 */
		/* 82254A48h case    0:*/		regs.R5 = regs.R24;
		/* 82254A48h case    0:*/		return 0x82254A4C;
		  /* 82254A4Ch */ case    1:  		/* li R4, 1 */
		/* 82254A4Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82254A4Ch case    1:*/		return 0x82254A50;
		  /* 82254A50h */ case    2:  		/* mr R3, R31 */
		/* 82254A50h case    2:*/		regs.R3 = regs.R31;
		/* 82254A50h case    2:*/		return 0x82254A54;
		  /* 82254A54h */ case    3:  		/* bl 6468 */
		/* 82254A54h case    3:*/		regs.LR = 0x82254A58; return 0x82256398;
		/* 82254A54h case    3:*/		return 0x82254A58;
		  /* 82254A58h */ case    4:  		/* mr R4, R31 */
		/* 82254A58h case    4:*/		regs.R4 = regs.R31;
		/* 82254A58h case    4:*/		return 0x82254A5C;
		  /* 82254A5Ch */ case    5:  		/* mr R3, R30 */
		/* 82254A5Ch case    5:*/		regs.R3 = regs.R30;
		/* 82254A5Ch case    5:*/		return 0x82254A60;
		  /* 82254A60h */ case    6:  		/* bl -124088 */
		/* 82254A60h case    6:*/		regs.LR = 0x82254A64; return 0x822365A8;
		/* 82254A60h case    6:*/		return 0x82254A64;
		  /* 82254A64h */ case    7:  		/* mr R4, R31 */
		/* 82254A64h case    7:*/		regs.R4 = regs.R31;
		/* 82254A64h case    7:*/		return 0x82254A68;
		  /* 82254A68h */ case    8:  		/* lwz R3, <#[R30 + 168]> */
		/* 82254A68h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000000A8) );
		/* 82254A68h case    8:*/		return 0x82254A6C;
		  /* 82254A6Ch */ case    9:  		/* bl 17676 */
		/* 82254A6Ch case    9:*/		regs.LR = 0x82254A70; return 0x82258F78;
		/* 82254A6Ch case    9:*/		return 0x82254A70;
		  /* 82254A70h */ case   10:  		/* lwz R11, <#[R28]> */
		/* 82254A70h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82254A70h case   10:*/		return 0x82254A74;
		  /* 82254A74h */ case   11:  		/* lis R10, -32253 */
		/* 82254A74h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8203);
		/* 82254A74h case   11:*/		return 0x82254A78;
		  /* 82254A78h */ case   12:  		/* stw R27, <#[R1 + 84]> */
		/* 82254A78h case   12:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000054) );
		/* 82254A78h case   12:*/		return 0x82254A7C;
		  /* 82254A7Ch */ case   13:  		/* lis R9, -32252 */
		/* 82254A7Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 82254A7Ch case   13:*/		return 0x82254A80;
		  /* 82254A80h */ case   14:  		/* lis R8, -32252 */
		/* 82254A80h case   14:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8204);
		/* 82254A80h case   14:*/		return 0x82254A84;
		  /* 82254A84h */ case   15:  		/* li R30, 0 */
		/* 82254A84h case   15:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82254A84h case   15:*/		return 0x82254A88;
		  /* 82254A88h */ case   16:  		/* stw R11, <#[R1 + 80]> */
		/* 82254A88h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82254A88h case   16:*/		return 0x82254A8C;
		  /* 82254A8Ch */ case   17:  		/* lis R11, -32252 */
		/* 82254A8Ch case   17:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82254A8Ch case   17:*/		return 0x82254A90;
		  /* 82254A90h */ case   18:  		/* addi R28, R10, 27460 */
		/* 82254A90h case   18:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R10,0x6B44);
		/* 82254A90h case   18:*/		return 0x82254A94;
		  /* 82254A94h */ case   19:  		/* addi R29, R11, 27112 */
		/* 82254A94h case   19:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x69E8);
		/* 82254A94h case   19:*/		return 0x82254A98;
		  /* 82254A98h */ case   20:  		/* addi R27, R9, 27080 */
		/* 82254A98h case   20:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R9,0x69C8);
		/* 82254A98h case   20:*/		return 0x82254A9C;
		  /* 82254A9Ch */ case   21:  		/* addi R26, R8, 26984 */
		/* 82254A9Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R8,0x6968);
		/* 82254A9Ch case   21:*/		return 0x82254AA0;
		  /* 82254AA0h */ case   22:  		/* addi R11, R1, 84 */
		/* 82254AA0h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x54);
		/* 82254AA0h case   22:*/		return 0x82254AA4;
		  /* 82254AA4h */ case   23:  		/* lbzx R25, <#[R30 + R11]> */
		/* 82254AA4h case   23:*/		cpu::mem::load8z( regs, &regs.R25, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 82254AA4h case   23:*/		return 0x82254AA8;
		  /* 82254AA8h */ case   24:  		/* cmplwi CR6, R25, 8 */
		/* 82254AA8h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000008);
		/* 82254AA8h case   24:*/		return 0x82254AAC;
		  /* 82254AACh */ case   25:  		/* bc 12, CR6_LT, 28 */
		/* 82254AACh case   25:*/		if ( regs.CR[6].lt ) { return 0x82254AC8;  }
		/* 82254AACh case   25:*/		return 0x82254AB0;
		  /* 82254AB0h */ case   26:  		/* mr R6, R26 */
		/* 82254AB0h case   26:*/		regs.R6 = regs.R26;
		/* 82254AB0h case   26:*/		return 0x82254AB4;
		  /* 82254AB4h */ case   27:  		/* mr R5, R27 */
		/* 82254AB4h case   27:*/		regs.R5 = regs.R27;
		/* 82254AB4h case   27:*/		return 0x82254AB8;
		  /* 82254AB8h */ case   28:  		/* mr R4, R28 */
		/* 82254AB8h case   28:*/		regs.R4 = regs.R28;
		/* 82254AB8h case   28:*/		return 0x82254ABC;
		  /* 82254ABCh */ case   29:  		/* li R7, 361 */
		/* 82254ABCh case   29:*/		cpu::op::li<0>(regs,&regs.R7,0x169);
		/* 82254ABCh case   29:*/		return 0x82254AC0;
		  /* 82254AC0h */ case   30:  		/* li R3, 0 */
		/* 82254AC0h case   30:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82254AC0h case   30:*/		return 0x82254AC4;
		  /* 82254AC4h */ case   31:  		/* bl -1035964 */
		/* 82254AC4h case   31:*/		regs.LR = 0x82254AC8; return 0x82157C08;
		/* 82254AC4h case   31:*/		return 0x82254AC8;
	}
	return 0x82254AC8;
} // Block from 82254A48h-82254AC8h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82254AC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254AC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254AC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254AC8);
		  /* 82254AC8h */ case    0:  		/* rlwinm R11, R25, 2, 0, 29 */
		/* 82254AC8h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R25);
		/* 82254AC8h case    0:*/		return 0x82254ACC;
		  /* 82254ACCh */ case    1:  		/* addi R10, R1, 80 */
		/* 82254ACCh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82254ACCh case    1:*/		return 0x82254AD0;
		  /* 82254AD0h */ case    2:  		/* lwzx R11, <#[R11 + R29]> */
		/* 82254AD0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82254AD0h case    2:*/		return 0x82254AD4;
		  /* 82254AD4h */ case    3:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 82254AD4h case    3:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82254AD4h case    3:*/		return 0x82254AD8;
		  /* 82254AD8h */ case    4:  		/* stbx R11, <#[R30 + R10]> */
		/* 82254AD8h case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + regs.R10 + 0x00000000) );
		/* 82254AD8h case    4:*/		return 0x82254ADC;
		  /* 82254ADCh */ case    5:  		/* addi R30, R30, 1 */
		/* 82254ADCh case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82254ADCh case    5:*/		return 0x82254AE0;
		  /* 82254AE0h */ case    6:  		/* cmpwi CR6, R30, 4 */
		/* 82254AE0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 82254AE0h case    6:*/		return 0x82254AE4;
		  /* 82254AE4h */ case    7:  		/* bc 12, CR6_LT, -68 */
		/* 82254AE4h case    7:*/		if ( regs.CR[6].lt ) { return 0x82254AA0;  }
		/* 82254AE4h case    7:*/		return 0x82254AE8;
		  /* 82254AE8h */ case    8:  		/* lwz R11, <#[R1 + 80]> */
		/* 82254AE8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82254AE8h case    8:*/		return 0x82254AEC;
		  /* 82254AECh */ case    9:  		/* mr R3, R24 */
		/* 82254AECh case    9:*/		regs.R3 = regs.R24;
		/* 82254AECh case    9:*/		return 0x82254AF0;
	}
	return 0x82254AF0;
} // Block from 82254AC8h-82254AF0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82254AF0h
// Function '??1InternalHashTable@XGRAPHICS@@IAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254AF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254AF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254AF0);
		  /* 82254AF0h */ case    0:  		/* stw R11, <#[R31 + 128]> */
		/* 82254AF0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 82254AF0h case    0:*/		return 0x82254AF4;
		  /* 82254AF4h */ case    1:  		/* addi R1, R1, 160 */
		/* 82254AF4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82254AF4h case    1:*/		return 0x82254AF8;
		  /* 82254AF8h */ case    2:  		/* b -1849440 */
		/* 82254AF8h case    2:*/		return 0x82091298;
		/* 82254AF8h case    2:*/		return 0x82254AFC;
		  /* 82254AFCh */ case    3:  		/* nop */
		/* 82254AFCh case    3:*/		cpu::op::nop();
		/* 82254AFCh case    3:*/		return 0x82254B00;
	}
	return 0x82254B00;
} // Block from 82254AF0h-82254B00h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82254B00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254B00);
		  /* 82254B00h */ case    0:  		/* mfspr R12, LR */
		/* 82254B00h case    0:*/		regs.R12 = regs.LR;
		/* 82254B00h case    0:*/		return 0x82254B04;
		  /* 82254B04h */ case    1:  		/* bl -1849532 */
		/* 82254B04h case    1:*/		regs.LR = 0x82254B08; return 0x82091248;
		/* 82254B04h case    1:*/		return 0x82254B08;
		  /* 82254B08h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82254B08h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82254B08h case    2:*/		return 0x82254B0C;
		  /* 82254B0Ch */ case    3:  		/* lwz R11, <#[R3 + 60]> */
		/* 82254B0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000003C) );
		/* 82254B0Ch case    3:*/		return 0x82254B10;
		  /* 82254B10h */ case    4:  		/* mr R31, R3 */
		/* 82254B10h case    4:*/		regs.R31 = regs.R3;
		/* 82254B10h case    4:*/		return 0x82254B14;
		  /* 82254B14h */ case    5:  		/* mr R28, R4 */
		/* 82254B14h case    5:*/		regs.R28 = regs.R4;
		/* 82254B14h case    5:*/		return 0x82254B18;
		  /* 82254B18h */ case    6:  		/* mr R30, R5 */
		/* 82254B18h case    6:*/		regs.R30 = regs.R5;
		/* 82254B18h case    6:*/		return 0x82254B1C;
		  /* 82254B1Ch */ case    7:  		/* mr R29, R6 */
		/* 82254B1Ch case    7:*/		regs.R29 = regs.R6;
		/* 82254B1Ch case    7:*/		return 0x82254B20;
		  /* 82254B20h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 82254B20h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82254B20h case    8:*/		return 0x82254B24;
		  /* 82254B24h */ case    9:  		/* bc 4, CR6_EQ, 32 */
		/* 82254B24h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82254B44;  }
		/* 82254B24h case    9:*/		return 0x82254B28;
		  /* 82254B28h */ case   10:  		/* lwz R11, <#[R6 + 1508]> */
		/* 82254B28h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x000005E4) );
		/* 82254B28h case   10:*/		return 0x82254B2C;
		  /* 82254B2Ch */ case   11:  		/* li R4, 0 */
		/* 82254B2Ch case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82254B2Ch case   11:*/		return 0x82254B30;
		  /* 82254B30h */ case   12:  		/* addi R5, R11, -1 */
		/* 82254B30h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 82254B30h case   12:*/		return 0x82254B34;
		  /* 82254B34h */ case   13:  		/* stw R5, <#[R6 + 1508]> */
		/* 82254B34h case   13:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R6 + 0x000005E4) );
		/* 82254B34h case   13:*/		return 0x82254B38;
		  /* 82254B38h */ case   14:  		/* lwz R3, <#[R30 + 172]> */
		/* 82254B38h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000000AC) );
		/* 82254B38h case   14:*/		return 0x82254B3C;
		  /* 82254B3Ch */ case   15:  		/* bl -64532 */
		/* 82254B3Ch case   15:*/		regs.LR = 0x82254B40; return 0x82244F28;
		/* 82254B3Ch case   15:*/		return 0x82254B40;
		  /* 82254B40h */ case   16:  		/* stw R3, <#[R31 + 60]> */
		/* 82254B40h case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000003C) );
		/* 82254B40h case   16:*/		return 0x82254B44;
	}
	return 0x82254B44;
} // Block from 82254B00h-82254B44h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82254B44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254B44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254B44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254B44);
		  /* 82254B44h */ case    0:  		/* mr R3, R30 */
		/* 82254B44h case    0:*/		regs.R3 = regs.R30;
		/* 82254B44h case    0:*/		return 0x82254B48;
		  /* 82254B48h */ case    1:  		/* bl -126608 */
		/* 82254B48h case    1:*/		regs.LR = 0x82254B4C; return 0x82235CB8;
		/* 82254B48h case    1:*/		return 0x82254B4C;
		  /* 82254B4Ch */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82254B4Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82254B4Ch case    2:*/		return 0x82254B50;
		  /* 82254B50h */ case    3:  		/* bc 12, CR0_EQ, 276 */
		/* 82254B50h case    3:*/		if ( regs.CR[0].eq ) { return 0x82254C64;  }
		/* 82254B50h case    3:*/		return 0x82254B54;
		  /* 82254B54h */ case    4:  		/* lwz R29, <#[R29 + 1452]> */
		/* 82254B54h case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x000005AC) );
		/* 82254B54h case    4:*/		return 0x82254B58;
		  /* 82254B58h */ case    5:  		/* li R4, 964 */
		/* 82254B58h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82254B58h case    5:*/		return 0x82254B5C;
		  /* 82254B5Ch */ case    6:  		/* lwz R24, <#[R31 + 60]> */
		/* 82254B5Ch case    6:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R31 + 0x0000003C) );
		/* 82254B5Ch case    6:*/		return 0x82254B60;
	}
	return 0x82254B60;
} // Block from 82254B44h-82254B60h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82254B60h
// Function '?Advance@InternalHashTableIterator@XGRAPHICS@@IAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254B60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254B60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254B60);
		  /* 82254B60h */ case    0:  		/* mr R3, R29 */
		/* 82254B60h case    0:*/		regs.R3 = regs.R29;
		/* 82254B60h case    0:*/		return 0x82254B64;
		  /* 82254B64h */ case    1:  		/* bl -231084 */
		/* 82254B64h case    1:*/		regs.LR = 0x82254B68; return 0x8221C4B8;
		/* 82254B64h case    1:*/		return 0x82254B68;
		  /* 82254B68h */ case    2:  		/* mr R11, R3 */
		/* 82254B68h case    2:*/		regs.R11 = regs.R3;
		/* 82254B68h case    2:*/		return 0x82254B6C;
		  /* 82254B6Ch */ case    3:  		/* addic. R3, R3, 4 */
		/* 82254B6Ch case    3:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82254B6Ch case    3:*/		return 0x82254B70;
		  /* 82254B70h */ case    4:  		/* stw R29, <#[R11]> */
		/* 82254B70h case    4:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82254B70h case    4:*/		return 0x82254B74;
		  /* 82254B74h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 82254B74h case    5:*/		if ( regs.CR[0].eq ) { return 0x82254B84;  }
		/* 82254B74h case    5:*/		return 0x82254B78;
		  /* 82254B78h */ case    6:  		/* lwz R4, <#[R30 + 12]> */
		/* 82254B78h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000000C) );
		/* 82254B78h case    6:*/		return 0x82254B7C;
		  /* 82254B7Ch */ case    7:  		/* bl 9724 */
		/* 82254B7Ch case    7:*/		regs.LR = 0x82254B80; return 0x82257178;
		/* 82254B7Ch case    7:*/		return 0x82254B80;
		  /* 82254B80h */ case    8:  		/* b 8 */
		/* 82254B80h case    8:*/		return 0x82254B88;
		/* 82254B80h case    8:*/		return 0x82254B84;
	}
	return 0x82254B84;
} // Block from 82254B60h-82254B84h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82254B84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254B84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254B84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254B84);
		  /* 82254B84h */ case    0:  		/* li R3, 0 */
		/* 82254B84h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82254B84h case    0:*/		return 0x82254B88;
	}
	return 0x82254B88;
} // Block from 82254B84h-82254B88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82254B88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254B88);
		  /* 82254B88h */ case    0:  		/* stw R3, <#[R31 + 56]> */
		/* 82254B88h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000038) );
		/* 82254B88h case    0:*/		return 0x82254B8C;
		  /* 82254B8Ch */ case    1:  		/* mr R5, R31 */
		/* 82254B8Ch case    1:*/		regs.R5 = regs.R31;
		/* 82254B8Ch case    1:*/		return 0x82254B90;
		  /* 82254B90h */ case    2:  		/* li R4, 0 */
		/* 82254B90h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82254B90h case    2:*/		return 0x82254B94;
		  /* 82254B94h */ case    3:  		/* bl 6148 */
		/* 82254B94h case    3:*/		regs.LR = 0x82254B98; return 0x82256398;
		/* 82254B94h case    3:*/		return 0x82254B98;
		  /* 82254B98h */ case    4:  		/* mr R5, R24 */
		/* 82254B98h case    4:*/		regs.R5 = regs.R24;
		/* 82254B98h case    4:*/		return 0x82254B9C;
		  /* 82254B9Ch */ case    5:  		/* li R4, 1 */
		/* 82254B9Ch case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82254B9Ch case    5:*/		return 0x82254BA0;
		  /* 82254BA0h */ case    6:  		/* lwz R3, <#[R31 + 56]> */
		/* 82254BA0h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000038) );
		/* 82254BA0h case    6:*/		return 0x82254BA4;
		  /* 82254BA4h */ case    7:  		/* bl 6132 */
		/* 82254BA4h case    7:*/		regs.LR = 0x82254BA8; return 0x82256398;
		/* 82254BA4h case    7:*/		return 0x82254BA8;
		  /* 82254BA8h */ case    8:  		/* mr R3, R30 */
		/* 82254BA8h case    8:*/		regs.R3 = regs.R30;
		/* 82254BA8h case    8:*/		return 0x82254BAC;
		  /* 82254BACh */ case    9:  		/* lwz R4, <#[R31 + 56]> */
		/* 82254BACh case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000038) );
		/* 82254BACh case    9:*/		return 0x82254BB0;
		  /* 82254BB0h */ case   10:  		/* bl -124424 */
		/* 82254BB0h case   10:*/		regs.LR = 0x82254BB4; return 0x822365A8;
		/* 82254BB0h case   10:*/		return 0x82254BB4;
		  /* 82254BB4h */ case   11:  		/* lwz R4, <#[R31 + 56]> */
		/* 82254BB4h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000038) );
		/* 82254BB4h case   11:*/		return 0x82254BB8;
		  /* 82254BB8h */ case   12:  		/* lwz R3, <#[R30 + 168]> */
		/* 82254BB8h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000000A8) );
		/* 82254BB8h case   12:*/		return 0x82254BBC;
		  /* 82254BBCh */ case   13:  		/* bl 17268 */
		/* 82254BBCh case   13:*/		regs.LR = 0x82254BC0; return 0x82258F30;
		/* 82254BBCh case   13:*/		return 0x82254BC0;
		  /* 82254BC0h */ case   14:  		/* lwz R3, <#[R30 + 96]> */
		/* 82254BC0h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000060) );
		/* 82254BC0h case   14:*/		return 0x82254BC4;
		  /* 82254BC4h */ case   15:  		/* lwz R4, <#[R3 + 4]> */
		/* 82254BC4h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82254BC4h case   15:*/		return 0x82254BC8;
		  /* 82254BC8h */ case   16:  		/* lwz R30, <#[R31 + 56]> */
		/* 82254BC8h case   16:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000038) );
		/* 82254BC8h case   16:*/		return 0x82254BCC;
		  /* 82254BCCh */ case   17:  		/* bl -4364 */
		/* 82254BCCh case   17:*/		regs.LR = 0x82254BD0; return 0x82253AC0;
		/* 82254BCCh case   17:*/		return 0x82254BD0;
		  /* 82254BD0h */ case   18:  		/* lis R11, -32252 */
		/* 82254BD0h case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82254BD0h case   18:*/		return 0x82254BD4;
		  /* 82254BD4h */ case   19:  		/* stw R30, <#[R3]> */
		/* 82254BD4h case   19:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82254BD4h case   19:*/		return 0x82254BD8;
		  /* 82254BD8h */ case   20:  		/* lis R10, -32253 */
		/* 82254BD8h case   20:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8203);
		/* 82254BD8h case   20:*/		return 0x82254BDC;
		  /* 82254BDCh */ case   21:  		/* stw R28, <#[R1 + 84]> */
		/* 82254BDCh case   21:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 82254BDCh case   21:*/		return 0x82254BE0;
		  /* 82254BE0h */ case   22:  		/* lis R9, -32252 */
		/* 82254BE0h case   22:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 82254BE0h case   22:*/		return 0x82254BE4;
		  /* 82254BE4h */ case   23:  		/* lis R8, -32252 */
		/* 82254BE4h case   23:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8204);
		/* 82254BE4h case   23:*/		return 0x82254BE8;
		  /* 82254BE8h */ case   24:  		/* li R30, 0 */
		/* 82254BE8h case   24:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82254BE8h case   24:*/		return 0x82254BEC;
		  /* 82254BECh */ case   25:  		/* lwz R11, <#[R11 + 26976]> */
		/* 82254BECh case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00006960) );
		/* 82254BECh case   25:*/		return 0x82254BF0;
		  /* 82254BF0h */ case   26:  		/* addi R28, R10, 27460 */
		/* 82254BF0h case   26:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R10,0x6B44);
		/* 82254BF0h case   26:*/		return 0x82254BF4;
		  /* 82254BF4h */ case   27:  		/* stw R11, <#[R1 + 80]> */
		/* 82254BF4h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82254BF4h case   27:*/		return 0x82254BF8;
		  /* 82254BF8h */ case   28:  		/* lis R11, -32252 */
		/* 82254BF8h case   28:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82254BF8h case   28:*/		return 0x82254BFC;
		  /* 82254BFCh */ case   29:  		/* addi R29, R11, 27112 */
		/* 82254BFCh case   29:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x69E8);
		/* 82254BFCh case   29:*/		return 0x82254C00;
		  /* 82254C00h */ case   30:  		/* addi R27, R9, 27080 */
		/* 82254C00h case   30:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R9,0x69C8);
		/* 82254C00h case   30:*/		return 0x82254C04;
		  /* 82254C04h */ case   31:  		/* addi R26, R8, 26984 */
		/* 82254C04h case   31:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R8,0x6968);
		/* 82254C04h case   31:*/		return 0x82254C08;
		  /* 82254C08h */ case   32:  		/* addi R11, R1, 84 */
		/* 82254C08h case   32:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x54);
		/* 82254C08h case   32:*/		return 0x82254C0C;
		  /* 82254C0Ch */ case   33:  		/* lbzx R25, <#[R30 + R11]> */
		/* 82254C0Ch case   33:*/		cpu::mem::load8z( regs, &regs.R25, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 82254C0Ch case   33:*/		return 0x82254C10;
		  /* 82254C10h */ case   34:  		/* cmplwi CR6, R25, 8 */
		/* 82254C10h case   34:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000008);
		/* 82254C10h case   34:*/		return 0x82254C14;
		  /* 82254C14h */ case   35:  		/* bc 12, CR6_LT, 28 */
		/* 82254C14h case   35:*/		if ( regs.CR[6].lt ) { return 0x82254C30;  }
		/* 82254C14h case   35:*/		return 0x82254C18;
	}
	return 0x82254C18;
} // Block from 82254B88h-82254C18h (36 instructions)

//////////////////////////////////////////////////////
// Block at 82254C18h
// Function '?Reset@InternalHashTableIterator@XGRAPHICS@@IAAXPBVInternalHashTable@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254C18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254C18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254C18);
		  /* 82254C18h */ case    0:  		/* mr R6, R26 */
		/* 82254C18h case    0:*/		regs.R6 = regs.R26;
		/* 82254C18h case    0:*/		return 0x82254C1C;
		  /* 82254C1Ch */ case    1:  		/* mr R5, R27 */
		/* 82254C1Ch case    1:*/		regs.R5 = regs.R27;
		/* 82254C1Ch case    1:*/		return 0x82254C20;
		  /* 82254C20h */ case    2:  		/* mr R4, R28 */
		/* 82254C20h case    2:*/		regs.R4 = regs.R28;
		/* 82254C20h case    2:*/		return 0x82254C24;
		  /* 82254C24h */ case    3:  		/* li R7, 361 */
		/* 82254C24h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x169);
		/* 82254C24h case    3:*/		return 0x82254C28;
		  /* 82254C28h */ case    4:  		/* li R3, 0 */
		/* 82254C28h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82254C28h case    4:*/		return 0x82254C2C;
		  /* 82254C2Ch */ case    5:  		/* bl -1036324 */
		/* 82254C2Ch case    5:*/		regs.LR = 0x82254C30; return 0x82157C08;
		/* 82254C2Ch case    5:*/		return 0x82254C30;
	}
	return 0x82254C30;
} // Block from 82254C18h-82254C30h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82254C30h
// Function '?Make@VRegInfo@XGRAPHICS@@SAPAV12@HW4RegType@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254C30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254C30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254C30);
		  /* 82254C30h */ case    0:  		/* rlwinm R11, R25, 2, 0, 29 */
		/* 82254C30h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R25);
		/* 82254C30h case    0:*/		return 0x82254C34;
		  /* 82254C34h */ case    1:  		/* addi R10, R1, 80 */
		/* 82254C34h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82254C34h case    1:*/		return 0x82254C38;
		  /* 82254C38h */ case    2:  		/* lwzx R11, <#[R11 + R29]> */
		/* 82254C38h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82254C38h case    2:*/		return 0x82254C3C;
		  /* 82254C3Ch */ case    3:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 82254C3Ch case    3:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82254C3Ch case    3:*/		return 0x82254C40;
		  /* 82254C40h */ case    4:  		/* stbx R11, <#[R30 + R10]> */
		/* 82254C40h case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + regs.R10 + 0x00000000) );
		/* 82254C40h case    4:*/		return 0x82254C44;
		  /* 82254C44h */ case    5:  		/* addi R30, R30, 1 */
		/* 82254C44h case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82254C44h case    5:*/		return 0x82254C48;
		  /* 82254C48h */ case    6:  		/* cmpwi CR6, R30, 4 */
		/* 82254C48h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 82254C48h case    6:*/		return 0x82254C4C;
		  /* 82254C4Ch */ case    7:  		/* bc 12, CR6_LT, -68 */
		/* 82254C4Ch case    7:*/		if ( regs.CR[6].lt ) { return 0x82254C08;  }
		/* 82254C4Ch case    7:*/		return 0x82254C50;
	}
	return 0x82254C50;
} // Block from 82254C30h-82254C50h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82254C50h
// Function '?GetReplacingTempIfNecessary@ExportValue@XGRAPHICS@@UAAPAVVRegInfo@2@TSwizzleOrMaskInfo@2@PAVCFG@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254C50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254C50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254C50);
		  /* 82254C50h */ case    0:  		/* lwz R11, <#[R31 + 56]> */
		/* 82254C50h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 82254C50h case    0:*/		return 0x82254C54;
		  /* 82254C54h */ case    1:  		/* mr R3, R24 */
		/* 82254C54h case    1:*/		regs.R3 = regs.R24;
		/* 82254C54h case    1:*/		return 0x82254C58;
		  /* 82254C58h */ case    2:  		/* lwz R10, <#[R1 + 80]> */
		/* 82254C58h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82254C58h case    2:*/		return 0x82254C5C;
		  /* 82254C5Ch */ case    3:  		/* stw R10, <#[R11 + 128]> */
		/* 82254C5Ch case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000080) );
		/* 82254C5Ch case    3:*/		return 0x82254C60;
		  /* 82254C60h */ case    4:  		/* b 8 */
		/* 82254C60h case    4:*/		return 0x82254C68;
		/* 82254C60h case    4:*/		return 0x82254C64;
	}
	return 0x82254C64;
} // Block from 82254C50h-82254C64h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82254C64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254C64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254C64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254C64);
		  /* 82254C64h */ case    0:  		/* mr R3, R31 */
		/* 82254C64h case    0:*/		regs.R3 = regs.R31;
		/* 82254C64h case    0:*/		return 0x82254C68;
	}
	return 0x82254C68;
} // Block from 82254C64h-82254C68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82254C68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254C68);
		  /* 82254C68h */ case    0:  		/* addi R1, R1, 160 */
		/* 82254C68h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82254C68h case    0:*/		return 0x82254C6C;
		  /* 82254C6Ch */ case    1:  		/* b -1849812 */
		/* 82254C6Ch case    1:*/		return 0x82091298;
		/* 82254C6Ch case    1:*/		return 0x82254C70;
	}
	return 0x82254C70;
} // Block from 82254C68h-82254C70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82254C70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254C70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254C70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254C70);
		  /* 82254C70h */ case    0:  		/* mfspr R12, LR */
		/* 82254C70h case    0:*/		regs.R12 = regs.LR;
		/* 82254C70h case    0:*/		return 0x82254C74;
		  /* 82254C74h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82254C74h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82254C74h case    1:*/		return 0x82254C78;
		  /* 82254C78h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82254C78h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82254C78h case    2:*/		return 0x82254C7C;
		  /* 82254C7Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82254C7Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82254C7Ch case    3:*/		return 0x82254C80;
		  /* 82254C80h */ case    4:  		/* lis R11, -32252 */
		/* 82254C80h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82254C80h case    4:*/		return 0x82254C84;
		  /* 82254C84h */ case    5:  		/* lwz R31, <#[R3 + 44]> */
		/* 82254C84h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x0000002C) );
		/* 82254C84h case    5:*/		return 0x82254C88;
		  /* 82254C88h */ case    6:  		/* addi R11, R11, 27280 */
		/* 82254C88h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6A90);
		/* 82254C88h case    6:*/		return 0x82254C8C;
		  /* 82254C8Ch */ case    7:  		/* cmplwi CR6, R31, 0 */
		/* 82254C8Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82254C8Ch case    7:*/		return 0x82254C90;
		  /* 82254C90h */ case    8:  		/* stw R11, <#[R3]> */
		/* 82254C90h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82254C90h case    8:*/		return 0x82254C94;
		  /* 82254C94h */ case    9:  		/* bc 12, CR6_EQ, 24 */
		/* 82254C94h case    9:*/		if ( regs.CR[6].eq ) { return 0x82254CAC;  }
		/* 82254C94h case    9:*/		return 0x82254C98;
		  /* 82254C98h */ case   10:  		/* mr R3, R31 */
		/* 82254C98h case   10:*/		regs.R3 = regs.R31;
		/* 82254C98h case   10:*/		return 0x82254C9C;
		  /* 82254C9Ch */ case   11:  		/* bl -2452 */
		/* 82254C9Ch case   11:*/		regs.LR = 0x82254CA0; return 0x82254308;
		/* 82254C9Ch case   11:*/		return 0x82254CA0;
		  /* 82254CA0h */ case   12:  		/* addi R4, R31, -4 */
		/* 82254CA0h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0xFFFFFFFC);
		/* 82254CA0h case   12:*/		return 0x82254CA4;
		  /* 82254CA4h */ case   13:  		/* lwz R3, <#[R31 - 4]> */
		/* 82254CA4h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0xFFFFFFFC) );
		/* 82254CA4h case   13:*/		return 0x82254CA8;
		  /* 82254CA8h */ case   14:  		/* bl -231016 */
		/* 82254CA8h case   14:*/		regs.LR = 0x82254CAC; return 0x8221C640;
		/* 82254CA8h case   14:*/		return 0x82254CAC;
	}
	return 0x82254CAC;
} // Block from 82254C70h-82254CACh (15 instructions)

//////////////////////////////////////////////////////
// Block at 82254CACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254CAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254CAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254CAC);
		  /* 82254CACh */ case    0:  		/* addi R1, R1, 96 */
		/* 82254CACh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82254CACh case    0:*/		return 0x82254CB0;
		  /* 82254CB0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82254CB0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82254CB0h case    1:*/		return 0x82254CB4;
		  /* 82254CB4h */ case    2:  		/* mtspr LR, R12 */
		/* 82254CB4h case    2:*/		regs.LR = regs.R12;
		/* 82254CB4h case    2:*/		return 0x82254CB8;
		  /* 82254CB8h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82254CB8h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82254CB8h case    3:*/		return 0x82254CBC;
		  /* 82254CBCh */ case    4:  		/* bclr 20, CR0_LT */
		/* 82254CBCh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82254CBCh case    4:*/		return 0x82254CC0;
	}
	return 0x82254CC0;
} // Block from 82254CACh-82254CC0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82254CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254CC0);
		  /* 82254CC0h */ case    0:  		/* mfspr R12, LR */
		/* 82254CC0h case    0:*/		regs.R12 = regs.LR;
		/* 82254CC0h case    0:*/		return 0x82254CC4;
		  /* 82254CC4h */ case    1:  		/* bl -1849964 */
		/* 82254CC4h case    1:*/		regs.LR = 0x82254CC8; return 0x82091258;
		/* 82254CC4h case    1:*/		return 0x82254CC8;
	}
	return 0x82254CC8;
} // Block from 82254CC0h-82254CC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82254CC8h
// Function '?GetReplacingTempIfNecessary@Interpolator@XGRAPHICS@@UAAPAVVRegInfo@2@TSwizzleOrMaskInfo@2@PAVCFG@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254CC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254CC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254CC8);
		  /* 82254CC8h */ case    0:  		/* stwu R1, <#[R1 - 128]> */
		/* 82254CC8h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82254CC8h case    0:*/		return 0x82254CCC;
		  /* 82254CCCh */ case    1:  		/* mr R30, R3 */
		/* 82254CCCh case    1:*/		regs.R30 = regs.R3;
		/* 82254CCCh case    1:*/		return 0x82254CD0;
		  /* 82254CD0h */ case    2:  		/* mr R29, R4 */
		/* 82254CD0h case    2:*/		regs.R29 = regs.R4;
		/* 82254CD0h case    2:*/		return 0x82254CD4;
		  /* 82254CD4h */ case    3:  		/* mr R28, R5 */
		/* 82254CD4h case    3:*/		regs.R28 = regs.R5;
		/* 82254CD4h case    3:*/		return 0x82254CD8;
		  /* 82254CD8h */ case    4:  		/* mr R31, R6 */
		/* 82254CD8h case    4:*/		regs.R31 = regs.R6;
		/* 82254CD8h case    4:*/		return 0x82254CDC;
		  /* 82254CDCh */ case    5:  		/* bl -2428 */
		/* 82254CDCh case    5:*/		regs.LR = 0x82254CE0; return 0x82254360;
		/* 82254CDCh case    5:*/		return 0x82254CE0;
		  /* 82254CE0h */ case    6:  		/* lis R11, -32252 */
		/* 82254CE0h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82254CE0h case    6:*/		return 0x82254CE4;
		  /* 82254CE4h */ case    7:  		/* stw R29, <#[R30 + 16]> */
		/* 82254CE4h case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000010) );
		/* 82254CE4h case    7:*/		return 0x82254CE8;
		  /* 82254CE8h */ case    8:  		/* cmpwi CR6, R28, 1 */
		/* 82254CE8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000001);
		/* 82254CE8h case    8:*/		return 0x82254CEC;
		  /* 82254CECh */ case    9:  		/* addi R11, R11, 27144 */
		/* 82254CECh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6A08);
		/* 82254CECh case    9:*/		return 0x82254CF0;
		  /* 82254CF0h */ case   10:  		/* stw R11, <#[R30]> */
		/* 82254CF0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82254CF0h case   10:*/		return 0x82254CF4;
		  /* 82254CF4h */ case   11:  		/* lwz R11, <#[R31 + 1416]> */
		/* 82254CF4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000588) );
		/* 82254CF4h case   11:*/		return 0x82254CF8;
		  /* 82254CF8h */ case   12:  		/* addi R11, R11, 1 */
		/* 82254CF8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82254CF8h case   12:*/		return 0x82254CFC;
		  /* 82254CFCh */ case   13:  		/* stw R11, <#[R31 + 1416]> */
		/* 82254CFCh case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000588) );
		/* 82254CFCh case   13:*/		return 0x82254D00;
		  /* 82254D00h */ case   14:  		/* bc 12, CR6_EQ, 92 */
		/* 82254D00h case   14:*/		if ( regs.CR[6].eq ) { return 0x82254D5C;  }
		/* 82254D00h case   14:*/		return 0x82254D04;
		  /* 82254D04h */ case   15:  		/* cmpwi CR6, R28, 2 */
		/* 82254D04h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000002);
		/* 82254D04h case   15:*/		return 0x82254D08;
		  /* 82254D08h */ case   16:  		/* bc 12, CR6_EQ, 48 */
		/* 82254D08h case   16:*/		if ( regs.CR[6].eq ) { return 0x82254D38;  }
		/* 82254D08h case   16:*/		return 0x82254D0C;
		  /* 82254D0Ch */ case   17:  		/* cmpwi CR6, R28, 3 */
		/* 82254D0Ch case   17:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000003);
		/* 82254D0Ch case   17:*/		return 0x82254D10;
		  /* 82254D10h */ case   18:  		/* bc 4, CR6_EQ, 112 */
		/* 82254D10h case   18:*/		if ( !regs.CR[6].eq ) { return 0x82254D80;  }
		/* 82254D10h case   18:*/		return 0x82254D14;
		  /* 82254D14h */ case   19:  		/* lwz R11, <#[R31 + 1360]> */
		/* 82254D14h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000550) );
		/* 82254D14h case   19:*/		return 0x82254D18;
		  /* 82254D18h */ case   20:  		/* lwz R11, <#[R11 + 36]> */
		/* 82254D18h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82254D18h case   20:*/		return 0x82254D1C;
		  /* 82254D1Ch */ case   21:  		/* cmpw CR6, R29, R11 */
		/* 82254D1Ch case   21:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R11);
		/* 82254D1Ch case   21:*/		return 0x82254D20;
		  /* 82254D20h */ case   22:  		/* bc 12, CR6_LT, 96 */
		/* 82254D20h case   22:*/		if ( regs.CR[6].lt ) { return 0x82254D80;  }
		/* 82254D20h case   22:*/		return 0x82254D24;
		  /* 82254D24h */ case   23:  		/* li R11, 30 */
		/* 82254D24h case   23:*/		cpu::op::li<0>(regs,&regs.R11,0x1E);
		/* 82254D24h case   23:*/		return 0x82254D28;
		  /* 82254D28h */ case   24:  		/* li R4, 1 */
		/* 82254D28h case   24:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82254D28h case   24:*/		return 0x82254D2C;
		  /* 82254D2Ch */ case   25:  		/* stw R11, <#[R31 + 1364]> */
		/* 82254D2Ch case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000554) );
		/* 82254D2Ch case   25:*/		return 0x82254D30;
		  /* 82254D30h */ case   26:  		/* addi R3, R31, 16 */
		/* 82254D30h case   26:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x10);
		/* 82254D30h case   26:*/		return 0x82254D34;
		  /* 82254D34h */ case   27:  		/* bl 82300 */
		/* 82254D34h case   27:*/		regs.LR = 0x82254D38; return 0x82268EB0;
		/* 82254D34h case   27:*/		return 0x82254D38;
	}
	return 0x82254D38;
} // Block from 82254CC8h-82254D38h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82254D38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254D38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254D38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254D38);
		  /* 82254D38h */ case    0:  		/* lwz R11, <#[R31 + 1360]> */
		/* 82254D38h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000550) );
		/* 82254D38h case    0:*/		return 0x82254D3C;
		  /* 82254D3Ch */ case    1:  		/* lwz R11, <#[R11 + 32]> */
		/* 82254D3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 82254D3Ch case    1:*/		return 0x82254D40;
		  /* 82254D40h */ case    2:  		/* cmpw CR6, R29, R11 */
		/* 82254D40h case    2:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R11);
		/* 82254D40h case    2:*/		return 0x82254D44;
		  /* 82254D44h */ case    3:  		/* bc 12, CR6_LT, 60 */
		/* 82254D44h case    3:*/		if ( regs.CR[6].lt ) { return 0x82254D80;  }
		/* 82254D44h case    3:*/		return 0x82254D48;
		  /* 82254D48h */ case    4:  		/* li R11, 28 */
		/* 82254D48h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1C);
		/* 82254D48h case    4:*/		return 0x82254D4C;
		  /* 82254D4Ch */ case    5:  		/* li R4, 1 */
		/* 82254D4Ch case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82254D4Ch case    5:*/		return 0x82254D50;
		  /* 82254D50h */ case    6:  		/* stw R11, <#[R31 + 1364]> */
		/* 82254D50h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000554) );
		/* 82254D50h case    6:*/		return 0x82254D54;
		  /* 82254D54h */ case    7:  		/* addi R3, R31, 16 */
		/* 82254D54h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x10);
		/* 82254D54h case    7:*/		return 0x82254D58;
	}
	return 0x82254D58;
} // Block from 82254D38h-82254D58h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82254D58h
// Function '?Push@DefStack@XGRAPHICS@@QAAXHPAUCurrentValue@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254D58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254D58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254D58);
		  /* 82254D58h */ case    0:  		/* bl 82264 */
		/* 82254D58h case    0:*/		regs.LR = 0x82254D5C; return 0x82268EB0;
		/* 82254D58h case    0:*/		return 0x82254D5C;
	}
	return 0x82254D5C;
} // Block from 82254D58h-82254D5Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82254D5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254D5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254D5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254D5C);
		  /* 82254D5Ch */ case    0:  		/* lwz R11, <#[R31 + 1360]> */
		/* 82254D5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000550) );
		/* 82254D5Ch case    0:*/		return 0x82254D60;
		  /* 82254D60h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 82254D60h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82254D60h case    1:*/		return 0x82254D64;
		  /* 82254D64h */ case    2:  		/* cmpw CR6, R29, R11 */
		/* 82254D64h case    2:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R11);
		/* 82254D64h case    2:*/		return 0x82254D68;
		  /* 82254D68h */ case    3:  		/* bc 12, CR6_LT, 24 */
		/* 82254D68h case    3:*/		if ( regs.CR[6].lt ) { return 0x82254D80;  }
		/* 82254D68h case    3:*/		return 0x82254D6C;
		  /* 82254D6Ch */ case    4:  		/* li R11, 29 */
		/* 82254D6Ch case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1D);
		/* 82254D6Ch case    4:*/		return 0x82254D70;
		  /* 82254D70h */ case    5:  		/* li R4, 1 */
		/* 82254D70h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82254D70h case    5:*/		return 0x82254D74;
		  /* 82254D74h */ case    6:  		/* stw R11, <#[R31 + 1364]> */
		/* 82254D74h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000554) );
		/* 82254D74h case    6:*/		return 0x82254D78;
		  /* 82254D78h */ case    7:  		/* addi R3, R31, 16 */
		/* 82254D78h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x10);
		/* 82254D78h case    7:*/		return 0x82254D7C;
		  /* 82254D7Ch */ case    8:  		/* bl 82228 */
		/* 82254D7Ch case    8:*/		regs.LR = 0x82254D80; return 0x82268EB0;
		/* 82254D7Ch case    8:*/		return 0x82254D80;
	}
	return 0x82254D80;
} // Block from 82254D5Ch-82254D80h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82254D80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254D80);
		  /* 82254D80h */ case    0:  		/* lwz R29, <#[R31 + 1452]> */
		/* 82254D80h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x000005AC) );
		/* 82254D80h case    0:*/		return 0x82254D84;
		  /* 82254D84h */ case    1:  		/* li R4, 964 */
		/* 82254D84h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82254D84h case    1:*/		return 0x82254D88;
		  /* 82254D88h */ case    2:  		/* mr R3, R29 */
		/* 82254D88h case    2:*/		regs.R3 = regs.R29;
		/* 82254D88h case    2:*/		return 0x82254D8C;
		  /* 82254D8Ch */ case    3:  		/* bl -231636 */
		/* 82254D8Ch case    3:*/		regs.LR = 0x82254D90; return 0x8221C4B8;
		/* 82254D8Ch case    3:*/		return 0x82254D90;
		  /* 82254D90h */ case    4:  		/* mr R11, R3 */
		/* 82254D90h case    4:*/		regs.R11 = regs.R3;
		/* 82254D90h case    4:*/		return 0x82254D94;
		  /* 82254D94h */ case    5:  		/* addic. R3, R3, 4 */
		/* 82254D94h case    5:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82254D94h case    5:*/		return 0x82254D98;
		  /* 82254D98h */ case    6:  		/* stw R29, <#[R11]> */
		/* 82254D98h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82254D98h case    6:*/		return 0x82254D9C;
		  /* 82254D9Ch */ case    7:  		/* bc 12, CR0_EQ, 24 */
		/* 82254D9Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x82254DB4;  }
		/* 82254D9Ch case    7:*/		return 0x82254DA0;
		  /* 82254DA0h */ case    8:  		/* mr R5, R31 */
		/* 82254DA0h case    8:*/		regs.R5 = regs.R31;
		/* 82254DA0h case    8:*/		return 0x82254DA4;
		  /* 82254DA4h */ case    9:  		/* mr R4, R30 */
		/* 82254DA4h case    9:*/		regs.R4 = regs.R30;
		/* 82254DA4h case    9:*/		return 0x82254DA8;
		  /* 82254DA8h */ case   10:  		/* bl 9696 */
		/* 82254DA8h case   10:*/		regs.LR = 0x82254DAC; return 0x82257388;
		/* 82254DA8h case   10:*/		return 0x82254DAC;
		  /* 82254DACh */ case   11:  		/* mr R29, R3 */
		/* 82254DACh case   11:*/		regs.R29 = regs.R3;
		/* 82254DACh case   11:*/		return 0x82254DB0;
		  /* 82254DB0h */ case   12:  		/* b 8 */
		/* 82254DB0h case   12:*/		return 0x82254DB8;
		/* 82254DB0h case   12:*/		return 0x82254DB4;
	}
	return 0x82254DB4;
} // Block from 82254D80h-82254DB4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82254DB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254DB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254DB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254DB4);
		  /* 82254DB4h */ case    0:  		/* li R29, 0 */
		/* 82254DB4h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82254DB4h case    0:*/		return 0x82254DB8;
	}
	return 0x82254DB8;
} // Block from 82254DB4h-82254DB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82254DB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254DB8);
		  /* 82254DB8h */ case    0:  		/* lwz R11, <#[R31 + 2736]> */
		/* 82254DB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000AB0) );
		/* 82254DB8h case    0:*/		return 0x82254DBC;
		  /* 82254DBCh */ case    1:  		/* mr R4, R29 */
		/* 82254DBCh case    1:*/		regs.R4 = regs.R29;
		/* 82254DBCh case    1:*/		return 0x82254DC0;
	}
	return 0x82254DC0;
} // Block from 82254DB8h-82254DC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82254DC0h
// Function '?PopDef@VRegInfo@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254DC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254DC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254DC0);
		  /* 82254DC0h */ case    0:  		/* lwz R3, <#[R11 + 164]> */
		/* 82254DC0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000000A4) );
		/* 82254DC0h case    0:*/		return 0x82254DC4;
		  /* 82254DC4h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 82254DC4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82254DC4h case    1:*/		return 0x82254DC8;
		  /* 82254DC8h */ case    2:  		/* lwz R11, <#[R11 + 40]> */
		/* 82254DC8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82254DC8h case    2:*/		return 0x82254DCC;
		  /* 82254DCCh */ case    3:  		/* mtspr CTR, R11 */
		/* 82254DCCh case    3:*/		regs.CTR = regs.R11;
		/* 82254DCCh case    3:*/		return 0x82254DD0;
		  /* 82254DD0h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 82254DD0h case    4:*/		if ( 1 ) { regs.LR = 0x82254DD4; return (uint32)regs.CTR; }
		/* 82254DD0h case    4:*/		return 0x82254DD4;
		  /* 82254DD4h */ case    5:  		/* mr R5, R30 */
		/* 82254DD4h case    5:*/		regs.R5 = regs.R30;
		/* 82254DD4h case    5:*/		return 0x82254DD8;
		  /* 82254DD8h */ case    6:  		/* li R4, 0 */
		/* 82254DD8h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82254DD8h case    6:*/		return 0x82254DDC;
		  /* 82254DDCh */ case    7:  		/* mr R3, R29 */
		/* 82254DDCh case    7:*/		regs.R3 = regs.R29;
		/* 82254DDCh case    7:*/		return 0x82254DE0;
		  /* 82254DE0h */ case    8:  		/* bl 5560 */
		/* 82254DE0h case    8:*/		regs.LR = 0x82254DE4; return 0x82256398;
		/* 82254DE0h case    8:*/		return 0x82254DE4;
		  /* 82254DE4h */ case    9:  		/* mr R4, R29 */
		/* 82254DE4h case    9:*/		regs.R4 = regs.R29;
		/* 82254DE4h case    9:*/		return 0x82254DE8;
	}
	return 0x82254DE8;
} // Block from 82254DC0h-82254DE8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82254DE8h
// Function '?PushDef@VRegInfo@XGRAPHICS@@QAAXHPAUCurrentValue@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254DE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254DE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254DE8);
		  /* 82254DE8h */ case    0:  		/* mr R3, R30 */
		/* 82254DE8h case    0:*/		regs.R3 = regs.R30;
		/* 82254DE8h case    0:*/		return 0x82254DEC;
		  /* 82254DECh */ case    1:  		/* bl -2436 */
		/* 82254DECh case    1:*/		regs.LR = 0x82254DF0; return 0x82254468;
		/* 82254DECh case    1:*/		return 0x82254DF0;
		  /* 82254DF0h */ case    2:  		/* mr R3, R30 */
		/* 82254DF0h case    2:*/		regs.R3 = regs.R30;
		/* 82254DF0h case    2:*/		return 0x82254DF4;
		  /* 82254DF4h */ case    3:  		/* addi R1, R1, 128 */
		/* 82254DF4h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82254DF4h case    3:*/		return 0x82254DF8;
		  /* 82254DF8h */ case    4:  		/* b -1850192 */
		/* 82254DF8h case    4:*/		return 0x820912A8;
		/* 82254DF8h case    4:*/		return 0x82254DFC;
		  /* 82254DFCh */ case    5:  		/* nop */
		/* 82254DFCh case    5:*/		cpu::op::nop();
		/* 82254DFCh case    5:*/		return 0x82254E00;
	}
	return 0x82254E00;
} // Block from 82254DE8h-82254E00h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82254E00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254E00);
		  /* 82254E00h */ case    0:  		/* mfspr R12, LR */
		/* 82254E00h case    0:*/		regs.R12 = regs.LR;
		/* 82254E00h case    0:*/		return 0x82254E04;
		  /* 82254E04h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82254E04h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82254E04h case    1:*/		return 0x82254E08;
		  /* 82254E08h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82254E08h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82254E08h case    2:*/		return 0x82254E0C;
		  /* 82254E0Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82254E0Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82254E0Ch case    3:*/		return 0x82254E10;
		  /* 82254E10h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82254E10h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82254E10h case    4:*/		return 0x82254E14;
		  /* 82254E14h */ case    5:  		/* mr R31, R3 */
		/* 82254E14h case    5:*/		regs.R31 = regs.R3;
		/* 82254E14h case    5:*/		return 0x82254E18;
	}
	return 0x82254E18;
} // Block from 82254E00h-82254E18h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82254E18h
// Function '??1DefStack@XGRAPHICS@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254E18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254E18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254E18);
		  /* 82254E18h */ case    0:  		/* mr R30, R6 */
		/* 82254E18h case    0:*/		regs.R30 = regs.R6;
		/* 82254E18h case    0:*/		return 0x82254E1C;
		  /* 82254E1Ch */ case    1:  		/* bl -2748 */
		/* 82254E1Ch case    1:*/		regs.LR = 0x82254E20; return 0x82254360;
		/* 82254E1Ch case    1:*/		return 0x82254E20;
		  /* 82254E20h */ case    2:  		/* lis R11, -32252 */
		/* 82254E20h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82254E20h case    2:*/		return 0x82254E24;
		  /* 82254E24h */ case    3:  		/* mr R3, R31 */
		/* 82254E24h case    3:*/		regs.R3 = regs.R31;
		/* 82254E24h case    3:*/		return 0x82254E28;
		  /* 82254E28h */ case    4:  		/* addi R11, R11, 27388 */
		/* 82254E28h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6AFC);
		/* 82254E28h case    4:*/		return 0x82254E2C;
		  /* 82254E2Ch */ case    5:  		/* stw R11, <#[R31]> */
		/* 82254E2Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82254E2Ch case    5:*/		return 0x82254E30;
		  /* 82254E30h */ case    6:  		/* lwz R11, <#[R30 + 1412]> */
		/* 82254E30h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000584) );
		/* 82254E30h case    6:*/		return 0x82254E34;
		  /* 82254E34h */ case    7:  		/* stw R11, <#[R31 + 16]> */
		/* 82254E34h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82254E34h case    7:*/		return 0x82254E38;
		  /* 82254E38h */ case    8:  		/* stw R11, <#[R31 + 48]> */
		/* 82254E38h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82254E38h case    8:*/		return 0x82254E3C;
		  /* 82254E3Ch */ case    9:  		/* lwz R11, <#[R30 + 1412]> */
		/* 82254E3Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000584) );
		/* 82254E3Ch case    9:*/		return 0x82254E40;
		  /* 82254E40h */ case   10:  		/* addi R11, R11, 1 */
		/* 82254E40h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82254E40h case   10:*/		return 0x82254E44;
		  /* 82254E44h */ case   11:  		/* stw R11, <#[R30 + 1412]> */
		/* 82254E44h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000584) );
		/* 82254E44h case   11:*/		return 0x82254E48;
		  /* 82254E48h */ case   12:  		/* addi R1, R1, 112 */
		/* 82254E48h case   12:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82254E48h case   12:*/		return 0x82254E4C;
		  /* 82254E4Ch */ case   13:  		/* lwz R12, <#[R1 - 8]> */
		/* 82254E4Ch case   13:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82254E4Ch case   13:*/		return 0x82254E50;
		  /* 82254E50h */ case   14:  		/* mtspr LR, R12 */
		/* 82254E50h case   14:*/		regs.LR = regs.R12;
		/* 82254E50h case   14:*/		return 0x82254E54;
		  /* 82254E54h */ case   15:  		/* ld R30, <#[R1 - 24]> */
		/* 82254E54h case   15:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82254E54h case   15:*/		return 0x82254E58;
		  /* 82254E58h */ case   16:  		/* ld R31, <#[R1 - 16]> */
		/* 82254E58h case   16:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82254E58h case   16:*/		return 0x82254E5C;
		  /* 82254E5Ch */ case   17:  		/* bclr 20, CR0_LT */
		/* 82254E5Ch case   17:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82254E5Ch case   17:*/		return 0x82254E60;
	}
	return 0x82254E60;
} // Block from 82254E18h-82254E60h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82254E60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254E60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254E60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254E60);
		  /* 82254E60h */ case    0:  		/* mfspr R12, LR */
		/* 82254E60h case    0:*/		regs.R12 = regs.LR;
		/* 82254E60h case    0:*/		return 0x82254E64;
		  /* 82254E64h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82254E64h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82254E64h case    1:*/		return 0x82254E68;
		  /* 82254E68h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82254E68h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82254E68h case    2:*/		return 0x82254E6C;
		  /* 82254E6Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82254E6Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82254E6Ch case    3:*/		return 0x82254E70;
	}
	return 0x82254E70;
} // Block from 82254E60h-82254E70h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82254E70h
// Function '??0VRegInfo@XGRAPHICS@@IAA@HW4RegType@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254E70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254E70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254E70);
		  /* 82254E70h */ case    0:  		/* mr R31, R3 */
		/* 82254E70h case    0:*/		regs.R31 = regs.R3;
		/* 82254E70h case    0:*/		return 0x82254E74;
		  /* 82254E74h */ case    1:  		/* bl -2836 */
		/* 82254E74h case    1:*/		regs.LR = 0x82254E78; return 0x82254360;
		/* 82254E74h case    1:*/		return 0x82254E78;
		  /* 82254E78h */ case    2:  		/* lis R11, -32252 */
		/* 82254E78h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82254E78h case    2:*/		return 0x82254E7C;
		  /* 82254E7Ch */ case    3:  		/* li R10, 0 */
		/* 82254E7Ch case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82254E7Ch case    3:*/		return 0x82254E80;
		  /* 82254E80h */ case    4:  		/* addi R11, R11, 27180 */
		/* 82254E80h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6A2C);
		/* 82254E80h case    4:*/		return 0x82254E84;
		  /* 82254E84h */ case    5:  		/* stw R10, <#[R31 + 52]> */
		/* 82254E84h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000034) );
		/* 82254E84h case    5:*/		return 0x82254E88;
		  /* 82254E88h */ case    6:  		/* mr R3, R31 */
		/* 82254E88h case    6:*/		regs.R3 = regs.R31;
		/* 82254E88h case    6:*/		return 0x82254E8C;
		  /* 82254E8Ch */ case    7:  		/* stw R11, <#[R31]> */
		/* 82254E8Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82254E8Ch case    7:*/		return 0x82254E90;
		  /* 82254E90h */ case    8:  		/* addi R1, R1, 96 */
		/* 82254E90h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82254E90h case    8:*/		return 0x82254E94;
		  /* 82254E94h */ case    9:  		/* lwz R12, <#[R1 - 8]> */
		/* 82254E94h case    9:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82254E94h case    9:*/		return 0x82254E98;
		  /* 82254E98h */ case   10:  		/* mtspr LR, R12 */
		/* 82254E98h case   10:*/		regs.LR = regs.R12;
		/* 82254E98h case   10:*/		return 0x82254E9C;
		  /* 82254E9Ch */ case   11:  		/* ld R31, <#[R1 - 16]> */
		/* 82254E9Ch case   11:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82254E9Ch case   11:*/		return 0x82254EA0;
		  /* 82254EA0h */ case   12:  		/* bclr 20, CR0_LT */
		/* 82254EA0h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82254EA0h case   12:*/		return 0x82254EA4;
	}
	return 0x82254EA4;
} // Block from 82254E70h-82254EA4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82254EA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254EA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254EA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254EA4);
		  /* 82254EA4h */ case    0:  		/* nop */
		/* 82254EA4h case    0:*/		cpu::op::nop();
		/* 82254EA4h case    0:*/		return 0x82254EA8;
	}
	return 0x82254EA8;
} // Block from 82254EA4h-82254EA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82254EA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254EA8);
		  /* 82254EA8h */ case    0:  		/* mfspr R12, LR */
		/* 82254EA8h case    0:*/		regs.R12 = regs.LR;
		/* 82254EA8h case    0:*/		return 0x82254EAC;
		  /* 82254EACh */ case    1:  		/* bl -1850452 */
		/* 82254EACh case    1:*/		regs.LR = 0x82254EB0; return 0x82091258;
		/* 82254EACh case    1:*/		return 0x82254EB0;
		  /* 82254EB0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82254EB0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82254EB0h case    2:*/		return 0x82254EB4;
		  /* 82254EB4h */ case    3:  		/* mr R31, R3 */
		/* 82254EB4h case    3:*/		regs.R31 = regs.R3;
		/* 82254EB4h case    3:*/		return 0x82254EB8;
		  /* 82254EB8h */ case    4:  		/* mr R30, R6 */
		/* 82254EB8h case    4:*/		regs.R30 = regs.R6;
		/* 82254EB8h case    4:*/		return 0x82254EBC;
		  /* 82254EBCh */ case    5:  		/* bl -2908 */
		/* 82254EBCh case    5:*/		regs.LR = 0x82254EC0; return 0x82254360;
		/* 82254EBCh case    5:*/		return 0x82254EC0;
		  /* 82254EC0h */ case    6:  		/* lis R11, -32252 */
		/* 82254EC0h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82254EC0h case    6:*/		return 0x82254EC4;
		  /* 82254EC4h */ case    7:  		/* lwz R5, <#[R31 + 12]> */
		/* 82254EC4h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 82254EC4h case    7:*/		return 0x82254EC8;
		  /* 82254EC8h */ case    8:  		/* li R29, 0 */
		/* 82254EC8h case    8:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82254EC8h case    8:*/		return 0x82254ECC;
		  /* 82254ECCh */ case    9:  		/* lwz R4, <#[R31 + 32]> */
		/* 82254ECCh case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000020) );
		/* 82254ECCh case    9:*/		return 0x82254ED0;
		  /* 82254ED0h */ case   10:  		/* addi R11, R11, 27216 */
		/* 82254ED0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6A50);
		/* 82254ED0h case   10:*/		return 0x82254ED4;
		  /* 82254ED4h */ case   11:  		/* stw R29, <#[R31 + 48]> */
		/* 82254ED4h case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000030) );
		/* 82254ED4h case   11:*/		return 0x82254ED8;
		  /* 82254ED8h */ case   12:  		/* mr R6, R31 */
		/* 82254ED8h case   12:*/		regs.R6 = regs.R31;
		/* 82254ED8h case   12:*/		return 0x82254EDC;
		  /* 82254EDCh */ case   13:  		/* stw R11, <#[R31]> */
		/* 82254EDCh case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82254EDCh case   13:*/		return 0x82254EE0;
		  /* 82254EE0h */ case   14:  		/* stw R29, <#[R31 + 52]> */
		/* 82254EE0h case   14:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000034) );
		/* 82254EE0h case   14:*/		return 0x82254EE4;
		  /* 82254EE4h */ case   15:  		/* stw R29, <#[R31 + 56]> */
		/* 82254EE4h case   15:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000038) );
		/* 82254EE4h case   15:*/		return 0x82254EE8;
		  /* 82254EE8h */ case   16:  		/* stw R29, <#[R31 + 60]> */
		/* 82254EE8h case   16:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x0000003C) );
		/* 82254EE8h case   16:*/		return 0x82254EEC;
		  /* 82254EECh */ case   17:  		/* lwz R11, <#[R30 + 2736]> */
		/* 82254EECh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000AB0) );
		/* 82254EECh case   17:*/		return 0x82254EF0;
		  /* 82254EF0h */ case   18:  		/* addi R3, R11, 184 */
		/* 82254EF0h case   18:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xB8);
		/* 82254EF0h case   18:*/		return 0x82254EF4;
		  /* 82254EF4h */ case   19:  		/* bl -13292 */
		/* 82254EF4h case   19:*/		regs.LR = 0x82254EF8; return 0x82251B08;
		/* 82254EF4h case   19:*/		return 0x82254EF8;
		  /* 82254EF8h */ case   20:  		/* li R11, 1 */
		/* 82254EF8h case   20:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82254EF8h case   20:*/		return 0x82254EFC;
		  /* 82254EFCh */ case   21:  		/* stw R3, <#[R31 + 16]> */
		/* 82254EFCh case   21:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82254EFCh case   21:*/		return 0x82254F00;
		  /* 82254F00h */ case   22:  		/* stb R11, <#[R31 + 5]> */
		/* 82254F00h case   22:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000005) );
		/* 82254F00h case   22:*/		return 0x82254F04;
		  /* 82254F04h */ case   23:  		/* lbz R11, <#[R30 + 1380]> */
		/* 82254F04h case   23:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000564) );
		/* 82254F04h case   23:*/		return 0x82254F08;
		  /* 82254F08h */ case   24:  		/* cmplwi CR0, R11, 0 */
		/* 82254F08h case   24:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82254F08h case   24:*/		return 0x82254F0C;
		  /* 82254F0Ch */ case   25:  		/* bc 4, CR0_EQ, 104 */
		/* 82254F0Ch case   25:*/		if ( !regs.CR[0].eq ) { return 0x82254F74;  }
		/* 82254F0Ch case   25:*/		return 0x82254F10;
		  /* 82254F10h */ case   26:  		/* lwz R28, <#[R30 + 1452]> */
		/* 82254F10h case   26:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x000005AC) );
		/* 82254F10h case   26:*/		return 0x82254F14;
		  /* 82254F14h */ case   27:  		/* li R4, 964 */
		/* 82254F14h case   27:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82254F14h case   27:*/		return 0x82254F18;
		  /* 82254F18h */ case   28:  		/* mr R3, R28 */
		/* 82254F18h case   28:*/		regs.R3 = regs.R28;
		/* 82254F18h case   28:*/		return 0x82254F1C;
		  /* 82254F1Ch */ case   29:  		/* bl -232036 */
		/* 82254F1Ch case   29:*/		regs.LR = 0x82254F20; return 0x8221C4B8;
		/* 82254F1Ch case   29:*/		return 0x82254F20;
		  /* 82254F20h */ case   30:  		/* mr R11, R3 */
		/* 82254F20h case   30:*/		regs.R11 = regs.R3;
		/* 82254F20h case   30:*/		return 0x82254F24;
		  /* 82254F24h */ case   31:  		/* addic. R3, R3, 4 */
		/* 82254F24h case   31:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82254F24h case   31:*/		return 0x82254F28;
		  /* 82254F28h */ case   32:  		/* stw R28, <#[R11]> */
		/* 82254F28h case   32:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82254F28h case   32:*/		return 0x82254F2C;
		  /* 82254F2Ch */ case   33:  		/* bc 12, CR0_EQ, 16 */
		/* 82254F2Ch case   33:*/		if ( regs.CR[0].eq ) { return 0x82254F3C;  }
		/* 82254F2Ch case   33:*/		return 0x82254F30;
		  /* 82254F30h */ case   34:  		/* mr R4, R30 */
		/* 82254F30h case   34:*/		regs.R4 = regs.R30;
		/* 82254F30h case   34:*/		return 0x82254F34;
		  /* 82254F34h */ case   35:  		/* bl 9636 */
		/* 82254F34h case   35:*/		regs.LR = 0x82254F38; return 0x822574D8;
		/* 82254F34h case   35:*/		return 0x82254F38;
		  /* 82254F38h */ case   36:  		/* mr R29, R3 */
		/* 82254F38h case   36:*/		regs.R29 = regs.R3;
		/* 82254F38h case   36:*/		return 0x82254F3C;
	}
	return 0x82254F3C;
} // Block from 82254EA8h-82254F3Ch (37 instructions)

//////////////////////////////////////////////////////
// Block at 82254F3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254F3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254F3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254F3C);
		  /* 82254F3Ch */ case    0:  		/* lwz R11, <#[R30 + 2736]> */
		/* 82254F3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000AB0) );
		/* 82254F3Ch case    0:*/		return 0x82254F40;
		  /* 82254F40h */ case    1:  		/* mr R4, R29 */
		/* 82254F40h case    1:*/		regs.R4 = regs.R29;
		/* 82254F40h case    1:*/		return 0x82254F44;
		  /* 82254F44h */ case    2:  		/* lwz R3, <#[R11 + 164]> */
		/* 82254F44h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000000A4) );
		/* 82254F44h case    2:*/		return 0x82254F48;
		  /* 82254F48h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 82254F48h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82254F48h case    3:*/		return 0x82254F4C;
		  /* 82254F4Ch */ case    4:  		/* lwz R11, <#[R11 + 40]> */
		/* 82254F4Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82254F4Ch case    4:*/		return 0x82254F50;
		  /* 82254F50h */ case    5:  		/* mtspr CTR, R11 */
		/* 82254F50h case    5:*/		regs.CTR = regs.R11;
		/* 82254F50h case    5:*/		return 0x82254F54;
		  /* 82254F54h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 82254F54h case    6:*/		if ( 1 ) { regs.LR = 0x82254F58; return (uint32)regs.CTR; }
		/* 82254F54h case    6:*/		return 0x82254F58;
		  /* 82254F58h */ case    7:  		/* mr R5, R31 */
		/* 82254F58h case    7:*/		regs.R5 = regs.R31;
		/* 82254F58h case    7:*/		return 0x82254F5C;
		  /* 82254F5Ch */ case    8:  		/* li R4, 0 */
		/* 82254F5Ch case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82254F5Ch case    8:*/		return 0x82254F60;
		  /* 82254F60h */ case    9:  		/* mr R3, R29 */
		/* 82254F60h case    9:*/		regs.R3 = regs.R29;
		/* 82254F60h case    9:*/		return 0x82254F64;
		  /* 82254F64h */ case   10:  		/* bl 5172 */
		/* 82254F64h case   10:*/		regs.LR = 0x82254F68; return 0x82256398;
		/* 82254F64h case   10:*/		return 0x82254F68;
		  /* 82254F68h */ case   11:  		/* mr R4, R29 */
		/* 82254F68h case   11:*/		regs.R4 = regs.R29;
		/* 82254F68h case   11:*/		return 0x82254F6C;
		  /* 82254F6Ch */ case   12:  		/* mr R3, R31 */
		/* 82254F6Ch case   12:*/		regs.R3 = regs.R31;
		/* 82254F6Ch case   12:*/		return 0x82254F70;
	}
	return 0x82254F70;
} // Block from 82254F3Ch-82254F70h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82254F70h
// Function '?SetGlobal@VRegInfo@XGRAPHICS@@UAAX_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254F70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254F70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254F70);
		  /* 82254F70h */ case    0:  		/* bl -2824 */
		/* 82254F70h case    0:*/		regs.LR = 0x82254F74; return 0x82254468;
		/* 82254F70h case    0:*/		return 0x82254F74;
	}
	return 0x82254F74;
} // Block from 82254F70h-82254F74h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82254F74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254F74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254F74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254F74);
		  /* 82254F74h */ case    0:  		/* mr R3, R31 */
		/* 82254F74h case    0:*/		regs.R3 = regs.R31;
		/* 82254F74h case    0:*/		return 0x82254F78;
	}
	return 0x82254F78;
} // Block from 82254F74h-82254F78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82254F78h
// Function '?BumpDefs@VRegInfo@XGRAPHICS@@QAAXPAVIRInst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254F78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254F78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254F78);
		  /* 82254F78h */ case    0:  		/* addi R1, R1, 128 */
		/* 82254F78h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82254F78h case    0:*/		return 0x82254F7C;
		  /* 82254F7Ch */ case    1:  		/* b -1850580 */
		/* 82254F7Ch case    1:*/		return 0x820912A8;
		/* 82254F7Ch case    1:*/		return 0x82254F80;
	}
	return 0x82254F80;
} // Block from 82254F78h-82254F80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82254F80h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254F80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254F80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254F80);
		  /* 82254F80h */ case    0:  		/* mfspr R12, LR */
		/* 82254F80h case    0:*/		regs.R12 = regs.LR;
		/* 82254F80h case    0:*/		return 0x82254F84;
		  /* 82254F84h */ case    1:  		/* bl -1850672 */
		/* 82254F84h case    1:*/		regs.LR = 0x82254F88; return 0x82091254;
		/* 82254F84h case    1:*/		return 0x82254F88;
		  /* 82254F88h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82254F88h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82254F88h case    2:*/		return 0x82254F8C;
		  /* 82254F8Ch */ case    3:  		/* mr R27, R6 */
		/* 82254F8Ch case    3:*/		regs.R27 = regs.R6;
		/* 82254F8Ch case    3:*/		return 0x82254F90;
		  /* 82254F90h */ case    4:  		/* mr R6, R7 */
		/* 82254F90h case    4:*/		regs.R6 = regs.R7;
		/* 82254F90h case    4:*/		return 0x82254F94;
		  /* 82254F94h */ case    5:  		/* mr R31, R3 */
		/* 82254F94h case    5:*/		regs.R31 = regs.R3;
		/* 82254F94h case    5:*/		return 0x82254F98;
		  /* 82254F98h */ case    6:  		/* mr R28, R5 */
		/* 82254F98h case    6:*/		regs.R28 = regs.R5;
		/* 82254F98h case    6:*/		return 0x82254F9C;
		  /* 82254F9Ch */ case    7:  		/* mr R30, R7 */
		/* 82254F9Ch case    7:*/		regs.R30 = regs.R7;
		/* 82254F9Ch case    7:*/		return 0x82254FA0;
		  /* 82254FA0h */ case    8:  		/* bl -3136 */
		/* 82254FA0h case    8:*/		regs.LR = 0x82254FA4; return 0x82254360;
		/* 82254FA0h case    8:*/		return 0x82254FA4;
		  /* 82254FA4h */ case    9:  		/* lis R11, -32252 */
		/* 82254FA4h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82254FA4h case    9:*/		return 0x82254FA8;
		  /* 82254FA8h */ case   10:  		/* lwz R5, <#[R31 + 12]> */
		/* 82254FA8h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 82254FA8h case   10:*/		return 0x82254FAC;
		  /* 82254FACh */ case   11:  		/* li R29, 0 */
		/* 82254FACh case   11:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82254FACh case   11:*/		return 0x82254FB0;
		  /* 82254FB0h */ case   12:  		/* addi R11, R11, 27216 */
		/* 82254FB0h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6A50);
		/* 82254FB0h case   12:*/		return 0x82254FB4;
		  /* 82254FB4h */ case   13:  		/* stw R29, <#[R31 + 48]> */
		/* 82254FB4h case   13:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000030) );
		/* 82254FB4h case   13:*/		return 0x82254FB8;
		  /* 82254FB8h */ case   14:  		/* mr R7, R27 */
		/* 82254FB8h case   14:*/		regs.R7 = regs.R27;
		/* 82254FB8h case   14:*/		return 0x82254FBC;
		  /* 82254FBCh */ case   15:  		/* stw R11, <#[R31]> */
		/* 82254FBCh case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82254FBCh case   15:*/		return 0x82254FC0;
		  /* 82254FC0h */ case   16:  		/* mr R6, R31 */
		/* 82254FC0h case   16:*/		regs.R6 = regs.R31;
		/* 82254FC0h case   16:*/		return 0x82254FC4;
		  /* 82254FC4h */ case   17:  		/* stw R29, <#[R31 + 52]> */
		/* 82254FC4h case   17:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000034) );
		/* 82254FC4h case   17:*/		return 0x82254FC8;
	}
	return 0x82254FC8;
} // Block from 82254F80h-82254FC8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82254FC8h
// Function '?BumpUses@VRegInfo@XGRAPHICS@@QAAXHPAVIRInst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82254FC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82254FC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82254FC8);
		  /* 82254FC8h */ case    0:  		/* mr R4, R28 */
		/* 82254FC8h case    0:*/		regs.R4 = regs.R28;
		/* 82254FC8h case    0:*/		return 0x82254FCC;
		  /* 82254FCCh */ case    1:  		/* stw R29, <#[R31 + 56]> */
		/* 82254FCCh case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000038) );
		/* 82254FCCh case    1:*/		return 0x82254FD0;
		  /* 82254FD0h */ case    2:  		/* stw R29, <#[R31 + 60]> */
		/* 82254FD0h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x0000003C) );
		/* 82254FD0h case    2:*/		return 0x82254FD4;
		  /* 82254FD4h */ case    3:  		/* lwz R11, <#[R30 + 2736]> */
		/* 82254FD4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000AB0) );
		/* 82254FD4h case    3:*/		return 0x82254FD8;
		  /* 82254FD8h */ case    4:  		/* addi R3, R11, 184 */
		/* 82254FD8h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xB8);
		/* 82254FD8h case    4:*/		return 0x82254FDC;
		  /* 82254FDCh */ case    5:  		/* bl -13268 */
		/* 82254FDCh case    5:*/		regs.LR = 0x82254FE0; return 0x82251C08;
		/* 82254FDCh case    5:*/		return 0x82254FE0;
		  /* 82254FE0h */ case    6:  		/* li R11, 1 */
		/* 82254FE0h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82254FE0h case    6:*/		return 0x82254FE4;
		  /* 82254FE4h */ case    7:  		/* stw R3, <#[R31 + 16]> */
		/* 82254FE4h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82254FE4h case    7:*/		return 0x82254FE8;
		  /* 82254FE8h */ case    8:  		/* stb R11, <#[R31 + 5]> */
		/* 82254FE8h case    8:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000005) );
		/* 82254FE8h case    8:*/		return 0x82254FEC;
		  /* 82254FECh */ case    9:  		/* lbz R11, <#[R30 + 1380]> */
		/* 82254FECh case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000564) );
		/* 82254FECh case    9:*/		return 0x82254FF0;
		  /* 82254FF0h */ case   10:  		/* cmplwi CR0, R11, 0 */
		/* 82254FF0h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82254FF0h case   10:*/		return 0x82254FF4;
		  /* 82254FF4h */ case   11:  		/* bc 12, CR0_EQ, 40 */
		/* 82254FF4h case   11:*/		if ( regs.CR[0].eq ) { return 0x8225501C;  }
		/* 82254FF4h case   11:*/		return 0x82254FF8;
		  /* 82254FF8h */ case   12:  		/* lis R11, -32252 */
		/* 82254FF8h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82254FF8h case   12:*/		return 0x82254FFC;
		  /* 82254FFCh */ case   13:  		/* lis R10, -32252 */
		/* 82254FFCh case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82254FFCh case   13:*/		return 0x82255000;
		  /* 82255000h */ case   14:  		/* lis R9, -32253 */
		/* 82255000h case   14:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82255000h case   14:*/		return 0x82255004;
		  /* 82255004h */ case   15:  		/* addi R6, R11, 26984 */
		/* 82255004h case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x6968);
		/* 82255004h case   15:*/		return 0x82255008;
		  /* 82255008h */ case   16:  		/* addi R5, R10, 27252 */
		/* 82255008h case   16:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x6A74);
		/* 82255008h case   16:*/		return 0x8225500C;
		  /* 8225500Ch */ case   17:  		/* addi R4, R9, 27460 */
		/* 8225500Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8225500Ch case   17:*/		return 0x82255010;
		  /* 82255010h */ case   18:  		/* li R7, 497 */
		/* 82255010h case   18:*/		cpu::op::li<0>(regs,&regs.R7,0x1F1);
		/* 82255010h case   18:*/		return 0x82255014;
		  /* 82255014h */ case   19:  		/* li R3, 0 */
		/* 82255014h case   19:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82255014h case   19:*/		return 0x82255018;
		  /* 82255018h */ case   20:  		/* bl -1037328 */
		/* 82255018h case   20:*/		regs.LR = 0x8225501C; return 0x82157C08;
		/* 82255018h case   20:*/		return 0x8225501C;
	}
	return 0x8225501C;
} // Block from 82254FC8h-8225501Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8225501Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225501C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225501C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225501C);
		  /* 8225501Ch */ case    0:  		/* lwz R28, <#[R30 + 1452]> */
		/* 8225501Ch case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x000005AC) );
		/* 8225501Ch case    0:*/		return 0x82255020;
		  /* 82255020h */ case    1:  		/* li R4, 964 */
		/* 82255020h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82255020h case    1:*/		return 0x82255024;
		  /* 82255024h */ case    2:  		/* mr R3, R28 */
		/* 82255024h case    2:*/		regs.R3 = regs.R28;
		/* 82255024h case    2:*/		return 0x82255028;
		  /* 82255028h */ case    3:  		/* bl -232304 */
		/* 82255028h case    3:*/		regs.LR = 0x8225502C; return 0x8221C4B8;
		/* 82255028h case    3:*/		return 0x8225502C;
		  /* 8225502Ch */ case    4:  		/* mr R11, R3 */
		/* 8225502Ch case    4:*/		regs.R11 = regs.R3;
		/* 8225502Ch case    4:*/		return 0x82255030;
		  /* 82255030h */ case    5:  		/* addic. R3, R3, 4 */
		/* 82255030h case    5:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82255030h case    5:*/		return 0x82255034;
		  /* 82255034h */ case    6:  		/* stw R28, <#[R11]> */
		/* 82255034h case    6:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82255034h case    6:*/		return 0x82255038;
		  /* 82255038h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 82255038h case    7:*/		if ( regs.CR[0].eq ) { return 0x82255048;  }
		/* 82255038h case    7:*/		return 0x8225503C;
		  /* 8225503Ch */ case    8:  		/* mr R4, R30 */
		/* 8225503Ch case    8:*/		regs.R4 = regs.R30;
		/* 8225503Ch case    8:*/		return 0x82255040;
		  /* 82255040h */ case    9:  		/* bl 9368 */
		/* 82255040h case    9:*/		regs.LR = 0x82255044; return 0x822574D8;
		/* 82255040h case    9:*/		return 0x82255044;
		  /* 82255044h */ case   10:  		/* mr R29, R3 */
		/* 82255044h case   10:*/		regs.R29 = regs.R3;
		/* 82255044h case   10:*/		return 0x82255048;
	}
	return 0x82255048;
} // Block from 8225501Ch-82255048h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82255048h
// Function '?GetActiveDefinition@VRegInfo@XGRAPHICS@@QAAPAUCurrentValue@2@PAVBlock@2@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255048( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255048) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255048);
		  /* 82255048h */ case    0:  		/* lwz R11, <#[R30 + 2736]> */
		/* 82255048h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000AB0) );
		/* 82255048h case    0:*/		return 0x8225504C;
		  /* 8225504Ch */ case    1:  		/* mr R4, R29 */
		/* 8225504Ch case    1:*/		regs.R4 = regs.R29;
		/* 8225504Ch case    1:*/		return 0x82255050;
		  /* 82255050h */ case    2:  		/* lwz R3, <#[R11 + 164]> */
		/* 82255050h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000000A4) );
		/* 82255050h case    2:*/		return 0x82255054;
		  /* 82255054h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 82255054h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82255054h case    3:*/		return 0x82255058;
		  /* 82255058h */ case    4:  		/* lwz R11, <#[R11 + 40]> */
		/* 82255058h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82255058h case    4:*/		return 0x8225505C;
		  /* 8225505Ch */ case    5:  		/* mtspr CTR, R11 */
		/* 8225505Ch case    5:*/		regs.CTR = regs.R11;
		/* 8225505Ch case    5:*/		return 0x82255060;
		  /* 82255060h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 82255060h case    6:*/		if ( 1 ) { regs.LR = 0x82255064; return (uint32)regs.CTR; }
		/* 82255060h case    6:*/		return 0x82255064;
		  /* 82255064h */ case    7:  		/* mr R5, R31 */
		/* 82255064h case    7:*/		regs.R5 = regs.R31;
		/* 82255064h case    7:*/		return 0x82255068;
		  /* 82255068h */ case    8:  		/* li R4, 0 */
		/* 82255068h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82255068h case    8:*/		return 0x8225506C;
		  /* 8225506Ch */ case    9:  		/* mr R3, R29 */
		/* 8225506Ch case    9:*/		regs.R3 = regs.R29;
		/* 8225506Ch case    9:*/		return 0x82255070;
		  /* 82255070h */ case   10:  		/* bl 4904 */
		/* 82255070h case   10:*/		regs.LR = 0x82255074; return 0x82256398;
		/* 82255070h case   10:*/		return 0x82255074;
		  /* 82255074h */ case   11:  		/* mr R4, R29 */
		/* 82255074h case   11:*/		regs.R4 = regs.R29;
		/* 82255074h case   11:*/		return 0x82255078;
		  /* 82255078h */ case   12:  		/* mr R3, R31 */
		/* 82255078h case   12:*/		regs.R3 = regs.R31;
		/* 82255078h case   12:*/		return 0x8225507C;
		  /* 8225507Ch */ case   13:  		/* bl -3092 */
		/* 8225507Ch case   13:*/		regs.LR = 0x82255080; return 0x82254468;
		/* 8225507Ch case   13:*/		return 0x82255080;
		  /* 82255080h */ case   14:  		/* mr R3, R31 */
		/* 82255080h case   14:*/		regs.R3 = regs.R31;
		/* 82255080h case   14:*/		return 0x82255084;
		  /* 82255084h */ case   15:  		/* addi R1, R1, 128 */
		/* 82255084h case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82255084h case   15:*/		return 0x82255088;
		  /* 82255088h */ case   16:  		/* b -1850852 */
		/* 82255088h case   16:*/		return 0x820912A4;
		/* 82255088h case   16:*/		return 0x8225508C;
		  /* 8225508Ch */ case   17:  		/* nop */
		/* 8225508Ch case   17:*/		cpu::op::nop();
		/* 8225508Ch case   17:*/		return 0x82255090;
	}
	return 0x82255090;
} // Block from 82255048h-82255090h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82255090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255090);
		  /* 82255090h */ case    0:  		/* mfspr R12, LR */
		/* 82255090h case    0:*/		regs.R12 = regs.LR;
		/* 82255090h case    0:*/		return 0x82255094;
		  /* 82255094h */ case    1:  		/* bl -1850936 */
		/* 82255094h case    1:*/		regs.LR = 0x82255098; return 0x8209125C;
		/* 82255094h case    1:*/		return 0x82255098;
		  /* 82255098h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82255098h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82255098h case    2:*/		return 0x8225509C;
		  /* 8225509Ch */ case    3:  		/* mr R31, R3 */
		/* 8225509Ch case    3:*/		regs.R31 = regs.R3;
		/* 8225509Ch case    3:*/		return 0x822550A0;
		  /* 822550A0h */ case    4:  		/* mr R30, R4 */
		/* 822550A0h case    4:*/		regs.R30 = regs.R4;
		/* 822550A0h case    4:*/		return 0x822550A4;
		  /* 822550A4h */ case    5:  		/* mr R29, R6 */
		/* 822550A4h case    5:*/		regs.R29 = regs.R6;
		/* 822550A4h case    5:*/		return 0x822550A8;
		  /* 822550A8h */ case    6:  		/* bl -3400 */
		/* 822550A8h case    6:*/		regs.LR = 0x822550AC; return 0x82254360;
		/* 822550A8h case    6:*/		return 0x822550AC;
		  /* 822550ACh */ case    7:  		/* lis R11, -32252 */
		/* 822550ACh case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822550ACh case    7:*/		return 0x822550B0;
		  /* 822550B0h */ case    8:  		/* mr R4, R30 */
		/* 822550B0h case    8:*/		regs.R4 = regs.R30;
		/* 822550B0h case    8:*/		return 0x822550B4;
		  /* 822550B4h */ case    9:  		/* addi R11, R11, 27280 */
		/* 822550B4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6A90);
		/* 822550B4h case    9:*/		return 0x822550B8;
		  /* 822550B8h */ case   10:  		/* stw R11, <#[R31]> */
		/* 822550B8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822550B8h case   10:*/		return 0x822550BC;
		  /* 822550BCh */ case   11:  		/* lwz R3, <#[R29 + 2736]> */
		/* 822550BCh case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000AB0) );
		/* 822550BCh case   11:*/		return 0x822550C0;
		  /* 822550C0h */ case   12:  		/* bl -56080 */
		/* 822550C0h case   12:*/		regs.LR = 0x822550C4; return 0x822475B0;
		/* 822550C0h case   12:*/		return 0x822550C4;
		  /* 822550C4h */ case   13:  		/* li R11, 1 */
		/* 822550C4h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822550C4h case   13:*/		return 0x822550C8;
		  /* 822550C8h */ case   14:  		/* stb R11, <#[R31 + 5]> */
		/* 822550C8h case   14:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000005) );
		/* 822550C8h case   14:*/		return 0x822550CC;
		  /* 822550CCh */ case   15:  		/* mr R3, R31 */
		/* 822550CCh case   15:*/		regs.R3 = regs.R31;
		/* 822550CCh case   15:*/		return 0x822550D0;
		  /* 822550D0h */ case   16:  		/* stw R30, <#[R31 + 16]> */
		/* 822550D0h case   16:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000010) );
		/* 822550D0h case   16:*/		return 0x822550D4;
		  /* 822550D4h */ case   17:  		/* stb R11, <#[R31 + 29]> */
		/* 822550D4h case   17:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x0000001D) );
		/* 822550D4h case   17:*/		return 0x822550D8;
		  /* 822550D8h */ case   18:  		/* stb R11, <#[R31 + 28]> */
		/* 822550D8h case   18:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 822550D8h case   18:*/		return 0x822550DC;
		  /* 822550DCh */ case   19:  		/* addi R1, R1, 112 */
		/* 822550DCh case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822550DCh case   19:*/		return 0x822550E0;
		  /* 822550E0h */ case   20:  		/* b -1850932 */
		/* 822550E0h case   20:*/		return 0x820912AC;
		/* 822550E0h case   20:*/		return 0x822550E4;
		  /* 822550E4h */ case   21:  		/* nop */
		/* 822550E4h case   21:*/		cpu::op::nop();
		/* 822550E4h case   21:*/		return 0x822550E8;
	}
	return 0x822550E8;
} // Block from 82255090h-822550E8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 822550E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822550E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822550E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822550E8);
		  /* 822550E8h */ case    0:  		/* mfspr R12, LR */
		/* 822550E8h case    0:*/		regs.R12 = regs.LR;
		/* 822550E8h case    0:*/		return 0x822550EC;
		  /* 822550ECh */ case    1:  		/* bl -1851032 */
		/* 822550ECh case    1:*/		regs.LR = 0x822550F0; return 0x82091254;
		/* 822550ECh case    1:*/		return 0x822550F0;
		  /* 822550F0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 822550F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822550F0h case    2:*/		return 0x822550F4;
		  /* 822550F4h */ case    3:  		/* mr R31, R3 */
		/* 822550F4h case    3:*/		regs.R31 = regs.R3;
		/* 822550F4h case    3:*/		return 0x822550F8;
		  /* 822550F8h */ case    4:  		/* mr R29, R4 */
		/* 822550F8h case    4:*/		regs.R29 = regs.R4;
		/* 822550F8h case    4:*/		return 0x822550FC;
		  /* 822550FCh */ case    5:  		/* mr R30, R5 */
		/* 822550FCh case    5:*/		regs.R30 = regs.R5;
		/* 822550FCh case    5:*/		return 0x82255100;
		  /* 82255100h */ case    6:  		/* bl -3488 */
		/* 82255100h case    6:*/		regs.LR = 0x82255104; return 0x82254360;
		/* 82255100h case    6:*/		return 0x82255104;
		  /* 82255104h */ case    7:  		/* lis R11, -32252 */
		/* 82255104h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82255104h case    7:*/		return 0x82255108;
		  /* 82255108h */ case    8:  		/* lis R10, 0 */
		/* 82255108h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 82255108h case    8:*/		return 0x8225510C;
		  /* 8225510Ch */ case    9:  		/* addi R9, R11, 27352 */
		/* 8225510Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x6AD8);
		/* 8225510Ch case    9:*/		return 0x82255110;
		  /* 82255110h */ case   10:  		/* ori R8, R10, 32768 */
		/* 82255110h case   10:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x8000);
		/* 82255110h case   10:*/		return 0x82255114;
		  /* 82255114h */ case   11:  		/* lis R11, -32253 */
		/* 82255114h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 82255114h case   11:*/		return 0x82255118;
		  /* 82255118h */ case   12:  		/* stw R9, <#[R31]> */
		/* 82255118h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82255118h case   12:*/		return 0x8225511C;
		  /* 8225511Ch */ case   13:  		/* lis R10, -32252 */
		/* 8225511Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8225511Ch case   13:*/		return 0x82255120;
		  /* 82255120h */ case   14:  		/* cmpw CR6, R30, R8 */
		/* 82255120h case   14:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R8);
		/* 82255120h case   14:*/		return 0x82255124;
		  /* 82255124h */ case   15:  		/* addi R28, R11, 27460 */
		/* 82255124h case   15:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0x6B44);
		/* 82255124h case   15:*/		return 0x82255128;
		  /* 82255128h */ case   16:  		/* addi R27, R10, 26984 */
		/* 82255128h case   16:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R10,0x6968);
		/* 82255128h case   16:*/		return 0x8225512C;
		  /* 8225512Ch */ case   17:  		/* bc 12, CR6_LT, 32 */
		/* 8225512Ch case   17:*/		if ( regs.CR[6].lt ) { return 0x8225514C;  }
		/* 8225512Ch case   17:*/		return 0x82255130;
		  /* 82255130h */ case   18:  		/* lis R11, -32252 */
		/* 82255130h case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82255130h case   18:*/		return 0x82255134;
		  /* 82255134h */ case   19:  		/* mr R6, R27 */
		/* 82255134h case   19:*/		regs.R6 = regs.R27;
		/* 82255134h case   19:*/		return 0x82255138;
		  /* 82255138h */ case   20:  		/* addi R5, R11, 27336 */
		/* 82255138h case   20:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x6AC8);
		/* 82255138h case   20:*/		return 0x8225513C;
		  /* 8225513Ch */ case   21:  		/* mr R4, R28 */
		/* 8225513Ch case   21:*/		regs.R4 = regs.R28;
		/* 8225513Ch case   21:*/		return 0x82255140;
		  /* 82255140h */ case   22:  		/* li R7, 577 */
		/* 82255140h case   22:*/		cpu::op::li<0>(regs,&regs.R7,0x241);
		/* 82255140h case   22:*/		return 0x82255144;
		  /* 82255144h */ case   23:  		/* li R3, 0 */
		/* 82255144h case   23:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82255144h case   23:*/		return 0x82255148;
		  /* 82255148h */ case   24:  		/* bl -1037632 */
		/* 82255148h case   24:*/		regs.LR = 0x8225514C; return 0x82157C08;
		/* 82255148h case   24:*/		return 0x8225514C;
	}
	return 0x8225514C;
} // Block from 822550E8h-8225514Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 8225514Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225514C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225514C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225514C);
		  /* 8225514Ch */ case    0:  		/* lis R11, 1 */
		/* 8225514Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x1);
		/* 8225514Ch case    0:*/		return 0x82255150;
		  /* 82255150h */ case    1:  		/* cmpw CR6, R29, R11 */
		/* 82255150h case    1:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R11);
		/* 82255150h case    1:*/		return 0x82255154;
		  /* 82255154h */ case    2:  		/* bc 12, CR6_LT, 32 */
		/* 82255154h case    2:*/		if ( regs.CR[6].lt ) { return 0x82255174;  }
		/* 82255154h case    2:*/		return 0x82255158;
		  /* 82255158h */ case    3:  		/* lis R11, -32252 */
		/* 82255158h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82255158h case    3:*/		return 0x8225515C;
		  /* 8225515Ch */ case    4:  		/* mr R6, R27 */
		/* 8225515Ch case    4:*/		regs.R6 = regs.R27;
		/* 8225515Ch case    4:*/		return 0x82255160;
		  /* 82255160h */ case    5:  		/* addi R5, R11, 27316 */
		/* 82255160h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x6AB4);
		/* 82255160h case    5:*/		return 0x82255164;
		  /* 82255164h */ case    6:  		/* mr R4, R28 */
		/* 82255164h case    6:*/		regs.R4 = regs.R28;
		/* 82255164h case    6:*/		return 0x82255168;
		  /* 82255168h */ case    7:  		/* li R7, 578 */
		/* 82255168h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x242);
		/* 82255168h case    7:*/		return 0x8225516C;
		  /* 8225516Ch */ case    8:  		/* li R3, 0 */
		/* 8225516Ch case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225516Ch case    8:*/		return 0x82255170;
		  /* 82255170h */ case    9:  		/* bl -1037672 */
		/* 82255170h case    9:*/		regs.LR = 0x82255174; return 0x82157C08;
		/* 82255170h case    9:*/		return 0x82255174;
	}
	return 0x82255174;
} // Block from 8225514Ch-82255174h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82255174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255174);
		  /* 82255174h */ case    0:  		/* rlwinm R11, R30, 16, 0, 15 */
		/* 82255174h case    0:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R11,regs.R30);
		/* 82255174h case    0:*/		return 0x82255178;
		  /* 82255178h */ case    1:  		/* mr R3, R31 */
		/* 82255178h case    1:*/		regs.R3 = regs.R31;
		/* 82255178h case    1:*/		return 0x8225517C;
		  /* 8225517Ch */ case    2:  		/* add R11, R11, R29 */
		/* 8225517Ch case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8225517Ch case    2:*/		return 0x82255180;
		  /* 82255180h */ case    3:  		/* stw R11, <#[R31 + 16]> */
		/* 82255180h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82255180h case    3:*/		return 0x82255184;
		  /* 82255184h */ case    4:  		/* addi R1, R1, 128 */
		/* 82255184h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82255184h case    4:*/		return 0x82255188;
		  /* 82255188h */ case    5:  		/* b -1851108 */
		/* 82255188h case    5:*/		return 0x820912A4;
		/* 82255188h case    5:*/		return 0x8225518C;
		  /* 8225518Ch */ case    6:  		/* nop */
		/* 8225518Ch case    6:*/		cpu::op::nop();
		/* 8225518Ch case    6:*/		return 0x82255190;
	}
	return 0x82255190;
} // Block from 82255174h-82255190h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82255190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255190);
		  /* 82255190h */ case    0:  		/* mfspr R12, LR */
		/* 82255190h case    0:*/		regs.R12 = regs.LR;
		/* 82255190h case    0:*/		return 0x82255194;
		  /* 82255194h */ case    1:  		/* bl -1851224 */
		/* 82255194h case    1:*/		regs.LR = 0x82255198; return 0x8209123C;
		/* 82255194h case    1:*/		return 0x82255198;
		  /* 82255198h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82255198h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82255198h case    2:*/		return 0x8225519C;
		  /* 8225519Ch */ case    3:  		/* mr R22, R3 */
		/* 8225519Ch case    3:*/		regs.R22 = regs.R3;
		/* 8225519Ch case    3:*/		return 0x822551A0;
		  /* 822551A0h */ case    4:  		/* mr R30, R6 */
		/* 822551A0h case    4:*/		regs.R30 = regs.R6;
		/* 822551A0h case    4:*/		return 0x822551A4;
		  /* 822551A4h */ case    5:  		/* bl -932 */
		/* 822551A4h case    5:*/		regs.LR = 0x822551A8; return 0x82254E00;
		/* 822551A4h case    5:*/		return 0x822551A8;
		  /* 822551A8h */ case    6:  		/* lis R11, -32252 */
		/* 822551A8h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822551A8h case    6:*/		return 0x822551AC;
		  /* 822551ACh */ case    7:  		/* addi R11, R11, 27388 */
		/* 822551ACh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6AFC);
		/* 822551ACh case    7:*/		return 0x822551B0;
		  /* 822551B0h */ case    8:  		/* stw R11, <#[R22]> */
		/* 822551B0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 822551B0h case    8:*/		return 0x822551B4;
		  /* 822551B4h */ case    9:  		/* lwz R3, <#[R30 + 1488]> */
		/* 822551B4h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000005D0) );
		/* 822551B4h case    9:*/		return 0x822551B8;
		  /* 822551B8h */ case   10:  		/* lwz R11, <#[R3]> */
		/* 822551B8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822551B8h case   10:*/		return 0x822551BC;
		  /* 822551BCh */ case   11:  		/* lwz R11, <#[R11 + 28]> */
		/* 822551BCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 822551BCh case   11:*/		return 0x822551C0;
		  /* 822551C0h */ case   12:  		/* lwz R31, <#[R30 + 2736]> */
		/* 822551C0h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000AB0) );
		/* 822551C0h case   12:*/		return 0x822551C4;
		  /* 822551C4h */ case   13:  		/* lwz R29, <#[R30 + 1536]> */
		/* 822551C4h case   13:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000600) );
		/* 822551C4h case   13:*/		return 0x822551C8;
		  /* 822551C8h */ case   14:  		/* mtspr CTR, R11 */
		/* 822551C8h case   14:*/		regs.CTR = regs.R11;
		/* 822551C8h case   14:*/		return 0x822551CC;
		  /* 822551CCh */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 822551CCh case   15:*/		if ( 1 ) { regs.LR = 0x822551D0; return (uint32)regs.CTR; }
		/* 822551CCh case   15:*/		return 0x822551D0;
		  /* 822551D0h */ case   16:  		/* lis R11, -32222 */
		/* 822551D0h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 822551D0h case   16:*/		return 0x822551D4;
		  /* 822551D4h */ case   17:  		/* mr R5, R3 */
		/* 822551D4h case   17:*/		regs.R5 = regs.R3;
		/* 822551D4h case   17:*/		return 0x822551D8;
		  /* 822551D8h */ case   18:  		/* li R4, 0 */
		/* 822551D8h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822551D8h case   18:*/		return 0x822551DC;
		  /* 822551DCh */ case   19:  		/* mr R3, R29 */
		/* 822551DCh case   19:*/		regs.R3 = regs.R29;
		/* 822551DCh case   19:*/		return 0x822551E0;
		  /* 822551E0h */ case   20:  		/* addi R6, R11, -12392 */
		/* 822551E0h case   20:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 822551E0h case   20:*/		return 0x822551E4;
		  /* 822551E4h */ case   21:  		/* mr R7, R30 */
		/* 822551E4h case   21:*/		regs.R7 = regs.R30;
		/* 822551E4h case   21:*/		return 0x822551E8;
		  /* 822551E8h */ case   22:  		/* bl -143536 */
		/* 822551E8h case   22:*/		regs.LR = 0x822551EC; return 0x82232138;
		/* 822551E8h case   22:*/		return 0x822551EC;
		  /* 822551ECh */ case   23:  		/* cmpwi CR0, R3, 0 */
		/* 822551ECh case   23:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 822551ECh case   23:*/		return 0x822551F0;
		  /* 822551F0h */ case   24:  		/* bc 4, CR0_EQ, 188 */
		/* 822551F0h case   24:*/		if ( !regs.CR[0].eq ) { return 0x822552AC;  }
		/* 822551F0h case   24:*/		return 0x822551F4;
		  /* 822551F4h */ case   25:  		/* lis R11, -32252 */
		/* 822551F4h case   25:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822551F4h case   25:*/		return 0x822551F8;
		  /* 822551F8h */ case   26:  		/* lwz R5, <#[R11 + 27584]> */
		/* 822551F8h case   26:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00006BC0) );
		/* 822551F8h case   26:*/		return 0x822551FC;
		  /* 822551FCh */ case   27:  		/* addi R11, R5, 6 */
		/* 822551FCh case   27:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0x6);
		/* 822551FCh case   27:*/		return 0x82255200;
		  /* 82255200h */ case   28:  		/* rlwinm R27, R11, 2, 0, 29 */
		/* 82255200h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R11);
		/* 82255200h case   28:*/		return 0x82255204;
		  /* 82255204h */ case   29:  		/* lwzx R11, <#[R27 + R31]> */
		/* 82255204h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + regs.R31 + 0x00000000) );
		/* 82255204h case   29:*/		return 0x82255208;
		  /* 82255208h */ case   30:  		/* cmplwi CR6, R11, 0 */
		/* 82255208h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82255208h case   30:*/		return 0x8225520C;
		  /* 8225520Ch */ case   31:  		/* bc 4, CR6_EQ, 124 */
		/* 8225520Ch case   31:*/		if ( !regs.CR[6].eq ) { return 0x82255288;  }
		/* 8225520Ch case   31:*/		return 0x82255210;
		  /* 82255210h */ case   32:  		/* li R4, 15 */
		/* 82255210h case   32:*/		cpu::op::li<0>(regs,&regs.R4,0xF);
		/* 82255210h case   32:*/		return 0x82255214;
		  /* 82255214h */ case   33:  		/* lwz R3, <#[R31 + 172]> */
		/* 82255214h case   33:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 82255214h case   33:*/		return 0x82255218;
		  /* 82255218h */ case   34:  		/* bl -64008 */
		/* 82255218h case   34:*/		regs.LR = 0x8225521C; return 0x82245810;
		/* 82255218h case   34:*/		return 0x8225521C;
		  /* 8225521Ch */ case   35:  		/* lwz R29, <#[R30 + 1452]> */
		/* 8225521Ch case   35:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x000005AC) );
		/* 8225521Ch case   35:*/		return 0x82255220;
		  /* 82255220h */ case   36:  		/* mr R28, R3 */
		/* 82255220h case   36:*/		regs.R28 = regs.R3;
		/* 82255220h case   36:*/		return 0x82255224;
		  /* 82255224h */ case   37:  		/* li R4, 964 */
		/* 82255224h case   37:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82255224h case   37:*/		return 0x82255228;
		  /* 82255228h */ case   38:  		/* mr R3, R29 */
		/* 82255228h case   38:*/		regs.R3 = regs.R29;
		/* 82255228h case   38:*/		return 0x8225522C;
		  /* 8225522Ch */ case   39:  		/* bl -232820 */
		/* 8225522Ch case   39:*/		regs.LR = 0x82255230; return 0x8221C4B8;
		/* 8225522Ch case   39:*/		return 0x82255230;
		  /* 82255230h */ case   40:  		/* mr R11, R3 */
		/* 82255230h case   40:*/		regs.R11 = regs.R3;
		/* 82255230h case   40:*/		return 0x82255234;
		  /* 82255234h */ case   41:  		/* addic. R3, R3, 4 */
		/* 82255234h case   41:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82255234h case   41:*/		return 0x82255238;
		  /* 82255238h */ case   42:  		/* stw R29, <#[R11]> */
		/* 82255238h case   42:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82255238h case   42:*/		return 0x8225523C;
		  /* 8225523Ch */ case   43:  		/* bc 12, CR0_EQ, 24 */
		/* 8225523Ch case   43:*/		if ( regs.CR[0].eq ) { return 0x82255254;  }
		/* 8225523Ch case   43:*/		return 0x82255240;
		  /* 82255240h */ case   44:  		/* mr R5, R30 */
		/* 82255240h case   44:*/		regs.R5 = regs.R30;
		/* 82255240h case   44:*/		return 0x82255244;
		  /* 82255244h */ case   45:  		/* mr R4, R22 */
		/* 82255244h case   45:*/		regs.R4 = regs.R22;
		/* 82255244h case   45:*/		return 0x82255248;
		  /* 82255248h */ case   46:  		/* bl 8736 */
		/* 82255248h case   46:*/		regs.LR = 0x8225524C; return 0x82257468;
		/* 82255248h case   46:*/		return 0x8225524C;
		  /* 8225524Ch */ case   47:  		/* mr R29, R3 */
		/* 8225524Ch case   47:*/		regs.R29 = regs.R3;
		/* 8225524Ch case   47:*/		return 0x82255250;
		  /* 82255250h */ case   48:  		/* b 8 */
		/* 82255250h case   48:*/		return 0x82255258;
		/* 82255250h case   48:*/		return 0x82255254;
	}
	return 0x82255254;
} // Block from 82255190h-82255254h (49 instructions)

//////////////////////////////////////////////////////
// Block at 82255254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255254);
		  /* 82255254h */ case    0:  		/* li R29, 0 */
		/* 82255254h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82255254h case    0:*/		return 0x82255258;
	}
	return 0x82255258;
} // Block from 82255254h-82255258h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82255258h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255258);
		  /* 82255258h */ case    0:  		/* mr R4, R29 */
		/* 82255258h case    0:*/		regs.R4 = regs.R29;
		/* 82255258h case    0:*/		return 0x8225525C;
		  /* 8225525Ch */ case    1:  		/* lwz R3, <#[R31 + 164]> */
		/* 8225525Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000A4) );
		/* 8225525Ch case    1:*/		return 0x82255260;
		  /* 82255260h */ case    2:  		/* bl 15640 */
		/* 82255260h case    2:*/		regs.LR = 0x82255264; return 0x82258F78;
		/* 82255260h case    2:*/		return 0x82255264;
		  /* 82255264h */ case    3:  		/* mr R5, R28 */
		/* 82255264h case    3:*/		regs.R5 = regs.R28;
		/* 82255264h case    3:*/		return 0x82255268;
		  /* 82255268h */ case    4:  		/* li R4, 0 */
		/* 82255268h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82255268h case    4:*/		return 0x8225526C;
		  /* 8225526Ch */ case    5:  		/* mr R3, R29 */
		/* 8225526Ch case    5:*/		regs.R3 = regs.R29;
		/* 8225526Ch case    5:*/		return 0x82255270;
		  /* 82255270h */ case    6:  		/* bl 4392 */
		/* 82255270h case    6:*/		regs.LR = 0x82255274; return 0x82256398;
		/* 82255270h case    6:*/		return 0x82255274;
		  /* 82255274h */ case    7:  		/* mr R4, R29 */
		/* 82255274h case    7:*/		regs.R4 = regs.R29;
		/* 82255274h case    7:*/		return 0x82255278;
		  /* 82255278h */ case    8:  		/* mr R3, R28 */
		/* 82255278h case    8:*/		regs.R3 = regs.R28;
		/* 82255278h case    8:*/		return 0x8225527C;
		  /* 8225527Ch */ case    9:  		/* bl -3604 */
		/* 8225527Ch case    9:*/		regs.LR = 0x82255280; return 0x82254468;
		/* 8225527Ch case    9:*/		return 0x82255280;
		  /* 82255280h */ case   10:  		/* stwx R29, <#[R27 + R31]> */
		/* 82255280h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R27 + regs.R31 + 0x00000000) );
		/* 82255280h case   10:*/		return 0x82255284;
		  /* 82255284h */ case   11:  		/* b 8 */
		/* 82255284h case   11:*/		return 0x8225528C;
		/* 82255284h case   11:*/		return 0x82255288;
	}
	return 0x82255288;
} // Block from 82255258h-82255288h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82255288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255288);
		  /* 82255288h */ case    0:  		/* lwz R28, <#[R11 + 28]> */
		/* 82255288h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x0000001C) );
		/* 82255288h case    0:*/		return 0x8225528C;
	}
	return 0x8225528C;
} // Block from 82255288h-8225528Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225528Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225528C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225528C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225528C);
		  /* 8225528Ch */ case    0:  		/* mr R4, R30 */
		/* 8225528Ch case    0:*/		regs.R4 = regs.R30;
		/* 8225528Ch case    0:*/		return 0x82255290;
		  /* 82255290h */ case    1:  		/* li R3, 49 */
		/* 82255290h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 82255290h case    1:*/		return 0x82255294;
		  /* 82255294h */ case    2:  		/* bl 10964 */
		/* 82255294h case    2:*/		regs.LR = 0x82255298; return 0x82257D68;
		/* 82255294h case    2:*/		return 0x82255298;
		  /* 82255298h */ case    3:  		/* mr R5, R28 */
		/* 82255298h case    3:*/		regs.R5 = regs.R28;
		/* 82255298h case    3:*/		return 0x8225529C;
		  /* 8225529Ch */ case    4:  		/* li R4, 1 */
		/* 8225529Ch case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225529Ch case    4:*/		return 0x822552A0;
		  /* 822552A0h */ case    5:  		/* mr R30, R3 */
		/* 822552A0h case    5:*/		regs.R30 = regs.R3;
		/* 822552A0h case    5:*/		return 0x822552A4;
		  /* 822552A4h */ case    6:  		/* bl 4340 */
		/* 822552A4h case    6:*/		regs.LR = 0x822552A8; return 0x82256398;
		/* 822552A4h case    6:*/		return 0x822552A8;
		  /* 822552A8h */ case    7:  		/* b 768 */
		/* 822552A8h case    7:*/		return 0x822555A8;
		/* 822552A8h case    7:*/		return 0x822552AC;
	}
	return 0x822552AC;
} // Block from 8225528Ch-822552ACh (8 instructions)

//////////////////////////////////////////////////////
// Block at 822552ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822552AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822552AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822552AC);
		  /* 822552ACh */ case    0:  		/* lis R11, -32222 */
		/* 822552ACh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 822552ACh case    0:*/		return 0x822552B0;
		  /* 822552B0h */ case    1:  		/* lwz R3, <#[R30 + 1536]> */
		/* 822552B0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000600) );
		/* 822552B0h case    1:*/		return 0x822552B4;
		  /* 822552B4h */ case    2:  		/* mr R6, R30 */
		/* 822552B4h case    2:*/		regs.R6 = regs.R30;
		/* 822552B4h case    2:*/		return 0x822552B8;
		  /* 822552B8h */ case    3:  		/* addi R5, R11, -12392 */
		/* 822552B8h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFCF98);
		/* 822552B8h case    3:*/		return 0x822552BC;
		  /* 822552BCh */ case    4:  		/* addi R4, R1, 80 */
		/* 822552BCh case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 822552BCh case    4:*/		return 0x822552C0;
		  /* 822552C0h */ case    5:  		/* bl -142320 */
		/* 822552C0h case    5:*/		regs.LR = 0x822552C4; return 0x822326D0;
		/* 822552C0h case    5:*/		return 0x822552C4;
		  /* 822552C4h */ case    6:  		/* lwz R9, <#[R1 + 80]> */
		/* 822552C4h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 822552C4h case    6:*/		return 0x822552C8;
		  /* 822552C8h */ case    7:  		/* lis R11, -32252 */
		/* 822552C8h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822552C8h case    7:*/		return 0x822552CC;
		  /* 822552CCh */ case    8:  		/* rlwinm R10, R9, 4, 0, 27 */
		/* 822552CCh case    8:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R9);
		/* 822552CCh case    8:*/		return 0x822552D0;
		  /* 822552D0h */ case    9:  		/* addi R21, R11, 27752 */
		/* 822552D0h case    9:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R11,0x6C68);
		/* 822552D0h case    9:*/		return 0x822552D4;
		  /* 822552D4h */ case   10:  		/* lwzx R10, <#[R10 + R21]> */
		/* 822552D4h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R21 + 0x00000000) );
		/* 822552D4h case   10:*/		return 0x822552D8;
		  /* 822552D8h */ case   11:  		/* cmpwi CR6, R10, 0 */
		/* 822552D8h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 822552D8h case   11:*/		return 0x822552DC;
		  /* 822552DCh */ case   12:  		/* bc 12, CR6_LT, 492 */
		/* 822552DCh case   12:*/		if ( regs.CR[6].lt ) { return 0x822554C8;  }
		/* 822552DCh case   12:*/		return 0x822552E0;
		  /* 822552E0h */ case   13:  		/* lis R11, -32252 */
		/* 822552E0h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822552E0h case   13:*/		return 0x822552E4;
		  /* 822552E4h */ case   14:  		/* rlwinm R10, R10, 4, 0, 27 */
		/* 822552E4h case   14:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R10);
		/* 822552E4h case   14:*/		return 0x822552E8;
		  /* 822552E8h */ case   15:  		/* addi R27, R11, 28056 */
		/* 822552E8h case   15:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0x6D98);
		/* 822552E8h case   15:*/		return 0x822552EC;
		  /* 822552ECh */ case   16:  		/* lis R11, -32252 */
		/* 822552ECh case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822552ECh case   16:*/		return 0x822552F0;
		  /* 822552F0h */ case   17:  		/* addi R9, R27, 8 */
		/* 822552F0h case   17:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0x8);
		/* 822552F0h case   17:*/		return 0x822552F4;
		  /* 822552F4h */ case   18:  		/* addi R11, R11, 27584 */
		/* 822552F4h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6BC0);
		/* 822552F4h case   18:*/		return 0x822552F8;
		  /* 822552F8h */ case   19:  		/* lwzx R8, <#[R10 + R27]> */
		/* 822552F8h case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 822552F8h case   19:*/		return 0x822552FC;
		  /* 822552FCh */ case   20:  		/* lwzx R10, <#[R10 + R9]> */
		/* 822552FCh case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 822552FCh case   20:*/		return 0x82255300;
		  /* 82255300h */ case   21:  		/* rlwinm R9, R8, 3, 0, 28 */
		/* 82255300h case   21:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R8);
		/* 82255300h case   21:*/		return 0x82255304;
		  /* 82255304h */ case   22:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 82255304h case   22:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 82255304h case   22:*/		return 0x82255308;
		  /* 82255308h */ case   23:  		/* lwzx R5, <#[R9 + R11]> */
		/* 82255308h case   23:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82255308h case   23:*/		return 0x8225530C;
		  /* 8225530Ch */ case   24:  		/* lwzx R26, <#[R10 + R11]> */
		/* 8225530Ch case   24:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8225530Ch case   24:*/		return 0x82255310;
		  /* 82255310h */ case   25:  		/* addi R11, R5, 6 */
		/* 82255310h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0x6);
		/* 82255310h case   25:*/		return 0x82255314;
		  /* 82255314h */ case   26:  		/* rlwinm R28, R11, 2, 0, 29 */
		/* 82255314h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R11);
		/* 82255314h case   26:*/		return 0x82255318;
		  /* 82255318h */ case   27:  		/* addi R11, R26, 6 */
		/* 82255318h case   27:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x6);
		/* 82255318h case   27:*/		return 0x8225531C;
		  /* 8225531Ch */ case   28:  		/* rlwinm R23, R11, 2, 0, 29 */
		/* 8225531Ch case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R23,regs.R11);
		/* 8225531Ch case   28:*/		return 0x82255320;
	}
	return 0x82255320;
} // Block from 822552ACh-82255320h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82255320h
// Function '?ReplaceUse@VRegInfo@XGRAPHICS@@QAAXPAVIRInst@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255320);
		  /* 82255320h */ case    0:  		/* lwzx R11, <#[R28 + R31]> */
		/* 82255320h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R31 + 0x00000000) );
		/* 82255320h case    0:*/		return 0x82255324;
		  /* 82255324h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82255324h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82255324h case    1:*/		return 0x82255328;
		  /* 82255328h */ case    2:  		/* lwzx R24, <#[R23 + R31]> */
		/* 82255328h case    2:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R23 + regs.R31 + 0x00000000) );
		/* 82255328h case    2:*/		return 0x8225532C;
		  /* 8225532Ch */ case    3:  		/* bc 4, CR6_EQ, 124 */
		/* 8225532Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x822553A8;  }
		/* 8225532Ch case    3:*/		return 0x82255330;
		  /* 82255330h */ case    4:  		/* li R4, 15 */
		/* 82255330h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0xF);
		/* 82255330h case    4:*/		return 0x82255334;
		  /* 82255334h */ case    5:  		/* lwz R3, <#[R31 + 172]> */
		/* 82255334h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 82255334h case    5:*/		return 0x82255338;
		  /* 82255338h */ case    6:  		/* bl -64296 */
		/* 82255338h case    6:*/		regs.LR = 0x8225533C; return 0x82245810;
		/* 82255338h case    6:*/		return 0x8225533C;
		  /* 8225533Ch */ case    7:  		/* lwz R29, <#[R30 + 1452]> */
		/* 8225533Ch case    7:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x000005AC) );
		/* 8225533Ch case    7:*/		return 0x82255340;
		  /* 82255340h */ case    8:  		/* mr R25, R3 */
		/* 82255340h case    8:*/		regs.R25 = regs.R3;
		/* 82255340h case    8:*/		return 0x82255344;
		  /* 82255344h */ case    9:  		/* li R4, 964 */
		/* 82255344h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82255344h case    9:*/		return 0x82255348;
		  /* 82255348h */ case   10:  		/* mr R3, R29 */
		/* 82255348h case   10:*/		regs.R3 = regs.R29;
		/* 82255348h case   10:*/		return 0x8225534C;
		  /* 8225534Ch */ case   11:  		/* bl -233108 */
		/* 8225534Ch case   11:*/		regs.LR = 0x82255350; return 0x8221C4B8;
		/* 8225534Ch case   11:*/		return 0x82255350;
		  /* 82255350h */ case   12:  		/* mr R11, R3 */
		/* 82255350h case   12:*/		regs.R11 = regs.R3;
		/* 82255350h case   12:*/		return 0x82255354;
		  /* 82255354h */ case   13:  		/* addic. R3, R3, 4 */
		/* 82255354h case   13:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82255354h case   13:*/		return 0x82255358;
		  /* 82255358h */ case   14:  		/* stw R29, <#[R11]> */
		/* 82255358h case   14:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82255358h case   14:*/		return 0x8225535C;
		  /* 8225535Ch */ case   15:  		/* bc 12, CR0_EQ, 24 */
		/* 8225535Ch case   15:*/		if ( regs.CR[0].eq ) { return 0x82255374;  }
		/* 8225535Ch case   15:*/		return 0x82255360;
		  /* 82255360h */ case   16:  		/* mr R5, R30 */
		/* 82255360h case   16:*/		regs.R5 = regs.R30;
		/* 82255360h case   16:*/		return 0x82255364;
		  /* 82255364h */ case   17:  		/* mr R4, R22 */
		/* 82255364h case   17:*/		regs.R4 = regs.R22;
		/* 82255364h case   17:*/		return 0x82255368;
		  /* 82255368h */ case   18:  		/* bl 8448 */
		/* 82255368h case   18:*/		regs.LR = 0x8225536C; return 0x82257468;
		/* 82255368h case   18:*/		return 0x8225536C;
		  /* 8225536Ch */ case   19:  		/* mr R29, R3 */
		/* 8225536Ch case   19:*/		regs.R29 = regs.R3;
		/* 8225536Ch case   19:*/		return 0x82255370;
		  /* 82255370h */ case   20:  		/* b 8 */
		/* 82255370h case   20:*/		return 0x82255378;
		/* 82255370h case   20:*/		return 0x82255374;
	}
	return 0x82255374;
} // Block from 82255320h-82255374h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82255374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255374);
		  /* 82255374h */ case    0:  		/* li R29, 0 */
		/* 82255374h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82255374h case    0:*/		return 0x82255378;
	}
	return 0x82255378;
} // Block from 82255374h-82255378h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82255378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255378);
		  /* 82255378h */ case    0:  		/* mr R4, R29 */
		/* 82255378h case    0:*/		regs.R4 = regs.R29;
		/* 82255378h case    0:*/		return 0x8225537C;
		  /* 8225537Ch */ case    1:  		/* lwz R3, <#[R31 + 164]> */
		/* 8225537Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000A4) );
		/* 8225537Ch case    1:*/		return 0x82255380;
		  /* 82255380h */ case    2:  		/* bl 15352 */
		/* 82255380h case    2:*/		regs.LR = 0x82255384; return 0x82258F78;
		/* 82255380h case    2:*/		return 0x82255384;
		  /* 82255384h */ case    3:  		/* mr R5, R25 */
		/* 82255384h case    3:*/		regs.R5 = regs.R25;
		/* 82255384h case    3:*/		return 0x82255388;
		  /* 82255388h */ case    4:  		/* li R4, 0 */
		/* 82255388h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82255388h case    4:*/		return 0x8225538C;
		  /* 8225538Ch */ case    5:  		/* mr R3, R29 */
		/* 8225538Ch case    5:*/		regs.R3 = regs.R29;
		/* 8225538Ch case    5:*/		return 0x82255390;
		  /* 82255390h */ case    6:  		/* bl 4104 */
		/* 82255390h case    6:*/		regs.LR = 0x82255394; return 0x82256398;
		/* 82255390h case    6:*/		return 0x82255394;
		  /* 82255394h */ case    7:  		/* mr R4, R29 */
		/* 82255394h case    7:*/		regs.R4 = regs.R29;
		/* 82255394h case    7:*/		return 0x82255398;
		  /* 82255398h */ case    8:  		/* mr R3, R25 */
		/* 82255398h case    8:*/		regs.R3 = regs.R25;
		/* 82255398h case    8:*/		return 0x8225539C;
		  /* 8225539Ch */ case    9:  		/* bl -3892 */
		/* 8225539Ch case    9:*/		regs.LR = 0x822553A0; return 0x82254468;
		/* 8225539Ch case    9:*/		return 0x822553A0;
		  /* 822553A0h */ case   10:  		/* stwx R29, <#[R28 + R31]> */
		/* 822553A0h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R28 + regs.R31 + 0x00000000) );
		/* 822553A0h case   10:*/		return 0x822553A4;
		  /* 822553A4h */ case   11:  		/* b 8 */
		/* 822553A4h case   11:*/		return 0x822553AC;
		/* 822553A4h case   11:*/		return 0x822553A8;
	}
	return 0x822553A8;
} // Block from 82255378h-822553A8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822553A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822553A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822553A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822553A8);
		  /* 822553A8h */ case    0:  		/* lwz R25, <#[R11 + 28]> */
		/* 822553A8h case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R11 + 0x0000001C) );
		/* 822553A8h case    0:*/		return 0x822553AC;
	}
	return 0x822553AC;
} // Block from 822553A8h-822553ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822553ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822553AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822553AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822553AC);
		  /* 822553ACh */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 822553ACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 822553ACh case    0:*/		return 0x822553B0;
		  /* 822553B0h */ case    1:  		/* bc 4, CR6_EQ, 128 */
		/* 822553B0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82255430;  }
		/* 822553B0h case    1:*/		return 0x822553B4;
		  /* 822553B4h */ case    2:  		/* mr R5, R26 */
		/* 822553B4h case    2:*/		regs.R5 = regs.R26;
		/* 822553B4h case    2:*/		return 0x822553B8;
		  /* 822553B8h */ case    3:  		/* lwz R3, <#[R31 + 172]> */
		/* 822553B8h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 822553B8h case    3:*/		return 0x822553BC;
		  /* 822553BCh */ case    4:  		/* li R4, 15 */
		/* 822553BCh case    4:*/		cpu::op::li<0>(regs,&regs.R4,0xF);
		/* 822553BCh case    4:*/		return 0x822553C0;
		  /* 822553C0h */ case    5:  		/* bl -64432 */
		/* 822553C0h case    5:*/		regs.LR = 0x822553C4; return 0x82245810;
		/* 822553C0h case    5:*/		return 0x822553C4;
		  /* 822553C4h */ case    6:  		/* lwz R29, <#[R30 + 1452]> */
		/* 822553C4h case    6:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x000005AC) );
		/* 822553C4h case    6:*/		return 0x822553C8;
	}
	return 0x822553C8;
} // Block from 822553ACh-822553C8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822553C8h
// Function '?RemoveUse@VRegInfo@XGRAPHICS@@QAAXPAVIRInst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822553C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822553C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822553C8);
		  /* 822553C8h */ case    0:  		/* mr R28, R3 */
		/* 822553C8h case    0:*/		regs.R28 = regs.R3;
		/* 822553C8h case    0:*/		return 0x822553CC;
		  /* 822553CCh */ case    1:  		/* li R4, 964 */
		/* 822553CCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 822553CCh case    1:*/		return 0x822553D0;
		  /* 822553D0h */ case    2:  		/* mr R3, R29 */
		/* 822553D0h case    2:*/		regs.R3 = regs.R29;
		/* 822553D0h case    2:*/		return 0x822553D4;
		  /* 822553D4h */ case    3:  		/* bl -233244 */
		/* 822553D4h case    3:*/		regs.LR = 0x822553D8; return 0x8221C4B8;
		/* 822553D4h case    3:*/		return 0x822553D8;
		  /* 822553D8h */ case    4:  		/* mr R11, R3 */
		/* 822553D8h case    4:*/		regs.R11 = regs.R3;
		/* 822553D8h case    4:*/		return 0x822553DC;
		  /* 822553DCh */ case    5:  		/* addic. R3, R3, 4 */
		/* 822553DCh case    5:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 822553DCh case    5:*/		return 0x822553E0;
		  /* 822553E0h */ case    6:  		/* stw R29, <#[R11]> */
		/* 822553E0h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 822553E0h case    6:*/		return 0x822553E4;
		  /* 822553E4h */ case    7:  		/* bc 12, CR0_EQ, 24 */
		/* 822553E4h case    7:*/		if ( regs.CR[0].eq ) { return 0x822553FC;  }
		/* 822553E4h case    7:*/		return 0x822553E8;
		  /* 822553E8h */ case    8:  		/* mr R5, R30 */
		/* 822553E8h case    8:*/		regs.R5 = regs.R30;
		/* 822553E8h case    8:*/		return 0x822553EC;
		  /* 822553ECh */ case    9:  		/* mr R4, R22 */
		/* 822553ECh case    9:*/		regs.R4 = regs.R22;
		/* 822553ECh case    9:*/		return 0x822553F0;
		  /* 822553F0h */ case   10:  		/* bl 8312 */
		/* 822553F0h case   10:*/		regs.LR = 0x822553F4; return 0x82257468;
		/* 822553F0h case   10:*/		return 0x822553F4;
		  /* 822553F4h */ case   11:  		/* mr R29, R3 */
		/* 822553F4h case   11:*/		regs.R29 = regs.R3;
		/* 822553F4h case   11:*/		return 0x822553F8;
		  /* 822553F8h */ case   12:  		/* b 8 */
		/* 822553F8h case   12:*/		return 0x82255400;
		/* 822553F8h case   12:*/		return 0x822553FC;
	}
	return 0x822553FC;
} // Block from 822553C8h-822553FCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 822553FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822553FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822553FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822553FC);
		  /* 822553FCh */ case    0:  		/* li R29, 0 */
		/* 822553FCh case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 822553FCh case    0:*/		return 0x82255400;
	}
	return 0x82255400;
} // Block from 822553FCh-82255400h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82255400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255400);
		  /* 82255400h */ case    0:  		/* mr R4, R29 */
		/* 82255400h case    0:*/		regs.R4 = regs.R29;
		/* 82255400h case    0:*/		return 0x82255404;
		  /* 82255404h */ case    1:  		/* lwz R3, <#[R31 + 164]> */
		/* 82255404h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000A4) );
		/* 82255404h case    1:*/		return 0x82255408;
		  /* 82255408h */ case    2:  		/* bl 15216 */
		/* 82255408h case    2:*/		regs.LR = 0x8225540C; return 0x82258F78;
		/* 82255408h case    2:*/		return 0x8225540C;
		  /* 8225540Ch */ case    3:  		/* mr R5, R28 */
		/* 8225540Ch case    3:*/		regs.R5 = regs.R28;
		/* 8225540Ch case    3:*/		return 0x82255410;
		  /* 82255410h */ case    4:  		/* li R4, 0 */
		/* 82255410h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82255410h case    4:*/		return 0x82255414;
		  /* 82255414h */ case    5:  		/* mr R3, R29 */
		/* 82255414h case    5:*/		regs.R3 = regs.R29;
		/* 82255414h case    5:*/		return 0x82255418;
		  /* 82255418h */ case    6:  		/* bl 3968 */
		/* 82255418h case    6:*/		regs.LR = 0x8225541C; return 0x82256398;
		/* 82255418h case    6:*/		return 0x8225541C;
		  /* 8225541Ch */ case    7:  		/* mr R4, R29 */
		/* 8225541Ch case    7:*/		regs.R4 = regs.R29;
		/* 8225541Ch case    7:*/		return 0x82255420;
		  /* 82255420h */ case    8:  		/* mr R3, R28 */
		/* 82255420h case    8:*/		regs.R3 = regs.R28;
		/* 82255420h case    8:*/		return 0x82255424;
		  /* 82255424h */ case    9:  		/* bl -4028 */
		/* 82255424h case    9:*/		regs.LR = 0x82255428; return 0x82254468;
		/* 82255424h case    9:*/		return 0x82255428;
		  /* 82255428h */ case   10:  		/* stwx R29, <#[R23 + R31]> */
		/* 82255428h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R23 + regs.R31 + 0x00000000) );
		/* 82255428h case   10:*/		return 0x8225542C;
		  /* 8225542Ch */ case   11:  		/* b 8 */
		/* 8225542Ch case   11:*/		return 0x82255434;
		/* 8225542Ch case   11:*/		return 0x82255430;
	}
	return 0x82255430;
} // Block from 82255400h-82255430h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82255430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255430);
		  /* 82255430h */ case    0:  		/* lwz R28, <#[R24 + 28]> */
		/* 82255430h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R24 + 0x0000001C) );
		/* 82255430h case    0:*/		return 0x82255434;
	}
	return 0x82255434;
} // Block from 82255430h-82255434h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82255434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255434);
		  /* 82255434h */ case    0:  		/* mr R4, R30 */
		/* 82255434h case    0:*/		regs.R4 = regs.R30;
		/* 82255434h case    0:*/		return 0x82255438;
		  /* 82255438h */ case    1:  		/* li R3, 49 */
		/* 82255438h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 82255438h case    1:*/		return 0x8225543C;
		  /* 8225543Ch */ case    2:  		/* bl 10540 */
		/* 8225543Ch case    2:*/		regs.LR = 0x82255440; return 0x82257D68;
		/* 8225543Ch case    2:*/		return 0x82255440;
		  /* 82255440h */ case    3:  		/* mr R5, R25 */
		/* 82255440h case    3:*/		regs.R5 = regs.R25;
		/* 82255440h case    3:*/		return 0x82255444;
		  /* 82255444h */ case    4:  		/* li R4, 1 */
		/* 82255444h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82255444h case    4:*/		return 0x82255448;
		  /* 82255448h */ case    5:  		/* mr R29, R3 */
		/* 82255448h case    5:*/		regs.R29 = regs.R3;
		/* 82255448h case    5:*/		return 0x8225544C;
		  /* 8225544Ch */ case    6:  		/* bl 3916 */
		/* 8225544Ch case    6:*/		regs.LR = 0x82255450; return 0x82256398;
		/* 8225544Ch case    6:*/		return 0x82255450;
	}
	return 0x82255450;
} // Block from 82255434h-82255450h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82255450h
// Function '?CreateReplacingTempIfNecessary@ExportValue@XGRAPHICS@@UAAPAVVRegInfo@2@TSwizzleOrMaskInfo@2@PAVCFG@2@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255450);
		  /* 82255450h */ case    0:  		/* lwz R10, <#[R1 + 80]> */
		/* 82255450h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82255450h case    0:*/		return 0x82255454;
		  /* 82255454h */ case    1:  		/* addi R11, R27, 4 */
		/* 82255454h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x4);
		/* 82255454h case    1:*/		return 0x82255458;
		  /* 82255458h */ case    2:  		/* rlwinm R10, R10, 4, 0, 27 */
		/* 82255458h case    2:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R10);
		/* 82255458h case    2:*/		return 0x8225545C;
		  /* 8225545Ch */ case    3:  		/* mr R3, R29 */
		/* 8225545Ch case    3:*/		regs.R3 = regs.R29;
		/* 8225545Ch case    3:*/		return 0x82255460;
		  /* 82255460h */ case    4:  		/* mr R5, R22 */
		/* 82255460h case    4:*/		regs.R5 = regs.R22;
		/* 82255460h case    4:*/		return 0x82255464;
		  /* 82255464h */ case    5:  		/* li R4, 0 */
		/* 82255464h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82255464h case    5:*/		return 0x82255468;
		  /* 82255468h */ case    6:  		/* lwzx R10, <#[R10 + R21]> */
		/* 82255468h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R21 + 0x00000000) );
		/* 82255468h case    6:*/		return 0x8225546C;
		  /* 8225546Ch */ case    7:  		/* rlwinm R10, R10, 4, 0, 27 */
		/* 8225546Ch case    7:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R10);
		/* 8225546Ch case    7:*/		return 0x82255470;
		  /* 82255470h */ case    8:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82255470h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82255470h case    8:*/		return 0x82255474;
		  /* 82255474h */ case    9:  		/* stw R11, <#[R29 + 132]> */
		/* 82255474h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000084) );
		/* 82255474h case    9:*/		return 0x82255478;
		  /* 82255478h */ case   10:  		/* bl 3872 */
		/* 82255478h case   10:*/		regs.LR = 0x8225547C; return 0x82256398;
		/* 82255478h case   10:*/		return 0x8225547C;
		  /* 8225547Ch */ case   11:  		/* mr R4, R29 */
		/* 8225547Ch case   11:*/		regs.R4 = regs.R29;
		/* 8225547Ch case   11:*/		return 0x82255480;
		  /* 82255480h */ case   12:  		/* mr R3, R22 */
		/* 82255480h case   12:*/		regs.R3 = regs.R22;
		/* 82255480h case   12:*/		return 0x82255484;
		  /* 82255484h */ case   13:  		/* bl -4124 */
		/* 82255484h case   13:*/		regs.LR = 0x82255488; return 0x82254468;
		/* 82255484h case   13:*/		return 0x82255488;
		  /* 82255488h */ case   14:  		/* mr R4, R29 */
		/* 82255488h case   14:*/		regs.R4 = regs.R29;
		/* 82255488h case   14:*/		return 0x8225548C;
		  /* 8225548Ch */ case   15:  		/* lwz R3, <#[R31 + 164]> */
		/* 8225548Ch case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000A4) );
		/* 8225548Ch case   15:*/		return 0x82255490;
		  /* 82255490h */ case   16:  		/* bl 15008 */
		/* 82255490h case   16:*/		regs.LR = 0x82255494; return 0x82258F30;
		/* 82255490h case   16:*/		return 0x82255494;
		  /* 82255494h */ case   17:  		/* mr R4, R30 */
		/* 82255494h case   17:*/		regs.R4 = regs.R30;
		/* 82255494h case   17:*/		return 0x82255498;
		  /* 82255498h */ case   18:  		/* li R3, 49 */
		/* 82255498h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 82255498h case   18:*/		return 0x8225549C;
		  /* 8225549Ch */ case   19:  		/* bl 10444 */
		/* 8225549Ch case   19:*/		regs.LR = 0x822554A0; return 0x82257D68;
		/* 8225549Ch case   19:*/		return 0x822554A0;
		  /* 822554A0h */ case   20:  		/* mr R5, R28 */
		/* 822554A0h case   20:*/		regs.R5 = regs.R28;
		/* 822554A0h case   20:*/		return 0x822554A4;
		  /* 822554A4h */ case   21:  		/* li R4, 1 */
		/* 822554A4h case   21:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822554A4h case   21:*/		return 0x822554A8;
		  /* 822554A8h */ case   22:  		/* mr R30, R3 */
		/* 822554A8h case   22:*/		regs.R30 = regs.R3;
		/* 822554A8h case   22:*/		return 0x822554AC;
		  /* 822554ACh */ case   23:  		/* bl 3820 */
		/* 822554ACh case   23:*/		regs.LR = 0x822554B0; return 0x82256398;
		/* 822554ACh case   23:*/		return 0x822554B0;
		  /* 822554B0h */ case   24:  		/* lwz R10, <#[R1 + 80]> */
		/* 822554B0h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 822554B0h case   24:*/		return 0x822554B4;
		  /* 822554B4h */ case   25:  		/* addi R11, R27, 12 */
		/* 822554B4h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0xC);
		/* 822554B4h case   25:*/		return 0x822554B8;
		  /* 822554B8h */ case   26:  		/* rlwinm R10, R10, 4, 0, 27 */
		/* 822554B8h case   26:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R10);
		/* 822554B8h case   26:*/		return 0x822554BC;
		  /* 822554BCh */ case   27:  		/* lwzx R10, <#[R10 + R21]> */
		/* 822554BCh case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R21 + 0x00000000) );
		/* 822554BCh case   27:*/		return 0x822554C0;
		  /* 822554C0h */ case   28:  		/* rlwinm R10, R10, 4, 0, 27 */
		/* 822554C0h case   28:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R10);
		/* 822554C0h case   28:*/		return 0x822554C4;
		  /* 822554C4h */ case   29:  		/* b 220 */
		/* 822554C4h case   29:*/		return 0x822555A0;
		/* 822554C4h case   29:*/		return 0x822554C8;
	}
	return 0x822554C8;
} // Block from 82255450h-822554C8h (30 instructions)

//////////////////////////////////////////////////////
// Block at 822554C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822554C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822554C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822554C8);
		  /* 822554C8h */ case    0:  		/* lis R11, -32252 */
		/* 822554C8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822554C8h case    0:*/		return 0x822554CC;
		  /* 822554CCh */ case    1:  		/* rlwinm R10, R9, 5, 0, 26 */
		/* 822554CCh case    1:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R9);
		/* 822554CCh case    1:*/		return 0x822554D0;
		  /* 822554D0h */ case    2:  		/* addi R26, R11, 28088 */
		/* 822554D0h case    2:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x6DB8);
		/* 822554D0h case    2:*/		return 0x822554D4;
		  /* 822554D4h */ case    3:  		/* lis R11, -32252 */
		/* 822554D4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822554D4h case    3:*/		return 0x822554D8;
		  /* 822554D8h */ case    4:  		/* addi R11, R11, 27584 */
		/* 822554D8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6BC0);
		/* 822554D8h case    4:*/		return 0x822554DC;
		  /* 822554DCh */ case    5:  		/* lwzx R10, <#[R10 + R26]> */
		/* 822554DCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R26 + 0x00000000) );
		/* 822554DCh case    5:*/		return 0x822554E0;
		  /* 822554E0h */ case    6:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 822554E0h case    6:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 822554E0h case    6:*/		return 0x822554E4;
		  /* 822554E4h */ case    7:  		/* lwzx R5, <#[R10 + R11]> */
		/* 822554E4h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822554E4h case    7:*/		return 0x822554E8;
		  /* 822554E8h */ case    8:  		/* addi R11, R5, 6 */
		/* 822554E8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0x6);
		/* 822554E8h case    8:*/		return 0x822554EC;
		  /* 822554ECh */ case    9:  		/* rlwinm R27, R11, 2, 0, 29 */
		/* 822554ECh case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R11);
		/* 822554ECh case    9:*/		return 0x822554F0;
		  /* 822554F0h */ case   10:  		/* lwzx R11, <#[R27 + R31]> */
		/* 822554F0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + regs.R31 + 0x00000000) );
		/* 822554F0h case   10:*/		return 0x822554F4;
		  /* 822554F4h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 822554F4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822554F4h case   11:*/		return 0x822554F8;
		  /* 822554F8h */ case   12:  		/* bc 4, CR6_EQ, 124 */
		/* 822554F8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82255574;  }
		/* 822554F8h case   12:*/		return 0x822554FC;
		  /* 822554FCh */ case   13:  		/* li R4, 15 */
		/* 822554FCh case   13:*/		cpu::op::li<0>(regs,&regs.R4,0xF);
		/* 822554FCh case   13:*/		return 0x82255500;
		  /* 82255500h */ case   14:  		/* lwz R3, <#[R31 + 172]> */
		/* 82255500h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 82255500h case   14:*/		return 0x82255504;
		  /* 82255504h */ case   15:  		/* bl -64756 */
		/* 82255504h case   15:*/		regs.LR = 0x82255508; return 0x82245810;
		/* 82255504h case   15:*/		return 0x82255508;
		  /* 82255508h */ case   16:  		/* lwz R29, <#[R30 + 1452]> */
		/* 82255508h case   16:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x000005AC) );
		/* 82255508h case   16:*/		return 0x8225550C;
		  /* 8225550Ch */ case   17:  		/* mr R28, R3 */
		/* 8225550Ch case   17:*/		regs.R28 = regs.R3;
		/* 8225550Ch case   17:*/		return 0x82255510;
		  /* 82255510h */ case   18:  		/* li R4, 964 */
		/* 82255510h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82255510h case   18:*/		return 0x82255514;
		  /* 82255514h */ case   19:  		/* mr R3, R29 */
		/* 82255514h case   19:*/		regs.R3 = regs.R29;
		/* 82255514h case   19:*/		return 0x82255518;
		  /* 82255518h */ case   20:  		/* bl -233568 */
		/* 82255518h case   20:*/		regs.LR = 0x8225551C; return 0x8221C4B8;
		/* 82255518h case   20:*/		return 0x8225551C;
		  /* 8225551Ch */ case   21:  		/* mr R11, R3 */
		/* 8225551Ch case   21:*/		regs.R11 = regs.R3;
		/* 8225551Ch case   21:*/		return 0x82255520;
		  /* 82255520h */ case   22:  		/* addic. R3, R3, 4 */
		/* 82255520h case   22:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82255520h case   22:*/		return 0x82255524;
		  /* 82255524h */ case   23:  		/* stw R29, <#[R11]> */
		/* 82255524h case   23:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82255524h case   23:*/		return 0x82255528;
		  /* 82255528h */ case   24:  		/* bc 12, CR0_EQ, 24 */
		/* 82255528h case   24:*/		if ( regs.CR[0].eq ) { return 0x82255540;  }
		/* 82255528h case   24:*/		return 0x8225552C;
		  /* 8225552Ch */ case   25:  		/* mr R5, R30 */
		/* 8225552Ch case   25:*/		regs.R5 = regs.R30;
		/* 8225552Ch case   25:*/		return 0x82255530;
		  /* 82255530h */ case   26:  		/* mr R4, R22 */
		/* 82255530h case   26:*/		regs.R4 = regs.R22;
		/* 82255530h case   26:*/		return 0x82255534;
		  /* 82255534h */ case   27:  		/* bl 7988 */
		/* 82255534h case   27:*/		regs.LR = 0x82255538; return 0x82257468;
		/* 82255534h case   27:*/		return 0x82255538;
		  /* 82255538h */ case   28:  		/* mr R29, R3 */
		/* 82255538h case   28:*/		regs.R29 = regs.R3;
		/* 82255538h case   28:*/		return 0x8225553C;
		  /* 8225553Ch */ case   29:  		/* b 8 */
		/* 8225553Ch case   29:*/		return 0x82255544;
		/* 8225553Ch case   29:*/		return 0x82255540;
	}
	return 0x82255540;
} // Block from 822554C8h-82255540h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82255540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255540);
		  /* 82255540h */ case    0:  		/* li R29, 0 */
		/* 82255540h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82255540h case    0:*/		return 0x82255544;
	}
	return 0x82255544;
} // Block from 82255540h-82255544h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82255544h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255544( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255544) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255544);
		  /* 82255544h */ case    0:  		/* mr R4, R29 */
		/* 82255544h case    0:*/		regs.R4 = regs.R29;
		/* 82255544h case    0:*/		return 0x82255548;
		  /* 82255548h */ case    1:  		/* lwz R3, <#[R31 + 164]> */
		/* 82255548h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000A4) );
		/* 82255548h case    1:*/		return 0x8225554C;
		  /* 8225554Ch */ case    2:  		/* bl 14892 */
		/* 8225554Ch case    2:*/		regs.LR = 0x82255550; return 0x82258F78;
		/* 8225554Ch case    2:*/		return 0x82255550;
		  /* 82255550h */ case    3:  		/* mr R5, R28 */
		/* 82255550h case    3:*/		regs.R5 = regs.R28;
		/* 82255550h case    3:*/		return 0x82255554;
		  /* 82255554h */ case    4:  		/* li R4, 0 */
		/* 82255554h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82255554h case    4:*/		return 0x82255558;
		  /* 82255558h */ case    5:  		/* mr R3, R29 */
		/* 82255558h case    5:*/		regs.R3 = regs.R29;
		/* 82255558h case    5:*/		return 0x8225555C;
		  /* 8225555Ch */ case    6:  		/* bl 3644 */
		/* 8225555Ch case    6:*/		regs.LR = 0x82255560; return 0x82256398;
		/* 8225555Ch case    6:*/		return 0x82255560;
		  /* 82255560h */ case    7:  		/* mr R4, R29 */
		/* 82255560h case    7:*/		regs.R4 = regs.R29;
		/* 82255560h case    7:*/		return 0x82255564;
		  /* 82255564h */ case    8:  		/* mr R3, R28 */
		/* 82255564h case    8:*/		regs.R3 = regs.R28;
		/* 82255564h case    8:*/		return 0x82255568;
		  /* 82255568h */ case    9:  		/* bl -4352 */
		/* 82255568h case    9:*/		regs.LR = 0x8225556C; return 0x82254468;
		/* 82255568h case    9:*/		return 0x8225556C;
		  /* 8225556Ch */ case   10:  		/* stwx R29, <#[R27 + R31]> */
		/* 8225556Ch case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R27 + regs.R31 + 0x00000000) );
		/* 8225556Ch case   10:*/		return 0x82255570;
		  /* 82255570h */ case   11:  		/* b 8 */
		/* 82255570h case   11:*/		return 0x82255578;
		/* 82255570h case   11:*/		return 0x82255574;
	}
	return 0x82255574;
} // Block from 82255544h-82255574h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82255574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255574);
		  /* 82255574h */ case    0:  		/* lwz R28, <#[R11 + 28]> */
		/* 82255574h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x0000001C) );
		/* 82255574h case    0:*/		return 0x82255578;
	}
	return 0x82255578;
} // Block from 82255574h-82255578h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82255578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255578);
		  /* 82255578h */ case    0:  		/* mr R4, R30 */
		/* 82255578h case    0:*/		regs.R4 = regs.R30;
		/* 82255578h case    0:*/		return 0x8225557C;
		  /* 8225557Ch */ case    1:  		/* li R3, 49 */
		/* 8225557Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8225557Ch case    1:*/		return 0x82255580;
		  /* 82255580h */ case    2:  		/* bl 10216 */
		/* 82255580h case    2:*/		regs.LR = 0x82255584; return 0x82257D68;
		/* 82255580h case    2:*/		return 0x82255584;
		  /* 82255584h */ case    3:  		/* mr R5, R28 */
		/* 82255584h case    3:*/		regs.R5 = regs.R28;
		/* 82255584h case    3:*/		return 0x82255588;
		  /* 82255588h */ case    4:  		/* li R4, 1 */
		/* 82255588h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82255588h case    4:*/		return 0x8225558C;
		  /* 8225558Ch */ case    5:  		/* mr R30, R3 */
		/* 8225558Ch case    5:*/		regs.R30 = regs.R3;
		/* 8225558Ch case    5:*/		return 0x82255590;
		  /* 82255590h */ case    6:  		/* bl 3592 */
		/* 82255590h case    6:*/		regs.LR = 0x82255594; return 0x82256398;
		/* 82255590h case    6:*/		return 0x82255594;
		  /* 82255594h */ case    7:  		/* lwz R10, <#[R1 + 80]> */
		/* 82255594h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82255594h case    7:*/		return 0x82255598;
		  /* 82255598h */ case    8:  		/* addi R11, R26, 4 */
		/* 82255598h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x4);
		/* 82255598h case    8:*/		return 0x8225559C;
		  /* 8225559Ch */ case    9:  		/* rlwinm R10, R10, 5, 0, 26 */
		/* 8225559Ch case    9:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R10);
		/* 8225559Ch case    9:*/		return 0x822555A0;
	}
	return 0x822555A0;
} // Block from 82255578h-822555A0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822555A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822555A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822555A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822555A0);
		  /* 822555A0h */ case    0:  		/* lwzx R11, <#[R10 + R11]> */
		/* 822555A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822555A0h case    0:*/		return 0x822555A4;
		  /* 822555A4h */ case    1:  		/* stw R11, <#[R30 + 132]> */
		/* 822555A4h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 822555A4h case    1:*/		return 0x822555A8;
	}
	return 0x822555A8;
} // Block from 822555A0h-822555A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822555A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822555A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822555A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822555A8);
		  /* 822555A8h */ case    0:  		/* mr R5, R22 */
		/* 822555A8h case    0:*/		regs.R5 = regs.R22;
		/* 822555A8h case    0:*/		return 0x822555AC;
		  /* 822555ACh */ case    1:  		/* li R4, 0 */
		/* 822555ACh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822555ACh case    1:*/		return 0x822555B0;
		  /* 822555B0h */ case    2:  		/* mr R3, R30 */
		/* 822555B0h case    2:*/		regs.R3 = regs.R30;
		/* 822555B0h case    2:*/		return 0x822555B4;
		  /* 822555B4h */ case    3:  		/* bl 3556 */
		/* 822555B4h case    3:*/		regs.LR = 0x822555B8; return 0x82256398;
		/* 822555B4h case    3:*/		return 0x822555B8;
		  /* 822555B8h */ case    4:  		/* mr R4, R30 */
		/* 822555B8h case    4:*/		regs.R4 = regs.R30;
		/* 822555B8h case    4:*/		return 0x822555BC;
		  /* 822555BCh */ case    5:  		/* mr R3, R22 */
		/* 822555BCh case    5:*/		regs.R3 = regs.R22;
		/* 822555BCh case    5:*/		return 0x822555C0;
		  /* 822555C0h */ case    6:  		/* bl -4440 */
		/* 822555C0h case    6:*/		regs.LR = 0x822555C4; return 0x82254468;
		/* 822555C0h case    6:*/		return 0x822555C4;
		  /* 822555C4h */ case    7:  		/* mr R4, R30 */
		/* 822555C4h case    7:*/		regs.R4 = regs.R30;
		/* 822555C4h case    7:*/		return 0x822555C8;
		  /* 822555C8h */ case    8:  		/* lwz R3, <#[R31 + 164]> */
		/* 822555C8h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000A4) );
		/* 822555C8h case    8:*/		return 0x822555CC;
		  /* 822555CCh */ case    9:  		/* bl 14692 */
		/* 822555CCh case    9:*/		regs.LR = 0x822555D0; return 0x82258F30;
		/* 822555CCh case    9:*/		return 0x822555D0;
		  /* 822555D0h */ case   10:  		/* mr R3, R22 */
		/* 822555D0h case   10:*/		regs.R3 = regs.R22;
		/* 822555D0h case   10:*/		return 0x822555D4;
		  /* 822555D4h */ case   11:  		/* addi R1, R1, 192 */
		/* 822555D4h case   11:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 822555D4h case   11:*/		return 0x822555D8;
		  /* 822555D8h */ case   12:  		/* b -1852236 */
		/* 822555D8h case   12:*/		return 0x8209128C;
		/* 822555D8h case   12:*/		return 0x822555DC;
		  /* 822555DCh */ case   13:  		/* nop */
		/* 822555DCh case   13:*/		cpu::op::nop();
		/* 822555DCh case   13:*/		return 0x822555E0;
	}
	return 0x822555E0;
} // Block from 822555A8h-822555E0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822555E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822555E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822555E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822555E0);
		  /* 822555E0h */ case    0:  		/* mfspr R12, LR */
		/* 822555E0h case    0:*/		regs.R12 = regs.LR;
		/* 822555E0h case    0:*/		return 0x822555E4;
		  /* 822555E4h */ case    1:  		/* bl -1852308 */
		/* 822555E4h case    1:*/		regs.LR = 0x822555E8; return 0x82091250;
		/* 822555E4h case    1:*/		return 0x822555E8;
		  /* 822555E8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 822555E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 822555E8h case    2:*/		return 0x822555EC;
		  /* 822555ECh */ case    3:  		/* mr R30, R3 */
		/* 822555ECh case    3:*/		regs.R30 = regs.R3;
		/* 822555ECh case    3:*/		return 0x822555F0;
		  /* 822555F0h */ case    4:  		/* mr R31, R6 */
		/* 822555F0h case    4:*/		regs.R31 = regs.R6;
		/* 822555F0h case    4:*/		return 0x822555F4;
		  /* 822555F4h */ case    5:  		/* bl -2036 */
		/* 822555F4h case    5:*/		regs.LR = 0x822555F8; return 0x82254E00;
		/* 822555F4h case    5:*/		return 0x822555F8;
		  /* 822555F8h */ case    6:  		/* lis R11, -32252 */
		/* 822555F8h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822555F8h case    6:*/		return 0x822555FC;
		  /* 822555FCh */ case    7:  		/* lis R10, -32252 */
		/* 822555FCh case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 822555FCh case    7:*/		return 0x82255600;
		  /* 82255600h */ case    8:  		/* addi R11, R11, 27388 */
		/* 82255600h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6AFC);
		/* 82255600h case    8:*/		return 0x82255604;
		  /* 82255604h */ case    9:  		/* addi R10, R10, 27584 */
		/* 82255604h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x6BC0);
		/* 82255604h case    9:*/		return 0x82255608;
		  /* 82255608h */ case   10:  		/* stw R11, <#[R30]> */
		/* 82255608h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82255608h case   10:*/		return 0x8225560C;
		  /* 8225560Ch */ case   11:  		/* lwz R5, <#[R10 + 160]> */
		/* 8225560Ch case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x000000A0) );
		/* 8225560Ch case   11:*/		return 0x82255610;
	}
	return 0x82255610;
} // Block from 822555E0h-82255610h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82255610h
// Function '?CreateReplacingTempIfNecessary@Interpolator@XGRAPHICS@@UAAPAVVRegInfo@2@TSwizzleOrMaskInfo@2@PAVCFG@2@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255610);
		  /* 82255610h */ case    0:  		/* addi R11, R5, 6 */
		/* 82255610h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0x6);
		/* 82255610h case    0:*/		return 0x82255614;
		  /* 82255614h */ case    1:  		/* lwz R29, <#[R31 + 2736]> */
		/* 82255614h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000AB0) );
		/* 82255614h case    1:*/		return 0x82255618;
		  /* 82255618h */ case    2:  		/* rlwinm R26, R11, 2, 0, 29 */
		/* 82255618h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R26,regs.R11);
		/* 82255618h case    2:*/		return 0x8225561C;
		  /* 8225561Ch */ case    3:  		/* lwzx R11, <#[R26 + R29]> */
		/* 8225561Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + regs.R29 + 0x00000000) );
		/* 8225561Ch case    3:*/		return 0x82255620;
		  /* 82255620h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82255620h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82255620h case    4:*/		return 0x82255624;
		  /* 82255624h */ case    5:  		/* bc 4, CR6_EQ, 124 */
		/* 82255624h case    5:*/		if ( !regs.CR[6].eq ) { return 0x822556A0;  }
		/* 82255624h case    5:*/		return 0x82255628;
		  /* 82255628h */ case    6:  		/* li R4, 15 */
		/* 82255628h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0xF);
		/* 82255628h case    6:*/		return 0x8225562C;
		  /* 8225562Ch */ case    7:  		/* lwz R3, <#[R29 + 172]> */
		/* 8225562Ch case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x000000AC) );
		/* 8225562Ch case    7:*/		return 0x82255630;
		  /* 82255630h */ case    8:  		/* bl -65056 */
		/* 82255630h case    8:*/		regs.LR = 0x82255634; return 0x82245810;
		/* 82255630h case    8:*/		return 0x82255634;
		  /* 82255634h */ case    9:  		/* lwz R28, <#[R31 + 1452]> */
		/* 82255634h case    9:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x000005AC) );
		/* 82255634h case    9:*/		return 0x82255638;
		  /* 82255638h */ case   10:  		/* mr R27, R3 */
		/* 82255638h case   10:*/		regs.R27 = regs.R3;
		/* 82255638h case   10:*/		return 0x8225563C;
		  /* 8225563Ch */ case   11:  		/* li R4, 964 */
		/* 8225563Ch case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 8225563Ch case   11:*/		return 0x82255640;
		  /* 82255640h */ case   12:  		/* mr R3, R28 */
		/* 82255640h case   12:*/		regs.R3 = regs.R28;
		/* 82255640h case   12:*/		return 0x82255644;
		  /* 82255644h */ case   13:  		/* bl -233868 */
		/* 82255644h case   13:*/		regs.LR = 0x82255648; return 0x8221C4B8;
		/* 82255644h case   13:*/		return 0x82255648;
		  /* 82255648h */ case   14:  		/* mr R11, R3 */
		/* 82255648h case   14:*/		regs.R11 = regs.R3;
		/* 82255648h case   14:*/		return 0x8225564C;
		  /* 8225564Ch */ case   15:  		/* addic. R3, R3, 4 */
		/* 8225564Ch case   15:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 8225564Ch case   15:*/		return 0x82255650;
		  /* 82255650h */ case   16:  		/* stw R28, <#[R11]> */
		/* 82255650h case   16:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82255650h case   16:*/		return 0x82255654;
		  /* 82255654h */ case   17:  		/* bc 12, CR0_EQ, 24 */
		/* 82255654h case   17:*/		if ( regs.CR[0].eq ) { return 0x8225566C;  }
		/* 82255654h case   17:*/		return 0x82255658;
		  /* 82255658h */ case   18:  		/* mr R5, R31 */
		/* 82255658h case   18:*/		regs.R5 = regs.R31;
		/* 82255658h case   18:*/		return 0x8225565C;
		  /* 8225565Ch */ case   19:  		/* mr R4, R30 */
		/* 8225565Ch case   19:*/		regs.R4 = regs.R30;
		/* 8225565Ch case   19:*/		return 0x82255660;
		  /* 82255660h */ case   20:  		/* bl 7688 */
		/* 82255660h case   20:*/		regs.LR = 0x82255664; return 0x82257468;
		/* 82255660h case   20:*/		return 0x82255664;
		  /* 82255664h */ case   21:  		/* mr R28, R3 */
		/* 82255664h case   21:*/		regs.R28 = regs.R3;
		/* 82255664h case   21:*/		return 0x82255668;
		  /* 82255668h */ case   22:  		/* b 8 */
		/* 82255668h case   22:*/		return 0x82255670;
		/* 82255668h case   22:*/		return 0x8225566C;
	}
	return 0x8225566C;
} // Block from 82255610h-8225566Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 8225566Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225566C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225566C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225566C);
		  /* 8225566Ch */ case    0:  		/* li R28, 0 */
		/* 8225566Ch case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8225566Ch case    0:*/		return 0x82255670;
	}
	return 0x82255670;
} // Block from 8225566Ch-82255670h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82255670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255670);
		  /* 82255670h */ case    0:  		/* mr R4, R28 */
		/* 82255670h case    0:*/		regs.R4 = regs.R28;
		/* 82255670h case    0:*/		return 0x82255674;
		  /* 82255674h */ case    1:  		/* lwz R3, <#[R29 + 164]> */
		/* 82255674h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x000000A4) );
		/* 82255674h case    1:*/		return 0x82255678;
		  /* 82255678h */ case    2:  		/* bl 14592 */
		/* 82255678h case    2:*/		regs.LR = 0x8225567C; return 0x82258F78;
		/* 82255678h case    2:*/		return 0x8225567C;
		  /* 8225567Ch */ case    3:  		/* mr R5, R27 */
		/* 8225567Ch case    3:*/		regs.R5 = regs.R27;
		/* 8225567Ch case    3:*/		return 0x82255680;
		  /* 82255680h */ case    4:  		/* li R4, 0 */
		/* 82255680h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82255680h case    4:*/		return 0x82255684;
		  /* 82255684h */ case    5:  		/* mr R3, R28 */
		/* 82255684h case    5:*/		regs.R3 = regs.R28;
		/* 82255684h case    5:*/		return 0x82255688;
		  /* 82255688h */ case    6:  		/* bl 3344 */
		/* 82255688h case    6:*/		regs.LR = 0x8225568C; return 0x82256398;
		/* 82255688h case    6:*/		return 0x8225568C;
		  /* 8225568Ch */ case    7:  		/* mr R4, R28 */
		/* 8225568Ch case    7:*/		regs.R4 = regs.R28;
		/* 8225568Ch case    7:*/		return 0x82255690;
		  /* 82255690h */ case    8:  		/* mr R3, R27 */
		/* 82255690h case    8:*/		regs.R3 = regs.R27;
		/* 82255690h case    8:*/		return 0x82255694;
		  /* 82255694h */ case    9:  		/* bl -4652 */
		/* 82255694h case    9:*/		regs.LR = 0x82255698; return 0x82254468;
		/* 82255694h case    9:*/		return 0x82255698;
		  /* 82255698h */ case   10:  		/* stwx R28, <#[R26 + R29]> */
		/* 82255698h case   10:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R26 + regs.R29 + 0x00000000) );
		/* 82255698h case   10:*/		return 0x8225569C;
		  /* 8225569Ch */ case   11:  		/* b 8 */
		/* 8225569Ch case   11:*/		return 0x822556A4;
		/* 8225569Ch case   11:*/		return 0x822556A0;
	}
	return 0x822556A0;
} // Block from 82255670h-822556A0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822556A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822556A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822556A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822556A0);
		  /* 822556A0h */ case    0:  		/* lwz R27, <#[R11 + 28]> */
		/* 822556A0h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x0000001C) );
		/* 822556A0h case    0:*/		return 0x822556A4;
	}
	return 0x822556A4;
} // Block from 822556A0h-822556A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822556A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822556A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822556A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822556A4);
		  /* 822556A4h */ case    0:  		/* mr R4, R31 */
		/* 822556A4h case    0:*/		regs.R4 = regs.R31;
		/* 822556A4h case    0:*/		return 0x822556A8;
		  /* 822556A8h */ case    1:  		/* li R3, 49 */
		/* 822556A8h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 822556A8h case    1:*/		return 0x822556AC;
		  /* 822556ACh */ case    2:  		/* bl 9916 */
		/* 822556ACh case    2:*/		regs.LR = 0x822556B0; return 0x82257D68;
		/* 822556ACh case    2:*/		return 0x822556B0;
		  /* 822556B0h */ case    3:  		/* mr R5, R27 */
		/* 822556B0h case    3:*/		regs.R5 = regs.R27;
		/* 822556B0h case    3:*/		return 0x822556B4;
		  /* 822556B4h */ case    4:  		/* li R4, 1 */
		/* 822556B4h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822556B4h case    4:*/		return 0x822556B8;
		  /* 822556B8h */ case    5:  		/* mr R31, R3 */
		/* 822556B8h case    5:*/		regs.R31 = regs.R3;
		/* 822556B8h case    5:*/		return 0x822556BC;
		  /* 822556BCh */ case    6:  		/* bl 3292 */
		/* 822556BCh case    6:*/		regs.LR = 0x822556C0; return 0x82256398;
		/* 822556BCh case    6:*/		return 0x822556C0;
		  /* 822556C0h */ case    7:  		/* mr R3, R31 */
		/* 822556C0h case    7:*/		regs.R3 = regs.R31;
		/* 822556C0h case    7:*/		return 0x822556C4;
		  /* 822556C4h */ case    8:  		/* mr R5, R30 */
		/* 822556C4h case    8:*/		regs.R5 = regs.R30;
		/* 822556C4h case    8:*/		return 0x822556C8;
		  /* 822556C8h */ case    9:  		/* li R4, 0 */
		/* 822556C8h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822556C8h case    9:*/		return 0x822556CC;
		  /* 822556CCh */ case   10:  		/* bl 3276 */
		/* 822556CCh case   10:*/		regs.LR = 0x822556D0; return 0x82256398;
		/* 822556CCh case   10:*/		return 0x822556D0;
		  /* 822556D0h */ case   11:  		/* mr R4, R31 */
		/* 822556D0h case   11:*/		regs.R4 = regs.R31;
		/* 822556D0h case   11:*/		return 0x822556D4;
		  /* 822556D4h */ case   12:  		/* mr R3, R30 */
		/* 822556D4h case   12:*/		regs.R3 = regs.R30;
		/* 822556D4h case   12:*/		return 0x822556D8;
		  /* 822556D8h */ case   13:  		/* bl -4720 */
		/* 822556D8h case   13:*/		regs.LR = 0x822556DC; return 0x82254468;
		/* 822556D8h case   13:*/		return 0x822556DC;
		  /* 822556DCh */ case   14:  		/* mr R4, R31 */
		/* 822556DCh case   14:*/		regs.R4 = regs.R31;
		/* 822556DCh case   14:*/		return 0x822556E0;
		  /* 822556E0h */ case   15:  		/* lwz R3, <#[R29 + 164]> */
		/* 822556E0h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x000000A4) );
		/* 822556E0h case   15:*/		return 0x822556E4;
		  /* 822556E4h */ case   16:  		/* bl 14412 */
		/* 822556E4h case   16:*/		regs.LR = 0x822556E8; return 0x82258F30;
		/* 822556E4h case   16:*/		return 0x822556E8;
		  /* 822556E8h */ case   17:  		/* mr R3, R30 */
		/* 822556E8h case   17:*/		regs.R3 = regs.R30;
		/* 822556E8h case   17:*/		return 0x822556EC;
		  /* 822556ECh */ case   18:  		/* addi R1, R1, 144 */
		/* 822556ECh case   18:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 822556ECh case   18:*/		return 0x822556F0;
		  /* 822556F0h */ case   19:  		/* b -1852496 */
		/* 822556F0h case   19:*/		return 0x820912A0;
		/* 822556F0h case   19:*/		return 0x822556F4;
		  /* 822556F4h */ case   20:  		/* nop */
		/* 822556F4h case   20:*/		cpu::op::nop();
		/* 822556F4h case   20:*/		return 0x822556F8;
	}
	return 0x822556F8;
} // Block from 822556A4h-822556F8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 822556F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822556F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822556F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822556F8);
		  /* 822556F8h */ case    0:  		/* mfspr R12, LR */
		/* 822556F8h case    0:*/		regs.R12 = regs.LR;
		/* 822556F8h case    0:*/		return 0x822556FC;
		  /* 822556FCh */ case    1:  		/* bl -1852608 */
		/* 822556FCh case    1:*/		regs.LR = 0x82255700; return 0x8209123C;
		/* 822556FCh case    1:*/		return 0x82255700;
		  /* 82255700h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82255700h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82255700h case    2:*/		return 0x82255704;
		  /* 82255704h */ case    3:  		/* mr R27, R3 */
		/* 82255704h case    3:*/		regs.R27 = regs.R3;
		/* 82255704h case    3:*/		return 0x82255708;
		  /* 82255708h */ case    4:  		/* mr R28, R5 */
		/* 82255708h case    4:*/		regs.R28 = regs.R5;
		/* 82255708h case    4:*/		return 0x8225570C;
		  /* 8225570Ch */ case    5:  		/* mr R31, R6 */
		/* 8225570Ch case    5:*/		regs.R31 = regs.R6;
		/* 8225570Ch case    5:*/		return 0x82255710;
		  /* 82255710h */ case    6:  		/* bl -2320 */
		/* 82255710h case    6:*/		regs.LR = 0x82255714; return 0x82254E00;
		/* 82255710h case    6:*/		return 0x82255714;
		  /* 82255714h */ case    7:  		/* lis R11, -32252 */
		/* 82255714h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82255714h case    7:*/		return 0x82255718;
		  /* 82255718h */ case    8:  		/* lis R10, -32222 */
		/* 82255718h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8222);
		/* 82255718h case    8:*/		return 0x8225571C;
		  /* 8225571Ch */ case    9:  		/* addi R11, R11, 27388 */
		/* 8225571Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6AFC);
		/* 8225571Ch case    9:*/		return 0x82255720;
		  /* 82255720h */ case   10:  		/* mr R6, R31 */
		/* 82255720h case   10:*/		regs.R6 = regs.R31;
		/* 82255720h case   10:*/		return 0x82255724;
		  /* 82255724h */ case   11:  		/* stw R11, <#[R27]> */
		/* 82255724h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82255724h case   11:*/		return 0x82255728;
		  /* 82255728h */ case   12:  		/* addi R5, R10, -12392 */
		/* 82255728h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFCF98);
		/* 82255728h case   12:*/		return 0x8225572C;
		  /* 8225572Ch */ case   13:  		/* addi R4, R1, 80 */
		/* 8225572Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8225572Ch case   13:*/		return 0x82255730;
		  /* 82255730h */ case   14:  		/* lwz R3, <#[R31 + 1536]> */
		/* 82255730h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000600) );
		/* 82255730h case   14:*/		return 0x82255734;
		  /* 82255734h */ case   15:  		/* lwz R25, <#[R31 + 2736]> */
		/* 82255734h case   15:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R31 + 0x00000AB0) );
		/* 82255734h case   15:*/		return 0x82255738;
		  /* 82255738h */ case   16:  		/* bl -143464 */
		/* 82255738h case   16:*/		regs.LR = 0x8225573C; return 0x822326D0;
		/* 82255738h case   16:*/		return 0x8225573C;
		  /* 8225573Ch */ case   17:  		/* lis R11, -32252 */
		/* 8225573Ch case   17:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8225573Ch case   17:*/		return 0x82255740;
		  /* 82255740h */ case   18:  		/* lis R10, -32253 */
		/* 82255740h case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8203);
		/* 82255740h case   18:*/		return 0x82255744;
		  /* 82255744h */ case   19:  		/* lis R9, -32255 */
		/* 82255744h case   19:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 82255744h case   19:*/		return 0x82255748;
		  /* 82255748h */ case   20:  		/* lis R8, -32252 */
		/* 82255748h case   20:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8204);
		/* 82255748h case   20:*/		return 0x8225574C;
		  /* 8225574Ch */ case   21:  		/* cmpwi CR6, R28, 12 */
		/* 8225574Ch case   21:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x0000000C);
		/* 8225574Ch case   21:*/		return 0x82255750;
		  /* 82255750h */ case   22:  		/* addi R24, R11, 28088 */
		/* 82255750h case   22:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x6DB8);
		/* 82255750h case   22:*/		return 0x82255754;
		  /* 82255754h */ case   23:  		/* addi R23, R10, 27460 */
		/* 82255754h case   23:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R10,0x6B44);
		/* 82255754h case   23:*/		return 0x82255758;
		  /* 82255758h */ case   24:  		/* addi R22, R9, 5216 */
		/* 82255758h case   24:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R9,0x1460);
		/* 82255758h case   24:*/		return 0x8225575C;
		  /* 8225575Ch */ case   25:  		/* addi R21, R8, 26984 */
		/* 8225575Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R8,0x6968);
		/* 8225575Ch case   25:*/		return 0x82255760;
		  /* 82255760h */ case   26:  		/* bc 12, CR6_EQ, 68 */
		/* 82255760h case   26:*/		if ( regs.CR[6].eq ) { return 0x822557A4;  }
		/* 82255760h case   26:*/		return 0x82255764;
		  /* 82255764h */ case   27:  		/* cmpwi CR6, R28, 13 */
		/* 82255764h case   27:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x0000000D);
		/* 82255764h case   27:*/		return 0x82255768;
		  /* 82255768h */ case   28:  		/* bc 12, CR6_EQ, 52 */
		/* 82255768h case   28:*/		if ( regs.CR[6].eq ) { return 0x8225579C;  }
		/* 82255768h case   28:*/		return 0x8225576C;
		  /* 8225576Ch */ case   29:  		/* cmpwi CR6, R28, 14 */
		/* 8225576Ch case   29:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x0000000E);
		/* 8225576Ch case   29:*/		return 0x82255770;
		  /* 82255770h */ case   30:  		/* bc 12, CR6_EQ, 36 */
		/* 82255770h case   30:*/		if ( regs.CR[6].eq ) { return 0x82255794;  }
		/* 82255770h case   30:*/		return 0x82255774;
		  /* 82255774h */ case   31:  		/* mr R6, R21 */
		/* 82255774h case   31:*/		regs.R6 = regs.R21;
		/* 82255774h case   31:*/		return 0x82255778;
		  /* 82255778h */ case   32:  		/* mr R5, R22 */
		/* 82255778h case   32:*/		regs.R5 = regs.R22;
		/* 82255778h case   32:*/		return 0x8225577C;
		  /* 8225577Ch */ case   33:  		/* mr R4, R23 */
		/* 8225577Ch case   33:*/		regs.R4 = regs.R23;
		/* 8225577Ch case   33:*/		return 0x82255780;
	}
	return 0x82255780;
} // Block from 822556F8h-82255780h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82255780h
// Function '??1VRegInfo@XGRAPHICS@@UAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255780);
		  /* 82255780h */ case    0:  		/* li R7, 757 */
		/* 82255780h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x2F5);
		/* 82255780h case    0:*/		return 0x82255784;
		  /* 82255784h */ case    1:  		/* li R3, 0 */
		/* 82255784h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82255784h case    1:*/		return 0x82255788;
		  /* 82255788h */ case    2:  		/* bl -1039232 */
		/* 82255788h case    2:*/		regs.LR = 0x8225578C; return 0x82157C08;
		/* 82255788h case    2:*/		return 0x8225578C;
		  /* 8225578Ch */ case    3:  		/* lwz R11, <#[R1 + 80]> */
		/* 8225578Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8225578Ch case    3:*/		return 0x82255790;
		  /* 82255790h */ case    4:  		/* b 36 */
		/* 82255790h case    4:*/		return 0x822557B4;
		/* 82255790h case    4:*/		return 0x82255794;
	}
	return 0x82255794;
} // Block from 82255780h-82255794h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82255794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255794);
		  /* 82255794h */ case    0:  		/* addi R10, R24, 8 */
		/* 82255794h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R24,0x8);
		/* 82255794h case    0:*/		return 0x82255798;
		  /* 82255798h */ case    1:  		/* b 16 */
		/* 82255798h case    1:*/		return 0x822557A8;
		/* 82255798h case    1:*/		return 0x8225579C;
	}
	return 0x8225579C;
} // Block from 82255794h-8225579Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225579Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225579C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225579C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225579C);
		  /* 8225579Ch */ case    0:  		/* addi R10, R24, 24 */
		/* 8225579Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R24,0x18);
		/* 8225579Ch case    0:*/		return 0x822557A0;
		  /* 822557A0h */ case    1:  		/* b 8 */
		/* 822557A0h case    1:*/		return 0x822557A8;
		/* 822557A0h case    1:*/		return 0x822557A4;
	}
	return 0x822557A4;
} // Block from 8225579Ch-822557A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822557A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822557A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822557A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822557A4);
		  /* 822557A4h */ case    0:  		/* addi R10, R24, 16 */
		/* 822557A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R24,0x10);
		/* 822557A4h case    0:*/		return 0x822557A8;
	}
	return 0x822557A8;
} // Block from 822557A4h-822557A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822557A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822557A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822557A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822557A8);
		  /* 822557A8h */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 822557A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 822557A8h case    0:*/		return 0x822557AC;
		  /* 822557ACh */ case    1:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 822557ACh case    1:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 822557ACh case    1:*/		return 0x822557B0;
		  /* 822557B0h */ case    2:  		/* lwzx R11, <#[R11 + R10]> */
		/* 822557B0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 822557B0h case    2:*/		return 0x822557B4;
	}
	return 0x822557B4;
} // Block from 822557A8h-822557B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822557B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822557B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822557B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822557B4);
		  /* 822557B4h */ case    0:  		/* lis R10, -32252 */
		/* 822557B4h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 822557B4h case    0:*/		return 0x822557B8;
		  /* 822557B8h */ case    1:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 822557B8h case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 822557B8h case    1:*/		return 0x822557BC;
		  /* 822557BCh */ case    2:  		/* addi R10, R10, 27584 */
		/* 822557BCh case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x6BC0);
		/* 822557BCh case    2:*/		return 0x822557C0;
		  /* 822557C0h */ case    3:  		/* lwzx R5, <#[R11 + R10]> */
		/* 822557C0h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 822557C0h case    3:*/		return 0x822557C4;
		  /* 822557C4h */ case    4:  		/* addi R11, R5, 6 */
		/* 822557C4h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0x6);
		/* 822557C4h case    4:*/		return 0x822557C8;
		  /* 822557C8h */ case    5:  		/* rlwinm R26, R11, 2, 0, 29 */
		/* 822557C8h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R26,regs.R11);
		/* 822557C8h case    5:*/		return 0x822557CC;
		  /* 822557CCh */ case    6:  		/* lwzx R11, <#[R26 + R25]> */
		/* 822557CCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + regs.R25 + 0x00000000) );
		/* 822557CCh case    6:*/		return 0x822557D0;
	}
	return 0x822557D0;
} // Block from 822557B4h-822557D0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822557D0h
// Function '??0FixedValue@XGRAPHICS@@QAA@HW4RegType@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822557D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822557D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822557D0);
		  /* 822557D0h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 822557D0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822557D0h case    0:*/		return 0x822557D4;
		  /* 822557D4h */ case    1:  		/* bc 4, CR6_EQ, 124 */
		/* 822557D4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82255850;  }
		/* 822557D4h case    1:*/		return 0x822557D8;
		  /* 822557D8h */ case    2:  		/* li R4, 15 */
		/* 822557D8h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0xF);
		/* 822557D8h case    2:*/		return 0x822557DC;
		  /* 822557DCh */ case    3:  		/* lwz R3, <#[R25 + 172]> */
		/* 822557DCh case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R25 + 0x000000AC) );
		/* 822557DCh case    3:*/		return 0x822557E0;
		  /* 822557E0h */ case    4:  		/* bl -65488 */
		/* 822557E0h case    4:*/		regs.LR = 0x822557E4; return 0x82245810;
		/* 822557E0h case    4:*/		return 0x822557E4;
		  /* 822557E4h */ case    5:  		/* lwz R30, <#[R31 + 1452]> */
		/* 822557E4h case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x000005AC) );
		/* 822557E4h case    5:*/		return 0x822557E8;
		  /* 822557E8h */ case    6:  		/* mr R29, R3 */
		/* 822557E8h case    6:*/		regs.R29 = regs.R3;
		/* 822557E8h case    6:*/		return 0x822557EC;
		  /* 822557ECh */ case    7:  		/* li R4, 964 */
		/* 822557ECh case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 822557ECh case    7:*/		return 0x822557F0;
		  /* 822557F0h */ case    8:  		/* mr R3, R30 */
		/* 822557F0h case    8:*/		regs.R3 = regs.R30;
		/* 822557F0h case    8:*/		return 0x822557F4;
		  /* 822557F4h */ case    9:  		/* bl -234300 */
		/* 822557F4h case    9:*/		regs.LR = 0x822557F8; return 0x8221C4B8;
		/* 822557F4h case    9:*/		return 0x822557F8;
		  /* 822557F8h */ case   10:  		/* mr R11, R3 */
		/* 822557F8h case   10:*/		regs.R11 = regs.R3;
		/* 822557F8h case   10:*/		return 0x822557FC;
		  /* 822557FCh */ case   11:  		/* addic. R3, R3, 4 */
		/* 822557FCh case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 822557FCh case   11:*/		return 0x82255800;
		  /* 82255800h */ case   12:  		/* stw R30, <#[R11]> */
		/* 82255800h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82255800h case   12:*/		return 0x82255804;
		  /* 82255804h */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 82255804h case   13:*/		if ( regs.CR[0].eq ) { return 0x8225581C;  }
		/* 82255804h case   13:*/		return 0x82255808;
		  /* 82255808h */ case   14:  		/* mr R5, R31 */
		/* 82255808h case   14:*/		regs.R5 = regs.R31;
		/* 82255808h case   14:*/		return 0x8225580C;
		  /* 8225580Ch */ case   15:  		/* mr R4, R27 */
		/* 8225580Ch case   15:*/		regs.R4 = regs.R27;
		/* 8225580Ch case   15:*/		return 0x82255810;
		  /* 82255810h */ case   16:  		/* bl 7256 */
		/* 82255810h case   16:*/		regs.LR = 0x82255814; return 0x82257468;
		/* 82255810h case   16:*/		return 0x82255814;
		  /* 82255814h */ case   17:  		/* mr R30, R3 */
		/* 82255814h case   17:*/		regs.R30 = regs.R3;
		/* 82255814h case   17:*/		return 0x82255818;
		  /* 82255818h */ case   18:  		/* b 8 */
		/* 82255818h case   18:*/		return 0x82255820;
		/* 82255818h case   18:*/		return 0x8225581C;
	}
	return 0x8225581C;
} // Block from 822557D0h-8225581Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8225581Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225581C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225581C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225581C);
		  /* 8225581Ch */ case    0:  		/* li R30, 0 */
		/* 8225581Ch case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8225581Ch case    0:*/		return 0x82255820;
	}
	return 0x82255820;
} // Block from 8225581Ch-82255820h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82255820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255820);
		  /* 82255820h */ case    0:  		/* mr R4, R30 */
		/* 82255820h case    0:*/		regs.R4 = regs.R30;
		/* 82255820h case    0:*/		return 0x82255824;
		  /* 82255824h */ case    1:  		/* lwz R3, <#[R25 + 164]> */
		/* 82255824h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R25 + 0x000000A4) );
		/* 82255824h case    1:*/		return 0x82255828;
		  /* 82255828h */ case    2:  		/* bl 14160 */
		/* 82255828h case    2:*/		regs.LR = 0x8225582C; return 0x82258F78;
		/* 82255828h case    2:*/		return 0x8225582C;
		  /* 8225582Ch */ case    3:  		/* mr R5, R29 */
		/* 8225582Ch case    3:*/		regs.R5 = regs.R29;
		/* 8225582Ch case    3:*/		return 0x82255830;
		  /* 82255830h */ case    4:  		/* li R4, 0 */
		/* 82255830h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82255830h case    4:*/		return 0x82255834;
		  /* 82255834h */ case    5:  		/* mr R3, R30 */
		/* 82255834h case    5:*/		regs.R3 = regs.R30;
		/* 82255834h case    5:*/		return 0x82255838;
		  /* 82255838h */ case    6:  		/* bl 2912 */
		/* 82255838h case    6:*/		regs.LR = 0x8225583C; return 0x82256398;
		/* 82255838h case    6:*/		return 0x8225583C;
		  /* 8225583Ch */ case    7:  		/* mr R4, R30 */
		/* 8225583Ch case    7:*/		regs.R4 = regs.R30;
		/* 8225583Ch case    7:*/		return 0x82255840;
		  /* 82255840h */ case    8:  		/* mr R3, R29 */
		/* 82255840h case    8:*/		regs.R3 = regs.R29;
		/* 82255840h case    8:*/		return 0x82255844;
		  /* 82255844h */ case    9:  		/* bl -5084 */
		/* 82255844h case    9:*/		regs.LR = 0x82255848; return 0x82254468;
		/* 82255844h case    9:*/		return 0x82255848;
		  /* 82255848h */ case   10:  		/* stwx R30, <#[R26 + R25]> */
		/* 82255848h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R26 + regs.R25 + 0x00000000) );
		/* 82255848h case   10:*/		return 0x8225584C;
		  /* 8225584Ch */ case   11:  		/* b 8 */
		/* 8225584Ch case   11:*/		return 0x82255854;
		/* 8225584Ch case   11:*/		return 0x82255850;
	}
	return 0x82255850;
} // Block from 82255820h-82255850h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82255850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255850);
		  /* 82255850h */ case    0:  		/* lwz R29, <#[R11 + 28]> */
		/* 82255850h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x0000001C) );
		/* 82255850h case    0:*/		return 0x82255854;
	}
	return 0x82255854;
} // Block from 82255850h-82255854h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82255854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255854);
		  /* 82255854h */ case    0:  		/* mr R4, R31 */
		/* 82255854h case    0:*/		regs.R4 = regs.R31;
		/* 82255854h case    0:*/		return 0x82255858;
		  /* 82255858h */ case    1:  		/* li R3, 49 */
		/* 82255858h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 82255858h case    1:*/		return 0x8225585C;
		  /* 8225585Ch */ case    2:  		/* bl 9484 */
		/* 8225585Ch case    2:*/		regs.LR = 0x82255860; return 0x82257D68;
		/* 8225585Ch case    2:*/		return 0x82255860;
		  /* 82255860h */ case    3:  		/* mr R5, R29 */
		/* 82255860h case    3:*/		regs.R5 = regs.R29;
		/* 82255860h case    3:*/		return 0x82255864;
		  /* 82255864h */ case    4:  		/* li R4, 1 */
		/* 82255864h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82255864h case    4:*/		return 0x82255868;
		  /* 82255868h */ case    5:  		/* mr R31, R3 */
		/* 82255868h case    5:*/		regs.R31 = regs.R3;
		/* 82255868h case    5:*/		return 0x8225586C;
		  /* 8225586Ch */ case    6:  		/* bl 2860 */
		/* 8225586Ch case    6:*/		regs.LR = 0x82255870; return 0x82256398;
		/* 8225586Ch case    6:*/		return 0x82255870;
		  /* 82255870h */ case    7:  		/* cmpwi CR6, R28, 12 */
		/* 82255870h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x0000000C);
		/* 82255870h case    7:*/		return 0x82255874;
		  /* 82255874h */ case    8:  		/* bc 12, CR6_EQ, 64 */
		/* 82255874h case    8:*/		if ( regs.CR[6].eq ) { return 0x822558B4;  }
		/* 82255874h case    8:*/		return 0x82255878;
		  /* 82255878h */ case    9:  		/* cmpwi CR6, R28, 13 */
		/* 82255878h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x0000000D);
		/* 82255878h case    9:*/		return 0x8225587C;
		  /* 8225587Ch */ case   10:  		/* bc 12, CR6_EQ, 48 */
		/* 8225587Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x822558AC;  }
		/* 8225587Ch case   10:*/		return 0x82255880;
		  /* 82255880h */ case   11:  		/* cmpwi CR6, R28, 14 */
		/* 82255880h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x0000000E);
		/* 82255880h case   11:*/		return 0x82255884;
		  /* 82255884h */ case   12:  		/* bc 12, CR6_EQ, 32 */
		/* 82255884h case   12:*/		if ( regs.CR[6].eq ) { return 0x822558A4;  }
		/* 82255884h case   12:*/		return 0x82255888;
		  /* 82255888h */ case   13:  		/* mr R6, R21 */
		/* 82255888h case   13:*/		regs.R6 = regs.R21;
		/* 82255888h case   13:*/		return 0x8225588C;
		  /* 8225588Ch */ case   14:  		/* mr R5, R22 */
		/* 8225588Ch case   14:*/		regs.R5 = regs.R22;
		/* 8225588Ch case   14:*/		return 0x82255890;
		  /* 82255890h */ case   15:  		/* mr R4, R23 */
		/* 82255890h case   15:*/		regs.R4 = regs.R23;
		/* 82255890h case   15:*/		return 0x82255894;
		  /* 82255894h */ case   16:  		/* li R7, 788 */
		/* 82255894h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x314);
		/* 82255894h case   16:*/		return 0x82255898;
		  /* 82255898h */ case   17:  		/* li R3, 0 */
		/* 82255898h case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82255898h case   17:*/		return 0x8225589C;
		  /* 8225589Ch */ case   18:  		/* bl -1039508 */
		/* 8225589Ch case   18:*/		regs.LR = 0x822558A0; return 0x82157C08;
		/* 8225589Ch case   18:*/		return 0x822558A0;
		  /* 822558A0h */ case   19:  		/* b 40 */
		/* 822558A0h case   19:*/		return 0x822558C8;
		/* 822558A0h case   19:*/		return 0x822558A4;
	}
	return 0x822558A4;
} // Block from 82255854h-822558A4h (20 instructions)

//////////////////////////////////////////////////////
// Block at 822558A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822558A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822558A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822558A4);
		  /* 822558A4h */ case    0:  		/* addi R10, R24, 12 */
		/* 822558A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R24,0xC);
		/* 822558A4h case    0:*/		return 0x822558A8;
		  /* 822558A8h */ case    1:  		/* b 16 */
		/* 822558A8h case    1:*/		return 0x822558B8;
		/* 822558A8h case    1:*/		return 0x822558AC;
	}
	return 0x822558AC;
} // Block from 822558A4h-822558ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822558ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822558AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822558AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822558AC);
		  /* 822558ACh */ case    0:  		/* addi R10, R24, 28 */
		/* 822558ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R24,0x1C);
		/* 822558ACh case    0:*/		return 0x822558B0;
		  /* 822558B0h */ case    1:  		/* b 8 */
		/* 822558B0h case    1:*/		return 0x822558B8;
		/* 822558B0h case    1:*/		return 0x822558B4;
	}
	return 0x822558B4;
} // Block from 822558ACh-822558B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822558B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822558B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822558B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822558B4);
		  /* 822558B4h */ case    0:  		/* addi R10, R24, 20 */
		/* 822558B4h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R24,0x14);
		/* 822558B4h case    0:*/		return 0x822558B8;
	}
	return 0x822558B8;
} // Block from 822558B4h-822558B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822558B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822558B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822558B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822558B8);
		  /* 822558B8h */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 822558B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 822558B8h case    0:*/		return 0x822558BC;
		  /* 822558BCh */ case    1:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 822558BCh case    1:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 822558BCh case    1:*/		return 0x822558C0;
		  /* 822558C0h */ case    2:  		/* lwzx R11, <#[R11 + R10]> */
		/* 822558C0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 822558C0h case    2:*/		return 0x822558C4;
		  /* 822558C4h */ case    3:  		/* stw R11, <#[R31 + 132]> */
		/* 822558C4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 822558C4h case    3:*/		return 0x822558C8;
	}
	return 0x822558C8;
} // Block from 822558B8h-822558C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822558C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822558C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822558C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822558C8);
		  /* 822558C8h */ case    0:  		/* mr R5, R27 */
		/* 822558C8h case    0:*/		regs.R5 = regs.R27;
		/* 822558C8h case    0:*/		return 0x822558CC;
		  /* 822558CCh */ case    1:  		/* li R4, 0 */
		/* 822558CCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822558CCh case    1:*/		return 0x822558D0;
		  /* 822558D0h */ case    2:  		/* mr R3, R31 */
		/* 822558D0h case    2:*/		regs.R3 = regs.R31;
		/* 822558D0h case    2:*/		return 0x822558D4;
		  /* 822558D4h */ case    3:  		/* bl 2756 */
		/* 822558D4h case    3:*/		regs.LR = 0x822558D8; return 0x82256398;
		/* 822558D4h case    3:*/		return 0x822558D8;
		  /* 822558D8h */ case    4:  		/* mr R4, R31 */
		/* 822558D8h case    4:*/		regs.R4 = regs.R31;
		/* 822558D8h case    4:*/		return 0x822558DC;
		  /* 822558DCh */ case    5:  		/* mr R3, R27 */
		/* 822558DCh case    5:*/		regs.R3 = regs.R27;
		/* 822558DCh case    5:*/		return 0x822558E0;
		  /* 822558E0h */ case    6:  		/* bl -5240 */
		/* 822558E0h case    6:*/		regs.LR = 0x822558E4; return 0x82254468;
		/* 822558E0h case    6:*/		return 0x822558E4;
		  /* 822558E4h */ case    7:  		/* mr R4, R31 */
		/* 822558E4h case    7:*/		regs.R4 = regs.R31;
		/* 822558E4h case    7:*/		return 0x822558E8;
		  /* 822558E8h */ case    8:  		/* lwz R3, <#[R25 + 164]> */
		/* 822558E8h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R25 + 0x000000A4) );
		/* 822558E8h case    8:*/		return 0x822558EC;
		  /* 822558ECh */ case    9:  		/* bl 13892 */
		/* 822558ECh case    9:*/		regs.LR = 0x822558F0; return 0x82258F30;
		/* 822558ECh case    9:*/		return 0x822558F0;
		  /* 822558F0h */ case   10:  		/* mr R3, R27 */
		/* 822558F0h case   10:*/		regs.R3 = regs.R27;
		/* 822558F0h case   10:*/		return 0x822558F4;
		  /* 822558F4h */ case   11:  		/* addi R1, R1, 192 */
		/* 822558F4h case   11:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 822558F4h case   11:*/		return 0x822558F8;
		  /* 822558F8h */ case   12:  		/* b -1853036 */
		/* 822558F8h case   12:*/		return 0x8209128C;
		/* 822558F8h case   12:*/		return 0x822558FC;
		  /* 822558FCh */ case   13:  		/* nop */
		/* 822558FCh case   13:*/		cpu::op::nop();
		/* 822558FCh case   13:*/		return 0x82255900;
	}
	return 0x82255900;
} // Block from 822558C8h-82255900h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82255900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255900);
		  /* 82255900h */ case    0:  		/* mfspr R12, LR */
		/* 82255900h case    0:*/		regs.R12 = regs.LR;
		/* 82255900h case    0:*/		return 0x82255904;
		  /* 82255904h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82255904h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255904h case    1:*/		return 0x82255908;
		  /* 82255908h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82255908h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82255908h case    2:*/		return 0x8225590C;
		  /* 8225590Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8225590Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8225590Ch case    3:*/		return 0x82255910;
	}
	return 0x82255910;
} // Block from 82255900h-82255910h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82255910h
// Function '??0TempValue@XGRAPHICS@@QAA@HW4RegType@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255910( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255910) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255910);
		  /* 82255910h */ case    0:  		/* mr R31, R3 */
		/* 82255910h case    0:*/		regs.R31 = regs.R3;
		/* 82255910h case    0:*/		return 0x82255914;
		  /* 82255914h */ case    1:  		/* bl -2836 */
		/* 82255914h case    1:*/		regs.LR = 0x82255918; return 0x82254E00;
		/* 82255914h case    1:*/		return 0x82255918;
		  /* 82255918h */ case    2:  		/* lis R11, -32252 */
		/* 82255918h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82255918h case    2:*/		return 0x8225591C;
		  /* 8225591Ch */ case    3:  		/* mr R3, R31 */
		/* 8225591Ch case    3:*/		regs.R3 = regs.R31;
		/* 8225591Ch case    3:*/		return 0x82255920;
		  /* 82255920h */ case    4:  		/* addi R11, R11, 27388 */
		/* 82255920h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6AFC);
		/* 82255920h case    4:*/		return 0x82255924;
		  /* 82255924h */ case    5:  		/* stw R11, <#[R31]> */
		/* 82255924h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82255924h case    5:*/		return 0x82255928;
		  /* 82255928h */ case    6:  		/* addi R1, R1, 96 */
		/* 82255928h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82255928h case    6:*/		return 0x8225592C;
		  /* 8225592Ch */ case    7:  		/* lwz R12, <#[R1 - 8]> */
		/* 8225592Ch case    7:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225592Ch case    7:*/		return 0x82255930;
		  /* 82255930h */ case    8:  		/* mtspr LR, R12 */
		/* 82255930h case    8:*/		regs.LR = regs.R12;
		/* 82255930h case    8:*/		return 0x82255934;
		  /* 82255934h */ case    9:  		/* ld R31, <#[R1 - 16]> */
		/* 82255934h case    9:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82255934h case    9:*/		return 0x82255938;
		  /* 82255938h */ case   10:  		/* bclr 20, CR0_LT */
		/* 82255938h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82255938h case   10:*/		return 0x8225593C;
	}
	return 0x8225593C;
} // Block from 82255910h-8225593Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8225593Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225593C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225593C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225593C);
		  /* 8225593Ch */ case    0:  		/* nop */
		/* 8225593Ch case    0:*/		cpu::op::nop();
		/* 8225593Ch case    0:*/		return 0x82255940;
	}
	return 0x82255940;
} // Block from 8225593Ch-82255940h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82255940h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255940);
		  /* 82255940h */ case    0:  		/* mfspr R12, LR */
		/* 82255940h case    0:*/		regs.R12 = regs.LR;
		/* 82255940h case    0:*/		return 0x82255944;
		  /* 82255944h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82255944h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255944h case    1:*/		return 0x82255948;
		  /* 82255948h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82255948h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82255948h case    2:*/		return 0x8225594C;
		  /* 8225594Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8225594Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225594Ch case    3:*/		return 0x82255950;
		  /* 82255950h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82255950h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82255950h case    4:*/		return 0x82255954;
		  /* 82255954h */ case    5:  		/* mr R31, R3 */
		/* 82255954h case    5:*/		regs.R31 = regs.R3;
		/* 82255954h case    5:*/		return 0x82255958;
		  /* 82255958h */ case    6:  		/* mr R30, R4 */
		/* 82255958h case    6:*/		regs.R30 = regs.R4;
		/* 82255958h case    6:*/		return 0x8225595C;
		  /* 8225595Ch */ case    7:  		/* bl -5628 */
		/* 8225595Ch case    7:*/		regs.LR = 0x82255960; return 0x82254360;
		/* 8225595Ch case    7:*/		return 0x82255960;
		  /* 82255960h */ case    8:  		/* lis R11, -32252 */
		/* 82255960h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82255960h case    8:*/		return 0x82255964;
		  /* 82255964h */ case    9:  		/* stw R30, <#[R31 + 16]> */
		/* 82255964h case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000010) );
		/* 82255964h case    9:*/		return 0x82255968;
		  /* 82255968h */ case   10:  		/* mr R3, R31 */
		/* 82255968h case   10:*/		regs.R3 = regs.R31;
		/* 82255968h case   10:*/		return 0x8225596C;
		  /* 8225596Ch */ case   11:  		/* addi R11, R11, 27280 */
		/* 8225596Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6A90);
		/* 8225596Ch case   11:*/		return 0x82255970;
	}
	return 0x82255970;
} // Block from 82255940h-82255970h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82255970h
// Function '??0ExportValue@XGRAPHICS@@IAA@HW4RegType@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255970);
		  /* 82255970h */ case    0:  		/* stw R11, <#[R31]> */
		/* 82255970h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82255970h case    0:*/		return 0x82255974;
		  /* 82255974h */ case    1:  		/* addi R1, R1, 112 */
		/* 82255974h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82255974h case    1:*/		return 0x82255978;
		  /* 82255978h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82255978h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255978h case    2:*/		return 0x8225597C;
		  /* 8225597Ch */ case    3:  		/* mtspr LR, R12 */
		/* 8225597Ch case    3:*/		regs.LR = regs.R12;
		/* 8225597Ch case    3:*/		return 0x82255980;
		  /* 82255980h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 82255980h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82255980h case    4:*/		return 0x82255984;
		  /* 82255984h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 82255984h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82255984h case    5:*/		return 0x82255988;
		  /* 82255988h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82255988h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82255988h case    6:*/		return 0x8225598C;
	}
	return 0x8225598C;
} // Block from 82255970h-8225598Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225598Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225598C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225598C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225598C);
		  /* 8225598Ch */ case    0:  		/* nop */
		/* 8225598Ch case    0:*/		cpu::op::nop();
		/* 8225598Ch case    0:*/		return 0x82255990;
	}
	return 0x82255990;
} // Block from 8225598Ch-82255990h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82255990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255990);
		  /* 82255990h */ case    0:  		/* mfspr R12, LR */
		/* 82255990h case    0:*/		regs.R12 = regs.LR;
		/* 82255990h case    0:*/		return 0x82255994;
		  /* 82255994h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82255994h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255994h case    1:*/		return 0x82255998;
		  /* 82255998h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82255998h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82255998h case    2:*/		return 0x8225599C;
		  /* 8225599Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8225599Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225599Ch case    3:*/		return 0x822559A0;
		  /* 822559A0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 822559A0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822559A0h case    4:*/		return 0x822559A4;
		  /* 822559A4h */ case    5:  		/* mr R31, R3 */
		/* 822559A4h case    5:*/		regs.R31 = regs.R3;
		/* 822559A4h case    5:*/		return 0x822559A8;
		  /* 822559A8h */ case    6:  		/* mr R30, R4 */
		/* 822559A8h case    6:*/		regs.R30 = regs.R4;
		/* 822559A8h case    6:*/		return 0x822559AC;
		  /* 822559ACh */ case    7:  		/* bl -5708 */
		/* 822559ACh case    7:*/		regs.LR = 0x822559B0; return 0x82254360;
		/* 822559ACh case    7:*/		return 0x822559B0;
		  /* 822559B0h */ case    8:  		/* lis R11, -32252 */
		/* 822559B0h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822559B0h case    8:*/		return 0x822559B4;
		  /* 822559B4h */ case    9:  		/* cmpwi CR6, R30, 0 */
		/* 822559B4h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 822559B4h case    9:*/		return 0x822559B8;
	}
	return 0x822559B8;
} // Block from 82255990h-822559B8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822559B8h
// Function '??0Interpolator@XGRAPHICS@@QAA@HW4RegType@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822559B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822559B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822559B8);
		  /* 822559B8h */ case    0:  		/* addi R11, R11, 27280 */
		/* 822559B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6A90);
		/* 822559B8h case    0:*/		return 0x822559BC;
		  /* 822559BCh */ case    1:  		/* stw R11, <#[R31]> */
		/* 822559BCh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822559BCh case    1:*/		return 0x822559C0;
		  /* 822559C0h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 822559C0h case    2:*/		if ( regs.CR[6].eq ) { return 0x822559E8;  }
		/* 822559C0h case    2:*/		return 0x822559C4;
		  /* 822559C4h */ case    3:  		/* lis R11, -32252 */
		/* 822559C4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822559C4h case    3:*/		return 0x822559C8;
		  /* 822559C8h */ case    4:  		/* lis R10, -32252 */
		/* 822559C8h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 822559C8h case    4:*/		return 0x822559CC;
		  /* 822559CCh */ case    5:  		/* lis R9, -32253 */
		/* 822559CCh case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 822559CCh case    5:*/		return 0x822559D0;
		  /* 822559D0h */ case    6:  		/* addi R6, R11, 26984 */
		/* 822559D0h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x6968);
		/* 822559D0h case    6:*/		return 0x822559D4;
		  /* 822559D4h */ case    7:  		/* addi R5, R10, 27424 */
		/* 822559D4h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x6B20);
		/* 822559D4h case    7:*/		return 0x822559D8;
		  /* 822559D8h */ case    8:  		/* addi R4, R9, 27460 */
		/* 822559D8h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 822559D8h case    8:*/		return 0x822559DC;
		  /* 822559DCh */ case    9:  		/* li R7, 851 */
		/* 822559DCh case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x353);
		/* 822559DCh case    9:*/		return 0x822559E0;
		  /* 822559E0h */ case   10:  		/* li R3, 0 */
		/* 822559E0h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822559E0h case   10:*/		return 0x822559E4;
		  /* 822559E4h */ case   11:  		/* bl -1039836 */
		/* 822559E4h case   11:*/		regs.LR = 0x822559E8; return 0x82157C08;
		/* 822559E4h case   11:*/		return 0x822559E8;
	}
	return 0x822559E8;
} // Block from 822559B8h-822559E8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822559E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822559E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822559E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822559E8);
		  /* 822559E8h */ case    0:  		/* li R11, 1 */
		/* 822559E8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822559E8h case    0:*/		return 0x822559EC;
		  /* 822559ECh */ case    1:  		/* li R10, 32 */
		/* 822559ECh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x20);
		/* 822559ECh case    1:*/		return 0x822559F0;
		  /* 822559F0h */ case    2:  		/* stb R11, <#[R31 + 5]> */
		/* 822559F0h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000005) );
		/* 822559F0h case    2:*/		return 0x822559F4;
		  /* 822559F4h */ case    3:  		/* mr R3, R31 */
		/* 822559F4h case    3:*/		regs.R3 = regs.R31;
		/* 822559F4h case    3:*/		return 0x822559F8;
		  /* 822559F8h */ case    4:  		/* stw R10, <#[R31 + 16]> */
		/* 822559F8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 822559F8h case    4:*/		return 0x822559FC;
		  /* 822559FCh */ case    5:  		/* addi R1, R1, 112 */
		/* 822559FCh case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822559FCh case    5:*/		return 0x82255A00;
		  /* 82255A00h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 82255A00h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255A00h case    6:*/		return 0x82255A04;
		  /* 82255A04h */ case    7:  		/* mtspr LR, R12 */
		/* 82255A04h case    7:*/		regs.LR = regs.R12;
		/* 82255A04h case    7:*/		return 0x82255A08;
		  /* 82255A08h */ case    8:  		/* ld R30, <#[R1 - 24]> */
		/* 82255A08h case    8:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82255A08h case    8:*/		return 0x82255A0C;
		  /* 82255A0Ch */ case    9:  		/* ld R31, <#[R1 - 16]> */
		/* 82255A0Ch case    9:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82255A0Ch case    9:*/		return 0x82255A10;
		  /* 82255A10h */ case   10:  		/* bclr 20, CR0_LT */
		/* 82255A10h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82255A10h case   10:*/		return 0x82255A14;
	}
	return 0x82255A14;
} // Block from 822559E8h-82255A14h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82255A14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255A14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255A14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255A14);
		  /* 82255A14h */ case    0:  		/* nop */
		/* 82255A14h case    0:*/		cpu::op::nop();
		/* 82255A14h case    0:*/		return 0x82255A18;
	}
	return 0x82255A18;
} // Block from 82255A14h-82255A18h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82255A18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255A18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255A18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255A18);
		  /* 82255A18h */ case    0:  		/* mfspr R12, LR */
		/* 82255A18h case    0:*/		regs.R12 = regs.LR;
		/* 82255A18h case    0:*/		return 0x82255A1C;
		  /* 82255A1Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82255A1Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255A1Ch case    1:*/		return 0x82255A20;
		  /* 82255A20h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82255A20h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82255A20h case    2:*/		return 0x82255A24;
		  /* 82255A24h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82255A24h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82255A24h case    3:*/		return 0x82255A28;
		  /* 82255A28h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82255A28h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82255A28h case    4:*/		return 0x82255A2C;
		  /* 82255A2Ch */ case    5:  		/* mr R31, R3 */
		/* 82255A2Ch case    5:*/		regs.R31 = regs.R3;
		/* 82255A2Ch case    5:*/		return 0x82255A30;
		  /* 82255A30h */ case    6:  		/* mr R30, R4 */
		/* 82255A30h case    6:*/		regs.R30 = regs.R4;
		/* 82255A30h case    6:*/		return 0x82255A34;
		  /* 82255A34h */ case    7:  		/* bl -5844 */
		/* 82255A34h case    7:*/		regs.LR = 0x82255A38; return 0x82254360;
		/* 82255A34h case    7:*/		return 0x82255A38;
		  /* 82255A38h */ case    8:  		/* lis R11, -32252 */
		/* 82255A38h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82255A38h case    8:*/		return 0x82255A3C;
		  /* 82255A3Ch */ case    9:  		/* cmpwi CR6, R30, 0 */
		/* 82255A3Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82255A3Ch case    9:*/		return 0x82255A40;
		  /* 82255A40h */ case   10:  		/* addi R11, R11, 27280 */
		/* 82255A40h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6A90);
		/* 82255A40h case   10:*/		return 0x82255A44;
		  /* 82255A44h */ case   11:  		/* stw R11, <#[R31]> */
		/* 82255A44h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82255A44h case   11:*/		return 0x82255A48;
		  /* 82255A48h */ case   12:  		/* bc 12, CR6_LT, 12 */
		/* 82255A48h case   12:*/		if ( regs.CR[6].lt ) { return 0x82255A54;  }
		/* 82255A48h case   12:*/		return 0x82255A4C;
		  /* 82255A4Ch */ case   13:  		/* cmpwi CR6, R30, 4 */
		/* 82255A4Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 82255A4Ch case   13:*/		return 0x82255A50;
		  /* 82255A50h */ case   14:  		/* bc 4, CR6_GT, 40 */
		/* 82255A50h case   14:*/		if ( !regs.CR[6].gt ) { return 0x82255A78;  }
		/* 82255A50h case   14:*/		return 0x82255A54;
	}
	return 0x82255A54;
} // Block from 82255A18h-82255A54h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82255A54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255A54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255A54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255A54);
		  /* 82255A54h */ case    0:  		/* lis R11, -32252 */
		/* 82255A54h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82255A54h case    0:*/		return 0x82255A58;
		  /* 82255A58h */ case    1:  		/* lis R10, -32252 */
		/* 82255A58h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82255A58h case    1:*/		return 0x82255A5C;
		  /* 82255A5Ch */ case    2:  		/* lis R9, -32253 */
		/* 82255A5Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82255A5Ch case    2:*/		return 0x82255A60;
		  /* 82255A60h */ case    3:  		/* addi R6, R11, 26984 */
		/* 82255A60h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x6968);
		/* 82255A60h case    3:*/		return 0x82255A64;
		  /* 82255A64h */ case    4:  		/* addi R5, R10, 27436 */
		/* 82255A64h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x6B2C);
		/* 82255A64h case    4:*/		return 0x82255A68;
		  /* 82255A68h */ case    5:  		/* addi R4, R9, 27460 */
		/* 82255A68h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82255A68h case    5:*/		return 0x82255A6C;
		  /* 82255A6Ch */ case    6:  		/* li R7, 862 */
		/* 82255A6Ch case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x35E);
		/* 82255A6Ch case    6:*/		return 0x82255A70;
		  /* 82255A70h */ case    7:  		/* li R3, 0 */
		/* 82255A70h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82255A70h case    7:*/		return 0x82255A74;
		  /* 82255A74h */ case    8:  		/* bl -1039980 */
		/* 82255A74h case    8:*/		regs.LR = 0x82255A78; return 0x82157C08;
		/* 82255A74h case    8:*/		return 0x82255A78;
	}
	return 0x82255A78;
} // Block from 82255A54h-82255A78h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82255A78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255A78);
		  /* 82255A78h */ case    0:  		/* li R11, 1 */
		/* 82255A78h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82255A78h case    0:*/		return 0x82255A7C;
		  /* 82255A7Ch */ case    1:  		/* addi R10, R30, 33 */
		/* 82255A7Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x21);
		/* 82255A7Ch case    1:*/		return 0x82255A80;
		  /* 82255A80h */ case    2:  		/* stb R11, <#[R31 + 5]> */
		/* 82255A80h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000005) );
		/* 82255A80h case    2:*/		return 0x82255A84;
		  /* 82255A84h */ case    3:  		/* mr R3, R31 */
		/* 82255A84h case    3:*/		regs.R3 = regs.R31;
		/* 82255A84h case    3:*/		return 0x82255A88;
		  /* 82255A88h */ case    4:  		/* stw R10, <#[R31 + 16]> */
		/* 82255A88h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82255A88h case    4:*/		return 0x82255A8C;
		  /* 82255A8Ch */ case    5:  		/* addi R1, R1, 112 */
		/* 82255A8Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82255A8Ch case    5:*/		return 0x82255A90;
	}
	return 0x82255A90;
} // Block from 82255A78h-82255A90h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82255A90h
// Function '?IsLoopIndexedSet@LoopIndexedSet@XGRAPHICS@@UBA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255A90);
		  /* 82255A90h */ case    0:  		/* lwz R12, <#[R1 - 8]> */
		/* 82255A90h case    0:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255A90h case    0:*/		return 0x82255A94;
		  /* 82255A94h */ case    1:  		/* mtspr LR, R12 */
		/* 82255A94h case    1:*/		regs.LR = regs.R12;
		/* 82255A94h case    1:*/		return 0x82255A98;
	}
	return 0x82255A98;
} // Block from 82255A90h-82255A98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82255A98h
// Function '??0Interpolator@XGRAPHICS@@QAA@HW4RegType@R400Tables@@HPAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255A98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255A98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255A98);
		  /* 82255A98h */ case    0:  		/* ld R30, <#[R1 - 24]> */
		/* 82255A98h case    0:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82255A98h case    0:*/		return 0x82255A9C;
		  /* 82255A9Ch */ case    1:  		/* ld R31, <#[R1 - 16]> */
		/* 82255A9Ch case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82255A9Ch case    1:*/		return 0x82255AA0;
		  /* 82255AA0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82255AA0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82255AA0h case    2:*/		return 0x82255AA4;
	}
	return 0x82255AA4;
} // Block from 82255A98h-82255AA4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82255AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255AA4);
		  /* 82255AA4h */ case    0:  		/* nop */
		/* 82255AA4h case    0:*/		cpu::op::nop();
		/* 82255AA4h case    0:*/		return 0x82255AA8;
	}
	return 0x82255AA8;
} // Block from 82255AA4h-82255AA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82255AA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255AA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255AA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255AA8);
		  /* 82255AA8h */ case    0:  		/* mfspr R12, LR */
		/* 82255AA8h case    0:*/		regs.R12 = regs.LR;
		/* 82255AA8h case    0:*/		return 0x82255AAC;
		  /* 82255AACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82255AACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255AACh case    1:*/		return 0x82255AB0;
		  /* 82255AB0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82255AB0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82255AB0h case    2:*/		return 0x82255AB4;
		  /* 82255AB4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82255AB4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82255AB4h case    3:*/		return 0x82255AB8;
		  /* 82255AB8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82255AB8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82255AB8h case    4:*/		return 0x82255ABC;
		  /* 82255ABCh */ case    5:  		/* mr R31, R3 */
		/* 82255ABCh case    5:*/		regs.R31 = regs.R3;
		/* 82255ABCh case    5:*/		return 0x82255AC0;
		  /* 82255AC0h */ case    6:  		/* mr R30, R4 */
		/* 82255AC0h case    6:*/		regs.R30 = regs.R4;
		/* 82255AC0h case    6:*/		return 0x82255AC4;
		  /* 82255AC4h */ case    7:  		/* bl -3668 */
		/* 82255AC4h case    7:*/		regs.LR = 0x82255AC8; return 0x82254C70;
		/* 82255AC4h case    7:*/		return 0x82255AC8;
		  /* 82255AC8h */ case    8:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 82255AC8h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 82255AC8h case    8:*/		return 0x82255ACC;
		  /* 82255ACCh */ case    9:  		/* bc 12, CR0_EQ, 24 */
		/* 82255ACCh case    9:*/		if ( regs.CR[0].eq ) { return 0x82255AE4;  }
		/* 82255ACCh case    9:*/		return 0x82255AD0;
		  /* 82255AD0h */ case   10:  		/* cmplwi CR6, R31, 0 */
		/* 82255AD0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82255AD0h case   10:*/		return 0x82255AD4;
		  /* 82255AD4h */ case   11:  		/* bc 12, CR6_EQ, 16 */
		/* 82255AD4h case   11:*/		if ( regs.CR[6].eq ) { return 0x82255AE4;  }
		/* 82255AD4h case   11:*/		return 0x82255AD8;
		  /* 82255AD8h */ case   12:  		/* addi R4, R31, -4 */
		/* 82255AD8h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0xFFFFFFFC);
		/* 82255AD8h case   12:*/		return 0x82255ADC;
		  /* 82255ADCh */ case   13:  		/* lwz R3, <#[R31 - 4]> */
		/* 82255ADCh case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0xFFFFFFFC) );
		/* 82255ADCh case   13:*/		return 0x82255AE0;
		  /* 82255AE0h */ case   14:  		/* bl -234656 */
		/* 82255AE0h case   14:*/		regs.LR = 0x82255AE4; return 0x8221C640;
		/* 82255AE0h case   14:*/		return 0x82255AE4;
	}
	return 0x82255AE4;
} // Block from 82255AA8h-82255AE4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82255AE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255AE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255AE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255AE4);
		  /* 82255AE4h */ case    0:  		/* mr R3, R31 */
		/* 82255AE4h case    0:*/		regs.R3 = regs.R31;
		/* 82255AE4h case    0:*/		return 0x82255AE8;
		  /* 82255AE8h */ case    1:  		/* addi R1, R1, 112 */
		/* 82255AE8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82255AE8h case    1:*/		return 0x82255AEC;
		  /* 82255AECh */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82255AECh case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255AECh case    2:*/		return 0x82255AF0;
		  /* 82255AF0h */ case    3:  		/* mtspr LR, R12 */
		/* 82255AF0h case    3:*/		regs.LR = regs.R12;
		/* 82255AF0h case    3:*/		return 0x82255AF4;
		  /* 82255AF4h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 82255AF4h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82255AF4h case    4:*/		return 0x82255AF8;
		  /* 82255AF8h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 82255AF8h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82255AF8h case    5:*/		return 0x82255AFC;
		  /* 82255AFCh */ case    6:  		/* bclr 20, CR0_LT */
		/* 82255AFCh case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82255AFCh case    6:*/		return 0x82255B00;
	}
	return 0x82255B00;
} // Block from 82255AE4h-82255B00h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82255B00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255B00);
		  /* 82255B00h */ case    0:  		/* mfspr R12, LR */
		/* 82255B00h case    0:*/		regs.R12 = regs.LR;
		/* 82255B00h case    0:*/		return 0x82255B04;
		  /* 82255B04h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82255B04h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255B04h case    1:*/		return 0x82255B08;
		  /* 82255B08h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82255B08h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82255B08h case    2:*/		return 0x82255B0C;
		  /* 82255B0Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82255B0Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82255B0Ch case    3:*/		return 0x82255B10;
		  /* 82255B10h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82255B10h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82255B10h case    4:*/		return 0x82255B14;
		  /* 82255B14h */ case    5:  		/* mr R31, R3 */
		/* 82255B14h case    5:*/		regs.R31 = regs.R3;
		/* 82255B14h case    5:*/		return 0x82255B18;
		  /* 82255B18h */ case    6:  		/* mr R30, R6 */
		/* 82255B18h case    6:*/		regs.R30 = regs.R6;
		/* 82255B18h case    6:*/		return 0x82255B1C;
		  /* 82255B1Ch */ case    7:  		/* bl -6076 */
		/* 82255B1Ch case    7:*/		regs.LR = 0x82255B20; return 0x82254360;
		/* 82255B1Ch case    7:*/		return 0x82255B20;
		  /* 82255B20h */ case    8:  		/* lis R11, -32252 */
		/* 82255B20h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82255B20h case    8:*/		return 0x82255B24;
		  /* 82255B24h */ case    9:  		/* li R10, 0 */
		/* 82255B24h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82255B24h case    9:*/		return 0x82255B28;
		  /* 82255B28h */ case   10:  		/* addi R11, R11, 27468 */
		/* 82255B28h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6B4C);
		/* 82255B28h case   10:*/		return 0x82255B2C;
		  /* 82255B2Ch */ case   11:  		/* stw R10, <#[R31 + 48]> */
		/* 82255B2Ch case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 82255B2Ch case   11:*/		return 0x82255B30;
		  /* 82255B30h */ case   12:  		/* mr R3, R31 */
		/* 82255B30h case   12:*/		regs.R3 = regs.R31;
		/* 82255B30h case   12:*/		return 0x82255B34;
		  /* 82255B34h */ case   13:  		/* stw R11, <#[R31]> */
		/* 82255B34h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82255B34h case   13:*/		return 0x82255B38;
		  /* 82255B38h */ case   14:  		/* lwz R11, <#[R30 + 1420]> */
		/* 82255B38h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000058C) );
		/* 82255B38h case   14:*/		return 0x82255B3C;
		  /* 82255B3Ch */ case   15:  		/* stw R11, <#[R31 + 16]> */
		/* 82255B3Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82255B3Ch case   15:*/		return 0x82255B40;
		  /* 82255B40h */ case   16:  		/* lwz R11, <#[R30 + 1420]> */
		/* 82255B40h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000058C) );
		/* 82255B40h case   16:*/		return 0x82255B44;
		  /* 82255B44h */ case   17:  		/* addi R11, R11, 1 */
		/* 82255B44h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82255B44h case   17:*/		return 0x82255B48;
		  /* 82255B48h */ case   18:  		/* stw R11, <#[R30 + 1420]> */
		/* 82255B48h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000058C) );
		/* 82255B48h case   18:*/		return 0x82255B4C;
		  /* 82255B4Ch */ case   19:  		/* addi R1, R1, 112 */
		/* 82255B4Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82255B4Ch case   19:*/		return 0x82255B50;
		  /* 82255B50h */ case   20:  		/* lwz R12, <#[R1 - 8]> */
		/* 82255B50h case   20:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255B50h case   20:*/		return 0x82255B54;
		  /* 82255B54h */ case   21:  		/* mtspr LR, R12 */
		/* 82255B54h case   21:*/		regs.LR = regs.R12;
		/* 82255B54h case   21:*/		return 0x82255B58;
		  /* 82255B58h */ case   22:  		/* ld R30, <#[R1 - 24]> */
		/* 82255B58h case   22:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82255B58h case   22:*/		return 0x82255B5C;
		  /* 82255B5Ch */ case   23:  		/* ld R31, <#[R1 - 16]> */
		/* 82255B5Ch case   23:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82255B5Ch case   23:*/		return 0x82255B60;
		  /* 82255B60h */ case   24:  		/* bclr 20, CR0_LT */
		/* 82255B60h case   24:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82255B60h case   24:*/		return 0x82255B64;
	}
	return 0x82255B64;
} // Block from 82255B00h-82255B64h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82255B64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255B64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255B64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255B64);
		  /* 82255B64h */ case    0:  		/* nop */
		/* 82255B64h case    0:*/		cpu::op::nop();
		/* 82255B64h case    0:*/		return 0x82255B68;
	}
	return 0x82255B68;
} // Block from 82255B64h-82255B68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82255B68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255B68);
		  /* 82255B68h */ case    0:  		/* mfspr R12, LR */
		/* 82255B68h case    0:*/		regs.R12 = regs.LR;
		/* 82255B68h case    0:*/		return 0x82255B6C;
		  /* 82255B6Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82255B6Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255B6Ch case    1:*/		return 0x82255B70;
		  /* 82255B70h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82255B70h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82255B70h case    2:*/		return 0x82255B74;
		  /* 82255B74h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82255B74h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82255B74h case    3:*/		return 0x82255B78;
		  /* 82255B78h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82255B78h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82255B78h case    4:*/		return 0x82255B7C;
		  /* 82255B7Ch */ case    5:  		/* mr R31, R3 */
		/* 82255B7Ch case    5:*/		regs.R31 = regs.R3;
		/* 82255B7Ch case    5:*/		return 0x82255B80;
		  /* 82255B80h */ case    6:  		/* mr R30, R6 */
		/* 82255B80h case    6:*/		regs.R30 = regs.R6;
		/* 82255B80h case    6:*/		return 0x82255B84;
		  /* 82255B84h */ case    7:  		/* bl -6180 */
		/* 82255B84h case    7:*/		regs.LR = 0x82255B88; return 0x82254360;
		/* 82255B84h case    7:*/		return 0x82255B88;
		  /* 82255B88h */ case    8:  		/* lis R11, -32252 */
		/* 82255B88h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82255B88h case    8:*/		return 0x82255B8C;
		  /* 82255B8Ch */ case    9:  		/* li R10, 0 */
		/* 82255B8Ch case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82255B8Ch case    9:*/		return 0x82255B90;
		  /* 82255B90h */ case   10:  		/* addi R11, R11, 27468 */
		/* 82255B90h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6B4C);
		/* 82255B90h case   10:*/		return 0x82255B94;
		  /* 82255B94h */ case   11:  		/* stw R10, <#[R31 + 48]> */
		/* 82255B94h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 82255B94h case   11:*/		return 0x82255B98;
		  /* 82255B98h */ case   12:  		/* mr R3, R31 */
		/* 82255B98h case   12:*/		regs.R3 = regs.R31;
		/* 82255B98h case   12:*/		return 0x82255B9C;
		  /* 82255B9Ch */ case   13:  		/* stw R11, <#[R31]> */
		/* 82255B9Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82255B9Ch case   13:*/		return 0x82255BA0;
		  /* 82255BA0h */ case   14:  		/* lwz R11, <#[R30 + 1424]> */
		/* 82255BA0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000590) );
		/* 82255BA0h case   14:*/		return 0x82255BA4;
		  /* 82255BA4h */ case   15:  		/* stw R11, <#[R31 + 16]> */
		/* 82255BA4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82255BA4h case   15:*/		return 0x82255BA8;
	}
	return 0x82255BA8;
} // Block from 82255B68h-82255BA8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82255BA8h
// Function '??0Physical@XGRAPHICS@@QAA@HW4RegType@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255BA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255BA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255BA8);
		  /* 82255BA8h */ case    0:  		/* lwz R11, <#[R30 + 1424]> */
		/* 82255BA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000590) );
		/* 82255BA8h case    0:*/		return 0x82255BAC;
		  /* 82255BACh */ case    1:  		/* addi R11, R11, 1 */
		/* 82255BACh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82255BACh case    1:*/		return 0x82255BB0;
		  /* 82255BB0h */ case    2:  		/* stw R11, <#[R30 + 1424]> */
		/* 82255BB0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000590) );
		/* 82255BB0h case    2:*/		return 0x82255BB4;
		  /* 82255BB4h */ case    3:  		/* addi R1, R1, 112 */
		/* 82255BB4h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82255BB4h case    3:*/		return 0x82255BB8;
		  /* 82255BB8h */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 82255BB8h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255BB8h case    4:*/		return 0x82255BBC;
		  /* 82255BBCh */ case    5:  		/* mtspr LR, R12 */
		/* 82255BBCh case    5:*/		regs.LR = regs.R12;
		/* 82255BBCh case    5:*/		return 0x82255BC0;
		  /* 82255BC0h */ case    6:  		/* ld R30, <#[R1 - 24]> */
		/* 82255BC0h case    6:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82255BC0h case    6:*/		return 0x82255BC4;
		  /* 82255BC4h */ case    7:  		/* ld R31, <#[R1 - 16]> */
		/* 82255BC4h case    7:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82255BC4h case    7:*/		return 0x82255BC8;
		  /* 82255BC8h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82255BC8h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82255BC8h case    8:*/		return 0x82255BCC;
	}
	return 0x82255BCC;
} // Block from 82255BA8h-82255BCCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 82255BCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255BCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255BCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255BCC);
		  /* 82255BCCh */ case    0:  		/* nop */
		/* 82255BCCh case    0:*/		cpu::op::nop();
		/* 82255BCCh case    0:*/		return 0x82255BD0;
	}
	return 0x82255BD0;
} // Block from 82255BCCh-82255BD0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82255BD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255BD0);
		  /* 82255BD0h */ case    0:  		/* mfspr R12, LR */
		/* 82255BD0h case    0:*/		regs.R12 = regs.LR;
		/* 82255BD0h case    0:*/		return 0x82255BD4;
		  /* 82255BD4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82255BD4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255BD4h case    1:*/		return 0x82255BD8;
		  /* 82255BD8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82255BD8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82255BD8h case    2:*/		return 0x82255BDC;
		  /* 82255BDCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82255BDCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82255BDCh case    3:*/		return 0x82255BE0;
		  /* 82255BE0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82255BE0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82255BE0h case    4:*/		return 0x82255BE4;
		  /* 82255BE4h */ case    5:  		/* mr R31, R3 */
		/* 82255BE4h case    5:*/		regs.R31 = regs.R3;
		/* 82255BE4h case    5:*/		return 0x82255BE8;
		  /* 82255BE8h */ case    6:  		/* mr R30, R6 */
		/* 82255BE8h case    6:*/		regs.R30 = regs.R6;
		/* 82255BE8h case    6:*/		return 0x82255BEC;
		  /* 82255BECh */ case    7:  		/* bl -6284 */
		/* 82255BECh case    7:*/		regs.LR = 0x82255BF0; return 0x82254360;
		/* 82255BECh case    7:*/		return 0x82255BF0;
		  /* 82255BF0h */ case    8:  		/* lis R11, -32252 */
		/* 82255BF0h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82255BF0h case    8:*/		return 0x82255BF4;
		  /* 82255BF4h */ case    9:  		/* li R10, 0 */
		/* 82255BF4h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82255BF4h case    9:*/		return 0x82255BF8;
		  /* 82255BF8h */ case   10:  		/* addi R11, R11, 27468 */
		/* 82255BF8h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6B4C);
		/* 82255BF8h case   10:*/		return 0x82255BFC;
		  /* 82255BFCh */ case   11:  		/* stw R10, <#[R31 + 48]> */
		/* 82255BFCh case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 82255BFCh case   11:*/		return 0x82255C00;
	}
	return 0x82255C00;
} // Block from 82255BD0h-82255C00h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82255C00h
// Function '??0Resource@XGRAPHICS@@AAA@HW4RegType@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255C00);
		  /* 82255C00h */ case    0:  		/* mr R3, R31 */
		/* 82255C00h case    0:*/		regs.R3 = regs.R31;
		/* 82255C00h case    0:*/		return 0x82255C04;
		  /* 82255C04h */ case    1:  		/* stw R11, <#[R31]> */
		/* 82255C04h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82255C04h case    1:*/		return 0x82255C08;
		  /* 82255C08h */ case    2:  		/* lwz R11, <#[R30 + 1428]> */
		/* 82255C08h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000594) );
		/* 82255C08h case    2:*/		return 0x82255C0C;
		  /* 82255C0Ch */ case    3:  		/* stw R11, <#[R31 + 16]> */
		/* 82255C0Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82255C0Ch case    3:*/		return 0x82255C10;
		  /* 82255C10h */ case    4:  		/* lwz R11, <#[R30 + 1428]> */
		/* 82255C10h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000594) );
		/* 82255C10h case    4:*/		return 0x82255C14;
		  /* 82255C14h */ case    5:  		/* addi R11, R11, 1 */
		/* 82255C14h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82255C14h case    5:*/		return 0x82255C18;
		  /* 82255C18h */ case    6:  		/* stw R11, <#[R30 + 1428]> */
		/* 82255C18h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000594) );
		/* 82255C18h case    6:*/		return 0x82255C1C;
		  /* 82255C1Ch */ case    7:  		/* addi R1, R1, 112 */
		/* 82255C1Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82255C1Ch case    7:*/		return 0x82255C20;
		  /* 82255C20h */ case    8:  		/* lwz R12, <#[R1 - 8]> */
		/* 82255C20h case    8:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255C20h case    8:*/		return 0x82255C24;
		  /* 82255C24h */ case    9:  		/* mtspr LR, R12 */
		/* 82255C24h case    9:*/		regs.LR = regs.R12;
		/* 82255C24h case    9:*/		return 0x82255C28;
		  /* 82255C28h */ case   10:  		/* ld R30, <#[R1 - 24]> */
		/* 82255C28h case   10:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82255C28h case   10:*/		return 0x82255C2C;
		  /* 82255C2Ch */ case   11:  		/* ld R31, <#[R1 - 16]> */
		/* 82255C2Ch case   11:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82255C2Ch case   11:*/		return 0x82255C30;
		  /* 82255C30h */ case   12:  		/* bclr 20, CR0_LT */
		/* 82255C30h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82255C30h case   12:*/		return 0x82255C34;
	}
	return 0x82255C34;
} // Block from 82255C00h-82255C34h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82255C34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255C34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255C34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255C34);
		  /* 82255C34h */ case    0:  		/* nop */
		/* 82255C34h case    0:*/		cpu::op::nop();
		/* 82255C34h case    0:*/		return 0x82255C38;
	}
	return 0x82255C38;
} // Block from 82255C34h-82255C38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82255C38h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255C38);
		  /* 82255C38h */ case    0:  		/* li R10, 1 */
		/* 82255C38h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82255C38h case    0:*/		return 0x82255C3C;
		  /* 82255C3Ch */ case    1:  		/* addi R9, R5, -1 */
		/* 82255C3Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R5,0xFFFFFFFF);
		/* 82255C3Ch case    1:*/		return 0x82255C40;
		  /* 82255C40h */ case    2:  		/* addi R11, R4, -1 */
		/* 82255C40h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0xFFFFFFFF);
		/* 82255C40h case    2:*/		return 0x82255C44;
		  /* 82255C44h */ case    3:  		/* slw R9, R10, R9 */
		/* 82255C44h case    3:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 82255C44h case    3:*/		return 0x82255C48;
		  /* 82255C48h */ case    4:  		/* extsw R9, R9 */
		/* 82255C48h case    4:*/		cpu::op::extsw<0>(regs,&regs.R9,regs.R9);
		/* 82255C48h case    4:*/		return 0x82255C4C;
		  /* 82255C4Ch */ case    5:  		/* slw R8, R10, R11 */
		/* 82255C4Ch case    5:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R10,regs.R11);
		/* 82255C4Ch case    5:*/		return 0x82255C50;
		  /* 82255C50h */ case    6:  		/* std R9, <#[R1 - 16]> */
		/* 82255C50h case    6:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82255C50h case    6:*/		return 0x82255C54;
		  /* 82255C54h */ case    7:  		/* extsw R9, R8 */
		/* 82255C54h case    7:*/		cpu::op::extsw<0>(regs,&regs.R9,regs.R8);
		/* 82255C54h case    7:*/		return 0x82255C58;
		  /* 82255C58h */ case    8:  		/* li R8, -1 */
		/* 82255C58h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 82255C58h case    8:*/		return 0x82255C5C;
		  /* 82255C5Ch */ case    9:  		/* std R9, <#[R1 - 8]> */
		/* 82255C5Ch case    9:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255C5Ch case    9:*/		return 0x82255C60;
		  /* 82255C60h */ case   10:  		/* lis R9, -32256 */
		/* 82255C60h case   10:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 82255C60h case   10:*/		return 0x82255C64;
		  /* 82255C64h */ case   11:  		/* slw R11, R8, R11 */
		/* 82255C64h case   11:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82255C64h case   11:*/		return 0x82255C68;
		  /* 82255C68h */ case   12:  		/* extsw R11, R11 */
		/* 82255C68h case   12:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 82255C68h case   12:*/		return 0x82255C6C;
		  /* 82255C6Ch */ case   13:  		/* lfd FR0, <#[R1 - 16]> */
		/* 82255C6Ch case   13:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82255C6Ch case   13:*/		return 0x82255C70;
		  /* 82255C70h */ case   14:  		/* fcfid FR13, FR0 */
		/* 82255C70h case   14:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR0);
		/* 82255C70h case   14:*/		return 0x82255C74;
		  /* 82255C74h */ case   15:  		/* lfd FR0, <#[R1 - 8]> */
		/* 82255C74h case   15:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255C74h case   15:*/		return 0x82255C78;
		  /* 82255C78h */ case   16:  		/* std R11, <#[R1 - 8]> */
		/* 82255C78h case   16:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255C78h case   16:*/		return 0x82255C7C;
		  /* 82255C7Ch */ case   17:  		/* fcfid FR12, FR0 */
		/* 82255C7Ch case   17:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR0);
		/* 82255C7Ch case   17:*/		return 0x82255C80;
		  /* 82255C80h */ case   18:  		/* lfs FR0, <#[R9 + 1792]> */
		/* 82255C80h case   18:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000700) );
		/* 82255C80h case   18:*/		return 0x82255C84;
		  /* 82255C84h */ case   19:  		/* lfd FR11, <#[R1 - 8]> */
		/* 82255C84h case   19:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255C84h case   19:*/		return 0x82255C88;
		  /* 82255C88h */ case   20:  		/* fcfid FR11, FR11 */
		/* 82255C88h case   20:*/		cpu::op::fcfid<0>(regs,&regs.FR11,regs.FR11);
		/* 82255C88h case   20:*/		return 0x82255C8C;
		  /* 82255C8Ch */ case   21:  		/* frsp FR10, FR13 */
		/* 82255C8Ch case   21:*/		cpu::op::frsp<0>(regs,&regs.FR10,regs.FR13);
		/* 82255C8Ch case   21:*/		return 0x82255C90;
		  /* 82255C90h */ case   22:  		/* frsp FR12, FR12 */
		/* 82255C90h case   22:*/		cpu::op::frsp<0>(regs,&regs.FR12,regs.FR12);
		/* 82255C90h case   22:*/		return 0x82255C94;
		  /* 82255C94h */ case   23:  		/* frsp FR13, FR11 */
		/* 82255C94h case   23:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR11);
		/* 82255C94h case   23:*/		return 0x82255C98;
		  /* 82255C98h */ case   24:  		/* fdivs FR0, FR0, FR10 */
		/* 82255C98h case   24:*/		cpu::op::fdivs<0>(regs,&regs.FR0,regs.FR0,regs.FR10);
		/* 82255C98h case   24:*/		return 0x82255C9C;
		  /* 82255C9Ch */ case   25:  		/* fsubs FR0, FR12, FR0 */
		/* 82255C9Ch case   25:*/		cpu::op::fsubs<0>(regs,&regs.FR0,regs.FR12,regs.FR0);
		/* 82255C9Ch case   25:*/		return 0x82255CA0;
		  /* 82255CA0h */ case   26:  		/* fcmpu CR6, FR1, FR0 */
		/* 82255CA0h case   26:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82255CA0h case   26:*/		return 0x82255CA4;
		  /* 82255CA4h */ case   27:  		/* bc 4, CR6_GT, 8 */
		/* 82255CA4h case   27:*/		if ( !regs.CR[6].gt ) { return 0x82255CAC;  }
		/* 82255CA4h case   27:*/		return 0x82255CA8;
	}
	return 0x82255CA8;
} // Block from 82255C38h-82255CA8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82255CA8h
// Function '??0StandardIndex@XGRAPHICS@@QAA@HW4RegType@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255CA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255CA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255CA8);
		  /* 82255CA8h */ case    0:  		/* fmr FR1, FR0 */
		/* 82255CA8h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR0);
		/* 82255CA8h case    0:*/		return 0x82255CAC;
	}
	return 0x82255CAC;
} // Block from 82255CA8h-82255CACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82255CACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255CAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255CAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255CAC);
		  /* 82255CACh */ case    0:  		/* fcmpu CR6, FR1, FR13 */
		/* 82255CACh case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR13);
		/* 82255CACh case    0:*/		return 0x82255CB0;
		  /* 82255CB0h */ case    1:  		/* bc 4, CR6_LT, 8 */
		/* 82255CB0h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82255CB8;  }
		/* 82255CB0h case    1:*/		return 0x82255CB4;
		  /* 82255CB4h */ case    2:  		/* fmr FR1, FR13 */
		/* 82255CB4h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR13);
		/* 82255CB4h case    2:*/		return 0x82255CB8;
	}
	return 0x82255CB8;
} // Block from 82255CACh-82255CB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82255CB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255CB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255CB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255CB8);
		  /* 82255CB8h */ case    0:  		/* slw R11, R10, R5 */
		/* 82255CB8h case    0:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R10,regs.R5);
		/* 82255CB8h case    0:*/		return 0x82255CBC;
		  /* 82255CBCh */ case    1:  		/* extsw R11, R11 */
		/* 82255CBCh case    1:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 82255CBCh case    1:*/		return 0x82255CC0;
		  /* 82255CC0h */ case    2:  		/* std R11, <#[R1 - 8]> */
		/* 82255CC0h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255CC0h case    2:*/		return 0x82255CC4;
		  /* 82255CC4h */ case    3:  		/* lfd FR0, <#[R1 - 8]> */
		/* 82255CC4h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255CC4h case    3:*/		return 0x82255CC8;
		  /* 82255CC8h */ case    4:  		/* fcfid FR0, FR0 */
		/* 82255CC8h case    4:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82255CC8h case    4:*/		return 0x82255CCC;
		  /* 82255CCCh */ case    5:  		/* frsp FR0, FR0 */
		/* 82255CCCh case    5:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 82255CCCh case    5:*/		return 0x82255CD0;
		  /* 82255CD0h */ case    6:  		/* fmuls FR0, FR0, FR1 */
		/* 82255CD0h case    6:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR0,regs.FR1);
		/* 82255CD0h case    6:*/		return 0x82255CD4;
		  /* 82255CD4h */ case    7:  		/* fctiwz FR0, FR0 */
		/* 82255CD4h case    7:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 82255CD4h case    7:*/		return 0x82255CD8;
		  /* 82255CD8h */ case    8:  		/* stfd FR0, <#[R1 - 8]> */
		/* 82255CD8h case    8:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82255CD8h case    8:*/		return 0x82255CDC;
		  /* 82255CDCh */ case    9:  		/* lwz R3, <#[R1 - 4]> */
		/* 82255CDCh case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFFC) );
		/* 82255CDCh case    9:*/		return 0x82255CE0;
		  /* 82255CE0h */ case   10:  		/* bclr 20, CR0_LT */
		/* 82255CE0h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82255CE0h case   10:*/		return 0x82255CE4;
	}
	return 0x82255CE4;
} // Block from 82255CB8h-82255CE4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82255CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255CE4);
		  /* 82255CE4h */ case    0:  		/* nop */
		/* 82255CE4h case    0:*/		cpu::op::nop();
		/* 82255CE4h case    0:*/		return 0x82255CE8;
		  /* 82255CE8h */ case    1:  		/* lis R11, -32256 */
		/* 82255CE8h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82255CE8h case    1:*/		return 0x82255CEC;
		  /* 82255CECh */ case    2:  		/* lfs FR1, <#[R11 + 1816]> */
		/* 82255CECh case    2:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000718) );
		/* 82255CECh case    2:*/		return 0x82255CF0;
		  /* 82255CF0h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82255CF0h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82255CF0h case    3:*/		return 0x82255CF4;
	}
	return 0x82255CF4;
} // Block from 82255CE4h-82255CF4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82255CF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255CF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255CF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255CF4);
		  /* 82255CF4h */ case    0:  		/* nop */
		/* 82255CF4h case    0:*/		cpu::op::nop();
		/* 82255CF4h case    0:*/		return 0x82255CF8;
	}
	return 0x82255CF8;
} // Block from 82255CF4h-82255CF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82255CF8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255CF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255CF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255CF8);
		  /* 82255CF8h */ case    0:  		/* mfspr R12, LR */
		/* 82255CF8h case    0:*/		regs.R12 = regs.LR;
		/* 82255CF8h case    0:*/		return 0x82255CFC;
		  /* 82255CFCh */ case    1:  		/* bl -1854120 */
		/* 82255CFCh case    1:*/		regs.LR = 0x82255D00; return 0x82091254;
		/* 82255CFCh case    1:*/		return 0x82255D00;
		  /* 82255D00h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82255D00h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82255D00h case    2:*/		return 0x82255D04;
		  /* 82255D04h */ case    3:  		/* lbz R11, <#[R4 + 164]> */
		/* 82255D04h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R4 + 0x000000A4) );
		/* 82255D04h case    3:*/		return 0x82255D08;
		  /* 82255D08h */ case    4:  		/* mr R30, R3 */
		/* 82255D08h case    4:*/		regs.R30 = regs.R3;
		/* 82255D08h case    4:*/		return 0x82255D0C;
		  /* 82255D0Ch */ case    5:  		/* lbz R10, <#[R3 + 164]> */
		/* 82255D0Ch case    5:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R3 + 0x000000A4) );
		/* 82255D0Ch case    5:*/		return 0x82255D10;
		  /* 82255D10h */ case    6:  		/* mr R29, R4 */
		/* 82255D10h case    6:*/		regs.R29 = regs.R4;
		/* 82255D10h case    6:*/		return 0x82255D14;
		  /* 82255D14h */ case    7:  		/* cmplw CR6, R10, R11 */
		/* 82255D14h case    7:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82255D14h case    7:*/		return 0x82255D18;
		  /* 82255D18h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 82255D18h case    8:*/		if ( regs.CR[6].eq ) { return 0x82255D24;  }
		/* 82255D18h case    8:*/		return 0x82255D1C;
		  /* 82255D1Ch */ case    9:  		/* li R3, 0 */
		/* 82255D1Ch case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82255D1Ch case    9:*/		return 0x82255D20;
		  /* 82255D20h */ case   10:  		/* b 120 */
		/* 82255D20h case   10:*/		return 0x82255D98;
		/* 82255D20h case   10:*/		return 0x82255D24;
	}
	return 0x82255D24;
} // Block from 82255CF8h-82255D24h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82255D24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255D24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255D24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255D24);
		  /* 82255D24h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82255D24h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82255D24h case    0:*/		return 0x82255D28;
		  /* 82255D28h */ case    1:  		/* mr R3, R30 */
		/* 82255D28h case    1:*/		regs.R3 = regs.R30;
		/* 82255D28h case    1:*/		return 0x82255D2C;
		  /* 82255D2Ch */ case    2:  		/* li R31, 1 */
		/* 82255D2Ch case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 82255D2Ch case    2:*/		return 0x82255D30;
		  /* 82255D30h */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 82255D30h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82255D30h case    3:*/		return 0x82255D34;
		  /* 82255D34h */ case    4:  		/* mtspr CTR, R11 */
		/* 82255D34h case    4:*/		regs.CTR = regs.R11;
		/* 82255D34h case    4:*/		return 0x82255D38;
		  /* 82255D38h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 82255D38h case    5:*/		if ( 1 ) { regs.LR = 0x82255D3C; return (uint32)regs.CTR; }
		/* 82255D38h case    5:*/		return 0x82255D3C;
		  /* 82255D3Ch */ case    6:  		/* cmpwi CR6, R3, 1 */
		/* 82255D3Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82255D3Ch case    6:*/		return 0x82255D40;
		  /* 82255D40h */ case    7:  		/* bc 12, CR6_LT, 84 */
		/* 82255D40h case    7:*/		if ( regs.CR[6].lt ) { return 0x82255D94;  }
		/* 82255D40h case    7:*/		return 0x82255D44;
		  /* 82255D44h */ case    8:  		/* addi R28, R29, 152 */
		/* 82255D44h case    8:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R29,0x98);
		/* 82255D44h case    8:*/		return 0x82255D48;
		  /* 82255D48h */ case    9:  		/* addi R27, R30, 152 */
		/* 82255D48h case    9:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R30,0x98);
		/* 82255D48h case    9:*/		return 0x82255D4C;
		  /* 82255D4Ch */ case   10:  		/* lbzx R11, <#[R27 + R31]> */
		/* 82255D4Ch case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R27 + regs.R31 + 0x00000000) );
		/* 82255D4Ch case   10:*/		return 0x82255D50;
		  /* 82255D50h */ case   11:  		/* lbzx R10, <#[R28 + R31]> */
		/* 82255D50h case   11:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R28 + regs.R31 + 0x00000000) );
		/* 82255D50h case   11:*/		return 0x82255D54;
		  /* 82255D54h */ case   12:  		/* cmplw CR6, R11, R10 */
		/* 82255D54h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82255D54h case   12:*/		return 0x82255D58;
		  /* 82255D58h */ case   13:  		/* bc 4, CR6_EQ, -60 */
		/* 82255D58h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82255D1C;  }
		/* 82255D58h case   13:*/		return 0x82255D5C;
		  /* 82255D5Ch */ case   14:  		/* add R11, R31, R29 */
		/* 82255D5Ch case   14:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R29);
		/* 82255D5Ch case   14:*/		return 0x82255D60;
		  /* 82255D60h */ case   15:  		/* add R10, R31, R30 */
		/* 82255D60h case   15:*/		cpu::op::add<0>(regs,&regs.R10,regs.R31,regs.R30);
		/* 82255D60h case   15:*/		return 0x82255D64;
		  /* 82255D64h */ case   16:  		/* lbz R11, <#[R11 + 158]> */
		/* 82255D64h case   16:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000009E) );
		/* 82255D64h case   16:*/		return 0x82255D68;
		  /* 82255D68h */ case   17:  		/* lbz R10, <#[R10 + 158]> */
		/* 82255D68h case   17:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000009E) );
		/* 82255D68h case   17:*/		return 0x82255D6C;
		  /* 82255D6Ch */ case   18:  		/* cmplw CR6, R10, R11 */
		/* 82255D6Ch case   18:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82255D6Ch case   18:*/		return 0x82255D70;
		  /* 82255D70h */ case   19:  		/* bc 4, CR6_EQ, -84 */
		/* 82255D70h case   19:*/		if ( !regs.CR[6].eq ) { return 0x82255D1C;  }
		/* 82255D70h case   19:*/		return 0x82255D74;
		  /* 82255D74h */ case   20:  		/* lwz R11, <#[R30]> */
		/* 82255D74h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82255D74h case   20:*/		return 0x82255D78;
		  /* 82255D78h */ case   21:  		/* mr R3, R30 */
		/* 82255D78h case   21:*/		regs.R3 = regs.R30;
		/* 82255D78h case   21:*/		return 0x82255D7C;
		  /* 82255D7Ch */ case   22:  		/* addi R31, R31, 1 */
		/* 82255D7Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82255D7Ch case   22:*/		return 0x82255D80;
		  /* 82255D80h */ case   23:  		/* lwz R11, <#[R11 + 4]> */
		/* 82255D80h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82255D80h case   23:*/		return 0x82255D84;
		  /* 82255D84h */ case   24:  		/* mtspr CTR, R11 */
		/* 82255D84h case   24:*/		regs.CTR = regs.R11;
		/* 82255D84h case   24:*/		return 0x82255D88;
		  /* 82255D88h */ case   25:  		/* bcctrl 20, CR0_LT */
		/* 82255D88h case   25:*/		if ( 1 ) { regs.LR = 0x82255D8C; return (uint32)regs.CTR; }
		/* 82255D88h case   25:*/		return 0x82255D8C;
		  /* 82255D8Ch */ case   26:  		/* cmpw CR6, R31, R3 */
		/* 82255D8Ch case   26:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R3);
		/* 82255D8Ch case   26:*/		return 0x82255D90;
		  /* 82255D90h */ case   27:  		/* bc 4, CR6_GT, -68 */
		/* 82255D90h case   27:*/		if ( !regs.CR[6].gt ) { return 0x82255D4C;  }
		/* 82255D90h case   27:*/		return 0x82255D94;
	}
	return 0x82255D94;
} // Block from 82255D24h-82255D94h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82255D94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255D94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255D94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255D94);
		  /* 82255D94h */ case    0:  		/* li R3, 1 */
		/* 82255D94h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82255D94h case    0:*/		return 0x82255D98;
	}
	return 0x82255D98;
} // Block from 82255D94h-82255D98h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82255D98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255D98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255D98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255D98);
		  /* 82255D98h */ case    0:  		/* addi R1, R1, 128 */
		/* 82255D98h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82255D98h case    0:*/		return 0x82255D9C;
		  /* 82255D9Ch */ case    1:  		/* b -1854200 */
		/* 82255D9Ch case    1:*/		return 0x820912A4;
		/* 82255D9Ch case    1:*/		return 0x82255DA0;
	}
	return 0x82255DA0;
} // Block from 82255D98h-82255DA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82255DA0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255DA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255DA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255DA0);
		  /* 82255DA0h */ case    0:  		/* mfspr R12, LR */
		/* 82255DA0h case    0:*/		regs.R12 = regs.LR;
		/* 82255DA0h case    0:*/		return 0x82255DA4;
		  /* 82255DA4h */ case    1:  		/* bl -1854280 */
		/* 82255DA4h case    1:*/		regs.LR = 0x82255DA8; return 0x8209125C;
		/* 82255DA4h case    1:*/		return 0x82255DA8;
		  /* 82255DA8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82255DA8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82255DA8h case    2:*/		return 0x82255DAC;
		  /* 82255DACh */ case    3:  		/* mr R30, R3 */
		/* 82255DACh case    3:*/		regs.R30 = regs.R3;
		/* 82255DACh case    3:*/		return 0x82255DB0;
		  /* 82255DB0h */ case    4:  		/* mr R29, R4 */
		/* 82255DB0h case    4:*/		regs.R29 = regs.R4;
		/* 82255DB0h case    4:*/		return 0x82255DB4;
		  /* 82255DB4h */ case    5:  		/* li R31, 0 */
		/* 82255DB4h case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82255DB4h case    5:*/		return 0x82255DB8;
		  /* 82255DB8h */ case    6:  		/* lwz R11, <#[R30]> */
		/* 82255DB8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82255DB8h case    6:*/		return 0x82255DBC;
		  /* 82255DBCh */ case    7:  		/* mr R5, R31 */
		/* 82255DBCh case    7:*/		regs.R5 = regs.R31;
		/* 82255DBCh case    7:*/		return 0x82255DC0;
		  /* 82255DC0h */ case    8:  		/* li R4, 0 */
		/* 82255DC0h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82255DC0h case    8:*/		return 0x82255DC4;
		  /* 82255DC4h */ case    9:  		/* mr R3, R30 */
		/* 82255DC4h case    9:*/		regs.R3 = regs.R30;
		/* 82255DC4h case    9:*/		return 0x82255DC8;
		  /* 82255DC8h */ case   10:  		/* lwz R11, <#[R11 + 80]> */
		/* 82255DC8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82255DC8h case   10:*/		return 0x82255DCC;
		  /* 82255DCCh */ case   11:  		/* mtspr CTR, R11 */
		/* 82255DCCh case   11:*/		regs.CTR = regs.R11;
		/* 82255DCCh case   11:*/		return 0x82255DD0;
		  /* 82255DD0h */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 82255DD0h case   12:*/		if ( 1 ) { regs.LR = 0x82255DD4; return (uint32)regs.CTR; }
		/* 82255DD0h case   12:*/		return 0x82255DD4;
		  /* 82255DD4h */ case   13:  		/* cmpwi CR6, R3, 1 */
		/* 82255DD4h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82255DD4h case   13:*/		return 0x82255DD8;
		  /* 82255DD8h */ case   14:  		/* bc 12, CR6_EQ, 40 */
		/* 82255DD8h case   14:*/		if ( regs.CR[6].eq ) { return 0x82255E00;  }
		/* 82255DD8h case   14:*/		return 0x82255DDC;
		  /* 82255DDCh */ case   15:  		/* lwz R11, <#[R29]> */
		/* 82255DDCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82255DDCh case   15:*/		return 0x82255DE0;
		  /* 82255DE0h */ case   16:  		/* mr R5, R31 */
		/* 82255DE0h case   16:*/		regs.R5 = regs.R31;
		/* 82255DE0h case   16:*/		return 0x82255DE4;
		  /* 82255DE4h */ case   17:  		/* li R4, 0 */
		/* 82255DE4h case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82255DE4h case   17:*/		return 0x82255DE8;
		  /* 82255DE8h */ case   18:  		/* mr R3, R29 */
		/* 82255DE8h case   18:*/		regs.R3 = regs.R29;
		/* 82255DE8h case   18:*/		return 0x82255DEC;
		  /* 82255DECh */ case   19:  		/* lwz R11, <#[R11 + 80]> */
		/* 82255DECh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82255DECh case   19:*/		return 0x82255DF0;
		  /* 82255DF0h */ case   20:  		/* mtspr CTR, R11 */
		/* 82255DF0h case   20:*/		regs.CTR = regs.R11;
		/* 82255DF0h case   20:*/		return 0x82255DF4;
		  /* 82255DF4h */ case   21:  		/* bcctrl 20, CR0_LT */
		/* 82255DF4h case   21:*/		if ( 1 ) { regs.LR = 0x82255DF8; return (uint32)regs.CTR; }
		/* 82255DF4h case   21:*/		return 0x82255DF8;
		  /* 82255DF8h */ case   22:  		/* cmpwi CR6, R3, 1 */
		/* 82255DF8h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82255DF8h case   22:*/		return 0x82255DFC;
		  /* 82255DFCh */ case   23:  		/* bc 4, CR6_EQ, 28 */
		/* 82255DFCh case   23:*/		if ( !regs.CR[6].eq ) { return 0x82255E18;  }
		/* 82255DFCh case   23:*/		return 0x82255E00;
	}
	return 0x82255E00;
} // Block from 82255DA0h-82255E00h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82255E00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255E00);
		  /* 82255E00h */ case    0:  		/* addi R31, R31, 1 */
		/* 82255E00h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82255E00h case    0:*/		return 0x82255E04;
		  /* 82255E04h */ case    1:  		/* cmpwi CR6, R31, 4 */
		/* 82255E04h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000004);
		/* 82255E04h case    1:*/		return 0x82255E08;
		  /* 82255E08h */ case    2:  		/* bc 12, CR6_LT, -80 */
		/* 82255E08h case    2:*/		if ( regs.CR[6].lt ) { return 0x82255DB8;  }
		/* 82255E08h case    2:*/		return 0x82255E0C;
		  /* 82255E0Ch */ case    3:  		/* li R3, 1 */
		/* 82255E0Ch case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82255E0Ch case    3:*/		return 0x82255E10;
		  /* 82255E10h */ case    4:  		/* addi R1, R1, 112 */
		/* 82255E10h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82255E10h case    4:*/		return 0x82255E14;
		  /* 82255E14h */ case    5:  		/* b -1854312 */
		/* 82255E14h case    5:*/		return 0x820912AC;
		/* 82255E14h case    5:*/		return 0x82255E18;
	}
	return 0x82255E18;
} // Block from 82255E00h-82255E18h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82255E18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255E18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255E18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255E18);
		  /* 82255E18h */ case    0:  		/* li R3, 0 */
		/* 82255E18h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82255E18h case    0:*/		return 0x82255E1C;
		  /* 82255E1Ch */ case    1:  		/* b -12 */
		/* 82255E1Ch case    1:*/		return 0x82255E10;
		/* 82255E1Ch case    1:*/		return 0x82255E20;
	}
	return 0x82255E20;
} // Block from 82255E18h-82255E20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82255E20h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255E20);
		  /* 82255E20h */ case    0:  		/* mfspr R12, LR */
		/* 82255E20h case    0:*/		regs.R12 = regs.LR;
		/* 82255E20h case    0:*/		return 0x82255E24;
		  /* 82255E24h */ case    1:  		/* bl -1854408 */
		/* 82255E24h case    1:*/		regs.LR = 0x82255E28; return 0x8209125C;
		/* 82255E24h case    1:*/		return 0x82255E28;
		  /* 82255E28h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82255E28h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82255E28h case    2:*/		return 0x82255E2C;
		  /* 82255E2Ch */ case    3:  		/* mr R30, R3 */
		/* 82255E2Ch case    3:*/		regs.R30 = regs.R3;
		/* 82255E2Ch case    3:*/		return 0x82255E30;
		  /* 82255E30h */ case    4:  		/* li R29, 0 */
		/* 82255E30h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82255E30h case    4:*/		return 0x82255E34;
		  /* 82255E34h */ case    5:  		/* li R31, 0 */
		/* 82255E34h case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82255E34h case    5:*/		return 0x82255E38;
		  /* 82255E38h */ case    6:  		/* lwz R11, <#[R30]> */
		/* 82255E38h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82255E38h case    6:*/		return 0x82255E3C;
		  /* 82255E3Ch */ case    7:  		/* mr R5, R31 */
		/* 82255E3Ch case    7:*/		regs.R5 = regs.R31;
		/* 82255E3Ch case    7:*/		return 0x82255E40;
		  /* 82255E40h */ case    8:  		/* li R4, 0 */
		/* 82255E40h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82255E40h case    8:*/		return 0x82255E44;
		  /* 82255E44h */ case    9:  		/* mr R3, R30 */
		/* 82255E44h case    9:*/		regs.R3 = regs.R30;
		/* 82255E44h case    9:*/		return 0x82255E48;
		  /* 82255E48h */ case   10:  		/* lwz R11, <#[R11 + 80]> */
		/* 82255E48h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82255E48h case   10:*/		return 0x82255E4C;
		  /* 82255E4Ch */ case   11:  		/* mtspr CTR, R11 */
		/* 82255E4Ch case   11:*/		regs.CTR = regs.R11;
		/* 82255E4Ch case   11:*/		return 0x82255E50;
		  /* 82255E50h */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 82255E50h case   12:*/		if ( 1 ) { regs.LR = 0x82255E54; return (uint32)regs.CTR; }
		/* 82255E50h case   12:*/		return 0x82255E54;
		  /* 82255E54h */ case   13:  		/* cmpwi CR6, R3, 1 */
		/* 82255E54h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82255E54h case   13:*/		return 0x82255E58;
		  /* 82255E58h */ case   14:  		/* bc 12, CR6_EQ, 8 */
		/* 82255E58h case   14:*/		if ( regs.CR[6].eq ) { return 0x82255E60;  }
		/* 82255E58h case   14:*/		return 0x82255E5C;
		  /* 82255E5Ch */ case   15:  		/* addi R29, R29, 1 */
		/* 82255E5Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82255E5Ch case   15:*/		return 0x82255E60;
	}
	return 0x82255E60;
} // Block from 82255E20h-82255E60h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82255E60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255E60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255E60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255E60);
		  /* 82255E60h */ case    0:  		/* addi R31, R31, 1 */
		/* 82255E60h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82255E60h case    0:*/		return 0x82255E64;
		  /* 82255E64h */ case    1:  		/* cmpwi CR6, R31, 4 */
		/* 82255E64h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000004);
		/* 82255E64h case    1:*/		return 0x82255E68;
		  /* 82255E68h */ case    2:  		/* bc 12, CR6_LT, -48 */
		/* 82255E68h case    2:*/		if ( regs.CR[6].lt ) { return 0x82255E38;  }
		/* 82255E68h case    2:*/		return 0x82255E6C;
		  /* 82255E6Ch */ case    3:  		/* mr R3, R29 */
		/* 82255E6Ch case    3:*/		regs.R3 = regs.R29;
		/* 82255E6Ch case    3:*/		return 0x82255E70;
		  /* 82255E70h */ case    4:  		/* addi R1, R1, 112 */
		/* 82255E70h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82255E70h case    4:*/		return 0x82255E74;
		  /* 82255E74h */ case    5:  		/* b -1854408 */
		/* 82255E74h case    5:*/		return 0x820912AC;
		/* 82255E74h case    5:*/		return 0x82255E78;
	}
	return 0x82255E78;
} // Block from 82255E60h-82255E78h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82255E78h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255E78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255E78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255E78);
		  /* 82255E78h */ case    0:  		/* mfspr R12, LR */
		/* 82255E78h case    0:*/		regs.R12 = regs.LR;
		/* 82255E78h case    0:*/		return 0x82255E7C;
		  /* 82255E7Ch */ case    1:  		/* bl -1854496 */
		/* 82255E7Ch case    1:*/		regs.LR = 0x82255E80; return 0x8209125C;
		/* 82255E7Ch case    1:*/		return 0x82255E80;
		  /* 82255E80h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82255E80h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82255E80h case    2:*/		return 0x82255E84;
		  /* 82255E84h */ case    3:  		/* mr R30, R3 */
		/* 82255E84h case    3:*/		regs.R30 = regs.R3;
		/* 82255E84h case    3:*/		return 0x82255E88;
		  /* 82255E88h */ case    4:  		/* mr R29, R4 */
		/* 82255E88h case    4:*/		regs.R29 = regs.R4;
		/* 82255E88h case    4:*/		return 0x82255E8C;
		  /* 82255E8Ch */ case    5:  		/* li R31, 0 */
		/* 82255E8Ch case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82255E8Ch case    5:*/		return 0x82255E90;
		  /* 82255E90h */ case    6:  		/* lwz R11, <#[R29]> */
		/* 82255E90h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82255E90h case    6:*/		return 0x82255E94;
		  /* 82255E94h */ case    7:  		/* mr R5, R31 */
		/* 82255E94h case    7:*/		regs.R5 = regs.R31;
		/* 82255E94h case    7:*/		return 0x82255E98;
		  /* 82255E98h */ case    8:  		/* li R4, 0 */
		/* 82255E98h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82255E98h case    8:*/		return 0x82255E9C;
		  /* 82255E9Ch */ case    9:  		/* mr R3, R29 */
		/* 82255E9Ch case    9:*/		regs.R3 = regs.R29;
		/* 82255E9Ch case    9:*/		return 0x82255EA0;
		  /* 82255EA0h */ case   10:  		/* lwz R11, <#[R11 + 80]> */
		/* 82255EA0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82255EA0h case   10:*/		return 0x82255EA4;
		  /* 82255EA4h */ case   11:  		/* mtspr CTR, R11 */
		/* 82255EA4h case   11:*/		regs.CTR = regs.R11;
		/* 82255EA4h case   11:*/		return 0x82255EA8;
		  /* 82255EA8h */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 82255EA8h case   12:*/		if ( 1 ) { regs.LR = 0x82255EAC; return (uint32)regs.CTR; }
		/* 82255EA8h case   12:*/		return 0x82255EAC;
		  /* 82255EACh */ case   13:  		/* lwz R11, <#[R30]> */
		/* 82255EACh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82255EACh case   13:*/		return 0x82255EB0;
		  /* 82255EB0h */ case   14:  		/* cmpwi CR6, R3, 1 */
		/* 82255EB0h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82255EB0h case   14:*/		return 0x82255EB4;
		  /* 82255EB4h */ case   15:  		/* mr R5, R31 */
		/* 82255EB4h case   15:*/		regs.R5 = regs.R31;
		/* 82255EB4h case   15:*/		return 0x82255EB8;
		  /* 82255EB8h */ case   16:  		/* li R4, 0 */
		/* 82255EB8h case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82255EB8h case   16:*/		return 0x82255EBC;
		  /* 82255EBCh */ case   17:  		/* mr R3, R30 */
		/* 82255EBCh case   17:*/		regs.R3 = regs.R30;
		/* 82255EBCh case   17:*/		return 0x82255EC0;
		  /* 82255EC0h */ case   18:  		/* li R6, 1 */
		/* 82255EC0h case   18:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82255EC0h case   18:*/		return 0x82255EC4;
		  /* 82255EC4h */ case   19:  		/* lwz R11, <#[R11 + 84]> */
		/* 82255EC4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 82255EC4h case   19:*/		return 0x82255EC8;
		  /* 82255EC8h */ case   20:  		/* mtspr CTR, R11 */
		/* 82255EC8h case   20:*/		regs.CTR = regs.R11;
		/* 82255EC8h case   20:*/		return 0x82255ECC;
		  /* 82255ECCh */ case   21:  		/* bc 4, CR6_EQ, 8 */
		/* 82255ECCh case   21:*/		if ( !regs.CR[6].eq ) { return 0x82255ED4;  }
		/* 82255ECCh case   21:*/		return 0x82255ED0;
		  /* 82255ED0h */ case   22:  		/* li R6, 0 */
		/* 82255ED0h case   22:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82255ED0h case   22:*/		return 0x82255ED4;
	}
	return 0x82255ED4;
} // Block from 82255E78h-82255ED4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82255ED4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255ED4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255ED4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255ED4);
		  /* 82255ED4h */ case    0:  		/* bcctrl 20, CR0_LT */
		/* 82255ED4h case    0:*/		if ( 1 ) { regs.LR = 0x82255ED8; return (uint32)regs.CTR; }
		/* 82255ED4h case    0:*/		return 0x82255ED8;
		  /* 82255ED8h */ case    1:  		/* addi R31, R31, 1 */
		/* 82255ED8h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82255ED8h case    1:*/		return 0x82255EDC;
		  /* 82255EDCh */ case    2:  		/* cmpwi CR6, R31, 4 */
		/* 82255EDCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000004);
		/* 82255EDCh case    2:*/		return 0x82255EE0;
		  /* 82255EE0h */ case    3:  		/* bc 12, CR6_LT, -80 */
		/* 82255EE0h case    3:*/		if ( regs.CR[6].lt ) { return 0x82255E90;  }
		/* 82255EE0h case    3:*/		return 0x82255EE4;
		  /* 82255EE4h */ case    4:  		/* addi R1, R1, 112 */
		/* 82255EE4h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82255EE4h case    4:*/		return 0x82255EE8;
		  /* 82255EE8h */ case    5:  		/* b -1854524 */
		/* 82255EE8h case    5:*/		return 0x820912AC;
		/* 82255EE8h case    5:*/		return 0x82255EEC;
		  /* 82255EECh */ case    6:  		/* nop */
		/* 82255EECh case    6:*/		cpu::op::nop();
		/* 82255EECh case    6:*/		return 0x82255EF0;
	}
	return 0x82255EF0;
} // Block from 82255ED4h-82255EF0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82255EF0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255EF0);
		  /* 82255EF0h */ case    0:  		/* lbz R11, <#[R3 + 128]> */
		/* 82255EF0h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000080) );
		/* 82255EF0h case    0:*/		return 0x82255EF4;
		  /* 82255EF4h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 82255EF4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82255EF4h case    1:*/		return 0x82255EF8;
		  /* 82255EF8h */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 82255EF8h case    2:*/		if ( regs.CR[6].eq ) { return 0x82255F24;  }
		/* 82255EF8h case    2:*/		return 0x82255EFC;
		  /* 82255EFCh */ case    3:  		/* lbz R11, <#[R3 + 129]> */
		/* 82255EFCh case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000081) );
		/* 82255EFCh case    3:*/		return 0x82255F00;
		  /* 82255F00h */ case    4:  		/* cmplwi CR6, R11, 1 */
		/* 82255F00h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82255F00h case    4:*/		return 0x82255F04;
		  /* 82255F04h */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 82255F04h case    5:*/		if ( regs.CR[6].eq ) { return 0x82255F24;  }
		/* 82255F04h case    5:*/		return 0x82255F08;
		  /* 82255F08h */ case    6:  		/* lbz R11, <#[R3 + 130]> */
		/* 82255F08h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000082) );
		/* 82255F08h case    6:*/		return 0x82255F0C;
		  /* 82255F0Ch */ case    7:  		/* cmplwi CR6, R11, 1 */
		/* 82255F0Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82255F0Ch case    7:*/		return 0x82255F10;
		  /* 82255F10h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 82255F10h case    8:*/		if ( regs.CR[6].eq ) { return 0x82255F24;  }
		/* 82255F10h case    8:*/		return 0x82255F14;
		  /* 82255F14h */ case    9:  		/* lbz R11, <#[R3 + 131]> */
		/* 82255F14h case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000083) );
		/* 82255F14h case    9:*/		return 0x82255F18;
		  /* 82255F18h */ case   10:  		/* li R3, 0 */
		/* 82255F18h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82255F18h case   10:*/		return 0x82255F1C;
		  /* 82255F1Ch */ case   11:  		/* cmplwi CR6, R11, 1 */
		/* 82255F1Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82255F1Ch case   11:*/		return 0x82255F20;
		  /* 82255F20h */ case   12:  		/* bclr 4, CR6_EQ */
		/* 82255F20h case   12:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82255F20h case   12:*/		return 0x82255F24;
	}
	return 0x82255F24;
} // Block from 82255EF0h-82255F24h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82255F24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255F24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255F24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255F24);
		  /* 82255F24h */ case    0:  		/* li R3, 1 */
		/* 82255F24h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82255F24h case    0:*/		return 0x82255F28;
		  /* 82255F28h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82255F28h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82255F28h case    1:*/		return 0x82255F2C;
	}
	return 0x82255F2C;
} // Block from 82255F24h-82255F2Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82255F2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255F2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255F2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255F2C);
		  /* 82255F2Ch */ case    0:  		/* nop */
		/* 82255F2Ch case    0:*/		cpu::op::nop();
		/* 82255F2Ch case    0:*/		return 0x82255F30;
	}
	return 0x82255F30;
} // Block from 82255F2Ch-82255F30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82255F30h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255F30);
		  /* 82255F30h */ case    0:  		/* lis R11, -32216 */
		/* 82255F30h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 82255F30h case    0:*/		return 0x82255F34;
		  /* 82255F34h */ case    1:  		/* mulli R10, R3, 52 */
		/* 82255F34h case    1:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R3,0x34);
		/* 82255F34h case    1:*/		return 0x82255F38;
		  /* 82255F38h */ case    2:  		/* addi R11, R11, 17992 */
		/* 82255F38h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4648);
		/* 82255F38h case    2:*/		return 0x82255F3C;
		  /* 82255F3Ch */ case    3:  		/* lis R9, -32252 */
		/* 82255F3Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 82255F3Ch case    3:*/		return 0x82255F40;
		  /* 82255F40h */ case    4:  		/* addi R11, R11, 48 */
		/* 82255F40h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x30);
		/* 82255F40h case    4:*/		return 0x82255F44;
		  /* 82255F44h */ case    5:  		/* addi R9, R9, 28696 */
		/* 82255F44h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x7018);
		/* 82255F44h case    5:*/		return 0x82255F48;
		  /* 82255F48h */ case    6:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82255F48h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82255F48h case    6:*/		return 0x82255F4C;
		  /* 82255F4Ch */ case    7:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 82255F4Ch case    7:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 82255F4Ch case    7:*/		return 0x82255F50;
		  /* 82255F50h */ case    8:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82255F50h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82255F50h case    8:*/		return 0x82255F54;
		  /* 82255F54h */ case    9:  		/* mtspr CTR, R11 */
		/* 82255F54h case    9:*/		regs.CTR = regs.R11;
		/* 82255F54h case    9:*/		return 0x82255F58;
		  /* 82255F58h */ case   10:  		/* bcctr 20, CR0_LT */
		/* 82255F58h case   10:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82255F58h case   10:*/		return 0x82255F5C;
		  /* 82255F5Ch */ case   11:  		/* nop */
		/* 82255F5Ch case   11:*/		cpu::op::nop();
		/* 82255F5Ch case   11:*/		return 0x82255F60;
	}
	return 0x82255F60;
} // Block from 82255F30h-82255F60h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82255F60h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255F60);
		  /* 82255F60h */ case    0:  		/* mfspr R12, LR */
		/* 82255F60h case    0:*/		regs.R12 = regs.LR;
		/* 82255F60h case    0:*/		return 0x82255F64;
		  /* 82255F64h */ case    1:  		/* bl -1854728 */
		/* 82255F64h case    1:*/		regs.LR = 0x82255F68; return 0x8209125C;
		/* 82255F64h case    1:*/		return 0x82255F68;
		  /* 82255F68h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82255F68h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82255F68h case    2:*/		return 0x82255F6C;
		  /* 82255F6Ch */ case    3:  		/* mr R29, R4 */
		/* 82255F6Ch case    3:*/		regs.R29 = regs.R4;
		/* 82255F6Ch case    3:*/		return 0x82255F70;
		  /* 82255F70h */ case    4:  		/* li R4, 964 */
		/* 82255F70h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82255F70h case    4:*/		return 0x82255F74;
		  /* 82255F74h */ case    5:  		/* mr R30, R3 */
		/* 82255F74h case    5:*/		regs.R30 = regs.R3;
		/* 82255F74h case    5:*/		return 0x82255F78;
		  /* 82255F78h */ case    6:  		/* lwz R3, <#[R29 + 1452]> */
		/* 82255F78h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x000005AC) );
		/* 82255F78h case    6:*/		return 0x82255F7C;
		  /* 82255F7Ch */ case    7:  		/* bl -236228 */
		/* 82255F7Ch case    7:*/		regs.LR = 0x82255F80; return 0x8221C4B8;
		/* 82255F7Ch case    7:*/		return 0x82255F80;
		  /* 82255F80h */ case    8:  		/* lwz R11, <#[R29 + 1452]> */
		/* 82255F80h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000005AC) );
		/* 82255F80h case    8:*/		return 0x82255F84;
		  /* 82255F84h */ case    9:  		/* mr R4, R30 */
		/* 82255F84h case    9:*/		regs.R4 = regs.R30;
		/* 82255F84h case    9:*/		return 0x82255F88;
		  /* 82255F88h */ case   10:  		/* addi R30, R3, 4 */
		/* 82255F88h case   10:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x4);
		/* 82255F88h case   10:*/		return 0x82255F8C;
		  /* 82255F8Ch */ case   11:  		/* mr R31, R3 */
		/* 82255F8Ch case   11:*/		regs.R31 = regs.R3;
		/* 82255F8Ch case   11:*/		return 0x82255F90;
		  /* 82255F90h */ case   12:  		/* li R5, 960 */
		/* 82255F90h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x3C0);
		/* 82255F90h case   12:*/		return 0x82255F94;
		  /* 82255F94h */ case   13:  		/* stw R11, <#[R3]> */
		/* 82255F94h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82255F94h case   13:*/		return 0x82255F98;
		  /* 82255F98h */ case   14:  		/* mr R3, R30 */
		/* 82255F98h case   14:*/		regs.R3 = regs.R30;
		/* 82255F98h case   14:*/		return 0x82255F9C;
		  /* 82255F9Ch */ case   15:  		/* bl -1852908 */
		/* 82255F9Ch case   15:*/		regs.LR = 0x82255FA0; return 0x820919B0;
		/* 82255F9Ch case   15:*/		return 0x82255FA0;
		  /* 82255FA0h */ case   16:  		/* lwz R11, <#[R29 + 1376]> */
		/* 82255FA0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000560) );
		/* 82255FA0h case   16:*/		return 0x82255FA4;
		  /* 82255FA4h */ case   17:  		/* mr R3, R30 */
		/* 82255FA4h case   17:*/		regs.R3 = regs.R30;
		/* 82255FA4h case   17:*/		return 0x82255FA8;
		  /* 82255FA8h */ case   18:  		/* stw R11, <#[R31 + 228]> */
		/* 82255FA8h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82255FA8h case   18:*/		return 0x82255FAC;
		  /* 82255FACh */ case   19:  		/* lwz R11, <#[R29 + 1376]> */
		/* 82255FACh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000560) );
		/* 82255FACh case   19:*/		return 0x82255FB0;
		  /* 82255FB0h */ case   20:  		/* addi R11, R11, 1 */
		/* 82255FB0h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82255FB0h case   20:*/		return 0x82255FB4;
		  /* 82255FB4h */ case   21:  		/* stw R11, <#[R29 + 1376]> */
		/* 82255FB4h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000560) );
		/* 82255FB4h case   21:*/		return 0x82255FB8;
		  /* 82255FB8h */ case   22:  		/* addi R1, R1, 112 */
		/* 82255FB8h case   22:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82255FB8h case   22:*/		return 0x82255FBC;
		  /* 82255FBCh */ case   23:  		/* b -1854736 */
		/* 82255FBCh case   23:*/		return 0x820912AC;
		/* 82255FBCh case   23:*/		return 0x82255FC0;
	}
	return 0x82255FC0;
} // Block from 82255F60h-82255FC0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82255FC0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82255FC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82255FC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82255FC0);
		  /* 82255FC0h */ case    0:  		/* mfspr R12, LR */
		/* 82255FC0h case    0:*/		regs.R12 = regs.LR;
		/* 82255FC0h case    0:*/		return 0x82255FC4;
		  /* 82255FC4h */ case    1:  		/* bl -1854844 */
		/* 82255FC4h case    1:*/		regs.LR = 0x82255FC8; return 0x82091248;
		/* 82255FC4h case    1:*/		return 0x82255FC8;
		  /* 82255FC8h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82255FC8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82255FC8h case    2:*/		return 0x82255FCC;
		  /* 82255FCCh */ case    3:  		/* lwz R11, <#[R3 + 16]> */
		/* 82255FCCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82255FCCh case    3:*/		return 0x82255FD0;
		  /* 82255FD0h */ case    4:  		/* lis R10, -32252 */
		/* 82255FD0h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82255FD0h case    4:*/		return 0x82255FD4;
		  /* 82255FD4h */ case    5:  		/* lis R9, -32252 */
		/* 82255FD4h case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 82255FD4h case    5:*/		return 0x82255FD8;
		  /* 82255FD8h */ case    6:  		/* lis R8, -32253 */
		/* 82255FD8h case    6:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8203);
		/* 82255FD8h case    6:*/		return 0x82255FDC;
		  /* 82255FDCh */ case    7:  		/* lis R7, -32252 */
		/* 82255FDCh case    7:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8204);
		/* 82255FDCh case    7:*/		return 0x82255FE0;
		  /* 82255FE0h */ case    8:  		/* lis R6, -32252 */
		/* 82255FE0h case    8:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8204);
		/* 82255FE0h case    8:*/		return 0x82255FE4;
		  /* 82255FE4h */ case    9:  		/* mr R31, R3 */
		/* 82255FE4h case    9:*/		regs.R31 = regs.R3;
		/* 82255FE4h case    9:*/		return 0x82255FE8;
		  /* 82255FE8h */ case   10:  		/* li R29, 0 */
		/* 82255FE8h case   10:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82255FE8h case   10:*/		return 0x82255FEC;
		  /* 82255FECh */ case   11:  		/* cmpwi CR6, R11, 0 */
		/* 82255FECh case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82255FECh case   11:*/		return 0x82255FF0;
		  /* 82255FF0h */ case   12:  		/* addi R26, R10, 29056 */
		/* 82255FF0h case   12:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R10,0x7180);
		/* 82255FF0h case   12:*/		return 0x82255FF4;
		  /* 82255FF4h */ case   13:  		/* addi R25, R9, 29012 */
		/* 82255FF4h case   13:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R9,0x7154);
		/* 82255FF4h case   13:*/		return 0x82255FF8;
		  /* 82255FF8h */ case   14:  		/* addi R28, R8, 27460 */
		/* 82255FF8h case   14:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R8,0x6B44);
		/* 82255FF8h case   14:*/		return 0x82255FFC;
		  /* 82255FFCh */ case   15:  		/* addi R24, R7, 29000 */
		/* 82255FFCh case   15:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R7,0x7148);
		/* 82255FFCh case   15:*/		return 0x82256000;
		  /* 82256000h */ case   16:  		/* addi R27, R6, 28888 */
		/* 82256000h case   16:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R6,0x70D8);
		/* 82256000h case   16:*/		return 0x82256004;
		  /* 82256004h */ case   17:  		/* bc 4, CR6_GT, 184 */
		/* 82256004h case   17:*/		if ( !regs.CR[6].gt ) { return 0x822560BC;  }
		/* 82256004h case   17:*/		return 0x82256008;
		  /* 82256008h */ case   18:  		/* addi R30, R3, 28 */
		/* 82256008h case   18:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x1C);
		/* 82256008h case   18:*/		return 0x8225600C;
		  /* 8225600Ch */ case   19:  		/* lwz R11, <#[R30]> */
		/* 8225600Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225600Ch case   19:*/		return 0x82256010;
		  /* 82256010h */ case   20:  		/* cmplwi CR6, R11, 0 */
		/* 82256010h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82256010h case   20:*/		return 0x82256014;
		  /* 82256014h */ case   21:  		/* bc 4, CR6_EQ, 28 */
		/* 82256014h case   21:*/		if ( !regs.CR[6].eq ) { return 0x82256030;  }
		/* 82256014h case   21:*/		return 0x82256018;
		  /* 82256018h */ case   22:  		/* mr R6, R27 */
		/* 82256018h case   22:*/		regs.R6 = regs.R27;
		/* 82256018h case   22:*/		return 0x8225601C;
		  /* 8225601Ch */ case   23:  		/* mr R5, R24 */
		/* 8225601Ch case   23:*/		regs.R5 = regs.R24;
		/* 8225601Ch case   23:*/		return 0x82256020;
		  /* 82256020h */ case   24:  		/* mr R4, R28 */
		/* 82256020h case   24:*/		regs.R4 = regs.R28;
		/* 82256020h case   24:*/		return 0x82256024;
		  /* 82256024h */ case   25:  		/* li R7, 136 */
		/* 82256024h case   25:*/		cpu::op::li<0>(regs,&regs.R7,0x88);
		/* 82256024h case   25:*/		return 0x82256028;
		  /* 82256028h */ case   26:  		/* li R3, 0 */
		/* 82256028h case   26:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82256028h case   26:*/		return 0x8225602C;
		  /* 8225602Ch */ case   27:  		/* bl -1041444 */
		/* 8225602Ch case   27:*/		regs.LR = 0x82256030; return 0x82157C08;
		/* 8225602Ch case   27:*/		return 0x82256030;
	}
	return 0x82256030;
} // Block from 82255FC0h-82256030h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82256030h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256030);
		  /* 82256030h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82256030h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82256030h case    0:*/		return 0x82256034;
		  /* 82256034h */ case    1:  		/* lwz R10, <#[R30 + 52]> */
		/* 82256034h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000034) );
		/* 82256034h case    1:*/		return 0x82256038;
		  /* 82256038h */ case    2:  		/* lwz R11, <#[R11 + 32]> */
		/* 82256038h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 82256038h case    2:*/		return 0x8225603C;
		  /* 8225603Ch */ case    3:  		/* cmpw CR6, R10, R11 */
		/* 8225603Ch case    3:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 8225603Ch case    3:*/		return 0x82256040;
		  /* 82256040h */ case    4:  		/* bc 12, CR6_EQ, 28 */
		/* 82256040h case    4:*/		if ( regs.CR[6].eq ) { return 0x8225605C;  }
		/* 82256040h case    4:*/		return 0x82256044;
		  /* 82256044h */ case    5:  		/* mr R6, R27 */
		/* 82256044h case    5:*/		regs.R6 = regs.R27;
		/* 82256044h case    5:*/		return 0x82256048;
		  /* 82256048h */ case    6:  		/* mr R5, R25 */
		/* 82256048h case    6:*/		regs.R5 = regs.R25;
		/* 82256048h case    6:*/		return 0x8225604C;
		  /* 8225604Ch */ case    7:  		/* mr R4, R28 */
		/* 8225604Ch case    7:*/		regs.R4 = regs.R28;
		/* 8225604Ch case    7:*/		return 0x82256050;
		  /* 82256050h */ case    8:  		/* li R7, 137 */
		/* 82256050h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x89);
		/* 82256050h case    8:*/		return 0x82256054;
		  /* 82256054h */ case    9:  		/* li R3, 0 */
		/* 82256054h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82256054h case    9:*/		return 0x82256058;
		  /* 82256058h */ case   10:  		/* bl -1041488 */
		/* 82256058h case   10:*/		regs.LR = 0x8225605C; return 0x82157C08;
		/* 82256058h case   10:*/		return 0x8225605C;
	}
	return 0x8225605C;
} // Block from 82256030h-8225605Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8225605Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225605C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225605C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225605C);
		  /* 8225605Ch */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8225605Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225605Ch case    0:*/		return 0x82256060;
		  /* 82256060h */ case    1:  		/* lwz R10, <#[R30 + 28]> */
		/* 82256060h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000001C) );
		/* 82256060h case    1:*/		return 0x82256064;
		  /* 82256064h */ case    2:  		/* lwz R9, <#[R11 + 16]> */
		/* 82256064h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 82256064h case    2:*/		return 0x82256068;
		  /* 82256068h */ case    3:  		/* cmpw CR6, R10, R9 */
		/* 82256068h case    3:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R9);
		/* 82256068h case    3:*/		return 0x8225606C;
		  /* 8225606Ch */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 8225606Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82256094;  }
		/* 8225606Ch case    4:*/		return 0x82256070;
		  /* 82256070h */ case    5:  		/* lwz R11, <#[R11 + 12]> */
		/* 82256070h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 82256070h case    5:*/		return 0x82256074;
		  /* 82256074h */ case    6:  		/* cmpw CR6, R10, R11 */
		/* 82256074h case    6:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 82256074h case    6:*/		return 0x82256078;
		  /* 82256078h */ case    7:  		/* bc 12, CR6_EQ, 28 */
		/* 82256078h case    7:*/		if ( regs.CR[6].eq ) { return 0x82256094;  }
		/* 82256078h case    7:*/		return 0x8225607C;
		  /* 8225607Ch */ case    8:  		/* mr R6, R27 */
		/* 8225607Ch case    8:*/		regs.R6 = regs.R27;
		/* 8225607Ch case    8:*/		return 0x82256080;
		  /* 82256080h */ case    9:  		/* mr R5, R26 */
		/* 82256080h case    9:*/		regs.R5 = regs.R26;
		/* 82256080h case    9:*/		return 0x82256084;
		  /* 82256084h */ case   10:  		/* mr R4, R28 */
		/* 82256084h case   10:*/		regs.R4 = regs.R28;
		/* 82256084h case   10:*/		return 0x82256088;
		  /* 82256088h */ case   11:  		/* li R7, 139 */
		/* 82256088h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x8B);
		/* 82256088h case   11:*/		return 0x8225608C;
		  /* 8225608Ch */ case   12:  		/* li R3, 0 */
		/* 8225608Ch case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225608Ch case   12:*/		return 0x82256090;
		  /* 82256090h */ case   13:  		/* bl -1041544 */
		/* 82256090h case   13:*/		regs.LR = 0x82256094; return 0x82157C08;
		/* 82256090h case   13:*/		return 0x82256094;
	}
	return 0x82256094;
} // Block from 8225605Ch-82256094h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82256094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256094);
		  /* 82256094h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82256094h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82256094h case    0:*/		return 0x82256098;
		  /* 82256098h */ case    1:  		/* mr R3, R31 */
		/* 82256098h case    1:*/		regs.R3 = regs.R31;
		/* 82256098h case    1:*/		return 0x8225609C;
		  /* 8225609Ch */ case    2:  		/* lwz R11, <#[R11 + 20]> */
		/* 8225609Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8225609Ch case    2:*/		return 0x822560A0;
		  /* 822560A0h */ case    3:  		/* mtspr CTR, R11 */
		/* 822560A0h case    3:*/		regs.CTR = regs.R11;
		/* 822560A0h case    3:*/		return 0x822560A4;
		  /* 822560A4h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 822560A4h case    4:*/		if ( 1 ) { regs.LR = 0x822560A8; return (uint32)regs.CTR; }
		/* 822560A4h case    4:*/		return 0x822560A8;
		  /* 822560A8h */ case    5:  		/* lwz R11, <#[R31 + 16]> */
		/* 822560A8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 822560A8h case    5:*/		return 0x822560AC;
		  /* 822560ACh */ case    6:  		/* addi R29, R29, 1 */
		/* 822560ACh case    6:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 822560ACh case    6:*/		return 0x822560B0;
		  /* 822560B0h */ case    7:  		/* addi R30, R30, 4 */
		/* 822560B0h case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 822560B0h case    7:*/		return 0x822560B4;
		  /* 822560B4h */ case    8:  		/* cmpw CR6, R29, R11 */
		/* 822560B4h case    8:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R11);
		/* 822560B4h case    8:*/		return 0x822560B8;
		  /* 822560B8h */ case    9:  		/* bc 12, CR6_LT, -172 */
		/* 822560B8h case    9:*/		if ( regs.CR[6].lt ) { return 0x8225600C;  }
		/* 822560B8h case    9:*/		return 0x822560BC;
	}
	return 0x822560BC;
} // Block from 82256094h-822560BCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 822560BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822560BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822560BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822560BC);
		  /* 822560BCh */ case    0:  		/* lwz R10, <#[R31 + 20]> */
		/* 822560BCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 822560BCh case    0:*/		return 0x822560C0;
		  /* 822560C0h */ case    1:  		/* li R29, 1 */
		/* 822560C0h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 822560C0h case    1:*/		return 0x822560C4;
		  /* 822560C4h */ case    2:  		/* add R11, R10, R11 */
		/* 822560C4h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 822560C4h case    2:*/		return 0x822560C8;
		  /* 822560C8h */ case    3:  		/* cmpwi CR6, R11, 1 */
		/* 822560C8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 822560C8h case    3:*/		return 0x822560CC;
		  /* 822560CCh */ case    4:  		/* bc 4, CR6_GT, 220 */
		/* 822560CCh case    4:*/		if ( !regs.CR[6].gt ) { return 0x822561A8;  }
		/* 822560CCh case    4:*/		return 0x822560D0;
		  /* 822560D0h */ case    5:  		/* addi R30, R31, 32 */
		/* 822560D0h case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x20);
		/* 822560D0h case    5:*/		return 0x822560D4;
		  /* 822560D4h */ case    6:  		/* lwz R11, <#[R30]> */
		/* 822560D4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822560D4h case    6:*/		return 0x822560D8;
		  /* 822560D8h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 822560D8h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822560D8h case    7:*/		return 0x822560DC;
		  /* 822560DCh */ case    8:  		/* bc 4, CR6_EQ, 28 */
		/* 822560DCh case    8:*/		if ( !regs.CR[6].eq ) { return 0x822560F8;  }
		/* 822560DCh case    8:*/		return 0x822560E0;
		  /* 822560E0h */ case    9:  		/* mr R6, R27 */
		/* 822560E0h case    9:*/		regs.R6 = regs.R27;
		/* 822560E0h case    9:*/		return 0x822560E4;
		  /* 822560E4h */ case   10:  		/* mr R5, R24 */
		/* 822560E4h case   10:*/		regs.R5 = regs.R24;
		/* 822560E4h case   10:*/		return 0x822560E8;
		  /* 822560E8h */ case   11:  		/* mr R4, R28 */
		/* 822560E8h case   11:*/		regs.R4 = regs.R28;
		/* 822560E8h case   11:*/		return 0x822560EC;
		  /* 822560ECh */ case   12:  		/* li R7, 145 */
		/* 822560ECh case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x91);
		/* 822560ECh case   12:*/		return 0x822560F0;
		  /* 822560F0h */ case   13:  		/* li R3, 0 */
		/* 822560F0h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822560F0h case   13:*/		return 0x822560F4;
		  /* 822560F4h */ case   14:  		/* bl -1041644 */
		/* 822560F4h case   14:*/		regs.LR = 0x822560F8; return 0x82157C08;
		/* 822560F4h case   14:*/		return 0x822560F8;
	}
	return 0x822560F8;
} // Block from 822560BCh-822560F8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 822560F8h
// Function '??0AutoIndexVtx@XGRAPHICS@@QAA@HW4RegType@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822560F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822560F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822560F8);
		  /* 822560F8h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 822560F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822560F8h case    0:*/		return 0x822560FC;
		  /* 822560FCh */ case    1:  		/* lwz R10, <#[R30 + 52]> */
		/* 822560FCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000034) );
		/* 822560FCh case    1:*/		return 0x82256100;
		  /* 82256100h */ case    2:  		/* lwz R11, <#[R11 + 32]> */
		/* 82256100h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 82256100h case    2:*/		return 0x82256104;
		  /* 82256104h */ case    3:  		/* cmpw CR6, R10, R11 */
		/* 82256104h case    3:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 82256104h case    3:*/		return 0x82256108;
		  /* 82256108h */ case    4:  		/* bc 12, CR6_EQ, 28 */
		/* 82256108h case    4:*/		if ( regs.CR[6].eq ) { return 0x82256124;  }
		/* 82256108h case    4:*/		return 0x8225610C;
		  /* 8225610Ch */ case    5:  		/* mr R6, R27 */
		/* 8225610Ch case    5:*/		regs.R6 = regs.R27;
		/* 8225610Ch case    5:*/		return 0x82256110;
		  /* 82256110h */ case    6:  		/* mr R5, R25 */
		/* 82256110h case    6:*/		regs.R5 = regs.R25;
		/* 82256110h case    6:*/		return 0x82256114;
		  /* 82256114h */ case    7:  		/* mr R4, R28 */
		/* 82256114h case    7:*/		regs.R4 = regs.R28;
		/* 82256114h case    7:*/		return 0x82256118;
		  /* 82256118h */ case    8:  		/* li R7, 146 */
		/* 82256118h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x92);
		/* 82256118h case    8:*/		return 0x8225611C;
		  /* 8225611Ch */ case    9:  		/* li R3, 0 */
		/* 8225611Ch case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225611Ch case    9:*/		return 0x82256120;
		  /* 82256120h */ case   10:  		/* bl -1041688 */
		/* 82256120h case   10:*/		regs.LR = 0x82256124; return 0x82157C08;
		/* 82256120h case   10:*/		return 0x82256124;
	}
	return 0x82256124;
} // Block from 822560F8h-82256124h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82256124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256124);
		  /* 82256124h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82256124h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82256124h case    0:*/		return 0x82256128;
		  /* 82256128h */ case    1:  		/* lwz R10, <#[R30 + 28]> */
		/* 82256128h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000001C) );
		/* 82256128h case    1:*/		return 0x8225612C;
		  /* 8225612Ch */ case    2:  		/* lwz R9, <#[R11 + 16]> */
		/* 8225612Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 8225612Ch case    2:*/		return 0x82256130;
		  /* 82256130h */ case    3:  		/* cmpw CR6, R10, R9 */
		/* 82256130h case    3:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R9);
		/* 82256130h case    3:*/		return 0x82256134;
		  /* 82256134h */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 82256134h case    4:*/		if ( regs.CR[6].eq ) { return 0x8225615C;  }
		/* 82256134h case    4:*/		return 0x82256138;
		  /* 82256138h */ case    5:  		/* lwz R11, <#[R11 + 12]> */
		/* 82256138h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 82256138h case    5:*/		return 0x8225613C;
		  /* 8225613Ch */ case    6:  		/* cmpw CR6, R10, R11 */
		/* 8225613Ch case    6:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 8225613Ch case    6:*/		return 0x82256140;
		  /* 82256140h */ case    7:  		/* bc 12, CR6_EQ, 28 */
		/* 82256140h case    7:*/		if ( regs.CR[6].eq ) { return 0x8225615C;  }
		/* 82256140h case    7:*/		return 0x82256144;
		  /* 82256144h */ case    8:  		/* mr R6, R27 */
		/* 82256144h case    8:*/		regs.R6 = regs.R27;
		/* 82256144h case    8:*/		return 0x82256148;
		  /* 82256148h */ case    9:  		/* mr R5, R26 */
		/* 82256148h case    9:*/		regs.R5 = regs.R26;
		/* 82256148h case    9:*/		return 0x8225614C;
		  /* 8225614Ch */ case   10:  		/* mr R4, R28 */
		/* 8225614Ch case   10:*/		regs.R4 = regs.R28;
		/* 8225614Ch case   10:*/		return 0x82256150;
		  /* 82256150h */ case   11:  		/* li R7, 148 */
		/* 82256150h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x94);
		/* 82256150h case   11:*/		return 0x82256154;
		  /* 82256154h */ case   12:  		/* li R3, 0 */
		/* 82256154h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82256154h case   12:*/		return 0x82256158;
		  /* 82256158h */ case   13:  		/* bl -1041744 */
		/* 82256158h case   13:*/		regs.LR = 0x8225615C; return 0x82157C08;
		/* 82256158h case   13:*/		return 0x8225615C;
	}
	return 0x8225615C;
} // Block from 82256124h-8225615Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8225615Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225615C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225615C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225615C);
		  /* 8225615Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8225615Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8225615Ch case    0:*/		return 0x82256160;
		  /* 82256160h */ case    1:  		/* mr R3, R31 */
		/* 82256160h case    1:*/		regs.R3 = regs.R31;
		/* 82256160h case    1:*/		return 0x82256164;
		  /* 82256164h */ case    2:  		/* lwz R11, <#[R11 + 20]> */
		/* 82256164h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82256164h case    2:*/		return 0x82256168;
		  /* 82256168h */ case    3:  		/* mtspr CTR, R11 */
		/* 82256168h case    3:*/		regs.CTR = regs.R11;
		/* 82256168h case    3:*/		return 0x8225616C;
		  /* 8225616Ch */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8225616Ch case    4:*/		if ( 1 ) { regs.LR = 0x82256170; return (uint32)regs.CTR; }
		/* 8225616Ch case    4:*/		return 0x82256170;
		  /* 82256170h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82256170h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82256170h case    5:*/		return 0x82256174;
		  /* 82256174h */ case    6:  		/* bc 4, CR0_EQ, 24 */
		/* 82256174h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8225618C;  }
		/* 82256174h case    6:*/		return 0x82256178;
		  /* 82256178h */ case    7:  		/* lwz R11, <#[R31]> */
		/* 82256178h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82256178h case    7:*/		return 0x8225617C;
		  /* 8225617Ch */ case    8:  		/* mr R3, R31 */
		/* 8225617Ch case    8:*/		regs.R3 = regs.R31;
		/* 8225617Ch case    8:*/		return 0x82256180;
		  /* 82256180h */ case    9:  		/* lwz R11, <#[R11 + 24]> */
		/* 82256180h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82256180h case    9:*/		return 0x82256184;
		  /* 82256184h */ case   10:  		/* mtspr CTR, R11 */
		/* 82256184h case   10:*/		regs.CTR = regs.R11;
		/* 82256184h case   10:*/		return 0x82256188;
		  /* 82256188h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 82256188h case   11:*/		if ( 1 ) { regs.LR = 0x8225618C; return (uint32)regs.CTR; }
		/* 82256188h case   11:*/		return 0x8225618C;
	}
	return 0x8225618C;
} // Block from 8225615Ch-8225618Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8225618Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225618C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225618C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225618C);
		  /* 8225618Ch */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 8225618Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8225618Ch case    0:*/		return 0x82256190;
		  /* 82256190h */ case    1:  		/* addi R29, R29, 1 */
		/* 82256190h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82256190h case    1:*/		return 0x82256194;
		  /* 82256194h */ case    2:  		/* lwz R10, <#[R31 + 16]> */
		/* 82256194h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82256194h case    2:*/		return 0x82256198;
		  /* 82256198h */ case    3:  		/* addi R30, R30, 4 */
		/* 82256198h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82256198h case    3:*/		return 0x8225619C;
		  /* 8225619Ch */ case    4:  		/* add R11, R11, R10 */
		/* 8225619Ch case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8225619Ch case    4:*/		return 0x822561A0;
		  /* 822561A0h */ case    5:  		/* cmpw CR6, R29, R11 */
		/* 822561A0h case    5:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R11);
		/* 822561A0h case    5:*/		return 0x822561A4;
		  /* 822561A4h */ case    6:  		/* bc 12, CR6_LT, -208 */
		/* 822561A4h case    6:*/		if ( regs.CR[6].lt ) { return 0x822560D4;  }
		/* 822561A4h case    6:*/		return 0x822561A8;
	}
	return 0x822561A8;
} // Block from 8225618Ch-822561A8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822561A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822561A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822561A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822561A8);
		  /* 822561A8h */ case    0:  		/* lwz R11, <#[R31 + 948]> */
		/* 822561A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000003B4) );
		/* 822561A8h case    0:*/		return 0x822561AC;
		  /* 822561ACh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 822561ACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822561ACh case    1:*/		return 0x822561B0;
		  /* 822561B0h */ case    2:  		/* bc 4, CR6_EQ, 32 */
		/* 822561B0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x822561D0;  }
		/* 822561B0h case    2:*/		return 0x822561B4;
		  /* 822561B4h */ case    3:  		/* lis R11, -32252 */
		/* 822561B4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822561B4h case    3:*/		return 0x822561B8;
		  /* 822561B8h */ case    4:  		/* mr R6, R27 */
		/* 822561B8h case    4:*/		regs.R6 = regs.R27;
		/* 822561B8h case    4:*/		return 0x822561BC;
		  /* 822561BCh */ case    5:  		/* addi R5, R11, 28980 */
		/* 822561BCh case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x7134);
		/* 822561BCh case    5:*/		return 0x822561C0;
		  /* 822561C0h */ case    6:  		/* mr R4, R28 */
		/* 822561C0h case    6:*/		regs.R4 = regs.R28;
		/* 822561C0h case    6:*/		return 0x822561C4;
		  /* 822561C4h */ case    7:  		/* li R7, 153 */
		/* 822561C4h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x99);
		/* 822561C4h case    7:*/		return 0x822561C8;
		  /* 822561C8h */ case    8:  		/* li R3, 0 */
		/* 822561C8h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822561C8h case    8:*/		return 0x822561CC;
		  /* 822561CCh */ case    9:  		/* bl -1041860 */
		/* 822561CCh case    9:*/		regs.LR = 0x822561D0; return 0x82157C08;
		/* 822561CCh case    9:*/		return 0x822561D0;
	}
	return 0x822561D0;
} // Block from 822561A8h-822561D0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822561D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822561D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822561D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822561D0);
		  /* 822561D0h */ case    0:  		/* li R3, 1 */
		/* 822561D0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 822561D0h case    0:*/		return 0x822561D4;
		  /* 822561D4h */ case    1:  		/* addi R1, R1, 160 */
		/* 822561D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 822561D4h case    1:*/		return 0x822561D8;
		  /* 822561D8h */ case    2:  		/* b -1855296 */
		/* 822561D8h case    2:*/		return 0x82091298;
		/* 822561D8h case    2:*/		return 0x822561DC;
		  /* 822561DCh */ case    3:  		/* nop */
		/* 822561DCh case    3:*/		cpu::op::nop();
		/* 822561DCh case    3:*/		return 0x822561E0;
	}
	return 0x822561E0;
} // Block from 822561D0h-822561E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822561E0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822561E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822561E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822561E0);
		  /* 822561E0h */ case    0:  		/* addi R11, R4, 58 */
		/* 822561E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x3A);
		/* 822561E0h case    0:*/		return 0x822561E4;
		  /* 822561E4h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822561E4h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822561E4h case    1:*/		return 0x822561E8;
		  /* 822561E8h */ case    2:  		/* lwzx R11, <#[R11 + R3]> */
		/* 822561E8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 822561E8h case    2:*/		return 0x822561EC;
		  /* 822561ECh */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 822561ECh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822561ECh case    3:*/		return 0x822561F0;
		  /* 822561F0h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 822561F0h case    4:*/		if ( regs.CR[6].eq ) { return 0x822561FC;  }
		/* 822561F0h case    4:*/		return 0x822561F4;
		  /* 822561F4h */ case    5:  		/* lwz R11, <#[R11 + 80]> */
		/* 822561F4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 822561F4h case    5:*/		return 0x822561F8;
		  /* 822561F8h */ case    6:  		/* b 16 */
		/* 822561F8h case    6:*/		return 0x82256208;
		/* 822561F8h case    6:*/		return 0x822561FC;
	}
	return 0x822561FC;
} // Block from 822561E0h-822561FCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 822561FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822561FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822561FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822561FC);
		  /* 822561FCh */ case    0:  		/* addi R11, R4, 20 */
		/* 822561FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x14);
		/* 822561FCh case    0:*/		return 0x82256200;
		  /* 82256200h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82256200h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82256200h case    1:*/		return 0x82256204;
		  /* 82256204h */ case    2:  		/* lwzx R11, <#[R11 + R3]> */
		/* 82256204h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82256204h case    2:*/		return 0x82256208;
	}
	return 0x82256208;
} // Block from 822561FCh-82256208h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82256208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256208);
		  /* 82256208h */ case    0:  		/* lis R10, -32251 */
		/* 82256208h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 82256208h case    0:*/		return 0x8225620C;
		  /* 8225620Ch */ case    1:  		/* mulli R9, R11, 12 */
		/* 8225620Ch case    1:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R11,0xC);
		/* 8225620Ch case    1:*/		return 0x82256210;
	}
	return 0x82256210;
} // Block from 82256208h-82256210h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82256210h
// Function '??0HosCoord@XGRAPHICS@@QAA@HW4RegType@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256210);
		  /* 82256210h */ case    0:  		/* addi R11, R10, -19064 */
		/* 82256210h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFB588);
		/* 82256210h case    0:*/		return 0x82256214;
		  /* 82256214h */ case    1:  		/* addi R11, R11, 7 */
		/* 82256214h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7);
		/* 82256214h case    1:*/		return 0x82256218;
		  /* 82256218h */ case    2:  		/* lbzx R11, <#[R9 + R11]> */
		/* 82256218h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82256218h case    2:*/		return 0x8225621C;
		  /* 8225621Ch */ case    3:  		/* cmplwi CR6, R11, 1 */
		/* 8225621Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8225621Ch case    3:*/		return 0x82256220;
		  /* 82256220h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 82256220h case    4:*/		if ( regs.CR[6].eq ) { return 0x82256234;  }
		/* 82256220h case    4:*/		return 0x82256224;
		  /* 82256224h */ case    5:  		/* addi R11, R11, -2 */
		/* 82256224h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFE);
		/* 82256224h case    5:*/		return 0x82256228;
		  /* 82256228h */ case    6:  		/* cntlzw R11, R11 */
		/* 82256228h case    6:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82256228h case    6:*/		return 0x8225622C;
		  /* 8225622Ch */ case    7:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 8225622Ch case    7:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 8225622Ch case    7:*/		return 0x82256230;
		  /* 82256230h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82256230h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82256230h case    8:*/		return 0x82256234;
	}
	return 0x82256234;
} // Block from 82256210h-82256234h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82256234h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256234);
		  /* 82256234h */ case    0:  		/* li R3, 2 */
		/* 82256234h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 82256234h case    0:*/		return 0x82256238;
		  /* 82256238h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82256238h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82256238h case    1:*/		return 0x8225623C;
	}
	return 0x8225623C;
} // Block from 82256234h-8225623Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225623Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225623C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225623C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225623C);
		  /* 8225623Ch */ case    0:  		/* nop */
		/* 8225623Ch case    0:*/		cpu::op::nop();
		/* 8225623Ch case    0:*/		return 0x82256240;
	}
	return 0x82256240;
} // Block from 8225623Ch-82256240h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82256240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256240);
		  /* 82256240h */ case    0:  		/* mfspr R12, LR */
		/* 82256240h case    0:*/		regs.R12 = regs.LR;
		/* 82256240h case    0:*/		return 0x82256244;
		  /* 82256244h */ case    1:  		/* bl -1855472 */
		/* 82256244h case    1:*/		regs.LR = 0x82256248; return 0x82091254;
		/* 82256244h case    1:*/		return 0x82256248;
		  /* 82256248h */ case    2:  		/* lis R10, -32252 */
		/* 82256248h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82256248h case    2:*/		return 0x8225624C;
		  /* 8225624Ch */ case    3:  		/* li R11, 0 */
		/* 8225624Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225624Ch case    3:*/		return 0x82256250;
		  /* 82256250h */ case    4:  		/* addi R9, R10, 28880 */
		/* 82256250h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x70D0);
		/* 82256250h case    4:*/		return 0x82256254;
		  /* 82256254h */ case    5:  		/* li R31, -1 */
		/* 82256254h case    5:*/		cpu::op::li<0>(regs,&regs.R31,0xFFFFFFFF);
		/* 82256254h case    5:*/		return 0x82256258;
		  /* 82256258h */ case    6:  		/* stw R11, <#[R3 + 52]> */
		/* 82256258h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000034) );
		/* 82256258h case    6:*/		return 0x8225625C;
		  /* 8225625Ch */ case    7:  		/* li R4, 48 */
		/* 8225625Ch case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x30);
		/* 8225625Ch case    7:*/		return 0x82256260;
		  /* 82256260h */ case    8:  		/* stw R11, <#[R3 + 16]> */
		/* 82256260h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82256260h case    8:*/		return 0x82256264;
		  /* 82256264h */ case    9:  		/* stw R11, <#[R3 + 20]> */
		/* 82256264h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82256264h case    9:*/		return 0x82256268;
		  /* 82256268h */ case   10:  		/* li R7, 12 */
		/* 82256268h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0xC);
		/* 82256268h case   10:*/		return 0x8225626C;
		  /* 8225626Ch */ case   11:  		/* stw R31, <#[R3 + 56]> */
		/* 8225626Ch case   11:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000038) );
		/* 8225626Ch case   11:*/		return 0x82256270;
		  /* 82256270h */ case   12:  		/* mr R30, R11 */
		/* 82256270h case   12:*/		regs.R30 = regs.R11;
		/* 82256270h case   12:*/		return 0x82256274;
		  /* 82256274h */ case   13:  		/* stw R4, <#[R3 + 80]> */
		/* 82256274h case   13:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000050) );
		/* 82256274h case   13:*/		return 0x82256278;
		  /* 82256278h */ case   14:  		/* addi R6, R3, 152 */
		/* 82256278h case   14:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R3,0x98);
		/* 82256278h case   14:*/		return 0x8225627C;
		  /* 8225627Ch */ case   15:  		/* lwz R10, <#[R9 - 8]> */
		/* 8225627Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0xFFFFFFF8) );
		/* 8225627Ch case   15:*/		return 0x82256280;
		  /* 82256280h */ case   16:  		/* addi R5, R3, 158 */
		/* 82256280h case   16:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R3,0x9E);
		/* 82256280h case   16:*/		return 0x82256284;
		  /* 82256284h */ case   17:  		/* stw R10, <#[R3 + 128]> */
		/* 82256284h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000080) );
		/* 82256284h case   17:*/		return 0x82256288;
		  /* 82256288h */ case   18:  		/* li R10, 1 */
		/* 82256288h case   18:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82256288h case   18:*/		return 0x8225628C;
		  /* 8225628Ch */ case   19:  		/* lwz R8, <#[R9 - 16]> */
		/* 8225628Ch case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0xFFFFFFF0) );
		/* 8225628Ch case   19:*/		return 0x82256290;
		  /* 82256290h */ case   20:  		/* stw R8, <#[R3 + 944]> */
		/* 82256290h case   20:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x000003B0) );
		/* 82256290h case   20:*/		return 0x82256294;
		  /* 82256294h */ case   21:  		/* lis R8, -32216 */
		/* 82256294h case   21:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8228);
		/* 82256294h case   21:*/		return 0x82256298;
		  /* 82256298h */ case   22:  		/* lwz R28, <#[R9 + 4]> */
		/* 82256298h case   22:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R9 + 0x00000004) );
		/* 82256298h case   22:*/		return 0x8225629C;
		  /* 8225629Ch */ case   23:  		/* addi R30, R8, 17992 */
		/* 8225629Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R8,0x4648);
		/* 8225629Ch case   23:*/		return 0x822562A0;
		  /* 822562A0h */ case   24:  		/* lwz R29, <#[R9]> */
		/* 822562A0h case   24:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R9 + 0x00000000) );
		/* 822562A0h case   24:*/		return 0x822562A4;
		  /* 822562A4h */ case   25:  		/* stb R11, <#[R3 + 152]> */
		/* 822562A4h case   25:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000098) );
		/* 822562A4h case   25:*/		return 0x822562A8;
		  /* 822562A8h */ case   26:  		/* stb R11, <#[R3 + 158]> */
		/* 822562A8h case   26:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x0000009E) );
		/* 822562A8h case   26:*/		return 0x822562AC;
		  /* 822562ACh */ case   27:  		/* stw R11, <#[R3 + 28]> */
		/* 822562ACh case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 822562ACh case   27:*/		return 0x822562B0;
		  /* 822562B0h */ case   28:  		/* stwbrx R11, <#[R3 + R7]> */
		/* 822562B0h case   28:*/		cpu::mem::stwbrx( regs, regs.R11, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 822562B0h case   28:*/		return 0x822562B4;
		  /* 822562B4h */ case   29:  		/* stw R11, <#[R3 + 200]> */
		/* 822562B4h case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000C8) );
		/* 822562B4h case   29:*/		return 0x822562B8;
		  /* 822562B8h */ case   30:  		/* addi R8, R10, 14 */
		/* 822562B8h case   30:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xE);
		/* 822562B8h case   30:*/		return 0x822562BC;
		  /* 822562BCh */ case   31:  		/* addi R7, R10, 20 */
		/* 822562BCh case   31:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0x14);
		/* 822562BCh case   31:*/		return 0x822562C0;
		  /* 822562C0h */ case   32:  		/* rlwinm R27, R8, 2, 0, 29 */
		/* 822562C0h case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R8);
		/* 822562C0h case   32:*/		return 0x822562C4;
		  /* 822562C4h */ case   33:  		/* addi R8, R10, 32 */
		/* 822562C4h case   33:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x20);
		/* 822562C4h case   33:*/		return 0x822562C8;
		  /* 822562C8h */ case   34:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 822562C8h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 822562C8h case   34:*/		return 0x822562CC;
		  /* 822562CCh */ case   35:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 822562CCh case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 822562CCh case   35:*/		return 0x822562D0;
		  /* 822562D0h */ case   36:  		/* stwx R31, <#[R27 + R3]> */
		/* 822562D0h case   36:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R27 + regs.R3 + 0x00000000) );
		/* 822562D0h case   36:*/		return 0x822562D4;
		  /* 822562D4h */ case   37:  		/* stwx R4, <#[R7 + R3]> */
		/* 822562D4h case   37:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R7 + regs.R3 + 0x00000000) );
		/* 822562D4h case   37:*/		return 0x822562D8;
		  /* 822562D8h */ case   38:  		/* lwz R7, <#[R9 - 16]> */
		/* 822562D8h case   38:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0xFFFFFFF0) );
		/* 822562D8h case   38:*/		return 0x822562DC;
		  /* 822562DCh */ case   39:  		/* stwx R7, <#[R8 + R3]> */
		/* 822562DCh case   39:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 822562DCh case   39:*/		return 0x822562E0;
		  /* 822562E0h */ case   40:  		/* lwz R7, <#[R3 + 24]> */
		/* 822562E0h case   40:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000018) );
		/* 822562E0h case   40:*/		return 0x822562E4;
		  /* 822562E4h */ case   41:  		/* mulli R7, R7, 52 */
		/* 822562E4h case   41:*/		cpu::op::mulli<0>(regs,&regs.R7,regs.R7,0x34);
		/* 822562E4h case   41:*/		return 0x822562E8;
		  /* 822562E8h */ case   42:  		/* lwzx R7, <#[R7 + R30]> */
		/* 822562E8h case   42:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R30 + 0x00000000) );
		/* 822562E8h case   42:*/		return 0x822562EC;
		  /* 822562ECh */ case   43:  		/* rlwinm. R7, R7, 30, 31, 31 */
		/* 822562ECh case   43:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R7,regs.R7);
		/* 822562ECh case   43:*/		return 0x822562F0;
		  /* 822562F0h */ case   44:  		/* bc 12, CR0_EQ, 24 */
		/* 822562F0h case   44:*/		if ( regs.CR[0].eq ) { return 0x82256308;  }
		/* 822562F0h case   44:*/		return 0x822562F4;
		  /* 822562F4h */ case   45:  		/* cmpwi CR6, R10, 1 */
		/* 822562F4h case   45:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 822562F4h case   45:*/		return 0x822562F8;
		  /* 822562F8h */ case   46:  		/* bc 4, CR6_EQ, 12 */
		/* 822562F8h case   46:*/		if ( !regs.CR[6].eq ) { return 0x82256304;  }
		/* 822562F8h case   46:*/		return 0x822562FC;
		  /* 822562FCh */ case   47:  		/* stw R28, <#[R3 + 132]> */
		/* 822562FCh case   47:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000084) );
		/* 822562FCh case   47:*/		return 0x82256300;
		  /* 82256300h */ case   48:  		/* b 8 */
		/* 82256300h case   48:*/		return 0x82256308;
		/* 82256300h case   48:*/		return 0x82256304;
	}
	return 0x82256304;
} // Block from 82256240h-82256304h (49 instructions)

//////////////////////////////////////////////////////
// Block at 82256304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256304);
		  /* 82256304h */ case    0:  		/* stwx R29, <#[R8 + R3]> */
		/* 82256304h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 82256304h case    0:*/		return 0x82256308;
	}
	return 0x82256308;
} // Block from 82256304h-82256308h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82256308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256308);
		  /* 82256308h */ case    0:  		/* addi R8, R10, 7 */
		/* 82256308h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x7);
		/* 82256308h case    0:*/		return 0x8225630C;
		  /* 8225630Ch */ case    1:  		/* stbx R11, <#[R6 + R10]> */
		/* 8225630Ch case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R6 + regs.R10 + 0x00000000) );
		/* 8225630Ch case    1:*/		return 0x82256310;
		  /* 82256310h */ case    2:  		/* addi R7, R10, 50 */
		/* 82256310h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0x32);
		/* 82256310h case    2:*/		return 0x82256314;
		  /* 82256314h */ case    3:  		/* stbx R11, <#[R5 + R10]> */
		/* 82256314h case    3:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R5 + regs.R10 + 0x00000000) );
		/* 82256314h case    3:*/		return 0x82256318;
		  /* 82256318h */ case    4:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82256318h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82256318h case    4:*/		return 0x8225631C;
		  /* 8225631Ch */ case    5:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 8225631Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 8225631Ch case    5:*/		return 0x82256320;
		  /* 82256320h */ case    6:  		/* addi R10, R10, 1 */
		/* 82256320h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82256320h case    6:*/		return 0x82256324;
		  /* 82256324h */ case    7:  		/* cmpwi CR6, R10, 6 */
		/* 82256324h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000006);
		/* 82256324h case    7:*/		return 0x82256328;
		  /* 82256328h */ case    8:  		/* stwx R11, <#[R8 + R3]> */
		/* 82256328h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 82256328h case    8:*/		return 0x8225632C;
		  /* 8225632Ch */ case    9:  		/* stwx R11, <#[R7 + R3]> */
		/* 8225632Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + regs.R3 + 0x00000000) );
		/* 8225632Ch case    9:*/		return 0x82256330;
		  /* 82256330h */ case   10:  		/* bc 12, CR6_LT, -120 */
		/* 82256330h case   10:*/		if ( regs.CR[6].lt ) { return 0x822562B8;  }
		/* 82256330h case   10:*/		return 0x82256334;
		  /* 82256334h */ case   11:  		/* li R10, 91 */
		/* 82256334h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x5B);
		/* 82256334h case   11:*/		return 0x82256338;
		  /* 82256338h */ case   12:  		/* stb R11, <#[R3 + 164]> */
		/* 82256338h case   12:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x000000A4) );
		/* 82256338h case   12:*/		return 0x8225633C;
		  /* 8225633Ch */ case   13:  		/* addi R7, R3, 141 */
		/* 8225633Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R3,0x8D);
		/* 8225633Ch case   13:*/		return 0x82256340;
		  /* 82256340h */ case   14:  		/* li R8, 4 */
		/* 82256340h case   14:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 82256340h case   14:*/		return 0x82256344;
		  /* 82256344h */ case   15:  		/* stwx R11, <#[R7 + R10]> */
		/* 82256344h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 82256344h case   15:*/		return 0x82256348;
		  /* 82256348h */ case   16:  		/* mr R9, R11 */
		/* 82256348h case   16:*/		regs.R9 = regs.R11;
		/* 82256348h case   16:*/		return 0x8225634C;
		  /* 8225634Ch */ case   17:  		/* mtspr CTR, R8 */
		/* 8225634Ch case   17:*/		regs.CTR = regs.R8;
		/* 8225634Ch case   17:*/		return 0x82256350;
		  /* 82256350h */ case   18:  		/* add R8, R10, R9 */
		/* 82256350h case   18:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R9);
		/* 82256350h case   18:*/		return 0x82256354;
		  /* 82256354h */ case   19:  		/* li R6, 3 */
		/* 82256354h case   19:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 82256354h case   19:*/		return 0x82256358;
		  /* 82256358h */ case   20:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82256358h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82256358h case   20:*/		return 0x8225635C;
		  /* 8225635Ch */ case   21:  		/* addi R9, R9, 1 */
		/* 8225635Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8225635Ch case   21:*/		return 0x82256360;
		  /* 82256360h */ case   22:  		/* stwx R6, <#[R8 + R3]> */
		/* 82256360h case   22:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 82256360h case   22:*/		return 0x82256364;
		  /* 82256364h */ case   23:  		/* bc 16, CR0_LT, -20 */
		/* 82256364h case   23:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82256350;  }
		/* 82256364h case   23:*/		return 0x82256368;
		  /* 82256368h */ case   24:  		/* addi R10, R10, 4 */
		/* 82256368h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82256368h case   24:*/		return 0x8225636C;
		  /* 8225636Ch */ case   25:  		/* cmpwi CR6, R10, 219 */
		/* 8225636Ch case   25:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x000000DB);
		/* 8225636Ch case   25:*/		return 0x82256370;
		  /* 82256370h */ case   26:  		/* bc 12, CR6_LT, -48 */
		/* 82256370h case   26:*/		if ( regs.CR[6].lt ) { return 0x82256340;  }
		/* 82256370h case   26:*/		return 0x82256374;
		  /* 82256374h */ case   27:  		/* li R8, 4 */
		/* 82256374h case   27:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 82256374h case   27:*/		return 0x82256378;
		  /* 82256378h */ case   28:  		/* addi R9, R3, 924 */
		/* 82256378h case   28:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x39C);
		/* 82256378h case   28:*/		return 0x8225637C;
		  /* 8225637Ch */ case   29:  		/* addi R10, R3, 892 */
		/* 8225637Ch case   29:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0x37C);
		/* 8225637Ch case   29:*/		return 0x82256380;
		  /* 82256380h */ case   30:  		/* mtspr CTR, R8 */
		/* 82256380h case   30:*/		regs.CTR = regs.R8;
		/* 82256380h case   30:*/		return 0x82256384;
		  /* 82256384h */ case   31:  		/* stw R11, <#[R10 + 4]> */
		/* 82256384h case   31:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 82256384h case   31:*/		return 0x82256388;
		  /* 82256388h */ case   32:  		/* stwu R11, <#[R10 + 8]> */
		/* 82256388h case   32:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 82256388h case   32:*/		return 0x8225638C;
		  /* 8225638Ch */ case   33:  		/* stwu R11, <#[R9 + 4]> */
		/* 8225638Ch case   33:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 8225638Ch case   33:*/		return 0x82256390;
		  /* 82256390h */ case   34:  		/* bc 16, CR0_LT, -12 */
		/* 82256390h case   34:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82256384;  }
		/* 82256390h case   34:*/		return 0x82256394;
		  /* 82256394h */ case   35:  		/* b -1855728 */
		/* 82256394h case   35:*/		return 0x820912A4;
		/* 82256394h case   35:*/		return 0x82256398;
	}
	return 0x82256398;
} // Block from 82256308h-82256398h (36 instructions)

//////////////////////////////////////////////////////
// Block at 82256398h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256398);
		  /* 82256398h */ case    0:  		/* mfspr R12, LR */
		/* 82256398h case    0:*/		regs.R12 = regs.LR;
		/* 82256398h case    0:*/		return 0x8225639C;
		  /* 8225639Ch */ case    1:  		/* bl -1855808 */
		/* 8225639Ch case    1:*/		regs.LR = 0x822563A0; return 0x8209125C;
		/* 8225639Ch case    1:*/		return 0x822563A0;
		  /* 822563A0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 822563A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822563A0h case    2:*/		return 0x822563A4;
		  /* 822563A4h */ case    3:  		/* mr R30, R3 */
		/* 822563A4h case    3:*/		regs.R30 = regs.R3;
		/* 822563A4h case    3:*/		return 0x822563A8;
		  /* 822563A8h */ case    4:  		/* mr R31, R4 */
		/* 822563A8h case    4:*/		regs.R31 = regs.R4;
		/* 822563A8h case    4:*/		return 0x822563AC;
		  /* 822563ACh */ case    5:  		/* mr R29, R5 */
		/* 822563ACh case    5:*/		regs.R29 = regs.R5;
		/* 822563ACh case    5:*/		return 0x822563B0;
		  /* 822563B0h */ case    6:  		/* cmpwi CR6, R4, 6 */
		/* 822563B0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000006);
		/* 822563B0h case    6:*/		return 0x822563B4;
		  /* 822563B4h */ case    7:  		/* bc 12, CR6_LT, 40 */
		/* 822563B4h case    7:*/		if ( regs.CR[6].lt ) { return 0x822563DC;  }
		/* 822563B4h case    7:*/		return 0x822563B8;
		  /* 822563B8h */ case    8:  		/* lis R11, -32252 */
		/* 822563B8h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822563B8h case    8:*/		return 0x822563BC;
		  /* 822563BCh */ case    9:  		/* lis R10, -32252 */
		/* 822563BCh case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 822563BCh case    9:*/		return 0x822563C0;
		  /* 822563C0h */ case   10:  		/* lis R9, -32253 */
		/* 822563C0h case   10:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 822563C0h case   10:*/		return 0x822563C4;
		  /* 822563C4h */ case   11:  		/* addi R6, R11, 28888 */
		/* 822563C4h case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x70D8);
		/* 822563C4h case   11:*/		return 0x822563C8;
		  /* 822563C8h */ case   12:  		/* addi R5, R10, 29140 */
		/* 822563C8h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x71D4);
		/* 822563C8h case   12:*/		return 0x822563CC;
		  /* 822563CCh */ case   13:  		/* addi R4, R9, 27460 */
		/* 822563CCh case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 822563CCh case   13:*/		return 0x822563D0;
		  /* 822563D0h */ case   14:  		/* li R7, 251 */
		/* 822563D0h case   14:*/		cpu::op::li<0>(regs,&regs.R7,0xFB);
		/* 822563D0h case   14:*/		return 0x822563D4;
		  /* 822563D4h */ case   15:  		/* li R3, 0 */
		/* 822563D4h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822563D4h case   15:*/		return 0x822563D8;
		  /* 822563D8h */ case   16:  		/* bl -1042384 */
		/* 822563D8h case   16:*/		regs.LR = 0x822563DC; return 0x82157C08;
		/* 822563D8h case   16:*/		return 0x822563DC;
	}
	return 0x822563DC;
} // Block from 82256398h-822563DCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 822563DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822563DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822563DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822563DC);
		  /* 822563DCh */ case    0:  		/* addi R11, R31, 20 */
		/* 822563DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x14);
		/* 822563DCh case    0:*/		return 0x822563E0;
		  /* 822563E0h */ case    1:  		/* lwz R10, <#[R29 + 32]> */
		/* 822563E0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000020) );
		/* 822563E0h case    1:*/		return 0x822563E4;
		  /* 822563E4h */ case    2:  		/* addi R9, R31, 14 */
		/* 822563E4h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0xE);
		/* 822563E4h case    2:*/		return 0x822563E8;
		  /* 822563E8h */ case    3:  		/* addi R8, R31, 7 */
		/* 822563E8h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0x7);
		/* 822563E8h case    3:*/		return 0x822563EC;
		  /* 822563ECh */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822563ECh case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822563ECh case    4:*/		return 0x822563F0;
		  /* 822563F0h */ case    5:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 822563F0h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 822563F0h case    5:*/		return 0x822563F4;
		  /* 822563F4h */ case    6:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 822563F4h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 822563F4h case    6:*/		return 0x822563F8;
		  /* 822563F8h */ case    7:  		/* stwx R10, <#[R11 + R30]> */
		/* 822563F8h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 822563F8h case    7:*/		return 0x822563FC;
		  /* 822563FCh */ case    8:  		/* lwz R11, <#[R29 + 12]> */
		/* 822563FCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 822563FCh case    8:*/		return 0x82256400;
		  /* 82256400h */ case    9:  		/* stwx R11, <#[R9 + R30]> */
		/* 82256400h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 82256400h case    9:*/		return 0x82256404;
		  /* 82256404h */ case   10:  		/* stwx R29, <#[R8 + R30]> */
		/* 82256404h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R8 + regs.R30 + 0x00000000) );
		/* 82256404h case   10:*/		return 0x82256408;
		  /* 82256408h */ case   11:  		/* addi R1, R1, 112 */
		/* 82256408h case   11:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82256408h case   11:*/		return 0x8225640C;
		  /* 8225640Ch */ case   12:  		/* b -1855840 */
		/* 8225640Ch case   12:*/		return 0x820912AC;
		/* 8225640Ch case   12:*/		return 0x82256410;
	}
	return 0x82256410;
} // Block from 822563DCh-82256410h (13 instructions)

