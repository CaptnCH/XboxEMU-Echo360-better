#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 8218B604h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B604( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B604) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B604);
		  /* 8218B604h */ case    0:  		/* bc 12, CR6_EQ, 36 */
		/* 8218B604h case    0:*/		if ( regs.CR[6].eq ) { return 0x8218B628;  }
		/* 8218B604h case    0:*/		return 0x8218B608;
		  /* 8218B608h */ case    1:  		/* cmpwi CR6, R28, 7 */
		/* 8218B608h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000007);
		/* 8218B608h case    1:*/		return 0x8218B60C;
		  /* 8218B60Ch */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8218B60Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8218B61C;  }
		/* 8218B60Ch case    2:*/		return 0x8218B610;
		  /* 8218B610h */ case    3:  		/* mr R5, R29 */
		/* 8218B610h case    3:*/		regs.R5 = regs.R29;
		/* 8218B610h case    3:*/		return 0x8218B614;
		  /* 8218B614h */ case    4:  		/* li R4, 4509 */
		/* 8218B614h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x119D);
		/* 8218B614h case    4:*/		return 0x8218B618;
		  /* 8218B618h */ case    5:  		/* bl -235440 */
		/* 8218B618h case    5:*/		regs.LR = 0x8218B61C; return 0x82151E68;
		/* 8218B618h case    5:*/		return 0x8218B61C;
	}
	return 0x8218B61C;
} // Block from 8218B604h-8218B61Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218B61Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B61C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B61C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B61C);
		  /* 8218B61Ch */ case    0:  		/* li R31, 256 */
		/* 8218B61Ch case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x100);
		/* 8218B61Ch case    0:*/		return 0x8218B620;
		  /* 8218B620h */ case    1:  		/* li R30, -1 */
		/* 8218B620h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFFFFF);
		/* 8218B620h case    1:*/		return 0x8218B624;
		  /* 8218B624h */ case    2:  		/* b 224 */
		/* 8218B624h case    2:*/		return 0x8218B704;
		/* 8218B624h case    2:*/		return 0x8218B628;
	}
	return 0x8218B628;
} // Block from 8218B61Ch-8218B628h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218B628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B628);
		  /* 8218B628h */ case    0:  		/* cmpwi CR6, R28, 3 */
		/* 8218B628h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000003);
		/* 8218B628h case    0:*/		return 0x8218B62C;
		  /* 8218B62Ch */ case    1:  		/* bc 4, CR6_EQ, 56 */
		/* 8218B62Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8218B664;  }
		/* 8218B62Ch case    1:*/		return 0x8218B630;
		  /* 8218B630h */ case    2:  		/* lbz R10, <#[R29 + 1]> */
		/* 8218B630h case    2:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000001) );
		/* 8218B630h case    2:*/		return 0x8218B634;
		  /* 8218B634h */ case    3:  		/* addi R11, R29, 1 */
		/* 8218B634h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x1);
		/* 8218B634h case    3:*/		return 0x8218B638;
		  /* 8218B638h */ case    4:  		/* extsb R10, R10 */
		/* 8218B638h case    4:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 8218B638h case    4:*/		return 0x8218B63C;
		  /* 8218B63Ch */ case    5:  		/* cmpwi CR6, R10, 102 */
		/* 8218B63Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000066);
		/* 8218B63Ch case    5:*/		return 0x8218B640;
		  /* 8218B640h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 8218B640h case    6:*/		if ( regs.CR[6].eq ) { return 0x8218B64C;  }
		/* 8218B640h case    6:*/		return 0x8218B644;
		  /* 8218B644h */ case    7:  		/* cmpwi CR6, R10, 70 */
		/* 8218B644h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000046);
		/* 8218B644h case    7:*/		return 0x8218B648;
		  /* 8218B648h */ case    8:  		/* bc 4, CR6_EQ, 28 */
		/* 8218B648h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8218B664;  }
		/* 8218B648h case    8:*/		return 0x8218B64C;
	}
	return 0x8218B64C;
} // Block from 8218B628h-8218B64Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218B64Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B64C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B64C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B64C);
		  /* 8218B64Ch */ case    0:  		/* li R10, 1 */
		/* 8218B64Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8218B64Ch case    0:*/		return 0x8218B650;
		  /* 8218B650h */ case    1:  		/* mr R29, R11 */
		/* 8218B650h case    1:*/		regs.R29 = regs.R11;
		/* 8218B650h case    1:*/		return 0x8218B654;
		  /* 8218B654h */ case    2:  		/* li R31, 0 */
		/* 8218B654h case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8218B654h case    2:*/		return 0x8218B658;
		  /* 8218B658h */ case    3:  		/* stb R10, <#[R8]> */
		/* 8218B658h case    3:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8218B658h case    3:*/		return 0x8218B65C;
		  /* 8218B65Ch */ case    4:  		/* li R30, 96 */
		/* 8218B65Ch case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x60);
		/* 8218B65Ch case    4:*/		return 0x8218B660;
		  /* 8218B660h */ case    5:  		/* b 164 */
		/* 8218B660h case    5:*/		return 0x8218B704;
		/* 8218B660h case    5:*/		return 0x8218B664;
	}
	return 0x8218B664;
} // Block from 8218B64Ch-8218B664h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218B664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B664);
		  /* 8218B664h */ case    0:  		/* mr R5, R29 */
		/* 8218B664h case    0:*/		regs.R5 = regs.R29;
		/* 8218B664h case    0:*/		return 0x8218B668;
		  /* 8218B668h */ case    1:  		/* li R4, 4509 */
		/* 8218B668h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x119D);
		/* 8218B668h case    1:*/		return 0x8218B66C;
		  /* 8218B66Ch */ case    2:  		/* bl -235524 */
		/* 8218B66Ch case    2:*/		regs.LR = 0x8218B670; return 0x82151E68;
		/* 8218B66Ch case    2:*/		return 0x8218B670;
	}
	return 0x8218B670;
} // Block from 8218B664h-8218B670h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218B670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B670);
		  /* 8218B670h */ case    0:  		/* cmpwi CR6, R28, 3 */
		/* 8218B670h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000003);
		/* 8218B670h case    0:*/		return 0x8218B674;
		  /* 8218B674h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8218B674h case    1:*/		if ( regs.CR[6].eq ) { return 0x8218B684;  }
		/* 8218B674h case    1:*/		return 0x8218B678;
		  /* 8218B678h */ case    2:  		/* mr R5, R29 */
		/* 8218B678h case    2:*/		regs.R5 = regs.R29;
		/* 8218B678h case    2:*/		return 0x8218B67C;
		  /* 8218B67Ch */ case    3:  		/* li R4, 4509 */
		/* 8218B67Ch case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x119D);
		/* 8218B67Ch case    3:*/		return 0x8218B680;
		  /* 8218B680h */ case    4:  		/* bl -235544 */
		/* 8218B680h case    4:*/		regs.LR = 0x8218B684; return 0x82151E68;
		/* 8218B680h case    4:*/		return 0x8218B684;
	}
	return 0x8218B684;
} // Block from 8218B670h-8218B684h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218B684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B684);
		  /* 8218B684h */ case    0:  		/* bl -160492 */
		/* 8218B684h case    0:*/		regs.LR = 0x8218B688; return 0x82164398;
		/* 8218B684h case    0:*/		return 0x8218B688;
		  /* 8218B688h */ case    1:  		/* mr R31, R3 */
		/* 8218B688h case    1:*/		regs.R31 = regs.R3;
		/* 8218B688h case    1:*/		return 0x8218B68C;
		  /* 8218B68Ch */ case    2:  		/* li R30, 32 */
		/* 8218B68Ch case    2:*/		cpu::op::li<0>(regs,&regs.R30,0x20);
		/* 8218B68Ch case    2:*/		return 0x8218B690;
		  /* 8218B690h */ case    3:  		/* b 116 */
		/* 8218B690h case    3:*/		return 0x8218B704;
		/* 8218B690h case    3:*/		return 0x8218B694;
	}
	return 0x8218B694;
} // Block from 8218B684h-8218B694h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218B694h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B694( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B694) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B694);
		  /* 8218B694h */ case    0:  		/* cmpwi CR6, R28, 7 */
		/* 8218B694h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000007);
		/* 8218B694h case    0:*/		return 0x8218B698;
		  /* 8218B698h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 8218B698h case    1:*/		if ( regs.CR[6].eq ) { return 0x8218B6B0;  }
		/* 8218B698h case    1:*/		return 0x8218B69C;
		  /* 8218B69Ch */ case    2:  		/* cmpwi CR6, R28, 1 */
		/* 8218B69Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000001);
		/* 8218B69Ch case    2:*/		return 0x8218B6A0;
		  /* 8218B6A0h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 8218B6A0h case    3:*/		if ( regs.CR[6].eq ) { return 0x8218B6B0;  }
		/* 8218B6A0h case    3:*/		return 0x8218B6A4;
		  /* 8218B6A4h */ case    4:  		/* mr R5, R29 */
		/* 8218B6A4h case    4:*/		regs.R5 = regs.R29;
		/* 8218B6A4h case    4:*/		return 0x8218B6A8;
		  /* 8218B6A8h */ case    5:  		/* li R4, 4509 */
		/* 8218B6A8h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x119D);
		/* 8218B6A8h case    5:*/		return 0x8218B6AC;
		  /* 8218B6ACh */ case    6:  		/* bl -235588 */
		/* 8218B6ACh case    6:*/		regs.LR = 0x8218B6B0; return 0x82151E68;
		/* 8218B6ACh case    6:*/		return 0x8218B6B0;
	}
	return 0x8218B6B0;
} // Block from 8218B694h-8218B6B0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218B6B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B6B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B6B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B6B0);
		  /* 8218B6B0h */ case    0:  		/* lwz R11, <#[R3 + 48]> */
		/* 8218B6B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 8218B6B0h case    0:*/		return 0x8218B6B4;
		  /* 8218B6B4h */ case    1:  		/* lis R10, -1 */
		/* 8218B6B4h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8218B6B4h case    1:*/		return 0x8218B6B8;
		  /* 8218B6B8h */ case    2:  		/* li R9, 16 */
		/* 8218B6B8h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 8218B6B8h case    2:*/		return 0x8218B6BC;
		  /* 8218B6BCh */ case    3:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 8218B6BCh case    3:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 8218B6BCh case    3:*/		return 0x8218B6C0;
		  /* 8218B6C0h */ case    4:  		/* li R28, 1 */
		/* 8218B6C0h case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 8218B6C0h case    4:*/		return 0x8218B6C4;
		  /* 8218B6C4h */ case    5:  		/* subf R11, R10, R11 */
		/* 8218B6C4h case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218B6C4h case    5:*/		return 0x8218B6C8;
	}
	return 0x8218B6C8;
} // Block from 8218B6B0h-8218B6C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218B6C8h
// Function '?GlobalRegisterAllocation@Compiler@D3DXShader@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B6C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B6C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B6C8);
		  /* 8218B6C8h */ case    0:  		/* li R30, 32 */
		/* 8218B6C8h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x20);
		/* 8218B6C8h case    0:*/		return 0x8218B6CC;
		  /* 8218B6CCh */ case    1:  		/* addic R11, R11, -1 */
		/* 8218B6CCh case    1:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8218B6CCh case    1:*/		return 0x8218B6D0;
		  /* 8218B6D0h */ case    2:  		/* subfe R11, R11, R11 */
		/* 8218B6D0h case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8218B6D0h case    2:*/		return 0x8218B6D4;
		  /* 8218B6D4h */ case    3:  		/* and R31, R11, R9 */
		/* 8218B6D4h case    3:*/		cpu::op::and<0>(regs,&regs.R31,regs.R11,regs.R9);
		/* 8218B6D4h case    3:*/		return 0x8218B6D8;
		  /* 8218B6D8h */ case    4:  		/* b 44 */
		/* 8218B6D8h case    4:*/		return 0x8218B704;
		/* 8218B6D8h case    4:*/		return 0x8218B6DC;
	}
	return 0x8218B6DC;
} // Block from 8218B6C8h-8218B6DCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218B6DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B6DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B6DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B6DC);
		  /* 8218B6DCh */ case    0:  		/* cmpwi CR6, R28, 7 */
		/* 8218B6DCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000007);
		/* 8218B6DCh case    0:*/		return 0x8218B6E0;
		  /* 8218B6E0h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 8218B6E0h case    1:*/		if ( regs.CR[6].eq ) { return 0x8218B6F8;  }
		/* 8218B6E0h case    1:*/		return 0x8218B6E4;
		  /* 8218B6E4h */ case    2:  		/* cmpwi CR6, R28, 2 */
		/* 8218B6E4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000002);
		/* 8218B6E4h case    2:*/		return 0x8218B6E8;
		  /* 8218B6E8h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 8218B6E8h case    3:*/		if ( regs.CR[6].eq ) { return 0x8218B6F8;  }
		/* 8218B6E8h case    3:*/		return 0x8218B6EC;
		  /* 8218B6ECh */ case    4:  		/* mr R5, R29 */
		/* 8218B6ECh case    4:*/		regs.R5 = regs.R29;
		/* 8218B6ECh case    4:*/		return 0x8218B6F0;
		  /* 8218B6F0h */ case    5:  		/* li R4, 4509 */
		/* 8218B6F0h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x119D);
		/* 8218B6F0h case    5:*/		return 0x8218B6F4;
		  /* 8218B6F4h */ case    6:  		/* bl -235660 */
		/* 8218B6F4h case    6:*/		regs.LR = 0x8218B6F8; return 0x82151E68;
		/* 8218B6F4h case    6:*/		return 0x8218B6F8;
	}
	return 0x8218B6F8;
} // Block from 8218B6DCh-8218B6F8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218B6F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B6F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B6F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B6F8);
		  /* 8218B6F8h */ case    0:  		/* li R28, 2 */
		/* 8218B6F8h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x2);
		/* 8218B6F8h case    0:*/		return 0x8218B6FC;
		  /* 8218B6FCh */ case    1:  		/* li R31, 0 */
		/* 8218B6FCh case    1:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8218B6FCh case    1:*/		return 0x8218B700;
	}
	return 0x8218B700;
} // Block from 8218B6F8h-8218B700h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218B700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B700);
		  /* 8218B700h */ case    0:  		/* li R30, 256 */
		/* 8218B700h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x100);
		/* 8218B700h case    0:*/		return 0x8218B704;
	}
	return 0x8218B704;
} // Block from 8218B700h-8218B704h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218B704h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B704( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B704) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B704);
		  /* 8218B704h */ case    0:  		/* li R5, 10 */
		/* 8218B704h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0xA);
		/* 8218B704h case    0:*/		return 0x8218B708;
		  /* 8218B708h */ case    1:  		/* addi R4, R1, 80 */
		/* 8218B708h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8218B708h case    1:*/		return 0x8218B70C;
		  /* 8218B70Ch */ case    2:  		/* addi R3, R29, 1 */
		/* 8218B70Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R29,0x1);
		/* 8218B70Ch case    2:*/		return 0x8218B710;
		  /* 8218B710h */ case    3:  		/* bl -996128 */
		/* 8218B710h case    3:*/		regs.LR = 0x8218B714; return 0x820983F0;
		/* 8218B710h case    3:*/		return 0x8218B714;
		  /* 8218B714h */ case    4:  		/* lwz R11, <#[R1 + 80]> */
		/* 8218B714h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8218B714h case    4:*/		return 0x8218B718;
		  /* 8218B718h */ case    5:  		/* lbz R11, <#[R11]> */
		/* 8218B718h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8218B718h case    5:*/		return 0x8218B71C;
		  /* 8218B71Ch */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 8218B71Ch case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8218B71Ch case    6:*/		return 0x8218B720;
		  /* 8218B720h */ case    7:  		/* bc 12, CR0_EQ, 8 */
		/* 8218B720h case    7:*/		if ( regs.CR[0].eq ) { return 0x8218B728;  }
		/* 8218B720h case    7:*/		return 0x8218B724;
		  /* 8218B724h */ case    8:  		/* li R31, 256 */
		/* 8218B724h case    8:*/		cpu::op::li<0>(regs,&regs.R31,0x100);
		/* 8218B724h case    8:*/		return 0x8218B728;
	}
	return 0x8218B728;
} // Block from 8218B704h-8218B728h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218B728h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B728);
		  /* 8218B728h */ case    0:  		/* add R11, R3, R31 */
		/* 8218B728h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R31);
		/* 8218B728h case    0:*/		return 0x8218B72C;
		  /* 8218B72Ch */ case    1:  		/* cmplw CR6, R11, R30 */
		/* 8218B72Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 8218B72Ch case    1:*/		return 0x8218B730;
		  /* 8218B730h */ case    2:  		/* bc 12, CR6_LT, 8 */
		/* 8218B730h case    2:*/		if ( regs.CR[6].lt ) { return 0x8218B738;  }
		/* 8218B730h case    2:*/		return 0x8218B734;
		  /* 8218B734h */ case    3:  		/* li R31, 256 */
		/* 8218B734h case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x100);
		/* 8218B734h case    3:*/		return 0x8218B738;
	}
	return 0x8218B738;
} // Block from 8218B728h-8218B738h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218B738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B738);
		  /* 8218B738h */ case    0:  		/* add R11, R3, R31 */
		/* 8218B738h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R31);
		/* 8218B738h case    0:*/		return 0x8218B73C;
		  /* 8218B73Ch */ case    1:  		/* cmplwi CR6, R11, 255 */
		/* 8218B73Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000FF);
		/* 8218B73Ch case    1:*/		return 0x8218B740;
		  /* 8218B740h */ case    2:  		/* bc 4, CR6_GT, 8 */
		/* 8218B740h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8218B748;  }
		/* 8218B740h case    2:*/		return 0x8218B744;
		  /* 8218B744h */ case    3:  		/* li R11, 256 */
		/* 8218B744h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x100);
		/* 8218B744h case    3:*/		return 0x8218B748;
	}
	return 0x8218B748;
} // Block from 8218B738h-8218B748h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218B748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B748);
		  /* 8218B748h */ case    0:  		/* stw R11, <#[R27]> */
		/* 8218B748h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8218B748h case    0:*/		return 0x8218B74C;
		  /* 8218B74Ch */ case    1:  		/* stw R28, <#[R26]> */
		/* 8218B74Ch case    1:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R26 + 0x00000000) );
		/* 8218B74Ch case    1:*/		return 0x8218B750;
		  /* 8218B750h */ case    2:  		/* addi R1, R1, 144 */
		/* 8218B750h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8218B750h case    2:*/		return 0x8218B754;
		  /* 8218B754h */ case    3:  		/* b -1025204 */
		/* 8218B754h case    3:*/		return 0x820912A0;
		/* 8218B754h case    3:*/		return 0x8218B758;
		  /* 8218B758h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 8218B758h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8218B758h case    4:*/		return 0x8218B75C;
		  /* 8218B75Ch */ case    5:  		/* lwz R10, <#[R4]> */
		/* 8218B75Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 8218B75Ch case    5:*/		return 0x8218B760;
		  /* 8218B760h */ case    6:  		/* lwz R11, <#[R11 + 8]> */
		/* 8218B760h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8218B760h case    6:*/		return 0x8218B764;
		  /* 8218B764h */ case    7:  		/* lwz R10, <#[R10 + 8]> */
		/* 8218B764h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8218B764h case    7:*/		return 0x8218B768;
		  /* 8218B768h */ case    8:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 8218B768h case    8:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 8218B768h case    8:*/		return 0x8218B76C;
		  /* 8218B76Ch */ case    9:  		/* rlwinm R10, R10, 18, 29, 31 */
		/* 8218B76Ch case    9:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R10,regs.R10);
		/* 8218B76Ch case    9:*/		return 0x8218B770;
		  /* 8218B770h */ case   10:  		/* subf R3, R11, R10 */
		/* 8218B770h case   10:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 8218B770h case   10:*/		return 0x8218B774;
		  /* 8218B774h */ case   11:  		/* bclr 20, CR0_LT */
		/* 8218B774h case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218B774h case   11:*/		return 0x8218B778;
	}
	return 0x8218B778;
} // Block from 8218B748h-8218B778h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8218B778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B778);
		  /* 8218B778h */ case    0:  		/* rldicl R10, R4, 0, 58 */
		/* 8218B778h case    0:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R10,regs.R4);
		/* 8218B778h case    0:*/		return 0x8218B77C;
		  /* 8218B77Ch */ case    1:  		/* rlwinm R11, R4, 26, 6, 31 */
		/* 8218B77Ch case    1:*/		cpu::op::rlwinm<0,26,6,31>(regs,&regs.R11,regs.R4);
		/* 8218B77Ch case    1:*/		return 0x8218B780;
		  /* 8218B780h */ case    2:  		/* li R9, -1 */
		/* 8218B780h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 8218B780h case    2:*/		return 0x8218B784;
		  /* 8218B784h */ case    3:  		/* cmplwi CR6, R11, 16 */
		/* 8218B784h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 8218B784h case    3:*/		return 0x8218B788;
		  /* 8218B788h */ case    4:  		/* sld R9, R9, R10 */
		/* 8218B788h case    4:*/		cpu::op::sld<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 8218B788h case    4:*/		return 0x8218B78C;
		  /* 8218B78Ch */ case    5:  		/* bc 4, CR6_LT, 48 */
		/* 8218B78Ch case    5:*/		if ( !regs.CR[6].lt ) { return 0x8218B7BC;  }
		/* 8218B78Ch case    5:*/		return 0x8218B790;
		  /* 8218B790h */ case    6:  		/* rlwinm R10, R11, 3, 0, 28 */
		/* 8218B790h case    6:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R11);
		/* 8218B790h case    6:*/		return 0x8218B794;
		  /* 8218B794h */ case    7:  		/* add R10, R10, R3 */
		/* 8218B794h case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 8218B794h case    7:*/		return 0x8218B798;
		  /* 8218B798h */ case    8:  		/* ld R8, <#[R10]> */
		/* 8218B798h case    8:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8218B798h case    8:*/		return 0x8218B79C;
		  /* 8218B79Ch */ case    9:  		/* and R9, R8, R9 */
		/* 8218B79Ch case    9:*/		cpu::op::and<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8218B79Ch case    9:*/		return 0x8218B7A0;
		  /* 8218B7A0h */ case   10:  		/* cmpldi CR6, R9, 0 */
		/* 8218B7A0h case   10:*/		cpu::op::cmpldi<6>(regs,regs.R9,0x00000000);
		/* 8218B7A0h case   10:*/		return 0x8218B7A4;
		  /* 8218B7A4h */ case   11:  		/* bc 4, CR6_EQ, 32 */
		/* 8218B7A4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8218B7C4;  }
		/* 8218B7A4h case   11:*/		return 0x8218B7A8;
		  /* 8218B7A8h */ case   12:  		/* addi R11, R11, 1 */
		/* 8218B7A8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218B7A8h case   12:*/		return 0x8218B7AC;
		  /* 8218B7ACh */ case   13:  		/* li R9, -1 */
		/* 8218B7ACh case   13:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 8218B7ACh case   13:*/		return 0x8218B7B0;
		  /* 8218B7B0h */ case   14:  		/* addi R10, R10, 8 */
		/* 8218B7B0h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8);
		/* 8218B7B0h case   14:*/		return 0x8218B7B4;
		  /* 8218B7B4h */ case   15:  		/* cmplwi CR6, R11, 16 */
		/* 8218B7B4h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 8218B7B4h case   15:*/		return 0x8218B7B8;
		  /* 8218B7B8h */ case   16:  		/* bc 12, CR6_LT, -32 */
		/* 8218B7B8h case   16:*/		if ( regs.CR[6].lt ) { return 0x8218B798;  }
		/* 8218B7B8h case   16:*/		return 0x8218B7BC;
	}
	return 0x8218B7BC;
} // Block from 8218B778h-8218B7BCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 8218B7BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B7BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B7BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B7BC);
		  /* 8218B7BCh */ case    0:  		/* li R3, -1 */
		/* 8218B7BCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8218B7BCh case    0:*/		return 0x8218B7C0;
		  /* 8218B7C0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8218B7C0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218B7C0h case    1:*/		return 0x8218B7C4;
	}
	return 0x8218B7C4;
} // Block from 8218B7BCh-8218B7C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218B7C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B7C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B7C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B7C4);
		  /* 8218B7C4h */ case    0:  		/* addi R10, R9, -1 */
		/* 8218B7C4h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFFFFF);
		/* 8218B7C4h case    0:*/		return 0x8218B7C8;
		  /* 8218B7C8h */ case    1:  		/* rlwinm R11, R11, 6, 0, 25 */
		/* 8218B7C8h case    1:*/		cpu::op::rlwinm<0,6,0,25>(regs,&regs.R11,regs.R11);
		/* 8218B7C8h case    1:*/		return 0x8218B7CC;
		  /* 8218B7CCh */ case    2:  		/* andc R10, R9, R10 */
		/* 8218B7CCh case    2:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8218B7CCh case    2:*/		return 0x8218B7D0;
		  /* 8218B7D0h */ case    3:  		/* cntlzd R10, R10 */
		/* 8218B7D0h case    3:*/		cpu::op::cntlzd<0>(regs,&regs.R10,regs.R10);
		/* 8218B7D0h case    3:*/		return 0x8218B7D4;
		  /* 8218B7D4h */ case    4:  		/* subf R11, R10, R11 */
		/* 8218B7D4h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218B7D4h case    4:*/		return 0x8218B7D8;
		  /* 8218B7D8h */ case    5:  		/* addi R3, R11, 63 */
		/* 8218B7D8h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x3F);
		/* 8218B7D8h case    5:*/		return 0x8218B7DC;
		  /* 8218B7DCh */ case    6:  		/* bclr 20, CR0_LT */
		/* 8218B7DCh case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218B7DCh case    6:*/		return 0x8218B7E0;
	}
	return 0x8218B7E0;
} // Block from 8218B7C4h-8218B7E0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218B7E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B7E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B7E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B7E0);
		  /* 8218B7E0h */ case    0:  		/* rldicl R10, R4, 0, 58 */
		/* 8218B7E0h case    0:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R10,regs.R4);
		/* 8218B7E0h case    0:*/		return 0x8218B7E4;
		  /* 8218B7E4h */ case    1:  		/* rlwinm R11, R4, 26, 6, 31 */
		/* 8218B7E4h case    1:*/		cpu::op::rlwinm<0,26,6,31>(regs,&regs.R11,regs.R4);
		/* 8218B7E4h case    1:*/		return 0x8218B7E8;
		  /* 8218B7E8h */ case    2:  		/* li R9, -1 */
		/* 8218B7E8h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 8218B7E8h case    2:*/		return 0x8218B7EC;
		  /* 8218B7ECh */ case    3:  		/* cmplwi CR6, R11, 16 */
		/* 8218B7ECh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 8218B7ECh case    3:*/		return 0x8218B7F0;
		  /* 8218B7F0h */ case    4:  		/* sld R9, R9, R10 */
		/* 8218B7F0h case    4:*/		cpu::op::sld<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 8218B7F0h case    4:*/		return 0x8218B7F4;
		  /* 8218B7F4h */ case    5:  		/* bc 4, CR6_LT, 48 */
		/* 8218B7F4h case    5:*/		if ( !regs.CR[6].lt ) { return 0x8218B824;  }
		/* 8218B7F4h case    5:*/		return 0x8218B7F8;
		  /* 8218B7F8h */ case    6:  		/* rlwinm R10, R11, 3, 0, 28 */
		/* 8218B7F8h case    6:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R11);
		/* 8218B7F8h case    6:*/		return 0x8218B7FC;
		  /* 8218B7FCh */ case    7:  		/* add R10, R10, R3 */
		/* 8218B7FCh case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 8218B7FCh case    7:*/		return 0x8218B800;
		  /* 8218B800h */ case    8:  		/* ld R8, <#[R10]> */
		/* 8218B800h case    8:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8218B800h case    8:*/		return 0x8218B804;
		  /* 8218B804h */ case    9:  		/* andc R9, R9, R8 */
		/* 8218B804h case    9:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8218B804h case    9:*/		return 0x8218B808;
		  /* 8218B808h */ case   10:  		/* cmpldi CR6, R9, 0 */
		/* 8218B808h case   10:*/		cpu::op::cmpldi<6>(regs,regs.R9,0x00000000);
		/* 8218B808h case   10:*/		return 0x8218B80C;
		  /* 8218B80Ch */ case   11:  		/* bc 4, CR6_EQ, 32 */
		/* 8218B80Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x8218B82C;  }
		/* 8218B80Ch case   11:*/		return 0x8218B810;
		  /* 8218B810h */ case   12:  		/* addi R11, R11, 1 */
		/* 8218B810h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218B810h case   12:*/		return 0x8218B814;
		  /* 8218B814h */ case   13:  		/* li R9, -1 */
		/* 8218B814h case   13:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 8218B814h case   13:*/		return 0x8218B818;
		  /* 8218B818h */ case   14:  		/* addi R10, R10, 8 */
		/* 8218B818h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8);
		/* 8218B818h case   14:*/		return 0x8218B81C;
		  /* 8218B81Ch */ case   15:  		/* cmplwi CR6, R11, 16 */
		/* 8218B81Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 8218B81Ch case   15:*/		return 0x8218B820;
		  /* 8218B820h */ case   16:  		/* bc 12, CR6_LT, -32 */
		/* 8218B820h case   16:*/		if ( regs.CR[6].lt ) { return 0x8218B800;  }
		/* 8218B820h case   16:*/		return 0x8218B824;
	}
	return 0x8218B824;
} // Block from 8218B7E0h-8218B824h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8218B824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B824);
		  /* 8218B824h */ case    0:  		/* li R3, -1 */
		/* 8218B824h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8218B824h case    0:*/		return 0x8218B828;
		  /* 8218B828h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8218B828h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218B828h case    1:*/		return 0x8218B82C;
	}
	return 0x8218B82C;
} // Block from 8218B824h-8218B82Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218B82Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B82C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B82C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B82C);
		  /* 8218B82Ch */ case    0:  		/* addi R10, R9, -1 */
		/* 8218B82Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFFFFF);
		/* 8218B82Ch case    0:*/		return 0x8218B830;
		  /* 8218B830h */ case    1:  		/* rlwinm R11, R11, 6, 0, 25 */
		/* 8218B830h case    1:*/		cpu::op::rlwinm<0,6,0,25>(regs,&regs.R11,regs.R11);
		/* 8218B830h case    1:*/		return 0x8218B834;
		  /* 8218B834h */ case    2:  		/* andc R10, R9, R10 */
		/* 8218B834h case    2:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8218B834h case    2:*/		return 0x8218B838;
		  /* 8218B838h */ case    3:  		/* cntlzd R10, R10 */
		/* 8218B838h case    3:*/		cpu::op::cntlzd<0>(regs,&regs.R10,regs.R10);
		/* 8218B838h case    3:*/		return 0x8218B83C;
		  /* 8218B83Ch */ case    4:  		/* subf R11, R10, R11 */
		/* 8218B83Ch case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218B83Ch case    4:*/		return 0x8218B840;
		  /* 8218B840h */ case    5:  		/* addi R3, R11, 63 */
		/* 8218B840h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x3F);
		/* 8218B840h case    5:*/		return 0x8218B844;
		  /* 8218B844h */ case    6:  		/* bclr 20, CR0_LT */
		/* 8218B844h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218B844h case    6:*/		return 0x8218B848;
	}
	return 0x8218B848;
} // Block from 8218B82Ch-8218B848h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218B848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B848);
		  /* 8218B848h */ case    0:  		/* rldicl R10, R4, 0, 58 */
		/* 8218B848h case    0:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R10,regs.R4);
		/* 8218B848h case    0:*/		return 0x8218B84C;
		  /* 8218B84Ch */ case    1:  		/* rlwinm R11, R4, 26, 6, 31 */
		/* 8218B84Ch case    1:*/		cpu::op::rlwinm<0,26,6,31>(regs,&regs.R11,regs.R4);
		/* 8218B84Ch case    1:*/		return 0x8218B850;
		  /* 8218B850h */ case    2:  		/* li R9, -1 */
		/* 8218B850h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 8218B850h case    2:*/		return 0x8218B854;
		  /* 8218B854h */ case    3:  		/* cmplwi CR6, R11, 16 */
		/* 8218B854h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 8218B854h case    3:*/		return 0x8218B858;
		  /* 8218B858h */ case    4:  		/* sld R10, R9, R10 */
		/* 8218B858h case    4:*/		cpu::op::sld<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8218B858h case    4:*/		return 0x8218B85C;
		  /* 8218B85Ch */ case    5:  		/* bc 4, CR6_LT, 48 */
		/* 8218B85Ch case    5:*/		if ( !regs.CR[6].lt ) { return 0x8218B88C;  }
		/* 8218B85Ch case    5:*/		return 0x8218B860;
		  /* 8218B860h */ case    6:  		/* rlwinm R9, R11, 3, 0, 28 */
		/* 8218B860h case    6:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R11);
		/* 8218B860h case    6:*/		return 0x8218B864;
		  /* 8218B864h */ case    7:  		/* add R9, R9, R3 */
		/* 8218B864h case    7:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R3);
		/* 8218B864h case    7:*/		return 0x8218B868;
		  /* 8218B868h */ case    8:  		/* ld R8, <#[R9]> */
		/* 8218B868h case    8:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 8218B868h case    8:*/		return 0x8218B86C;
		  /* 8218B86Ch */ case    9:  		/* andc R10, R10, R8 */
		/* 8218B86Ch case    9:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8218B86Ch case    9:*/		return 0x8218B870;
		  /* 8218B870h */ case   10:  		/* cmpldi CR6, R10, 0 */
		/* 8218B870h case   10:*/		cpu::op::cmpldi<6>(regs,regs.R10,0x00000000);
		/* 8218B870h case   10:*/		return 0x8218B874;
		  /* 8218B874h */ case   11:  		/* bc 4, CR6_EQ, 32 */
		/* 8218B874h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8218B894;  }
		/* 8218B874h case   11:*/		return 0x8218B878;
		  /* 8218B878h */ case   12:  		/* addi R11, R11, 1 */
		/* 8218B878h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218B878h case   12:*/		return 0x8218B87C;
		  /* 8218B87Ch */ case   13:  		/* li R10, -1 */
		/* 8218B87Ch case   13:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8218B87Ch case   13:*/		return 0x8218B880;
		  /* 8218B880h */ case   14:  		/* addi R9, R9, 8 */
		/* 8218B880h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x8);
		/* 8218B880h case   14:*/		return 0x8218B884;
		  /* 8218B884h */ case   15:  		/* cmplwi CR6, R11, 16 */
		/* 8218B884h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 8218B884h case   15:*/		return 0x8218B888;
		  /* 8218B888h */ case   16:  		/* bc 12, CR6_LT, -32 */
		/* 8218B888h case   16:*/		if ( regs.CR[6].lt ) { return 0x8218B868;  }
		/* 8218B888h case   16:*/		return 0x8218B88C;
	}
	return 0x8218B88C;
} // Block from 8218B848h-8218B88Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8218B88Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B88C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B88C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B88C);
		  /* 8218B88Ch */ case    0:  		/* li R3, -1 */
		/* 8218B88Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8218B88Ch case    0:*/		return 0x8218B890;
		  /* 8218B890h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8218B890h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218B890h case    1:*/		return 0x8218B894;
	}
	return 0x8218B894;
} // Block from 8218B88Ch-8218B894h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218B894h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B894( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B894) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B894);
		  /* 8218B894h */ case    0:  		/* addi R7, R10, -1 */
		/* 8218B894h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFFFFF);
		/* 8218B894h case    0:*/		return 0x8218B898;
		  /* 8218B898h */ case    1:  		/* rlwinm R9, R11, 6, 0, 25 */
		/* 8218B898h case    1:*/		cpu::op::rlwinm<0,6,0,25>(regs,&regs.R9,regs.R11);
		/* 8218B898h case    1:*/		return 0x8218B89C;
		  /* 8218B89Ch */ case    2:  		/* andc R11, R10, R7 */
		/* 8218B89Ch case    2:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R10,regs.R7);
		/* 8218B89Ch case    2:*/		return 0x8218B8A0;
		  /* 8218B8A0h */ case    3:  		/* cntlzd R11, R11 */
		/* 8218B8A0h case    3:*/		cpu::op::cntlzd<0>(regs,&regs.R11,regs.R11);
		/* 8218B8A0h case    3:*/		return 0x8218B8A4;
		  /* 8218B8A4h */ case    4:  		/* subfic R11, R11, 63 */
		/* 8218B8A4h case    4:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x3F);
		/* 8218B8A4h case    4:*/		return 0x8218B8A8;
		  /* 8218B8A8h */ case    5:  		/* rlwinm R10, R11, 0, 0, 29 */
		/* 8218B8A8h case    5:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R10,regs.R11);
		/* 8218B8A8h case    5:*/		return 0x8218B8AC;
		  /* 8218B8ACh */ case    6:  		/* add R3, R9, R11 */
		/* 8218B8ACh case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R9,regs.R11);
		/* 8218B8ACh case    6:*/		return 0x8218B8B0;
		  /* 8218B8B0h */ case    7:  		/* srd R11, R8, R10 */
		/* 8218B8B0h case    7:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R8,regs.R10);
		/* 8218B8B0h case    7:*/		return 0x8218B8B4;
		  /* 8218B8B4h */ case    8:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 8218B8B4h case    8:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 8218B8B4h case    8:*/		return 0x8218B8B8;
		  /* 8218B8B8h */ case    9:  		/* stw R11, <#[R5]> */
		/* 8218B8B8h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8218B8B8h case    9:*/		return 0x8218B8BC;
		  /* 8218B8BCh */ case   10:  		/* bclr 20, CR0_LT */
		/* 8218B8BCh case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218B8BCh case   10:*/		return 0x8218B8C0;
	}
	return 0x8218B8C0;
} // Block from 8218B894h-8218B8C0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8218B8C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B8C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B8C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B8C0);
		  /* 8218B8C0h */ case    0:  		/* rldicl R10, R4, 0, 58 */
		/* 8218B8C0h case    0:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R10,regs.R4);
		/* 8218B8C0h case    0:*/		return 0x8218B8C4;
		  /* 8218B8C4h */ case    1:  		/* rlwinm R11, R4, 26, 6, 31 */
		/* 8218B8C4h case    1:*/		cpu::op::rlwinm<0,26,6,31>(regs,&regs.R11,regs.R4);
		/* 8218B8C4h case    1:*/		return 0x8218B8C8;
		  /* 8218B8C8h */ case    2:  		/* li R9, -1 */
		/* 8218B8C8h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 8218B8C8h case    2:*/		return 0x8218B8CC;
		  /* 8218B8CCh */ case    3:  		/* cmplwi CR6, R11, 4 */
		/* 8218B8CCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 8218B8CCh case    3:*/		return 0x8218B8D0;
		  /* 8218B8D0h */ case    4:  		/* sld R9, R9, R10 */
		/* 8218B8D0h case    4:*/		cpu::op::sld<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 8218B8D0h case    4:*/		return 0x8218B8D4;
		  /* 8218B8D4h */ case    5:  		/* bc 4, CR6_LT, 48 */
		/* 8218B8D4h case    5:*/		if ( !regs.CR[6].lt ) { return 0x8218B904;  }
		/* 8218B8D4h case    5:*/		return 0x8218B8D8;
		  /* 8218B8D8h */ case    6:  		/* rlwinm R10, R11, 3, 0, 28 */
		/* 8218B8D8h case    6:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R11);
		/* 8218B8D8h case    6:*/		return 0x8218B8DC;
		  /* 8218B8DCh */ case    7:  		/* add R10, R10, R3 */
		/* 8218B8DCh case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 8218B8DCh case    7:*/		return 0x8218B8E0;
		  /* 8218B8E0h */ case    8:  		/* ld R8, <#[R10]> */
		/* 8218B8E0h case    8:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8218B8E0h case    8:*/		return 0x8218B8E4;
		  /* 8218B8E4h */ case    9:  		/* andc R9, R9, R8 */
		/* 8218B8E4h case    9:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8218B8E4h case    9:*/		return 0x8218B8E8;
		  /* 8218B8E8h */ case   10:  		/* cmpldi CR6, R9, 0 */
		/* 8218B8E8h case   10:*/		cpu::op::cmpldi<6>(regs,regs.R9,0x00000000);
		/* 8218B8E8h case   10:*/		return 0x8218B8EC;
		  /* 8218B8ECh */ case   11:  		/* bc 4, CR6_EQ, 32 */
		/* 8218B8ECh case   11:*/		if ( !regs.CR[6].eq ) { return 0x8218B90C;  }
		/* 8218B8ECh case   11:*/		return 0x8218B8F0;
		  /* 8218B8F0h */ case   12:  		/* addi R11, R11, 1 */
		/* 8218B8F0h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218B8F0h case   12:*/		return 0x8218B8F4;
		  /* 8218B8F4h */ case   13:  		/* li R9, -1 */
		/* 8218B8F4h case   13:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 8218B8F4h case   13:*/		return 0x8218B8F8;
		  /* 8218B8F8h */ case   14:  		/* addi R10, R10, 8 */
		/* 8218B8F8h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8);
		/* 8218B8F8h case   14:*/		return 0x8218B8FC;
		  /* 8218B8FCh */ case   15:  		/* cmplwi CR6, R11, 4 */
		/* 8218B8FCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 8218B8FCh case   15:*/		return 0x8218B900;
		  /* 8218B900h */ case   16:  		/* bc 12, CR6_LT, -32 */
		/* 8218B900h case   16:*/		if ( regs.CR[6].lt ) { return 0x8218B8E0;  }
		/* 8218B900h case   16:*/		return 0x8218B904;
	}
	return 0x8218B904;
} // Block from 8218B8C0h-8218B904h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8218B904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B904);
		  /* 8218B904h */ case    0:  		/* li R3, -1 */
		/* 8218B904h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8218B904h case    0:*/		return 0x8218B908;
		  /* 8218B908h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8218B908h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218B908h case    1:*/		return 0x8218B90C;
	}
	return 0x8218B90C;
} // Block from 8218B904h-8218B90Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218B90Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B90C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B90C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B90C);
		  /* 8218B90Ch */ case    0:  		/* addi R10, R9, -1 */
		/* 8218B90Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFFFFF);
		/* 8218B90Ch case    0:*/		return 0x8218B910;
		  /* 8218B910h */ case    1:  		/* rlwinm R11, R11, 6, 0, 25 */
		/* 8218B910h case    1:*/		cpu::op::rlwinm<0,6,0,25>(regs,&regs.R11,regs.R11);
		/* 8218B910h case    1:*/		return 0x8218B914;
		  /* 8218B914h */ case    2:  		/* andc R10, R9, R10 */
		/* 8218B914h case    2:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8218B914h case    2:*/		return 0x8218B918;
		  /* 8218B918h */ case    3:  		/* cntlzd R10, R10 */
		/* 8218B918h case    3:*/		cpu::op::cntlzd<0>(regs,&regs.R10,regs.R10);
		/* 8218B918h case    3:*/		return 0x8218B91C;
		  /* 8218B91Ch */ case    4:  		/* subf R11, R10, R11 */
		/* 8218B91Ch case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218B91Ch case    4:*/		return 0x8218B920;
		  /* 8218B920h */ case    5:  		/* addi R3, R11, 63 */
		/* 8218B920h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x3F);
		/* 8218B920h case    5:*/		return 0x8218B924;
		  /* 8218B924h */ case    6:  		/* bclr 20, CR0_LT */
		/* 8218B924h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218B924h case    6:*/		return 0x8218B928;
	}
	return 0x8218B928;
} // Block from 8218B90Ch-8218B928h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218B928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B928);
		  /* 8218B928h */ case    0:  		/* mr R10, R3 */
		/* 8218B928h case    0:*/		regs.R10 = regs.R3;
		/* 8218B928h case    0:*/		return 0x8218B92C;
		  /* 8218B92Ch */ case    1:  		/* li R3, -1 */
		/* 8218B92Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8218B92Ch case    1:*/		return 0x8218B930;
		  /* 8218B930h */ case    2:  		/* rlwinm R9, R4, 0, 27, 31 */
		/* 8218B930h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R4);
		/* 8218B930h case    2:*/		return 0x8218B934;
		  /* 8218B934h */ case    3:  		/* rlwinm R11, R4, 27, 5, 31 */
		/* 8218B934h case    3:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R4);
		/* 8218B934h case    3:*/		return 0x8218B938;
		  /* 8218B938h */ case    4:  		/* slw R8, R3, R9 */
		/* 8218B938h case    4:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R3,regs.R9);
		/* 8218B938h case    4:*/		return 0x8218B93C;
		  /* 8218B93Ch */ case    5:  		/* cmplwi CR6, R11, 1 */
		/* 8218B93Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8218B93Ch case    5:*/		return 0x8218B940;
		  /* 8218B940h */ case    6:  		/* bclr 4, CR6_LT */
		/* 8218B940h case    6:*/		if ( !regs.CR[6].lt ) { return (uint32)regs.LR; }
		/* 8218B940h case    6:*/		return 0x8218B944;
	}
	return 0x8218B944;
} // Block from 8218B928h-8218B944h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218B944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B944);
		  /* 8218B944h */ case    0:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8218B944h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8218B944h case    0:*/		return 0x8218B948;
		  /* 8218B948h */ case    1:  		/* add R10, R9, R10 */
		/* 8218B948h case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8218B948h case    1:*/		return 0x8218B94C;
		  /* 8218B94Ch */ case    2:  		/* lwz R9, <#[R10]> */
		/* 8218B94Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8218B94Ch case    2:*/		return 0x8218B950;
		  /* 8218B950h */ case    3:  		/* andc. R9, R8, R9 */
		/* 8218B950h case    3:*/		cpu::op::andc<1>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8218B950h case    3:*/		return 0x8218B954;
		  /* 8218B954h */ case    4:  		/* bc 4, CR0_EQ, 28 */
		/* 8218B954h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8218B970;  }
		/* 8218B954h case    4:*/		return 0x8218B958;
		  /* 8218B958h */ case    5:  		/* addi R11, R11, 1 */
		/* 8218B958h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218B958h case    5:*/		return 0x8218B95C;
		  /* 8218B95Ch */ case    6:  		/* mr R8, R3 */
		/* 8218B95Ch case    6:*/		regs.R8 = regs.R3;
		/* 8218B95Ch case    6:*/		return 0x8218B960;
		  /* 8218B960h */ case    7:  		/* addi R10, R10, 4 */
		/* 8218B960h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8218B960h case    7:*/		return 0x8218B964;
		  /* 8218B964h */ case    8:  		/* cmplwi CR6, R11, 1 */
		/* 8218B964h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8218B964h case    8:*/		return 0x8218B968;
		  /* 8218B968h */ case    9:  		/* bc 12, CR6_LT, -28 */
		/* 8218B968h case    9:*/		if ( regs.CR[6].lt ) { return 0x8218B94C;  }
		/* 8218B968h case    9:*/		return 0x8218B96C;
		  /* 8218B96Ch */ case   10:  		/* bclr 20, CR0_LT */
		/* 8218B96Ch case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218B96Ch case   10:*/		return 0x8218B970;
	}
	return 0x8218B970;
} // Block from 8218B944h-8218B970h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8218B970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B970);
		  /* 8218B970h */ case    0:  		/* addi R10, R9, -1 */
		/* 8218B970h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFFFFF);
		/* 8218B970h case    0:*/		return 0x8218B974;
		  /* 8218B974h */ case    1:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 8218B974h case    1:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 8218B974h case    1:*/		return 0x8218B978;
		  /* 8218B978h */ case    2:  		/* andc R10, R9, R10 */
		/* 8218B978h case    2:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8218B978h case    2:*/		return 0x8218B97C;
		  /* 8218B97Ch */ case    3:  		/* cntlzw R10, R10 */
		/* 8218B97Ch case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 8218B97Ch case    3:*/		return 0x8218B980;
		  /* 8218B980h */ case    4:  		/* subf R11, R10, R11 */
		/* 8218B980h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218B980h case    4:*/		return 0x8218B984;
		  /* 8218B984h */ case    5:  		/* addi R3, R11, 31 */
		/* 8218B984h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1F);
		/* 8218B984h case    5:*/		return 0x8218B988;
		  /* 8218B988h */ case    6:  		/* bclr 20, CR0_LT */
		/* 8218B988h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218B988h case    6:*/		return 0x8218B98C;
	}
	return 0x8218B98C;
} // Block from 8218B970h-8218B98Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218B98Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B98C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B98C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B98C);
		  /* 8218B98Ch */ case    0:  		/* nop */
		/* 8218B98Ch case    0:*/		cpu::op::nop();
		/* 8218B98Ch case    0:*/		return 0x8218B990;
		  /* 8218B990h */ case    1:  		/* mr R9, R3 */
		/* 8218B990h case    1:*/		regs.R9 = regs.R3;
		/* 8218B990h case    1:*/		return 0x8218B994;
		  /* 8218B994h */ case    2:  		/* li R3, -1 */
		/* 8218B994h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8218B994h case    2:*/		return 0x8218B998;
		  /* 8218B998h */ case    3:  		/* rlwinm R10, R4, 0, 27, 31 */
		/* 8218B998h case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R4);
		/* 8218B998h case    3:*/		return 0x8218B99C;
		  /* 8218B99Ch */ case    4:  		/* rlwinm R11, R4, 27, 5, 31 */
		/* 8218B99Ch case    4:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R4);
		/* 8218B99Ch case    4:*/		return 0x8218B9A0;
		  /* 8218B9A0h */ case    5:  		/* slw R10, R3, R10 */
		/* 8218B9A0h case    5:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R3,regs.R10);
		/* 8218B9A0h case    5:*/		return 0x8218B9A4;
		  /* 8218B9A4h */ case    6:  		/* cmplwi CR6, R11, 1 */
		/* 8218B9A4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8218B9A4h case    6:*/		return 0x8218B9A8;
		  /* 8218B9A8h */ case    7:  		/* bclr 4, CR6_LT */
		/* 8218B9A8h case    7:*/		if ( !regs.CR[6].lt ) { return (uint32)regs.LR; }
		/* 8218B9A8h case    7:*/		return 0x8218B9AC;
	}
	return 0x8218B9AC;
} // Block from 8218B98Ch-8218B9ACh (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218B9ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B9AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B9AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B9AC);
		  /* 8218B9ACh */ case    0:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 8218B9ACh case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 8218B9ACh case    0:*/		return 0x8218B9B0;
		  /* 8218B9B0h */ case    1:  		/* add R9, R8, R9 */
		/* 8218B9B0h case    1:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8218B9B0h case    1:*/		return 0x8218B9B4;
		  /* 8218B9B4h */ case    2:  		/* lwz R8, <#[R9]> */
		/* 8218B9B4h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 8218B9B4h case    2:*/		return 0x8218B9B8;
		  /* 8218B9B8h */ case    3:  		/* andc. R10, R10, R8 */
		/* 8218B9B8h case    3:*/		cpu::op::andc<1>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8218B9B8h case    3:*/		return 0x8218B9BC;
		  /* 8218B9BCh */ case    4:  		/* bc 4, CR0_EQ, 28 */
		/* 8218B9BCh case    4:*/		if ( !regs.CR[0].eq ) { return 0x8218B9D8;  }
		/* 8218B9BCh case    4:*/		return 0x8218B9C0;
		  /* 8218B9C0h */ case    5:  		/* addi R11, R11, 1 */
		/* 8218B9C0h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218B9C0h case    5:*/		return 0x8218B9C4;
		  /* 8218B9C4h */ case    6:  		/* mr R10, R3 */
		/* 8218B9C4h case    6:*/		regs.R10 = regs.R3;
		/* 8218B9C4h case    6:*/		return 0x8218B9C8;
		  /* 8218B9C8h */ case    7:  		/* addi R9, R9, 4 */
		/* 8218B9C8h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8218B9C8h case    7:*/		return 0x8218B9CC;
		  /* 8218B9CCh */ case    8:  		/* cmplwi CR6, R11, 1 */
		/* 8218B9CCh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8218B9CCh case    8:*/		return 0x8218B9D0;
		  /* 8218B9D0h */ case    9:  		/* bc 12, CR6_LT, -28 */
		/* 8218B9D0h case    9:*/		if ( regs.CR[6].lt ) { return 0x8218B9B4;  }
		/* 8218B9D0h case    9:*/		return 0x8218B9D4;
		  /* 8218B9D4h */ case   10:  		/* bclr 20, CR0_LT */
		/* 8218B9D4h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218B9D4h case   10:*/		return 0x8218B9D8;
	}
	return 0x8218B9D8;
} // Block from 8218B9ACh-8218B9D8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8218B9D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218B9D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218B9D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218B9D8);
		  /* 8218B9D8h */ case    0:  		/* addi R7, R10, -1 */
		/* 8218B9D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFFFFF);
		/* 8218B9D8h case    0:*/		return 0x8218B9DC;
		  /* 8218B9DCh */ case    1:  		/* rlwinm R9, R11, 5, 0, 26 */
		/* 8218B9DCh case    1:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R9,regs.R11);
		/* 8218B9DCh case    1:*/		return 0x8218B9E0;
		  /* 8218B9E0h */ case    2:  		/* andc R11, R10, R7 */
		/* 8218B9E0h case    2:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R10,regs.R7);
		/* 8218B9E0h case    2:*/		return 0x8218B9E4;
		  /* 8218B9E4h */ case    3:  		/* cntlzw R11, R11 */
		/* 8218B9E4h case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8218B9E4h case    3:*/		return 0x8218B9E8;
		  /* 8218B9E8h */ case    4:  		/* subfic R11, R11, 31 */
		/* 8218B9E8h case    4:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x1F);
		/* 8218B9E8h case    4:*/		return 0x8218B9EC;
		  /* 8218B9ECh */ case    5:  		/* rlwinm R10, R11, 0, 0, 29 */
		/* 8218B9ECh case    5:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R10,regs.R11);
		/* 8218B9ECh case    5:*/		return 0x8218B9F0;
		  /* 8218B9F0h */ case    6:  		/* add R3, R9, R11 */
		/* 8218B9F0h case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R9,regs.R11);
		/* 8218B9F0h case    6:*/		return 0x8218B9F4;
		  /* 8218B9F4h */ case    7:  		/* srw R11, R8, R10 */
		/* 8218B9F4h case    7:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R8,regs.R10);
		/* 8218B9F4h case    7:*/		return 0x8218B9F8;
		  /* 8218B9F8h */ case    8:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 8218B9F8h case    8:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 8218B9F8h case    8:*/		return 0x8218B9FC;
		  /* 8218B9FCh */ case    9:  		/* stw R11, <#[R5]> */
		/* 8218B9FCh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8218B9FCh case    9:*/		return 0x8218BA00;
		  /* 8218BA00h */ case   10:  		/* bclr 20, CR0_LT */
		/* 8218BA00h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218BA00h case   10:*/		return 0x8218BA04;
	}
	return 0x8218BA04;
} // Block from 8218B9D8h-8218BA04h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8218BA04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BA04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BA04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BA04);
		  /* 8218BA04h */ case    0:  		/* nop */
		/* 8218BA04h case    0:*/		cpu::op::nop();
		/* 8218BA04h case    0:*/		return 0x8218BA08;
		  /* 8218BA08h */ case    1:  		/* li R8, 2 */
		/* 8218BA08h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 8218BA08h case    1:*/		return 0x8218BA0C;
		  /* 8218BA0Ch */ case    2:  		/* rlwinm R10, R4, 0, 27, 31 */
		/* 8218BA0Ch case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R4);
		/* 8218BA0Ch case    2:*/		return 0x8218BA10;
		  /* 8218BA10h */ case    3:  		/* mr R9, R3 */
		/* 8218BA10h case    3:*/		regs.R9 = regs.R3;
		/* 8218BA10h case    3:*/		return 0x8218BA14;
		  /* 8218BA14h */ case    4:  		/* slw R10, R8, R10 */
		/* 8218BA14h case    4:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8218BA14h case    4:*/		return 0x8218BA18;
		  /* 8218BA18h */ case    5:  		/* rlwinm. R11, R4, 27, 5, 31 */
		/* 8218BA18h case    5:*/		cpu::op::rlwinm<1,27,5,31>(regs,&regs.R11,regs.R4);
		/* 8218BA18h case    5:*/		return 0x8218BA1C;
		  /* 8218BA1Ch */ case    6:  		/* li R3, -1 */
		/* 8218BA1Ch case    6:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8218BA1Ch case    6:*/		return 0x8218BA20;
		  /* 8218BA20h */ case    7:  		/* addi R8, R10, -1 */
		/* 8218BA20h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xFFFFFFFF);
		/* 8218BA20h case    7:*/		return 0x8218BA24;
		  /* 8218BA24h */ case    8:  		/* bclr 12, CR0_LT */
		/* 8218BA24h case    8:*/		if ( regs.CR[0].lt ) { return (uint32)regs.LR; }
		/* 8218BA24h case    8:*/		return 0x8218BA28;
	}
	return 0x8218BA28;
} // Block from 8218BA04h-8218BA28h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218BA28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BA28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BA28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BA28);
		  /* 8218BA28h */ case    0:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 8218BA28h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 8218BA28h case    0:*/		return 0x8218BA2C;
		  /* 8218BA2Ch */ case    1:  		/* add R10, R10, R9 */
		/* 8218BA2Ch case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8218BA2Ch case    1:*/		return 0x8218BA30;
		  /* 8218BA30h */ case    2:  		/* lwz R9, <#[R10]> */
		/* 8218BA30h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8218BA30h case    2:*/		return 0x8218BA34;
		  /* 8218BA34h */ case    3:  		/* andc. R8, R8, R9 */
		/* 8218BA34h case    3:*/		cpu::op::andc<1>(regs,&regs.R8,regs.R8,regs.R9);
		/* 8218BA34h case    3:*/		return 0x8218BA38;
		  /* 8218BA38h */ case    4:  		/* bc 4, CR0_EQ, 24 */
		/* 8218BA38h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8218BA50;  }
		/* 8218BA38h case    4:*/		return 0x8218BA3C;
		  /* 8218BA3Ch */ case    5:  		/* addic. R11, R11, -1 */
		/* 8218BA3Ch case    5:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8218BA3Ch case    5:*/		return 0x8218BA40;
		  /* 8218BA40h */ case    6:  		/* mr R8, R3 */
		/* 8218BA40h case    6:*/		regs.R8 = regs.R3;
		/* 8218BA40h case    6:*/		return 0x8218BA44;
		  /* 8218BA44h */ case    7:  		/* addi R10, R10, -4 */
		/* 8218BA44h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 8218BA44h case    7:*/		return 0x8218BA48;
		  /* 8218BA48h */ case    8:  		/* bc 4, CR0_LT, -24 */
		/* 8218BA48h case    8:*/		if ( !regs.CR[0].lt ) { return 0x8218BA30;  }
		/* 8218BA48h case    8:*/		return 0x8218BA4C;
		  /* 8218BA4Ch */ case    9:  		/* bclr 20, CR0_LT */
		/* 8218BA4Ch case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218BA4Ch case    9:*/		return 0x8218BA50;
	}
	return 0x8218BA50;
} // Block from 8218BA28h-8218BA50h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8218BA50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BA50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BA50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BA50);
		  /* 8218BA50h */ case    0:  		/* cntlzw R8, R8 */
		/* 8218BA50h case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R8,regs.R8);
		/* 8218BA50h case    0:*/		return 0x8218BA54;
		  /* 8218BA54h */ case    1:  		/* rlwinm R10, R11, 5, 0, 26 */
		/* 8218BA54h case    1:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R11);
		/* 8218BA54h case    1:*/		return 0x8218BA58;
		  /* 8218BA58h */ case    2:  		/* subfic R11, R8, 31 */
		/* 8218BA58h case    2:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R8,0x1F);
		/* 8218BA58h case    2:*/		return 0x8218BA5C;
		  /* 8218BA5Ch */ case    3:  		/* rlwinm R8, R11, 0, 0, 29 */
		/* 8218BA5Ch case    3:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R8,regs.R11);
		/* 8218BA5Ch case    3:*/		return 0x8218BA60;
		  /* 8218BA60h */ case    4:  		/* add R3, R10, R11 */
		/* 8218BA60h case    4:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8218BA60h case    4:*/		return 0x8218BA64;
		  /* 8218BA64h */ case    5:  		/* srw R11, R9, R8 */
		/* 8218BA64h case    5:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R9,regs.R8);
		/* 8218BA64h case    5:*/		return 0x8218BA68;
		  /* 8218BA68h */ case    6:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 8218BA68h case    6:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 8218BA68h case    6:*/		return 0x8218BA6C;
		  /* 8218BA6Ch */ case    7:  		/* stw R11, <#[R5]> */
		/* 8218BA6Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8218BA6Ch case    7:*/		return 0x8218BA70;
		  /* 8218BA70h */ case    8:  		/* bclr 20, CR0_LT */
		/* 8218BA70h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218BA70h case    8:*/		return 0x8218BA74;
	}
	return 0x8218BA74;
} // Block from 8218BA50h-8218BA74h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218BA74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BA74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BA74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BA74);
		  /* 8218BA74h */ case    0:  		/* nop */
		/* 8218BA74h case    0:*/		cpu::op::nop();
		/* 8218BA74h case    0:*/		return 0x8218BA78;
	}
	return 0x8218BA78;
} // Block from 8218BA74h-8218BA78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218BA78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BA78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BA78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BA78);
		  /* 8218BA78h */ case    0:  		/* mfspr R12, LR */
		/* 8218BA78h case    0:*/		regs.R12 = regs.LR;
		/* 8218BA78h case    0:*/		return 0x8218BA7C;
		  /* 8218BA7Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8218BA7Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8218BA7Ch case    1:*/		return 0x8218BA80;
		  /* 8218BA80h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8218BA80h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8218BA80h case    2:*/		return 0x8218BA84;
		  /* 8218BA84h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8218BA84h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8218BA84h case    3:*/		return 0x8218BA88;
		  /* 8218BA88h */ case    4:  		/* lwz R11, <#[R3 + 8]> */
		/* 8218BA88h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8218BA88h case    4:*/		return 0x8218BA8C;
		  /* 8218BA8Ch */ case    5:  		/* mr R31, R3 */
		/* 8218BA8Ch case    5:*/		regs.R31 = regs.R3;
		/* 8218BA8Ch case    5:*/		return 0x8218BA90;
		  /* 8218BA90h */ case    6:  		/* mr R3, R4 */
		/* 8218BA90h case    6:*/		regs.R3 = regs.R4;
		/* 8218BA90h case    6:*/		return 0x8218BA94;
		  /* 8218BA94h */ case    7:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8218BA94h case    7:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8218BA94h case    7:*/		return 0x8218BA98;
		  /* 8218BA98h */ case    8:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8218BA98h case    8:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8218BA98h case    8:*/		return 0x8218BA9C;
		  /* 8218BA9Ch */ case    9:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8218BA9Ch case    9:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8218BA9Ch case    9:*/		return 0x8218BAA0;
		  /* 8218BAA0h */ case   10:  		/* bl -161392 */
		/* 8218BAA0h case   10:*/		regs.LR = 0x8218BAA4; return 0x82164430;
		/* 8218BAA0h case   10:*/		return 0x8218BAA4;
		  /* 8218BAA4h */ case   11:  		/* addi R11, R31, -8 */
		/* 8218BAA4h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF8);
		/* 8218BAA4h case   11:*/		return 0x8218BAA8;
		  /* 8218BAA8h */ case   12:  		/* lwzx R11, <#[R3 + R11]> */
		/* 8218BAA8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 8218BAA8h case   12:*/		return 0x8218BAAC;
		  /* 8218BAACh */ case   13:  		/* rlwinm R3, R11, 17, 18, 31 */
		/* 8218BAACh case   13:*/		cpu::op::rlwinm<0,17,18,31>(regs,&regs.R3,regs.R11);
		/* 8218BAACh case   13:*/		return 0x8218BAB0;
		  /* 8218BAB0h */ case   14:  		/* addi R1, R1, 96 */
		/* 8218BAB0h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8218BAB0h case   14:*/		return 0x8218BAB4;
		  /* 8218BAB4h */ case   15:  		/* lwz R12, <#[R1 - 8]> */
		/* 8218BAB4h case   15:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8218BAB4h case   15:*/		return 0x8218BAB8;
		  /* 8218BAB8h */ case   16:  		/* mtspr LR, R12 */
		/* 8218BAB8h case   16:*/		regs.LR = regs.R12;
		/* 8218BAB8h case   16:*/		return 0x8218BABC;
		  /* 8218BABCh */ case   17:  		/* ld R31, <#[R1 - 16]> */
		/* 8218BABCh case   17:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8218BABCh case   17:*/		return 0x8218BAC0;
		  /* 8218BAC0h */ case   18:  		/* bclr 20, CR0_LT */
		/* 8218BAC0h case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218BAC0h case   18:*/		return 0x8218BAC4;
	}
	return 0x8218BAC4;
} // Block from 8218BA78h-8218BAC4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8218BAC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BAC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BAC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BAC4);
		  /* 8218BAC4h */ case    0:  		/* nop */
		/* 8218BAC4h case    0:*/		cpu::op::nop();
		/* 8218BAC4h case    0:*/		return 0x8218BAC8;
	}
	return 0x8218BAC8;
} // Block from 8218BAC4h-8218BAC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218BAC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BAC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BAC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BAC8);
		  /* 8218BAC8h */ case    0:  		/* mfspr R12, LR */
		/* 8218BAC8h case    0:*/		regs.R12 = regs.LR;
		/* 8218BAC8h case    0:*/		return 0x8218BACC;
		  /* 8218BACCh */ case    1:  		/* bl -1026160 */
		/* 8218BACCh case    1:*/		regs.LR = 0x8218BAD0; return 0x8209125C;
		/* 8218BACCh case    1:*/		return 0x8218BAD0;
		  /* 8218BAD0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8218BAD0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8218BAD0h case    2:*/		return 0x8218BAD4;
		  /* 8218BAD4h */ case    3:  		/* mr R30, R3 */
		/* 8218BAD4h case    3:*/		regs.R30 = regs.R3;
		/* 8218BAD4h case    3:*/		return 0x8218BAD8;
		  /* 8218BAD8h */ case    4:  		/* mr R31, R5 */
		/* 8218BAD8h case    4:*/		regs.R31 = regs.R5;
		/* 8218BAD8h case    4:*/		return 0x8218BADC;
		  /* 8218BADCh */ case    5:  		/* mr R29, R6 */
		/* 8218BADCh case    5:*/		regs.R29 = regs.R6;
		/* 8218BADCh case    5:*/		return 0x8218BAE0;
		  /* 8218BAE0h */ case    6:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 8218BAE0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 8218BAE0h case    6:*/		return 0x8218BAE4;
		  /* 8218BAE4h */ case    7:  		/* cmpwi CR6, R29, 0 */
		/* 8218BAE4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 8218BAE4h case    7:*/		return 0x8218BAE8;
		  /* 8218BAE8h */ case    8:  		/* addi R5, R1, 80 */
		/* 8218BAE8h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8218BAE8h case    8:*/		return 0x8218BAEC;
		  /* 8218BAECh */ case    9:  		/* addi R3, R30, 8 */
		/* 8218BAECh case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x8);
		/* 8218BAECh case    9:*/		return 0x8218BAF0;
		  /* 8218BAF0h */ case   10:  		/* bc 4, CR6_GT, 12 */
		/* 8218BAF0h case   10:*/		if ( !regs.CR[6].gt ) { return 0x8218BAFC;  }
		/* 8218BAF0h case   10:*/		return 0x8218BAF4;
		  /* 8218BAF4h */ case   11:  		/* bl -684 */
		/* 8218BAF4h case   11:*/		regs.LR = 0x8218BAF8; return 0x8218B848;
		/* 8218BAF4h case   11:*/		return 0x8218BAF8;
		  /* 8218BAF8h */ case   12:  		/* b 12 */
		/* 8218BAF8h case   12:*/		return 0x8218BB04;
		/* 8218BAF8h case   12:*/		return 0x8218BAFC;
	}
	return 0x8218BAFC;
} // Block from 8218BAC8h-8218BAFCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 8218BAFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BAFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BAFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BAFC);
		  /* 8218BAFCh */ case    0:  		/* addi R4, R4, 3 */
		/* 8218BAFCh case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x3);
		/* 8218BAFCh case    0:*/		return 0x8218BB00;
		  /* 8218BB00h */ case    1:  		/* bl -86768 */
		/* 8218BB00h case    1:*/		regs.LR = 0x8218BB04; return 0x82176810;
		/* 8218BB00h case    1:*/		return 0x8218BB04;
	}
	return 0x8218BB04;
} // Block from 8218BAFCh-8218BB04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218BB04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BB04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BB04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BB04);
		  /* 8218BB04h */ case    0:  		/* cmpwi CR6, R3, -1 */
		/* 8218BB04h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218BB04h case    0:*/		return 0x8218BB08;
		  /* 8218BB08h */ case    1:  		/* bc 12, CR6_EQ, 80 */
		/* 8218BB08h case    1:*/		if ( regs.CR[6].eq ) { return 0x8218BB58;  }
		/* 8218BB08h case    1:*/		return 0x8218BB0C;
		  /* 8218BB0Ch */ case    2:  		/* cmplwi CR6, R31, 1 */
		/* 8218BB0Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000001);
		/* 8218BB0Ch case    2:*/		return 0x8218BB10;
		  /* 8218BB10h */ case    3:  		/* bc 12, CR6_EQ, 84 */
		/* 8218BB10h case    3:*/		if ( regs.CR[6].eq ) { return 0x8218BB64;  }
		/* 8218BB10h case    3:*/		return 0x8218BB14;
		  /* 8218BB14h */ case    4:  		/* lis R10, -27863 */
		/* 8218BB14h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF9329);
		/* 8218BB14h case    4:*/		return 0x8218BB18;
		  /* 8218BB18h */ case    5:  		/* lwz R11, <#[R1 + 80]> */
		/* 8218BB18h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8218BB18h case    5:*/		return 0x8218BB1C;
		  /* 8218BB1Ch */ case    6:  		/* li R9, 1186 */
		/* 8218BB1Ch case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x4A2);
		/* 8218BB1Ch case    6:*/		return 0x8218BB20;
		  /* 8218BB20h */ case    7:  		/* ori R10, R10, 13532 */
		/* 8218BB20h case    7:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x34DC);
		/* 8218BB20h case    7:*/		return 0x8218BB24;
		  /* 8218BB24h */ case    8:  		/* mr R8, R11 */
		/* 8218BB24h case    8:*/		regs.R8 = regs.R11;
		/* 8218BB24h case    8:*/		return 0x8218BB28;
		  /* 8218BB28h */ case    9:  		/* rldimi R10, R9, 32, 0 */
		/* 8218BB28h case    9:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R10,regs.R9);
		/* 8218BB28h case    9:*/		return 0x8218BB2C;
		  /* 8218BB2Ch */ case   10:  		/* srd R10, R10, R11 */
		/* 8218BB2Ch case   10:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8218BB2Ch case   10:*/		return 0x8218BB30;
		  /* 8218BB30h */ case   11:  		/* srd R10, R10, R11 */
		/* 8218BB30h case   11:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8218BB30h case   11:*/		return 0x8218BB34;
		  /* 8218BB34h */ case   12:  		/* srd R10, R10, R11 */
		/* 8218BB34h case   12:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8218BB34h case   12:*/		return 0x8218BB38;
		  /* 8218BB38h */ case   13:  		/* rlwinm R10, R10, 0, 29, 31 */
		/* 8218BB38h case   13:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R10);
		/* 8218BB38h case   13:*/		return 0x8218BB3C;
		  /* 8218BB3Ch */ case   14:  		/* cmplw CR6, R10, R31 */
		/* 8218BB3Ch case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 8218BB3Ch case   14:*/		return 0x8218BB40;
		  /* 8218BB40h */ case   15:  		/* bc 4, CR6_LT, 52 */
		/* 8218BB40h case   15:*/		if ( !regs.CR[6].lt ) { return 0x8218BB74;  }
		/* 8218BB40h case   15:*/		return 0x8218BB44;
		  /* 8218BB44h */ case   16:  		/* add R11, R3, R29 */
		/* 8218BB44h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R29);
		/* 8218BB44h case   16:*/		return 0x8218BB48;
		  /* 8218BB48h */ case   17:  		/* rlwinm R4, R11, 0, 0, 29 */
		/* 8218BB48h case   17:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R4,regs.R11);
		/* 8218BB48h case   17:*/		return 0x8218BB4C;
		  /* 8218BB4Ch */ case   18:  		/* add R11, R4, R31 */
		/* 8218BB4Ch case   18:*/		cpu::op::add<0>(regs,&regs.R11,regs.R4,regs.R31);
		/* 8218BB4Ch case   18:*/		return 0x8218BB50;
		  /* 8218BB50h */ case   19:  		/* cmplwi CR6, R11, 1024 */
		/* 8218BB50h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000400);
		/* 8218BB50h case   19:*/		return 0x8218BB54;
		  /* 8218BB54h */ case   20:  		/* bc 4, CR6_GT, -112 */
		/* 8218BB54h case   20:*/		if ( !regs.CR[6].gt ) { return 0x8218BAE4;  }
		/* 8218BB54h case   20:*/		return 0x8218BB58;
	}
	return 0x8218BB58;
} // Block from 8218BB04h-8218BB58h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8218BB58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BB58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BB58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BB58);
		  /* 8218BB58h */ case    0:  		/* li R3, -1 */
		/* 8218BB58h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8218BB58h case    0:*/		return 0x8218BB5C;
		  /* 8218BB5Ch */ case    1:  		/* addi R1, R1, 128 */
		/* 8218BB5Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8218BB5Ch case    1:*/		return 0x8218BB60;
		  /* 8218BB60h */ case    2:  		/* b -1026228 */
		/* 8218BB60h case    2:*/		return 0x820912AC;
		/* 8218BB60h case    2:*/		return 0x8218BB64;
	}
	return 0x8218BB64;
} // Block from 8218BB58h-8218BB64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218BB64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BB64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BB64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BB64);
		  /* 8218BB64h */ case    0:  		/* rlwinm R11, R3, 0, 30, 31 */
		/* 8218BB64h case    0:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R3);
		/* 8218BB64h case    0:*/		return 0x8218BB68;
		  /* 8218BB68h */ case    1:  		/* li R10, 1 */
		/* 8218BB68h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8218BB68h case    1:*/		return 0x8218BB6C;
		  /* 8218BB6Ch */ case    2:  		/* slw R11, R10, R11 */
		/* 8218BB6Ch case    2:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218BB6Ch case    2:*/		return 0x8218BB70;
		  /* 8218BB70h */ case    3:  		/* b 8 */
		/* 8218BB70h case    3:*/		return 0x8218BB78;
		/* 8218BB70h case    3:*/		return 0x8218BB74;
	}
	return 0x8218BB74;
} // Block from 8218BB64h-8218BB74h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218BB74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BB74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BB74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BB74);
		  /* 8218BB74h */ case    0:  		/* nor R11, R11, R11 */
		/* 8218BB74h case    0:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8218BB74h case    0:*/		return 0x8218BB78;
	}
	return 0x8218BB78;
} // Block from 8218BB74h-8218BB78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218BB78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BB78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BB78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BB78);
		  /* 8218BB78h */ case    0:  		/* rlwimi R11, R3, 2, 0, 27 */
		/* 8218BB78h case    0:*/		cpu::op::rlwimi<0,2,0,27>(regs,&regs.R11,regs.R3);
		/* 8218BB78h case    0:*/		return 0x8218BB7C;
		  /* 8218BB7Ch */ case    1:  		/* mr R3, R11 */
		/* 8218BB7Ch case    1:*/		regs.R3 = regs.R11;
		/* 8218BB7Ch case    1:*/		return 0x8218BB80;
		  /* 8218BB80h */ case    2:  		/* b -36 */
		/* 8218BB80h case    2:*/		return 0x8218BB5C;
		/* 8218BB80h case    2:*/		return 0x8218BB84;
		  /* 8218BB84h */ case    3:  		/* nop */
		/* 8218BB84h case    3:*/		cpu::op::nop();
		/* 8218BB84h case    3:*/		return 0x8218BB88;
		  /* 8218BB88h */ case    4:  		/* rlwinm R9, R5, 0, 27, 31 */
		/* 8218BB88h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R5);
		/* 8218BB88h case    4:*/		return 0x8218BB8C;
		  /* 8218BB8Ch */ case    5:  		/* li R8, 2 */
		/* 8218BB8Ch case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 8218BB8Ch case    5:*/		return 0x8218BB90;
		  /* 8218BB90h */ case    6:  		/* rlwinm R10, R5, 29, 3, 29 */
		/* 8218BB90h case    6:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R5);
		/* 8218BB90h case    6:*/		return 0x8218BB94;
		  /* 8218BB94h */ case    7:  		/* rlwinm R6, R5, 27, 5, 31 */
		/* 8218BB94h case    7:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R6,regs.R5);
		/* 8218BB94h case    7:*/		return 0x8218BB98;
		  /* 8218BB98h */ case    8:  		/* rlwinm R7, R4, 27, 5, 31 */
		/* 8218BB98h case    8:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R7,regs.R4);
		/* 8218BB98h case    8:*/		return 0x8218BB9C;
		  /* 8218BB9Ch */ case    9:  		/* rlwinm R11, R4, 29, 3, 29 */
		/* 8218BB9Ch case    9:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R11,regs.R4);
		/* 8218BB9Ch case    9:*/		return 0x8218BBA0;
		  /* 8218BBA0h */ case   10:  		/* rlwinm R5, R4, 0, 27, 31 */
		/* 8218BBA0h case   10:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R4);
		/* 8218BBA0h case   10:*/		return 0x8218BBA4;
		  /* 8218BBA4h */ case   11:  		/* slw R9, R8, R9 */
		/* 8218BBA4h case   11:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8218BBA4h case   11:*/		return 0x8218BBA8;
		  /* 8218BBA8h */ case   12:  		/* li R4, -1 */
		/* 8218BBA8h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0xFFFFFFFF);
		/* 8218BBA8h case   12:*/		return 0x8218BBAC;
		  /* 8218BBACh */ case   13:  		/* add R8, R10, R3 */
		/* 8218BBACh case   13:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R3);
		/* 8218BBACh case   13:*/		return 0x8218BBB0;
		  /* 8218BBB0h */ case   14:  		/* add R11, R11, R3 */
		/* 8218BBB0h case   14:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8218BBB0h case   14:*/		return 0x8218BBB4;
		  /* 8218BBB4h */ case   15:  		/* slw R10, R4, R5 */
		/* 8218BBB4h case   15:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R4,regs.R5);
		/* 8218BBB4h case   15:*/		return 0x8218BBB8;
		  /* 8218BBB8h */ case   16:  		/* addi R9, R9, -1 */
		/* 8218BBB8h case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8218BBB8h case   16:*/		return 0x8218BBBC;
		  /* 8218BBBCh */ case   17:  		/* cmplw CR6, R7, R6 */
		/* 8218BBBCh case   17:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 8218BBBCh case   17:*/		return 0x8218BBC0;
		  /* 8218BBC0h */ case   18:  		/* bc 4, CR6_EQ, 24 */
		/* 8218BBC0h case   18:*/		if ( !regs.CR[6].eq ) { return 0x8218BBD8;  }
		/* 8218BBC0h case   18:*/		return 0x8218BBC4;
		  /* 8218BBC4h */ case   19:  		/* lwz R11, <#[R11]> */
		/* 8218BBC4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8218BBC4h case   19:*/		return 0x8218BBC8;
		  /* 8218BBC8h */ case   20:  		/* and R11, R11, R9 */
		/* 8218BBC8h case   20:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8218BBC8h case   20:*/		return 0x8218BBCC;
		  /* 8218BBCCh */ case   21:  		/* and R11, R11, R10 */
		/* 8218BBCCh case   21:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8218BBCCh case   21:*/		return 0x8218BBD0;
		  /* 8218BBD0h */ case   22:  		/* addi R11, R11, 0 */
		/* 8218BBD0h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x0);
		/* 8218BBD0h case   22:*/		return 0x8218BBD4;
		  /* 8218BBD4h */ case   23:  		/* b 56 */
		/* 8218BBD4h case   23:*/		return 0x8218BC0C;
		/* 8218BBD4h case   23:*/		return 0x8218BBD8;
	}
	return 0x8218BBD8;
} // Block from 8218BB78h-8218BBD8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8218BBD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BBD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BBD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BBD8);
		  /* 8218BBD8h */ case    0:  		/* lwz R7, <#[R11]> */
		/* 8218BBD8h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8218BBD8h case    0:*/		return 0x8218BBDC;
		  /* 8218BBDCh */ case    1:  		/* and. R10, R7, R10 */
		/* 8218BBDCh case    1:*/		cpu::op::and<1>(regs,&regs.R10,regs.R7,regs.R10);
		/* 8218BBDCh case    1:*/		return 0x8218BBE0;
		  /* 8218BBE0h */ case    2:  		/* bc 12, CR0_EQ, 24 */
		/* 8218BBE0h case    2:*/		if ( regs.CR[0].eq ) { return 0x8218BBF8;  }
		/* 8218BBE0h case    2:*/		return 0x8218BBE4;
		  /* 8218BBE4h */ case    3:  		/* li R3, 1 */
		/* 8218BBE4h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8218BBE4h case    3:*/		return 0x8218BBE8;
		  /* 8218BBE8h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8218BBE8h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218BBE8h case    4:*/		return 0x8218BBEC;
	}
	return 0x8218BBEC;
} // Block from 8218BBD8h-8218BBECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218BBECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BBEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BBEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BBEC);
		  /* 8218BBECh */ case    0:  		/* lwz R10, <#[R11]> */
		/* 8218BBECh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218BBECh case    0:*/		return 0x8218BBF0;
		  /* 8218BBF0h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 8218BBF0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8218BBF0h case    1:*/		return 0x8218BBF4;
		  /* 8218BBF4h */ case    2:  		/* bc 4, CR6_EQ, -16 */
		/* 8218BBF4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8218BBE4;  }
		/* 8218BBF4h case    2:*/		return 0x8218BBF8;
	}
	return 0x8218BBF8;
} // Block from 8218BBECh-8218BBF8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218BBF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BBF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BBF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BBF8);
		  /* 8218BBF8h */ case    0:  		/* addi R11, R11, 4 */
		/* 8218BBF8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8218BBF8h case    0:*/		return 0x8218BBFC;
		  /* 8218BBFCh */ case    1:  		/* cmplw CR6, R11, R8 */
		/* 8218BBFCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8218BBFCh case    1:*/		return 0x8218BC00;
		  /* 8218BC00h */ case    2:  		/* bc 12, CR6_LT, -20 */
		/* 8218BC00h case    2:*/		if ( regs.CR[6].lt ) { return 0x8218BBEC;  }
		/* 8218BC00h case    2:*/		return 0x8218BC04;
		  /* 8218BC04h */ case    3:  		/* lwz R11, <#[R8]> */
		/* 8218BC04h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8218BC04h case    3:*/		return 0x8218BC08;
		  /* 8218BC08h */ case    4:  		/* and R11, R11, R9 */
		/* 8218BC08h case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8218BC08h case    4:*/		return 0x8218BC0C;
	}
	return 0x8218BC0C;
} // Block from 8218BBF8h-8218BC0Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218BC0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BC0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BC0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BC0C);
		  /* 8218BC0Ch */ case    0:  		/* addic R10, R11, -1 */
		/* 8218BC0Ch case    0:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 8218BC0Ch case    0:*/		return 0x8218BC10;
		  /* 8218BC10h */ case    1:  		/* subfe R3, R10, R11 */
		/* 8218BC10h case    1:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8218BC10h case    1:*/		return 0x8218BC14;
		  /* 8218BC14h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8218BC14h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218BC14h case    2:*/		return 0x8218BC18;
	}
	return 0x8218BC18;
} // Block from 8218BC0Ch-8218BC18h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218BC18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BC18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BC18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BC18);
		  /* 8218BC18h */ case    0:  		/* std R30, <#[R1 - 16]> */
		/* 8218BC18h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8218BC18h case    0:*/		return 0x8218BC1C;
		  /* 8218BC1Ch */ case    1:  		/* std R31, <#[R1 - 8]> */
		/* 8218BC1Ch case    1:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8218BC1Ch case    1:*/		return 0x8218BC20;
		  /* 8218BC20h */ case    2:  		/* rlwinm R9, R5, 0, 27, 31 */
		/* 8218BC20h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R5);
		/* 8218BC20h case    2:*/		return 0x8218BC24;
		  /* 8218BC24h */ case    3:  		/* li R7, 2 */
		/* 8218BC24h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 8218BC24h case    3:*/		return 0x8218BC28;
		  /* 8218BC28h */ case    4:  		/* li R8, -1 */
		/* 8218BC28h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 8218BC28h case    4:*/		return 0x8218BC2C;
		  /* 8218BC2Ch */ case    5:  		/* slw R7, R7, R9 */
		/* 8218BC2Ch case    5:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R7,regs.R9);
		/* 8218BC2Ch case    5:*/		return 0x8218BC30;
		  /* 8218BC30h */ case    6:  		/* rlwinm R31, R4, 27, 5, 31 */
		/* 8218BC30h case    6:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R31,regs.R4);
		/* 8218BC30h case    6:*/		return 0x8218BC34;
		  /* 8218BC34h */ case    7:  		/* rlwinm R11, R4, 29, 3, 29 */
		/* 8218BC34h case    7:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R11,regs.R4);
		/* 8218BC34h case    7:*/		return 0x8218BC38;
		  /* 8218BC38h */ case    8:  		/* rlwinm R30, R5, 27, 5, 31 */
		/* 8218BC38h case    8:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R30,regs.R5);
		/* 8218BC38h case    8:*/		return 0x8218BC3C;
		  /* 8218BC3Ch */ case    9:  		/* rlwinm R10, R5, 29, 3, 29 */
		/* 8218BC3Ch case    9:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R5);
		/* 8218BC3Ch case    9:*/		return 0x8218BC40;
		  /* 8218BC40h */ case   10:  		/* rlwinm R6, R4, 0, 27, 31 */
		/* 8218BC40h case   10:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R6,regs.R4);
		/* 8218BC40h case   10:*/		return 0x8218BC44;
		  /* 8218BC44h */ case   11:  		/* add R11, R11, R3 */
		/* 8218BC44h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8218BC44h case   11:*/		return 0x8218BC48;
		  /* 8218BC48h */ case   12:  		/* add R9, R10, R3 */
		/* 8218BC48h case   12:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R3);
		/* 8218BC48h case   12:*/		return 0x8218BC4C;
		  /* 8218BC4Ch */ case   13:  		/* slw R6, R8, R6 */
		/* 8218BC4Ch case   13:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R8,regs.R6);
		/* 8218BC4Ch case   13:*/		return 0x8218BC50;
		  /* 8218BC50h */ case   14:  		/* addi R7, R7, -1 */
		/* 8218BC50h case   14:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0xFFFFFFFF);
		/* 8218BC50h case   14:*/		return 0x8218BC54;
		  /* 8218BC54h */ case   15:  		/* cmplw CR6, R31, R30 */
		/* 8218BC54h case   15:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 8218BC54h case   15:*/		return 0x8218BC58;
		  /* 8218BC58h */ case   16:  		/* bc 4, CR6_EQ, 24 */
		/* 8218BC58h case   16:*/		if ( !regs.CR[6].eq ) { return 0x8218BC70;  }
		/* 8218BC58h case   16:*/		return 0x8218BC5C;
		  /* 8218BC5Ch */ case   17:  		/* lwz R10, <#[R11]> */
		/* 8218BC5Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218BC5Ch case   17:*/		return 0x8218BC60;
		  /* 8218BC60h */ case   18:  		/* and R9, R7, R6 */
		/* 8218BC60h case   18:*/		cpu::op::and<0>(regs,&regs.R9,regs.R7,regs.R6);
		/* 8218BC60h case   18:*/		return 0x8218BC64;
		  /* 8218BC64h */ case   19:  		/* or R10, R9, R10 */
		/* 8218BC64h case   19:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8218BC64h case   19:*/		return 0x8218BC68;
		  /* 8218BC68h */ case   20:  		/* stw R10, <#[R11]> */
		/* 8218BC68h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218BC68h case   20:*/		return 0x8218BC6C;
		  /* 8218BC6Ch */ case   21:  		/* b 76 */
		/* 8218BC6Ch case   21:*/		return 0x8218BCB8;
		/* 8218BC6Ch case   21:*/		return 0x8218BC70;
	}
	return 0x8218BC70;
} // Block from 8218BC18h-8218BC70h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8218BC70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BC70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BC70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BC70);
		  /* 8218BC70h */ case    0:  		/* lwz R5, <#[R11]> */
		/* 8218BC70h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 8218BC70h case    0:*/		return 0x8218BC74;
		  /* 8218BC74h */ case    1:  		/* addi R10, R11, 4 */
		/* 8218BC74h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8218BC74h case    1:*/		return 0x8218BC78;
		  /* 8218BC78h */ case    2:  		/* or R6, R5, R6 */
		/* 8218BC78h case    2:*/		cpu::op::or<0>(regs,&regs.R6,regs.R5,regs.R6);
		/* 8218BC78h case    2:*/		return 0x8218BC7C;
		  /* 8218BC7Ch */ case    3:  		/* cmplw CR6, R10, R9 */
		/* 8218BC7Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8218BC7Ch case    3:*/		return 0x8218BC80;
		  /* 8218BC80h */ case    4:  		/* stw R6, <#[R11]> */
		/* 8218BC80h case    4:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8218BC80h case    4:*/		return 0x8218BC84;
		  /* 8218BC84h */ case    5:  		/* bc 4, CR6_LT, 40 */
		/* 8218BC84h case    5:*/		if ( !regs.CR[6].lt ) { return 0x8218BCAC;  }
		/* 8218BC84h case    5:*/		return 0x8218BC88;
		  /* 8218BC88h */ case    6:  		/* subf R11, R10, R9 */
		/* 8218BC88h case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R9);
		/* 8218BC88h case    6:*/		return 0x8218BC8C;
		  /* 8218BC8Ch */ case    7:  		/* addi R10, R10, -4 */
		/* 8218BC8Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 8218BC8Ch case    7:*/		return 0x8218BC90;
		  /* 8218BC90h */ case    8:  		/* addi R11, R11, -1 */
		/* 8218BC90h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8218BC90h case    8:*/		return 0x8218BC94;
		  /* 8218BC94h */ case    9:  		/* rlwinm R11, R11, 30, 2, 31 */
		/* 8218BC94h case    9:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R11);
		/* 8218BC94h case    9:*/		return 0x8218BC98;
		  /* 8218BC98h */ case   10:  		/* addic. R11, R11, 1 */
		/* 8218BC98h case   10:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0x1);
		/* 8218BC98h case   10:*/		return 0x8218BC9C;
		  /* 8218BC9Ch */ case   11:  		/* bc 12, CR0_EQ, 16 */
		/* 8218BC9Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x8218BCAC;  }
		/* 8218BC9Ch case   11:*/		return 0x8218BCA0;
		  /* 8218BCA0h */ case   12:  		/* mtspr CTR, R11 */
		/* 8218BCA0h case   12:*/		regs.CTR = regs.R11;
		/* 8218BCA0h case   12:*/		return 0x8218BCA4;
		  /* 8218BCA4h */ case   13:  		/* stwu R8, <#[R10 + 4]> */
		/* 8218BCA4h case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8218BCA4h case   13:*/		return 0x8218BCA8;
		  /* 8218BCA8h */ case   14:  		/* bc 16, CR0_LT, -4 */
		/* 8218BCA8h case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8218BCA4;  }
		/* 8218BCA8h case   14:*/		return 0x8218BCAC;
	}
	return 0x8218BCAC;
} // Block from 8218BC70h-8218BCACh (15 instructions)

//////////////////////////////////////////////////////
// Block at 8218BCACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BCAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BCAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BCAC);
		  /* 8218BCACh */ case    0:  		/* lwz R11, <#[R9]> */
		/* 8218BCACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8218BCACh case    0:*/		return 0x8218BCB0;
		  /* 8218BCB0h */ case    1:  		/* or R11, R11, R7 */
		/* 8218BCB0h case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 8218BCB0h case    1:*/		return 0x8218BCB4;
		  /* 8218BCB4h */ case    2:  		/* stw R11, <#[R9]> */
		/* 8218BCB4h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8218BCB4h case    2:*/		return 0x8218BCB8;
	}
	return 0x8218BCB8;
} // Block from 8218BCACh-8218BCB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218BCB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BCB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BCB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BCB8);
		  /* 8218BCB8h */ case    0:  		/* ld R30, <#[R1 - 16]> */
		/* 8218BCB8h case    0:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8218BCB8h case    0:*/		return 0x8218BCBC;
		  /* 8218BCBCh */ case    1:  		/* ld R31, <#[R1 - 8]> */
		/* 8218BCBCh case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8218BCBCh case    1:*/		return 0x8218BCC0;
		  /* 8218BCC0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8218BCC0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218BCC0h case    2:*/		return 0x8218BCC4;
	}
	return 0x8218BCC4;
} // Block from 8218BCB8h-8218BCC4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218BCC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BCC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BCC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BCC4);
		  /* 8218BCC4h */ case    0:  		/* nop */
		/* 8218BCC4h case    0:*/		cpu::op::nop();
		/* 8218BCC4h case    0:*/		return 0x8218BCC8;
	}
	return 0x8218BCC8;
} // Block from 8218BCC4h-8218BCC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218BCC8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BCC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BCC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BCC8);
		  /* 8218BCC8h */ case    0:  		/* std R30, <#[R1 - 16]> */
		/* 8218BCC8h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8218BCC8h case    0:*/		return 0x8218BCCC;
		  /* 8218BCCCh */ case    1:  		/* std R31, <#[R1 - 8]> */
		/* 8218BCCCh case    1:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8218BCCCh case    1:*/		return 0x8218BCD0;
		  /* 8218BCD0h */ case    2:  		/* rldicl R9, R5, 0, 58 */
		/* 8218BCD0h case    2:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R9,regs.R5);
		/* 8218BCD0h case    2:*/		return 0x8218BCD4;
		  /* 8218BCD4h */ case    3:  		/* li R8, 2 */
		/* 8218BCD4h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 8218BCD4h case    3:*/		return 0x8218BCD8;
		  /* 8218BCD8h */ case    4:  		/* li R6, -1 */
		/* 8218BCD8h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFF);
		/* 8218BCD8h case    4:*/		return 0x8218BCDC;
		  /* 8218BCDCh */ case    5:  		/* rldicl R7, R4, 0, 58 */
		/* 8218BCDCh case    5:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R7,regs.R4);
		/* 8218BCDCh case    5:*/		return 0x8218BCE0;
		  /* 8218BCE0h */ case    6:  		/* sld R8, R8, R9 */
		/* 8218BCE0h case    6:*/		cpu::op::sld<0>(regs,&regs.R8,regs.R8,regs.R9);
		/* 8218BCE0h case    6:*/		return 0x8218BCE4;
		  /* 8218BCE4h */ case    7:  		/* rlwinm R31, R4, 26, 6, 31 */
		/* 8218BCE4h case    7:*/		cpu::op::rlwinm<0,26,6,31>(regs,&regs.R31,regs.R4);
		/* 8218BCE4h case    7:*/		return 0x8218BCE8;
		  /* 8218BCE8h */ case    8:  		/* rlwinm R11, R4, 29, 3, 28 */
		/* 8218BCE8h case    8:*/		cpu::op::rlwinm<0,29,3,28>(regs,&regs.R11,regs.R4);
		/* 8218BCE8h case    8:*/		return 0x8218BCEC;
		  /* 8218BCECh */ case    9:  		/* rlwinm R30, R5, 26, 6, 31 */
		/* 8218BCECh case    9:*/		cpu::op::rlwinm<0,26,6,31>(regs,&regs.R30,regs.R5);
		/* 8218BCECh case    9:*/		return 0x8218BCF0;
	}
	return 0x8218BCF0;
} // Block from 8218BCC8h-8218BCF0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8218BCF0h
// Function '?GetConstantRegisterUseType@Instruction@D3DXShader@@QAA?AW4_D3DXREGISTER_SET@@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BCF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BCF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BCF0);
		  /* 8218BCF0h */ case    0:  		/* rlwinm R10, R5, 29, 3, 28 */
		/* 8218BCF0h case    0:*/		cpu::op::rlwinm<0,29,3,28>(regs,&regs.R10,regs.R5);
		/* 8218BCF0h case    0:*/		return 0x8218BCF4;
		  /* 8218BCF4h */ case    1:  		/* sld R7, R6, R7 */
		/* 8218BCF4h case    1:*/		cpu::op::sld<0>(regs,&regs.R7,regs.R6,regs.R7);
		/* 8218BCF4h case    1:*/		return 0x8218BCF8;
		  /* 8218BCF8h */ case    2:  		/* add R11, R11, R3 */
		/* 8218BCF8h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8218BCF8h case    2:*/		return 0x8218BCFC;
		  /* 8218BCFCh */ case    3:  		/* add R9, R10, R3 */
		/* 8218BCFCh case    3:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R3);
		/* 8218BCFCh case    3:*/		return 0x8218BD00;
		  /* 8218BD00h */ case    4:  		/* addi R6, R8, -1 */
		/* 8218BD00h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R8,0xFFFFFFFF);
		/* 8218BD00h case    4:*/		return 0x8218BD04;
		  /* 8218BD04h */ case    5:  		/* cmplw CR6, R31, R30 */
		/* 8218BD04h case    5:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 8218BD04h case    5:*/		return 0x8218BD08;
		  /* 8218BD08h */ case    6:  		/* bc 4, CR6_EQ, 24 */
		/* 8218BD08h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8218BD20;  }
		/* 8218BD08h case    6:*/		return 0x8218BD0C;
		  /* 8218BD0Ch */ case    7:  		/* ld R10, <#[R11]> */
		/* 8218BD0Ch case    7:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218BD0Ch case    7:*/		return 0x8218BD10;
		  /* 8218BD10h */ case    8:  		/* and R9, R6, R7 */
		/* 8218BD10h case    8:*/		cpu::op::and<0>(regs,&regs.R9,regs.R6,regs.R7);
		/* 8218BD10h case    8:*/		return 0x8218BD14;
		  /* 8218BD14h */ case    9:  		/* or R10, R9, R10 */
		/* 8218BD14h case    9:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8218BD14h case    9:*/		return 0x8218BD18;
		  /* 8218BD18h */ case   10:  		/* std R10, <#[R11]> */
		/* 8218BD18h case   10:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218BD18h case   10:*/		return 0x8218BD1C;
		  /* 8218BD1Ch */ case   11:  		/* b 80 */
		/* 8218BD1Ch case   11:*/		return 0x8218BD6C;
		/* 8218BD1Ch case   11:*/		return 0x8218BD20;
	}
	return 0x8218BD20;
} // Block from 8218BCF0h-8218BD20h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8218BD20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BD20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BD20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BD20);
		  /* 8218BD20h */ case    0:  		/* ld R8, <#[R11]> */
		/* 8218BD20h case    0:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8218BD20h case    0:*/		return 0x8218BD24;
		  /* 8218BD24h */ case    1:  		/* addi R10, R11, 8 */
		/* 8218BD24h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x8);
		/* 8218BD24h case    1:*/		return 0x8218BD28;
		  /* 8218BD28h */ case    2:  		/* or R8, R8, R7 */
		/* 8218BD28h case    2:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8218BD28h case    2:*/		return 0x8218BD2C;
		  /* 8218BD2Ch */ case    3:  		/* cmplw CR6, R10, R9 */
		/* 8218BD2Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8218BD2Ch case    3:*/		return 0x8218BD30;
		  /* 8218BD30h */ case    4:  		/* std R8, <#[R11]> */
		/* 8218BD30h case    4:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8218BD30h case    4:*/		return 0x8218BD34;
		  /* 8218BD34h */ case    5:  		/* bc 4, CR6_LT, 44 */
		/* 8218BD34h case    5:*/		if ( !regs.CR[6].lt ) { return 0x8218BD60;  }
		/* 8218BD34h case    5:*/		return 0x8218BD38;
		  /* 8218BD38h */ case    6:  		/* subf R11, R10, R9 */
		/* 8218BD38h case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R9);
		/* 8218BD38h case    6:*/		return 0x8218BD3C;
		  /* 8218BD3Ch */ case    7:  		/* addi R10, R10, -8 */
		/* 8218BD3Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFF8);
		/* 8218BD3Ch case    7:*/		return 0x8218BD40;
		  /* 8218BD40h */ case    8:  		/* addi R11, R11, -1 */
		/* 8218BD40h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8218BD40h case    8:*/		return 0x8218BD44;
		  /* 8218BD44h */ case    9:  		/* li R8, -1 */
		/* 8218BD44h case    9:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 8218BD44h case    9:*/		return 0x8218BD48;
		  /* 8218BD48h */ case   10:  		/* rlwinm R11, R11, 29, 3, 31 */
		/* 8218BD48h case   10:*/		cpu::op::rlwinm<0,29,3,31>(regs,&regs.R11,regs.R11);
		/* 8218BD48h case   10:*/		return 0x8218BD4C;
		  /* 8218BD4Ch */ case   11:  		/* addic. R11, R11, 1 */
		/* 8218BD4Ch case   11:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0x1);
		/* 8218BD4Ch case   11:*/		return 0x8218BD50;
		  /* 8218BD50h */ case   12:  		/* bc 12, CR0_EQ, 16 */
		/* 8218BD50h case   12:*/		if ( regs.CR[0].eq ) { return 0x8218BD60;  }
		/* 8218BD50h case   12:*/		return 0x8218BD54;
		  /* 8218BD54h */ case   13:  		/* mtspr CTR, R11 */
		/* 8218BD54h case   13:*/		regs.CTR = regs.R11;
		/* 8218BD54h case   13:*/		return 0x8218BD58;
		  /* 8218BD58h */ case   14:  		/* stdu R8, <#[R10 + 8]> */
		/* 8218BD58h case   14:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 8218BD58h case   14:*/		return 0x8218BD5C;
		  /* 8218BD5Ch */ case   15:  		/* bc 16, CR0_LT, -4 */
		/* 8218BD5Ch case   15:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8218BD58;  }
		/* 8218BD5Ch case   15:*/		return 0x8218BD60;
	}
	return 0x8218BD60;
} // Block from 8218BD20h-8218BD60h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8218BD60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BD60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BD60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BD60);
		  /* 8218BD60h */ case    0:  		/* ld R11, <#[R9]> */
		/* 8218BD60h case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8218BD60h case    0:*/		return 0x8218BD64;
		  /* 8218BD64h */ case    1:  		/* or R11, R11, R6 */
		/* 8218BD64h case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 8218BD64h case    1:*/		return 0x8218BD68;
		  /* 8218BD68h */ case    2:  		/* std R11, <#[R9]> */
		/* 8218BD68h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8218BD68h case    2:*/		return 0x8218BD6C;
	}
	return 0x8218BD6C;
} // Block from 8218BD60h-8218BD6Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218BD6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BD6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BD6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BD6C);
		  /* 8218BD6Ch */ case    0:  		/* ld R30, <#[R1 - 16]> */
		/* 8218BD6Ch case    0:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8218BD6Ch case    0:*/		return 0x8218BD70;
		  /* 8218BD70h */ case    1:  		/* ld R31, <#[R1 - 8]> */
		/* 8218BD70h case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8218BD70h case    1:*/		return 0x8218BD74;
		  /* 8218BD74h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8218BD74h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218BD74h case    2:*/		return 0x8218BD78;
	}
	return 0x8218BD78;
} // Block from 8218BD6Ch-8218BD78h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218BD78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BD78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BD78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BD78);
		  /* 8218BD78h */ case    0:  		/* mfspr R12, LR */
		/* 8218BD78h case    0:*/		regs.R12 = regs.LR;
		/* 8218BD78h case    0:*/		return 0x8218BD7C;
		  /* 8218BD7Ch */ case    1:  		/* bl -1026848 */
		/* 8218BD7Ch case    1:*/		regs.LR = 0x8218BD80; return 0x8209125C;
		/* 8218BD7Ch case    1:*/		return 0x8218BD80;
		  /* 8218BD80h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8218BD80h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8218BD80h case    2:*/		return 0x8218BD84;
		  /* 8218BD84h */ case    3:  		/* mr R30, R3 */
		/* 8218BD84h case    3:*/		regs.R30 = regs.R3;
		/* 8218BD84h case    3:*/		return 0x8218BD88;
		  /* 8218BD88h */ case    4:  		/* mr R31, R5 */
		/* 8218BD88h case    4:*/		regs.R31 = regs.R5;
		/* 8218BD88h case    4:*/		return 0x8218BD8C;
		  /* 8218BD8Ch */ case    5:  		/* mr R29, R6 */
		/* 8218BD8Ch case    5:*/		regs.R29 = regs.R6;
		/* 8218BD8Ch case    5:*/		return 0x8218BD90;
	}
	return 0x8218BD90;
} // Block from 8218BD78h-8218BD90h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218BD90h
// Function '?GetSamplerRegisterCount@Compiler@D3DXShader@@QAAIXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BD90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BD90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BD90);
		  /* 8218BD90h */ case    0:  		/* cmpwi CR6, R29, 0 */
		/* 8218BD90h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 8218BD90h case    0:*/		return 0x8218BD94;
		  /* 8218BD94h */ case    1:  		/* addi R5, R1, 80 */
		/* 8218BD94h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8218BD94h case    1:*/		return 0x8218BD98;
		  /* 8218BD98h */ case    2:  		/* addi R3, R30, 4 */
		/* 8218BD98h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x4);
		/* 8218BD98h case    2:*/		return 0x8218BD9C;
		  /* 8218BD9Ch */ case    3:  		/* bc 4, CR6_GT, 12 */
		/* 8218BD9Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x8218BDA8;  }
		/* 8218BD9Ch case    3:*/		return 0x8218BDA0;
		  /* 8218BDA0h */ case    4:  		/* bl -1040 */
		/* 8218BDA0h case    4:*/		regs.LR = 0x8218BDA4; return 0x8218B990;
		/* 8218BDA0h case    4:*/		return 0x8218BDA4;
		  /* 8218BDA4h */ case    5:  		/* b 8 */
		/* 8218BDA4h case    5:*/		return 0x8218BDAC;
		/* 8218BDA4h case    5:*/		return 0x8218BDA8;
	}
	return 0x8218BDA8;
} // Block from 8218BD90h-8218BDA8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218BDA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BDA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BDA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BDA8);
		  /* 8218BDA8h */ case    0:  		/* bl -928 */
		/* 8218BDA8h case    0:*/		regs.LR = 0x8218BDAC; return 0x8218BA08;
		/* 8218BDA8h case    0:*/		return 0x8218BDAC;
	}
	return 0x8218BDAC;
} // Block from 8218BDA8h-8218BDACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218BDACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BDAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BDAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BDAC);
		  /* 8218BDACh */ case    0:  		/* cmpwi CR6, R3, -1 */
		/* 8218BDACh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218BDACh case    0:*/		return 0x8218BDB0;
		  /* 8218BDB0h */ case    1:  		/* bc 12, CR6_EQ, 76 */
		/* 8218BDB0h case    1:*/		if ( regs.CR[6].eq ) { return 0x8218BDFC;  }
		/* 8218BDB0h case    1:*/		return 0x8218BDB4;
		  /* 8218BDB4h */ case    2:  		/* cmplwi CR6, R31, 1 */
		/* 8218BDB4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000001);
		/* 8218BDB4h case    2:*/		return 0x8218BDB8;
		  /* 8218BDB8h */ case    3:  		/* bc 12, CR6_EQ, 80 */
		/* 8218BDB8h case    3:*/		if ( regs.CR[6].eq ) { return 0x8218BE08;  }
		/* 8218BDB8h case    3:*/		return 0x8218BDBC;
		  /* 8218BDBCh */ case    4:  		/* lis R10, -27863 */
		/* 8218BDBCh case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF9329);
		/* 8218BDBCh case    4:*/		return 0x8218BDC0;
		  /* 8218BDC0h */ case    5:  		/* lwz R11, <#[R1 + 80]> */
		/* 8218BDC0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8218BDC0h case    5:*/		return 0x8218BDC4;
		  /* 8218BDC4h */ case    6:  		/* li R9, 1186 */
		/* 8218BDC4h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x4A2);
		/* 8218BDC4h case    6:*/		return 0x8218BDC8;
		  /* 8218BDC8h */ case    7:  		/* ori R10, R10, 13532 */
		/* 8218BDC8h case    7:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x34DC);
		/* 8218BDC8h case    7:*/		return 0x8218BDCC;
		  /* 8218BDCCh */ case    8:  		/* mr R8, R11 */
		/* 8218BDCCh case    8:*/		regs.R8 = regs.R11;
		/* 8218BDCCh case    8:*/		return 0x8218BDD0;
		  /* 8218BDD0h */ case    9:  		/* rldimi R10, R9, 32, 0 */
		/* 8218BDD0h case    9:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R10,regs.R9);
		/* 8218BDD0h case    9:*/		return 0x8218BDD4;
		  /* 8218BDD4h */ case   10:  		/* srd R10, R10, R11 */
		/* 8218BDD4h case   10:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8218BDD4h case   10:*/		return 0x8218BDD8;
		  /* 8218BDD8h */ case   11:  		/* srd R10, R10, R11 */
		/* 8218BDD8h case   11:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8218BDD8h case   11:*/		return 0x8218BDDC;
		  /* 8218BDDCh */ case   12:  		/* srd R10, R10, R11 */
		/* 8218BDDCh case   12:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8218BDDCh case   12:*/		return 0x8218BDE0;
	}
	return 0x8218BDE0;
} // Block from 8218BDACh-8218BDE0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8218BDE0h
// Function '?SetVariableComponentInfo@D3DXShader@@YAXPAUVariableComponentInfo@1@IIIW4_D3DCOMPONENT_TYPE@1@_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BDE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BDE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BDE0);
		  /* 8218BDE0h */ case    0:  		/* rlwinm R10, R10, 0, 29, 31 */
		/* 8218BDE0h case    0:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R10);
		/* 8218BDE0h case    0:*/		return 0x8218BDE4;
		  /* 8218BDE4h */ case    1:  		/* cmplw CR6, R10, R31 */
		/* 8218BDE4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 8218BDE4h case    1:*/		return 0x8218BDE8;
		  /* 8218BDE8h */ case    2:  		/* bc 4, CR6_LT, 44 */
		/* 8218BDE8h case    2:*/		if ( !regs.CR[6].lt ) { return 0x8218BE14;  }
		/* 8218BDE8h case    2:*/		return 0x8218BDEC;
		  /* 8218BDECh */ case    3:  		/* add R4, R3, R29 */
		/* 8218BDECh case    3:*/		cpu::op::add<0>(regs,&regs.R4,regs.R3,regs.R29);
		/* 8218BDECh case    3:*/		return 0x8218BDF0;
		  /* 8218BDF0h */ case    4:  		/* add R11, R4, R31 */
		/* 8218BDF0h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R4,regs.R31);
		/* 8218BDF0h case    4:*/		return 0x8218BDF4;
		  /* 8218BDF4h */ case    5:  		/* cmplwi CR6, R11, 32 */
		/* 8218BDF4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 8218BDF4h case    5:*/		return 0x8218BDF8;
		  /* 8218BDF8h */ case    6:  		/* bc 4, CR6_GT, -104 */
		/* 8218BDF8h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8218BD90;  }
		/* 8218BDF8h case    6:*/		return 0x8218BDFC;
	}
	return 0x8218BDFC;
} // Block from 8218BDE0h-8218BDFCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218BDFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BDFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BDFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BDFC);
		  /* 8218BDFCh */ case    0:  		/* li R3, -1 */
		/* 8218BDFCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8218BDFCh case    0:*/		return 0x8218BE00;
		  /* 8218BE00h */ case    1:  		/* addi R1, R1, 128 */
		/* 8218BE00h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8218BE00h case    1:*/		return 0x8218BE04;
		  /* 8218BE04h */ case    2:  		/* b -1026904 */
		/* 8218BE04h case    2:*/		return 0x820912AC;
		/* 8218BE04h case    2:*/		return 0x8218BE08;
	}
	return 0x8218BE08;
} // Block from 8218BDFCh-8218BE08h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218BE08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BE08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BE08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BE08);
		  /* 8218BE08h */ case    0:  		/* rlwinm R11, R3, 4, 0, 27 */
		/* 8218BE08h case    0:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R3);
		/* 8218BE08h case    0:*/		return 0x8218BE0C;
		  /* 8218BE0Ch */ case    1:  		/* ori R3, R11, 1 */
		/* 8218BE0Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R11,0x1);
		/* 8218BE0Ch case    1:*/		return 0x8218BE10;
		  /* 8218BE10h */ case    2:  		/* b -16 */
		/* 8218BE10h case    2:*/		return 0x8218BE00;
		/* 8218BE10h case    2:*/		return 0x8218BE14;
	}
	return 0x8218BE14;
} // Block from 8218BE08h-8218BE14h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218BE14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BE14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BE14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BE14);
		  /* 8218BE14h */ case    0:  		/* nor R11, R11, R11 */
		/* 8218BE14h case    0:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8218BE14h case    0:*/		return 0x8218BE18;
		  /* 8218BE18h */ case    1:  		/* rlwinm R10, R3, 4, 0, 27 */
		/* 8218BE18h case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R3);
		/* 8218BE18h case    1:*/		return 0x8218BE1C;
		  /* 8218BE1Ch */ case    2:  		/* rlwinm R11, R11, 0, 31, 31 */
		/* 8218BE1Ch case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8218BE1Ch case    2:*/		return 0x8218BE20;
		  /* 8218BE20h */ case    3:  		/* or R3, R11, R10 */
		/* 8218BE20h case    3:*/		cpu::op::or<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 8218BE20h case    3:*/		return 0x8218BE24;
		  /* 8218BE24h */ case    4:  		/* b -36 */
		/* 8218BE24h case    4:*/		return 0x8218BE00;
		/* 8218BE24h case    4:*/		return 0x8218BE28;
	}
	return 0x8218BE28;
} // Block from 8218BE14h-8218BE28h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218BE28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BE28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BE28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BE28);
		  /* 8218BE28h */ case    0:  		/* mfspr R12, LR */
		/* 8218BE28h case    0:*/		regs.R12 = regs.LR;
		/* 8218BE28h case    0:*/		return 0x8218BE2C;
		  /* 8218BE2Ch */ case    1:  		/* bl -1027024 */
		/* 8218BE2Ch case    1:*/		regs.LR = 0x8218BE30; return 0x8209125C;
		/* 8218BE2Ch case    1:*/		return 0x8218BE30;
		  /* 8218BE30h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8218BE30h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8218BE30h case    2:*/		return 0x8218BE34;
		  /* 8218BE34h */ case    3:  		/* mr R30, R3 */
		/* 8218BE34h case    3:*/		regs.R30 = regs.R3;
		/* 8218BE34h case    3:*/		return 0x8218BE38;
		  /* 8218BE38h */ case    4:  		/* mr R31, R5 */
		/* 8218BE38h case    4:*/		regs.R31 = regs.R5;
		/* 8218BE38h case    4:*/		return 0x8218BE3C;
		  /* 8218BE3Ch */ case    5:  		/* mr R29, R6 */
		/* 8218BE3Ch case    5:*/		regs.R29 = regs.R6;
		/* 8218BE3Ch case    5:*/		return 0x8218BE40;
		  /* 8218BE40h */ case    6:  		/* cmpwi CR6, R29, 0 */
		/* 8218BE40h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 8218BE40h case    6:*/		return 0x8218BE44;
		  /* 8218BE44h */ case    7:  		/* addi R5, R1, 80 */
		/* 8218BE44h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8218BE44h case    7:*/		return 0x8218BE48;
		  /* 8218BE48h */ case    8:  		/* addi R3, R30, 8 */
		/* 8218BE48h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x8);
		/* 8218BE48h case    8:*/		return 0x8218BE4C;
		  /* 8218BE4Ch */ case    9:  		/* bc 4, CR6_GT, 12 */
		/* 8218BE4Ch case    9:*/		if ( !regs.CR[6].gt ) { return 0x8218BE58;  }
		/* 8218BE4Ch case    9:*/		return 0x8218BE50;
		  /* 8218BE50h */ case   10:  		/* bl -87736 */
		/* 8218BE50h case   10:*/		regs.LR = 0x8218BE54; return 0x82176798;
		/* 8218BE50h case   10:*/		return 0x8218BE54;
		  /* 8218BE54h */ case   11:  		/* b 8 */
		/* 8218BE54h case   11:*/		return 0x8218BE5C;
		/* 8218BE54h case   11:*/		return 0x8218BE58;
	}
	return 0x8218BE58;
} // Block from 8218BE28h-8218BE58h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8218BE58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BE58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BE58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BE58);
		  /* 8218BE58h */ case    0:  		/* bl -87624 */
		/* 8218BE58h case    0:*/		regs.LR = 0x8218BE5C; return 0x82176810;
		/* 8218BE58h case    0:*/		return 0x8218BE5C;
	}
	return 0x8218BE5C;
} // Block from 8218BE58h-8218BE5Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218BE5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BE5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BE5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BE5C);
		  /* 8218BE5Ch */ case    0:  		/* cmpwi CR6, R3, -1 */
		/* 8218BE5Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218BE5Ch case    0:*/		return 0x8218BE60;
		  /* 8218BE60h */ case    1:  		/* bc 12, CR6_EQ, 76 */
		/* 8218BE60h case    1:*/		if ( regs.CR[6].eq ) { return 0x8218BEAC;  }
		/* 8218BE60h case    1:*/		return 0x8218BE64;
		  /* 8218BE64h */ case    2:  		/* cmplwi CR6, R31, 1 */
		/* 8218BE64h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000001);
		/* 8218BE64h case    2:*/		return 0x8218BE68;
		  /* 8218BE68h */ case    3:  		/* bc 12, CR6_EQ, 80 */
		/* 8218BE68h case    3:*/		if ( regs.CR[6].eq ) { return 0x8218BEB8;  }
		/* 8218BE68h case    3:*/		return 0x8218BE6C;
		  /* 8218BE6Ch */ case    4:  		/* lis R10, -27863 */
		/* 8218BE6Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF9329);
		/* 8218BE6Ch case    4:*/		return 0x8218BE70;
		  /* 8218BE70h */ case    5:  		/* lwz R11, <#[R1 + 80]> */
		/* 8218BE70h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8218BE70h case    5:*/		return 0x8218BE74;
		  /* 8218BE74h */ case    6:  		/* li R9, 1186 */
		/* 8218BE74h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x4A2);
		/* 8218BE74h case    6:*/		return 0x8218BE78;
		  /* 8218BE78h */ case    7:  		/* ori R10, R10, 13532 */
		/* 8218BE78h case    7:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x34DC);
		/* 8218BE78h case    7:*/		return 0x8218BE7C;
		  /* 8218BE7Ch */ case    8:  		/* mr R8, R11 */
		/* 8218BE7Ch case    8:*/		regs.R8 = regs.R11;
		/* 8218BE7Ch case    8:*/		return 0x8218BE80;
	}
	return 0x8218BE80;
} // Block from 8218BE5Ch-8218BE80h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218BE80h
// Function '?ParseRegisterToken@Compiler@D3DXShader@@AAAXPAVCNodeToken@2@W4_D3DXREGISTER_SET@@PAW44@PAIPA_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BE80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BE80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BE80);
		  /* 8218BE80h */ case    0:  		/* rldimi R10, R9, 32, 0 */
		/* 8218BE80h case    0:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R10,regs.R9);
		/* 8218BE80h case    0:*/		return 0x8218BE84;
		  /* 8218BE84h */ case    1:  		/* srd R10, R10, R11 */
		/* 8218BE84h case    1:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8218BE84h case    1:*/		return 0x8218BE88;
		  /* 8218BE88h */ case    2:  		/* srd R10, R10, R11 */
		/* 8218BE88h case    2:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8218BE88h case    2:*/		return 0x8218BE8C;
		  /* 8218BE8Ch */ case    3:  		/* srd R10, R10, R11 */
		/* 8218BE8Ch case    3:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8218BE8Ch case    3:*/		return 0x8218BE90;
		  /* 8218BE90h */ case    4:  		/* rlwinm R10, R10, 0, 29, 31 */
		/* 8218BE90h case    4:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R10);
		/* 8218BE90h case    4:*/		return 0x8218BE94;
		  /* 8218BE94h */ case    5:  		/* cmplw CR6, R10, R31 */
		/* 8218BE94h case    5:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 8218BE94h case    5:*/		return 0x8218BE98;
		  /* 8218BE98h */ case    6:  		/* bc 4, CR6_LT, 44 */
		/* 8218BE98h case    6:*/		if ( !regs.CR[6].lt ) { return 0x8218BEC4;  }
		/* 8218BE98h case    6:*/		return 0x8218BE9C;
		  /* 8218BE9Ch */ case    7:  		/* add R4, R3, R29 */
		/* 8218BE9Ch case    7:*/		cpu::op::add<0>(regs,&regs.R4,regs.R3,regs.R29);
		/* 8218BE9Ch case    7:*/		return 0x8218BEA0;
		  /* 8218BEA0h */ case    8:  		/* add R11, R4, R31 */
		/* 8218BEA0h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R4,regs.R31);
		/* 8218BEA0h case    8:*/		return 0x8218BEA4;
		  /* 8218BEA4h */ case    9:  		/* cmplwi CR6, R11, 256 */
		/* 8218BEA4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000100);
		/* 8218BEA4h case    9:*/		return 0x8218BEA8;
		  /* 8218BEA8h */ case   10:  		/* bc 4, CR6_GT, -104 */
		/* 8218BEA8h case   10:*/		if ( !regs.CR[6].gt ) { return 0x8218BE40;  }
		/* 8218BEA8h case   10:*/		return 0x8218BEAC;
	}
	return 0x8218BEAC;
} // Block from 8218BE80h-8218BEACh (11 instructions)

//////////////////////////////////////////////////////
// Block at 8218BEACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BEAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BEAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BEAC);
		  /* 8218BEACh */ case    0:  		/* li R3, -1 */
		/* 8218BEACh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8218BEACh case    0:*/		return 0x8218BEB0;
		  /* 8218BEB0h */ case    1:  		/* addi R1, R1, 128 */
		/* 8218BEB0h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8218BEB0h case    1:*/		return 0x8218BEB4;
		  /* 8218BEB4h */ case    2:  		/* b -1027080 */
		/* 8218BEB4h case    2:*/		return 0x820912AC;
		/* 8218BEB4h case    2:*/		return 0x8218BEB8;
	}
	return 0x8218BEB8;
} // Block from 8218BEACh-8218BEB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218BEB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BEB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BEB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BEB8);
		  /* 8218BEB8h */ case    0:  		/* rlwinm R11, R3, 4, 0, 27 */
		/* 8218BEB8h case    0:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R3);
		/* 8218BEB8h case    0:*/		return 0x8218BEBC;
		  /* 8218BEBCh */ case    1:  		/* ori R3, R11, 1 */
		/* 8218BEBCh case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R11,0x1);
		/* 8218BEBCh case    1:*/		return 0x8218BEC0;
		  /* 8218BEC0h */ case    2:  		/* b -16 */
		/* 8218BEC0h case    2:*/		return 0x8218BEB0;
		/* 8218BEC0h case    2:*/		return 0x8218BEC4;
	}
	return 0x8218BEC4;
} // Block from 8218BEB8h-8218BEC4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218BEC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BEC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BEC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BEC4);
		  /* 8218BEC4h */ case    0:  		/* nor R11, R11, R11 */
		/* 8218BEC4h case    0:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8218BEC4h case    0:*/		return 0x8218BEC8;
		  /* 8218BEC8h */ case    1:  		/* rlwinm R10, R3, 4, 0, 27 */
		/* 8218BEC8h case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R3);
		/* 8218BEC8h case    1:*/		return 0x8218BECC;
		  /* 8218BECCh */ case    2:  		/* rlwinm R11, R11, 0, 31, 31 */
		/* 8218BECCh case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8218BECCh case    2:*/		return 0x8218BED0;
		  /* 8218BED0h */ case    3:  		/* or R3, R11, R10 */
		/* 8218BED0h case    3:*/		cpu::op::or<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 8218BED0h case    3:*/		return 0x8218BED4;
		  /* 8218BED4h */ case    4:  		/* b -36 */
		/* 8218BED4h case    4:*/		return 0x8218BEB0;
		/* 8218BED4h case    4:*/		return 0x8218BED8;
	}
	return 0x8218BED8;
} // Block from 8218BEC4h-8218BED8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218BED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BED8);
		  /* 8218BED8h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8218BED8h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8218BED8h case    0:*/		return 0x8218BEDC;
		  /* 8218BEDCh */ case    1:  		/* li R8, 2 */
		/* 8218BEDCh case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 8218BEDCh case    1:*/		return 0x8218BEE0;
		  /* 8218BEE0h */ case    2:  		/* rldicl R11, R5, 0, 58 */
		/* 8218BEE0h case    2:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R11,regs.R5);
		/* 8218BEE0h case    2:*/		return 0x8218BEE4;
		  /* 8218BEE4h */ case    3:  		/* rlwinm R7, R4, 26, 6, 31 */
		/* 8218BEE4h case    3:*/		cpu::op::rlwinm<0,26,6,31>(regs,&regs.R7,regs.R4);
		/* 8218BEE4h case    3:*/		return 0x8218BEE8;
		  /* 8218BEE8h */ case    4:  		/* sld R11, R8, R11 */
		/* 8218BEE8h case    4:*/		cpu::op::sld<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 8218BEE8h case    4:*/		return 0x8218BEEC;
		  /* 8218BEECh */ case    5:  		/* rlwinm R10, R4, 29, 3, 28 */
		/* 8218BEECh case    5:*/		cpu::op::rlwinm<0,29,3,28>(regs,&regs.R10,regs.R4);
		/* 8218BEECh case    5:*/		return 0x8218BEF0;
		  /* 8218BEF0h */ case    6:  		/* rlwinm R6, R5, 26, 6, 31 */
		/* 8218BEF0h case    6:*/		cpu::op::rlwinm<0,26,6,31>(regs,&regs.R6,regs.R5);
		/* 8218BEF0h case    6:*/		return 0x8218BEF4;
		  /* 8218BEF4h */ case    7:  		/* rlwinm R9, R5, 29, 3, 28 */
		/* 8218BEF4h case    7:*/		cpu::op::rlwinm<0,29,3,28>(regs,&regs.R9,regs.R5);
		/* 8218BEF4h case    7:*/		return 0x8218BEF8;
		  /* 8218BEF8h */ case    8:  		/* rldicl R8, R4, 0, 58 */
		/* 8218BEF8h case    8:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R8,regs.R4);
		/* 8218BEF8h case    8:*/		return 0x8218BEFC;
		  /* 8218BEFCh */ case    9:  		/* li R31, -1 */
		/* 8218BEFCh case    9:*/		cpu::op::li<0>(regs,&regs.R31,0xFFFFFFFF);
		/* 8218BEFCh case    9:*/		return 0x8218BF00;
		  /* 8218BF00h */ case   10:  		/* add R10, R10, R3 */
		/* 8218BF00h case   10:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 8218BF00h case   10:*/		return 0x8218BF04;
		  /* 8218BF04h */ case   11:  		/* add R9, R9, R3 */
		/* 8218BF04h case   11:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R3);
		/* 8218BF04h case   11:*/		return 0x8218BF08;
		  /* 8218BF08h */ case   12:  		/* addi R11, R11, -1 */
		/* 8218BF08h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8218BF08h case   12:*/		return 0x8218BF0C;
		  /* 8218BF0Ch */ case   13:  		/* sld R8, R31, R8 */
		/* 8218BF0Ch case   13:*/		cpu::op::sld<0>(regs,&regs.R8,regs.R31,regs.R8);
		/* 8218BF0Ch case   13:*/		return 0x8218BF10;
		  /* 8218BF10h */ case   14:  		/* cmplw CR6, R7, R6 */
		/* 8218BF10h case   14:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 8218BF10h case   14:*/		return 0x8218BF14;
		  /* 8218BF14h */ case   15:  		/* bc 4, CR6_EQ, 12 */
		/* 8218BF14h case   15:*/		if ( !regs.CR[6].eq ) { return 0x8218BF20;  }
		/* 8218BF14h case   15:*/		return 0x8218BF18;
		  /* 8218BF18h */ case   16:  		/* and R8, R8, R11 */
		/* 8218BF18h case   16:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 8218BF18h case   16:*/		return 0x8218BF1C;
		  /* 8218BF1Ch */ case   17:  		/* mr R11, R8 */
		/* 8218BF1Ch case   17:*/		regs.R11 = regs.R8;
		/* 8218BF1Ch case   17:*/		return 0x8218BF20;
	}
	return 0x8218BF20;
} // Block from 8218BED8h-8218BF20h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8218BF20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BF20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BF20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BF20);
		  /* 8218BF20h */ case    0:  		/* ld R7, <#[R9]> */
		/* 8218BF20h case    0:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 8218BF20h case    0:*/		return 0x8218BF24;
		  /* 8218BF24h */ case    1:  		/* and R11, R7, R11 */
		/* 8218BF24h case    1:*/		cpu::op::and<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 8218BF24h case    1:*/		return 0x8218BF28;
		  /* 8218BF28h */ case    2:  		/* cmpldi CR6, R11, 0 */
		/* 8218BF28h case    2:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 8218BF28h case    2:*/		return 0x8218BF2C;
		  /* 8218BF2Ch */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 8218BF2Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8218BF44;  }
		/* 8218BF2Ch case    3:*/		return 0x8218BF30;
		  /* 8218BF30h */ case    4:  		/* rlwinm R10, R5, 0, 0, 25 */
		/* 8218BF30h case    4:*/		cpu::op::rlwinm<0,0,0,25>(regs,&regs.R10,regs.R5);
		/* 8218BF30h case    4:*/		return 0x8218BF34;
		  /* 8218BF34h */ case    5:  		/* cntlzd R11, R11 */
		/* 8218BF34h case    5:*/		cpu::op::cntlzd<0>(regs,&regs.R11,regs.R11);
		/* 8218BF34h case    5:*/		return 0x8218BF38;
		  /* 8218BF38h */ case    6:  		/* subf R11, R11, R10 */
		/* 8218BF38h case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8218BF38h case    6:*/		return 0x8218BF3C;
		  /* 8218BF3Ch */ case    7:  		/* addi R3, R11, 63 */
		/* 8218BF3Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x3F);
		/* 8218BF3Ch case    7:*/		return 0x8218BF40;
		  /* 8218BF40h */ case    8:  		/* b 96 */
		/* 8218BF40h case    8:*/		return 0x8218BFA0;
		/* 8218BF40h case    8:*/		return 0x8218BF44;
	}
	return 0x8218BF44;
} // Block from 8218BF20h-8218BF44h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218BF44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BF44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BF44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BF44);
		  /* 8218BF44h */ case    0:  		/* addi R11, R9, -8 */
		/* 8218BF44h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xFFFFFFF8);
		/* 8218BF44h case    0:*/		return 0x8218BF48;
		  /* 8218BF48h */ case    1:  		/* b 20 */
		/* 8218BF48h case    1:*/		return 0x8218BF5C;
		/* 8218BF48h case    1:*/		return 0x8218BF4C;
		  /* 8218BF4Ch */ case    2:  		/* ld R9, <#[R11]> */
		/* 8218BF4Ch case    2:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8218BF4Ch case    2:*/		return 0x8218BF50;
		  /* 8218BF50h */ case    3:  		/* cmpldi CR6, R9, 0 */
		/* 8218BF50h case    3:*/		cpu::op::cmpldi<6>(regs,regs.R9,0x00000000);
		/* 8218BF50h case    3:*/		return 0x8218BF54;
		  /* 8218BF54h */ case    4:  		/* bc 4, CR6_EQ, 40 */
		/* 8218BF54h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8218BF7C;  }
		/* 8218BF54h case    4:*/		return 0x8218BF58;
		  /* 8218BF58h */ case    5:  		/* addi R11, R11, -8 */
		/* 8218BF58h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFF8);
		/* 8218BF58h case    5:*/		return 0x8218BF5C;
	}
	return 0x8218BF5C;
} // Block from 8218BF44h-8218BF5Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218BF5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BF5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BF5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BF5C);
		  /* 8218BF5Ch */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 8218BF5Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8218BF5Ch case    0:*/		return 0x8218BF60;
		  /* 8218BF60h */ case    1:  		/* bc 12, CR6_GT, -20 */
		/* 8218BF60h case    1:*/		if ( regs.CR[6].gt ) { return 0x8218BF4C;  }
		/* 8218BF60h case    1:*/		return 0x8218BF64;
		  /* 8218BF64h */ case    2:  		/* ld R11, <#[R10]> */
		/* 8218BF64h case    2:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8218BF64h case    2:*/		return 0x8218BF68;
		  /* 8218BF68h */ case    3:  		/* and R11, R11, R8 */
		/* 8218BF68h case    3:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8218BF68h case    3:*/		return 0x8218BF6C;
		  /* 8218BF6Ch */ case    4:  		/* cmpldi CR6, R11, 0 */
		/* 8218BF6Ch case    4:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 8218BF6Ch case    4:*/		return 0x8218BF70;
		  /* 8218BF70h */ case    5:  		/* bc 12, CR6_EQ, 44 */
		/* 8218BF70h case    5:*/		if ( regs.CR[6].eq ) { return 0x8218BF9C;  }
		/* 8218BF70h case    5:*/		return 0x8218BF74;
		  /* 8218BF74h */ case    6:  		/* rlwinm R10, R4, 0, 0, 25 */
		/* 8218BF74h case    6:*/		cpu::op::rlwinm<0,0,0,25>(regs,&regs.R10,regs.R4);
		/* 8218BF74h case    6:*/		return 0x8218BF78;
		  /* 8218BF78h */ case    7:  		/* b -68 */
		/* 8218BF78h case    7:*/		return 0x8218BF34;
		/* 8218BF78h case    7:*/		return 0x8218BF7C;
	}
	return 0x8218BF7C;
} // Block from 8218BF5Ch-8218BF7Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218BF7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BF7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BF7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BF7C);
		  /* 8218BF7Ch */ case    0:  		/* subf R11, R10, R11 */
		/* 8218BF7Ch case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218BF7Ch case    0:*/		return 0x8218BF80;
		  /* 8218BF80h */ case    1:  		/* rlwinm R10, R4, 0, 0, 25 */
		/* 8218BF80h case    1:*/		cpu::op::rlwinm<0,0,0,25>(regs,&regs.R10,regs.R4);
		/* 8218BF80h case    1:*/		return 0x8218BF84;
		  /* 8218BF84h */ case    2:  		/* srawi R11, R11, 3 */
		/* 8218BF84h case    2:*/		cpu::op::srawi<0,3>(regs,&regs.R11,regs.R11);
		/* 8218BF84h case    2:*/		return 0x8218BF88;
		  /* 8218BF88h */ case    3:  		/* cntlzd R9, R9 */
		/* 8218BF88h case    3:*/		cpu::op::cntlzd<0>(regs,&regs.R9,regs.R9);
		/* 8218BF88h case    3:*/		return 0x8218BF8C;
		  /* 8218BF8Ch */ case    4:  		/* rlwinm R11, R11, 6, 0, 25 */
		/* 8218BF8Ch case    4:*/		cpu::op::rlwinm<0,6,0,25>(regs,&regs.R11,regs.R11);
		/* 8218BF8Ch case    4:*/		return 0x8218BF90;
		  /* 8218BF90h */ case    5:  		/* add R11, R11, R10 */
		/* 8218BF90h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8218BF90h case    5:*/		return 0x8218BF94;
		  /* 8218BF94h */ case    6:  		/* subf R11, R9, R11 */
		/* 8218BF94h case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8218BF94h case    6:*/		return 0x8218BF98;
		  /* 8218BF98h */ case    7:  		/* b -92 */
		/* 8218BF98h case    7:*/		return 0x8218BF3C;
		/* 8218BF98h case    7:*/		return 0x8218BF9C;
	}
	return 0x8218BF9C;
} // Block from 8218BF7Ch-8218BF9Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218BF9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BF9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BF9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BF9C);
		  /* 8218BF9Ch */ case    0:  		/* li R3, -1 */
		/* 8218BF9Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8218BF9Ch case    0:*/		return 0x8218BFA0;
	}
	return 0x8218BFA0;
} // Block from 8218BF9Ch-8218BFA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218BFA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BFA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BFA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BFA0);
		  /* 8218BFA0h */ case    0:  		/* ld R31, <#[R1 - 8]> */
		/* 8218BFA0h case    0:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8218BFA0h case    0:*/		return 0x8218BFA4;
		  /* 8218BFA4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8218BFA4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218BFA4h case    1:*/		return 0x8218BFA8;
	}
	return 0x8218BFA8;
} // Block from 8218BFA0h-8218BFA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218BFA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BFA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BFA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BFA8);
		  /* 8218BFA8h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8218BFA8h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8218BFA8h case    0:*/		return 0x8218BFAC;
		  /* 8218BFACh */ case    1:  		/* li R7, 2 */
		/* 8218BFACh case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 8218BFACh case    1:*/		return 0x8218BFB0;
		  /* 8218BFB0h */ case    2:  		/* rlwinm R8, R5, 0, 27, 31 */
		/* 8218BFB0h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R5);
		/* 8218BFB0h case    2:*/		return 0x8218BFB4;
		  /* 8218BFB4h */ case    3:  		/* mr R11, R3 */
		/* 8218BFB4h case    3:*/		regs.R11 = regs.R3;
		/* 8218BFB4h case    3:*/		return 0x8218BFB8;
		  /* 8218BFB8h */ case    4:  		/* rlwinm R10, R4, 29, 3, 29 */
		/* 8218BFB8h case    4:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R4);
		/* 8218BFB8h case    4:*/		return 0x8218BFBC;
		  /* 8218BFBCh */ case    5:  		/* rlwinm R9, R5, 29, 3, 29 */
		/* 8218BFBCh case    5:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R5);
		/* 8218BFBCh case    5:*/		return 0x8218BFC0;
		  /* 8218BFC0h */ case    6:  		/* slw R8, R7, R8 */
		/* 8218BFC0h case    6:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 8218BFC0h case    6:*/		return 0x8218BFC4;
		  /* 8218BFC4h */ case    7:  		/* li R3, -1 */
		/* 8218BFC4h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8218BFC4h case    7:*/		return 0x8218BFC8;
		  /* 8218BFC8h */ case    8:  		/* rlwinm R7, R4, 27, 5, 31 */
		/* 8218BFC8h case    8:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R7,regs.R4);
		/* 8218BFC8h case    8:*/		return 0x8218BFCC;
		  /* 8218BFCCh */ case    9:  		/* rlwinm R6, R5, 27, 5, 31 */
		/* 8218BFCCh case    9:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R6,regs.R5);
		/* 8218BFCCh case    9:*/		return 0x8218BFD0;
		  /* 8218BFD0h */ case   10:  		/* rlwinm R31, R4, 0, 27, 31 */
		/* 8218BFD0h case   10:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R31,regs.R4);
		/* 8218BFD0h case   10:*/		return 0x8218BFD4;
		  /* 8218BFD4h */ case   11:  		/* add R10, R10, R11 */
		/* 8218BFD4h case   11:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8218BFD4h case   11:*/		return 0x8218BFD8;
		  /* 8218BFD8h */ case   12:  		/* add R9, R9, R11 */
		/* 8218BFD8h case   12:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 8218BFD8h case   12:*/		return 0x8218BFDC;
		  /* 8218BFDCh */ case   13:  		/* addi R11, R8, -1 */
		/* 8218BFDCh case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0xFFFFFFFF);
		/* 8218BFDCh case   13:*/		return 0x8218BFE0;
		  /* 8218BFE0h */ case   14:  		/* slw R8, R3, R31 */
		/* 8218BFE0h case   14:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R3,regs.R31);
		/* 8218BFE0h case   14:*/		return 0x8218BFE4;
		  /* 8218BFE4h */ case   15:  		/* cmplw CR6, R7, R6 */
		/* 8218BFE4h case   15:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 8218BFE4h case   15:*/		return 0x8218BFE8;
		  /* 8218BFE8h */ case   16:  		/* bc 4, CR6_EQ, 12 */
		/* 8218BFE8h case   16:*/		if ( !regs.CR[6].eq ) { return 0x8218BFF4;  }
		/* 8218BFE8h case   16:*/		return 0x8218BFEC;
		  /* 8218BFECh */ case   17:  		/* and R8, R8, R11 */
		/* 8218BFECh case   17:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 8218BFECh case   17:*/		return 0x8218BFF0;
		  /* 8218BFF0h */ case   18:  		/* mr R11, R8 */
		/* 8218BFF0h case   18:*/		regs.R11 = regs.R8;
		/* 8218BFF0h case   18:*/		return 0x8218BFF4;
	}
	return 0x8218BFF4;
} // Block from 8218BFA8h-8218BFF4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8218BFF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218BFF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218BFF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218BFF4);
		  /* 8218BFF4h */ case    0:  		/* lwz R7, <#[R9]> */
		/* 8218BFF4h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 8218BFF4h case    0:*/		return 0x8218BFF8;
		  /* 8218BFF8h */ case    1:  		/* and. R11, R7, R11 */
		/* 8218BFF8h case    1:*/		cpu::op::and<1>(regs,&regs.R11,regs.R7,regs.R11);
		/* 8218BFF8h case    1:*/		return 0x8218BFFC;
		  /* 8218BFFCh */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 8218BFFCh case    2:*/		if ( regs.CR[0].eq ) { return 0x8218C008;  }
		/* 8218BFFCh case    2:*/		return 0x8218C000;
		  /* 8218C000h */ case    3:  		/* rlwinm R10, R5, 0, 0, 26 */
		/* 8218C000h case    3:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R10,regs.R5);
		/* 8218C000h case    3:*/		return 0x8218C004;
		  /* 8218C004h */ case    4:  		/* b 52 */
		/* 8218C004h case    4:*/		return 0x8218C038;
		/* 8218C004h case    4:*/		return 0x8218C008;
	}
	return 0x8218C008;
} // Block from 8218BFF4h-8218C008h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218C008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C008);
		  /* 8218C008h */ case    0:  		/* addi R11, R9, -4 */
		/* 8218C008h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xFFFFFFFC);
		/* 8218C008h case    0:*/		return 0x8218C00C;
		  /* 8218C00Ch */ case    1:  		/* b 20 */
		/* 8218C00Ch case    1:*/		return 0x8218C020;
		/* 8218C00Ch case    1:*/		return 0x8218C010;
		  /* 8218C010h */ case    2:  		/* lwz R9, <#[R11]> */
		/* 8218C010h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8218C010h case    2:*/		return 0x8218C014;
		  /* 8218C014h */ case    3:  		/* cmplwi CR6, R9, 0 */
		/* 8218C014h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8218C014h case    3:*/		return 0x8218C018;
		  /* 8218C018h */ case    4:  		/* bc 4, CR6_EQ, 52 */
		/* 8218C018h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8218C04C;  }
		/* 8218C018h case    4:*/		return 0x8218C01C;
		  /* 8218C01Ch */ case    5:  		/* addi R11, R11, -4 */
		/* 8218C01Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8218C01Ch case    5:*/		return 0x8218C020;
	}
	return 0x8218C020;
} // Block from 8218C008h-8218C020h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218C020h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C020);
		  /* 8218C020h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 8218C020h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8218C020h case    0:*/		return 0x8218C024;
		  /* 8218C024h */ case    1:  		/* bc 12, CR6_GT, -20 */
		/* 8218C024h case    1:*/		if ( regs.CR[6].gt ) { return 0x8218C010;  }
		/* 8218C024h case    1:*/		return 0x8218C028;
		  /* 8218C028h */ case    2:  		/* lwz R11, <#[R10]> */
		/* 8218C028h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8218C028h case    2:*/		return 0x8218C02C;
		  /* 8218C02Ch */ case    3:  		/* and. R11, R11, R8 */
		/* 8218C02Ch case    3:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8218C02Ch case    3:*/		return 0x8218C030;
		  /* 8218C030h */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 8218C030h case    4:*/		if ( regs.CR[0].eq ) { return 0x8218C044;  }
		/* 8218C030h case    4:*/		return 0x8218C034;
		  /* 8218C034h */ case    5:  		/* rlwinm R10, R4, 0, 0, 26 */
		/* 8218C034h case    5:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R10,regs.R4);
		/* 8218C034h case    5:*/		return 0x8218C038;
	}
	return 0x8218C038;
} // Block from 8218C020h-8218C038h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218C038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C038);
		  /* 8218C038h */ case    0:  		/* cntlzw R11, R11 */
		/* 8218C038h case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8218C038h case    0:*/		return 0x8218C03C;
		  /* 8218C03Ch */ case    1:  		/* subf R11, R11, R10 */
		/* 8218C03Ch case    1:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8218C03Ch case    1:*/		return 0x8218C040;
		  /* 8218C040h */ case    2:  		/* addi R3, R11, 31 */
		/* 8218C040h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1F);
		/* 8218C040h case    2:*/		return 0x8218C044;
	}
	return 0x8218C044;
} // Block from 8218C038h-8218C044h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218C044h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C044( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C044) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C044);
		  /* 8218C044h */ case    0:  		/* ld R31, <#[R1 - 8]> */
		/* 8218C044h case    0:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8218C044h case    0:*/		return 0x8218C048;
		  /* 8218C048h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8218C048h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218C048h case    1:*/		return 0x8218C04C;
	}
	return 0x8218C04C;
} // Block from 8218C044h-8218C04Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218C04Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C04C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C04C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C04C);
		  /* 8218C04Ch */ case    0:  		/* subf R11, R10, R11 */
		/* 8218C04Ch case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218C04Ch case    0:*/		return 0x8218C050;
		  /* 8218C050h */ case    1:  		/* rlwinm R10, R4, 0, 0, 26 */
		/* 8218C050h case    1:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R10,regs.R4);
		/* 8218C050h case    1:*/		return 0x8218C054;
		  /* 8218C054h */ case    2:  		/* srawi R11, R11, 2 */
		/* 8218C054h case    2:*/		cpu::op::srawi<0,2>(regs,&regs.R11,regs.R11);
		/* 8218C054h case    2:*/		return 0x8218C058;
		  /* 8218C058h */ case    3:  		/* cntlzw R9, R9 */
		/* 8218C058h case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R9,regs.R9);
		/* 8218C058h case    3:*/		return 0x8218C05C;
		  /* 8218C05Ch */ case    4:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 8218C05Ch case    4:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 8218C05Ch case    4:*/		return 0x8218C060;
		  /* 8218C060h */ case    5:  		/* add R11, R11, R10 */
		/* 8218C060h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8218C060h case    5:*/		return 0x8218C064;
		  /* 8218C064h */ case    6:  		/* subf R11, R9, R11 */
		/* 8218C064h case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8218C064h case    6:*/		return 0x8218C068;
		  /* 8218C068h */ case    7:  		/* b -40 */
		/* 8218C068h case    7:*/		return 0x8218C040;
		/* 8218C068h case    7:*/		return 0x8218C06C;
		  /* 8218C06Ch */ case    8:  		/* nop */
		/* 8218C06Ch case    8:*/		cpu::op::nop();
		/* 8218C06Ch case    8:*/		return 0x8218C070;
	}
	return 0x8218C070;
} // Block from 8218C04Ch-8218C070h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218C070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C070);
		  /* 8218C070h */ case    0:  		/* mfspr R12, LR */
		/* 8218C070h case    0:*/		regs.R12 = regs.LR;
		/* 8218C070h case    0:*/		return 0x8218C074;
		  /* 8218C074h */ case    1:  		/* bl -1027612 */
		/* 8218C074h case    1:*/		regs.LR = 0x8218C078; return 0x82091258;
		/* 8218C074h case    1:*/		return 0x8218C078;
		  /* 8218C078h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8218C078h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8218C078h case    2:*/		return 0x8218C07C;
		  /* 8218C07Ch */ case    3:  		/* mr R28, R5 */
		/* 8218C07Ch case    3:*/		regs.R28 = regs.R5;
		/* 8218C07Ch case    3:*/		return 0x8218C080;
		  /* 8218C080h */ case    4:  		/* mr R29, R4 */
		/* 8218C080h case    4:*/		regs.R29 = regs.R4;
		/* 8218C080h case    4:*/		return 0x8218C084;
		  /* 8218C084h */ case    5:  		/* mr R5, R4 */
		/* 8218C084h case    5:*/		regs.R5 = regs.R4;
		/* 8218C084h case    5:*/		return 0x8218C088;
	}
	return 0x8218C088;
} // Block from 8218C070h-8218C088h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218C088h
// Function '?CompareConstants@D3DXShader@@YAHPBX0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C088);
		  /* 8218C088h */ case    0:  		/* li R6, 4 */
		/* 8218C088h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 8218C088h case    0:*/		return 0x8218C08C;
		  /* 8218C08Ch */ case    1:  		/* li R4, 0 */
		/* 8218C08Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8218C08Ch case    1:*/		return 0x8218C090;
		  /* 8218C090h */ case    2:  		/* mr R30, R3 */
		/* 8218C090h case    2:*/		regs.R30 = regs.R3;
		/* 8218C090h case    2:*/		return 0x8218C094;
		  /* 8218C094h */ case    3:  		/* bl -1484 */
		/* 8218C094h case    3:*/		regs.LR = 0x8218C098; return 0x8218BAC8;
		/* 8218C094h case    3:*/		return 0x8218C098;
		  /* 8218C098h */ case    4:  		/* mr R31, R3 */
		/* 8218C098h case    4:*/		regs.R31 = regs.R3;
		/* 8218C098h case    4:*/		return 0x8218C09C;
		  /* 8218C09Ch */ case    5:  		/* cmpwi CR6, R3, -1 */
		/* 8218C09Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218C09Ch case    5:*/		return 0x8218C0A0;
		  /* 8218C0A0h */ case    6:  		/* bc 4, CR6_EQ, 32 */
		/* 8218C0A0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8218C0C0;  }
		/* 8218C0A0h case    6:*/		return 0x8218C0A4;
		  /* 8218C0A4h */ case    7:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 8218C0A4h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 8218C0A4h case    7:*/		return 0x8218C0A8;
	}
	return 0x8218C0A8;
} // Block from 8218C088h-8218C0A8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218C0A8h
// Function '?FindSetBit@?$FixedSizeBitSet@_K$0BA@@D3DXShader@@QAAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C0A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C0A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C0A8);
		  /* 8218C0A8h */ case    0:  		/* bc 12, CR0_EQ, 16 */
		/* 8218C0A8h case    0:*/		if ( regs.CR[0].eq ) { return 0x8218C0B8;  }
		/* 8218C0A8h case    0:*/		return 0x8218C0AC;
		  /* 8218C0ACh */ case    1:  		/* li R4, 3566 */
		/* 8218C0ACh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xDEE);
		/* 8218C0ACh case    1:*/		return 0x8218C0B0;
		  /* 8218C0B0h */ case    2:  		/* lwz R3, <#[R30]> */
		/* 8218C0B0h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 8218C0B0h case    2:*/		return 0x8218C0B4;
		  /* 8218C0B4h */ case    3:  		/* bl -238156 */
		/* 8218C0B4h case    3:*/		regs.LR = 0x8218C0B8; return 0x82151E68;
		/* 8218C0B4h case    3:*/		return 0x8218C0B8;
	}
	return 0x8218C0B8;
} // Block from 8218C0A8h-8218C0B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218C0B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C0B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C0B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C0B8);
		  /* 8218C0B8h */ case    0:  		/* li R3, -1 */
		/* 8218C0B8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8218C0B8h case    0:*/		return 0x8218C0BC;
		  /* 8218C0BCh */ case    1:  		/* b 60 */
		/* 8218C0BCh case    1:*/		return 0x8218C0F8;
		/* 8218C0BCh case    1:*/		return 0x8218C0C0;
	}
	return 0x8218C0C0;
} // Block from 8218C0B8h-8218C0C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218C0C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C0C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C0C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C0C0);
		  /* 8218C0C0h */ case    0:  		/* mr R4, R29 */
		/* 8218C0C0h case    0:*/		regs.R4 = regs.R29;
		/* 8218C0C0h case    0:*/		return 0x8218C0C4;
		  /* 8218C0C4h */ case    1:  		/* rlwinm R3, R31, 0, 28, 31 */
		/* 8218C0C4h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R3,regs.R31);
		/* 8218C0C4h case    1:*/		return 0x8218C0C8;
		  /* 8218C0C8h */ case    2:  		/* rlwinm R29, R31, 30, 2, 29 */
		/* 8218C0C8h case    2:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R29,regs.R31);
		/* 8218C0C8h case    2:*/		return 0x8218C0CC;
		  /* 8218C0CCh */ case    3:  		/* bl -111628 */
		/* 8218C0CCh case    3:*/		regs.LR = 0x8218C0D0; return 0x82170CC0;
		/* 8218C0CCh case    3:*/		return 0x8218C0D0;
		  /* 8218C0D0h */ case    4:  		/* rlwinm R11, R31, 24, 8, 31 */
		/* 8218C0D0h case    4:*/		cpu::op::rlwinm<0,24,8,31>(regs,&regs.R11,regs.R31);
		/* 8218C0D0h case    4:*/		return 0x8218C0D4;
		  /* 8218C0D4h */ case    5:  		/* rldicl R10, R3, 0, 32 */
		/* 8218C0D4h case    5:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R3);
		/* 8218C0D4h case    5:*/		return 0x8218C0D8;
		  /* 8218C0D8h */ case    6:  		/* addi R11, R11, 1 */
		/* 8218C0D8h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218C0D8h case    6:*/		return 0x8218C0DC;
		  /* 8218C0DCh */ case    7:  		/* rldicl R9, R29, 0, 58 */
		/* 8218C0DCh case    7:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R9,regs.R29);
		/* 8218C0DCh case    7:*/		return 0x8218C0E0;
		  /* 8218C0E0h */ case    8:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8218C0E0h case    8:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8218C0E0h case    8:*/		return 0x8218C0E4;
		  /* 8218C0E4h */ case    9:  		/* sld R10, R10, R9 */
		/* 8218C0E4h case    9:*/		cpu::op::sld<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8218C0E4h case    9:*/		return 0x8218C0E8;
		  /* 8218C0E8h */ case   10:  		/* ldx R9, <#[R11 + R30]> */
		/* 8218C0E8h case   10:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8218C0E8h case   10:*/		return 0x8218C0EC;
		  /* 8218C0ECh */ case   11:  		/* rlwimi R3, R31, 0, 0, 27 */
		/* 8218C0ECh case   11:*/		cpu::op::rlwimi<0,0,0,27>(regs,&regs.R3,regs.R31);
		/* 8218C0ECh case   11:*/		return 0x8218C0F0;
		  /* 8218C0F0h */ case   12:  		/* or R10, R10, R9 */
		/* 8218C0F0h case   12:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8218C0F0h case   12:*/		return 0x8218C0F4;
		  /* 8218C0F4h */ case   13:  		/* stdx R10, <#[R11 + R30]> */
		/* 8218C0F4h case   13:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8218C0F4h case   13:*/		return 0x8218C0F8;
	}
	return 0x8218C0F8;
} // Block from 8218C0C0h-8218C0F8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8218C0F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C0F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C0F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C0F8);
		  /* 8218C0F8h */ case    0:  		/* addi R1, R1, 128 */
		/* 8218C0F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8218C0F8h case    0:*/		return 0x8218C0FC;
		  /* 8218C0FCh */ case    1:  		/* b -1027668 */
		/* 8218C0FCh case    1:*/		return 0x820912A8;
		/* 8218C0FCh case    1:*/		return 0x8218C100;
	}
	return 0x8218C100;
} // Block from 8218C0F8h-8218C100h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218C100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C100);
		  /* 8218C100h */ case    0:  		/* mfspr R12, LR */
		/* 8218C100h case    0:*/		regs.R12 = regs.LR;
		/* 8218C100h case    0:*/		return 0x8218C104;
		  /* 8218C104h */ case    1:  		/* bl -1027752 */
		/* 8218C104h case    1:*/		regs.LR = 0x8218C108; return 0x8209125C;
		/* 8218C104h case    1:*/		return 0x8218C108;
		  /* 8218C108h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8218C108h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8218C108h case    2:*/		return 0x8218C10C;
		  /* 8218C10Ch */ case    3:  		/* mr R29, R4 */
		/* 8218C10Ch case    3:*/		regs.R29 = regs.R4;
		/* 8218C10Ch case    3:*/		return 0x8218C110;
	}
	return 0x8218C110;
} // Block from 8218C100h-8218C110h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218C110h
// Function '?FindClearBit@?$FixedSizeBitSet@_K$0BA@@D3DXShader@@QAAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C110);
		  /* 8218C110h */ case    0:  		/* mr R5, R4 */
		/* 8218C110h case    0:*/		regs.R5 = regs.R4;
		/* 8218C110h case    0:*/		return 0x8218C114;
		  /* 8218C114h */ case    1:  		/* li R6, -4 */
		/* 8218C114h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFC);
		/* 8218C114h case    1:*/		return 0x8218C118;
		  /* 8218C118h */ case    2:  		/* li R4, 255 */
		/* 8218C118h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0xFF);
		/* 8218C118h case    2:*/		return 0x8218C11C;
		  /* 8218C11Ch */ case    3:  		/* mr R30, R3 */
		/* 8218C11Ch case    3:*/		regs.R30 = regs.R3;
		/* 8218C11Ch case    3:*/		return 0x8218C120;
		  /* 8218C120h */ case    4:  		/* bl -1624 */
		/* 8218C120h case    4:*/		regs.LR = 0x8218C124; return 0x8218BAC8;
		/* 8218C120h case    4:*/		return 0x8218C124;
		  /* 8218C124h */ case    5:  		/* mr R31, R3 */
		/* 8218C124h case    5:*/		regs.R31 = regs.R3;
		/* 8218C124h case    5:*/		return 0x8218C128;
		  /* 8218C128h */ case    6:  		/* cmpwi CR6, R3, -1 */
		/* 8218C128h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218C128h case    6:*/		return 0x8218C12C;
		  /* 8218C12Ch */ case    7:  		/* bc 4, CR6_EQ, 16 */
		/* 8218C12Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x8218C13C;  }
		/* 8218C12Ch case    7:*/		return 0x8218C130;
		  /* 8218C130h */ case    8:  		/* li R4, 3566 */
		/* 8218C130h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0xDEE);
		/* 8218C130h case    8:*/		return 0x8218C134;
		  /* 8218C134h */ case    9:  		/* lwz R3, <#[R30]> */
		/* 8218C134h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 8218C134h case    9:*/		return 0x8218C138;
		  /* 8218C138h */ case   10:  		/* bl -238288 */
		/* 8218C138h case   10:*/		regs.LR = 0x8218C13C; return 0x82151E68;
		/* 8218C138h case   10:*/		return 0x8218C13C;
	}
	return 0x8218C13C;
} // Block from 8218C110h-8218C13Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8218C13Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C13C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C13C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C13C);
		  /* 8218C13Ch */ case    0:  		/* mr R4, R29 */
		/* 8218C13Ch case    0:*/		regs.R4 = regs.R29;
		/* 8218C13Ch case    0:*/		return 0x8218C140;
		  /* 8218C140h */ case    1:  		/* rlwinm R3, R31, 0, 28, 31 */
		/* 8218C140h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R3,regs.R31);
		/* 8218C140h case    1:*/		return 0x8218C144;
		  /* 8218C144h */ case    2:  		/* rlwinm R29, R31, 30, 2, 29 */
		/* 8218C144h case    2:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R29,regs.R31);
		/* 8218C144h case    2:*/		return 0x8218C148;
		  /* 8218C148h */ case    3:  		/* bl -111752 */
		/* 8218C148h case    3:*/		regs.LR = 0x8218C14C; return 0x82170CC0;
		/* 8218C148h case    3:*/		return 0x8218C14C;
		  /* 8218C14Ch */ case    4:  		/* rlwinm R11, R31, 24, 8, 31 */
		/* 8218C14Ch case    4:*/		cpu::op::rlwinm<0,24,8,31>(regs,&regs.R11,regs.R31);
		/* 8218C14Ch case    4:*/		return 0x8218C150;
		  /* 8218C150h */ case    5:  		/* rldicl R10, R3, 0, 32 */
		/* 8218C150h case    5:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R3);
		/* 8218C150h case    5:*/		return 0x8218C154;
		  /* 8218C154h */ case    6:  		/* addi R11, R11, 1 */
		/* 8218C154h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218C154h case    6:*/		return 0x8218C158;
		  /* 8218C158h */ case    7:  		/* rldicl R9, R29, 0, 58 */
		/* 8218C158h case    7:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R9,regs.R29);
		/* 8218C158h case    7:*/		return 0x8218C15C;
		  /* 8218C15Ch */ case    8:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8218C15Ch case    8:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8218C15Ch case    8:*/		return 0x8218C160;
		  /* 8218C160h */ case    9:  		/* sld R10, R10, R9 */
		/* 8218C160h case    9:*/		cpu::op::sld<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8218C160h case    9:*/		return 0x8218C164;
		  /* 8218C164h */ case   10:  		/* ldx R9, <#[R11 + R30]> */
		/* 8218C164h case   10:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8218C164h case   10:*/		return 0x8218C168;
		  /* 8218C168h */ case   11:  		/* rlwimi R3, R31, 0, 0, 27 */
		/* 8218C168h case   11:*/		cpu::op::rlwimi<0,0,0,27>(regs,&regs.R3,regs.R31);
		/* 8218C168h case   11:*/		return 0x8218C16C;
		  /* 8218C16Ch */ case   12:  		/* or R10, R10, R9 */
		/* 8218C16Ch case   12:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8218C16Ch case   12:*/		return 0x8218C170;
		  /* 8218C170h */ case   13:  		/* stdx R10, <#[R11 + R30]> */
		/* 8218C170h case   13:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8218C170h case   13:*/		return 0x8218C174;
		  /* 8218C174h */ case   14:  		/* addi R1, R1, 112 */
		/* 8218C174h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8218C174h case   14:*/		return 0x8218C178;
	}
	return 0x8218C178;
} // Block from 8218C13Ch-8218C178h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8218C178h
// Function '?FindNibbleWithClearBit@?$FixedSizeBitSet@_K$0BA@@D3DXShader@@QAAIIPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C178);
		  /* 8218C178h */ case    0:  		/* b -1027788 */
		/* 8218C178h case    0:*/		return 0x820912AC;
		/* 8218C178h case    0:*/		return 0x8218C17C;
		  /* 8218C17Ch */ case    1:  		/* nop */
		/* 8218C17Ch case    1:*/		cpu::op::nop();
		/* 8218C17Ch case    1:*/		return 0x8218C180;
	}
	return 0x8218C180;
} // Block from 8218C178h-8218C180h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218C180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C180);
		  /* 8218C180h */ case    0:  		/* mfspr R12, LR */
		/* 8218C180h case    0:*/		regs.R12 = regs.LR;
		/* 8218C180h case    0:*/		return 0x8218C184;
		  /* 8218C184h */ case    1:  		/* bl -1027880 */
		/* 8218C184h case    1:*/		regs.LR = 0x8218C188; return 0x8209125C;
		/* 8218C184h case    1:*/		return 0x8218C188;
		  /* 8218C188h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8218C188h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8218C188h case    2:*/		return 0x8218C18C;
		  /* 8218C18Ch */ case    3:  		/* addi R29, R3, 8 */
		/* 8218C18Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R3,0x8);
		/* 8218C18Ch case    3:*/		return 0x8218C190;
		  /* 8218C190h */ case    4:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 8218C190h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 8218C190h case    4:*/		return 0x8218C194;
		  /* 8218C194h */ case    5:  		/* mr R3, R29 */
		/* 8218C194h case    5:*/		regs.R3 = regs.R29;
		/* 8218C194h case    5:*/		return 0x8218C198;
		  /* 8218C198h */ case    6:  		/* mr R30, R5 */
		/* 8218C198h case    6:*/		regs.R30 = regs.R5;
		/* 8218C198h case    6:*/		return 0x8218C19C;
		  /* 8218C19Ch */ case    7:  		/* bl -2492 */
		/* 8218C19Ch case    7:*/		regs.LR = 0x8218C1A0; return 0x8218B7E0;
		/* 8218C19Ch case    7:*/		return 0x8218C1A0;
		  /* 8218C1A0h */ case    8:  		/* mr R31, R3 */
		/* 8218C1A0h case    8:*/		regs.R31 = regs.R3;
		/* 8218C1A0h case    8:*/		return 0x8218C1A4;
		  /* 8218C1A4h */ case    9:  		/* cmpwi CR6, R3, -1 */
		/* 8218C1A4h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218C1A4h case    9:*/		return 0x8218C1A8;
		  /* 8218C1A8h */ case   10:  		/* bc 4, CR6_EQ, 12 */
		/* 8218C1A8h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8218C1B4;  }
		/* 8218C1A8h case   10:*/		return 0x8218C1AC;
		  /* 8218C1ACh */ case   11:  		/* li R3, -1 */
		/* 8218C1ACh case   11:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8218C1ACh case   11:*/		return 0x8218C1B0;
		  /* 8218C1B0h */ case   12:  		/* b 76 */
		/* 8218C1B0h case   12:*/		return 0x8218C1FC;
		/* 8218C1B0h case   12:*/		return 0x8218C1B4;
	}
	return 0x8218C1B4;
} // Block from 8218C180h-8218C1B4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8218C1B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C1B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C1B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C1B4);
		  /* 8218C1B4h */ case    0:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 8218C1B4h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 8218C1B4h case    0:*/		return 0x8218C1B8;
		  /* 8218C1B8h */ case    1:  		/* b 48 */
		/* 8218C1B8h case    1:*/		return 0x8218C1E8;
		/* 8218C1B8h case    1:*/		return 0x8218C1BC;
		  /* 8218C1BCh */ case    2:  		/* addi R5, R11, -1 */
		/* 8218C1BCh case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 8218C1BCh case    2:*/		return 0x8218C1C0;
		  /* 8218C1C0h */ case    3:  		/* mr R4, R31 */
		/* 8218C1C0h case    3:*/		regs.R4 = regs.R31;
		/* 8218C1C0h case    3:*/		return 0x8218C1C4;
		  /* 8218C1C4h */ case    4:  		/* mr R3, R29 */
		/* 8218C1C4h case    4:*/		regs.R3 = regs.R29;
		/* 8218C1C4h case    4:*/		return 0x8218C1C8;
		  /* 8218C1C8h */ case    5:  		/* bl -752 */
		/* 8218C1C8h case    5:*/		regs.LR = 0x8218C1CC; return 0x8218BED8;
		/* 8218C1C8h case    5:*/		return 0x8218C1CC;
		  /* 8218C1CCh */ case    6:  		/* cmpwi CR6, R3, -1 */
		/* 8218C1CCh case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218C1CCh case    6:*/		return 0x8218C1D0;
		  /* 8218C1D0h */ case    7:  		/* bc 4, CR6_EQ, 16 */
		/* 8218C1D0h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8218C1E0;  }
		/* 8218C1D0h case    7:*/		return 0x8218C1D4;
		  /* 8218C1D4h */ case    8:  		/* rlwinm. R11, R31, 0, 30, 31 */
		/* 8218C1D4h case    8:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R11,regs.R31);
		/* 8218C1D4h case    8:*/		return 0x8218C1D8;
		  /* 8218C1D8h */ case    9:  		/* bc 12, CR0_EQ, 32 */
		/* 8218C1D8h case    9:*/		if ( regs.CR[0].eq ) { return 0x8218C1F8;  }
		/* 8218C1D8h case    9:*/		return 0x8218C1DC;
		  /* 8218C1DCh */ case   10:  		/* mr R3, R31 */
		/* 8218C1DCh case   10:*/		regs.R3 = regs.R31;
		/* 8218C1DCh case   10:*/		return 0x8218C1E0;
	}
	return 0x8218C1E0;
} // Block from 8218C1B4h-8218C1E0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8218C1E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C1E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C1E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C1E0);
		  /* 8218C1E0h */ case    0:  		/* addi R11, R3, 4 */
		/* 8218C1E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x4);
		/* 8218C1E0h case    0:*/		return 0x8218C1E4;
		  /* 8218C1E4h */ case    1:  		/* rlwinm R31, R11, 0, 0, 29 */
		/* 8218C1E4h case    1:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R31,regs.R11);
		/* 8218C1E4h case    1:*/		return 0x8218C1E8;
	}
	return 0x8218C1E8;
} // Block from 8218C1E0h-8218C1E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218C1E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C1E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C1E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C1E8);
		  /* 8218C1E8h */ case    0:  		/* add R11, R30, R31 */
		/* 8218C1E8h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R31);
		/* 8218C1E8h case    0:*/		return 0x8218C1EC;
		  /* 8218C1ECh */ case    1:  		/* cmplwi CR6, R11, 1024 */
		/* 8218C1ECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000400);
		/* 8218C1ECh case    1:*/		return 0x8218C1F0;
	}
	return 0x8218C1F0;
} // Block from 8218C1E8h-8218C1F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218C1F0h
// Function '?FindClearBit@?$FixedSizeBitSet@_K$03@D3DXShader@@QAAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C1F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C1F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C1F0);
		  /* 8218C1F0h */ case    0:  		/* bc 4, CR6_GT, -52 */
		/* 8218C1F0h case    0:*/		if ( !regs.CR[6].gt ) { return 0x8218C1BC;  }
		/* 8218C1F0h case    0:*/		return 0x8218C1F4;
		  /* 8218C1F4h */ case    1:  		/* b -72 */
		/* 8218C1F4h case    1:*/		return 0x8218C1AC;
		/* 8218C1F4h case    1:*/		return 0x8218C1F8;
	}
	return 0x8218C1F8;
} // Block from 8218C1F0h-8218C1F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218C1F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C1F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C1F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C1F8);
		  /* 8218C1F8h */ case    0:  		/* rlwinm R3, R31, 30, 2, 31 */
		/* 8218C1F8h case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R3,regs.R31);
		/* 8218C1F8h case    0:*/		return 0x8218C1FC;
	}
	return 0x8218C1FC;
} // Block from 8218C1F8h-8218C1FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218C1FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C1FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C1FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C1FC);
		  /* 8218C1FCh */ case    0:  		/* addi R1, R1, 112 */
		/* 8218C1FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8218C1FCh case    0:*/		return 0x8218C200;
		  /* 8218C200h */ case    1:  		/* b -1027924 */
		/* 8218C200h case    1:*/		return 0x820912AC;
		/* 8218C200h case    1:*/		return 0x8218C204;
		  /* 8218C204h */ case    2:  		/* nop */
		/* 8218C204h case    2:*/		cpu::op::nop();
		/* 8218C204h case    2:*/		return 0x8218C208;
		  /* 8218C208h */ case    3:  		/* rlwinm R10, R4, 23, 9, 31 */
		/* 8218C208h case    3:*/		cpu::op::rlwinm<0,23,9,31>(regs,&regs.R10,regs.R4);
		/* 8218C208h case    3:*/		return 0x8218C20C;
		  /* 8218C20Ch */ case    4:  		/* rlwinm R11, R4, 28, 27, 31 */
		/* 8218C20Ch case    4:*/		cpu::op::rlwinm<0,28,27,31>(regs,&regs.R11,regs.R4);
		/* 8218C20Ch case    4:*/		return 0x8218C210;
		  /* 8218C210h */ case    5:  		/* addi R10, R10, 1 */
		/* 8218C210h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8218C210h case    5:*/		return 0x8218C214;
		  /* 8218C214h */ case    6:  		/* li R9, 2 */
		/* 8218C214h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 8218C214h case    6:*/		return 0x8218C218;
		  /* 8218C218h */ case    7:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8218C218h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8218C218h case    7:*/		return 0x8218C21C;
		  /* 8218C21Ch */ case    8:  		/* slw R9, R9, R11 */
		/* 8218C21Ch case    8:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 8218C21Ch case    8:*/		return 0x8218C220;
		  /* 8218C220h */ case    9:  		/* li R8, -1 */
		/* 8218C220h case    9:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 8218C220h case    9:*/		return 0x8218C224;
		  /* 8218C224h */ case   10:  		/* lwzx R7, <#[R10 + R3]> */
		/* 8218C224h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 8218C224h case   10:*/		return 0x8218C228;
		  /* 8218C228h */ case   11:  		/* addi R9, R9, -1 */
		/* 8218C228h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8218C228h case   11:*/		return 0x8218C22C;
		  /* 8218C22Ch */ case   12:  		/* slw R8, R8, R11 */
		/* 8218C22Ch case   12:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 8218C22Ch case   12:*/		return 0x8218C230;
		  /* 8218C230h */ case   13:  		/* and R8, R9, R8 */
		/* 8218C230h case   13:*/		cpu::op::and<0>(regs,&regs.R8,regs.R9,regs.R8);
		/* 8218C230h case   13:*/		return 0x8218C234;
		  /* 8218C234h */ case   14:  		/* rlwinm R9, R4, 0, 28, 31 */
		/* 8218C234h case   14:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R9,regs.R4);
		/* 8218C234h case   14:*/		return 0x8218C238;
		  /* 8218C238h */ case   15:  		/* and R8, R8, R7 */
		/* 8218C238h case   15:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8218C238h case   15:*/		return 0x8218C23C;
		  /* 8218C23Ch */ case   16:  		/* rlwinm R5, R4, 28, 4, 31 */
		/* 8218C23Ch case   16:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R5,regs.R4);
		/* 8218C23Ch case   16:*/		return 0x8218C240;
		  /* 8218C240h */ case   17:  		/* srw R8, R8, R11 */
		/* 8218C240h case   17:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 8218C240h case   17:*/		return 0x8218C244;
		  /* 8218C244h */ case   18:  		/* and. R8, R8, R9 */
		/* 8218C244h case   18:*/		cpu::op::and<1>(regs,&regs.R8,regs.R8,regs.R9);
		/* 8218C244h case   18:*/		return 0x8218C248;
		  /* 8218C248h */ case   19:  		/* bc 12, CR0_EQ, 16 */
		/* 8218C248h case   19:*/		if ( regs.CR[0].eq ) { return 0x8218C258;  }
		/* 8218C248h case   19:*/		return 0x8218C24C;
		  /* 8218C24Ch */ case   20:  		/* lwz R3, <#[R3]> */
		/* 8218C24Ch case   20:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 8218C24Ch case   20:*/		return 0x8218C250;
		  /* 8218C250h */ case   21:  		/* li R4, 3526 */
		/* 8218C250h case   21:*/		cpu::op::li<0>(regs,&regs.R4,0xDC6);
		/* 8218C250h case   21:*/		return 0x8218C254;
		  /* 8218C254h */ case   22:  		/* b -238572 */
		/* 8218C254h case   22:*/		return 0x82151E68;
		/* 8218C254h case   22:*/		return 0x8218C258;
	}
	return 0x8218C258;
} // Block from 8218C1FCh-8218C258h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8218C258h
// Function '?FindClearBit@?$FixedSizeBitSet@I$00@D3DXShader@@QAAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C258);
		  /* 8218C258h */ case    0:  		/* lwzx R8, <#[R10 + R3]> */
		/* 8218C258h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 8218C258h case    0:*/		return 0x8218C25C;
		  /* 8218C25Ch */ case    1:  		/* slw R11, R9, R11 */
		/* 8218C25Ch case    1:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8218C25Ch case    1:*/		return 0x8218C260;
		  /* 8218C260h */ case    2:  		/* or R11, R11, R8 */
		/* 8218C260h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8218C260h case    2:*/		return 0x8218C264;
		  /* 8218C264h */ case    3:  		/* stwx R11, <#[R10 + R3]> */
		/* 8218C264h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 8218C264h case    3:*/		return 0x8218C268;
		  /* 8218C268h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8218C268h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218C268h case    4:*/		return 0x8218C26C;
	}
	return 0x8218C26C;
} // Block from 8218C258h-8218C26Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218C26Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C26C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C26C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C26C);
		  /* 8218C26Ch */ case    0:  		/* nop */
		/* 8218C26Ch case    0:*/		cpu::op::nop();
		/* 8218C26Ch case    0:*/		return 0x8218C270;
	}
	return 0x8218C270;
} // Block from 8218C26Ch-8218C270h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218C270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C270);
		  /* 8218C270h */ case    0:  		/* mfspr R12, LR */
		/* 8218C270h case    0:*/		regs.R12 = regs.LR;
		/* 8218C270h case    0:*/		return 0x8218C274;
		  /* 8218C274h */ case    1:  		/* bl -1028124 */
		/* 8218C274h case    1:*/		regs.LR = 0x8218C278; return 0x82091258;
		/* 8218C274h case    1:*/		return 0x8218C278;
		  /* 8218C278h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8218C278h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8218C278h case    2:*/		return 0x8218C27C;
		  /* 8218C27Ch */ case    3:  		/* add R11, R4, R5 */
		/* 8218C27Ch case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R4,regs.R5);
		/* 8218C27Ch case    3:*/		return 0x8218C280;
		  /* 8218C280h */ case    4:  		/* addi R30, R3, 4 */
		/* 8218C280h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x4);
		/* 8218C280h case    4:*/		return 0x8218C284;
		  /* 8218C284h */ case    5:  		/* addi R29, R11, -1 */
		/* 8218C284h case    5:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFFFFFF);
		/* 8218C284h case    5:*/		return 0x8218C288;
		  /* 8218C288h */ case    6:  		/* mr R28, R3 */
		/* 8218C288h case    6:*/		regs.R28 = regs.R3;
		/* 8218C288h case    6:*/		return 0x8218C28C;
		  /* 8218C28Ch */ case    7:  		/* mr R5, R29 */
		/* 8218C28Ch case    7:*/		regs.R5 = regs.R29;
		/* 8218C28Ch case    7:*/		return 0x8218C290;
		  /* 8218C290h */ case    8:  		/* mr R3, R30 */
		/* 8218C290h case    8:*/		regs.R3 = regs.R30;
		/* 8218C290h case    8:*/		return 0x8218C294;
		  /* 8218C294h */ case    9:  		/* mr R31, R4 */
		/* 8218C294h case    9:*/		regs.R31 = regs.R4;
		/* 8218C294h case    9:*/		return 0x8218C298;
		  /* 8218C298h */ case   10:  		/* bl -1808 */
		/* 8218C298h case   10:*/		regs.LR = 0x8218C29C; return 0x8218BB88;
		/* 8218C298h case   10:*/		return 0x8218C29C;
		  /* 8218C29Ch */ case   11:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8218C29Ch case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8218C29Ch case   11:*/		return 0x8218C2A0;
		  /* 8218C2A0h */ case   12:  		/* bc 12, CR0_EQ, 20 */
		/* 8218C2A0h case   12:*/		if ( regs.CR[0].eq ) { return 0x8218C2B4;  }
		/* 8218C2A0h case   12:*/		return 0x8218C2A4;
		  /* 8218C2A4h */ case   13:  		/* mr R5, R31 */
		/* 8218C2A4h case   13:*/		regs.R5 = regs.R31;
		/* 8218C2A4h case   13:*/		return 0x8218C2A8;
		  /* 8218C2A8h */ case   14:  		/* lwz R3, <#[R28]> */
		/* 8218C2A8h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000000) );
		/* 8218C2A8h case   14:*/		return 0x8218C2AC;
		  /* 8218C2ACh */ case   15:  		/* li R4, 3526 */
		/* 8218C2ACh case   15:*/		cpu::op::li<0>(regs,&regs.R4,0xDC6);
		/* 8218C2ACh case   15:*/		return 0x8218C2B0;
		  /* 8218C2B0h */ case   16:  		/* bl -238664 */
		/* 8218C2B0h case   16:*/		regs.LR = 0x8218C2B4; return 0x82151E68;
		/* 8218C2B0h case   16:*/		return 0x8218C2B4;
	}
	return 0x8218C2B4;
} // Block from 8218C270h-8218C2B4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8218C2B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C2B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C2B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C2B4);
		  /* 8218C2B4h */ case    0:  		/* mr R5, R29 */
		/* 8218C2B4h case    0:*/		regs.R5 = regs.R29;
		/* 8218C2B4h case    0:*/		return 0x8218C2B8;
		  /* 8218C2B8h */ case    1:  		/* mr R4, R31 */
		/* 8218C2B8h case    1:*/		regs.R4 = regs.R31;
		/* 8218C2B8h case    1:*/		return 0x8218C2BC;
		  /* 8218C2BCh */ case    2:  		/* mr R3, R30 */
		/* 8218C2BCh case    2:*/		regs.R3 = regs.R30;
		/* 8218C2BCh case    2:*/		return 0x8218C2C0;
	}
	return 0x8218C2C0;
} // Block from 8218C2B4h-8218C2C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218C2C0h
// Function '?FindNibbleWithClearBit@?$FixedSizeBitSet@I$00@D3DXShader@@QAAIIPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C2C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C2C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C2C0);
		  /* 8218C2C0h */ case    0:  		/* bl -1704 */
		/* 8218C2C0h case    0:*/		regs.LR = 0x8218C2C4; return 0x8218BC18;
		/* 8218C2C0h case    0:*/		return 0x8218C2C4;
		  /* 8218C2C4h */ case    1:  		/* addi R1, R1, 128 */
		/* 8218C2C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8218C2C4h case    1:*/		return 0x8218C2C8;
		  /* 8218C2C8h */ case    2:  		/* b -1028128 */
		/* 8218C2C8h case    2:*/		return 0x820912A8;
		/* 8218C2C8h case    2:*/		return 0x8218C2CC;
		  /* 8218C2CCh */ case    3:  		/* nop */
		/* 8218C2CCh case    3:*/		cpu::op::nop();
		/* 8218C2CCh case    3:*/		return 0x8218C2D0;
	}
	return 0x8218C2D0;
} // Block from 8218C2C0h-8218C2D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218C2D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C2D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C2D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C2D0);
		  /* 8218C2D0h */ case    0:  		/* mfspr R12, LR */
		/* 8218C2D0h case    0:*/		regs.R12 = regs.LR;
		/* 8218C2D0h case    0:*/		return 0x8218C2D4;
		  /* 8218C2D4h */ case    1:  		/* bl -1028220 */
		/* 8218C2D4h case    1:*/		regs.LR = 0x8218C2D8; return 0x82091258;
		/* 8218C2D4h case    1:*/		return 0x8218C2D8;
		  /* 8218C2D8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8218C2D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8218C2D8h case    2:*/		return 0x8218C2DC;
		  /* 8218C2DCh */ case    3:  		/* mr R28, R5 */
		/* 8218C2DCh case    3:*/		regs.R28 = regs.R5;
		/* 8218C2DCh case    3:*/		return 0x8218C2E0;
		  /* 8218C2E0h */ case    4:  		/* mr R29, R4 */
		/* 8218C2E0h case    4:*/		regs.R29 = regs.R4;
		/* 8218C2E0h case    4:*/		return 0x8218C2E4;
		  /* 8218C2E4h */ case    5:  		/* mr R5, R4 */
		/* 8218C2E4h case    5:*/		regs.R5 = regs.R4;
		/* 8218C2E4h case    5:*/		return 0x8218C2E8;
		  /* 8218C2E8h */ case    6:  		/* li R6, 1 */
		/* 8218C2E8h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8218C2E8h case    6:*/		return 0x8218C2EC;
		  /* 8218C2ECh */ case    7:  		/* li R4, 0 */
		/* 8218C2ECh case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8218C2ECh case    7:*/		return 0x8218C2F0;
		  /* 8218C2F0h */ case    8:  		/* mr R30, R3 */
		/* 8218C2F0h case    8:*/		regs.R30 = regs.R3;
		/* 8218C2F0h case    8:*/		return 0x8218C2F4;
		  /* 8218C2F4h */ case    9:  		/* bl -1404 */
		/* 8218C2F4h case    9:*/		regs.LR = 0x8218C2F8; return 0x8218BD78;
		/* 8218C2F4h case    9:*/		return 0x8218C2F8;
		  /* 8218C2F8h */ case   10:  		/* mr R31, R3 */
		/* 8218C2F8h case   10:*/		regs.R31 = regs.R3;
		/* 8218C2F8h case   10:*/		return 0x8218C2FC;
		  /* 8218C2FCh */ case   11:  		/* cmpwi CR6, R3, -1 */
		/* 8218C2FCh case   11:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218C2FCh case   11:*/		return 0x8218C300;
		  /* 8218C300h */ case   12:  		/* bc 4, CR6_EQ, 80 */
		/* 8218C300h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8218C350;  }
		/* 8218C300h case   12:*/		return 0x8218C304;
		  /* 8218C304h */ case   13:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 8218C304h case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 8218C304h case   13:*/		return 0x8218C308;
		  /* 8218C308h */ case   14:  		/* bc 12, CR0_EQ, 64 */
		/* 8218C308h case   14:*/		if ( regs.CR[0].eq ) { return 0x8218C348;  }
		/* 8218C308h case   14:*/		return 0x8218C30C;
		  /* 8218C30Ch */ case   15:  		/* lwz R31, <#[R30]> */
		/* 8218C30Ch case   15:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 8218C30Ch case   15:*/		return 0x8218C310;
		  /* 8218C310h */ case   16:  		/* mr R3, R31 */
		/* 8218C310h case   16:*/		regs.R3 = regs.R31;
		/* 8218C310h case   16:*/		return 0x8218C314;
		  /* 8218C314h */ case   17:  		/* lwz R11, <#[R31 + 804]> */
		/* 8218C314h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000324) );
		/* 8218C314h case   17:*/		return 0x8218C318;
		  /* 8218C318h */ case   18:  		/* cmplwi CR6, R11, 0 */
		/* 8218C318h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218C318h case   18:*/		return 0x8218C31C;
		  /* 8218C31Ch */ case   19:  		/* bc 12, CR6_EQ, 24 */
		/* 8218C31Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x8218C334;  }
		/* 8218C31Ch case   19:*/		return 0x8218C320;
		  /* 8218C320h */ case   20:  		/* bl -3776 */
		/* 8218C320h case   20:*/		regs.LR = 0x8218C324; return 0x8218B460;
		/* 8218C320h case   20:*/		return 0x8218C324;
		  /* 8218C324h */ case   21:  		/* mr R5, R3 */
		/* 8218C324h case   21:*/		regs.R5 = regs.R3;
		/* 8218C324h case   21:*/		return 0x8218C328;
		  /* 8218C328h */ case   22:  		/* li R4, 3567 */
		/* 8218C328h case   22:*/		cpu::op::li<0>(regs,&regs.R4,0xDEF);
		/* 8218C328h case   22:*/		return 0x8218C32C;
		  /* 8218C32Ch */ case   23:  		/* mr R3, R31 */
		/* 8218C32Ch case   23:*/		regs.R3 = regs.R31;
		/* 8218C32Ch case   23:*/		return 0x8218C330;
		  /* 8218C330h */ case   24:  		/* bl -238792 */
		/* 8218C330h case   24:*/		regs.LR = 0x8218C334; return 0x82151E68;
		/* 8218C330h case   24:*/		return 0x8218C334;
	}
	return 0x8218C334;
} // Block from 8218C2D0h-8218C334h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8218C334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C334);
		  /* 8218C334h */ case    0:  		/* bl -3796 */
		/* 8218C334h case    0:*/		regs.LR = 0x8218C338; return 0x8218B460;
		/* 8218C334h case    0:*/		return 0x8218C338;
	}
	return 0x8218C338;
} // Block from 8218C334h-8218C338h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218C338h
// Function '?FindLastNibbleWithClearBit@?$FixedSizeBitSet@I$00@D3DXShader@@QAAIIPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C338);
		  /* 8218C338h */ case    0:  		/* mr R5, R3 */
		/* 8218C338h case    0:*/		regs.R5 = regs.R3;
		/* 8218C338h case    0:*/		return 0x8218C33C;
		  /* 8218C33Ch */ case    1:  		/* li R4, 3568 */
		/* 8218C33Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xDF0);
		/* 8218C33Ch case    1:*/		return 0x8218C340;
		  /* 8218C340h */ case    2:  		/* mr R3, R31 */
		/* 8218C340h case    2:*/		regs.R3 = regs.R31;
		/* 8218C340h case    2:*/		return 0x8218C344;
		  /* 8218C344h */ case    3:  		/* bl -238812 */
		/* 8218C344h case    3:*/		regs.LR = 0x8218C348; return 0x82151E68;
		/* 8218C344h case    3:*/		return 0x8218C348;
	}
	return 0x8218C348;
} // Block from 8218C338h-8218C348h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218C348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C348);
		  /* 8218C348h */ case    0:  		/* li R3, -1 */
		/* 8218C348h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8218C348h case    0:*/		return 0x8218C34C;
		  /* 8218C34Ch */ case    1:  		/* b 52 */
		/* 8218C34Ch case    1:*/		return 0x8218C380;
		/* 8218C34Ch case    1:*/		return 0x8218C350;
	}
	return 0x8218C350;
} // Block from 8218C348h-8218C350h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218C350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C350);
		  /* 8218C350h */ case    0:  		/* mr R4, R29 */
		/* 8218C350h case    0:*/		regs.R4 = regs.R29;
		/* 8218C350h case    0:*/		return 0x8218C354;
		  /* 8218C354h */ case    1:  		/* rlwinm R3, R31, 0, 28, 31 */
		/* 8218C354h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R3,regs.R31);
		/* 8218C354h case    1:*/		return 0x8218C358;
		  /* 8218C358h */ case    2:  		/* bl -112280 */
		/* 8218C358h case    2:*/		regs.LR = 0x8218C35C; return 0x82170CC0;
		/* 8218C358h case    2:*/		return 0x8218C35C;
		  /* 8218C35Ch */ case    3:  		/* rlwinm R11, R31, 23, 9, 31 */
		/* 8218C35Ch case    3:*/		cpu::op::rlwinm<0,23,9,31>(regs,&regs.R11,regs.R31);
		/* 8218C35Ch case    3:*/		return 0x8218C360;
		  /* 8218C360h */ case    4:  		/* rlwinm R10, R31, 28, 27, 31 */
		/* 8218C360h case    4:*/		cpu::op::rlwinm<0,28,27,31>(regs,&regs.R10,regs.R31);
		/* 8218C360h case    4:*/		return 0x8218C364;
		  /* 8218C364h */ case    5:  		/* addi R11, R11, 1 */
		/* 8218C364h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218C364h case    5:*/		return 0x8218C368;
		  /* 8218C368h */ case    6:  		/* slw R10, R3, R10 */
		/* 8218C368h case    6:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R3,regs.R10);
		/* 8218C368h case    6:*/		return 0x8218C36C;
		  /* 8218C36Ch */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8218C36Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8218C36Ch case    7:*/		return 0x8218C370;
		  /* 8218C370h */ case    8:  		/* rlwimi R3, R31, 0, 0, 27 */
		/* 8218C370h case    8:*/		cpu::op::rlwimi<0,0,0,27>(regs,&regs.R3,regs.R31);
		/* 8218C370h case    8:*/		return 0x8218C374;
		  /* 8218C374h */ case    9:  		/* lwzx R9, <#[R11 + R30]> */
		/* 8218C374h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8218C374h case    9:*/		return 0x8218C378;
		  /* 8218C378h */ case   10:  		/* or R10, R10, R9 */
		/* 8218C378h case   10:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8218C378h case   10:*/		return 0x8218C37C;
		  /* 8218C37Ch */ case   11:  		/* stwx R10, <#[R11 + R30]> */
		/* 8218C37Ch case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8218C37Ch case   11:*/		return 0x8218C380;
	}
	return 0x8218C380;
} // Block from 8218C350h-8218C380h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8218C380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C380);
		  /* 8218C380h */ case    0:  		/* addi R1, R1, 128 */
		/* 8218C380h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8218C380h case    0:*/		return 0x8218C384;
		  /* 8218C384h */ case    1:  		/* b -1028316 */
		/* 8218C384h case    1:*/		return 0x820912A8;
		/* 8218C384h case    1:*/		return 0x8218C388;
		  /* 8218C388h */ case    2:  		/* rlwinm R11, R4, 22, 10, 31 */
		/* 8218C388h case    2:*/		cpu::op::rlwinm<0,22,10,31>(regs,&regs.R11,regs.R4);
		/* 8218C388h case    2:*/		return 0x8218C38C;
		  /* 8218C38Ch */ case    3:  		/* rlwinm R5, R4, 28, 4, 31 */
		/* 8218C38Ch case    3:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R5,regs.R4);
		/* 8218C38Ch case    3:*/		return 0x8218C390;
		  /* 8218C390h */ case    4:  		/* addi R10, R11, 1 */
		/* 8218C390h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1);
		/* 8218C390h case    4:*/		return 0x8218C394;
		  /* 8218C394h */ case    5:  		/* rldicl R11, R5, 0, 58 */
		/* 8218C394h case    5:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R11,regs.R5);
		/* 8218C394h case    5:*/		return 0x8218C398;
		  /* 8218C398h */ case    6:  		/* li R8, 2 */
		/* 8218C398h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 8218C398h case    6:*/		return 0x8218C39C;
		  /* 8218C39Ch */ case    7:  		/* rlwinm R9, R10, 3, 0, 28 */
		/* 8218C39Ch case    7:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R10);
		/* 8218C39Ch case    7:*/		return 0x8218C3A0;
		  /* 8218C3A0h */ case    8:  		/* sld R10, R8, R11 */
		/* 8218C3A0h case    8:*/		cpu::op::sld<0>(regs,&regs.R10,regs.R8,regs.R11);
		/* 8218C3A0h case    8:*/		return 0x8218C3A4;
		  /* 8218C3A4h */ case    9:  		/* li R8, -1 */
		/* 8218C3A4h case    9:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 8218C3A4h case    9:*/		return 0x8218C3A8;
	}
	return 0x8218C3A8;
} // Block from 8218C380h-8218C3A8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8218C3A8h
// Function '?GetVarRegIndex@Instruction@D3DXShader@@QAAIPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C3A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C3A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C3A8);
		  /* 8218C3A8h */ case    0:  		/* ldx R7, <#[R9 + R3]> */
		/* 8218C3A8h case    0:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8218C3A8h case    0:*/		return 0x8218C3AC;
		  /* 8218C3ACh */ case    1:  		/* addi R10, R10, -1 */
		/* 8218C3ACh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8218C3ACh case    1:*/		return 0x8218C3B0;
		  /* 8218C3B0h */ case    2:  		/* sld R8, R8, R11 */
		/* 8218C3B0h case    2:*/		cpu::op::sld<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 8218C3B0h case    2:*/		return 0x8218C3B4;
		  /* 8218C3B4h */ case    3:  		/* and R8, R10, R8 */
		/* 8218C3B4h case    3:*/		cpu::op::and<0>(regs,&regs.R8,regs.R10,regs.R8);
		/* 8218C3B4h case    3:*/		return 0x8218C3B8;
		  /* 8218C3B8h */ case    4:  		/* rlwinm R10, R4, 0, 28, 31 */
		/* 8218C3B8h case    4:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R10,regs.R4);
		/* 8218C3B8h case    4:*/		return 0x8218C3BC;
		  /* 8218C3BCh */ case    5:  		/* and R8, R8, R7 */
		/* 8218C3BCh case    5:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8218C3BCh case    5:*/		return 0x8218C3C0;
		  /* 8218C3C0h */ case    6:  		/* srd R8, R8, R11 */
		/* 8218C3C0h case    6:*/		cpu::op::srd<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 8218C3C0h case    6:*/		return 0x8218C3C4;
		  /* 8218C3C4h */ case    7:  		/* and R8, R8, R10 */
		/* 8218C3C4h case    7:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R10);
		/* 8218C3C4h case    7:*/		return 0x8218C3C8;
		  /* 8218C3C8h */ case    8:  		/* cmpldi CR6, R8, 0 */
		/* 8218C3C8h case    8:*/		cpu::op::cmpldi<6>(regs,regs.R8,0x00000000);
		/* 8218C3C8h case    8:*/		return 0x8218C3CC;
		  /* 8218C3CCh */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 8218C3CCh case    9:*/		if ( regs.CR[6].eq ) { return 0x8218C3DC;  }
		/* 8218C3CCh case    9:*/		return 0x8218C3D0;
		  /* 8218C3D0h */ case   10:  		/* lwz R3, <#[R3]> */
		/* 8218C3D0h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 8218C3D0h case   10:*/		return 0x8218C3D4;
		  /* 8218C3D4h */ case   11:  		/* li R4, 3526 */
		/* 8218C3D4h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0xDC6);
		/* 8218C3D4h case   11:*/		return 0x8218C3D8;
		  /* 8218C3D8h */ case   12:  		/* b -238960 */
		/* 8218C3D8h case   12:*/		return 0x82151E68;
		/* 8218C3D8h case   12:*/		return 0x8218C3DC;
	}
	return 0x8218C3DC;
} // Block from 8218C3A8h-8218C3DCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 8218C3DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C3DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C3DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C3DC);
		  /* 8218C3DCh */ case    0:  		/* ldx R8, <#[R9 + R3]> */
		/* 8218C3DCh case    0:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8218C3DCh case    0:*/		return 0x8218C3E0;
		  /* 8218C3E0h */ case    1:  		/* sld R11, R10, R11 */
		/* 8218C3E0h case    1:*/		cpu::op::sld<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218C3E0h case    1:*/		return 0x8218C3E4;
		  /* 8218C3E4h */ case    2:  		/* or R11, R11, R8 */
		/* 8218C3E4h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8218C3E4h case    2:*/		return 0x8218C3E8;
		  /* 8218C3E8h */ case    3:  		/* stdx R11, <#[R9 + R3]> */
		/* 8218C3E8h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8218C3E8h case    3:*/		return 0x8218C3EC;
		  /* 8218C3ECh */ case    4:  		/* bclr 20, CR0_LT */
		/* 8218C3ECh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218C3ECh case    4:*/		return 0x8218C3F0;
	}
	return 0x8218C3F0;
} // Block from 8218C3DCh-8218C3F0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218C3F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C3F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C3F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C3F0);
		  /* 8218C3F0h */ case    0:  		/* mfspr R12, LR */
		/* 8218C3F0h case    0:*/		regs.R12 = regs.LR;
		/* 8218C3F0h case    0:*/		return 0x8218C3F4;
		  /* 8218C3F4h */ case    1:  		/* bl -1028508 */
		/* 8218C3F4h case    1:*/		regs.LR = 0x8218C3F8; return 0x82091258;
		/* 8218C3F4h case    1:*/		return 0x8218C3F8;
	}
	return 0x8218C3F8;
} // Block from 8218C3F0h-8218C3F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218C3F8h
// Function '?Find@?$RegisterSet@V?$FixedSizeBitSet@_K$0BA@@D3DXShader@@$1?PrintConstantRegister@2@YAXPAVCompiler@2@I@Z$0BAA@$03$1?ReportOutOfConstantRegistersError@2@YAX0@Z@D3DXShader@@QAAIIIH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C3F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C3F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C3F8);
		  /* 8218C3F8h */ case    0:  		/* stwu R1, <#[R1 - 128]> */
		/* 8218C3F8h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8218C3F8h case    0:*/		return 0x8218C3FC;
		  /* 8218C3FCh */ case    1:  		/* add R11, R4, R5 */
		/* 8218C3FCh case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R4,regs.R5);
		/* 8218C3FCh case    1:*/		return 0x8218C400;
		  /* 8218C400h */ case    2:  		/* addi R30, R3, 8 */
		/* 8218C400h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x8);
		/* 8218C400h case    2:*/		return 0x8218C404;
		  /* 8218C404h */ case    3:  		/* addi R29, R11, -1 */
		/* 8218C404h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFFFFFF);
		/* 8218C404h case    3:*/		return 0x8218C408;
		  /* 8218C408h */ case    4:  		/* mr R28, R3 */
		/* 8218C408h case    4:*/		regs.R28 = regs.R3;
		/* 8218C408h case    4:*/		return 0x8218C40C;
		  /* 8218C40Ch */ case    5:  		/* mr R5, R29 */
		/* 8218C40Ch case    5:*/		regs.R5 = regs.R29;
		/* 8218C40Ch case    5:*/		return 0x8218C410;
		  /* 8218C410h */ case    6:  		/* mr R3, R30 */
		/* 8218C410h case    6:*/		regs.R3 = regs.R30;
		/* 8218C410h case    6:*/		return 0x8218C414;
		  /* 8218C414h */ case    7:  		/* mr R31, R4 */
		/* 8218C414h case    7:*/		regs.R31 = regs.R4;
		/* 8218C414h case    7:*/		return 0x8218C418;
		  /* 8218C418h */ case    8:  		/* bl -119104 */
		/* 8218C418h case    8:*/		regs.LR = 0x8218C41C; return 0x8216F2D8;
		/* 8218C418h case    8:*/		return 0x8218C41C;
		  /* 8218C41Ch */ case    9:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8218C41Ch case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8218C41Ch case    9:*/		return 0x8218C420;
		  /* 8218C420h */ case   10:  		/* bc 12, CR0_EQ, 20 */
		/* 8218C420h case   10:*/		if ( regs.CR[0].eq ) { return 0x8218C434;  }
		/* 8218C420h case   10:*/		return 0x8218C424;
		  /* 8218C424h */ case   11:  		/* mr R5, R31 */
		/* 8218C424h case   11:*/		regs.R5 = regs.R31;
		/* 8218C424h case   11:*/		return 0x8218C428;
		  /* 8218C428h */ case   12:  		/* lwz R3, <#[R28]> */
		/* 8218C428h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000000) );
		/* 8218C428h case   12:*/		return 0x8218C42C;
		  /* 8218C42Ch */ case   13:  		/* li R4, 3526 */
		/* 8218C42Ch case   13:*/		cpu::op::li<0>(regs,&regs.R4,0xDC6);
		/* 8218C42Ch case   13:*/		return 0x8218C430;
		  /* 8218C430h */ case   14:  		/* bl -239048 */
		/* 8218C430h case   14:*/		regs.LR = 0x8218C434; return 0x82151E68;
		/* 8218C430h case   14:*/		return 0x8218C434;
	}
	return 0x8218C434;
} // Block from 8218C3F8h-8218C434h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8218C434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C434);
		  /* 8218C434h */ case    0:  		/* mr R5, R29 */
		/* 8218C434h case    0:*/		regs.R5 = regs.R29;
		/* 8218C434h case    0:*/		return 0x8218C438;
		  /* 8218C438h */ case    1:  		/* mr R4, R31 */
		/* 8218C438h case    1:*/		regs.R4 = regs.R31;
		/* 8218C438h case    1:*/		return 0x8218C43C;
		  /* 8218C43Ch */ case    2:  		/* mr R3, R30 */
		/* 8218C43Ch case    2:*/		regs.R3 = regs.R30;
		/* 8218C43Ch case    2:*/		return 0x8218C440;
		  /* 8218C440h */ case    3:  		/* bl -1912 */
		/* 8218C440h case    3:*/		regs.LR = 0x8218C444; return 0x8218BCC8;
		/* 8218C440h case    3:*/		return 0x8218C444;
		  /* 8218C444h */ case    4:  		/* addi R1, R1, 128 */
		/* 8218C444h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8218C444h case    4:*/		return 0x8218C448;
		  /* 8218C448h */ case    5:  		/* b -1028512 */
		/* 8218C448h case    5:*/		return 0x820912A8;
		/* 8218C448h case    5:*/		return 0x8218C44C;
		  /* 8218C44Ch */ case    6:  		/* nop */
		/* 8218C44Ch case    6:*/		cpu::op::nop();
		/* 8218C44Ch case    6:*/		return 0x8218C450;
	}
	return 0x8218C450;
} // Block from 8218C434h-8218C450h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218C450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C450);
		  /* 8218C450h */ case    0:  		/* mfspr R12, LR */
		/* 8218C450h case    0:*/		regs.R12 = regs.LR;
		/* 8218C450h case    0:*/		return 0x8218C454;
		  /* 8218C454h */ case    1:  		/* bl -1028604 */
		/* 8218C454h case    1:*/		regs.LR = 0x8218C458; return 0x82091258;
		/* 8218C454h case    1:*/		return 0x8218C458;
		  /* 8218C458h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8218C458h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8218C458h case    2:*/		return 0x8218C45C;
		  /* 8218C45Ch */ case    3:  		/* mr R28, R5 */
		/* 8218C45Ch case    3:*/		regs.R28 = regs.R5;
		/* 8218C45Ch case    3:*/		return 0x8218C460;
		  /* 8218C460h */ case    4:  		/* mr R29, R4 */
		/* 8218C460h case    4:*/		regs.R29 = regs.R4;
		/* 8218C460h case    4:*/		return 0x8218C464;
		  /* 8218C464h */ case    5:  		/* mr R5, R4 */
		/* 8218C464h case    5:*/		regs.R5 = regs.R4;
		/* 8218C464h case    5:*/		return 0x8218C468;
		  /* 8218C468h */ case    6:  		/* li R6, 1 */
		/* 8218C468h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8218C468h case    6:*/		return 0x8218C46C;
		  /* 8218C46Ch */ case    7:  		/* li R4, 0 */
		/* 8218C46Ch case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8218C46Ch case    7:*/		return 0x8218C470;
		  /* 8218C470h */ case    8:  		/* mr R30, R3 */
		/* 8218C470h case    8:*/		regs.R30 = regs.R3;
		/* 8218C470h case    8:*/		return 0x8218C474;
		  /* 8218C474h */ case    9:  		/* bl -1612 */
		/* 8218C474h case    9:*/		regs.LR = 0x8218C478; return 0x8218BE28;
		/* 8218C474h case    9:*/		return 0x8218C478;
		  /* 8218C478h */ case   10:  		/* mr R31, R3 */
		/* 8218C478h case   10:*/		regs.R31 = regs.R3;
		/* 8218C478h case   10:*/		return 0x8218C47C;
		  /* 8218C47Ch */ case   11:  		/* cmpwi CR6, R3, -1 */
		/* 8218C47Ch case   11:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218C47Ch case   11:*/		return 0x8218C480;
		  /* 8218C480h */ case   12:  		/* bc 4, CR6_EQ, 32 */
		/* 8218C480h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8218C4A0;  }
		/* 8218C480h case   12:*/		return 0x8218C484;
		  /* 8218C484h */ case   13:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 8218C484h case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 8218C484h case   13:*/		return 0x8218C488;
		  /* 8218C488h */ case   14:  		/* bc 12, CR0_EQ, 16 */
		/* 8218C488h case   14:*/		if ( regs.CR[0].eq ) { return 0x8218C498;  }
		/* 8218C488h case   14:*/		return 0x8218C48C;
		  /* 8218C48Ch */ case   15:  		/* li R4, 3569 */
		/* 8218C48Ch case   15:*/		cpu::op::li<0>(regs,&regs.R4,0xDF1);
		/* 8218C48Ch case   15:*/		return 0x8218C490;
		  /* 8218C490h */ case   16:  		/* lwz R3, <#[R30]> */
		/* 8218C490h case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 8218C490h case   16:*/		return 0x8218C494;
		  /* 8218C494h */ case   17:  		/* bl -239148 */
		/* 8218C494h case   17:*/		regs.LR = 0x8218C498; return 0x82151E68;
		/* 8218C494h case   17:*/		return 0x8218C498;
	}
	return 0x8218C498;
} // Block from 8218C450h-8218C498h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8218C498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C498);
		  /* 8218C498h */ case    0:  		/* li R3, -1 */
		/* 8218C498h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8218C498h case    0:*/		return 0x8218C49C;
		  /* 8218C49Ch */ case    1:  		/* b 60 */
		/* 8218C49Ch case    1:*/		return 0x8218C4D8;
		/* 8218C49Ch case    1:*/		return 0x8218C4A0;
	}
	return 0x8218C4A0;
} // Block from 8218C498h-8218C4A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218C4A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C4A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C4A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C4A0);
		  /* 8218C4A0h */ case    0:  		/* mr R4, R29 */
		/* 8218C4A0h case    0:*/		regs.R4 = regs.R29;
		/* 8218C4A0h case    0:*/		return 0x8218C4A4;
		  /* 8218C4A4h */ case    1:  		/* rlwinm R3, R31, 0, 28, 31 */
		/* 8218C4A4h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R3,regs.R31);
		/* 8218C4A4h case    1:*/		return 0x8218C4A8;
		  /* 8218C4A8h */ case    2:  		/* rlwinm R29, R31, 28, 4, 31 */
		/* 8218C4A8h case    2:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R29,regs.R31);
		/* 8218C4A8h case    2:*/		return 0x8218C4AC;
		  /* 8218C4ACh */ case    3:  		/* bl -112620 */
		/* 8218C4ACh case    3:*/		regs.LR = 0x8218C4B0; return 0x82170CC0;
		/* 8218C4ACh case    3:*/		return 0x8218C4B0;
		  /* 8218C4B0h */ case    4:  		/* rlwinm R11, R31, 22, 10, 31 */
		/* 8218C4B0h case    4:*/		cpu::op::rlwinm<0,22,10,31>(regs,&regs.R11,regs.R31);
		/* 8218C4B0h case    4:*/		return 0x8218C4B4;
		  /* 8218C4B4h */ case    5:  		/* rldicl R10, R3, 0, 32 */
		/* 8218C4B4h case    5:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R3);
		/* 8218C4B4h case    5:*/		return 0x8218C4B8;
	}
	return 0x8218C4B8;
} // Block from 8218C4A0h-8218C4B8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218C4B8h
// Function '?IsAnyBitSet@?$FixedSizeBitSet@I$00@D3DXShader@@QAA_NII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C4B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C4B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C4B8);
		  /* 8218C4B8h */ case    0:  		/* addi R11, R11, 1 */
		/* 8218C4B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218C4B8h case    0:*/		return 0x8218C4BC;
		  /* 8218C4BCh */ case    1:  		/* rldicl R9, R29, 0, 58 */
		/* 8218C4BCh case    1:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R9,regs.R29);
		/* 8218C4BCh case    1:*/		return 0x8218C4C0;
		  /* 8218C4C0h */ case    2:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8218C4C0h case    2:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8218C4C0h case    2:*/		return 0x8218C4C4;
		  /* 8218C4C4h */ case    3:  		/* sld R10, R10, R9 */
		/* 8218C4C4h case    3:*/		cpu::op::sld<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8218C4C4h case    3:*/		return 0x8218C4C8;
		  /* 8218C4C8h */ case    4:  		/* ldx R9, <#[R11 + R30]> */
		/* 8218C4C8h case    4:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8218C4C8h case    4:*/		return 0x8218C4CC;
		  /* 8218C4CCh */ case    5:  		/* rlwimi R3, R31, 0, 0, 27 */
		/* 8218C4CCh case    5:*/		cpu::op::rlwimi<0,0,0,27>(regs,&regs.R3,regs.R31);
		/* 8218C4CCh case    5:*/		return 0x8218C4D0;
		  /* 8218C4D0h */ case    6:  		/* or R10, R10, R9 */
		/* 8218C4D0h case    6:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8218C4D0h case    6:*/		return 0x8218C4D4;
		  /* 8218C4D4h */ case    7:  		/* stdx R10, <#[R11 + R30]> */
		/* 8218C4D4h case    7:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8218C4D4h case    7:*/		return 0x8218C4D8;
	}
	return 0x8218C4D8;
} // Block from 8218C4B8h-8218C4D8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218C4D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C4D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C4D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C4D8);
		  /* 8218C4D8h */ case    0:  		/* addi R1, R1, 128 */
		/* 8218C4D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8218C4D8h case    0:*/		return 0x8218C4DC;
		  /* 8218C4DCh */ case    1:  		/* b -1028660 */
		/* 8218C4DCh case    1:*/		return 0x820912A8;
		/* 8218C4DCh case    1:*/		return 0x8218C4E0;
	}
	return 0x8218C4E0;
} // Block from 8218C4D8h-8218C4E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218C4E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C4E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C4E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C4E0);
		  /* 8218C4E0h */ case    0:  		/* mfspr R12, LR */
		/* 8218C4E0h case    0:*/		regs.R12 = regs.LR;
		/* 8218C4E0h case    0:*/		return 0x8218C4E4;
		  /* 8218C4E4h */ case    1:  		/* bl -1028744 */
		/* 8218C4E4h case    1:*/		regs.LR = 0x8218C4E8; return 0x8209125C;
		/* 8218C4E4h case    1:*/		return 0x8218C4E8;
		  /* 8218C4E8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8218C4E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8218C4E8h case    2:*/		return 0x8218C4EC;
		  /* 8218C4ECh */ case    3:  		/* mr R29, R4 */
		/* 8218C4ECh case    3:*/		regs.R29 = regs.R4;
		/* 8218C4ECh case    3:*/		return 0x8218C4F0;
		  /* 8218C4F0h */ case    4:  		/* mr R5, R4 */
		/* 8218C4F0h case    4:*/		regs.R5 = regs.R4;
		/* 8218C4F0h case    4:*/		return 0x8218C4F4;
		  /* 8218C4F4h */ case    5:  		/* li R6, -1 */
		/* 8218C4F4h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFF);
		/* 8218C4F4h case    5:*/		return 0x8218C4F8;
		  /* 8218C4F8h */ case    6:  		/* li R4, 31 */
		/* 8218C4F8h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x1F);
		/* 8218C4F8h case    6:*/		return 0x8218C4FC;
		  /* 8218C4FCh */ case    7:  		/* mr R30, R3 */
		/* 8218C4FCh case    7:*/		regs.R30 = regs.R3;
		/* 8218C4FCh case    7:*/		return 0x8218C500;
		  /* 8218C500h */ case    8:  		/* bl -1928 */
		/* 8218C500h case    8:*/		regs.LR = 0x8218C504; return 0x8218BD78;
		/* 8218C500h case    8:*/		return 0x8218C504;
		  /* 8218C504h */ case    9:  		/* mr R31, R3 */
		/* 8218C504h case    9:*/		regs.R31 = regs.R3;
		/* 8218C504h case    9:*/		return 0x8218C508;
		  /* 8218C508h */ case   10:  		/* cmpwi CR6, R3, -1 */
		/* 8218C508h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218C508h case   10:*/		return 0x8218C50C;
		  /* 8218C50Ch */ case   11:  		/* bc 4, CR6_EQ, 16 */
		/* 8218C50Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x8218C51C;  }
		/* 8218C50Ch case   11:*/		return 0x8218C510;
		  /* 8218C510h */ case   12:  		/* li R4, 3570 */
		/* 8218C510h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0xDF2);
		/* 8218C510h case   12:*/		return 0x8218C514;
		  /* 8218C514h */ case   13:  		/* lwz R3, <#[R30]> */
		/* 8218C514h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 8218C514h case   13:*/		return 0x8218C518;
		  /* 8218C518h */ case   14:  		/* bl -239280 */
		/* 8218C518h case   14:*/		regs.LR = 0x8218C51C; return 0x82151E68;
		/* 8218C518h case   14:*/		return 0x8218C51C;
	}
	return 0x8218C51C;
} // Block from 8218C4E0h-8218C51Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8218C51Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C51C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C51C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C51C);
		  /* 8218C51Ch */ case    0:  		/* mr R4, R29 */
		/* 8218C51Ch case    0:*/		regs.R4 = regs.R29;
		/* 8218C51Ch case    0:*/		return 0x8218C520;
		  /* 8218C520h */ case    1:  		/* rlwinm R3, R31, 0, 28, 31 */
		/* 8218C520h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R3,regs.R31);
		/* 8218C520h case    1:*/		return 0x8218C524;
		  /* 8218C524h */ case    2:  		/* bl -112740 */
		/* 8218C524h case    2:*/		regs.LR = 0x8218C528; return 0x82170CC0;
		/* 8218C524h case    2:*/		return 0x8218C528;
		  /* 8218C528h */ case    3:  		/* rlwinm R11, R31, 23, 9, 31 */
		/* 8218C528h case    3:*/		cpu::op::rlwinm<0,23,9,31>(regs,&regs.R11,regs.R31);
		/* 8218C528h case    3:*/		return 0x8218C52C;
		  /* 8218C52Ch */ case    4:  		/* rlwinm R10, R31, 28, 27, 31 */
		/* 8218C52Ch case    4:*/		cpu::op::rlwinm<0,28,27,31>(regs,&regs.R10,regs.R31);
		/* 8218C52Ch case    4:*/		return 0x8218C530;
		  /* 8218C530h */ case    5:  		/* addi R11, R11, 1 */
		/* 8218C530h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218C530h case    5:*/		return 0x8218C534;
		  /* 8218C534h */ case    6:  		/* slw R10, R3, R10 */
		/* 8218C534h case    6:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R3,regs.R10);
		/* 8218C534h case    6:*/		return 0x8218C538;
		  /* 8218C538h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8218C538h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8218C538h case    7:*/		return 0x8218C53C;
		  /* 8218C53Ch */ case    8:  		/* rlwimi R3, R31, 0, 0, 27 */
		/* 8218C53Ch case    8:*/		cpu::op::rlwimi<0,0,0,27>(regs,&regs.R3,regs.R31);
		/* 8218C53Ch case    8:*/		return 0x8218C540;
		  /* 8218C540h */ case    9:  		/* lwzx R9, <#[R11 + R30]> */
		/* 8218C540h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8218C540h case    9:*/		return 0x8218C544;
		  /* 8218C544h */ case   10:  		/* or R10, R10, R9 */
		/* 8218C544h case   10:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8218C544h case   10:*/		return 0x8218C548;
	}
	return 0x8218C548;
} // Block from 8218C51Ch-8218C548h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8218C548h
// Function '?SetBitRange@?$FixedSizeBitSet@I$00@D3DXShader@@QAAXII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C548);
		  /* 8218C548h */ case    0:  		/* stwx R10, <#[R11 + R30]> */
		/* 8218C548h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8218C548h case    0:*/		return 0x8218C54C;
		  /* 8218C54Ch */ case    1:  		/* addi R1, R1, 112 */
		/* 8218C54Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8218C54Ch case    1:*/		return 0x8218C550;
		  /* 8218C550h */ case    2:  		/* b -1028772 */
		/* 8218C550h case    2:*/		return 0x820912AC;
		/* 8218C550h case    2:*/		return 0x8218C554;
		  /* 8218C554h */ case    3:  		/* nop */
		/* 8218C554h case    3:*/		cpu::op::nop();
		/* 8218C554h case    3:*/		return 0x8218C558;
	}
	return 0x8218C558;
} // Block from 8218C548h-8218C558h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218C558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C558);
		  /* 8218C558h */ case    0:  		/* mfspr R12, LR */
		/* 8218C558h case    0:*/		regs.R12 = regs.LR;
		/* 8218C558h case    0:*/		return 0x8218C55C;
		  /* 8218C55Ch */ case    1:  		/* bl -1028864 */
		/* 8218C55Ch case    1:*/		regs.LR = 0x8218C560; return 0x8209125C;
		/* 8218C55Ch case    1:*/		return 0x8218C560;
		  /* 8218C560h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8218C560h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8218C560h case    2:*/		return 0x8218C564;
		  /* 8218C564h */ case    3:  		/* addi R29, R3, 8 */
		/* 8218C564h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R3,0x8);
		/* 8218C564h case    3:*/		return 0x8218C568;
		  /* 8218C568h */ case    4:  		/* mr R30, R5 */
		/* 8218C568h case    4:*/		regs.R30 = regs.R5;
		/* 8218C568h case    4:*/		return 0x8218C56C;
		  /* 8218C56Ch */ case    5:  		/* mr R3, R29 */
		/* 8218C56Ch case    5:*/		regs.R3 = regs.R29;
		/* 8218C56Ch case    5:*/		return 0x8218C570;
		  /* 8218C570h */ case    6:  		/* bl -3248 */
		/* 8218C570h case    6:*/		regs.LR = 0x8218C574; return 0x8218B8C0;
		/* 8218C570h case    6:*/		return 0x8218C574;
		  /* 8218C574h */ case    7:  		/* mr R31, R3 */
		/* 8218C574h case    7:*/		regs.R31 = regs.R3;
		/* 8218C574h case    7:*/		return 0x8218C578;
		  /* 8218C578h */ case    8:  		/* cmpwi CR6, R3, -1 */
		/* 8218C578h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218C578h case    8:*/		return 0x8218C57C;
		  /* 8218C57Ch */ case    9:  		/* bc 4, CR6_EQ, 40 */
		/* 8218C57Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x8218C5A4;  }
		/* 8218C57Ch case    9:*/		return 0x8218C580;
		  /* 8218C580h */ case   10:  		/* li R3, -1 */
		/* 8218C580h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8218C580h case   10:*/		return 0x8218C584;
		  /* 8218C584h */ case   11:  		/* b 52 */
		/* 8218C584h case   11:*/		return 0x8218C5B8;
		/* 8218C584h case   11:*/		return 0x8218C588;
		  /* 8218C588h */ case   12:  		/* addi R5, R11, -1 */
		/* 8218C588h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 8218C588h case   12:*/		return 0x8218C58C;
		  /* 8218C58Ch */ case   13:  		/* mr R4, R31 */
		/* 8218C58Ch case   13:*/		regs.R4 = regs.R31;
		/* 8218C58Ch case   13:*/		return 0x8218C590;
		  /* 8218C590h */ case   14:  		/* mr R3, R29 */
		/* 8218C590h case   14:*/		regs.R3 = regs.R29;
		/* 8218C590h case   14:*/		return 0x8218C594;
		  /* 8218C594h */ case   15:  		/* bl -1724 */
		/* 8218C594h case   15:*/		regs.LR = 0x8218C598; return 0x8218BED8;
		/* 8218C594h case   15:*/		return 0x8218C598;
		  /* 8218C598h */ case   16:  		/* cmpwi CR6, R3, -1 */
		/* 8218C598h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218C598h case   16:*/		return 0x8218C59C;
		  /* 8218C59Ch */ case   17:  		/* bc 12, CR6_EQ, 24 */
		/* 8218C59Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x8218C5B4;  }
		/* 8218C59Ch case   17:*/		return 0x8218C5A0;
		  /* 8218C5A0h */ case   18:  		/* addi R31, R3, 1 */
		/* 8218C5A0h case   18:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x1);
		/* 8218C5A0h case   18:*/		return 0x8218C5A4;
	}
	return 0x8218C5A4;
} // Block from 8218C558h-8218C5A4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8218C5A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C5A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C5A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C5A4);
		  /* 8218C5A4h */ case    0:  		/* add R11, R31, R30 */
		/* 8218C5A4h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R30);
		/* 8218C5A4h case    0:*/		return 0x8218C5A8;
		  /* 8218C5A8h */ case    1:  		/* cmplwi CR6, R11, 256 */
		/* 8218C5A8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000100);
		/* 8218C5A8h case    1:*/		return 0x8218C5AC;
		  /* 8218C5ACh */ case    2:  		/* bc 4, CR6_GT, -36 */
		/* 8218C5ACh case    2:*/		if ( !regs.CR[6].gt ) { return 0x8218C588;  }
		/* 8218C5ACh case    2:*/		return 0x8218C5B0;
		  /* 8218C5B0h */ case    3:  		/* b -48 */
		/* 8218C5B0h case    3:*/		return 0x8218C580;
		/* 8218C5B0h case    3:*/		return 0x8218C5B4;
	}
	return 0x8218C5B4;
} // Block from 8218C5A4h-8218C5B4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218C5B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C5B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C5B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C5B4);
		  /* 8218C5B4h */ case    0:  		/* mr R3, R31 */
		/* 8218C5B4h case    0:*/		regs.R3 = regs.R31;
		/* 8218C5B4h case    0:*/		return 0x8218C5B8;
	}
	return 0x8218C5B8;
} // Block from 8218C5B4h-8218C5B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218C5B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C5B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C5B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C5B8);
		  /* 8218C5B8h */ case    0:  		/* addi R1, R1, 112 */
		/* 8218C5B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8218C5B8h case    0:*/		return 0x8218C5BC;
		  /* 8218C5BCh */ case    1:  		/* b -1028880 */
		/* 8218C5BCh case    1:*/		return 0x820912AC;
		/* 8218C5BCh case    1:*/		return 0x8218C5C0;
	}
	return 0x8218C5C0;
} // Block from 8218C5B8h-8218C5C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218C5C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C5C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C5C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C5C0);
		  /* 8218C5C0h */ case    0:  		/* mfspr R12, LR */
		/* 8218C5C0h case    0:*/		regs.R12 = regs.LR;
		/* 8218C5C0h case    0:*/		return 0x8218C5C4;
		  /* 8218C5C4h */ case    1:  		/* bl -1028968 */
		/* 8218C5C4h case    1:*/		regs.LR = 0x8218C5C8; return 0x8209125C;
		/* 8218C5C4h case    1:*/		return 0x8218C5C8;
		  /* 8218C5C8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8218C5C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8218C5C8h case    2:*/		return 0x8218C5CC;
		  /* 8218C5CCh */ case    3:  		/* addi R29, R3, 4 */
		/* 8218C5CCh case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R3,0x4);
		/* 8218C5CCh case    3:*/		return 0x8218C5D0;
		  /* 8218C5D0h */ case    4:  		/* mr R30, R5 */
		/* 8218C5D0h case    4:*/		regs.R30 = regs.R5;
		/* 8218C5D0h case    4:*/		return 0x8218C5D4;
		  /* 8218C5D4h */ case    5:  		/* mr R3, R29 */
		/* 8218C5D4h case    5:*/		regs.R3 = regs.R29;
		/* 8218C5D4h case    5:*/		return 0x8218C5D8;
		  /* 8218C5D8h */ case    6:  		/* bl -3248 */
		/* 8218C5D8h case    6:*/		regs.LR = 0x8218C5DC; return 0x8218B928;
		/* 8218C5D8h case    6:*/		return 0x8218C5DC;
		  /* 8218C5DCh */ case    7:  		/* mr R31, R3 */
		/* 8218C5DCh case    7:*/		regs.R31 = regs.R3;
		/* 8218C5DCh case    7:*/		return 0x8218C5E0;
		  /* 8218C5E0h */ case    8:  		/* cmpwi CR6, R3, -1 */
		/* 8218C5E0h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218C5E0h case    8:*/		return 0x8218C5E4;
		  /* 8218C5E4h */ case    9:  		/* bc 4, CR6_EQ, 40 */
		/* 8218C5E4h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8218C60C;  }
		/* 8218C5E4h case    9:*/		return 0x8218C5E8;
		  /* 8218C5E8h */ case   10:  		/* li R3, -1 */
		/* 8218C5E8h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8218C5E8h case   10:*/		return 0x8218C5EC;
		  /* 8218C5ECh */ case   11:  		/* b 52 */
		/* 8218C5ECh case   11:*/		return 0x8218C620;
		/* 8218C5ECh case   11:*/		return 0x8218C5F0;
		  /* 8218C5F0h */ case   12:  		/* addi R5, R11, -1 */
		/* 8218C5F0h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 8218C5F0h case   12:*/		return 0x8218C5F4;
		  /* 8218C5F4h */ case   13:  		/* mr R4, R31 */
		/* 8218C5F4h case   13:*/		regs.R4 = regs.R31;
		/* 8218C5F4h case   13:*/		return 0x8218C5F8;
	}
	return 0x8218C5F8;
} // Block from 8218C5C0h-8218C5F8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8218C5F8h
// Function '?IsAnyBitSet@?$FixedSizeBitSet@_K$03@D3DXShader@@QAA_NII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C5F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C5F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C5F8);
		  /* 8218C5F8h */ case    0:  		/* mr R3, R29 */
		/* 8218C5F8h case    0:*/		regs.R3 = regs.R29;
		/* 8218C5F8h case    0:*/		return 0x8218C5FC;
		  /* 8218C5FCh */ case    1:  		/* bl -1620 */
		/* 8218C5FCh case    1:*/		regs.LR = 0x8218C600; return 0x8218BFA8;
		/* 8218C5FCh case    1:*/		return 0x8218C600;
		  /* 8218C600h */ case    2:  		/* cmpwi CR6, R3, -1 */
		/* 8218C600h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218C600h case    2:*/		return 0x8218C604;
		  /* 8218C604h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 8218C604h case    3:*/		if ( regs.CR[6].eq ) { return 0x8218C61C;  }
		/* 8218C604h case    3:*/		return 0x8218C608;
		  /* 8218C608h */ case    4:  		/* addi R31, R3, 1 */
		/* 8218C608h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x1);
		/* 8218C608h case    4:*/		return 0x8218C60C;
	}
	return 0x8218C60C;
} // Block from 8218C5F8h-8218C60Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218C60Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C60C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C60C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C60C);
		  /* 8218C60Ch */ case    0:  		/* add R11, R31, R30 */
		/* 8218C60Ch case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R30);
		/* 8218C60Ch case    0:*/		return 0x8218C610;
		  /* 8218C610h */ case    1:  		/* cmplwi CR6, R11, 32 */
		/* 8218C610h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 8218C610h case    1:*/		return 0x8218C614;
		  /* 8218C614h */ case    2:  		/* bc 4, CR6_GT, -36 */
		/* 8218C614h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8218C5F0;  }
		/* 8218C614h case    2:*/		return 0x8218C618;
		  /* 8218C618h */ case    3:  		/* b -48 */
		/* 8218C618h case    3:*/		return 0x8218C5E8;
		/* 8218C618h case    3:*/		return 0x8218C61C;
	}
	return 0x8218C61C;
} // Block from 8218C60Ch-8218C61Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218C61Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C61C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C61C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C61C);
		  /* 8218C61Ch */ case    0:  		/* mr R3, R31 */
		/* 8218C61Ch case    0:*/		regs.R3 = regs.R31;
		/* 8218C61Ch case    0:*/		return 0x8218C620;
	}
	return 0x8218C620;
} // Block from 8218C61Ch-8218C620h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218C620h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C620);
		  /* 8218C620h */ case    0:  		/* addi R1, R1, 112 */
		/* 8218C620h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8218C620h case    0:*/		return 0x8218C624;
		  /* 8218C624h */ case    1:  		/* b -1028984 */
		/* 8218C624h case    1:*/		return 0x820912AC;
		/* 8218C624h case    1:*/		return 0x8218C628;
	}
	return 0x8218C628;
} // Block from 8218C620h-8218C628h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218C628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C628);
		  /* 8218C628h */ case    0:  		/* mfspr R12, LR */
		/* 8218C628h case    0:*/		regs.R12 = regs.LR;
		/* 8218C628h case    0:*/		return 0x8218C62C;
		  /* 8218C62Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8218C62Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8218C62Ch case    1:*/		return 0x8218C630;
		  /* 8218C630h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8218C630h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8218C630h case    2:*/		return 0x8218C634;
		  /* 8218C634h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8218C634h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8218C634h case    3:*/		return 0x8218C638;
		  /* 8218C638h */ case    4:  		/* addi R11, R3, 812 */
		/* 8218C638h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x32C);
		/* 8218C638h case    4:*/		return 0x8218C63C;
		  /* 8218C63Ch */ case    5:  		/* cmplwi CR6, R4, 132 */
		/* 8218C63Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000084);
		/* 8218C63Ch case    5:*/		return 0x8218C640;
		  /* 8218C640h */ case    6:  		/* bc 4, CR6_GT, 16 */
		/* 8218C640h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8218C650;  }
		/* 8218C640h case    6:*/		return 0x8218C644;
		  /* 8218C644h */ case    7:  		/* mr R3, R11 */
		/* 8218C644h case    7:*/		regs.R3 = regs.R11;
		/* 8218C644h case    7:*/		return 0x8218C648;
		  /* 8218C648h */ case    8:  		/* bl -161592 */
		/* 8218C648h case    8:*/		regs.LR = 0x8218C64C; return 0x82164F10;
		/* 8218C648h case    8:*/		return 0x8218C64C;
		  /* 8218C64Ch */ case    9:  		/* b 112 */
		/* 8218C64Ch case    9:*/		return 0x8218C6BC;
		/* 8218C64Ch case    9:*/		return 0x8218C650;
	}
	return 0x8218C650;
} // Block from 8218C628h-8218C650h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8218C650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C650);
		  /* 8218C650h */ case    0:  		/* lwz R9, <#[R11 + 140]> */
		/* 8218C650h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000008C) );
		/* 8218C650h case    0:*/		return 0x8218C654;
		  /* 8218C654h */ case    1:  		/* lwz R10, <#[R11 + 144]> */
		/* 8218C654h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000090) );
		/* 8218C654h case    1:*/		return 0x8218C658;
		  /* 8218C658h */ case    2:  		/* subf R9, R10, R9 */
		/* 8218C658h case    2:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 8218C658h case    2:*/		return 0x8218C65C;
		  /* 8218C65Ch */ case    3:  		/* addi R9, R9, 4096 */
		/* 8218C65Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1000);
		/* 8218C65Ch case    3:*/		return 0x8218C660;
		  /* 8218C660h */ case    4:  		/* cmplw CR6, R9, R4 */
		/* 8218C660h case    4:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R4);
		/* 8218C660h case    4:*/		return 0x8218C664;
		  /* 8218C664h */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 8218C664h case    5:*/		if ( regs.CR[6].lt ) { return 0x8218C674;  }
		/* 8218C664h case    5:*/		return 0x8218C668;
		  /* 8218C668h */ case    6:  		/* add R9, R10, R4 */
		/* 8218C668h case    6:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R4);
		/* 8218C668h case    6:*/		return 0x8218C66C;
		  /* 8218C66Ch */ case    7:  		/* stw R9, <#[R11 + 144]> */
		/* 8218C66Ch case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000090) );
		/* 8218C66Ch case    7:*/		return 0x8218C670;
		  /* 8218C670h */ case    8:  		/* b 72 */
		/* 8218C670h case    8:*/		return 0x8218C6B8;
		/* 8218C670h case    8:*/		return 0x8218C674;
	}
	return 0x8218C674;
} // Block from 8218C650h-8218C674h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218C674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C674);
		  /* 8218C674h */ case    0:  		/* rlwinm R10, R4, 30, 2, 31 */
		/* 8218C674h case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R4);
		/* 8218C674h case    0:*/		return 0x8218C678;
		  /* 8218C678h */ case    1:  		/* addi R10, R10, -1 */
		/* 8218C678h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8218C678h case    1:*/		return 0x8218C67C;
		  /* 8218C67Ch */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8218C67Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8218C67Ch case    2:*/		return 0x8218C680;
		  /* 8218C680h */ case    3:  		/* lwzx R31, <#[R10 + R11]> */
		/* 8218C680h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8218C680h case    3:*/		return 0x8218C684;
		  /* 8218C684h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8218C684h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8218C684h case    4:*/		return 0x8218C688;
		  /* 8218C688h */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 8218C688h case    5:*/		if ( regs.CR[6].eq ) { return 0x8218C6AC;  }
		/* 8218C688h case    5:*/		return 0x8218C68C;
		  /* 8218C68Ch */ case    6:  		/* lwz R9, <#[R31]> */
		/* 8218C68Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8218C68Ch case    6:*/		return 0x8218C690;
		  /* 8218C690h */ case    7:  		/* mr R5, R4 */
		/* 8218C690h case    7:*/		regs.R5 = regs.R4;
		/* 8218C690h case    7:*/		return 0x8218C694;
		  /* 8218C694h */ case    8:  		/* li R4, 0 */
		/* 8218C694h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8218C694h case    8:*/		return 0x8218C698;
		  /* 8218C698h */ case    9:  		/* mr R3, R31 */
		/* 8218C698h case    9:*/		regs.R3 = regs.R31;
		/* 8218C698h case    9:*/		return 0x8218C69C;
		  /* 8218C69Ch */ case   10:  		/* stwx R9, <#[R10 + R11]> */
		/* 8218C69Ch case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8218C69Ch case   10:*/		return 0x8218C6A0;
	}
	return 0x8218C6A0;
} // Block from 8218C674h-8218C6A0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8218C6A0h
// Function '?FindLastBitSetInRange@?$FixedSizeBitSet@_K$0BA@@D3DXShader@@QAAIII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C6A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C6A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C6A0);
		  /* 8218C6A0h */ case    0:  		/* bl -1028960 */
		/* 8218C6A0h case    0:*/		regs.LR = 0x8218C6A4; return 0x82091340;
		/* 8218C6A0h case    0:*/		return 0x8218C6A4;
		  /* 8218C6A4h */ case    1:  		/* mr R10, R31 */
		/* 8218C6A4h case    1:*/		regs.R10 = regs.R31;
		/* 8218C6A4h case    1:*/		return 0x8218C6A8;
		  /* 8218C6A8h */ case    2:  		/* b 16 */
		/* 8218C6A8h case    2:*/		return 0x8218C6B8;
		/* 8218C6A8h case    2:*/		return 0x8218C6AC;
	}
	return 0x8218C6AC;
} // Block from 8218C6A0h-8218C6ACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218C6ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C6AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C6AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C6AC);
		  /* 8218C6ACh */ case    0:  		/* mr R3, R11 */
		/* 8218C6ACh case    0:*/		regs.R3 = regs.R11;
		/* 8218C6ACh case    0:*/		return 0x8218C6B0;
		  /* 8218C6B0h */ case    1:  		/* bl -164032 */
		/* 8218C6B0h case    1:*/		regs.LR = 0x8218C6B4; return 0x821645F0;
		/* 8218C6B0h case    1:*/		return 0x8218C6B4;
		  /* 8218C6B4h */ case    2:  		/* mr R10, R3 */
		/* 8218C6B4h case    2:*/		regs.R10 = regs.R3;
		/* 8218C6B4h case    2:*/		return 0x8218C6B8;
	}
	return 0x8218C6B8;
} // Block from 8218C6ACh-8218C6B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218C6B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C6B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C6B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C6B8);
		  /* 8218C6B8h */ case    0:  		/* mr R3, R10 */
		/* 8218C6B8h case    0:*/		regs.R3 = regs.R10;
		/* 8218C6B8h case    0:*/		return 0x8218C6BC;
	}
	return 0x8218C6BC;
} // Block from 8218C6B8h-8218C6BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218C6BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C6BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C6BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C6BC);
		  /* 8218C6BCh */ case    0:  		/* addi R1, R1, 96 */
		/* 8218C6BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8218C6BCh case    0:*/		return 0x8218C6C0;
		  /* 8218C6C0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8218C6C0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8218C6C0h case    1:*/		return 0x8218C6C4;
		  /* 8218C6C4h */ case    2:  		/* mtspr LR, R12 */
		/* 8218C6C4h case    2:*/		regs.LR = regs.R12;
		/* 8218C6C4h case    2:*/		return 0x8218C6C8;
		  /* 8218C6C8h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8218C6C8h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8218C6C8h case    3:*/		return 0x8218C6CC;
		  /* 8218C6CCh */ case    4:  		/* bclr 20, CR0_LT */
		/* 8218C6CCh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218C6CCh case    4:*/		return 0x8218C6D0;
	}
	return 0x8218C6D0;
} // Block from 8218C6BCh-8218C6D0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218C6D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C6D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C6D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C6D0);
		  /* 8218C6D0h */ case    0:  		/* mfspr R12, LR */
		/* 8218C6D0h case    0:*/		regs.R12 = regs.LR;
		/* 8218C6D0h case    0:*/		return 0x8218C6D4;
		  /* 8218C6D4h */ case    1:  		/* bl -1029300 */
		/* 8218C6D4h case    1:*/		regs.LR = 0x8218C6D8; return 0x82091220;
		/* 8218C6D4h case    1:*/		return 0x8218C6D8;
		  /* 8218C6D8h */ case    2:  		/* stwu R1, <#[R1 - 272]> */
		/* 8218C6D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEF0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEF0);
		/* 8218C6D8h case    2:*/		return 0x8218C6DC;
		  /* 8218C6DCh */ case    3:  		/* lwz R11, <#[R3 + 88]> */
		/* 8218C6DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000058) );
		/* 8218C6DCh case    3:*/		return 0x8218C6E0;
		  /* 8218C6E0h */ case    4:  		/* li R5, 0 */
		/* 8218C6E0h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8218C6E0h case    4:*/		return 0x8218C6E4;
		  /* 8218C6E4h */ case    5:  		/* mr R19, R3 */
		/* 8218C6E4h case    5:*/		regs.R19 = regs.R3;
		/* 8218C6E4h case    5:*/		return 0x8218C6E8;
		  /* 8218C6E8h */ case    6:  		/* rlwinm R4, R11, 2, 0, 29 */
		/* 8218C6E8h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R11);
		/* 8218C6E8h case    6:*/		return 0x8218C6EC;
		  /* 8218C6ECh */ case    7:  		/* bl -161460 */
		/* 8218C6ECh case    7:*/		regs.LR = 0x8218C6F0; return 0x82165038;
		/* 8218C6ECh case    7:*/		return 0x8218C6F0;
		  /* 8218C6F0h */ case    8:  		/* li R20, 0 */
		/* 8218C6F0h case    8:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 8218C6F0h case    8:*/		return 0x8218C6F4;
		  /* 8218C6F4h */ case    9:  		/* mr R18, R3 */
		/* 8218C6F4h case    9:*/		regs.R18 = regs.R3;
		/* 8218C6F4h case    9:*/		return 0x8218C6F8;
		  /* 8218C6F8h */ case   10:  		/* mr R17, R20 */
		/* 8218C6F8h case   10:*/		regs.R17 = regs.R20;
		/* 8218C6F8h case   10:*/		return 0x8218C6FC;
		  /* 8218C6FCh */ case   11:  		/* addi R27, R19, 60 */
		/* 8218C6FCh case   11:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R19,0x3C);
		/* 8218C6FCh case   11:*/		return 0x8218C700;
		  /* 8218C700h */ case   12:  		/* li R26, 7 */
		/* 8218C700h case   12:*/		cpu::op::li<0>(regs,&regs.R26,0x7);
		/* 8218C700h case   12:*/		return 0x8218C704;
		  /* 8218C704h */ case   13:  		/* li R16, 1 */
		/* 8218C704h case   13:*/		cpu::op::li<0>(regs,&regs.R16,0x1);
		/* 8218C704h case   13:*/		return 0x8218C708;
		  /* 8218C708h */ case   14:  		/* li R15, 3 */
		/* 8218C708h case   14:*/		cpu::op::li<0>(regs,&regs.R15,0x3);
		/* 8218C708h case   14:*/		return 0x8218C70C;
		  /* 8218C70Ch */ case   15:  		/* lwz R30, <#[R27]> */
		/* 8218C70Ch case   15:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x00000000) );
		/* 8218C70Ch case   15:*/		return 0x8218C710;
		  /* 8218C710h */ case   16:  		/* cmplwi CR6, R30, 0 */
		/* 8218C710h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8218C710h case   16:*/		return 0x8218C714;
		  /* 8218C714h */ case   17:  		/* bc 12, CR6_EQ, 556 */
		/* 8218C714h case   17:*/		if ( regs.CR[6].eq ) { return 0x8218C940;  }
		/* 8218C714h case   17:*/		return 0x8218C718;
		  /* 8218C718h */ case   18:  		/* rlwinm R11, R17, 2, 0, 29 */
		/* 8218C718h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R17);
		/* 8218C718h case   18:*/		return 0x8218C71C;
		  /* 8218C71Ch */ case   19:  		/* add R11, R11, R18 */
		/* 8218C71Ch case   19:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R18);
		/* 8218C71Ch case   19:*/		return 0x8218C720;
		  /* 8218C720h */ case   20:  		/* addi R28, R11, -4 */
		/* 8218C720h case   20:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0xFFFFFFFC);
		/* 8218C720h case   20:*/		return 0x8218C724;
		  /* 8218C724h */ case   21:  		/* lwz R11, <#[R30 + 8]> */
		/* 8218C724h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8218C724h case   21:*/		return 0x8218C728;
		  /* 8218C728h */ case   22:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8218C728h case   22:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8218C728h case   22:*/		return 0x8218C72C;
		  /* 8218C72Ch */ case   23:  		/* cmplwi CR6, R11, 14720 */
		/* 8218C72Ch case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003980);
		/* 8218C72Ch case   23:*/		return 0x8218C730;
		  /* 8218C730h */ case   24:  		/* bc 12, CR6_EQ, 516 */
		/* 8218C730h case   24:*/		if ( regs.CR[6].eq ) { return 0x8218C934;  }
		/* 8218C730h case   24:*/		return 0x8218C734;
		  /* 8218C734h */ case   25:  		/* mr R4, R19 */
		/* 8218C734h case   25:*/		regs.R4 = regs.R19;
		/* 8218C734h case   25:*/		return 0x8218C738;
		  /* 8218C738h */ case   26:  		/* mr R3, R30 */
		/* 8218C738h case   26:*/		regs.R3 = regs.R30;
		/* 8218C738h case   26:*/		return 0x8218C73C;
		  /* 8218C73Ch */ case   27:  		/* bl 42092 */
		/* 8218C73Ch case   27:*/		regs.LR = 0x8218C740; return 0x82196BA8;
		/* 8218C73Ch case   27:*/		return 0x8218C740;
		  /* 8218C740h */ case   28:  		/* lwz R11, <#[R30 + 4]> */
		/* 8218C740h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8218C740h case   28:*/		return 0x8218C744;
		  /* 8218C744h */ case   29:  		/* cmpwi CR6, R11, 0 */
		/* 8218C744h case   29:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8218C744h case   29:*/		return 0x8218C748;
		  /* 8218C748h */ case   30:  		/* bc 12, CR6_EQ, 472 */
		/* 8218C748h case   30:*/		if ( regs.CR[6].eq ) { return 0x8218C920;  }
		/* 8218C748h case   30:*/		return 0x8218C74C;
		  /* 8218C74Ch */ case   31:  		/* mr R31, R20 */
		/* 8218C74Ch case   31:*/		regs.R31 = regs.R20;
		/* 8218C74Ch case   31:*/		return 0x8218C750;
		  /* 8218C750h */ case   32:  		/* mr R29, R20 */
		/* 8218C750h case   32:*/		regs.R29 = regs.R20;
		/* 8218C750h case   32:*/		return 0x8218C754;
		  /* 8218C754h */ case   33:  		/* mr R5, R20 */
		/* 8218C754h case   33:*/		regs.R5 = regs.R20;
		/* 8218C754h case   33:*/		return 0x8218C758;
		  /* 8218C758h */ case   34:  		/* mr R6, R11 */
		/* 8218C758h case   34:*/		regs.R6 = regs.R11;
		/* 8218C758h case   34:*/		return 0x8218C75C;
		  /* 8218C75Ch */ case   35:  		/* cmplwi CR6, R6, 0 */
		/* 8218C75Ch case   35:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8218C75Ch case   35:*/		return 0x8218C760;
		  /* 8218C760h */ case   36:  		/* bc 12, CR6_EQ, 88 */
		/* 8218C760h case   36:*/		if ( regs.CR[6].eq ) { return 0x8218C7B8;  }
		/* 8218C760h case   36:*/		return 0x8218C764;
		  /* 8218C764h */ case   37:  		/* lwz R11, <#[R6 + 16]> */
		/* 8218C764h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000010) );
		/* 8218C764h case   37:*/		return 0x8218C768;
		  /* 8218C768h */ case   38:  		/* cmplwi CR6, R11, 0 */
		/* 8218C768h case   38:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218C768h case   38:*/		return 0x8218C76C;
		  /* 8218C76Ch */ case   39:  		/* bc 12, CR6_EQ, 68 */
		/* 8218C76Ch case   39:*/		if ( regs.CR[6].eq ) { return 0x8218C7B0;  }
		/* 8218C76Ch case   39:*/		return 0x8218C770;
	}
	return 0x8218C770;
} // Block from 8218C6D0h-8218C770h (40 instructions)

//////////////////////////////////////////////////////
// Block at 8218C770h
// Function '?SetBitRange@?$FixedSizeBitSet@_K$03@D3DXShader@@QAAXII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C770);
		  /* 8218C770h */ case    0:  		/* lwz R8, <#[R6]> */
		/* 8218C770h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + 0x00000000) );
		/* 8218C770h case    0:*/		return 0x8218C774;
		  /* 8218C774h */ case    1:  		/* mr R9, R20 */
		/* 8218C774h case    1:*/		regs.R9 = regs.R20;
		/* 8218C774h case    1:*/		return 0x8218C778;
		  /* 8218C778h */ case    2:  		/* mr R11, R20 */
		/* 8218C778h case    2:*/		regs.R11 = regs.R20;
		/* 8218C778h case    2:*/		return 0x8218C77C;
		  /* 8218C77Ch */ case    3:  		/* rlwinm. R7, R8, 7, 29, 31 */
		/* 8218C77Ch case    3:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R7,regs.R8);
		/* 8218C77Ch case    3:*/		return 0x8218C780;
		  /* 8218C780h */ case    4:  		/* bc 12, CR0_EQ, 44 */
		/* 8218C780h case    4:*/		if ( regs.CR[0].eq ) { return 0x8218C7AC;  }
		/* 8218C780h case    4:*/		return 0x8218C784;
		  /* 8218C784h */ case    5:  		/* mr R10, R20 */
		/* 8218C784h case    5:*/		regs.R10 = regs.R20;
		/* 8218C784h case    5:*/		return 0x8218C788;
		  /* 8218C788h */ case    6:  		/* rlwinm R4, R8, 27, 24, 31 */
		/* 8218C788h case    6:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R4,regs.R8);
		/* 8218C788h case    6:*/		return 0x8218C78C;
		  /* 8218C78Ch */ case    7:  		/* addi R11, R11, 1 */
		/* 8218C78Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218C78Ch case    7:*/		return 0x8218C790;
		  /* 8218C790h */ case    8:  		/* srw R4, R4, R10 */
		/* 8218C790h case    8:*/		cpu::op::srw<0>(regs,&regs.R4,regs.R4,regs.R10);
		/* 8218C790h case    8:*/		return 0x8218C794;
		  /* 8218C794h */ case    9:  		/* rlwinm R4, R4, 0, 30, 31 */
		/* 8218C794h case    9:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R4,regs.R4);
		/* 8218C794h case    9:*/		return 0x8218C798;
		  /* 8218C798h */ case   10:  		/* addi R10, R10, 2 */
		/* 8218C798h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 8218C798h case   10:*/		return 0x8218C79C;
		  /* 8218C79Ch */ case   11:  		/* slw R4, R16, R4 */
		/* 8218C79Ch case   11:*/		cpu::op::slw<0>(regs,&regs.R4,regs.R16,regs.R4);
		/* 8218C79Ch case   11:*/		return 0x8218C7A0;
		  /* 8218C7A0h */ case   12:  		/* or R9, R4, R9 */
		/* 8218C7A0h case   12:*/		cpu::op::or<0>(regs,&regs.R9,regs.R4,regs.R9);
		/* 8218C7A0h case   12:*/		return 0x8218C7A4;
		  /* 8218C7A4h */ case   13:  		/* cmplw CR6, R11, R7 */
		/* 8218C7A4h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 8218C7A4h case   13:*/		return 0x8218C7A8;
		  /* 8218C7A8h */ case   14:  		/* bc 12, CR6_LT, -32 */
		/* 8218C7A8h case   14:*/		if ( regs.CR[6].lt ) { return 0x8218C788;  }
		/* 8218C7A8h case   14:*/		return 0x8218C7AC;
	}
	return 0x8218C7AC;
} // Block from 8218C770h-8218C7ACh (15 instructions)

//////////////////////////////////////////////////////
// Block at 8218C7ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C7AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C7AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C7AC);
		  /* 8218C7ACh */ case    0:  		/* or R5, R9, R5 */
		/* 8218C7ACh case    0:*/		cpu::op::or<0>(regs,&regs.R5,regs.R9,regs.R5);
		/* 8218C7ACh case    0:*/		return 0x8218C7B0;
	}
	return 0x8218C7B0;
} // Block from 8218C7ACh-8218C7B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218C7B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C7B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C7B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C7B0);
		  /* 8218C7B0h */ case    0:  		/* lwz R6, <#[R6 + 8]> */
		/* 8218C7B0h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000008) );
		/* 8218C7B0h case    0:*/		return 0x8218C7B4;
		  /* 8218C7B4h */ case    1:  		/* b -88 */
		/* 8218C7B4h case    1:*/		return 0x8218C75C;
		/* 8218C7B4h case    1:*/		return 0x8218C7B8;
	}
	return 0x8218C7B8;
} // Block from 8218C7B0h-8218C7B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218C7B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C7B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C7B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C7B8);
		  /* 8218C7B8h */ case    0:  		/* addi R11, R1, 96 */
		/* 8218C7B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 8218C7B8h case    0:*/		return 0x8218C7BC;
		  /* 8218C7BCh */ case    1:  		/* addi R3, R30, 44 */
		/* 8218C7BCh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x2C);
		/* 8218C7BCh case    1:*/		return 0x8218C7C0;
		  /* 8218C7C0h */ case    2:  		/* mr R7, R16 */
		/* 8218C7C0h case    2:*/		regs.R7 = regs.R16;
		/* 8218C7C0h case    2:*/		return 0x8218C7C4;
		  /* 8218C7C4h */ case    3:  		/* mr R10, R20 */
		/* 8218C7C4h case    3:*/		regs.R10 = regs.R20;
		/* 8218C7C4h case    3:*/		return 0x8218C7C8;
		  /* 8218C7C8h */ case    4:  		/* addi R6, R11, -4 */
		/* 8218C7C8h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFFFC);
		/* 8218C7C8h case    4:*/		return 0x8218C7CC;
		  /* 8218C7CCh */ case    5:  		/* mr R8, R3 */
		/* 8218C7CCh case    5:*/		regs.R8 = regs.R3;
		/* 8218C7CCh case    5:*/		return 0x8218C7D0;
		  /* 8218C7D0h */ case    6:  		/* and. R11, R7, R5 */
		/* 8218C7D0h case    6:*/		cpu::op::and<1>(regs,&regs.R11,regs.R7,regs.R5);
		/* 8218C7D0h case    6:*/		return 0x8218C7D4;
		  /* 8218C7D4h */ case    7:  		/* bc 12, CR0_EQ, 84 */
		/* 8218C7D4h case    7:*/		if ( regs.CR[0].eq ) { return 0x8218C828;  }
		/* 8218C7D4h case    7:*/		return 0x8218C7D8;
		  /* 8218C7D8h */ case    8:  		/* lfs FR0, <#[R8]> */
		/* 8218C7D8h case    8:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R8 + 0x00000000) );
		/* 8218C7D8h case    8:*/		return 0x8218C7DC;
		  /* 8218C7DCh */ case    9:  		/* mr R11, R20 */
		/* 8218C7DCh case    9:*/		regs.R11 = regs.R20;
		/* 8218C7DCh case    9:*/		return 0x8218C7E0;
		  /* 8218C7E0h */ case   10:  		/* cmplwi CR6, R31, 0 */
		/* 8218C7E0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8218C7E0h case   10:*/		return 0x8218C7E4;
		  /* 8218C7E4h */ case   11:  		/* bc 12, CR6_EQ, 36 */
		/* 8218C7E4h case   11:*/		if ( regs.CR[6].eq ) { return 0x8218C808;  }
		/* 8218C7E4h case   11:*/		return 0x8218C7E8;
		  /* 8218C7E8h */ case   12:  		/* addi R9, R1, 96 */
		/* 8218C7E8h case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 8218C7E8h case   12:*/		return 0x8218C7EC;
		  /* 8218C7ECh */ case   13:  		/* lfs FR13, <#[R9]> */
		/* 8218C7ECh case   13:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R9 + 0x00000000) );
		/* 8218C7ECh case   13:*/		return 0x8218C7F0;
		  /* 8218C7F0h */ case   14:  		/* fcmpu CR6, FR13, FR0 */
		/* 8218C7F0h case   14:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 8218C7F0h case   14:*/		return 0x8218C7F4;
		  /* 8218C7F4h */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 8218C7F4h case   15:*/		if ( regs.CR[6].eq ) { return 0x8218C808;  }
		/* 8218C7F4h case   15:*/		return 0x8218C7F8;
		  /* 8218C7F8h */ case   16:  		/* addi R11, R11, 1 */
		/* 8218C7F8h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218C7F8h case   16:*/		return 0x8218C7FC;
		  /* 8218C7FCh */ case   17:  		/* addi R9, R9, 4 */
		/* 8218C7FCh case   17:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8218C7FCh case   17:*/		return 0x8218C800;
		  /* 8218C800h */ case   18:  		/* cmplw CR6, R11, R31 */
		/* 8218C800h case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 8218C800h case   18:*/		return 0x8218C804;
		  /* 8218C804h */ case   19:  		/* bc 12, CR6_LT, -24 */
		/* 8218C804h case   19:*/		if ( regs.CR[6].lt ) { return 0x8218C7EC;  }
		/* 8218C804h case   19:*/		return 0x8218C808;
	}
	return 0x8218C808;
} // Block from 8218C7B8h-8218C808h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8218C808h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C808);
		  /* 8218C808h */ case    0:  		/* cmplw CR6, R11, R31 */
		/* 8218C808h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 8218C808h case    0:*/		return 0x8218C80C;
		  /* 8218C80Ch */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 8218C80Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8218C818;  }
		/* 8218C80Ch case    1:*/		return 0x8218C810;
		  /* 8218C810h */ case    2:  		/* stfsu FR0, <#[R6 + 4]> */
		/* 8218C810h case    2:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R6 + 0x00000004) );
		regs.R6 = (uint32)(regs.R6 + 0x00000004);
		/* 8218C810h case    2:*/		return 0x8218C814;
		  /* 8218C814h */ case    3:  		/* addi R31, R31, 1 */
		/* 8218C814h case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8218C814h case    3:*/		return 0x8218C818;
	}
	return 0x8218C818;
} // Block from 8218C808h-8218C818h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218C818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C818);
		  /* 8218C818h */ case    0:  		/* slw R9, R15, R10 */
		/* 8218C818h case    0:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R15,regs.R10);
		/* 8218C818h case    0:*/		return 0x8218C81C;
		  /* 8218C81Ch */ case    1:  		/* slw R11, R11, R10 */
		/* 8218C81Ch case    1:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8218C81Ch case    1:*/		return 0x8218C820;
	}
	return 0x8218C820;
} // Block from 8218C818h-8218C820h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218C820h
// Function '?Find@?$RegisterSet@V?$FixedSizeBitSet@_K$03@D3DXShader@@$1?PrintConditionRegister@2@YAXPAVCompiler@2@I@Z$0BAA@$00$1?ReportOutOfBooleanRegistersError@2@YAX0@Z@D3DXShader@@QAAIIIH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C820);
		  /* 8218C820h */ case    0:  		/* andc R9, R29, R9 */
		/* 8218C820h case    0:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R29,regs.R9);
		/* 8218C820h case    0:*/		return 0x8218C824;
		  /* 8218C824h */ case    1:  		/* or R29, R9, R11 */
		/* 8218C824h case    1:*/		cpu::op::or<0>(regs,&regs.R29,regs.R9,regs.R11);
		/* 8218C824h case    1:*/		return 0x8218C828;
	}
	return 0x8218C828;
} // Block from 8218C820h-8218C828h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218C828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C828);
		  /* 8218C828h */ case    0:  		/* addi R10, R10, 2 */
		/* 8218C828h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 8218C828h case    0:*/		return 0x8218C82C;
		  /* 8218C82Ch */ case    1:  		/* addi R8, R8, 4 */
		/* 8218C82Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 8218C82Ch case    1:*/		return 0x8218C830;
		  /* 8218C830h */ case    2:  		/* rlwinm R7, R7, 1, 0, 30 */
		/* 8218C830h case    2:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R7,regs.R7);
		/* 8218C830h case    2:*/		return 0x8218C834;
		  /* 8218C834h */ case    3:  		/* cmplwi CR6, R10, 8 */
		/* 8218C834h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000008);
		/* 8218C834h case    3:*/		return 0x8218C838;
		  /* 8218C838h */ case    4:  		/* bc 12, CR6_LT, -104 */
		/* 8218C838h case    4:*/		if ( regs.CR[6].lt ) { return 0x8218C7D0;  }
		/* 8218C838h case    4:*/		return 0x8218C83C;
		  /* 8218C83Ch */ case    5:  		/* lwz R11, <#[R30 + 8]> */
		/* 8218C83Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8218C83Ch case    5:*/		return 0x8218C840;
		  /* 8218C840h */ case    6:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 8218C840h case    6:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 8218C840h case    6:*/		return 0x8218C844;
		  /* 8218C844h */ case    7:  		/* cmplw CR6, R31, R11 */
		/* 8218C844h case    7:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8218C844h case    7:*/		return 0x8218C848;
		  /* 8218C848h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 8218C848h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8218C854;  }
		/* 8218C848h case    8:*/		return 0x8218C84C;
		  /* 8218C84Ch */ case    9:  		/* srw. R11, R5, R31 */
		/* 8218C84Ch case    9:*/		cpu::op::srw<1>(regs,&regs.R11,regs.R5,regs.R31);
		/* 8218C84Ch case    9:*/		return 0x8218C850;
		  /* 8218C850h */ case   10:  		/* bc 12, CR0_EQ, 196 */
		/* 8218C850h case   10:*/		if ( regs.CR[0].eq ) { return 0x8218C914;  }
		/* 8218C850h case   10:*/		return 0x8218C854;
	}
	return 0x8218C854;
} // Block from 8218C828h-8218C854h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8218C854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C854);
		  /* 8218C854h */ case    0:  		/* rlwinm R5, R31, 2, 0, 29 */
		/* 8218C854h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R31);
		/* 8218C854h case    0:*/		return 0x8218C858;
		  /* 8218C858h */ case    1:  		/* addi R4, R1, 96 */
		/* 8218C858h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 8218C858h case    1:*/		return 0x8218C85C;
		  /* 8218C85Ch */ case    2:  		/* bl -1027756 */
		/* 8218C85Ch case    2:*/		regs.LR = 0x8218C860; return 0x820919B0;
		/* 8218C85Ch case    2:*/		return 0x8218C860;
		  /* 8218C860h */ case    3:  		/* lis R11, -28311 */
		/* 8218C860h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF9169);
		/* 8218C860h case    3:*/		return 0x8218C864;
		  /* 8218C864h */ case    4:  		/* lis R9, 0 */
		/* 8218C864h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0x0);
		/* 8218C864h case    4:*/		return 0x8218C868;
		  /* 8218C868h */ case    5:  		/* lwz R7, <#[R30 + 8]> */
		/* 8218C868h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000008) );
		/* 8218C868h case    5:*/		return 0x8218C86C;
		  /* 8218C86Ch */ case    6:  		/* ori R8, R11, 5192 */
		/* 8218C86Ch case    6:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R11,0x1448);
		/* 8218C86Ch case    6:*/		return 0x8218C870;
		  /* 8218C870h */ case    7:  		/* lwz R10, <#[R30 + 4]> */
		/* 8218C870h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 8218C870h case    7:*/		return 0x8218C874;
		  /* 8218C874h */ case    8:  		/* slw R11, R16, R31 */
		/* 8218C874h case    8:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R16,regs.R31);
		/* 8218C874h case    8:*/		return 0x8218C878;
		  /* 8218C878h */ case    9:  		/* ori R9, R9, 36262 */
		/* 8218C878h case    9:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x8DA6);
		/* 8218C878h case    9:*/		return 0x8218C87C;
		  /* 8218C87Ch */ case   10:  		/* addi R11, R11, -1 */
		/* 8218C87Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8218C87Ch case   10:*/		return 0x8218C880;
		  /* 8218C880h */ case   11:  		/* rldimi R8, R9, 32, 0 */
		/* 8218C880h case   11:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R8,regs.R9);
		/* 8218C880h case   11:*/		return 0x8218C884;
		  /* 8218C884h */ case   12:  		/* rldicl R9, R11, 0, 32 */
		/* 8218C884h case   12:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R11);
		/* 8218C884h case   12:*/		return 0x8218C888;
		  /* 8218C888h */ case   13:  		/* rlwimi R7, R31, 14, 15, 17 */
		/* 8218C888h case   13:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R7,regs.R31);
		/* 8218C888h case   13:*/		return 0x8218C88C;
		  /* 8218C88Ch */ case   14:  		/* srd R8, R8, R9 */
		/* 8218C88Ch case   14:*/		cpu::op::srd<0>(regs,&regs.R8,regs.R8,regs.R9);
		/* 8218C88Ch case   14:*/		return 0x8218C890;
		  /* 8218C890h */ case   15:  		/* srd R8, R8, R9 */
		/* 8218C890h case   15:*/		cpu::op::srd<0>(regs,&regs.R8,regs.R8,regs.R9);
		/* 8218C890h case   15:*/		return 0x8218C894;
		  /* 8218C894h */ case   16:  		/* stw R7, <#[R30 + 8]> */
		/* 8218C894h case   16:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R30 + 0x00000008) );
		/* 8218C894h case   16:*/		return 0x8218C898;
		  /* 8218C898h */ case   17:  		/* srd R9, R8, R9 */
		/* 8218C898h case   17:*/		cpu::op::srd<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8218C898h case   17:*/		return 0x8218C89C;
		  /* 8218C89Ch */ case   18:  		/* rlwinm R9, R9, 0, 0, 31 */
		/* 8218C89Ch case   18:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R9,regs.R9);
		/* 8218C89Ch case   18:*/		return 0x8218C8A0;
		  /* 8218C8A0h */ case   19:  		/* rlwimi R11, R9, 13, 16, 18 */
		/* 8218C8A0h case   19:*/		cpu::op::rlwimi<0,13,16,18>(regs,&regs.R11,regs.R9);
		/* 8218C8A0h case   19:*/		return 0x8218C8A4;
		  /* 8218C8A4h */ case   20:  		/* mr R9, R7 */
		/* 8218C8A4h case   20:*/		regs.R9 = regs.R7;
		/* 8218C8A4h case   20:*/		return 0x8218C8A8;
		  /* 8218C8A8h */ case   21:  		/* rlwimi R9, R11, 1, 27, 30 */
		/* 8218C8A8h case   21:*/		cpu::op::rlwimi<0,1,27,30>(regs,&regs.R9,regs.R11);
		/* 8218C8A8h case   21:*/		return 0x8218C8AC;
		  /* 8218C8ACh */ case   22:  		/* rlwimi R9, R11, 1, 15, 17 */
		/* 8218C8ACh case   22:*/		cpu::op::rlwimi<0,1,15,17>(regs,&regs.R9,regs.R11);
		/* 8218C8ACh case   22:*/		return 0x8218C8B0;
		  /* 8218C8B0h */ case   23:  		/* stw R9, <#[R30 + 8]> */
		/* 8218C8B0h case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 8218C8B0h case   23:*/		return 0x8218C8B4;
		  /* 8218C8B4h */ case   24:  		/* cmplwi CR6, R10, 0 */
		/* 8218C8B4h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8218C8B4h case   24:*/		return 0x8218C8B8;
		  /* 8218C8B8h */ case   25:  		/* bc 12, CR6_EQ, 92 */
		/* 8218C8B8h case   25:*/		if ( regs.CR[6].eq ) { return 0x8218C914;  }
		/* 8218C8B8h case   25:*/		return 0x8218C8BC;
		  /* 8218C8BCh */ case   26:  		/* lwz R11, <#[R10 + 16]> */
		/* 8218C8BCh case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 8218C8BCh case   26:*/		return 0x8218C8C0;
		  /* 8218C8C0h */ case   27:  		/* cmplwi CR6, R11, 0 */
		/* 8218C8C0h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218C8C0h case   27:*/		return 0x8218C8C4;
		  /* 8218C8C4h */ case   28:  		/* bc 12, CR6_EQ, 72 */
		/* 8218C8C4h case   28:*/		if ( regs.CR[6].eq ) { return 0x8218C90C;  }
		/* 8218C8C4h case   28:*/		return 0x8218C8C8;
		  /* 8218C8C8h */ case   29:  		/* lwz R11, <#[R10]> */
		/* 8218C8C8h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8218C8C8h case   29:*/		return 0x8218C8CC;
		  /* 8218C8CCh */ case   30:  		/* rlwinm R9, R11, 22, 29, 30 */
		/* 8218C8CCh case   30:*/		cpu::op::rlwinm<0,22,29,30>(regs,&regs.R9,regs.R11);
		/* 8218C8CCh case   30:*/		return 0x8218C8D0;
	}
	return 0x8218C8D0;
} // Block from 8218C854h-8218C8D0h (31 instructions)

//////////////////////////////////////////////////////
// Block at 8218C8D0h
// Function '?Find@?$RegisterSet@V?$FixedSizeBitSet@I$00@D3DXShader@@$1?PrintSamplerRegister@2@YAXPAVCompiler@2@I@Z$0CA@$00$1?ReportOutOfSamplerRegistersError@2@YAX0@Z@D3DXShader@@QAAIIIH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C8D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C8D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C8D0);
		  /* 8218C8D0h */ case    0:  		/* rlwinm R8, R11, 24, 29, 30 */
		/* 8218C8D0h case    0:*/		cpu::op::rlwinm<0,24,29,30>(regs,&regs.R8,regs.R11);
		/* 8218C8D0h case    0:*/		return 0x8218C8D4;
		  /* 8218C8D4h */ case    1:  		/* srw R9, R29, R9 */
		/* 8218C8D4h case    1:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R29,regs.R9);
		/* 8218C8D4h case    1:*/		return 0x8218C8D8;
		  /* 8218C8D8h */ case    2:  		/* srw R8, R29, R8 */
		/* 8218C8D8h case    2:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R29,regs.R8);
		/* 8218C8D8h case    2:*/		return 0x8218C8DC;
		  /* 8218C8DCh */ case    3:  		/* rlwimi R8, R9, 2, 28, 29 */
		/* 8218C8DCh case    3:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R8,regs.R9);
		/* 8218C8DCh case    3:*/		return 0x8218C8E0;
		  /* 8218C8E0h */ case    4:  		/* rlwinm R9, R11, 26, 29, 30 */
		/* 8218C8E0h case    4:*/		cpu::op::rlwinm<0,26,29,30>(regs,&regs.R9,regs.R11);
		/* 8218C8E0h case    4:*/		return 0x8218C8E4;
		  /* 8218C8E4h */ case    5:  		/* rlwinm R8, R8, 0, 28, 31 */
		/* 8218C8E4h case    5:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R8,regs.R8);
		/* 8218C8E4h case    5:*/		return 0x8218C8E8;
		  /* 8218C8E8h */ case    6:  		/* srw R9, R29, R9 */
		/* 8218C8E8h case    6:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R29,regs.R9);
		/* 8218C8E8h case    6:*/		return 0x8218C8EC;
		  /* 8218C8ECh */ case    7:  		/* rlwinm R7, R11, 28, 29, 30 */
		/* 8218C8ECh case    7:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R7,regs.R11);
		/* 8218C8ECh case    7:*/		return 0x8218C8F0;
		  /* 8218C8F0h */ case    8:  		/* rlwimi R9, R8, 2, 0, 29 */
		/* 8218C8F0h case    8:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 8218C8F0h case    8:*/		return 0x8218C8F4;
		  /* 8218C8F4h */ case    9:  		/* srw R8, R29, R7 */
		/* 8218C8F4h case    9:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R29,regs.R7);
		/* 8218C8F4h case    9:*/		return 0x8218C8F8;
		  /* 8218C8F8h */ case   10:  		/* rlwimi R8, R9, 2, 0, 29 */
		/* 8218C8F8h case   10:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R8,regs.R9);
		/* 8218C8F8h case   10:*/		return 0x8218C8FC;
		  /* 8218C8FCh */ case   11:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 8218C8FCh case   11:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 8218C8FCh case   11:*/		return 0x8218C900;
		  /* 8218C900h */ case   12:  		/* rlwinm R9, R8, 5, 0, 26 */
		/* 8218C900h case   12:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R9,regs.R8);
		/* 8218C900h case   12:*/		return 0x8218C904;
		  /* 8218C904h */ case   13:  		/* or R11, R9, R11 */
		/* 8218C904h case   13:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8218C904h case   13:*/		return 0x8218C908;
		  /* 8218C908h */ case   14:  		/* stw R11, <#[R10]> */
		/* 8218C908h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8218C908h case   14:*/		return 0x8218C90C;
	}
	return 0x8218C90C;
} // Block from 8218C8D0h-8218C90Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8218C90Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C90C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C90C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C90C);
		  /* 8218C90Ch */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 8218C90Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8218C90Ch case    0:*/		return 0x8218C910;
		  /* 8218C910h */ case    1:  		/* b -92 */
		/* 8218C910h case    1:*/		return 0x8218C8B4;
		/* 8218C910h case    1:*/		return 0x8218C914;
	}
	return 0x8218C914;
} // Block from 8218C90Ch-8218C914h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218C914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C914);
		  /* 8218C914h */ case    0:  		/* stwu R30, <#[R28 + 4]> */
		/* 8218C914h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R28 + 0x00000004) );
		regs.R28 = (uint32)(regs.R28 + 0x00000004);
		/* 8218C914h case    0:*/		return 0x8218C918;
		  /* 8218C918h */ case    1:  		/* addi R17, R17, 1 */
		/* 8218C918h case    1:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 8218C918h case    1:*/		return 0x8218C91C;
		  /* 8218C91Ch */ case    2:  		/* b 24 */
		/* 8218C91Ch case    2:*/		return 0x8218C934;
		/* 8218C91Ch case    2:*/		return 0x8218C920;
	}
	return 0x8218C920;
} // Block from 8218C914h-8218C920h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218C920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C920);
		  /* 8218C920h */ case    0:  		/* li R6, 1 */
		/* 8218C920h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8218C920h case    0:*/		return 0x8218C924;
		  /* 8218C924h */ case    1:  		/* li R5, 0 */
		/* 8218C924h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8218C924h case    1:*/		return 0x8218C928;
		  /* 8218C928h */ case    2:  		/* mr R4, R30 */
		/* 8218C928h case    2:*/		regs.R4 = regs.R30;
		/* 8218C928h case    2:*/		return 0x8218C92C;
		  /* 8218C92Ch */ case    3:  		/* mr R3, R19 */
		/* 8218C92Ch case    3:*/		regs.R3 = regs.R19;
		/* 8218C92Ch case    3:*/		return 0x8218C930;
		  /* 8218C930h */ case    4:  		/* bl 649880 */
		/* 8218C930h case    4:*/		regs.LR = 0x8218C934; return 0x8222B3C8;
		/* 8218C930h case    4:*/		return 0x8218C934;
	}
	return 0x8218C934;
} // Block from 8218C920h-8218C934h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218C934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C934);
		  /* 8218C934h */ case    0:  		/* lwz R30, <#[R30 + 32]> */
		/* 8218C934h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000020) );
		/* 8218C934h case    0:*/		return 0x8218C938;
		  /* 8218C938h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 8218C938h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8218C938h case    1:*/		return 0x8218C93C;
		  /* 8218C93Ch */ case    2:  		/* bc 4, CR6_EQ, -536 */
		/* 8218C93Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x8218C724;  }
		/* 8218C93Ch case    2:*/		return 0x8218C940;
	}
	return 0x8218C940;
} // Block from 8218C934h-8218C940h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218C940h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C940);
		  /* 8218C940h */ case    0:  		/* addic. R26, R26, -1 */
		/* 8218C940h case    0:*/		cpu::op::addic<1>(regs,&regs.R26,regs.R26,0xFFFFFFFF);
		/* 8218C940h case    0:*/		return 0x8218C944;
		  /* 8218C944h */ case    1:  		/* addi R27, R27, 4 */
		/* 8218C944h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 8218C944h case    1:*/		return 0x8218C948;
		  /* 8218C948h */ case    2:  		/* bc 4, CR0_EQ, -572 */
		/* 8218C948h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8218C70C;  }
		/* 8218C948h case    2:*/		return 0x8218C94C;
		  /* 8218C94Ch */ case    3:  		/* lis R11, -32231 */
		/* 8218C94Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8219);
		/* 8218C94Ch case    3:*/		return 0x8218C950;
		  /* 8218C950h */ case    4:  		/* li R5, 4 */
		/* 8218C950h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8218C950h case    4:*/		return 0x8218C954;
		  /* 8218C954h */ case    5:  		/* addi R6, R11, -18600 */
		/* 8218C954h case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFB758);
		/* 8218C954h case    5:*/		return 0x8218C958;
		  /* 8218C958h */ case    6:  		/* mr R4, R17 */
		/* 8218C958h case    6:*/		regs.R4 = regs.R17;
		/* 8218C958h case    6:*/		return 0x8218C95C;
		  /* 8218C95Ch */ case    7:  		/* mr R3, R18 */
		/* 8218C95Ch case    7:*/		regs.R3 = regs.R18;
		/* 8218C95Ch case    7:*/		return 0x8218C960;
		  /* 8218C960h */ case    8:  		/* bl -1026432 */
		/* 8218C960h case    8:*/		regs.LR = 0x8218C964; return 0x82091FE0;
		/* 8218C960h case    8:*/		return 0x8218C964;
		  /* 8218C964h */ case    9:  		/* mr R21, R20 */
		/* 8218C964h case    9:*/		regs.R21 = regs.R20;
		/* 8218C964h case    9:*/		return 0x8218C968;
		  /* 8218C968h */ case   10:  		/* cmplwi CR6, R17, 0 */
		/* 8218C968h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 8218C968h case   10:*/		return 0x8218C96C;
		  /* 8218C96Ch */ case   11:  		/* bc 12, CR6_EQ, 1240 */
		/* 8218C96Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x8218CE44;  }
		/* 8218C96Ch case   11:*/		return 0x8218C970;
		  /* 8218C970h */ case   12:  		/* mr R22, R18 */
		/* 8218C970h case   12:*/		regs.R22 = regs.R18;
		/* 8218C970h case   12:*/		return 0x8218C974;
		  /* 8218C974h */ case   13:  		/* lwz R24, <#[R22]> */
		/* 8218C974h case   13:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R22 + 0x00000000) );
		/* 8218C974h case   13:*/		return 0x8218C978;
		  /* 8218C978h */ case   14:  		/* cmplwi CR6, R24, 0 */
		/* 8218C978h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 8218C978h case   14:*/		return 0x8218C97C;
		  /* 8218C97Ch */ case   15:  		/* bc 12, CR6_EQ, 1208 */
		/* 8218C97Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x8218CE34;  }
		/* 8218C97Ch case   15:*/		return 0x8218C980;
	}
	return 0x8218C980;
} // Block from 8218C940h-8218C980h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8218C980h
// Function '?FindLastBitSetInRange@?$FixedSizeBitSet@I$00@D3DXShader@@QAAIII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C980);
		  /* 8218C980h */ case    0:  		/* lwz R11, <#[R24 + 8]> */
		/* 8218C980h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 8218C980h case    0:*/		return 0x8218C984;
		  /* 8218C984h */ case    1:  		/* mr R30, R20 */
		/* 8218C984h case    1:*/		regs.R30 = regs.R20;
		/* 8218C984h case    1:*/		return 0x8218C988;
		  /* 8218C988h */ case    2:  		/* cmplwi CR6, R21, 0 */
		/* 8218C988h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 8218C988h case    2:*/		return 0x8218C98C;
		  /* 8218C98Ch */ case    3:  		/* rlwinm R4, R11, 18, 29, 31 */
		/* 8218C98Ch case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R4,regs.R11);
		/* 8218C98Ch case    3:*/		return 0x8218C990;
		  /* 8218C990h */ case    4:  		/* bc 12, CR6_EQ, 380 */
		/* 8218C990h case    4:*/		if ( regs.CR[6].eq ) { return 0x8218CB0C;  }
		/* 8218C990h case    4:*/		return 0x8218C994;
		  /* 8218C994h */ case    5:  		/* mr R31, R18 */
		/* 8218C994h case    5:*/		regs.R31 = regs.R18;
		/* 8218C994h case    5:*/		return 0x8218C998;
		  /* 8218C998h */ case    6:  		/* lwz R3, <#[R31]> */
		/* 8218C998h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8218C998h case    6:*/		return 0x8218C99C;
		  /* 8218C99Ch */ case    7:  		/* cmplwi CR6, R3, 0 */
		/* 8218C99Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8218C99Ch case    7:*/		return 0x8218C9A0;
		  /* 8218C9A0h */ case    8:  		/* bc 12, CR6_EQ, 140 */
		/* 8218C9A0h case    8:*/		if ( regs.CR[6].eq ) { return 0x8218CA2C;  }
		/* 8218C9A0h case    8:*/		return 0x8218C9A4;
		  /* 8218C9A4h */ case    9:  		/* lwz R11, <#[R3 + 8]> */
		/* 8218C9A4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8218C9A4h case    9:*/		return 0x8218C9A8;
		  /* 8218C9A8h */ case   10:  		/* mr R5, R20 */
		/* 8218C9A8h case   10:*/		regs.R5 = regs.R20;
		/* 8218C9A8h case   10:*/		return 0x8218C9AC;
		  /* 8218C9ACh */ case   11:  		/* mr R7, R20 */
		/* 8218C9ACh case   11:*/		regs.R7 = regs.R20;
		/* 8218C9ACh case   11:*/		return 0x8218C9B0;
		  /* 8218C9B0h */ case   12:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8218C9B0h case   12:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8218C9B0h case   12:*/		return 0x8218C9B4;
		  /* 8218C9B4h */ case   13:  		/* cmplwi CR6, R4, 0 */
		/* 8218C9B4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8218C9B4h case   13:*/		return 0x8218C9B8;
		  /* 8218C9B8h */ case   14:  		/* bc 12, CR6_EQ, 108 */
		/* 8218C9B8h case   14:*/		if ( regs.CR[6].eq ) { return 0x8218CA24;  }
		/* 8218C9B8h case   14:*/		return 0x8218C9BC;
		  /* 8218C9BCh */ case   15:  		/* mr R9, R20 */
		/* 8218C9BCh case   15:*/		regs.R9 = regs.R20;
		/* 8218C9BCh case   15:*/		return 0x8218C9C0;
		  /* 8218C9C0h */ case   16:  		/* addi R8, R24, 44 */
		/* 8218C9C0h case   16:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R24,0x2C);
		/* 8218C9C0h case   16:*/		return 0x8218C9C4;
		  /* 8218C9C4h */ case   17:  		/* lfs FR0, <#[R8]> */
		/* 8218C9C4h case   17:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R8 + 0x00000000) );
		/* 8218C9C4h case   17:*/		return 0x8218C9C8;
		  /* 8218C9C8h */ case   18:  		/* mr R11, R20 */
		/* 8218C9C8h case   18:*/		regs.R11 = regs.R20;
		/* 8218C9C8h case   18:*/		return 0x8218C9CC;
		  /* 8218C9CCh */ case   19:  		/* cmplwi CR6, R6, 0 */
		/* 8218C9CCh case   19:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8218C9CCh case   19:*/		return 0x8218C9D0;
		  /* 8218C9D0h */ case   20:  		/* bc 12, CR6_EQ, 56 */
		/* 8218C9D0h case   20:*/		if ( regs.CR[6].eq ) { return 0x8218CA08;  }
		/* 8218C9D0h case   20:*/		return 0x8218C9D4;
		  /* 8218C9D4h */ case   21:  		/* addi R10, R3, 44 */
		/* 8218C9D4h case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0x2C);
		/* 8218C9D4h case   21:*/		return 0x8218C9D8;
		  /* 8218C9D8h */ case   22:  		/* lfs FR13, <#[R10]> */
		/* 8218C9D8h case   22:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000000) );
		/* 8218C9D8h case   22:*/		return 0x8218C9DC;
		  /* 8218C9DCh */ case   23:  		/* fcmpu CR6, FR0, FR13 */
		/* 8218C9DCh case   23:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 8218C9DCh case   23:*/		return 0x8218C9E0;
		  /* 8218C9E0h */ case   24:  		/* bc 12, CR6_EQ, 24 */
		/* 8218C9E0h case   24:*/		if ( regs.CR[6].eq ) { return 0x8218C9F8;  }
		/* 8218C9E0h case   24:*/		return 0x8218C9E4;
		  /* 8218C9E4h */ case   25:  		/* addi R11, R11, 1 */
		/* 8218C9E4h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218C9E4h case   25:*/		return 0x8218C9E8;
		  /* 8218C9E8h */ case   26:  		/* addi R10, R10, 4 */
		/* 8218C9E8h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8218C9E8h case   26:*/		return 0x8218C9EC;
		  /* 8218C9ECh */ case   27:  		/* cmplw CR6, R11, R6 */
		/* 8218C9ECh case   27:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 8218C9ECh case   27:*/		return 0x8218C9F0;
		  /* 8218C9F0h */ case   28:  		/* bc 12, CR6_LT, -24 */
		/* 8218C9F0h case   28:*/		if ( regs.CR[6].lt ) { return 0x8218C9D8;  }
		/* 8218C9F0h case   28:*/		return 0x8218C9F4;
		  /* 8218C9F4h */ case   29:  		/* b 20 */
		/* 8218C9F4h case   29:*/		return 0x8218CA08;
		/* 8218C9F4h case   29:*/		return 0x8218C9F8;
	}
	return 0x8218C9F8;
} // Block from 8218C980h-8218C9F8h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8218C9F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218C9F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218C9F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218C9F8);
		  /* 8218C9F8h */ case    0:  		/* slw R10, R15, R9 */
		/* 8218C9F8h case    0:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R15,regs.R9);
		/* 8218C9F8h case    0:*/		return 0x8218C9FC;
		  /* 8218C9FCh */ case    1:  		/* slw R29, R11, R9 */
		/* 8218C9FCh case    1:*/		cpu::op::slw<0>(regs,&regs.R29,regs.R11,regs.R9);
		/* 8218C9FCh case    1:*/		return 0x8218CA00;
		  /* 8218CA00h */ case    2:  		/* andc R10, R5, R10 */
		/* 8218CA00h case    2:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R5,regs.R10);
		/* 8218CA00h case    2:*/		return 0x8218CA04;
		  /* 8218CA04h */ case    3:  		/* or R5, R10, R29 */
		/* 8218CA04h case    3:*/		cpu::op::or<0>(regs,&regs.R5,regs.R10,regs.R29);
		/* 8218CA04h case    3:*/		return 0x8218CA08;
	}
	return 0x8218CA08;
} // Block from 8218C9F8h-8218CA08h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218CA08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CA08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CA08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CA08);
		  /* 8218CA08h */ case    0:  		/* cmplw CR6, R11, R6 */
		/* 8218CA08h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 8218CA08h case    0:*/		return 0x8218CA0C;
		  /* 8218CA0Ch */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 8218CA0Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8218CA24;  }
		/* 8218CA0Ch case    1:*/		return 0x8218CA10;
		  /* 8218CA10h */ case    2:  		/* addi R7, R7, 1 */
		/* 8218CA10h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8218CA10h case    2:*/		return 0x8218CA14;
		  /* 8218CA14h */ case    3:  		/* addi R8, R8, 4 */
		/* 8218CA14h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 8218CA14h case    3:*/		return 0x8218CA18;
		  /* 8218CA18h */ case    4:  		/* addi R9, R9, 2 */
		/* 8218CA18h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x2);
		/* 8218CA18h case    4:*/		return 0x8218CA1C;
		  /* 8218CA1Ch */ case    5:  		/* cmplw CR6, R7, R4 */
		/* 8218CA1Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R4);
		/* 8218CA1Ch case    5:*/		return 0x8218CA20;
		  /* 8218CA20h */ case    6:  		/* bc 12, CR6_LT, -92 */
		/* 8218CA20h case    6:*/		if ( regs.CR[6].lt ) { return 0x8218C9C4;  }
		/* 8218CA20h case    6:*/		return 0x8218CA24;
	}
	return 0x8218CA24;
} // Block from 8218CA08h-8218CA24h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218CA24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CA24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CA24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CA24);
		  /* 8218CA24h */ case    0:  		/* cmplw CR6, R7, R4 */
		/* 8218CA24h case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R4);
		/* 8218CA24h case    0:*/		return 0x8218CA28;
		  /* 8218CA28h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 8218CA28h case    1:*/		if ( regs.CR[6].eq ) { return 0x8218CA40;  }
		/* 8218CA28h case    1:*/		return 0x8218CA2C;
	}
	return 0x8218CA2C;
} // Block from 8218CA24h-8218CA2Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218CA2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CA2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CA2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CA2C);
		  /* 8218CA2Ch */ case    0:  		/* addi R30, R30, 1 */
		/* 8218CA2Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8218CA2Ch case    0:*/		return 0x8218CA30;
		  /* 8218CA30h */ case    1:  		/* addi R31, R31, 4 */
		/* 8218CA30h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8218CA30h case    1:*/		return 0x8218CA34;
		  /* 8218CA34h */ case    2:  		/* cmplw CR6, R30, R21 */
		/* 8218CA34h case    2:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R21);
		/* 8218CA34h case    2:*/		return 0x8218CA38;
		  /* 8218CA38h */ case    3:  		/* bc 12, CR6_LT, -160 */
		/* 8218CA38h case    3:*/		if ( regs.CR[6].lt ) { return 0x8218C998;  }
		/* 8218CA38h case    3:*/		return 0x8218CA3C;
		  /* 8218CA3Ch */ case    4:  		/* b 200 */
		/* 8218CA3Ch case    4:*/		return 0x8218CB04;
		/* 8218CA3Ch case    4:*/		return 0x8218CA40;
	}
	return 0x8218CA40;
} // Block from 8218CA2Ch-8218CA40h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218CA40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CA40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CA40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CA40);
		  /* 8218CA40h */ case    0:  		/* addi R8, R24, 4 */
		/* 8218CA40h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R24,0x4);
		/* 8218CA40h case    0:*/		return 0x8218CA44;
		  /* 8218CA44h */ case    1:  		/* lwz R11, <#[R8]> */
		/* 8218CA44h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8218CA44h case    1:*/		return 0x8218CA48;
	}
	return 0x8218CA48;
} // Block from 8218CA40h-8218CA48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218CA48h
// Function '?Reserve@?$RegisterSet@V?$FixedSizeBitSet@_K$0BA@@D3DXShader@@$1?PrintConstantRegister@2@YAXPAVCompiler@2@I@Z$0BAA@$03$1?ReportOutOfConstantRegistersError@2@YAX0@Z@D3DXShader@@QAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CA48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CA48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CA48);
		  /* 8218CA48h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8218CA48h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218CA48h case    0:*/		return 0x8218CA4C;
		  /* 8218CA4Ch */ case    1:  		/* bc 12, CR6_EQ, 160 */
		/* 8218CA4Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8218CAEC;  }
		/* 8218CA4Ch case    1:*/		return 0x8218CA50;
		  /* 8218CA50h */ case    2:  		/* lwz R10, <#[R11 + 16]> */
		/* 8218CA50h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 8218CA50h case    2:*/		return 0x8218CA54;
		  /* 8218CA54h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 8218CA54h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8218CA54h case    3:*/		return 0x8218CA58;
		  /* 8218CA58h */ case    4:  		/* bc 12, CR6_EQ, 128 */
		/* 8218CA58h case    4:*/		if ( regs.CR[6].eq ) { return 0x8218CAD8;  }
		/* 8218CA58h case    4:*/		return 0x8218CA5C;
		  /* 8218CA5Ch */ case    5:  		/* lwz R10, <#[R11 + 12]> */
		/* 8218CA5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8218CA5Ch case    5:*/		return 0x8218CA60;
		  /* 8218CA60h */ case    6:  		/* addi R10, R10, 4 */
		/* 8218CA60h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8218CA60h case    6:*/		return 0x8218CA64;
		  /* 8218CA64h */ case    7:  		/* lwz R9, <#[R10]> */
		/* 8218CA64h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8218CA64h case    7:*/		return 0x8218CA68;
		  /* 8218CA68h */ case    8:  		/* b 12 */
		/* 8218CA68h case    8:*/		return 0x8218CA74;
		/* 8218CA68h case    8:*/		return 0x8218CA6C;
		  /* 8218CA6Ch */ case    9:  		/* addi R10, R9, 8 */
		/* 8218CA6Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 8218CA6Ch case    9:*/		return 0x8218CA70;
		  /* 8218CA70h */ case   10:  		/* lwz R9, <#[R9 + 8]> */
		/* 8218CA70h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 8218CA70h case   10:*/		return 0x8218CA74;
	}
	return 0x8218CA74;
} // Block from 8218CA48h-8218CA74h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8218CA74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CA74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CA74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CA74);
		  /* 8218CA74h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 8218CA74h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8218CA74h case    0:*/		return 0x8218CA78;
		  /* 8218CA78h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 8218CA78h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8218CA6C;  }
		/* 8218CA78h case    1:*/		return 0x8218CA7C;
		  /* 8218CA7Ch */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 8218CA7Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8218CA7Ch case    2:*/		return 0x8218CA80;
		  /* 8218CA80h */ case    3:  		/* stw R9, <#[R10]> */
		/* 8218CA80h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8218CA80h case    3:*/		return 0x8218CA84;
		  /* 8218CA84h */ case    4:  		/* lwz R10, <#[R3 + 4]> */
		/* 8218CA84h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 8218CA84h case    4:*/		return 0x8218CA88;
		  /* 8218CA88h */ case    5:  		/* stw R10, <#[R11 + 8]> */
		/* 8218CA88h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8218CA88h case    5:*/		return 0x8218CA8C;
		  /* 8218CA8Ch */ case    6:  		/* stw R11, <#[R3 + 4]> */
		/* 8218CA8Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8218CA8Ch case    6:*/		return 0x8218CA90;
		  /* 8218CA90h */ case    7:  		/* lwz R10, <#[R11]> */
		/* 8218CA90h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218CA90h case    7:*/		return 0x8218CA94;
		  /* 8218CA94h */ case    8:  		/* rlwinm R9, R10, 22, 29, 30 */
		/* 8218CA94h case    8:*/		cpu::op::rlwinm<0,22,29,30>(regs,&regs.R9,regs.R10);
		/* 8218CA94h case    8:*/		return 0x8218CA98;
		  /* 8218CA98h */ case    9:  		/* rlwinm R7, R10, 24, 29, 30 */
		/* 8218CA98h case    9:*/		cpu::op::rlwinm<0,24,29,30>(regs,&regs.R7,regs.R10);
		/* 8218CA98h case    9:*/		return 0x8218CA9C;
		  /* 8218CA9Ch */ case   10:  		/* stw R3, <#[R11 + 12]> */
		/* 8218CA9Ch case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x0000000C) );
		/* 8218CA9Ch case   10:*/		return 0x8218CAA0;
		  /* 8218CAA0h */ case   11:  		/* srw R9, R5, R9 */
		/* 8218CAA0h case   11:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R5,regs.R9);
		/* 8218CAA0h case   11:*/		return 0x8218CAA4;
		  /* 8218CAA4h */ case   12:  		/* srw R7, R5, R7 */
		/* 8218CAA4h case   12:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R5,regs.R7);
		/* 8218CAA4h case   12:*/		return 0x8218CAA8;
		  /* 8218CAA8h */ case   13:  		/* rlwimi R7, R9, 2, 28, 29 */
		/* 8218CAA8h case   13:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R7,regs.R9);
		/* 8218CAA8h case   13:*/		return 0x8218CAAC;
		  /* 8218CAACh */ case   14:  		/* rlwinm R9, R10, 26, 29, 30 */
		/* 8218CAACh case   14:*/		cpu::op::rlwinm<0,26,29,30>(regs,&regs.R9,regs.R10);
		/* 8218CAACh case   14:*/		return 0x8218CAB0;
		  /* 8218CAB0h */ case   15:  		/* rlwinm R7, R7, 0, 28, 31 */
		/* 8218CAB0h case   15:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R7,regs.R7);
		/* 8218CAB0h case   15:*/		return 0x8218CAB4;
		  /* 8218CAB4h */ case   16:  		/* srw R9, R5, R9 */
		/* 8218CAB4h case   16:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R5,regs.R9);
		/* 8218CAB4h case   16:*/		return 0x8218CAB8;
		  /* 8218CAB8h */ case   17:  		/* rlwinm R6, R10, 28, 29, 30 */
		/* 8218CAB8h case   17:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R6,regs.R10);
		/* 8218CAB8h case   17:*/		return 0x8218CABC;
		  /* 8218CABCh */ case   18:  		/* rlwimi R9, R7, 2, 0, 29 */
		/* 8218CABCh case   18:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R7);
		/* 8218CABCh case   18:*/		return 0x8218CAC0;
	}
	return 0x8218CAC0;
} // Block from 8218CA74h-8218CAC0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8218CAC0h
// Function '?ReserveContiguousRegisters@?$RegisterSet@V?$FixedSizeBitSet@_K$03@D3DXShader@@$1?PrintTempRegister@2@YAXPAVCompiler@2@I@Z$0EA@$03$1?ReportOutOfTempRegistersError@2@YAX0@Z@D3DXShader@@QAAXII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CAC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CAC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CAC0);
		  /* 8218CAC0h */ case    0:  		/* srw R7, R5, R6 */
		/* 8218CAC0h case    0:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R5,regs.R6);
		/* 8218CAC0h case    0:*/		return 0x8218CAC4;
		  /* 8218CAC4h */ case    1:  		/* rlwimi R7, R9, 2, 0, 29 */
		/* 8218CAC4h case    1:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R7,regs.R9);
		/* 8218CAC4h case    1:*/		return 0x8218CAC8;
		  /* 8218CAC8h */ case    2:  		/* rlwinm R10, R10, 0, 27, 18 */
		/* 8218CAC8h case    2:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R10,regs.R10);
		/* 8218CAC8h case    2:*/		return 0x8218CACC;
		  /* 8218CACCh */ case    3:  		/* rlwinm R9, R7, 5, 0, 26 */
		/* 8218CACCh case    3:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R9,regs.R7);
		/* 8218CACCh case    3:*/		return 0x8218CAD0;
		  /* 8218CAD0h */ case    4:  		/* or R10, R9, R10 */
		/* 8218CAD0h case    4:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8218CAD0h case    4:*/		return 0x8218CAD4;
		  /* 8218CAD4h */ case    5:  		/* stw R10, <#[R11]> */
		/* 8218CAD4h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218CAD4h case    5:*/		return 0x8218CAD8;
	}
	return 0x8218CAD8;
} // Block from 8218CAC0h-8218CAD8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218CAD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CAD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CAD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CAD8);
		  /* 8218CAD8h */ case    0:  		/* lwz R10, <#[R8]> */
		/* 8218CAD8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8218CAD8h case    0:*/		return 0x8218CADC;
		  /* 8218CADCh */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 8218CADCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8218CADCh case    1:*/		return 0x8218CAE0;
		  /* 8218CAE0h */ case    2:  		/* bc 4, CR6_EQ, -156 */
		/* 8218CAE0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8218CA44;  }
		/* 8218CAE0h case    2:*/		return 0x8218CAE4;
		  /* 8218CAE4h */ case    3:  		/* addi R8, R11, 8 */
		/* 8218CAE4h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 8218CAE4h case    3:*/		return 0x8218CAE8;
		  /* 8218CAE8h */ case    4:  		/* b -164 */
		/* 8218CAE8h case    4:*/		return 0x8218CA44;
		/* 8218CAE8h case    4:*/		return 0x8218CAEC;
	}
	return 0x8218CAEC;
} // Block from 8218CAD8h-8218CAECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218CAECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CAEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CAEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CAEC);
		  /* 8218CAECh */ case    0:  		/* li R6, 1 */
		/* 8218CAECh case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8218CAECh case    0:*/		return 0x8218CAF0;
		  /* 8218CAF0h */ case    1:  		/* li R5, 0 */
		/* 8218CAF0h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8218CAF0h case    1:*/		return 0x8218CAF4;
		  /* 8218CAF4h */ case    2:  		/* mr R4, R24 */
		/* 8218CAF4h case    2:*/		regs.R4 = regs.R24;
		/* 8218CAF4h case    2:*/		return 0x8218CAF8;
		  /* 8218CAF8h */ case    3:  		/* mr R3, R19 */
		/* 8218CAF8h case    3:*/		regs.R3 = regs.R19;
		/* 8218CAF8h case    3:*/		return 0x8218CAFC;
		  /* 8218CAFCh */ case    4:  		/* bl 649420 */
		/* 8218CAFCh case    4:*/		regs.LR = 0x8218CB00; return 0x8222B3C8;
		/* 8218CAFCh case    4:*/		return 0x8218CB00;
		  /* 8218CB00h */ case    5:  		/* stw R20, <#[R22]> */
		/* 8218CB00h case    5:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R22 + 0x00000000) );
		/* 8218CB00h case    5:*/		return 0x8218CB04;
	}
	return 0x8218CB04;
} // Block from 8218CAECh-8218CB04h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218CB04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CB04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CB04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CB04);
		  /* 8218CB04h */ case    0:  		/* cmplw CR6, R30, R21 */
		/* 8218CB04h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R21);
		/* 8218CB04h case    0:*/		return 0x8218CB08;
		  /* 8218CB08h */ case    1:  		/* bc 12, CR6_LT, 812 */
		/* 8218CB08h case    1:*/		if ( regs.CR[6].lt ) { return 0x8218CE34;  }
		/* 8218CB08h case    1:*/		return 0x8218CB0C;
	}
	return 0x8218CB0C;
} // Block from 8218CB04h-8218CB0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218CB0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CB0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CB0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CB0C);
		  /* 8218CB0Ch */ case    0:  		/* addi R23, R21, 1 */
		/* 8218CB0Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R21,0x1);
		/* 8218CB0Ch case    0:*/		return 0x8218CB10;
		  /* 8218CB10h */ case    1:  		/* lwz R11, <#[R24 + 8]> */
		/* 8218CB10h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 8218CB10h case    1:*/		return 0x8218CB14;
		  /* 8218CB14h */ case    2:  		/* mr R27, R20 */
		/* 8218CB14h case    2:*/		regs.R27 = regs.R20;
		/* 8218CB14h case    2:*/		return 0x8218CB18;
		  /* 8218CB18h */ case    3:  		/* mr R31, R20 */
		/* 8218CB18h case    3:*/		regs.R31 = regs.R20;
		/* 8218CB18h case    3:*/		return 0x8218CB1C;
		  /* 8218CB1Ch */ case    4:  		/* li R28, -1 */
		/* 8218CB1Ch case    4:*/		cpu::op::li<0>(regs,&regs.R28,0xFFFFFFFF);
		/* 8218CB1Ch case    4:*/		return 0x8218CB20;
		  /* 8218CB20h */ case    5:  		/* mr R25, R20 */
		/* 8218CB20h case    5:*/		regs.R25 = regs.R20;
		/* 8218CB20h case    5:*/		return 0x8218CB24;
		  /* 8218CB24h */ case    6:  		/* rlwinm R29, R11, 18, 29, 31 */
		/* 8218CB24h case    6:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R29,regs.R11);
		/* 8218CB24h case    6:*/		return 0x8218CB28;
	}
	return 0x8218CB28;
} // Block from 8218CB0Ch-8218CB28h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218CB28h
// Function '?Alloc@?$RegisterSet@V?$FixedSizeBitSet@_K$0BA@@D3DXShader@@$1?PrintConstantRegister@2@YAXPAVCompiler@2@I@Z$0BAA@$03$1?ReportOutOfConstantRegistersError@2@YAX0@Z@D3DXShader@@QAAII_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CB28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CB28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CB28);
		  /* 8218CB28h */ case    0:  		/* mr R30, R23 */
		/* 8218CB28h case    0:*/		regs.R30 = regs.R23;
		/* 8218CB28h case    0:*/		return 0x8218CB2C;
		  /* 8218CB2Ch */ case    1:  		/* cmplw CR6, R23, R17 */
		/* 8218CB2Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R17);
		/* 8218CB2Ch case    1:*/		return 0x8218CB30;
		  /* 8218CB30h */ case    2:  		/* bc 4, CR6_LT, 772 */
		/* 8218CB30h case    2:*/		if ( !regs.CR[6].lt ) { return 0x8218CE34;  }
		/* 8218CB30h case    2:*/		return 0x8218CB34;
		  /* 8218CB34h */ case    3:  		/* rlwinm R11, R23, 2, 0, 29 */
		/* 8218CB34h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R23);
		/* 8218CB34h case    3:*/		return 0x8218CB38;
		  /* 8218CB38h */ case    4:  		/* add R26, R11, R18 */
		/* 8218CB38h case    4:*/		cpu::op::add<0>(regs,&regs.R26,regs.R11,regs.R18);
		/* 8218CB38h case    4:*/		return 0x8218CB3C;
		  /* 8218CB3Ch */ case    5:  		/* lwz R10, <#[R26]> */
		/* 8218CB3Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 8218CB3Ch case    5:*/		return 0x8218CB40;
		  /* 8218CB40h */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 8218CB40h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8218CB40h case    6:*/		return 0x8218CB44;
		  /* 8218CB44h */ case    7:  		/* bc 12, CR6_EQ, 208 */
		/* 8218CB44h case    7:*/		if ( regs.CR[6].eq ) { return 0x8218CC14;  }
		/* 8218CB44h case    7:*/		return 0x8218CB48;
		  /* 8218CB48h */ case    8:  		/* lwz R11, <#[R10 + 8]> */
		/* 8218CB48h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8218CB48h case    8:*/		return 0x8218CB4C;
		  /* 8218CB4Ch */ case    9:  		/* mr R8, R20 */
		/* 8218CB4Ch case    9:*/		regs.R8 = regs.R20;
		/* 8218CB4Ch case    9:*/		return 0x8218CB50;
		  /* 8218CB50h */ case   10:  		/* mr R6, R20 */
		/* 8218CB50h case   10:*/		regs.R6 = regs.R20;
		/* 8218CB50h case   10:*/		return 0x8218CB54;
		  /* 8218CB54h */ case   11:  		/* rlwinm. R3, R11, 18, 29, 31 */
		/* 8218CB54h case   11:*/		cpu::op::rlwinm<1,18,29,31>(regs,&regs.R3,regs.R11);
		/* 8218CB54h case   11:*/		return 0x8218CB58;
		  /* 8218CB58h */ case   12:  		/* mr R7, R29 */
		/* 8218CB58h case   12:*/		regs.R7 = regs.R29;
		/* 8218CB58h case   12:*/		return 0x8218CB5C;
		  /* 8218CB5Ch */ case   13:  		/* mr R4, R20 */
		/* 8218CB5Ch case   13:*/		regs.R4 = regs.R20;
		/* 8218CB5Ch case   13:*/		return 0x8218CB60;
		  /* 8218CB60h */ case   14:  		/* bc 12, CR0_EQ, 140 */
		/* 8218CB60h case   14:*/		if ( regs.CR[0].eq ) { return 0x8218CBEC;  }
		/* 8218CB60h case   14:*/		return 0x8218CB64;
		  /* 8218CB64h */ case   15:  		/* mr R11, R20 */
		/* 8218CB64h case   15:*/		regs.R11 = regs.R20;
		/* 8218CB64h case   15:*/		return 0x8218CB68;
		  /* 8218CB68h */ case   16:  		/* addi R5, R10, 44 */
		/* 8218CB68h case   16:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x2C);
		/* 8218CB68h case   16:*/		return 0x8218CB6C;
		  /* 8218CB6Ch */ case   17:  		/* lfs FR0, <#[R5]> */
		/* 8218CB6Ch case   17:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R5 + 0x00000000) );
		/* 8218CB6Ch case   17:*/		return 0x8218CB70;
		  /* 8218CB70h */ case   18:  		/* mr R10, R20 */
		/* 8218CB70h case   18:*/		regs.R10 = regs.R20;
		/* 8218CB70h case   18:*/		return 0x8218CB74;
		  /* 8218CB74h */ case   19:  		/* cmplwi CR6, R29, 0 */
		/* 8218CB74h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8218CB74h case   19:*/		return 0x8218CB78;
		  /* 8218CB78h */ case   20:  		/* bc 12, CR6_EQ, 60 */
		/* 8218CB78h case   20:*/		if ( regs.CR[6].eq ) { return 0x8218CBB4;  }
		/* 8218CB78h case   20:*/		return 0x8218CB7C;
		  /* 8218CB7Ch */ case   21:  		/* addi R9, R24, 44 */
		/* 8218CB7Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R24,0x2C);
		/* 8218CB7Ch case   21:*/		return 0x8218CB80;
		  /* 8218CB80h */ case   22:  		/* lfs FR13, <#[R9]> */
		/* 8218CB80h case   22:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R9 + 0x00000000) );
		/* 8218CB80h case   22:*/		return 0x8218CB84;
		  /* 8218CB84h */ case   23:  		/* fcmpu CR6, FR0, FR13 */
		/* 8218CB84h case   23:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 8218CB84h case   23:*/		return 0x8218CB88;
		  /* 8218CB88h */ case   24:  		/* bc 12, CR6_EQ, 24 */
		/* 8218CB88h case   24:*/		if ( regs.CR[6].eq ) { return 0x8218CBA0;  }
		/* 8218CB88h case   24:*/		return 0x8218CB8C;
		  /* 8218CB8Ch */ case   25:  		/* addi R10, R10, 1 */
		/* 8218CB8Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8218CB8Ch case   25:*/		return 0x8218CB90;
		  /* 8218CB90h */ case   26:  		/* addi R9, R9, 4 */
		/* 8218CB90h case   26:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8218CB90h case   26:*/		return 0x8218CB94;
		  /* 8218CB94h */ case   27:  		/* cmplw CR6, R10, R29 */
		/* 8218CB94h case   27:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 8218CB94h case   27:*/		return 0x8218CB98;
		  /* 8218CB98h */ case   28:  		/* bc 12, CR6_LT, -24 */
		/* 8218CB98h case   28:*/		if ( regs.CR[6].lt ) { return 0x8218CB80;  }
		/* 8218CB98h case   28:*/		return 0x8218CB9C;
		  /* 8218CB9Ch */ case   29:  		/* b 24 */
		/* 8218CB9Ch case   29:*/		return 0x8218CBB4;
		/* 8218CB9Ch case   29:*/		return 0x8218CBA0;
	}
	return 0x8218CBA0;
} // Block from 8218CB28h-8218CBA0h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8218CBA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CBA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CBA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CBA0);
		  /* 8218CBA0h */ case    0:  		/* slw R9, R15, R11 */
		/* 8218CBA0h case    0:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R15,regs.R11);
		/* 8218CBA0h case    0:*/		return 0x8218CBA4;
		  /* 8218CBA4h */ case    1:  		/* slw R14, R10, R11 */
		/* 8218CBA4h case    1:*/		cpu::op::slw<0>(regs,&regs.R14,regs.R10,regs.R11);
		/* 8218CBA4h case    1:*/		return 0x8218CBA8;
		  /* 8218CBA8h */ case    2:  		/* andc R9, R8, R9 */
		/* 8218CBA8h case    2:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8218CBA8h case    2:*/		return 0x8218CBAC;
		  /* 8218CBACh */ case    3:  		/* addi R6, R6, 1 */
		/* 8218CBACh case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8218CBACh case    3:*/		return 0x8218CBB0;
		  /* 8218CBB0h */ case    4:  		/* or R8, R9, R14 */
		/* 8218CBB0h case    4:*/		cpu::op::or<0>(regs,&regs.R8,regs.R9,regs.R14);
		/* 8218CBB0h case    4:*/		return 0x8218CBB4;
	}
	return 0x8218CBB4;
} // Block from 8218CBA0h-8218CBB4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218CBB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CBB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CBB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CBB4);
		  /* 8218CBB4h */ case    0:  		/* cmplw CR6, R10, R29 */
		/* 8218CBB4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 8218CBB4h case    0:*/		return 0x8218CBB8;
	}
	return 0x8218CBB8;
} // Block from 8218CBB4h-8218CBB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218CBB8h
// Function '?AllocTopDown@?$RegisterSet@V?$FixedSizeBitSet@_K$0BA@@D3DXShader@@$1?PrintConstantRegister@2@YAXPAVCompiler@2@I@Z$0BAA@$03$1?ReportOutOfConstantRegistersError@2@YAX0@Z@D3DXShader@@QAAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CBB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CBB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CBB8);
		  /* 8218CBB8h */ case    0:  		/* bc 4, CR6_EQ, 32 */
		/* 8218CBB8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8218CBD8;  }
		/* 8218CBB8h case    0:*/		return 0x8218CBBC;
		  /* 8218CBBCh */ case    1:  		/* cmplwi CR6, R7, 4 */
		/* 8218CBBCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000004);
		/* 8218CBBCh case    1:*/		return 0x8218CBC0;
		  /* 8218CBC0h */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 8218CBC0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8218CBEC;  }
		/* 8218CBC0h case    2:*/		return 0x8218CBC4;
		  /* 8218CBC4h */ case    3:  		/* slw R10, R15, R11 */
		/* 8218CBC4h case    3:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R15,regs.R11);
		/* 8218CBC4h case    3:*/		return 0x8218CBC8;
		  /* 8218CBC8h */ case    4:  		/* slw R9, R7, R11 */
		/* 8218CBC8h case    4:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R7,regs.R11);
		/* 8218CBC8h case    4:*/		return 0x8218CBCC;
		  /* 8218CBCCh */ case    5:  		/* andc R10, R8, R10 */
		/* 8218CBCCh case    5:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8218CBCCh case    5:*/		return 0x8218CBD0;
		  /* 8218CBD0h */ case    6:  		/* addi R7, R7, 1 */
		/* 8218CBD0h case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8218CBD0h case    6:*/		return 0x8218CBD4;
		  /* 8218CBD4h */ case    7:  		/* or R8, R10, R9 */
		/* 8218CBD4h case    7:*/		cpu::op::or<0>(regs,&regs.R8,regs.R10,regs.R9);
		/* 8218CBD4h case    7:*/		return 0x8218CBD8;
	}
	return 0x8218CBD8;
} // Block from 8218CBB8h-8218CBD8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218CBD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CBD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CBD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CBD8);
		  /* 8218CBD8h */ case    0:  		/* addi R4, R4, 1 */
		/* 8218CBD8h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 8218CBD8h case    0:*/		return 0x8218CBDC;
		  /* 8218CBDCh */ case    1:  		/* addi R5, R5, 4 */
		/* 8218CBDCh case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 8218CBDCh case    1:*/		return 0x8218CBE0;
		  /* 8218CBE0h */ case    2:  		/* addi R11, R11, 2 */
		/* 8218CBE0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8218CBE0h case    2:*/		return 0x8218CBE4;
		  /* 8218CBE4h */ case    3:  		/* cmplw CR6, R4, R3 */
		/* 8218CBE4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R3);
		/* 8218CBE4h case    3:*/		return 0x8218CBE8;
		  /* 8218CBE8h */ case    4:  		/* bc 12, CR6_LT, -124 */
		/* 8218CBE8h case    4:*/		if ( regs.CR[6].lt ) { return 0x8218CB6C;  }
		/* 8218CBE8h case    4:*/		return 0x8218CBEC;
	}
	return 0x8218CBEC;
} // Block from 8218CBD8h-8218CBECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218CBECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CBEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CBEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CBEC);
		  /* 8218CBECh */ case    0:  		/* cmplw CR6, R4, R3 */
		/* 8218CBECh case    0:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R3);
		/* 8218CBECh case    0:*/		return 0x8218CBF0;
		  /* 8218CBF0h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 8218CBF0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8218CC14;  }
		/* 8218CBF0h case    1:*/		return 0x8218CBF4;
		  /* 8218CBF4h */ case    2:  		/* cmplw CR6, R7, R31 */
		/* 8218CBF4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R31);
		/* 8218CBF4h case    2:*/		return 0x8218CBF8;
		  /* 8218CBF8h */ case    3:  		/* bc 12, CR6_LT, 28 */
		/* 8218CBF8h case    3:*/		if ( regs.CR[6].lt ) { return 0x8218CC14;  }
		/* 8218CBF8h case    3:*/		return 0x8218CBFC;
		  /* 8218CBFCh */ case    4:  		/* cmplw CR6, R6, R27 */
		/* 8218CBFCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R27);
		/* 8218CBFCh case    4:*/		return 0x8218CC00;
		  /* 8218CC00h */ case    5:  		/* bc 12, CR6_LT, 20 */
		/* 8218CC00h case    5:*/		if ( regs.CR[6].lt ) { return 0x8218CC14;  }
		/* 8218CC00h case    5:*/		return 0x8218CC04;
		  /* 8218CC04h */ case    6:  		/* mr R31, R7 */
		/* 8218CC04h case    6:*/		regs.R31 = regs.R7;
		/* 8218CC04h case    6:*/		return 0x8218CC08;
		  /* 8218CC08h */ case    7:  		/* mr R27, R6 */
		/* 8218CC08h case    7:*/		regs.R27 = regs.R6;
		/* 8218CC08h case    7:*/		return 0x8218CC0C;
		  /* 8218CC0Ch */ case    8:  		/* mr R28, R30 */
		/* 8218CC0Ch case    8:*/		regs.R28 = regs.R30;
		/* 8218CC0Ch case    8:*/		return 0x8218CC10;
		  /* 8218CC10h */ case    9:  		/* mr R25, R8 */
		/* 8218CC10h case    9:*/		regs.R25 = regs.R8;
		/* 8218CC10h case    9:*/		return 0x8218CC14;
	}
	return 0x8218CC14;
} // Block from 8218CBECh-8218CC14h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8218CC14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CC14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CC14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CC14);
		  /* 8218CC14h */ case    0:  		/* addi R30, R30, 1 */
		/* 8218CC14h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8218CC14h case    0:*/		return 0x8218CC18;
		  /* 8218CC18h */ case    1:  		/* addi R26, R26, 4 */
		/* 8218CC18h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 8218CC18h case    1:*/		return 0x8218CC1C;
		  /* 8218CC1Ch */ case    2:  		/* cmplw CR6, R30, R17 */
		/* 8218CC1Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R17);
		/* 8218CC1Ch case    2:*/		return 0x8218CC20;
		  /* 8218CC20h */ case    3:  		/* bc 12, CR6_LT, -228 */
		/* 8218CC20h case    3:*/		if ( regs.CR[6].lt ) { return 0x8218CB3C;  }
		/* 8218CC20h case    3:*/		return 0x8218CC24;
		  /* 8218CC24h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8218CC24h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8218CC24h case    4:*/		return 0x8218CC28;
		  /* 8218CC28h */ case    5:  		/* bc 12, CR6_EQ, 524 */
		/* 8218CC28h case    5:*/		if ( regs.CR[6].eq ) { return 0x8218CE34;  }
		/* 8218CC28h case    5:*/		return 0x8218CC2C;
		  /* 8218CC2Ch */ case    6:  		/* rlwinm R28, R28, 2, 0, 29 */
		/* 8218CC2Ch case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R28);
		/* 8218CC2Ch case    6:*/		return 0x8218CC30;
		  /* 8218CC30h */ case    7:  		/* rlwinm R5, R29, 2, 0, 29 */
		/* 8218CC30h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R29);
		/* 8218CC30h case    7:*/		return 0x8218CC34;
		  /* 8218CC34h */ case    8:  		/* addi R4, R24, 44 */
		/* 8218CC34h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R24,0x2C);
		/* 8218CC34h case    8:*/		return 0x8218CC38;
	}
	return 0x8218CC38;
} // Block from 8218CC14h-8218CC38h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218CC38h
// Function '?FindContiguousRegisters@?$RegisterSet@V?$FixedSizeBitSet@_K$0BA@@D3DXShader@@$1?PrintConstantRegister@2@YAXPAVCompiler@2@I@Z$0BAA@$03$1?ReportOutOfConstantRegistersError@2@YAX0@Z@D3DXShader@@QAAIII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CC38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CC38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CC38);
		  /* 8218CC38h */ case    0:  		/* addi R3, R1, 96 */
		/* 8218CC38h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8218CC38h case    0:*/		return 0x8218CC3C;
		  /* 8218CC3Ch */ case    1:  		/* lwzx R30, <#[R28 + R18]> */
		/* 8218CC3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + regs.R18 + 0x00000000) );
		/* 8218CC3Ch case    1:*/		return 0x8218CC40;
		  /* 8218CC40h */ case    2:  		/* bl -1028752 */
		/* 8218CC40h case    2:*/		regs.LR = 0x8218CC44; return 0x820919B0;
		/* 8218CC40h case    2:*/		return 0x8218CC44;
		  /* 8218CC44h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 8218CC44h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8218CC44h case    3:*/		return 0x8218CC48;
		  /* 8218CC48h */ case    4:  		/* bc 12, CR6_EQ, 60 */
		/* 8218CC48h case    4:*/		if ( regs.CR[6].eq ) { return 0x8218CC84;  }
		/* 8218CC48h case    4:*/		return 0x8218CC4C;
		  /* 8218CC4Ch */ case    5:  		/* mr R11, R20 */
		/* 8218CC4Ch case    5:*/		regs.R11 = regs.R20;
		/* 8218CC4Ch case    5:*/		return 0x8218CC50;
		  /* 8218CC50h */ case    6:  		/* mtspr CTR, R31 */
		/* 8218CC50h case    6:*/		regs.CTR = regs.R31;
		/* 8218CC50h case    6:*/		return 0x8218CC54;
		  /* 8218CC54h */ case    7:  		/* addi R9, R30, 44 */
		/* 8218CC54h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0x2C);
		/* 8218CC54h case    7:*/		return 0x8218CC58;
		  /* 8218CC58h */ case    8:  		/* srw R10, R25, R11 */
		/* 8218CC58h case    8:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R25,regs.R11);
		/* 8218CC58h case    8:*/		return 0x8218CC5C;
		  /* 8218CC5Ch */ case    9:  		/* rlwinm R10, R10, 0, 30, 31 */
		/* 8218CC5Ch case    9:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R10);
		/* 8218CC5Ch case    9:*/		return 0x8218CC60;
		  /* 8218CC60h */ case   10:  		/* cmplw CR6, R10, R29 */
		/* 8218CC60h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 8218CC60h case   10:*/		return 0x8218CC64;
		  /* 8218CC64h */ case   11:  		/* bc 12, CR6_LT, 20 */
		/* 8218CC64h case   11:*/		if ( regs.CR[6].lt ) { return 0x8218CC78;  }
		/* 8218CC64h case   11:*/		return 0x8218CC68;
		  /* 8218CC68h */ case   12:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8218CC68h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8218CC68h case   12:*/		return 0x8218CC6C;
		  /* 8218CC6Ch */ case   13:  		/* lfs FR0, <#[R9]> */
		/* 8218CC6Ch case   13:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000000) );
		/* 8218CC6Ch case   13:*/		return 0x8218CC70;
		  /* 8218CC70h */ case   14:  		/* addi R8, R1, 96 */
		/* 8218CC70h case   14:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 8218CC70h case   14:*/		return 0x8218CC74;
		  /* 8218CC74h */ case   15:  		/* stfsx FR0, <#[R10 + R8]> */
		/* 8218CC74h case   15:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 8218CC74h case   15:*/		return 0x8218CC78;
	}
	return 0x8218CC78;
} // Block from 8218CC38h-8218CC78h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8218CC78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CC78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CC78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CC78);
		  /* 8218CC78h */ case    0:  		/* addi R9, R9, 4 */
		/* 8218CC78h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8218CC78h case    0:*/		return 0x8218CC7C;
		  /* 8218CC7Ch */ case    1:  		/* addi R11, R11, 2 */
		/* 8218CC7Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8218CC7Ch case    1:*/		return 0x8218CC80;
		  /* 8218CC80h */ case    2:  		/* bc 16, CR0_LT, -40 */
		/* 8218CC80h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8218CC58;  }
		/* 8218CC80h case    2:*/		return 0x8218CC84;
	}
	return 0x8218CC84;
} // Block from 8218CC78h-8218CC84h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218CC84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CC84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CC84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CC84);
		  /* 8218CC84h */ case    0:  		/* addi R11, R1, 80 */
		/* 8218CC84h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8218CC84h case    0:*/		return 0x8218CC88;
		  /* 8218CC88h */ case    1:  		/* addi R5, R1, 96 */
		/* 8218CC88h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 8218CC88h case    1:*/		return 0x8218CC8C;
		  /* 8218CC8Ch */ case    2:  		/* mr R4, R31 */
		/* 8218CC8Ch case    2:*/		regs.R4 = regs.R31;
		/* 8218CC8Ch case    2:*/		return 0x8218CC90;
		  /* 8218CC90h */ case    3:  		/* mr R3, R19 */
		/* 8218CC90h case    3:*/		regs.R3 = regs.R19;
		/* 8218CC90h case    3:*/		return 0x8218CC94;
		  /* 8218CC94h */ case    4:  		/* stw R20, <#[R11]> */
		/* 8218CC94h case    4:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R11 + 0x00000000) );
		/* 8218CC94h case    4:*/		return 0x8218CC98;
		  /* 8218CC98h */ case    5:  		/* lwz R6, <#[R1 + 80]> */
		/* 8218CC98h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 8218CC98h case    5:*/		return 0x8218CC9C;
		  /* 8218CC9Ch */ case    6:  		/* bl 630364 */
		/* 8218CC9Ch case    6:*/		regs.LR = 0x8218CCA0; return 0x82226AF8;
		/* 8218CC9Ch case    6:*/		return 0x8218CCA0;
		  /* 8218CCA0h */ case    7:  		/* lis R10, -28311 */
		/* 8218CCA0h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF9169);
		/* 8218CCA0h case    7:*/		return 0x8218CCA4;
		  /* 8218CCA4h */ case    8:  		/* lwz R7, <#[R3 + 8]> */
		/* 8218CCA4h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000008) );
		/* 8218CCA4h case    8:*/		return 0x8218CCA8;
		  /* 8218CCA8h */ case    9:  		/* lis R9, 0 */
		/* 8218CCA8h case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0x0);
		/* 8218CCA8h case    9:*/		return 0x8218CCAC;
		  /* 8218CCACh */ case   10:  		/* slw R11, R16, R31 */
		/* 8218CCACh case   10:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R16,regs.R31);
		/* 8218CCACh case   10:*/		return 0x8218CCB0;
		  /* 8218CCB0h */ case   11:  		/* ori R10, R10, 5192 */
		/* 8218CCB0h case   11:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1448);
		/* 8218CCB0h case   11:*/		return 0x8218CCB4;
		  /* 8218CCB4h */ case   12:  		/* ori R9, R9, 36262 */
		/* 8218CCB4h case   12:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x8DA6);
		/* 8218CCB4h case   12:*/		return 0x8218CCB8;
		  /* 8218CCB8h */ case   13:  		/* addi R11, R11, -1 */
		/* 8218CCB8h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8218CCB8h case   13:*/		return 0x8218CCBC;
		  /* 8218CCBCh */ case   14:  		/* rldimi R10, R9, 32, 0 */
		/* 8218CCBCh case   14:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R10,regs.R9);
		/* 8218CCBCh case   14:*/		return 0x8218CCC0;
	}
	return 0x8218CCC0;
} // Block from 8218CC84h-8218CCC0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8218CCC0h
// Function '?ReserveContiguousRegisters@?$RegisterSet@V?$FixedSizeBitSet@I$00@D3DXShader@@$1?PrintIntegerRegister@2@YAXPAVCompiler@2@I@Z$0CA@$00$1?ReportOutOfIntegerRegistersError@2@YAX0@Z@D3DXShader@@QAAXII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CCC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CCC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CCC0);
		  /* 8218CCC0h */ case    0:  		/* rldicl R9, R11, 0, 32 */
		/* 8218CCC0h case    0:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R11);
		/* 8218CCC0h case    0:*/		return 0x8218CCC4;
		  /* 8218CCC4h */ case    1:  		/* mr R31, R3 */
		/* 8218CCC4h case    1:*/		regs.R31 = regs.R3;
		/* 8218CCC4h case    1:*/		return 0x8218CCC8;
		  /* 8218CCC8h */ case    2:  		/* srd R10, R10, R9 */
		/* 8218CCC8h case    2:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8218CCC8h case    2:*/		return 0x8218CCCC;
		  /* 8218CCCCh */ case    3:  		/* srd R10, R10, R9 */
		/* 8218CCCCh case    3:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8218CCCCh case    3:*/		return 0x8218CCD0;
		  /* 8218CCD0h */ case    4:  		/* srd R10, R10, R9 */
		/* 8218CCD0h case    4:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8218CCD0h case    4:*/		return 0x8218CCD4;
		  /* 8218CCD4h */ case    5:  		/* rlwinm R10, R10, 0, 0, 31 */
		/* 8218CCD4h case    5:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R10);
		/* 8218CCD4h case    5:*/		return 0x8218CCD8;
		  /* 8218CCD8h */ case    6:  		/* addi R8, R24, 4 */
		/* 8218CCD8h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R24,0x4);
		/* 8218CCD8h case    6:*/		return 0x8218CCDC;
		  /* 8218CCDCh */ case    7:  		/* rlwimi R11, R10, 13, 16, 18 */
		/* 8218CCDCh case    7:*/		cpu::op::rlwimi<0,13,16,18>(regs,&regs.R11,regs.R10);
		/* 8218CCDCh case    7:*/		return 0x8218CCE0;
		  /* 8218CCE0h */ case    8:  		/* rlwimi R7, R11, 1, 27, 30 */
		/* 8218CCE0h case    8:*/		cpu::op::rlwimi<0,1,27,30>(regs,&regs.R7,regs.R11);
		/* 8218CCE0h case    8:*/		return 0x8218CCE4;
		  /* 8218CCE4h */ case    9:  		/* rlwimi R7, R11, 1, 15, 17 */
		/* 8218CCE4h case    9:*/		cpu::op::rlwimi<0,1,15,17>(regs,&regs.R7,regs.R11);
		/* 8218CCE4h case    9:*/		return 0x8218CCE8;
		  /* 8218CCE8h */ case   10:  		/* stw R7, <#[R3 + 8]> */
		/* 8218CCE8h case   10:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000008) );
		/* 8218CCE8h case   10:*/		return 0x8218CCEC;
		  /* 8218CCECh */ case   11:  		/* lwz R11, <#[R8]> */
		/* 8218CCECh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8218CCECh case   11:*/		return 0x8218CCF0;
		  /* 8218CCF0h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 8218CCF0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218CCF0h case   12:*/		return 0x8218CCF4;
		  /* 8218CCF4h */ case   13:  		/* bc 12, CR6_EQ, 92 */
		/* 8218CCF4h case   13:*/		if ( regs.CR[6].eq ) { return 0x8218CD50;  }
		/* 8218CCF4h case   13:*/		return 0x8218CCF8;
		  /* 8218CCF8h */ case   14:  		/* lwz R10, <#[R11 + 16]> */
		/* 8218CCF8h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 8218CCF8h case   14:*/		return 0x8218CCFC;
		  /* 8218CCFCh */ case   15:  		/* cmplwi CR6, R10, 0 */
		/* 8218CCFCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8218CCFCh case   15:*/		return 0x8218CD00;
		  /* 8218CD00h */ case   16:  		/* bc 12, CR6_EQ, 60 */
		/* 8218CD00h case   16:*/		if ( regs.CR[6].eq ) { return 0x8218CD3C;  }
		/* 8218CD00h case   16:*/		return 0x8218CD04;
		  /* 8218CD04h */ case   17:  		/* lwz R10, <#[R11 + 12]> */
		/* 8218CD04h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8218CD04h case   17:*/		return 0x8218CD08;
		  /* 8218CD08h */ case   18:  		/* addi R10, R10, 4 */
		/* 8218CD08h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8218CD08h case   18:*/		return 0x8218CD0C;
		  /* 8218CD0Ch */ case   19:  		/* lwz R9, <#[R10]> */
		/* 8218CD0Ch case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8218CD0Ch case   19:*/		return 0x8218CD10;
		  /* 8218CD10h */ case   20:  		/* b 12 */
		/* 8218CD10h case   20:*/		return 0x8218CD1C;
		/* 8218CD10h case   20:*/		return 0x8218CD14;
		  /* 8218CD14h */ case   21:  		/* addi R10, R9, 8 */
		/* 8218CD14h case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 8218CD14h case   21:*/		return 0x8218CD18;
		  /* 8218CD18h */ case   22:  		/* lwz R9, <#[R9 + 8]> */
		/* 8218CD18h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 8218CD18h case   22:*/		return 0x8218CD1C;
	}
	return 0x8218CD1C;
} // Block from 8218CCC0h-8218CD1Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 8218CD1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CD1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CD1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CD1C);
		  /* 8218CD1Ch */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 8218CD1Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8218CD1Ch case    0:*/		return 0x8218CD20;
	}
	return 0x8218CD20;
} // Block from 8218CD1Ch-8218CD20h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218CD20h
// Function '?Alloc@?$RegisterSet@V?$FixedSizeBitSet@I$00@D3DXShader@@$1?PrintSamplerRegister@2@YAXPAVCompiler@2@I@Z$0CA@$00$1?ReportOutOfSamplerRegistersError@2@YAX0@Z@D3DXShader@@QAAII_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CD20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CD20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CD20);
		  /* 8218CD20h */ case    0:  		/* bc 4, CR6_EQ, -12 */
		/* 8218CD20h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8218CD14;  }
		/* 8218CD20h case    0:*/		return 0x8218CD24;
		  /* 8218CD24h */ case    1:  		/* lwz R9, <#[R11 + 8]> */
		/* 8218CD24h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8218CD24h case    1:*/		return 0x8218CD28;
		  /* 8218CD28h */ case    2:  		/* stw R9, <#[R10]> */
		/* 8218CD28h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8218CD28h case    2:*/		return 0x8218CD2C;
		  /* 8218CD2Ch */ case    3:  		/* lwz R10, <#[R31 + 4]> */
		/* 8218CD2Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8218CD2Ch case    3:*/		return 0x8218CD30;
		  /* 8218CD30h */ case    4:  		/* stw R10, <#[R11 + 8]> */
		/* 8218CD30h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8218CD30h case    4:*/		return 0x8218CD34;
		  /* 8218CD34h */ case    5:  		/* stw R11, <#[R31 + 4]> */
		/* 8218CD34h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8218CD34h case    5:*/		return 0x8218CD38;
		  /* 8218CD38h */ case    6:  		/* stw R31, <#[R11 + 12]> */
		/* 8218CD38h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x0000000C) );
		/* 8218CD38h case    6:*/		return 0x8218CD3C;
	}
	return 0x8218CD3C;
} // Block from 8218CD20h-8218CD3Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218CD3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CD3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CD3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CD3C);
		  /* 8218CD3Ch */ case    0:  		/* lwz R10, <#[R8]> */
		/* 8218CD3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8218CD3Ch case    0:*/		return 0x8218CD40;
		  /* 8218CD40h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 8218CD40h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8218CD40h case    1:*/		return 0x8218CD44;
		  /* 8218CD44h */ case    2:  		/* bc 4, CR6_EQ, -88 */
		/* 8218CD44h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8218CCEC;  }
		/* 8218CD44h case    2:*/		return 0x8218CD48;
		  /* 8218CD48h */ case    3:  		/* addi R8, R11, 8 */
		/* 8218CD48h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 8218CD48h case    3:*/		return 0x8218CD4C;
		  /* 8218CD4Ch */ case    4:  		/* b -96 */
		/* 8218CD4Ch case    4:*/		return 0x8218CCEC;
		/* 8218CD4Ch case    4:*/		return 0x8218CD50;
	}
	return 0x8218CD50;
} // Block from 8218CD3Ch-8218CD50h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218CD50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CD50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CD50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CD50);
		  /* 8218CD50h */ case    0:  		/* addi R8, R30, 4 */
		/* 8218CD50h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R30,0x4);
		/* 8218CD50h case    0:*/		return 0x8218CD54;
		  /* 8218CD54h */ case    1:  		/* lwz R11, <#[R8]> */
		/* 8218CD54h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8218CD54h case    1:*/		return 0x8218CD58;
		  /* 8218CD58h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8218CD58h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218CD58h case    2:*/		return 0x8218CD5C;
		  /* 8218CD5Ch */ case    3:  		/* bc 12, CR6_EQ, 160 */
		/* 8218CD5Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8218CDFC;  }
		/* 8218CD5Ch case    3:*/		return 0x8218CD60;
		  /* 8218CD60h */ case    4:  		/* lwz R10, <#[R11 + 16]> */
		/* 8218CD60h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 8218CD60h case    4:*/		return 0x8218CD64;
		  /* 8218CD64h */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 8218CD64h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8218CD64h case    5:*/		return 0x8218CD68;
		  /* 8218CD68h */ case    6:  		/* bc 12, CR6_EQ, 128 */
		/* 8218CD68h case    6:*/		if ( regs.CR[6].eq ) { return 0x8218CDE8;  }
		/* 8218CD68h case    6:*/		return 0x8218CD6C;
		  /* 8218CD6Ch */ case    7:  		/* lwz R10, <#[R11 + 12]> */
		/* 8218CD6Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8218CD6Ch case    7:*/		return 0x8218CD70;
		  /* 8218CD70h */ case    8:  		/* addi R10, R10, 4 */
		/* 8218CD70h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8218CD70h case    8:*/		return 0x8218CD74;
		  /* 8218CD74h */ case    9:  		/* lwz R9, <#[R10]> */
		/* 8218CD74h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8218CD74h case    9:*/		return 0x8218CD78;
		  /* 8218CD78h */ case   10:  		/* b 12 */
		/* 8218CD78h case   10:*/		return 0x8218CD84;
		/* 8218CD78h case   10:*/		return 0x8218CD7C;
		  /* 8218CD7Ch */ case   11:  		/* addi R10, R9, 8 */
		/* 8218CD7Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 8218CD7Ch case   11:*/		return 0x8218CD80;
		  /* 8218CD80h */ case   12:  		/* lwz R9, <#[R9 + 8]> */
		/* 8218CD80h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 8218CD80h case   12:*/		return 0x8218CD84;
	}
	return 0x8218CD84;
} // Block from 8218CD50h-8218CD84h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8218CD84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CD84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CD84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CD84);
		  /* 8218CD84h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 8218CD84h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8218CD84h case    0:*/		return 0x8218CD88;
		  /* 8218CD88h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 8218CD88h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8218CD7C;  }
		/* 8218CD88h case    1:*/		return 0x8218CD8C;
		  /* 8218CD8Ch */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 8218CD8Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8218CD8Ch case    2:*/		return 0x8218CD90;
		  /* 8218CD90h */ case    3:  		/* stw R9, <#[R10]> */
		/* 8218CD90h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8218CD90h case    3:*/		return 0x8218CD94;
		  /* 8218CD94h */ case    4:  		/* lwz R10, <#[R31 + 4]> */
		/* 8218CD94h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8218CD94h case    4:*/		return 0x8218CD98;
		  /* 8218CD98h */ case    5:  		/* stw R10, <#[R11 + 8]> */
		/* 8218CD98h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8218CD98h case    5:*/		return 0x8218CD9C;
		  /* 8218CD9Ch */ case    6:  		/* stw R11, <#[R31 + 4]> */
		/* 8218CD9Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8218CD9Ch case    6:*/		return 0x8218CDA0;
		  /* 8218CDA0h */ case    7:  		/* lwz R10, <#[R11]> */
		/* 8218CDA0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218CDA0h case    7:*/		return 0x8218CDA4;
		  /* 8218CDA4h */ case    8:  		/* rlwinm R9, R10, 22, 29, 30 */
		/* 8218CDA4h case    8:*/		cpu::op::rlwinm<0,22,29,30>(regs,&regs.R9,regs.R10);
		/* 8218CDA4h case    8:*/		return 0x8218CDA8;
		  /* 8218CDA8h */ case    9:  		/* rlwinm R7, R10, 24, 29, 30 */
		/* 8218CDA8h case    9:*/		cpu::op::rlwinm<0,24,29,30>(regs,&regs.R7,regs.R10);
		/* 8218CDA8h case    9:*/		return 0x8218CDAC;
		  /* 8218CDACh */ case   10:  		/* stw R31, <#[R11 + 12]> */
		/* 8218CDACh case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x0000000C) );
		/* 8218CDACh case   10:*/		return 0x8218CDB0;
		  /* 8218CDB0h */ case   11:  		/* srw R9, R25, R9 */
		/* 8218CDB0h case   11:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R25,regs.R9);
		/* 8218CDB0h case   11:*/		return 0x8218CDB4;
		  /* 8218CDB4h */ case   12:  		/* srw R7, R25, R7 */
		/* 8218CDB4h case   12:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R25,regs.R7);
		/* 8218CDB4h case   12:*/		return 0x8218CDB8;
		  /* 8218CDB8h */ case   13:  		/* rlwimi R7, R9, 2, 28, 29 */
		/* 8218CDB8h case   13:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R7,regs.R9);
		/* 8218CDB8h case   13:*/		return 0x8218CDBC;
		  /* 8218CDBCh */ case   14:  		/* rlwinm R9, R10, 26, 29, 30 */
		/* 8218CDBCh case   14:*/		cpu::op::rlwinm<0,26,29,30>(regs,&regs.R9,regs.R10);
		/* 8218CDBCh case   14:*/		return 0x8218CDC0;
		  /* 8218CDC0h */ case   15:  		/* rlwinm R7, R7, 0, 28, 31 */
		/* 8218CDC0h case   15:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R7,regs.R7);
		/* 8218CDC0h case   15:*/		return 0x8218CDC4;
		  /* 8218CDC4h */ case   16:  		/* srw R9, R25, R9 */
		/* 8218CDC4h case   16:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R25,regs.R9);
		/* 8218CDC4h case   16:*/		return 0x8218CDC8;
		  /* 8218CDC8h */ case   17:  		/* rlwinm R6, R10, 28, 29, 30 */
		/* 8218CDC8h case   17:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R6,regs.R10);
		/* 8218CDC8h case   17:*/		return 0x8218CDCC;
		  /* 8218CDCCh */ case   18:  		/* rlwimi R9, R7, 2, 0, 29 */
		/* 8218CDCCh case   18:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R7);
		/* 8218CDCCh case   18:*/		return 0x8218CDD0;
		  /* 8218CDD0h */ case   19:  		/* srw R7, R25, R6 */
		/* 8218CDD0h case   19:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R25,regs.R6);
		/* 8218CDD0h case   19:*/		return 0x8218CDD4;
		  /* 8218CDD4h */ case   20:  		/* rlwimi R7, R9, 2, 0, 29 */
		/* 8218CDD4h case   20:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R7,regs.R9);
		/* 8218CDD4h case   20:*/		return 0x8218CDD8;
	}
	return 0x8218CDD8;
} // Block from 8218CD84h-8218CDD8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8218CDD8h
// Function '?Reserve@?$RegisterSet@V?$FixedSizeBitSet@_K$03@D3DXShader@@$1?PrintConditionRegister@2@YAXPAVCompiler@2@I@Z$0BAA@$00$1?ReportOutOfBooleanRegistersError@2@YAX0@Z@D3DXShader@@QAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CDD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CDD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CDD8);
		  /* 8218CDD8h */ case    0:  		/* rlwinm R10, R10, 0, 27, 18 */
		/* 8218CDD8h case    0:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R10,regs.R10);
		/* 8218CDD8h case    0:*/		return 0x8218CDDC;
		  /* 8218CDDCh */ case    1:  		/* rlwinm R9, R7, 5, 0, 26 */
		/* 8218CDDCh case    1:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R9,regs.R7);
		/* 8218CDDCh case    1:*/		return 0x8218CDE0;
		  /* 8218CDE0h */ case    2:  		/* or R10, R9, R10 */
		/* 8218CDE0h case    2:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8218CDE0h case    2:*/		return 0x8218CDE4;
		  /* 8218CDE4h */ case    3:  		/* stw R10, <#[R11]> */
		/* 8218CDE4h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218CDE4h case    3:*/		return 0x8218CDE8;
	}
	return 0x8218CDE8;
} // Block from 8218CDD8h-8218CDE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218CDE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CDE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CDE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CDE8);
		  /* 8218CDE8h */ case    0:  		/* lwz R10, <#[R8]> */
		/* 8218CDE8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8218CDE8h case    0:*/		return 0x8218CDEC;
		  /* 8218CDECh */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 8218CDECh case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8218CDECh case    1:*/		return 0x8218CDF0;
		  /* 8218CDF0h */ case    2:  		/* bc 4, CR6_EQ, -156 */
		/* 8218CDF0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8218CD54;  }
		/* 8218CDF0h case    2:*/		return 0x8218CDF4;
		  /* 8218CDF4h */ case    3:  		/* addi R8, R11, 8 */
		/* 8218CDF4h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 8218CDF4h case    3:*/		return 0x8218CDF8;
		  /* 8218CDF8h */ case    4:  		/* b -164 */
		/* 8218CDF8h case    4:*/		return 0x8218CD54;
		/* 8218CDF8h case    4:*/		return 0x8218CDFC;
	}
	return 0x8218CDFC;
} // Block from 8218CDE8h-8218CDFCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218CDFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CDFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CDFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CDFC);
		  /* 8218CDFCh */ case    0:  		/* li R6, 1 */
		/* 8218CDFCh case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8218CDFCh case    0:*/		return 0x8218CE00;
		  /* 8218CE00h */ case    1:  		/* li R5, 0 */
		/* 8218CE00h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8218CE00h case    1:*/		return 0x8218CE04;
		  /* 8218CE04h */ case    2:  		/* mr R4, R24 */
		/* 8218CE04h case    2:*/		regs.R4 = regs.R24;
		/* 8218CE04h case    2:*/		return 0x8218CE08;
		  /* 8218CE08h */ case    3:  		/* mr R3, R19 */
		/* 8218CE08h case    3:*/		regs.R3 = regs.R19;
		/* 8218CE08h case    3:*/		return 0x8218CE0C;
		  /* 8218CE0Ch */ case    4:  		/* bl 648636 */
		/* 8218CE0Ch case    4:*/		regs.LR = 0x8218CE10; return 0x8222B3C8;
		/* 8218CE0Ch case    4:*/		return 0x8218CE10;
		  /* 8218CE10h */ case    5:  		/* stw R31, <#[R22]> */
		/* 8218CE10h case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R22 + 0x00000000) );
		/* 8218CE10h case    5:*/		return 0x8218CE14;
		  /* 8218CE14h */ case    6:  		/* li R6, 1 */
		/* 8218CE14h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8218CE14h case    6:*/		return 0x8218CE18;
		  /* 8218CE18h */ case    7:  		/* li R5, 0 */
		/* 8218CE18h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8218CE18h case    7:*/		return 0x8218CE1C;
		  /* 8218CE1Ch */ case    8:  		/* mr R4, R30 */
		/* 8218CE1Ch case    8:*/		regs.R4 = regs.R30;
		/* 8218CE1Ch case    8:*/		return 0x8218CE20;
		  /* 8218CE20h */ case    9:  		/* mr R3, R19 */
		/* 8218CE20h case    9:*/		regs.R3 = regs.R19;
		/* 8218CE20h case    9:*/		return 0x8218CE24;
		  /* 8218CE24h */ case   10:  		/* bl 648612 */
		/* 8218CE24h case   10:*/		regs.LR = 0x8218CE28; return 0x8222B3C8;
		/* 8218CE24h case   10:*/		return 0x8218CE28;
		  /* 8218CE28h */ case   11:  		/* mr R24, R31 */
		/* 8218CE28h case   11:*/		regs.R24 = regs.R31;
		/* 8218CE28h case   11:*/		return 0x8218CE2C;
		  /* 8218CE2Ch */ case   12:  		/* stwx R20, <#[R28 + R18]> */
		/* 8218CE2Ch case   12:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R28 + regs.R18 + 0x00000000) );
		/* 8218CE2Ch case   12:*/		return 0x8218CE30;
		  /* 8218CE30h */ case   13:  		/* b -800 */
		/* 8218CE30h case   13:*/		return 0x8218CB10;
		/* 8218CE30h case   13:*/		return 0x8218CE34;
	}
	return 0x8218CE34;
} // Block from 8218CDFCh-8218CE34h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8218CE34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CE34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CE34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CE34);
		  /* 8218CE34h */ case    0:  		/* addi R21, R21, 1 */
		/* 8218CE34h case    0:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 8218CE34h case    0:*/		return 0x8218CE38;
		  /* 8218CE38h */ case    1:  		/* addi R22, R22, 4 */
		/* 8218CE38h case    1:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x4);
		/* 8218CE38h case    1:*/		return 0x8218CE3C;
		  /* 8218CE3Ch */ case    2:  		/* cmplw CR6, R21, R17 */
		/* 8218CE3Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R17);
		/* 8218CE3Ch case    2:*/		return 0x8218CE40;
	}
	return 0x8218CE40;
} // Block from 8218CE34h-8218CE40h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218CE40h
// Function '?ReserveContiguousRegisters@?$RegisterSet@V?$FixedSizeBitSet@_K$03@D3DXShader@@$1?PrintConditionRegister@2@YAXPAVCompiler@2@I@Z$0BAA@$00$1?ReportOutOfBooleanRegistersError@2@YAX0@Z@D3DXShader@@QAAXII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CE40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CE40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CE40);
		  /* 8218CE40h */ case    0:  		/* bc 12, CR6_LT, -1228 */
		/* 8218CE40h case    0:*/		if ( regs.CR[6].lt ) { return 0x8218C974;  }
		/* 8218CE40h case    0:*/		return 0x8218CE44;
	}
	return 0x8218CE44;
} // Block from 8218CE40h-8218CE44h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218CE44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CE44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CE44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CE44);
		  /* 8218CE44h */ case    0:  		/* addi R1, R1, 272 */
		/* 8218CE44h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x110);
		/* 8218CE44h case    0:*/		return 0x8218CE48;
		  /* 8218CE48h */ case    1:  		/* b -1031128 */
		/* 8218CE48h case    1:*/		return 0x82091270;
		/* 8218CE48h case    1:*/		return 0x8218CE4C;
		  /* 8218CE4Ch */ case    2:  		/* nop */
		/* 8218CE4Ch case    2:*/		cpu::op::nop();
		/* 8218CE4Ch case    2:*/		return 0x8218CE50;
	}
	return 0x8218CE50;
} // Block from 8218CE44h-8218CE50h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218CE50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CE50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CE50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CE50);
		  /* 8218CE50h */ case    0:  		/* mfspr R12, LR */
		/* 8218CE50h case    0:*/		regs.R12 = regs.LR;
		/* 8218CE50h case    0:*/		return 0x8218CE54;
		  /* 8218CE54h */ case    1:  		/* bl -1031200 */
		/* 8218CE54h case    1:*/		regs.LR = 0x8218CE58; return 0x82091234;
		/* 8218CE54h case    1:*/		return 0x8218CE58;
		  /* 8218CE58h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 8218CE58h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 8218CE58h case    2:*/		return 0x8218CE5C;
		  /* 8218CE5Ch */ case    3:  		/* li R21, -1 */
		/* 8218CE5Ch case    3:*/		cpu::op::li<0>(regs,&regs.R21,0xFFFFFFFF);
		/* 8218CE5Ch case    3:*/		return 0x8218CE60;
		  /* 8218CE60h */ case    4:  		/* mr R22, R4 */
		/* 8218CE60h case    4:*/		regs.R22 = regs.R4;
		/* 8218CE60h case    4:*/		return 0x8218CE64;
		  /* 8218CE64h */ case    5:  		/* mr R19, R3 */
		/* 8218CE64h case    5:*/		regs.R19 = regs.R3;
		/* 8218CE64h case    5:*/		return 0x8218CE68;
		  /* 8218CE68h */ case    6:  		/* mr R27, R5 */
		/* 8218CE68h case    6:*/		regs.R27 = regs.R5;
		/* 8218CE68h case    6:*/		return 0x8218CE6C;
		  /* 8218CE6Ch */ case    7:  		/* li R4, 0 */
		/* 8218CE6Ch case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8218CE6Ch case    7:*/		return 0x8218CE70;
		  /* 8218CE70h */ case    8:  		/* mr R23, R21 */
		/* 8218CE70h case    8:*/		regs.R23 = regs.R21;
		/* 8218CE70h case    8:*/		return 0x8218CE74;
		  /* 8218CE74h */ case    9:  		/* mr R20, R21 */
		/* 8218CE74h case    9:*/		regs.R20 = regs.R21;
		/* 8218CE74h case    9:*/		return 0x8218CE78;
		  /* 8218CE78h */ case   10:  		/* li R25, 0 */
		/* 8218CE78h case   10:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 8218CE78h case   10:*/		return 0x8218CE7C;
		  /* 8218CE7Ch */ case   11:  		/* subfic R24, R5, 256 */
		/* 8218CE7Ch case   11:*/		cpu::op::subfic<0>(regs,&regs.R24,regs.R5,0x100);
		/* 8218CE7Ch case   11:*/		return 0x8218CE80;
		  /* 8218CE80h */ case   12:  		/* mr R5, R27 */
		/* 8218CE80h case   12:*/		regs.R5 = regs.R27;
		/* 8218CE80h case   12:*/		return 0x8218CE84;
		  /* 8218CE84h */ case   13:  		/* mr R3, R22 */
		/* 8218CE84h case   13:*/		regs.R3 = regs.R22;
		/* 8218CE84h case   13:*/		return 0x8218CE88;
		  /* 8218CE88h */ case   14:  		/* bl -3336 */
		/* 8218CE88h case   14:*/		regs.LR = 0x8218CE8C; return 0x8218C180;
		/* 8218CE88h case   14:*/		return 0x8218CE8C;
		  /* 8218CE8Ch */ case   15:  		/* mr R31, R3 */
		/* 8218CE8Ch case   15:*/		regs.R31 = regs.R3;
		/* 8218CE8Ch case   15:*/		return 0x8218CE90;
		  /* 8218CE90h */ case   16:  		/* cmpwi CR6, R3, -1 */
		/* 8218CE90h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218CE90h case   16:*/		return 0x8218CE94;
		  /* 8218CE94h */ case   17:  		/* bc 12, CR6_EQ, 388 */
		/* 8218CE94h case   17:*/		if ( regs.CR[6].eq ) { return 0x8218D018;  }
		/* 8218CE94h case   17:*/		return 0x8218CE98;
		  /* 8218CE98h */ case   18:  		/* rlwinm R4, R3, 2, 0, 29 */
		/* 8218CE98h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R3);
		/* 8218CE98h case   18:*/		return 0x8218CE9C;
		  /* 8218CE9Ch */ case   19:  		/* addi R3, R22, 8 */
		/* 8218CE9Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R22,0x8);
		/* 8218CE9Ch case   19:*/		return 0x8218CEA0;
	}
	return 0x8218CEA0;
} // Block from 8218CE50h-8218CEA0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8218CEA0h
// Function '?Alloc@?$RegisterSet@V?$FixedSizeBitSet@_K$03@D3DXShader@@$1?PrintConditionRegister@2@YAXPAVCompiler@2@I@Z$0BAA@$00$1?ReportOutOfBooleanRegistersError@2@YAX0@Z@D3DXShader@@QAAII_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CEA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CEA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CEA0);
		  /* 8218CEA0h */ case    0:  		/* bl -5928 */
		/* 8218CEA0h case    0:*/		regs.LR = 0x8218CEA4; return 0x8218B778;
		/* 8218CEA0h case    0:*/		return 0x8218CEA4;
		  /* 8218CEA4h */ case    1:  		/* cmpwi CR6, R3, -1 */
		/* 8218CEA4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218CEA4h case    1:*/		return 0x8218CEA8;
		  /* 8218CEA8h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8218CEA8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8218CEB8;  }
		/* 8218CEA8h case    2:*/		return 0x8218CEAC;
		  /* 8218CEACh */ case    3:  		/* rlwinm R28, R3, 30, 2, 31 */
		/* 8218CEACh case    3:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R28,regs.R3);
		/* 8218CEACh case    3:*/		return 0x8218CEB0;
		  /* 8218CEB0h */ case    4:  		/* cmpwi CR6, R28, -1 */
		/* 8218CEB0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R28,0xFFFFFFFF);
		/* 8218CEB0h case    4:*/		return 0x8218CEB4;
		  /* 8218CEB4h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 8218CEB4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8218CEBC;  }
		/* 8218CEB4h case    5:*/		return 0x8218CEB8;
	}
	return 0x8218CEB8;
} // Block from 8218CEA0h-8218CEB8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218CEB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CEB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CEB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CEB8);
		  /* 8218CEB8h */ case    0:  		/* add R28, R24, R27 */
		/* 8218CEB8h case    0:*/		cpu::op::add<0>(regs,&regs.R28,regs.R24,regs.R27);
		/* 8218CEB8h case    0:*/		return 0x8218CEBC;
	}
	return 0x8218CEBC;
} // Block from 8218CEB8h-8218CEBCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218CEBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CEBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CEBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CEBC);
		  /* 8218CEBCh */ case    0:  		/* add R11, R31, R27 */
		/* 8218CEBCh case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R27);
		/* 8218CEBCh case    0:*/		return 0x8218CEC0;
		  /* 8218CEC0h */ case    1:  		/* rlwinm R26, R28, 0, 0, 29 */
		/* 8218CEC0h case    1:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R26,regs.R28);
		/* 8218CEC0h case    1:*/		return 0x8218CEC4;
		  /* 8218CEC4h */ case    2:  		/* rlwinm R10, R11, 0, 0, 29 */
		/* 8218CEC4h case    2:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R10,regs.R11);
		/* 8218CEC4h case    2:*/		return 0x8218CEC8;
		  /* 8218CEC8h */ case    3:  		/* cmplw CR6, R10, R26 */
		/* 8218CEC8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R26);
		/* 8218CEC8h case    3:*/		return 0x8218CECC;
		  /* 8218CECCh */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 8218CECCh case    4:*/		if ( !regs.CR[6].eq ) { return 0x8218CED8;  }
		/* 8218CECCh case    4:*/		return 0x8218CED0;
		  /* 8218CED0h */ case    5:  		/* subf R29, R11, R28 */
		/* 8218CED0h case    5:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R11,regs.R28);
		/* 8218CED0h case    5:*/		return 0x8218CED4;
		  /* 8218CED4h */ case    6:  		/* b 28 */
		/* 8218CED4h case    6:*/		return 0x8218CEF0;
		/* 8218CED4h case    6:*/		return 0x8218CED8;
	}
	return 0x8218CED8;
} // Block from 8218CEBCh-8218CED8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218CED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CED8);
		  /* 8218CED8h */ case    0:  		/* subf R29, R26, R28 */
		/* 8218CED8h case    0:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R26,regs.R28);
		/* 8218CED8h case    0:*/		return 0x8218CEDC;
		  /* 8218CEDCh */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 8218CEDCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8218CEDCh case    1:*/		return 0x8218CEE0;
		  /* 8218CEE0h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8218CEE0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8218CEF0;  }
		/* 8218CEE0h case    2:*/		return 0x8218CEE4;
		  /* 8218CEE4h */ case    3:  		/* subf R11, R11, R29 */
		/* 8218CEE4h case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8218CEE4h case    3:*/		return 0x8218CEE8;
		  /* 8218CEE8h */ case    4:  		/* add R11, R11, R10 */
		/* 8218CEE8h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8218CEE8h case    4:*/		return 0x8218CEEC;
		  /* 8218CEECh */ case    5:  		/* addi R29, R11, 4 */
		/* 8218CEECh case    5:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x4);
		/* 8218CEECh case    5:*/		return 0x8218CEF0;
	}
	return 0x8218CEF0;
} // Block from 8218CED8h-8218CEF0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218CEF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CEF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CEF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CEF0);
		  /* 8218CEF0h */ case    0:  		/* cmplw CR6, R28, R24 */
		/* 8218CEF0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R24);
		/* 8218CEF0h case    0:*/		return 0x8218CEF4;
		  /* 8218CEF4h */ case    1:  		/* bc 12, CR6_LT, 12 */
		/* 8218CEF4h case    1:*/		if ( regs.CR[6].lt ) { return 0x8218CF00;  }
		/* 8218CEF4h case    1:*/		return 0x8218CEF8;
		  /* 8218CEF8h */ case    2:  		/* mr R7, R21 */
		/* 8218CEF8h case    2:*/		regs.R7 = regs.R21;
		/* 8218CEF8h case    2:*/		return 0x8218CEFC;
		  /* 8218CEFCh */ case    3:  		/* b 56 */
		/* 8218CEFCh case    3:*/		return 0x8218CF34;
		/* 8218CEFCh case    3:*/		return 0x8218CF00;
	}
	return 0x8218CF00;
} // Block from 8218CEF0h-8218CF00h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218CF00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CF00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CF00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CF00);
		  /* 8218CF00h */ case    0:  		/* subf R10, R27, R28 */
		/* 8218CF00h case    0:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R27,regs.R28);
		/* 8218CF00h case    0:*/		return 0x8218CF04;
		  /* 8218CF04h */ case    1:  		/* rlwinm R11, R31, 0, 0, 29 */
		/* 8218CF04h case    1:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R31);
		/* 8218CF04h case    1:*/		return 0x8218CF08;
		  /* 8218CF08h */ case    2:  		/* rlwinm R9, R10, 0, 0, 29 */
		/* 8218CF08h case    2:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R9,regs.R10);
		/* 8218CF08h case    2:*/		return 0x8218CF0C;
		  /* 8218CF0Ch */ case    3:  		/* cmplw CR6, R11, R9 */
		/* 8218CF0Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8218CF0Ch case    3:*/		return 0x8218CF10;
		  /* 8218CF10h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 8218CF10h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8218CF1C;  }
		/* 8218CF10h case    4:*/		return 0x8218CF14;
		  /* 8218CF14h */ case    5:  		/* subf R7, R31, R10 */
		/* 8218CF14h case    5:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R31,regs.R10);
		/* 8218CF14h case    5:*/		return 0x8218CF18;
		  /* 8218CF18h */ case    6:  		/* b 28 */
		/* 8218CF18h case    6:*/		return 0x8218CF34;
		/* 8218CF18h case    6:*/		return 0x8218CF1C;
	}
	return 0x8218CF1C;
} // Block from 8218CF00h-8218CF1Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218CF1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CF1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CF1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CF1C);
		  /* 8218CF1Ch */ case    0:  		/* subf R7, R9, R10 */
		/* 8218CF1Ch case    0:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R9,regs.R10);
		/* 8218CF1Ch case    0:*/		return 0x8218CF20;
		  /* 8218CF20h */ case    1:  		/* cmplw CR6, R31, R11 */
		/* 8218CF20h case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8218CF20h case    1:*/		return 0x8218CF24;
		  /* 8218CF24h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8218CF24h case    2:*/		if ( regs.CR[6].eq ) { return 0x8218CF34;  }
		/* 8218CF24h case    2:*/		return 0x8218CF28;
		  /* 8218CF28h */ case    3:  		/* subf R11, R31, R11 */
		/* 8218CF28h case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 8218CF28h case    3:*/		return 0x8218CF2C;
		  /* 8218CF2Ch */ case    4:  		/* add R11, R11, R7 */
		/* 8218CF2Ch case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 8218CF2Ch case    4:*/		return 0x8218CF30;
	}
	return 0x8218CF30;
} // Block from 8218CF1Ch-8218CF30h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218CF30h
// Function '?Reserve@?$RegisterSet@V?$FixedSizeBitSet@I$00@D3DXShader@@$1?PrintSamplerRegister@2@YAXPAVCompiler@2@I@Z$0CA@$00$1?ReportOutOfSamplerRegistersError@2@YAX0@Z@D3DXShader@@QAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CF30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CF30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CF30);
		  /* 8218CF30h */ case    0:  		/* addi R7, R11, 4 */
		/* 8218CF30h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x4);
		/* 8218CF30h case    0:*/		return 0x8218CF34;
	}
	return 0x8218CF34;
} // Block from 8218CF30h-8218CF34h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218CF34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CF34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CF34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CF34);
		  /* 8218CF34h */ case    0:  		/* addi R11, R31, 3 */
		/* 8218CF34h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x3);
		/* 8218CF34h case    0:*/		return 0x8218CF38;
		  /* 8218CF38h */ case    1:  		/* rlwinm R9, R31, 0, 0, 29 */
		/* 8218CF38h case    1:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R9,regs.R31);
		/* 8218CF38h case    1:*/		return 0x8218CF3C;
		  /* 8218CF3Ch */ case    2:  		/* rlwinm R11, R11, 0, 0, 29 */
		/* 8218CF3Ch case    2:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R11);
		/* 8218CF3Ch case    2:*/		return 0x8218CF40;
		  /* 8218CF40h */ case    3:  		/* li R10, 0 */
		/* 8218CF40h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8218CF40h case    3:*/		return 0x8218CF44;
		  /* 8218CF44h */ case    4:  		/* add R11, R11, R27 */
		/* 8218CF44h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 8218CF44h case    4:*/		return 0x8218CF48;
		  /* 8218CF48h */ case    5:  		/* cmplw CR6, R31, R9 */
		/* 8218CF48h case    5:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R9);
		/* 8218CF48h case    5:*/		return 0x8218CF4C;
		  /* 8218CF4Ch */ case    6:  		/* rlwinm R8, R11, 0, 0, 29 */
		/* 8218CF4Ch case    6:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R8,regs.R11);
		/* 8218CF4Ch case    6:*/		return 0x8218CF50;
		  /* 8218CF50h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 8218CF50h case    7:*/		if ( regs.CR[6].eq ) { return 0x8218CF5C;  }
		/* 8218CF50h case    7:*/		return 0x8218CF54;
		  /* 8218CF54h */ case    8:  		/* subf R10, R31, R9 */
		/* 8218CF54h case    8:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R31,regs.R9);
		/* 8218CF54h case    8:*/		return 0x8218CF58;
		  /* 8218CF58h */ case    9:  		/* addi R10, R10, 4 */
		/* 8218CF58h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8218CF58h case    9:*/		return 0x8218CF5C;
	}
	return 0x8218CF5C;
} // Block from 8218CF34h-8218CF5Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8218CF5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CF5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CF5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CF5C);
		  /* 8218CF5Ch */ case    0:  		/* cmplw CR6, R8, R26 */
		/* 8218CF5Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R26);
		/* 8218CF5Ch case    0:*/		return 0x8218CF60;
		  /* 8218CF60h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8218CF60h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8218CF70;  }
		/* 8218CF60h case    1:*/		return 0x8218CF64;
		  /* 8218CF64h */ case    2:  		/* subf R11, R11, R10 */
		/* 8218CF64h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8218CF64h case    2:*/		return 0x8218CF68;
		  /* 8218CF68h */ case    3:  		/* add R10, R11, R28 */
		/* 8218CF68h case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R28);
		/* 8218CF68h case    3:*/		return 0x8218CF6C;
		  /* 8218CF6Ch */ case    4:  		/* b 32 */
		/* 8218CF6Ch case    4:*/		return 0x8218CF8C;
		/* 8218CF6Ch case    4:*/		return 0x8218CF70;
	}
	return 0x8218CF70;
} // Block from 8218CF5Ch-8218CF70h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218CF70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CF70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CF70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CF70);
		  /* 8218CF70h */ case    0:  		/* subf R10, R26, R10 */
		/* 8218CF70h case    0:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R26,regs.R10);
		/* 8218CF70h case    0:*/		return 0x8218CF74;
		  /* 8218CF74h */ case    1:  		/* cmplw CR6, R11, R8 */
		/* 8218CF74h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8218CF74h case    1:*/		return 0x8218CF78;
		  /* 8218CF78h */ case    2:  		/* add R10, R10, R28 */
		/* 8218CF78h case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R28);
		/* 8218CF78h case    2:*/		return 0x8218CF7C;
		  /* 8218CF7Ch */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 8218CF7Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8218CF8C;  }
		/* 8218CF7Ch case    3:*/		return 0x8218CF80;
		  /* 8218CF80h */ case    4:  		/* subf R11, R11, R10 */
		/* 8218CF80h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8218CF80h case    4:*/		return 0x8218CF84;
		  /* 8218CF84h */ case    5:  		/* add R11, R11, R8 */
		/* 8218CF84h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8218CF84h case    5:*/		return 0x8218CF88;
		  /* 8218CF88h */ case    6:  		/* addi R10, R11, 4 */
		/* 8218CF88h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8218CF88h case    6:*/		return 0x8218CF8C;
	}
	return 0x8218CF8C;
} // Block from 8218CF70h-8218CF8Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218CF8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CF8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CF8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CF8C);
		  /* 8218CF8Ch */ case    0:  		/* cmplw CR6, R7, R29 */
		/* 8218CF8Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R29);
		/* 8218CF8Ch case    0:*/		return 0x8218CF90;
		  /* 8218CF90h */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 8218CF90h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8218CF9C;  }
		/* 8218CF90h case    1:*/		return 0x8218CF94;
		  /* 8218CF94h */ case    2:  		/* mr R29, R7 */
		/* 8218CF94h case    2:*/		regs.R29 = regs.R7;
		/* 8218CF94h case    2:*/		return 0x8218CF98;
	}
	return 0x8218CF98;
} // Block from 8218CF8Ch-8218CF98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218CF98h
// Function '?AllocTopDown@?$RegisterSet@V?$FixedSizeBitSet@I$00@D3DXShader@@$1?PrintIntegerRegister@2@YAXPAVCompiler@2@I@Z$0CA@$00$1?ReportOutOfIntegerRegistersError@2@YAX0@Z@D3DXShader@@QAAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CF98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CF98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CF98);
		  /* 8218CF98h */ case    0:  		/* subf R31, R27, R28 */
		/* 8218CF98h case    0:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R27,regs.R28);
		/* 8218CF98h case    0:*/		return 0x8218CF9C;
	}
	return 0x8218CF9C;
} // Block from 8218CF98h-8218CF9Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218CF9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CF9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CF9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CF9C);
		  /* 8218CF9Ch */ case    0:  		/* cmplw CR6, R10, R29 */
		/* 8218CF9Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 8218CF9Ch case    0:*/		return 0x8218CFA0;
		  /* 8218CFA0h */ case    1:  		/* bc 4, CR6_LT, 16 */
		/* 8218CFA0h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8218CFB0;  }
		/* 8218CFA0h case    1:*/		return 0x8218CFA4;
		  /* 8218CFA4h */ case    2:  		/* addi R11, R31, 3 */
		/* 8218CFA4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x3);
		/* 8218CFA4h case    2:*/		return 0x8218CFA8;
		  /* 8218CFA8h */ case    3:  		/* mr R29, R10 */
		/* 8218CFA8h case    3:*/		regs.R29 = regs.R10;
		/* 8218CFA8h case    3:*/		return 0x8218CFAC;
		  /* 8218CFACh */ case    4:  		/* rlwinm R31, R11, 0, 0, 29 */
		/* 8218CFACh case    4:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R31,regs.R11);
		/* 8218CFACh case    4:*/		return 0x8218CFB0;
	}
	return 0x8218CFB0;
} // Block from 8218CF9Ch-8218CFB0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218CFB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CFB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CFB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CFB0);
		  /* 8218CFB0h */ case    0:  		/* li R30, 0 */
		/* 8218CFB0h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8218CFB0h case    0:*/		return 0x8218CFB4;
		  /* 8218CFB4h */ case    1:  		/* cmplw CR6, R28, R24 */
		/* 8218CFB4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R24);
		/* 8218CFB4h case    1:*/		return 0x8218CFB8;
		  /* 8218CFB8h */ case    2:  		/* bc 4, CR6_LT, 48 */
		/* 8218CFB8h case    2:*/		if ( !regs.CR[6].lt ) { return 0x8218CFE8;  }
		/* 8218CFB8h case    2:*/		return 0x8218CFBC;
		  /* 8218CFBCh */ case    3:  		/* li R6, 4 */
		/* 8218CFBCh case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 8218CFBCh case    3:*/		return 0x8218CFC0;
		  /* 8218CFC0h */ case    4:  		/* li R5, 1 */
		/* 8218CFC0h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8218CFC0h case    4:*/		return 0x8218CFC4;
		  /* 8218CFC4h */ case    5:  		/* mr R4, R28 */
		/* 8218CFC4h case    5:*/		regs.R4 = regs.R28;
		/* 8218CFC4h case    5:*/		return 0x8218CFC8;
		  /* 8218CFC8h */ case    6:  		/* mr R3, R22 */
		/* 8218CFC8h case    6:*/		regs.R3 = regs.R22;
		/* 8218CFC8h case    6:*/		return 0x8218CFCC;
		  /* 8218CFCCh */ case    7:  		/* bl -5380 */
		/* 8218CFCCh case    7:*/		regs.LR = 0x8218CFD0; return 0x8218BAC8;
		/* 8218CFCCh case    7:*/		return 0x8218CFD0;
		  /* 8218CFD0h */ case    8:  		/* cmpwi CR6, R3, -1 */
		/* 8218CFD0h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218CFD0h case    8:*/		return 0x8218CFD4;
		  /* 8218CFD4h */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 8218CFD4h case    9:*/		if ( regs.CR[6].eq ) { return 0x8218CFE8;  }
		/* 8218CFD4h case    9:*/		return 0x8218CFD8;
		  /* 8218CFD8h */ case   10:  		/* rlwinm R11, R3, 28, 4, 31 */
		/* 8218CFD8h case   10:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R11,regs.R3);
		/* 8218CFD8h case   10:*/		return 0x8218CFDC;
		  /* 8218CFDCh */ case   11:  		/* addi R10, R11, 3 */
		/* 8218CFDCh case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x3);
		/* 8218CFDCh case   11:*/		return 0x8218CFE0;
		  /* 8218CFE0h */ case   12:  		/* rlwinm R10, R10, 0, 0, 29 */
		/* 8218CFE0h case   12:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R10,regs.R10);
		/* 8218CFE0h case   12:*/		return 0x8218CFE4;
		  /* 8218CFE4h */ case   13:  		/* subf R30, R11, R10 */
		/* 8218CFE4h case   13:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R11,regs.R10);
		/* 8218CFE4h case   13:*/		return 0x8218CFE8;
	}
	return 0x8218CFE8;
} // Block from 8218CFB0h-8218CFE8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8218CFE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218CFE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218CFE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218CFE8);
		  /* 8218CFE8h */ case    0:  		/* add R11, R30, R29 */
		/* 8218CFE8h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R29);
		/* 8218CFE8h case    0:*/		return 0x8218CFEC;
		  /* 8218CFECh */ case    1:  		/* cmpwi CR6, R23, -1 */
		/* 8218CFECh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R23,0xFFFFFFFF);
		/* 8218CFECh case    1:*/		return 0x8218CFF0;
		  /* 8218CFF0h */ case    2:  		/* add R11, R11, R25 */
		/* 8218CFF0h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R25);
		/* 8218CFF0h case    2:*/		return 0x8218CFF4;
		  /* 8218CFF4h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 8218CFF4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8218D000;  }
		/* 8218CFF4h case    3:*/		return 0x8218CFF8;
		  /* 8218CFF8h */ case    4:  		/* cmplw CR6, R11, R20 */
		/* 8218CFF8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R20);
		/* 8218CFF8h case    4:*/		return 0x8218CFFC;
		  /* 8218CFFCh */ case    5:  		/* bc 4, CR6_LT, 12 */
		/* 8218CFFCh case    5:*/		if ( !regs.CR[6].lt ) { return 0x8218D008;  }
		/* 8218CFFCh case    5:*/		return 0x8218D000;
	}
	return 0x8218D000;
} // Block from 8218CFE8h-8218D000h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218D000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D000);
		  /* 8218D000h */ case    0:  		/* mr R23, R31 */
		/* 8218D000h case    0:*/		regs.R23 = regs.R31;
		/* 8218D000h case    0:*/		return 0x8218D004;
		  /* 8218D004h */ case    1:  		/* mr R20, R11 */
		/* 8218D004h case    1:*/		regs.R20 = regs.R11;
		/* 8218D004h case    1:*/		return 0x8218D008;
	}
	return 0x8218D008;
} // Block from 8218D000h-8218D008h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218D008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D008);
		  /* 8218D008h */ case    0:  		/* mr R4, R28 */
		/* 8218D008h case    0:*/		regs.R4 = regs.R28;
		/* 8218D008h case    0:*/		return 0x8218D00C;
		  /* 8218D00Ch */ case    1:  		/* subf R25, R26, R28 */
		/* 8218D00Ch case    1:*/		cpu::op::subf<0>(regs,&regs.R25,regs.R26,regs.R28);
		/* 8218D00Ch case    1:*/		return 0x8218D010;
	}
	return 0x8218D010;
} // Block from 8218D008h-8218D010h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218D010h
// Function '?FindContiguousRegisters@?$RegisterSet@V?$FixedSizeBitSet@I$00@D3DXShader@@$1?PrintSamplerRegister@2@YAXPAVCompiler@2@I@Z$0CA@$00$1?ReportOutOfSamplerRegistersError@2@YAX0@Z@D3DXShader@@QAAIII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D010);
		  /* 8218D010h */ case    0:  		/* cmplw CR6, R28, R24 */
		/* 8218D010h case    0:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R24);
		/* 8218D010h case    0:*/		return 0x8218D014;
		  /* 8218D014h */ case    1:  		/* bc 4, CR6_GT, -404 */
		/* 8218D014h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8218CE80;  }
		/* 8218D014h case    1:*/		return 0x8218D018;
	}
	return 0x8218D018;
} // Block from 8218D010h-8218D018h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218D018h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D018);
		  /* 8218D018h */ case    0:  		/* cmpwi CR6, R23, -1 */
		/* 8218D018h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R23,0xFFFFFFFF);
		/* 8218D018h case    0:*/		return 0x8218D01C;
		  /* 8218D01Ch */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8218D01Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8218D02C;  }
		/* 8218D01Ch case    1:*/		return 0x8218D020;
		  /* 8218D020h */ case    2:  		/* li R4, 3566 */
		/* 8218D020h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0xDEE);
		/* 8218D020h case    2:*/		return 0x8218D024;
		  /* 8218D024h */ case    3:  		/* mr R3, R19 */
		/* 8218D024h case    3:*/		regs.R3 = regs.R19;
		/* 8218D024h case    3:*/		return 0x8218D028;
		  /* 8218D028h */ case    4:  		/* bl -242112 */
		/* 8218D028h case    4:*/		regs.LR = 0x8218D02C; return 0x82151E68;
		/* 8218D028h case    4:*/		return 0x8218D02C;
	}
	return 0x8218D02C;
} // Block from 8218D018h-8218D02Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218D02Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D02C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D02C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D02C);
		  /* 8218D02Ch */ case    0:  		/* mr R5, R27 */
		/* 8218D02Ch case    0:*/		regs.R5 = regs.R27;
		/* 8218D02Ch case    0:*/		return 0x8218D030;
		  /* 8218D030h */ case    1:  		/* mr R4, R23 */
		/* 8218D030h case    1:*/		regs.R4 = regs.R23;
		/* 8218D030h case    1:*/		return 0x8218D034;
		  /* 8218D034h */ case    2:  		/* mr R3, R22 */
		/* 8218D034h case    2:*/		regs.R3 = regs.R22;
		/* 8218D034h case    2:*/		return 0x8218D038;
		  /* 8218D038h */ case    3:  		/* bl -121696 */
		/* 8218D038h case    3:*/		regs.LR = 0x8218D03C; return 0x8216F4D8;
		/* 8218D038h case    3:*/		return 0x8218D03C;
		  /* 8218D03Ch */ case    4:  		/* mr R3, R23 */
		/* 8218D03Ch case    4:*/		regs.R3 = regs.R23;
		/* 8218D03Ch case    4:*/		return 0x8218D040;
		  /* 8218D040h */ case    5:  		/* addi R1, R1, 192 */
		/* 8218D040h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 8218D040h case    5:*/		return 0x8218D044;
		  /* 8218D044h */ case    6:  		/* b -1031616 */
		/* 8218D044h case    6:*/		return 0x82091284;
		/* 8218D044h case    6:*/		return 0x8218D048;
		  /* 8218D048h */ case    7:  		/* lwz R11, <#[R3 + 4]> */
		/* 8218D048h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8218D048h case    7:*/		return 0x8218D04C;
		  /* 8218D04Ch */ case    8:  		/* li R7, 0 */
		/* 8218D04Ch case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8218D04Ch case    8:*/		return 0x8218D050;
		  /* 8218D050h */ case    9:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8218D050h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8218D050h case    9:*/		return 0x8218D054;
		  /* 8218D054h */ case   10:  		/* bc 4, CR0_EQ, 96 */
		/* 8218D054h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8218D0B4;  }
		/* 8218D054h case   10:*/		return 0x8218D058;
		  /* 8218D058h */ case   11:  		/* mr R8, R11 */
		/* 8218D058h case   11:*/		regs.R8 = regs.R11;
		/* 8218D058h case   11:*/		return 0x8218D05C;
		  /* 8218D05Ch */ case   12:  		/* cmplwi CR0, R11, 0 */
		/* 8218D05Ch case   12:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8218D05Ch case   12:*/		return 0x8218D060;
		  /* 8218D060h */ case   13:  		/* bc 12, CR0_EQ, 84 */
		/* 8218D060h case   13:*/		if ( regs.CR[0].eq ) { return 0x8218D0B4;  }
		/* 8218D060h case   13:*/		return 0x8218D064;
		  /* 8218D064h */ case   14:  		/* lwz R10, <#[R8 + 8]> */
		/* 8218D064h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000008) );
		/* 8218D064h case   14:*/		return 0x8218D068;
		  /* 8218D068h */ case   15:  		/* li R11, 0 */
		/* 8218D068h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218D068h case   15:*/		return 0x8218D06C;
		  /* 8218D06Ch */ case   16:  		/* cmplwi CR6, R10, 0 */
		/* 8218D06Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8218D06Ch case   16:*/		return 0x8218D070;
		  /* 8218D070h */ case   17:  		/* bc 12, CR6_EQ, 36 */
		/* 8218D070h case   17:*/		if ( regs.CR[6].eq ) { return 0x8218D094;  }
		/* 8218D070h case   17:*/		return 0x8218D074;
		  /* 8218D074h */ case   18:  		/* addi R9, R8, 16 */
		/* 8218D074h case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R8,0x10);
		/* 8218D074h case   18:*/		return 0x8218D078;
	}
	return 0x8218D078;
} // Block from 8218D02Ch-8218D078h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8218D078h
// Function '?FindContiguousRegisters@?$RegisterSet@V?$FixedSizeBitSet@_K$03@D3DXShader@@$1?PrintConditionRegister@2@YAXPAVCompiler@2@I@Z$0BAA@$00$1?ReportOutOfBooleanRegistersError@2@YAX0@Z@D3DXShader@@QAAIII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D078);
		  /* 8218D078h */ case    0:  		/* lwz R6, <#[R9]> */
		/* 8218D078h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + 0x00000000) );
		/* 8218D078h case    0:*/		return 0x8218D07C;
		  /* 8218D07Ch */ case    1:  		/* cmplw CR6, R6, R4 */
		/* 8218D07Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R4);
		/* 8218D07Ch case    1:*/		return 0x8218D080;
		  /* 8218D080h */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 8218D080h case    2:*/		if ( regs.CR[6].eq ) { return 0x8218D0BC;  }
		/* 8218D080h case    2:*/		return 0x8218D084;
		  /* 8218D084h */ case    3:  		/* addi R11, R11, 1 */
		/* 8218D084h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218D084h case    3:*/		return 0x8218D088;
		  /* 8218D088h */ case    4:  		/* addi R9, R9, 4 */
		/* 8218D088h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8218D088h case    4:*/		return 0x8218D08C;
		  /* 8218D08Ch */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 8218D08Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8218D08Ch case    5:*/		return 0x8218D090;
		  /* 8218D090h */ case    6:  		/* bc 12, CR6_LT, -24 */
		/* 8218D090h case    6:*/		if ( regs.CR[6].lt ) { return 0x8218D078;  }
		/* 8218D090h case    6:*/		return 0x8218D094;
	}
	return 0x8218D094;
} // Block from 8218D078h-8218D094h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218D094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D094);
		  /* 8218D094h */ case    0:  		/* rlwinm R11, R8, 0, 0, 30 */
		/* 8218D094h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R8);
		/* 8218D094h case    0:*/		return 0x8218D098;
		  /* 8218D098h */ case    1:  		/* add R7, R10, R7 */
		/* 8218D098h case    1:*/		cpu::op::add<0>(regs,&regs.R7,regs.R10,regs.R7);
		/* 8218D098h case    1:*/		return 0x8218D09C;
		  /* 8218D09Ch */ case    2:  		/* lwz R11, <#[R11 + 4]> */
		/* 8218D09Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8218D09Ch case    2:*/		return 0x8218D0A0;
		  /* 8218D0A0h */ case    3:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8218D0A0h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8218D0A0h case    3:*/		return 0x8218D0A4;
		  /* 8218D0A4h */ case    4:  		/* bc 4, CR0_EQ, 16 */
		/* 8218D0A4h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8218D0B4;  }
		/* 8218D0A4h case    4:*/		return 0x8218D0A8;
		  /* 8218D0A8h */ case    5:  		/* mr R8, R11 */
		/* 8218D0A8h case    5:*/		regs.R8 = regs.R11;
		/* 8218D0A8h case    5:*/		return 0x8218D0AC;
		  /* 8218D0ACh */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 8218D0ACh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218D0ACh case    6:*/		return 0x8218D0B0;
		  /* 8218D0B0h */ case    7:  		/* bc 4, CR6_EQ, -76 */
		/* 8218D0B0h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8218D064;  }
		/* 8218D0B0h case    7:*/		return 0x8218D0B4;
	}
	return 0x8218D0B4;
} // Block from 8218D094h-8218D0B4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218D0B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D0B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D0B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D0B4);
		  /* 8218D0B4h */ case    0:  		/* li R3, -1 */
		/* 8218D0B4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8218D0B4h case    0:*/		return 0x8218D0B8;
		  /* 8218D0B8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8218D0B8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218D0B8h case    1:*/		return 0x8218D0BC;
	}
	return 0x8218D0BC;
} // Block from 8218D0B4h-8218D0BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218D0BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D0BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D0BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D0BC);
		  /* 8218D0BCh */ case    0:  		/* add R3, R11, R7 */
		/* 8218D0BCh case    0:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R7);
		/* 8218D0BCh case    0:*/		return 0x8218D0C0;
		  /* 8218D0C0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8218D0C0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218D0C0h case    1:*/		return 0x8218D0C4;
	}
	return 0x8218D0C4;
} // Block from 8218D0BCh-8218D0C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218D0C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D0C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D0C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D0C4);
		  /* 8218D0C4h */ case    0:  		/* nop */
		/* 8218D0C4h case    0:*/		cpu::op::nop();
		/* 8218D0C4h case    0:*/		return 0x8218D0C8;
	}
	return 0x8218D0C8;
} // Block from 8218D0C4h-8218D0C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218D0C8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D0C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D0C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D0C8);
		  /* 8218D0C8h */ case    0:  		/* mfspr R12, LR */
		/* 8218D0C8h case    0:*/		regs.R12 = regs.LR;
		/* 8218D0C8h case    0:*/		return 0x8218D0CC;
		  /* 8218D0CCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8218D0CCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8218D0CCh case    1:*/		return 0x8218D0D0;
		  /* 8218D0D0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8218D0D0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8218D0D0h case    2:*/		return 0x8218D0D4;
		  /* 8218D0D4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8218D0D4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8218D0D4h case    3:*/		return 0x8218D0D8;
		  /* 8218D0D8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8218D0D8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8218D0D8h case    4:*/		return 0x8218D0DC;
		  /* 8218D0DCh */ case    5:  		/* mr R31, R3 */
		/* 8218D0DCh case    5:*/		regs.R31 = regs.R3;
		/* 8218D0DCh case    5:*/		return 0x8218D0E0;
	}
	return 0x8218D0E0;
} // Block from 8218D0C8h-8218D0E0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218D0E0h
// Function '?AllocFunctionMem@Compiler@D3DXShader@@QAAPAXKW4CompilerHeapStructTypes@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D0E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D0E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D0E0);
		  /* 8218D0E0h */ case    0:  		/* cmplwi CR6, R4, 10 */
		/* 8218D0E0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000000A);
		/* 8218D0E0h case    0:*/		return 0x8218D0E4;
		  /* 8218D0E4h */ case    1:  		/* mr R30, R4 */
		/* 8218D0E4h case    1:*/		regs.R30 = regs.R4;
		/* 8218D0E4h case    1:*/		return 0x8218D0E8;
		  /* 8218D0E8h */ case    2:  		/* bc 12, CR6_GT, 8 */
		/* 8218D0E8h case    2:*/		if ( regs.CR[6].gt ) { return 0x8218D0F0;  }
		/* 8218D0E8h case    2:*/		return 0x8218D0EC;
		  /* 8218D0ECh */ case    3:  		/* li R30, 10 */
		/* 8218D0ECh case    3:*/		cpu::op::li<0>(regs,&regs.R30,0xA);
		/* 8218D0ECh case    3:*/		return 0x8218D0F0;
	}
	return 0x8218D0F0;
} // Block from 8218D0E0h-8218D0F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218D0F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D0F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D0F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D0F0);
		  /* 8218D0F0h */ case    0:  		/* addi R11, R30, 4 */
		/* 8218D0F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x4);
		/* 8218D0F0h case    0:*/		return 0x8218D0F4;
		  /* 8218D0F4h */ case    1:  		/* mr R3, R31 */
		/* 8218D0F4h case    1:*/		regs.R3 = regs.R31;
		/* 8218D0F4h case    1:*/		return 0x8218D0F8;
		  /* 8218D0F8h */ case    2:  		/* rlwinm R4, R11, 2, 0, 29 */
		/* 8218D0F8h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R11);
		/* 8218D0F8h case    2:*/		return 0x8218D0FC;
		  /* 8218D0FCh */ case    3:  		/* bl -164212 */
		/* 8218D0FCh case    3:*/		regs.LR = 0x8218D100; return 0x82164F88;
		/* 8218D0FCh case    3:*/		return 0x8218D100;
		  /* 8218D100h */ case    4:  		/* li R9, 0 */
		/* 8218D100h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8218D100h case    4:*/		return 0x8218D104;
		  /* 8218D104h */ case    5:  		/* stw R30, <#[R3 + 12]> */
		/* 8218D104h case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 8218D104h case    5:*/		return 0x8218D108;
		  /* 8218D108h */ case    6:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 8218D108h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 8218D108h case    6:*/		return 0x8218D10C;
		  /* 8218D10Ch */ case    7:  		/* stw R9, <#[R3 + 8]> */
		/* 8218D10Ch case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 8218D10Ch case    7:*/		return 0x8218D110;
		  /* 8218D110h */ case    8:  		/* ori R8, R31, 1 */
		/* 8218D110h case    8:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R31,0x1);
		/* 8218D110h case    8:*/		return 0x8218D114;
		  /* 8218D114h */ case    9:  		/* lwz R9, <#[R31]> */
		/* 8218D114h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8218D114h case    9:*/		return 0x8218D118;
		  /* 8218D118h */ case   10:  		/* addi R10, R11, 4 */
		/* 8218D118h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8218D118h case   10:*/		return 0x8218D11C;
		  /* 8218D11Ch */ case   11:  		/* stw R9, <#[R11]> */
		/* 8218D11Ch case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8218D11Ch case   11:*/		return 0x8218D120;
		  /* 8218D120h */ case   12:  		/* lwz R9, <#[R31]> */
		/* 8218D120h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8218D120h case   12:*/		return 0x8218D124;
		  /* 8218D124h */ case   13:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 8218D124h case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 8218D124h case   13:*/		return 0x8218D128;
		  /* 8218D128h */ case   14:  		/* stw R11, <#[R9]> */
		/* 8218D128h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8218D128h case   14:*/		return 0x8218D12C;
		  /* 8218D12Ch */ case   15:  		/* stw R8, <#[R11 + 4]> */
		/* 8218D12Ch case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8218D12Ch case   15:*/		return 0x8218D130;
		  /* 8218D130h */ case   16:  		/* stw R10, <#[R31]> */
		/* 8218D130h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8218D130h case   16:*/		return 0x8218D134;
		  /* 8218D134h */ case   17:  		/* addi R1, R1, 112 */
		/* 8218D134h case   17:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8218D134h case   17:*/		return 0x8218D138;
		  /* 8218D138h */ case   18:  		/* lwz R12, <#[R1 - 8]> */
		/* 8218D138h case   18:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8218D138h case   18:*/		return 0x8218D13C;
		  /* 8218D13Ch */ case   19:  		/* mtspr LR, R12 */
		/* 8218D13Ch case   19:*/		regs.LR = regs.R12;
		/* 8218D13Ch case   19:*/		return 0x8218D140;
		  /* 8218D140h */ case   20:  		/* ld R30, <#[R1 - 24]> */
		/* 8218D140h case   20:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8218D140h case   20:*/		return 0x8218D144;
		  /* 8218D144h */ case   21:  		/* ld R31, <#[R1 - 16]> */
		/* 8218D144h case   21:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8218D144h case   21:*/		return 0x8218D148;
		  /* 8218D148h */ case   22:  		/* bclr 20, CR0_LT */
		/* 8218D148h case   22:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218D148h case   22:*/		return 0x8218D14C;
	}
	return 0x8218D14C;
} // Block from 8218D0F0h-8218D14Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 8218D14Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D14C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D14C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D14C);
		  /* 8218D14Ch */ case    0:  		/* nop */
		/* 8218D14Ch case    0:*/		cpu::op::nop();
		/* 8218D14Ch case    0:*/		return 0x8218D150;
	}
	return 0x8218D150;
} // Block from 8218D14Ch-8218D150h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218D150h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D150);
		  /* 8218D150h */ case    0:  		/* mfspr R12, LR */
		/* 8218D150h case    0:*/		regs.R12 = regs.LR;
		/* 8218D150h case    0:*/		return 0x8218D154;
		  /* 8218D154h */ case    1:  		/* bl -1031928 */
		/* 8218D154h case    1:*/		regs.LR = 0x8218D158; return 0x8209125C;
		/* 8218D154h case    1:*/		return 0x8218D158;
		  /* 8218D158h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8218D158h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8218D158h case    2:*/		return 0x8218D15C;
		  /* 8218D15Ch */ case    3:  		/* mr R29, R4 */
		/* 8218D15Ch case    3:*/		regs.R29 = regs.R4;
		/* 8218D15Ch case    3:*/		return 0x8218D160;
		  /* 8218D160h */ case    4:  		/* mr R5, R4 */
		/* 8218D160h case    4:*/		regs.R5 = regs.R4;
		/* 8218D160h case    4:*/		return 0x8218D164;
		  /* 8218D164h */ case    5:  		/* li R4, 0 */
		/* 8218D164h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8218D164h case    5:*/		return 0x8218D168;
		  /* 8218D168h */ case    6:  		/* mr R30, R3 */
		/* 8218D168h case    6:*/		regs.R30 = regs.R3;
		/* 8218D168h case    6:*/		return 0x8218D16C;
		  /* 8218D16Ch */ case    7:  		/* bl -2988 */
		/* 8218D16Ch case    7:*/		regs.LR = 0x8218D170; return 0x8218C5C0;
		/* 8218D16Ch case    7:*/		return 0x8218D170;
		  /* 8218D170h */ case    8:  		/* mr R31, R3 */
		/* 8218D170h case    8:*/		regs.R31 = regs.R3;
		/* 8218D170h case    8:*/		return 0x8218D174;
		  /* 8218D174h */ case    9:  		/* cmpwi CR6, R3, -1 */
		/* 8218D174h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218D174h case    9:*/		return 0x8218D178;
		  /* 8218D178h */ case   10:  		/* bc 4, CR6_EQ, 64 */
		/* 8218D178h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8218D1B8;  }
		/* 8218D178h case   10:*/		return 0x8218D17C;
		  /* 8218D17Ch */ case   11:  		/* lwz R31, <#[R30]> */
		/* 8218D17Ch case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 8218D17Ch case   11:*/		return 0x8218D180;
		  /* 8218D180h */ case   12:  		/* mr R3, R31 */
		/* 8218D180h case   12:*/		regs.R3 = regs.R31;
		/* 8218D180h case   12:*/		return 0x8218D184;
		  /* 8218D184h */ case   13:  		/* lwz R11, <#[R31 + 804]> */
		/* 8218D184h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000324) );
		/* 8218D184h case   13:*/		return 0x8218D188;
	}
	return 0x8218D188;
} // Block from 8218D150h-8218D188h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8218D188h
// Function '?PackConstants@Compiler@D3DXShader@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D188);
		  /* 8218D188h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8218D188h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218D188h case    0:*/		return 0x8218D18C;
		  /* 8218D18Ch */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 8218D18Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8218D1A4;  }
		/* 8218D18Ch case    1:*/		return 0x8218D190;
		  /* 8218D190h */ case    2:  		/* bl -7472 */
		/* 8218D190h case    2:*/		regs.LR = 0x8218D194; return 0x8218B460;
		/* 8218D190h case    2:*/		return 0x8218D194;
		  /* 8218D194h */ case    3:  		/* mr R5, R3 */
		/* 8218D194h case    3:*/		regs.R5 = regs.R3;
		/* 8218D194h case    3:*/		return 0x8218D198;
		  /* 8218D198h */ case    4:  		/* li R4, 3567 */
		/* 8218D198h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0xDEF);
		/* 8218D198h case    4:*/		return 0x8218D19C;
		  /* 8218D19Ch */ case    5:  		/* mr R3, R31 */
		/* 8218D19Ch case    5:*/		regs.R3 = regs.R31;
		/* 8218D19Ch case    5:*/		return 0x8218D1A0;
		  /* 8218D1A0h */ case    6:  		/* bl -242488 */
		/* 8218D1A0h case    6:*/		regs.LR = 0x8218D1A4; return 0x82151E68;
		/* 8218D1A0h case    6:*/		return 0x8218D1A4;
	}
	return 0x8218D1A4;
} // Block from 8218D188h-8218D1A4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218D1A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D1A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D1A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D1A4);
		  /* 8218D1A4h */ case    0:  		/* bl -7492 */
		/* 8218D1A4h case    0:*/		regs.LR = 0x8218D1A8; return 0x8218B460;
		/* 8218D1A4h case    0:*/		return 0x8218D1A8;
		  /* 8218D1A8h */ case    1:  		/* mr R5, R3 */
		/* 8218D1A8h case    1:*/		regs.R5 = regs.R3;
		/* 8218D1A8h case    1:*/		return 0x8218D1AC;
		  /* 8218D1ACh */ case    2:  		/* li R4, 3568 */
		/* 8218D1ACh case    2:*/		cpu::op::li<0>(regs,&regs.R4,0xDF0);
		/* 8218D1ACh case    2:*/		return 0x8218D1B0;
		  /* 8218D1B0h */ case    3:  		/* mr R3, R31 */
		/* 8218D1B0h case    3:*/		regs.R3 = regs.R31;
		/* 8218D1B0h case    3:*/		return 0x8218D1B4;
		  /* 8218D1B4h */ case    4:  		/* bl -242508 */
		/* 8218D1B4h case    4:*/		regs.LR = 0x8218D1B8; return 0x82151E68;
		/* 8218D1B4h case    4:*/		return 0x8218D1B8;
	}
	return 0x8218D1B8;
} // Block from 8218D1A4h-8218D1B8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218D1B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D1B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D1B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D1B8);
		  /* 8218D1B8h */ case    0:  		/* add R11, R31, R29 */
		/* 8218D1B8h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R29);
		/* 8218D1B8h case    0:*/		return 0x8218D1BC;
		  /* 8218D1BCh */ case    1:  		/* mr R4, R31 */
		/* 8218D1BCh case    1:*/		regs.R4 = regs.R31;
		/* 8218D1BCh case    1:*/		return 0x8218D1C0;
		  /* 8218D1C0h */ case    2:  		/* addi R5, R11, -1 */
		/* 8218D1C0h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 8218D1C0h case    2:*/		return 0x8218D1C4;
		  /* 8218D1C4h */ case    3:  		/* addi R3, R30, 4 */
		/* 8218D1C4h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x4);
		/* 8218D1C4h case    3:*/		return 0x8218D1C8;
		  /* 8218D1C8h */ case    4:  		/* bl -5552 */
		/* 8218D1C8h case    4:*/		regs.LR = 0x8218D1CC; return 0x8218BC18;
		/* 8218D1C8h case    4:*/		return 0x8218D1CC;
		  /* 8218D1CCh */ case    5:  		/* mr R3, R31 */
		/* 8218D1CCh case    5:*/		regs.R3 = regs.R31;
		/* 8218D1CCh case    5:*/		return 0x8218D1D0;
		  /* 8218D1D0h */ case    6:  		/* addi R1, R1, 112 */
		/* 8218D1D0h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8218D1D0h case    6:*/		return 0x8218D1D4;
		  /* 8218D1D4h */ case    7:  		/* b -1031976 */
		/* 8218D1D4h case    7:*/		return 0x820912AC;
		/* 8218D1D4h case    7:*/		return 0x8218D1D8;
	}
	return 0x8218D1D8;
} // Block from 8218D1B8h-8218D1D8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218D1D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D1D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D1D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D1D8);
		  /* 8218D1D8h */ case    0:  		/* mfspr R12, LR */
		/* 8218D1D8h case    0:*/		regs.R12 = regs.LR;
		/* 8218D1D8h case    0:*/		return 0x8218D1DC;
		  /* 8218D1DCh */ case    1:  		/* bl -1032064 */
		/* 8218D1DCh case    1:*/		regs.LR = 0x8218D1E0; return 0x8209125C;
		/* 8218D1DCh case    1:*/		return 0x8218D1E0;
		  /* 8218D1E0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8218D1E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8218D1E0h case    2:*/		return 0x8218D1E4;
		  /* 8218D1E4h */ case    3:  		/* mr R29, R4 */
		/* 8218D1E4h case    3:*/		regs.R29 = regs.R4;
		/* 8218D1E4h case    3:*/		return 0x8218D1E8;
		  /* 8218D1E8h */ case    4:  		/* mr R5, R4 */
		/* 8218D1E8h case    4:*/		regs.R5 = regs.R4;
		/* 8218D1E8h case    4:*/		return 0x8218D1EC;
		  /* 8218D1ECh */ case    5:  		/* li R4, 0 */
		/* 8218D1ECh case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8218D1ECh case    5:*/		return 0x8218D1F0;
		  /* 8218D1F0h */ case    6:  		/* mr R30, R3 */
		/* 8218D1F0h case    6:*/		regs.R30 = regs.R3;
		/* 8218D1F0h case    6:*/		return 0x8218D1F4;
		  /* 8218D1F4h */ case    7:  		/* bl -3228 */
		/* 8218D1F4h case    7:*/		regs.LR = 0x8218D1F8; return 0x8218C558;
		/* 8218D1F4h case    7:*/		return 0x8218D1F8;
		  /* 8218D1F8h */ case    8:  		/* mr R31, R3 */
		/* 8218D1F8h case    8:*/		regs.R31 = regs.R3;
		/* 8218D1F8h case    8:*/		return 0x8218D1FC;
		  /* 8218D1FCh */ case    9:  		/* cmpwi CR6, R3, -1 */
		/* 8218D1FCh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218D1FCh case    9:*/		return 0x8218D200;
		  /* 8218D200h */ case   10:  		/* bc 4, CR6_EQ, 16 */
		/* 8218D200h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8218D210;  }
		/* 8218D200h case   10:*/		return 0x8218D204;
		  /* 8218D204h */ case   11:  		/* li R4, 3569 */
		/* 8218D204h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0xDF1);
		/* 8218D204h case   11:*/		return 0x8218D208;
		  /* 8218D208h */ case   12:  		/* lwz R3, <#[R30]> */
		/* 8218D208h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 8218D208h case   12:*/		return 0x8218D20C;
		  /* 8218D20Ch */ case   13:  		/* bl -242596 */
		/* 8218D20Ch case   13:*/		regs.LR = 0x8218D210; return 0x82151E68;
		/* 8218D20Ch case   13:*/		return 0x8218D210;
	}
	return 0x8218D210;
} // Block from 8218D1D8h-8218D210h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8218D210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D210);
		  /* 8218D210h */ case    0:  		/* add R11, R31, R29 */
		/* 8218D210h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R29);
		/* 8218D210h case    0:*/		return 0x8218D214;
		  /* 8218D214h */ case    1:  		/* mr R4, R31 */
		/* 8218D214h case    1:*/		regs.R4 = regs.R31;
		/* 8218D214h case    1:*/		return 0x8218D218;
		  /* 8218D218h */ case    2:  		/* addi R5, R11, -1 */
		/* 8218D218h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 8218D218h case    2:*/		return 0x8218D21C;
		  /* 8218D21Ch */ case    3:  		/* addi R3, R30, 8 */
		/* 8218D21Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x8);
		/* 8218D21Ch case    3:*/		return 0x8218D220;
		  /* 8218D220h */ case    4:  		/* bl -5464 */
		/* 8218D220h case    4:*/		regs.LR = 0x8218D224; return 0x8218BCC8;
		/* 8218D220h case    4:*/		return 0x8218D224;
		  /* 8218D224h */ case    5:  		/* mr R3, R31 */
		/* 8218D224h case    5:*/		regs.R3 = regs.R31;
		/* 8218D224h case    5:*/		return 0x8218D228;
		  /* 8218D228h */ case    6:  		/* addi R1, R1, 112 */
		/* 8218D228h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8218D228h case    6:*/		return 0x8218D22C;
		  /* 8218D22Ch */ case    7:  		/* b -1032064 */
		/* 8218D22Ch case    7:*/		return 0x820912AC;
		/* 8218D22Ch case    7:*/		return 0x8218D230;
	}
	return 0x8218D230;
} // Block from 8218D210h-8218D230h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218D230h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D230);
		  /* 8218D230h */ case    0:  		/* mfspr R12, LR */
		/* 8218D230h case    0:*/		regs.R12 = regs.LR;
		/* 8218D230h case    0:*/		return 0x8218D234;
		  /* 8218D234h */ case    1:  		/* bl -1032152 */
		/* 8218D234h case    1:*/		regs.LR = 0x8218D238; return 0x8209125C;
		/* 8218D234h case    1:*/		return 0x8218D238;
		  /* 8218D238h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8218D238h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8218D238h case    2:*/		return 0x8218D23C;
		  /* 8218D23Ch */ case    3:  		/* mr R29, R4 */
		/* 8218D23Ch case    3:*/		regs.R29 = regs.R4;
		/* 8218D23Ch case    3:*/		return 0x8218D240;
		  /* 8218D240h */ case    4:  		/* mr R5, R4 */
		/* 8218D240h case    4:*/		regs.R5 = regs.R4;
		/* 8218D240h case    4:*/		return 0x8218D244;
		  /* 8218D244h */ case    5:  		/* li R4, 0 */
		/* 8218D244h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8218D244h case    5:*/		return 0x8218D248;
		  /* 8218D248h */ case    6:  		/* mr R30, R3 */
		/* 8218D248h case    6:*/		regs.R30 = regs.R3;
		/* 8218D248h case    6:*/		return 0x8218D24C;
		  /* 8218D24Ch */ case    7:  		/* bl -3212 */
		/* 8218D24Ch case    7:*/		regs.LR = 0x8218D250; return 0x8218C5C0;
		/* 8218D24Ch case    7:*/		return 0x8218D250;
		  /* 8218D250h */ case    8:  		/* mr R31, R3 */
		/* 8218D250h case    8:*/		regs.R31 = regs.R3;
		/* 8218D250h case    8:*/		return 0x8218D254;
		  /* 8218D254h */ case    9:  		/* cmpwi CR6, R3, -1 */
		/* 8218D254h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218D254h case    9:*/		return 0x8218D258;
		  /* 8218D258h */ case   10:  		/* bc 4, CR6_EQ, 16 */
		/* 8218D258h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8218D268;  }
		/* 8218D258h case   10:*/		return 0x8218D25C;
		  /* 8218D25Ch */ case   11:  		/* li R4, 3570 */
		/* 8218D25Ch case   11:*/		cpu::op::li<0>(regs,&regs.R4,0xDF2);
		/* 8218D25Ch case   11:*/		return 0x8218D260;
		  /* 8218D260h */ case   12:  		/* lwz R3, <#[R30]> */
		/* 8218D260h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 8218D260h case   12:*/		return 0x8218D264;
		  /* 8218D264h */ case   13:  		/* bl -242684 */
		/* 8218D264h case   13:*/		regs.LR = 0x8218D268; return 0x82151E68;
		/* 8218D264h case   13:*/		return 0x8218D268;
	}
	return 0x8218D268;
} // Block from 8218D230h-8218D268h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8218D268h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D268);
		  /* 8218D268h */ case    0:  		/* add R11, R31, R29 */
		/* 8218D268h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R29);
		/* 8218D268h case    0:*/		return 0x8218D26C;
		  /* 8218D26Ch */ case    1:  		/* mr R4, R31 */
		/* 8218D26Ch case    1:*/		regs.R4 = regs.R31;
		/* 8218D26Ch case    1:*/		return 0x8218D270;
		  /* 8218D270h */ case    2:  		/* addi R5, R11, -1 */
		/* 8218D270h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 8218D270h case    2:*/		return 0x8218D274;
		  /* 8218D274h */ case    3:  		/* addi R3, R30, 4 */
		/* 8218D274h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x4);
		/* 8218D274h case    3:*/		return 0x8218D278;
		  /* 8218D278h */ case    4:  		/* bl -5728 */
		/* 8218D278h case    4:*/		regs.LR = 0x8218D27C; return 0x8218BC18;
		/* 8218D278h case    4:*/		return 0x8218D27C;
		  /* 8218D27Ch */ case    5:  		/* mr R3, R31 */
		/* 8218D27Ch case    5:*/		regs.R3 = regs.R31;
		/* 8218D27Ch case    5:*/		return 0x8218D280;
		  /* 8218D280h */ case    6:  		/* addi R1, R1, 112 */
		/* 8218D280h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8218D280h case    6:*/		return 0x8218D284;
		  /* 8218D284h */ case    7:  		/* b -1032152 */
		/* 8218D284h case    7:*/		return 0x820912AC;
		/* 8218D284h case    7:*/		return 0x8218D288;
	}
	return 0x8218D288;
} // Block from 8218D268h-8218D288h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218D288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D288);
		  /* 8218D288h */ case    0:  		/* mfspr R12, LR */
		/* 8218D288h case    0:*/		regs.R12 = regs.LR;
		/* 8218D288h case    0:*/		return 0x8218D28C;
		  /* 8218D28Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8218D28Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8218D28Ch case    1:*/		return 0x8218D290;
		  /* 8218D290h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8218D290h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8218D290h case    2:*/		return 0x8218D294;
		  /* 8218D294h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8218D294h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8218D294h case    3:*/		return 0x8218D298;
		  /* 8218D298h */ case    4:  		/* lwz R31, <#[R3 + 2484]> */
		/* 8218D298h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x000009B4) );
		/* 8218D298h case    4:*/		return 0x8218D29C;
		  /* 8218D29Ch */ case    5:  		/* cmplwi CR6, R31, 0 */
		/* 8218D29Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8218D29Ch case    5:*/		return 0x8218D2A0;
		  /* 8218D2A0h */ case    6:  		/* bc 12, CR6_EQ, 96 */
		/* 8218D2A0h case    6:*/		if ( regs.CR[6].eq ) { return 0x8218D300;  }
		/* 8218D2A0h case    6:*/		return 0x8218D2A4;
		  /* 8218D2A4h */ case    7:  		/* mr R3, R31 */
		/* 8218D2A4h case    7:*/		regs.R3 = regs.R31;
		/* 8218D2A4h case    7:*/		return 0x8218D2A8;
		  /* 8218D2A8h */ case    8:  		/* bl -608 */
		/* 8218D2A8h case    8:*/		regs.LR = 0x8218D2AC; return 0x8218D048;
		/* 8218D2A8h case    8:*/		return 0x8218D2AC;
		  /* 8218D2ACh */ case    9:  		/* cmpwi CR6, R3, -1 */
		/* 8218D2ACh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218D2ACh case    9:*/		return 0x8218D2B0;
		  /* 8218D2B0h */ case   10:  		/* bc 12, CR6_EQ, 80 */
		/* 8218D2B0h case   10:*/		if ( regs.CR[6].eq ) { return 0x8218D300;  }
		/* 8218D2B0h case   10:*/		return 0x8218D2B4;
		  /* 8218D2B4h */ case   11:  		/* rlwinm. R11, R3, 0, 31, 31 */
		/* 8218D2B4h case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R3);
		/* 8218D2B4h case   11:*/		return 0x8218D2B8;
		  /* 8218D2B8h */ case   12:  		/* bc 4, CR0_EQ, 72 */
		/* 8218D2B8h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8218D300;  }
		/* 8218D2B8h case   12:*/		return 0x8218D2BC;
		  /* 8218D2BCh */ case   13:  		/* lwz R10, <#[R31 + 4]> */
		/* 8218D2BCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8218D2BCh case   13:*/		return 0x8218D2C0;
		  /* 8218D2C0h */ case   14:  		/* addi R11, R3, 1 */
		/* 8218D2C0h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x1);
		/* 8218D2C0h case   14:*/		return 0x8218D2C4;
		  /* 8218D2C4h */ case   15:  		/* b 16 */
		/* 8218D2C4h case   15:*/		return 0x8218D2D4;
		/* 8218D2C4h case   15:*/		return 0x8218D2C8;
		  /* 8218D2C8h */ case   16:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 8218D2C8h case   16:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 8218D2C8h case   16:*/		return 0x8218D2CC;
		  /* 8218D2CCh */ case   17:  		/* subf R11, R9, R11 */
		/* 8218D2CCh case   17:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8218D2CCh case   17:*/		return 0x8218D2D0;
		  /* 8218D2D0h */ case   18:  		/* lwz R10, <#[R10 + 4]> */
		/* 8218D2D0h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8218D2D0h case   18:*/		return 0x8218D2D4;
	}
	return 0x8218D2D4;
} // Block from 8218D288h-8218D2D4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8218D2D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D2D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D2D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D2D4);
		  /* 8218D2D4h */ case    0:  		/* rlwinm R9, R10, 0, 31, 31 */
		/* 8218D2D4h case    0:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R10);
		/* 8218D2D4h case    0:*/		return 0x8218D2D8;
		  /* 8218D2D8h */ case    1:  		/* addic R9, R9, -1 */
		/* 8218D2D8h case    1:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8218D2D8h case    1:*/		return 0x8218D2DC;
		  /* 8218D2DCh */ case    2:  		/* subfe R9, R9, R9 */
		/* 8218D2DCh case    2:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 8218D2DCh case    2:*/		return 0x8218D2E0;
		  /* 8218D2E0h */ case    3:  		/* and R10, R9, R10 */
		/* 8218D2E0h case    3:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8218D2E0h case    3:*/		return 0x8218D2E4;
		  /* 8218D2E4h */ case    4:  		/* lwz R9, <#[R10 + 8]> */
		/* 8218D2E4h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 8218D2E4h case    4:*/		return 0x8218D2E8;
		  /* 8218D2E8h */ case    5:  		/* cmplw CR6, R11, R9 */
		/* 8218D2E8h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8218D2E8h case    5:*/		return 0x8218D2EC;
		  /* 8218D2ECh */ case    6:  		/* bc 4, CR6_LT, -36 */
		/* 8218D2ECh case    6:*/		if ( !regs.CR[6].lt ) { return 0x8218D2C8;  }
		/* 8218D2ECh case    6:*/		return 0x8218D2F0;
		  /* 8218D2F0h */ case    7:  		/* addi R11, R11, 4 */
		/* 8218D2F0h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8218D2F0h case    7:*/		return 0x8218D2F4;
		  /* 8218D2F4h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8218D2F4h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8218D2F4h case    8:*/		return 0x8218D2F8;
		  /* 8218D2F8h */ case    9:  		/* lwzx R3, <#[R11 + R10]> */
		/* 8218D2F8h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8218D2F8h case    9:*/		return 0x8218D2FC;
		  /* 8218D2FCh */ case   10:  		/* b 8 */
		/* 8218D2FCh case   10:*/		return 0x8218D304;
		/* 8218D2FCh case   10:*/		return 0x8218D300;
	}
	return 0x8218D300;
} // Block from 8218D2D4h-8218D300h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8218D300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D300);
		  /* 8218D300h */ case    0:  		/* li R3, 0 */
		/* 8218D300h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8218D300h case    0:*/		return 0x8218D304;
	}
	return 0x8218D304;
} // Block from 8218D300h-8218D304h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218D304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D304);
		  /* 8218D304h */ case    0:  		/* addi R1, R1, 96 */
		/* 8218D304h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8218D304h case    0:*/		return 0x8218D308;
		  /* 8218D308h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8218D308h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8218D308h case    1:*/		return 0x8218D30C;
		  /* 8218D30Ch */ case    2:  		/* mtspr LR, R12 */
		/* 8218D30Ch case    2:*/		regs.LR = regs.R12;
		/* 8218D30Ch case    2:*/		return 0x8218D310;
		  /* 8218D310h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8218D310h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8218D310h case    3:*/		return 0x8218D314;
		  /* 8218D314h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8218D314h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218D314h case    4:*/		return 0x8218D318;
	}
	return 0x8218D318;
} // Block from 8218D304h-8218D318h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218D318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D318);
		  /* 8218D318h */ case    0:  		/* mfspr R12, LR */
		/* 8218D318h case    0:*/		regs.R12 = regs.LR;
		/* 8218D318h case    0:*/		return 0x8218D31C;
		  /* 8218D31Ch */ case    1:  		/* bl -1032388 */
		/* 8218D31Ch case    1:*/		regs.LR = 0x8218D320; return 0x82091258;
		/* 8218D31Ch case    1:*/		return 0x8218D320;
		  /* 8218D320h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8218D320h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8218D320h case    2:*/		return 0x8218D324;
		  /* 8218D324h */ case    3:  		/* lwz R11, <#[R3 + 12]> */
		/* 8218D324h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8218D324h case    3:*/		return 0x8218D328;
		  /* 8218D328h */ case    4:  		/* mulli R10, R4, 40 */
		/* 8218D328h case    4:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R4,0x28);
		/* 8218D328h case    4:*/		return 0x8218D32C;
		  /* 8218D32Ch */ case    5:  		/* add R10, R10, R11 */
		/* 8218D32Ch case    5:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8218D32Ch case    5:*/		return 0x8218D330;
		  /* 8218D330h */ case    6:  		/* mr R31, R3 */
		/* 8218D330h case    6:*/		regs.R31 = regs.R3;
		/* 8218D330h case    6:*/		return 0x8218D334;
		  /* 8218D334h */ case    7:  		/* mr R30, R5 */
		/* 8218D334h case    7:*/		regs.R30 = regs.R5;
		/* 8218D334h case    7:*/		return 0x8218D338;
		  /* 8218D338h */ case    8:  		/* mr R29, R6 */
		/* 8218D338h case    8:*/		regs.R29 = regs.R6;
		/* 8218D338h case    8:*/		return 0x8218D33C;
		  /* 8218D33Ch */ case    9:  		/* lwz R9, <#[R10 + 4]> */
		/* 8218D33Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 8218D33Ch case    9:*/		return 0x8218D340;
		  /* 8218D340h */ case   10:  		/* rlwinm R11, R9, 28, 29, 31 */
		/* 8218D340h case   10:*/		cpu::op::rlwinm<0,28,29,31>(regs,&regs.R11,regs.R9);
		/* 8218D340h case   10:*/		return 0x8218D344;
		  /* 8218D344h */ case   11:  		/* cmplwi CR6, R11, 1 */
		/* 8218D344h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8218D344h case   11:*/		return 0x8218D348;
		  /* 8218D348h */ case   12:  		/* bc 12, CR6_LT, 200 */
		/* 8218D348h case   12:*/		if ( regs.CR[6].lt ) { return 0x8218D410;  }
		/* 8218D348h case   12:*/		return 0x8218D34C;
		  /* 8218D34Ch */ case   13:  		/* bc 12, CR6_EQ, 156 */
		/* 8218D34Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x8218D3E8;  }
		/* 8218D34Ch case   13:*/		return 0x8218D350;
		  /* 8218D350h */ case   14:  		/* cmplwi CR6, R11, 3 */
		/* 8218D350h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8218D350h case   14:*/		return 0x8218D354;
		  /* 8218D354h */ case   15:  		/* bc 12, CR6_LT, 136 */
		/* 8218D354h case   15:*/		if ( regs.CR[6].lt ) { return 0x8218D3DC;  }
		/* 8218D354h case   15:*/		return 0x8218D358;
		  /* 8218D358h */ case   16:  		/* bc 12, CR6_EQ, 96 */
		/* 8218D358h case   16:*/		if ( regs.CR[6].eq ) { return 0x8218D3B8;  }
		/* 8218D358h case   16:*/		return 0x8218D35C;
		  /* 8218D35Ch */ case   17:  		/* lwz R11, <#[R10]> */
		/* 8218D35Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8218D35Ch case   17:*/		return 0x8218D360;
		  /* 8218D360h */ case   18:  		/* lis R10, 4080 */
		/* 8218D360h case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0xFF0);
		/* 8218D360h case   18:*/		return 0x8218D364;
		  /* 8218D364h */ case   19:  		/* rlwinm R11, R11, 0, 3, 11 */
		/* 8218D364h case   19:*/		cpu::op::rlwinm<0,0,3,11>(regs,&regs.R11,regs.R11);
		/* 8218D364h case   19:*/		return 0x8218D368;
		  /* 8218D368h */ case   20:  		/* cmplw CR6, R11, R10 */
		/* 8218D368h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8218D368h case   20:*/		return 0x8218D36C;
		  /* 8218D36Ch */ case   21:  		/* bc 12, CR6_GT, 12 */
		/* 8218D36Ch case   21:*/		if ( regs.CR[6].gt ) { return 0x8218D378;  }
		/* 8218D36Ch case   21:*/		return 0x8218D370;
		  /* 8218D370h */ case   22:  		/* li R4, 4800 */
		/* 8218D370h case   22:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8218D370h case   22:*/		return 0x8218D374;
		  /* 8218D374h */ case   23:  		/* bl -242956 */
		/* 8218D374h case   23:*/		regs.LR = 0x8218D378; return 0x82151E68;
		/* 8218D374h case   23:*/		return 0x8218D378;
	}
	return 0x8218D378;
} // Block from 8218D318h-8218D378h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8218D378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D378);
		  /* 8218D378h */ case    0:  		/* rlwinm. R11, R9, 0, 16, 24 */
		/* 8218D378h case    0:*/		cpu::op::rlwinm<1,0,16,24>(regs,&regs.R11,regs.R9);
		/* 8218D378h case    0:*/		return 0x8218D37C;
		  /* 8218D37Ch */ case    1:  		/* bc 12, CR0_EQ, 48 */
		/* 8218D37Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8218D3AC;  }
		/* 8218D37Ch case    1:*/		return 0x8218D380;
		  /* 8218D380h */ case    2:  		/* mr R3, R31 */
		/* 8218D380h case    2:*/		regs.R3 = regs.R31;
		/* 8218D380h case    2:*/		return 0x8218D384;
		  /* 8218D384h */ case    3:  		/* bl -252 */
		/* 8218D384h case    3:*/		regs.LR = 0x8218D388; return 0x8218D288;
		/* 8218D384h case    3:*/		return 0x8218D388;
		  /* 8218D388h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 8218D388h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8218D388h case    4:*/		return 0x8218D38C;
		  /* 8218D38Ch */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 8218D38Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x8218D39C;  }
		/* 8218D38Ch case    5:*/		return 0x8218D390;
		  /* 8218D390h */ case    6:  		/* li R4, 4800 */
		/* 8218D390h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8218D390h case    6:*/		return 0x8218D394;
		  /* 8218D394h */ case    7:  		/* mr R3, R31 */
		/* 8218D394h case    7:*/		regs.R3 = regs.R31;
		/* 8218D394h case    7:*/		return 0x8218D398;
		  /* 8218D398h */ case    8:  		/* bl -242992 */
		/* 8218D398h case    8:*/		regs.LR = 0x8218D39C; return 0x82151E68;
		/* 8218D398h case    8:*/		return 0x8218D39C;
	}
	return 0x8218D39C;
} // Block from 8218D378h-8218D39Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218D39Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D39C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D39C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D39C);
		  /* 8218D39Ch */ case    0:  		/* lwz R5, <#[R3 + 24]> */
		/* 8218D39Ch case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000018) );
		/* 8218D39Ch case    0:*/		return 0x8218D3A0;
		  /* 8218D3A0h */ case    1:  		/* li R4, 4509 */
		/* 8218D3A0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x119D);
		/* 8218D3A0h case    1:*/		return 0x8218D3A4;
		  /* 8218D3A4h */ case    2:  		/* mr R3, R31 */
		/* 8218D3A4h case    2:*/		regs.R3 = regs.R31;
		/* 8218D3A4h case    2:*/		return 0x8218D3A8;
		  /* 8218D3A8h */ case    3:  		/* bl -243008 */
		/* 8218D3A8h case    3:*/		regs.LR = 0x8218D3AC; return 0x82151E68;
		/* 8218D3A8h case    3:*/		return 0x8218D3AC;
	}
	return 0x8218D3AC;
} // Block from 8218D39Ch-8218D3ACh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218D3ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D3AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D3AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D3AC);
		  /* 8218D3ACh */ case    0:  		/* li R11, 0 */
		/* 8218D3ACh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218D3ACh case    0:*/		return 0x8218D3B0;
		  /* 8218D3B0h */ case    1:  		/* stw R11, <#[R30]> */
		/* 8218D3B0h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8218D3B0h case    1:*/		return 0x8218D3B4;
		  /* 8218D3B4h */ case    2:  		/* b 32 */
		/* 8218D3B4h case    2:*/		return 0x8218D3D4;
		/* 8218D3B4h case    2:*/		return 0x8218D3B8;
	}
	return 0x8218D3B8;
} // Block from 8218D3ACh-8218D3B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218D3B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D3B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D3B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D3B8);
		  /* 8218D3B8h */ case    0:  		/* mr R3, R31 */
		/* 8218D3B8h case    0:*/		regs.R3 = regs.R31;
		/* 8218D3B8h case    0:*/		return 0x8218D3BC;
		  /* 8218D3BCh */ case    1:  		/* bl -167972 */
		/* 8218D3BCh case    1:*/		regs.LR = 0x8218D3C0; return 0x82164398;
		/* 8218D3BCh case    1:*/		return 0x8218D3C0;
		  /* 8218D3C0h */ case    2:  		/* mr R28, R3 */
		/* 8218D3C0h case    2:*/		regs.R28 = regs.R3;
		/* 8218D3C0h case    2:*/		return 0x8218D3C4;
		  /* 8218D3C4h */ case    3:  		/* mr R3, R31 */
		/* 8218D3C4h case    3:*/		regs.R3 = regs.R31;
		/* 8218D3C4h case    3:*/		return 0x8218D3C8;
		  /* 8218D3C8h */ case    4:  		/* bl -8040 */
		/* 8218D3C8h case    4:*/		regs.LR = 0x8218D3CC; return 0x8218B460;
		/* 8218D3C8h case    4:*/		return 0x8218D3CC;
		  /* 8218D3CCh */ case    5:  		/* add R11, R3, R28 */
		/* 8218D3CCh case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R28);
		/* 8218D3CCh case    5:*/		return 0x8218D3D0;
		  /* 8218D3D0h */ case    6:  		/* stw R28, <#[R30]> */
		/* 8218D3D0h case    6:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R30 + 0x00000000) );
		/* 8218D3D0h case    6:*/		return 0x8218D3D4;
	}
	return 0x8218D3D4;
} // Block from 8218D3B8h-8218D3D4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218D3D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D3D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D3D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D3D4);
		  /* 8218D3D4h */ case    0:  		/* stw R11, <#[R29]> */
		/* 8218D3D4h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8218D3D4h case    0:*/		return 0x8218D3D8;
		  /* 8218D3D8h */ case    1:  		/* b 100 */
		/* 8218D3D8h case    1:*/		return 0x8218D43C;
		/* 8218D3D8h case    1:*/		return 0x8218D3DC;
	}
	return 0x8218D3DC;
} // Block from 8218D3D4h-8218D3DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218D3DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D3DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D3DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D3DC);
		  /* 8218D3DCh */ case    0:  		/* li R11, 0 */
		/* 8218D3DCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218D3DCh case    0:*/		return 0x8218D3E0;
		  /* 8218D3E0h */ case    1:  		/* li R10, 256 */
		/* 8218D3E0h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x100);
		/* 8218D3E0h case    1:*/		return 0x8218D3E4;
		  /* 8218D3E4h */ case    2:  		/* b 80 */
		/* 8218D3E4h case    2:*/		return 0x8218D434;
		/* 8218D3E4h case    2:*/		return 0x8218D3E8;
	}
	return 0x8218D3E8;
} // Block from 8218D3DCh-8218D3E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218D3E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D3E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D3E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D3E8);
		  /* 8218D3E8h */ case    0:  		/* lwz R11, <#[R31 + 48]> */
		/* 8218D3E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8218D3E8h case    0:*/		return 0x8218D3EC;
		  /* 8218D3ECh */ case    1:  		/* lis R10, -1 */
		/* 8218D3ECh case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8218D3ECh case    1:*/		return 0x8218D3F0;
		  /* 8218D3F0h */ case    2:  		/* li R9, 16 */
		/* 8218D3F0h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 8218D3F0h case    2:*/		return 0x8218D3F4;
		  /* 8218D3F4h */ case    3:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 8218D3F4h case    3:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 8218D3F4h case    3:*/		return 0x8218D3F8;
		  /* 8218D3F8h */ case    4:  		/* subf R11, R10, R11 */
		/* 8218D3F8h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218D3F8h case    4:*/		return 0x8218D3FC;
		  /* 8218D3FCh */ case    5:  		/* addic R11, R11, -1 */
		/* 8218D3FCh case    5:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8218D3FCh case    5:*/		return 0x8218D400;
		  /* 8218D400h */ case    6:  		/* subfe R11, R11, R11 */
		/* 8218D400h case    6:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8218D400h case    6:*/		return 0x8218D404;
		  /* 8218D404h */ case    7:  		/* and R11, R11, R9 */
		/* 8218D404h case    7:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8218D404h case    7:*/		return 0x8218D408;
		  /* 8218D408h */ case    8:  		/* addi R10, R11, 16 */
		/* 8218D408h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x10);
		/* 8218D408h case    8:*/		return 0x8218D40C;
		  /* 8218D40Ch */ case    9:  		/* b 40 */
		/* 8218D40Ch case    9:*/		return 0x8218D434;
		/* 8218D40Ch case    9:*/		return 0x8218D410;
	}
	return 0x8218D410;
} // Block from 8218D3E8h-8218D410h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8218D410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D410);
		  /* 8218D410h */ case    0:  		/* lwz R11, <#[R31 + 48]> */
		/* 8218D410h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8218D410h case    0:*/		return 0x8218D414;
		  /* 8218D414h */ case    1:  		/* lis R10, -1 */
		/* 8218D414h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8218D414h case    1:*/		return 0x8218D418;
		  /* 8218D418h */ case    2:  		/* li R9, 128 */
		/* 8218D418h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x80);
		/* 8218D418h case    2:*/		return 0x8218D41C;
		  /* 8218D41Ch */ case    3:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 8218D41Ch case    3:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 8218D41Ch case    3:*/		return 0x8218D420;
		  /* 8218D420h */ case    4:  		/* subf R11, R10, R11 */
		/* 8218D420h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218D420h case    4:*/		return 0x8218D424;
		  /* 8218D424h */ case    5:  		/* addic R11, R11, -1 */
		/* 8218D424h case    5:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8218D424h case    5:*/		return 0x8218D428;
		  /* 8218D428h */ case    6:  		/* subfe R11, R11, R11 */
		/* 8218D428h case    6:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8218D428h case    6:*/		return 0x8218D42C;
		  /* 8218D42Ch */ case    7:  		/* and R11, R11, R9 */
		/* 8218D42Ch case    7:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8218D42Ch case    7:*/		return 0x8218D430;
		  /* 8218D430h */ case    8:  		/* addi R10, R11, 128 */
		/* 8218D430h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x80);
		/* 8218D430h case    8:*/		return 0x8218D434;
	}
	return 0x8218D434;
} // Block from 8218D410h-8218D434h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218D434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D434);
		  /* 8218D434h */ case    0:  		/* stw R11, <#[R30]> */
		/* 8218D434h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8218D434h case    0:*/		return 0x8218D438;
		  /* 8218D438h */ case    1:  		/* stw R10, <#[R29]> */
		/* 8218D438h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 8218D438h case    1:*/		return 0x8218D43C;
	}
	return 0x8218D43C;
} // Block from 8218D434h-8218D43Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218D43Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D43C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D43C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D43C);
		  /* 8218D43Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 8218D43Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8218D43Ch case    0:*/		return 0x8218D440;
		  /* 8218D440h */ case    1:  		/* b -1032600 */
		/* 8218D440h case    1:*/		return 0x820912A8;
		/* 8218D440h case    1:*/		return 0x8218D444;
		  /* 8218D444h */ case    2:  		/* nop */
		/* 8218D444h case    2:*/		cpu::op::nop();
		/* 8218D444h case    2:*/		return 0x8218D448;
	}
	return 0x8218D448;
} // Block from 8218D43Ch-8218D448h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218D448h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D448);
		  /* 8218D448h */ case    0:  		/* mfspr R12, LR */
		/* 8218D448h case    0:*/		regs.R12 = regs.LR;
		/* 8218D448h case    0:*/		return 0x8218D44C;
		  /* 8218D44Ch */ case    1:  		/* bl -1032692 */
		/* 8218D44Ch case    1:*/		regs.LR = 0x8218D450; return 0x82091258;
		/* 8218D44Ch case    1:*/		return 0x8218D450;
		  /* 8218D450h */ case    2:  		/* stwu R1, <#[R1 - 400]> */
		/* 8218D450h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE70);
		/* 8218D450h case    2:*/		return 0x8218D454;
		  /* 8218D454h */ case    3:  		/* addi R6, R1, 80 */
		/* 8218D454h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 8218D454h case    3:*/		return 0x8218D458;
		  /* 8218D458h */ case    4:  		/* addi R5, R1, 84 */
		/* 8218D458h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 8218D458h case    4:*/		return 0x8218D45C;
		  /* 8218D45Ch */ case    5:  		/* mr R31, R3 */
		/* 8218D45Ch case    5:*/		regs.R31 = regs.R3;
		/* 8218D45Ch case    5:*/		return 0x8218D460;
		  /* 8218D460h */ case    6:  		/* mr R30, R4 */
		/* 8218D460h case    6:*/		regs.R30 = regs.R4;
		/* 8218D460h case    6:*/		return 0x8218D464;
		  /* 8218D464h */ case    7:  		/* bl -332 */
		/* 8218D464h case    7:*/		regs.LR = 0x8218D468; return 0x8218D318;
		/* 8218D464h case    7:*/		return 0x8218D468;
		  /* 8218D468h */ case    8:  		/* lwz R11, <#[R31 + 12]> */
		/* 8218D468h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8218D468h case    8:*/		return 0x8218D46C;
		  /* 8218D46Ch */ case    9:  		/* mulli R10, R30, 40 */
		/* 8218D46Ch case    9:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R30,0x28);
		/* 8218D46Ch case    9:*/		return 0x8218D470;
		  /* 8218D470h */ case   10:  		/* add R28, R10, R11 */
		/* 8218D470h case   10:*/		cpu::op::add<0>(regs,&regs.R28,regs.R10,regs.R11);
		/* 8218D470h case   10:*/		return 0x8218D474;
		  /* 8218D474h */ case   11:  		/* li R29, 63 */
		/* 8218D474h case   11:*/		cpu::op::li<0>(regs,&regs.R29,0x3F);
		/* 8218D474h case   11:*/		return 0x8218D478;
		  /* 8218D478h */ case   12:  		/* lwz R11, <#[R28 + 4]> */
		/* 8218D478h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8218D478h case   12:*/		return 0x8218D47C;
		  /* 8218D47Ch */ case   13:  		/* rlwinm R11, R11, 28, 29, 31 */
		/* 8218D47Ch case   13:*/		cpu::op::rlwinm<0,28,29,31>(regs,&regs.R11,regs.R11);
		/* 8218D47Ch case   13:*/		return 0x8218D480;
		  /* 8218D480h */ case   14:  		/* cmplwi CR6, R11, 1 */
		/* 8218D480h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8218D480h case   14:*/		return 0x8218D484;
		  /* 8218D484h */ case   15:  		/* bc 12, CR6_LT, 44 */
		/* 8218D484h case   15:*/		if ( regs.CR[6].lt ) { return 0x8218D4B0;  }
		/* 8218D484h case   15:*/		return 0x8218D488;
		  /* 8218D488h */ case   16:  		/* bc 12, CR6_EQ, 32 */
		/* 8218D488h case   16:*/		if ( regs.CR[6].eq ) { return 0x8218D4A8;  }
		/* 8218D488h case   16:*/		return 0x8218D48C;
		  /* 8218D48Ch */ case   17:  		/* cmplwi CR6, R11, 3 */
		/* 8218D48Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8218D48Ch case   17:*/		return 0x8218D490;
		  /* 8218D490h */ case   18:  		/* bc 12, CR6_LT, 16 */
		/* 8218D490h case   18:*/		if ( regs.CR[6].lt ) { return 0x8218D4A0;  }
		/* 8218D490h case   18:*/		return 0x8218D494;
		  /* 8218D494h */ case   19:  		/* bc 4, CR6_EQ, 32 */
		/* 8218D494h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8218D4B4;  }
		/* 8218D494h case   19:*/		return 0x8218D498;
		  /* 8218D498h */ case   20:  		/* li R29, 115 */
		/* 8218D498h case   20:*/		cpu::op::li<0>(regs,&regs.R29,0x73);
		/* 8218D498h case   20:*/		return 0x8218D49C;
		  /* 8218D49Ch */ case   21:  		/* b 24 */
		/* 8218D49Ch case   21:*/		return 0x8218D4B4;
		/* 8218D49Ch case   21:*/		return 0x8218D4A0;
	}
	return 0x8218D4A0;
} // Block from 8218D448h-8218D4A0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8218D4A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D4A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D4A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D4A0);
		  /* 8218D4A0h */ case    0:  		/* li R29, 99 */
		/* 8218D4A0h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x63);
		/* 8218D4A0h case    0:*/		return 0x8218D4A4;
		  /* 8218D4A4h */ case    1:  		/* b 16 */
		/* 8218D4A4h case    1:*/		return 0x8218D4B4;
		/* 8218D4A4h case    1:*/		return 0x8218D4A8;
	}
	return 0x8218D4A8;
} // Block from 8218D4A0h-8218D4A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218D4A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D4A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D4A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D4A8);
		  /* 8218D4A8h */ case    0:  		/* li R29, 105 */
		/* 8218D4A8h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x69);
		/* 8218D4A8h case    0:*/		return 0x8218D4AC;
		  /* 8218D4ACh */ case    1:  		/* b 8 */
		/* 8218D4ACh case    1:*/		return 0x8218D4B4;
		/* 8218D4ACh case    1:*/		return 0x8218D4B0;
	}
	return 0x8218D4B0;
} // Block from 8218D4A8h-8218D4B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218D4B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D4B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D4B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D4B0);
		  /* 8218D4B0h */ case    0:  		/* li R29, 98 */
		/* 8218D4B0h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x62);
		/* 8218D4B0h case    0:*/		return 0x8218D4B4;
	}
	return 0x8218D4B4;
} // Block from 8218D4B0h-8218D4B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218D4B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D4B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D4B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D4B4);
		  /* 8218D4B4h */ case    0:  		/* mr R4, R30 */
		/* 8218D4B4h case    0:*/		regs.R4 = regs.R30;
		/* 8218D4B4h case    0:*/		return 0x8218D4B8;
		  /* 8218D4B8h */ case    1:  		/* mr R3, R31 */
		/* 8218D4B8h case    1:*/		regs.R3 = regs.R31;
		/* 8218D4B8h case    1:*/		return 0x8218D4BC;
		  /* 8218D4BCh */ case    2:  		/* bl -564 */
		/* 8218D4BCh case    2:*/		regs.LR = 0x8218D4C0; return 0x8218D288;
		/* 8218D4BCh case    2:*/		return 0x8218D4C0;
		  /* 8218D4C0h */ case    3:  		/* lwz R30, <#[R1 + 84]> */
		/* 8218D4C0h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 8218D4C0h case    3:*/		return 0x8218D4C4;
		  /* 8218D4C4h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 8218D4C4h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8218D4C4h case    4:*/		return 0x8218D4C8;
		  /* 8218D4C8h */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 8218D4C8h case    5:*/		if ( regs.CR[0].eq ) { return 0x8218D4D4;  }
		/* 8218D4C8h case    5:*/		return 0x8218D4CC;
		  /* 8218D4CCh */ case    6:  		/* lwz R5, <#[R3 + 24]> */
		/* 8218D4CCh case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000018) );
		/* 8218D4CCh case    6:*/		return 0x8218D4D0;
		  /* 8218D4D0h */ case    7:  		/* b 44 */
		/* 8218D4D0h case    7:*/		return 0x8218D4FC;
		/* 8218D4D0h case    7:*/		return 0x8218D4D4;
	}
	return 0x8218D4D4;
} // Block from 8218D4B4h-8218D4D4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218D4D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D4D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D4D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D4D4);
		  /* 8218D4D4h */ case    0:  		/* lwz R11, <#[R28]> */
		/* 8218D4D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8218D4D4h case    0:*/		return 0x8218D4D8;
		  /* 8218D4D8h */ case    1:  		/* lis R10, -32253 */
		/* 8218D4D8h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8203);
		/* 8218D4D8h case    1:*/		return 0x8218D4DC;
		  /* 8218D4DCh */ case    2:  		/* extsb R6, R29 */
		/* 8218D4DCh case    2:*/		cpu::op::extsb<0>(regs,&regs.R6,regs.R29);
		/* 8218D4DCh case    2:*/		return 0x8218D4E0;
		  /* 8218D4E0h */ case    3:  		/* rlwinm R11, R11, 12, 23, 31 */
		/* 8218D4E0h case    3:*/		cpu::op::rlwinm<0,12,23,31>(regs,&regs.R11,regs.R11);
		/* 8218D4E0h case    3:*/		return 0x8218D4E4;
		  /* 8218D4E4h */ case    4:  		/* addi R5, R10, 28280 */
		/* 8218D4E4h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x6E78);
		/* 8218D4E4h case    4:*/		return 0x8218D4E8;
		  /* 8218D4E8h */ case    5:  		/* subf R7, R30, R11 */
		/* 8218D4E8h case    5:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R30,regs.R11);
		/* 8218D4E8h case    5:*/		return 0x8218D4EC;
		  /* 8218D4ECh */ case    6:  		/* li R4, 256 */
		/* 8218D4ECh case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x100);
		/* 8218D4ECh case    6:*/		return 0x8218D4F0;
		  /* 8218D4F0h */ case    7:  		/* addi R3, R1, 96 */
		/* 8218D4F0h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8218D4F0h case    7:*/		return 0x8218D4F4;
		  /* 8218D4F4h */ case    8:  		/* bl 899252 */
		/* 8218D4F4h case    8:*/		regs.LR = 0x8218D4F8; return 0x82268DA8;
		/* 8218D4F4h case    8:*/		return 0x8218D4F8;
		  /* 8218D4F8h */ case    9:  		/* addi R5, R1, 96 */
		/* 8218D4F8h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 8218D4F8h case    9:*/		return 0x8218D4FC;
	}
	return 0x8218D4FC;
} // Block from 8218D4D4h-8218D4FCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 8218D4FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D4FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D4FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D4FC);
		  /* 8218D4FCh */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 8218D4FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8218D4FCh case    0:*/		return 0x8218D500;
		  /* 8218D500h */ case    1:  		/* mr R3, R31 */
		/* 8218D500h case    1:*/		regs.R3 = regs.R31;
		/* 8218D500h case    1:*/		return 0x8218D504;
		  /* 8218D504h */ case    2:  		/* cmplw CR6, R30, R11 */
		/* 8218D504h case    2:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8218D504h case    2:*/		return 0x8218D508;
		  /* 8218D508h */ case    3:  		/* bc 4, CR6_LT, 32 */
		/* 8218D508h case    3:*/		if ( !regs.CR[6].lt ) { return 0x8218D528;  }
		/* 8218D508h case    3:*/		return 0x8218D50C;
		  /* 8218D50Ch */ case    4:  		/* extsb R6, R29 */
		/* 8218D50Ch case    4:*/		cpu::op::extsb<0>(regs,&regs.R6,regs.R29);
		/* 8218D50Ch case    4:*/		return 0x8218D510;
		  /* 8218D510h */ case    5:  		/* subf R11, R30, R11 */
		/* 8218D510h case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 8218D510h case    5:*/		return 0x8218D514;
		  /* 8218D514h */ case    6:  		/* mr R8, R6 */
		/* 8218D514h case    6:*/		regs.R8 = regs.R6;
		/* 8218D514h case    6:*/		return 0x8218D518;
		  /* 8218D518h */ case    7:  		/* addi R9, R11, -1 */
		/* 8218D518h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 8218D518h case    7:*/		return 0x8218D51C;
		  /* 8218D51Ch */ case    8:  		/* li R7, 0 */
		/* 8218D51Ch case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8218D51Ch case    8:*/		return 0x8218D520;
		  /* 8218D520h */ case    9:  		/* li R4, 3563 */
		/* 8218D520h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0xDEB);
		/* 8218D520h case    9:*/		return 0x8218D524;
		  /* 8218D524h */ case   10:  		/* bl -243388 */
		/* 8218D524h case   10:*/		regs.LR = 0x8218D528; return 0x82151E68;
		/* 8218D524h case   10:*/		return 0x8218D528;
	}
	return 0x8218D528;
} // Block from 8218D4FCh-8218D528h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8218D528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D528);
		  /* 8218D528h */ case    0:  		/* li R4, 4509 */
		/* 8218D528h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x119D);
		/* 8218D528h case    0:*/		return 0x8218D52C;
		  /* 8218D52Ch */ case    1:  		/* bl -243396 */
		/* 8218D52Ch case    1:*/		regs.LR = 0x8218D530; return 0x82151E68;
		/* 8218D52Ch case    1:*/		return 0x8218D530;
	}
	return 0x8218D530;
} // Block from 8218D528h-8218D530h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218D530h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D530);
		  /* 8218D530h */ case    0:  		/* mfspr R12, LR */
		/* 8218D530h case    0:*/		regs.R12 = regs.LR;
		/* 8218D530h case    0:*/		return 0x8218D534;
		  /* 8218D534h */ case    1:  		/* bl -1032924 */
		/* 8218D534h case    1:*/		regs.LR = 0x8218D538; return 0x82091258;
		/* 8218D534h case    1:*/		return 0x8218D538;
		  /* 8218D538h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8218D538h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8218D538h case    2:*/		return 0x8218D53C;
		  /* 8218D53Ch */ case    3:  		/* add R28, R4, R5 */
		/* 8218D53Ch case    3:*/		cpu::op::add<0>(regs,&regs.R28,regs.R4,regs.R5);
		/* 8218D53Ch case    3:*/		return 0x8218D540;
		  /* 8218D540h */ case    4:  		/* mr R29, R3 */
		/* 8218D540h case    4:*/		regs.R29 = regs.R3;
		/* 8218D540h case    4:*/		return 0x8218D544;
		  /* 8218D544h */ case    5:  		/* mr R30, R4 */
		/* 8218D544h case    5:*/		regs.R30 = regs.R4;
		/* 8218D544h case    5:*/		return 0x8218D548;
		  /* 8218D548h */ case    6:  		/* cmplw CR6, R4, R28 */
		/* 8218D548h case    6:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R28);
		/* 8218D548h case    6:*/		return 0x8218D54C;
		  /* 8218D54Ch */ case    7:  		/* bc 4, CR6_LT, 112 */
		/* 8218D54Ch case    7:*/		if ( !regs.CR[6].lt ) { return 0x8218D5BC;  }
		/* 8218D54Ch case    7:*/		return 0x8218D550;
		  /* 8218D550h */ case    8:  		/* rlwinm R31, R4, 2, 0, 29 */
		/* 8218D550h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R4);
		/* 8218D550h case    8:*/		return 0x8218D554;
		  /* 8218D554h */ case    9:  		/* rlwinm R11, R31, 26, 6, 31 */
		/* 8218D554h case    9:*/		cpu::op::rlwinm<0,26,6,31>(regs,&regs.R11,regs.R31);
		/* 8218D554h case    9:*/		return 0x8218D558;
		  /* 8218D558h */ case   10:  		/* addi R10, R31, 3 */
		/* 8218D558h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x3);
		/* 8218D558h case   10:*/		return 0x8218D55C;
		  /* 8218D55Ch */ case   11:  		/* addi R11, R11, 1 */
		/* 8218D55Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218D55Ch case   11:*/		return 0x8218D560;
		  /* 8218D560h */ case   12:  		/* rldicl R10, R10, 0, 58 */
		/* 8218D560h case   12:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R10,regs.R10);
		/* 8218D560h case   12:*/		return 0x8218D564;
		  /* 8218D564h */ case   13:  		/* rlwinm R8, R11, 3, 0, 28 */
		/* 8218D564h case   13:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R8,regs.R11);
		/* 8218D564h case   13:*/		return 0x8218D568;
		  /* 8218D568h */ case   14:  		/* li R9, 2 */
		/* 8218D568h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 8218D568h case   14:*/		return 0x8218D56C;
		  /* 8218D56Ch */ case   15:  		/* sld R11, R9, R10 */
		/* 8218D56Ch case   15:*/		cpu::op::sld<0>(regs,&regs.R11,regs.R9,regs.R10);
		/* 8218D56Ch case   15:*/		return 0x8218D570;
		  /* 8218D570h */ case   16:  		/* ldx R10, <#[R8 + R29]> */
		/* 8218D570h case   16:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R8 + regs.R29 + 0x00000000) );
		/* 8218D570h case   16:*/		return 0x8218D574;
		  /* 8218D574h */ case   17:  		/* addi R11, R11, -1 */
		/* 8218D574h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8218D574h case   17:*/		return 0x8218D578;
		  /* 8218D578h */ case   18:  		/* rldicl R9, R31, 0, 58 */
		/* 8218D578h case   18:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R9,regs.R31);
		/* 8218D578h case   18:*/		return 0x8218D57C;
		  /* 8218D57Ch */ case   19:  		/* li R8, -1 */
		/* 8218D57Ch case   19:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 8218D57Ch case   19:*/		return 0x8218D580;
		  /* 8218D580h */ case   20:  		/* and R11, R11, R10 */
		/* 8218D580h case   20:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8218D580h case   20:*/		return 0x8218D584;
		  /* 8218D584h */ case   21:  		/* sld R10, R8, R9 */
		/* 8218D584h case   21:*/		cpu::op::sld<0>(regs,&regs.R10,regs.R8,regs.R9);
		/* 8218D584h case   21:*/		return 0x8218D588;
		  /* 8218D588h */ case   22:  		/* and R11, R11, R10 */
		/* 8218D588h case   22:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8218D588h case   22:*/		return 0x8218D58C;
		  /* 8218D58Ch */ case   23:  		/* srd R11, R11, R9 */
		/* 8218D58Ch case   23:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8218D58Ch case   23:*/		return 0x8218D590;
		  /* 8218D590h */ case   24:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 8218D590h case   24:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 8218D590h case   24:*/		return 0x8218D594;
		  /* 8218D594h */ case   25:  		/* subfic R4, R11, 15 */
		/* 8218D594h case   25:*/		cpu::op::subfic<0>(regs,&regs.R4,regs.R11,0xF);
		/* 8218D594h case   25:*/		return 0x8218D598;
		  /* 8218D598h */ case   26:  		/* cmplwi CR6, R4, 0 */
		/* 8218D598h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8218D598h case   26:*/		return 0x8218D59C;
		  /* 8218D59Ch */ case   27:  		/* bc 12, CR6_EQ, 16 */
		/* 8218D59Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x8218D5AC;  }
		/* 8218D59Ch case   27:*/		return 0x8218D5A0;
		  /* 8218D5A0h */ case   28:  		/* mr R3, R29 */
		/* 8218D5A0h case   28:*/		regs.R3 = regs.R29;
		/* 8218D5A0h case   28:*/		return 0x8218D5A4;
		  /* 8218D5A4h */ case   29:  		/* rlwimi R4, R30, 4, 0, 27 */
		/* 8218D5A4h case   29:*/		cpu::op::rlwimi<0,4,0,27>(regs,&regs.R4,regs.R30);
		/* 8218D5A4h case   29:*/		return 0x8218D5A8;
		  /* 8218D5A8h */ case   30:  		/* bl -123208 */
		/* 8218D5A8h case   30:*/		regs.LR = 0x8218D5AC; return 0x8216F460;
		/* 8218D5A8h case   30:*/		return 0x8218D5AC;
	}
	return 0x8218D5AC;
} // Block from 8218D530h-8218D5ACh (31 instructions)

//////////////////////////////////////////////////////
// Block at 8218D5ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D5AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D5AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D5AC);
		  /* 8218D5ACh */ case    0:  		/* addi R30, R30, 1 */
		/* 8218D5ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8218D5ACh case    0:*/		return 0x8218D5B0;
		  /* 8218D5B0h */ case    1:  		/* addi R31, R31, 4 */
		/* 8218D5B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8218D5B0h case    1:*/		return 0x8218D5B4;
		  /* 8218D5B4h */ case    2:  		/* cmplw CR6, R30, R28 */
		/* 8218D5B4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R28);
		/* 8218D5B4h case    2:*/		return 0x8218D5B8;
		  /* 8218D5B8h */ case    3:  		/* bc 12, CR6_LT, -100 */
		/* 8218D5B8h case    3:*/		if ( regs.CR[6].lt ) { return 0x8218D554;  }
		/* 8218D5B8h case    3:*/		return 0x8218D5BC;
	}
	return 0x8218D5BC;
} // Block from 8218D5ACh-8218D5BCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218D5BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D5BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D5BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D5BC);
		  /* 8218D5BCh */ case    0:  		/* addi R1, R1, 128 */
		/* 8218D5BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8218D5BCh case    0:*/		return 0x8218D5C0;
		  /* 8218D5C0h */ case    1:  		/* b -1032984 */
		/* 8218D5C0h case    1:*/		return 0x820912A8;
		/* 8218D5C0h case    1:*/		return 0x8218D5C4;
		  /* 8218D5C4h */ case    2:  		/* nop */
		/* 8218D5C4h case    2:*/		cpu::op::nop();
		/* 8218D5C4h case    2:*/		return 0x8218D5C8;
		  /* 8218D5C8h */ case    3:  		/* add R8, R4, R5 */
		/* 8218D5C8h case    3:*/		cpu::op::add<0>(regs,&regs.R8,regs.R4,regs.R5);
		/* 8218D5C8h case    3:*/		return 0x8218D5CC;
		  /* 8218D5CCh */ case    4:  		/* mr R9, R4 */
		/* 8218D5CCh case    4:*/		regs.R9 = regs.R4;
		/* 8218D5CCh case    4:*/		return 0x8218D5D0;
		  /* 8218D5D0h */ case    5:  		/* cmplw CR6, R4, R8 */
		/* 8218D5D0h case    5:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R8);
		/* 8218D5D0h case    5:*/		return 0x8218D5D4;
		  /* 8218D5D4h */ case    6:  		/* bclr 4, CR6_LT */
		/* 8218D5D4h case    6:*/		if ( !regs.CR[6].lt ) { return (uint32)regs.LR; }
		/* 8218D5D4h case    6:*/		return 0x8218D5D8;
	}
	return 0x8218D5D8;
} // Block from 8218D5BCh-8218D5D8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218D5D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D5D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D5D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D5D8);
		  /* 8218D5D8h */ case    0:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 8218D5D8h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 8218D5D8h case    0:*/		return 0x8218D5DC;
		  /* 8218D5DCh */ case    1:  		/* rlwinm R11, R10, 26, 6, 31 */
		/* 8218D5DCh case    1:*/		cpu::op::rlwinm<0,26,6,31>(regs,&regs.R11,regs.R10);
		/* 8218D5DCh case    1:*/		return 0x8218D5E0;
		  /* 8218D5E0h */ case    2:  		/* addi R7, R10, 3 */
		/* 8218D5E0h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0x3);
		/* 8218D5E0h case    2:*/		return 0x8218D5E4;
		  /* 8218D5E4h */ case    3:  		/* addi R11, R11, 1 */
		/* 8218D5E4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218D5E4h case    3:*/		return 0x8218D5E8;
		  /* 8218D5E8h */ case    4:  		/* rldicl R7, R7, 0, 58 */
		/* 8218D5E8h case    4:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R7,regs.R7);
		/* 8218D5E8h case    4:*/		return 0x8218D5EC;
		  /* 8218D5ECh */ case    5:  		/* rlwinm R5, R11, 3, 0, 28 */
		/* 8218D5ECh case    5:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R5,regs.R11);
		/* 8218D5ECh case    5:*/		return 0x8218D5F0;
		  /* 8218D5F0h */ case    6:  		/* li R6, 2 */
		/* 8218D5F0h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 8218D5F0h case    6:*/		return 0x8218D5F4;
		  /* 8218D5F4h */ case    7:  		/* sld R11, R6, R7 */
		/* 8218D5F4h case    7:*/		cpu::op::sld<0>(regs,&regs.R11,regs.R6,regs.R7);
		/* 8218D5F4h case    7:*/		return 0x8218D5F8;
		  /* 8218D5F8h */ case    8:  		/* ldx R7, <#[R5 + R3]> */
		/* 8218D5F8h case    8:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8218D5F8h case    8:*/		return 0x8218D5FC;
		  /* 8218D5FCh */ case    9:  		/* addi R11, R11, -1 */
		/* 8218D5FCh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8218D5FCh case    9:*/		return 0x8218D600;
		  /* 8218D600h */ case   10:  		/* rldicl R6, R10, 0, 58 */
		/* 8218D600h case   10:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R6,regs.R10);
		/* 8218D600h case   10:*/		return 0x8218D604;
		  /* 8218D604h */ case   11:  		/* li R5, -1 */
		/* 8218D604h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0xFFFFFFFF);
		/* 8218D604h case   11:*/		return 0x8218D608;
		  /* 8218D608h */ case   12:  		/* and R11, R11, R7 */
		/* 8218D608h case   12:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 8218D608h case   12:*/		return 0x8218D60C;
		  /* 8218D60Ch */ case   13:  		/* sld R7, R5, R6 */
		/* 8218D60Ch case   13:*/		cpu::op::sld<0>(regs,&regs.R7,regs.R5,regs.R6);
		/* 8218D60Ch case   13:*/		return 0x8218D610;
		  /* 8218D610h */ case   14:  		/* and R11, R11, R7 */
		/* 8218D610h case   14:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 8218D610h case   14:*/		return 0x8218D614;
		  /* 8218D614h */ case   15:  		/* srd R11, R11, R6 */
		/* 8218D614h case   15:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 8218D614h case   15:*/		return 0x8218D618;
		  /* 8218D618h */ case   16:  		/* rlwinm. R11, R11, 0, 0, 31 */
		/* 8218D618h case   16:*/		cpu::op::rlwinm<1,0,0,31>(regs,&regs.R11,regs.R11);
		/* 8218D618h case   16:*/		return 0x8218D61C;
		  /* 8218D61Ch */ case   17:  		/* bc 12, CR0_EQ, 52 */
		/* 8218D61Ch case   17:*/		if ( regs.CR[0].eq ) { return 0x8218D650;  }
		/* 8218D61Ch case   17:*/		return 0x8218D620;
		  /* 8218D620h */ case   18:  		/* rlwimi R11, R9, 4, 0, 27 */
		/* 8218D620h case   18:*/		cpu::op::rlwimi<0,4,0,27>(regs,&regs.R11,regs.R9);
		/* 8218D620h case   18:*/		return 0x8218D624;
		  /* 8218D624h */ case   19:  		/* mr R7, R11 */
		/* 8218D624h case   19:*/		regs.R7 = regs.R11;
		/* 8218D624h case   19:*/		return 0x8218D628;
		  /* 8218D628h */ case   20:  		/* rlwinm R11, R11, 24, 8, 31 */
		/* 8218D628h case   20:*/		cpu::op::rlwinm<0,24,8,31>(regs,&regs.R11,regs.R11);
		/* 8218D628h case   20:*/		return 0x8218D62C;
		  /* 8218D62Ch */ case   21:  		/* rlwinm R6, R7, 30, 2, 29 */
		/* 8218D62Ch case   21:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R6,regs.R7);
		/* 8218D62Ch case   21:*/		return 0x8218D630;
		  /* 8218D630h */ case   22:  		/* addi R11, R11, 1 */
		/* 8218D630h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218D630h case   22:*/		return 0x8218D634;
		  /* 8218D634h */ case   23:  		/* rldicl R6, R6, 0, 58 */
		/* 8218D634h case   23:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R6,regs.R6);
		/* 8218D634h case   23:*/		return 0x8218D638;
		  /* 8218D638h */ case   24:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8218D638h case   24:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8218D638h case   24:*/		return 0x8218D63C;
		  /* 8218D63Ch */ case   25:  		/* rldicl R7, R7, 0, 60 */
		/* 8218D63Ch case   25:*/		cpu::op::rldicl<0,0,60>(regs,&regs.R7,regs.R7);
		/* 8218D63Ch case   25:*/		return 0x8218D640;
		  /* 8218D640h */ case   26:  		/* sld R7, R7, R6 */
		/* 8218D640h case   26:*/		cpu::op::sld<0>(regs,&regs.R7,regs.R7,regs.R6);
		/* 8218D640h case   26:*/		return 0x8218D644;
		  /* 8218D644h */ case   27:  		/* ldx R6, <#[R11 + R3]> */
		/* 8218D644h case   27:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8218D644h case   27:*/		return 0x8218D648;
		  /* 8218D648h */ case   28:  		/* subf R7, R7, R6 */
		/* 8218D648h case   28:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R7,regs.R6);
		/* 8218D648h case   28:*/		return 0x8218D64C;
		  /* 8218D64Ch */ case   29:  		/* stdx R7, <#[R11 + R3]> */
		/* 8218D64Ch case   29:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8218D64Ch case   29:*/		return 0x8218D650;
	}
	return 0x8218D650;
} // Block from 8218D5D8h-8218D650h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8218D650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D650);
		  /* 8218D650h */ case    0:  		/* addi R9, R9, 1 */
		/* 8218D650h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8218D650h case    0:*/		return 0x8218D654;
		  /* 8218D654h */ case    1:  		/* addi R10, R10, 4 */
		/* 8218D654h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8218D654h case    1:*/		return 0x8218D658;
		  /* 8218D658h */ case    2:  		/* cmplw CR6, R9, R8 */
		/* 8218D658h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 8218D658h case    2:*/		return 0x8218D65C;
		  /* 8218D65Ch */ case    3:  		/* bc 12, CR6_LT, -128 */
		/* 8218D65Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8218D5DC;  }
		/* 8218D65Ch case    3:*/		return 0x8218D660;
		  /* 8218D660h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8218D660h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218D660h case    4:*/		return 0x8218D664;
	}
	return 0x8218D664;
} // Block from 8218D650h-8218D664h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218D664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D664);
		  /* 8218D664h */ case    0:  		/* nop */
		/* 8218D664h case    0:*/		cpu::op::nop();
		/* 8218D664h case    0:*/		return 0x8218D668;
	}
	return 0x8218D668;
} // Block from 8218D664h-8218D668h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218D668h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D668);
		  /* 8218D668h */ case    0:  		/* mfspr R12, LR */
		/* 8218D668h case    0:*/		regs.R12 = regs.LR;
		/* 8218D668h case    0:*/		return 0x8218D66C;
		  /* 8218D66Ch */ case    1:  		/* bl -1033232 */
		/* 8218D66Ch case    1:*/		regs.LR = 0x8218D670; return 0x8209125C;
		/* 8218D66Ch case    1:*/		return 0x8218D670;
		  /* 8218D670h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8218D670h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8218D670h case    2:*/		return 0x8218D674;
		  /* 8218D674h */ case    3:  		/* add R29, R4, R5 */
		/* 8218D674h case    3:*/		cpu::op::add<0>(regs,&regs.R29,regs.R4,regs.R5);
		/* 8218D674h case    3:*/		return 0x8218D678;
		  /* 8218D678h */ case    4:  		/* mr R30, R3 */
		/* 8218D678h case    4:*/		regs.R30 = regs.R3;
		/* 8218D678h case    4:*/		return 0x8218D67C;
		  /* 8218D67Ch */ case    5:  		/* mr R31, R4 */
		/* 8218D67Ch case    5:*/		regs.R31 = regs.R4;
		/* 8218D67Ch case    5:*/		return 0x8218D680;
		  /* 8218D680h */ case    6:  		/* cmplw CR6, R4, R29 */
		/* 8218D680h case    6:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R29);
		/* 8218D680h case    6:*/		return 0x8218D684;
		  /* 8218D684h */ case    7:  		/* bc 4, CR6_LT, 96 */
		/* 8218D684h case    7:*/		if ( !regs.CR[6].lt ) { return 0x8218D6E4;  }
		/* 8218D684h case    7:*/		return 0x8218D688;
		  /* 8218D688h */ case    8:  		/* rlwinm R11, R31, 26, 6, 31 */
		/* 8218D688h case    8:*/		cpu::op::rlwinm<0,26,6,31>(regs,&regs.R11,regs.R31);
		/* 8218D688h case    8:*/		return 0x8218D68C;
		  /* 8218D68Ch */ case    9:  		/* rldicl R10, R31, 0, 58 */
		/* 8218D68Ch case    9:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R10,regs.R31);
		/* 8218D68Ch case    9:*/		return 0x8218D690;
		  /* 8218D690h */ case   10:  		/* addi R11, R11, 1 */
		/* 8218D690h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218D690h case   10:*/		return 0x8218D694;
		  /* 8218D694h */ case   11:  		/* li R9, 2 */
		/* 8218D694h case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 8218D694h case   11:*/		return 0x8218D698;
		  /* 8218D698h */ case   12:  		/* rlwinm R8, R11, 3, 0, 28 */
		/* 8218D698h case   12:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R8,regs.R11);
		/* 8218D698h case   12:*/		return 0x8218D69C;
		  /* 8218D69Ch */ case   13:  		/* sld R11, R9, R10 */
		/* 8218D69Ch case   13:*/		cpu::op::sld<0>(regs,&regs.R11,regs.R9,regs.R10);
		/* 8218D69Ch case   13:*/		return 0x8218D6A0;
		  /* 8218D6A0h */ case   14:  		/* ldx R9, <#[R8 + R30]> */
		/* 8218D6A0h case   14:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R8 + regs.R30 + 0x00000000) );
		/* 8218D6A0h case   14:*/		return 0x8218D6A4;
		  /* 8218D6A4h */ case   15:  		/* addi R11, R11, -1 */
		/* 8218D6A4h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8218D6A4h case   15:*/		return 0x8218D6A8;
		  /* 8218D6A8h */ case   16:  		/* li R8, -1 */
		/* 8218D6A8h case   16:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 8218D6A8h case   16:*/		return 0x8218D6AC;
		  /* 8218D6ACh */ case   17:  		/* and R11, R9, R11 */
		/* 8218D6ACh case   17:*/		cpu::op::and<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8218D6ACh case   17:*/		return 0x8218D6B0;
		  /* 8218D6B0h */ case   18:  		/* sld R9, R8, R10 */
		/* 8218D6B0h case   18:*/		cpu::op::sld<0>(regs,&regs.R9,regs.R8,regs.R10);
		/* 8218D6B0h case   18:*/		return 0x8218D6B4;
		  /* 8218D6B4h */ case   19:  		/* and R11, R11, R9 */
		/* 8218D6B4h case   19:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8218D6B4h case   19:*/		return 0x8218D6B8;
		  /* 8218D6B8h */ case   20:  		/* srd R11, R11, R10 */
		/* 8218D6B8h case   20:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8218D6B8h case   20:*/		return 0x8218D6BC;
		  /* 8218D6BCh */ case   21:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 8218D6BCh case   21:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 8218D6BCh case   21:*/		return 0x8218D6C0;
		  /* 8218D6C0h */ case   22:  		/* subfic R4, R11, 1 */
		/* 8218D6C0h case   22:*/		cpu::op::subfic<0>(regs,&regs.R4,regs.R11,0x1);
		/* 8218D6C0h case   22:*/		return 0x8218D6C4;
		  /* 8218D6C4h */ case   23:  		/* cmplwi CR6, R4, 0 */
		/* 8218D6C4h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8218D6C4h case   23:*/		return 0x8218D6C8;
		  /* 8218D6C8h */ case   24:  		/* bc 12, CR6_EQ, 16 */
		/* 8218D6C8h case   24:*/		if ( regs.CR[6].eq ) { return 0x8218D6D8;  }
		/* 8218D6C8h case   24:*/		return 0x8218D6CC;
		  /* 8218D6CCh */ case   25:  		/* mr R3, R30 */
		/* 8218D6CCh case   25:*/		regs.R3 = regs.R30;
		/* 8218D6CCh case   25:*/		return 0x8218D6D0;
		  /* 8218D6D0h */ case   26:  		/* rlwimi R4, R31, 4, 0, 27 */
		/* 8218D6D0h case   26:*/		cpu::op::rlwimi<0,4,0,27>(regs,&regs.R4,regs.R31);
		/* 8218D6D0h case   26:*/		return 0x8218D6D4;
		  /* 8218D6D4h */ case   27:  		/* bl -4940 */
		/* 8218D6D4h case   27:*/		regs.LR = 0x8218D6D8; return 0x8218C388;
		/* 8218D6D4h case   27:*/		return 0x8218D6D8;
	}
	return 0x8218D6D8;
} // Block from 8218D668h-8218D6D8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8218D6D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D6D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D6D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D6D8);
		  /* 8218D6D8h */ case    0:  		/* addi R31, R31, 1 */
		/* 8218D6D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8218D6D8h case    0:*/		return 0x8218D6DC;
		  /* 8218D6DCh */ case    1:  		/* cmplw CR6, R31, R29 */
		/* 8218D6DCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 8218D6DCh case    1:*/		return 0x8218D6E0;
		  /* 8218D6E0h */ case    2:  		/* bc 12, CR6_LT, -88 */
		/* 8218D6E0h case    2:*/		if ( regs.CR[6].lt ) { return 0x8218D688;  }
		/* 8218D6E0h case    2:*/		return 0x8218D6E4;
	}
	return 0x8218D6E4;
} // Block from 8218D6D8h-8218D6E4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218D6E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D6E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D6E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D6E4);
		  /* 8218D6E4h */ case    0:  		/* addi R1, R1, 112 */
		/* 8218D6E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8218D6E4h case    0:*/		return 0x8218D6E8;
		  /* 8218D6E8h */ case    1:  		/* b -1033276 */
		/* 8218D6E8h case    1:*/		return 0x820912AC;
		/* 8218D6E8h case    1:*/		return 0x8218D6EC;
		  /* 8218D6ECh */ case    2:  		/* nop */
		/* 8218D6ECh case    2:*/		cpu::op::nop();
		/* 8218D6ECh case    2:*/		return 0x8218D6F0;
	}
	return 0x8218D6F0;
} // Block from 8218D6E4h-8218D6F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218D6F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D6F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D6F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D6F0);
		  /* 8218D6F0h */ case    0:  		/* mfspr R12, LR */
		/* 8218D6F0h case    0:*/		regs.R12 = regs.LR;
		/* 8218D6F0h case    0:*/		return 0x8218D6F4;
		  /* 8218D6F4h */ case    1:  		/* bl -1033368 */
		/* 8218D6F4h case    1:*/		regs.LR = 0x8218D6F8; return 0x8209125C;
		/* 8218D6F4h case    1:*/		return 0x8218D6F8;
		  /* 8218D6F8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8218D6F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8218D6F8h case    2:*/		return 0x8218D6FC;
		  /* 8218D6FCh */ case    3:  		/* add R29, R4, R5 */
		/* 8218D6FCh case    3:*/		cpu::op::add<0>(regs,&regs.R29,regs.R4,regs.R5);
		/* 8218D6FCh case    3:*/		return 0x8218D700;
		  /* 8218D700h */ case    4:  		/* mr R30, R3 */
		/* 8218D700h case    4:*/		regs.R30 = regs.R3;
		/* 8218D700h case    4:*/		return 0x8218D704;
		  /* 8218D704h */ case    5:  		/* mr R31, R4 */
		/* 8218D704h case    5:*/		regs.R31 = regs.R4;
		/* 8218D704h case    5:*/		return 0x8218D708;
		  /* 8218D708h */ case    6:  		/* cmplw CR6, R4, R29 */
		/* 8218D708h case    6:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R29);
		/* 8218D708h case    6:*/		return 0x8218D70C;
		  /* 8218D70Ch */ case    7:  		/* bc 4, CR6_LT, 92 */
		/* 8218D70Ch case    7:*/		if ( !regs.CR[6].lt ) { return 0x8218D768;  }
		/* 8218D70Ch case    7:*/		return 0x8218D710;
		  /* 8218D710h */ case    8:  		/* rlwinm R11, R31, 27, 5, 31 */
		/* 8218D710h case    8:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R31);
		/* 8218D710h case    8:*/		return 0x8218D714;
		  /* 8218D714h */ case    9:  		/* rlwinm R10, R31, 0, 27, 31 */
		/* 8218D714h case    9:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R31);
		/* 8218D714h case    9:*/		return 0x8218D718;
		  /* 8218D718h */ case   10:  		/* addi R11, R11, 1 */
		/* 8218D718h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218D718h case   10:*/		return 0x8218D71C;
		  /* 8218D71Ch */ case   11:  		/* li R9, 2 */
		/* 8218D71Ch case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 8218D71Ch case   11:*/		return 0x8218D720;
		  /* 8218D720h */ case   12:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 8218D720h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 8218D720h case   12:*/		return 0x8218D724;
		  /* 8218D724h */ case   13:  		/* slw R11, R9, R10 */
		/* 8218D724h case   13:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R9,regs.R10);
		/* 8218D724h case   13:*/		return 0x8218D728;
		  /* 8218D728h */ case   14:  		/* lwzx R9, <#[R8 + R30]> */
		/* 8218D728h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R30 + 0x00000000) );
		/* 8218D728h case   14:*/		return 0x8218D72C;
		  /* 8218D72Ch */ case   15:  		/* addi R11, R11, -1 */
		/* 8218D72Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8218D72Ch case   15:*/		return 0x8218D730;
		  /* 8218D730h */ case   16:  		/* li R8, -1 */
		/* 8218D730h case   16:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 8218D730h case   16:*/		return 0x8218D734;
		  /* 8218D734h */ case   17:  		/* and R11, R9, R11 */
		/* 8218D734h case   17:*/		cpu::op::and<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8218D734h case   17:*/		return 0x8218D738;
		  /* 8218D738h */ case   18:  		/* slw R9, R8, R10 */
		/* 8218D738h case   18:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R8,regs.R10);
		/* 8218D738h case   18:*/		return 0x8218D73C;
		  /* 8218D73Ch */ case   19:  		/* and R11, R11, R9 */
		/* 8218D73Ch case   19:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8218D73Ch case   19:*/		return 0x8218D740;
		  /* 8218D740h */ case   20:  		/* srw R11, R11, R10 */
		/* 8218D740h case   20:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8218D740h case   20:*/		return 0x8218D744;
		  /* 8218D744h */ case   21:  		/* subfic R4, R11, 1 */
		/* 8218D744h case   21:*/		cpu::op::subfic<0>(regs,&regs.R4,regs.R11,0x1);
		/* 8218D744h case   21:*/		return 0x8218D748;
		  /* 8218D748h */ case   22:  		/* cmplwi CR6, R4, 0 */
		/* 8218D748h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8218D748h case   22:*/		return 0x8218D74C;
		  /* 8218D74Ch */ case   23:  		/* bc 12, CR6_EQ, 16 */
		/* 8218D74Ch case   23:*/		if ( regs.CR[6].eq ) { return 0x8218D75C;  }
		/* 8218D74Ch case   23:*/		return 0x8218D750;
		  /* 8218D750h */ case   24:  		/* mr R3, R30 */
		/* 8218D750h case   24:*/		regs.R3 = regs.R30;
		/* 8218D750h case   24:*/		return 0x8218D754;
		  /* 8218D754h */ case   25:  		/* rlwimi R4, R31, 4, 0, 27 */
		/* 8218D754h case   25:*/		cpu::op::rlwimi<0,4,0,27>(regs,&regs.R4,regs.R31);
		/* 8218D754h case   25:*/		return 0x8218D758;
		  /* 8218D758h */ case   26:  		/* bl -5456 */
		/* 8218D758h case   26:*/		regs.LR = 0x8218D75C; return 0x8218C208;
		/* 8218D758h case   26:*/		return 0x8218D75C;
	}
	return 0x8218D75C;
} // Block from 8218D6F0h-8218D75Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 8218D75Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D75C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D75C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D75C);
		  /* 8218D75Ch */ case    0:  		/* addi R31, R31, 1 */
		/* 8218D75Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8218D75Ch case    0:*/		return 0x8218D760;
		  /* 8218D760h */ case    1:  		/* cmplw CR6, R31, R29 */
		/* 8218D760h case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 8218D760h case    1:*/		return 0x8218D764;
		  /* 8218D764h */ case    2:  		/* bc 12, CR6_LT, -84 */
		/* 8218D764h case    2:*/		if ( regs.CR[6].lt ) { return 0x8218D710;  }
		/* 8218D764h case    2:*/		return 0x8218D768;
	}
	return 0x8218D768;
} // Block from 8218D75Ch-8218D768h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218D768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D768);
		  /* 8218D768h */ case    0:  		/* addi R1, R1, 112 */
		/* 8218D768h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8218D768h case    0:*/		return 0x8218D76C;
		  /* 8218D76Ch */ case    1:  		/* b -1033408 */
		/* 8218D76Ch case    1:*/		return 0x820912AC;
		/* 8218D76Ch case    1:*/		return 0x8218D770;
	}
	return 0x8218D770;
} // Block from 8218D768h-8218D770h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218D770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D770);
		  /* 8218D770h */ case    0:  		/* mfspr R12, LR */
		/* 8218D770h case    0:*/		regs.R12 = regs.LR;
		/* 8218D770h case    0:*/		return 0x8218D774;
		  /* 8218D774h */ case    1:  		/* bl -1033500 */
		/* 8218D774h case    1:*/		regs.LR = 0x8218D778; return 0x82091258;
		/* 8218D774h case    1:*/		return 0x8218D778;
		  /* 8218D778h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8218D778h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8218D778h case    2:*/		return 0x8218D77C;
		  /* 8218D77Ch */ case    3:  		/* mr R30, R4 */
		/* 8218D77Ch case    3:*/		regs.R30 = regs.R4;
		/* 8218D77Ch case    3:*/		return 0x8218D780;
		  /* 8218D780h */ case    4:  		/* mr R29, R5 */
		/* 8218D780h case    4:*/		regs.R29 = regs.R5;
		/* 8218D780h case    4:*/		return 0x8218D784;
		  /* 8218D784h */ case    5:  		/* li R5, 21 */
		/* 8218D784h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x15);
		/* 8218D784h case    5:*/		return 0x8218D788;
		  /* 8218D788h */ case    6:  		/* li R4, 40 */
		/* 8218D788h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x28);
		/* 8218D788h case    6:*/		return 0x8218D78C;
		  /* 8218D78Ch */ case    7:  		/* mr R28, R6 */
		/* 8218D78Ch case    7:*/		regs.R28 = regs.R6;
		/* 8218D78Ch case    7:*/		return 0x8218D790;
		  /* 8218D790h */ case    8:  		/* bl -167584 */
		/* 8218D790h case    8:*/		regs.LR = 0x8218D794; return 0x821648F0;
		/* 8218D790h case    8:*/		return 0x8218D794;
		  /* 8218D794h */ case    9:  		/* addi R10, R3, 28 */
		/* 8218D794h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0x1C);
		/* 8218D794h case    9:*/		return 0x8218D798;
		  /* 8218D798h */ case   10:  		/* li R11, 0 */
		/* 8218D798h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218D798h case   10:*/		return 0x8218D79C;
		  /* 8218D79Ch */ case   11:  		/* addi R9, R10, 4 */
		/* 8218D79Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 8218D79Ch case   11:*/		return 0x8218D7A0;
		  /* 8218D7A0h */ case   12:  		/* ori R10, R10, 1 */
		/* 8218D7A0h case   12:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8218D7A0h case   12:*/		return 0x8218D7A4;
		  /* 8218D7A4h */ case   13:  		/* ori R9, R9, 1 */
		/* 8218D7A4h case   13:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8218D7A4h case   13:*/		return 0x8218D7A8;
		  /* 8218D7A8h */ case   14:  		/* stw R10, <#[R3 + 32]> */
		/* 8218D7A8h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000020) );
		/* 8218D7A8h case   14:*/		return 0x8218D7AC;
		  /* 8218D7ACh */ case   15:  		/* mr R4, R30 */
		/* 8218D7ACh case   15:*/		regs.R4 = regs.R30;
		/* 8218D7ACh case   15:*/		return 0x8218D7B0;
		  /* 8218D7B0h */ case   16:  		/* stw R9, <#[R3 + 28]> */
		/* 8218D7B0h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x0000001C) );
		/* 8218D7B0h case   16:*/		return 0x8218D7B4;
		  /* 8218D7B4h */ case   17:  		/* mr R31, R3 */
		/* 8218D7B4h case   17:*/		regs.R31 = regs.R3;
		/* 8218D7B4h case   17:*/		return 0x8218D7B8;
		  /* 8218D7B8h */ case   18:  		/* stw R28, <#[R3 + 12]> */
		/* 8218D7B8h case   18:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x0000000C) );
		/* 8218D7B8h case   18:*/		return 0x8218D7BC;
		  /* 8218D7BCh */ case   19:  		/* stw R29, <#[R3 + 8]> */
		/* 8218D7BCh case   19:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000008) );
		/* 8218D7BCh case   19:*/		return 0x8218D7C0;
		  /* 8218D7C0h */ case   20:  		/* stw R11, <#[R3 + 20]> */
		/* 8218D7C0h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 8218D7C0h case   20:*/		return 0x8218D7C4;
		  /* 8218D7C4h */ case   21:  		/* stw R11, <#[R3 + 16]> */
		/* 8218D7C4h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8218D7C4h case   21:*/		return 0x8218D7C8;
		  /* 8218D7C8h */ case   22:  		/* stw R11, <#[R3 + 4]> */
		/* 8218D7C8h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8218D7C8h case   22:*/		return 0x8218D7CC;
		  /* 8218D7CCh */ case   23:  		/* stb R11, <#[R3 + 36]> */
		/* 8218D7CCh case   23:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 8218D7CCh case   23:*/		return 0x8218D7D0;
		  /* 8218D7D0h */ case   24:  		/* stw R11, <#[R3 + 24]> */
		/* 8218D7D0h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 8218D7D0h case   24:*/		return 0x8218D7D4;
		  /* 8218D7D4h */ case   25:  		/* bl 432364 */
		/* 8218D7D4h case   25:*/		regs.LR = 0x8218D7D8; return 0x821F70C0;
		/* 8218D7D4h case   25:*/		return 0x8218D7D8;
		  /* 8218D7D8h */ case   26:  		/* mr R3, R31 */
		/* 8218D7D8h case   26:*/		regs.R3 = regs.R31;
		/* 8218D7D8h case   26:*/		return 0x8218D7DC;
		  /* 8218D7DCh */ case   27:  		/* addi R1, R1, 128 */
		/* 8218D7DCh case   27:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8218D7DCh case   27:*/		return 0x8218D7E0;
		  /* 8218D7E0h */ case   28:  		/* b -1033528 */
		/* 8218D7E0h case   28:*/		return 0x820912A8;
		/* 8218D7E0h case   28:*/		return 0x8218D7E4;
		  /* 8218D7E4h */ case   29:  		/* nop */
		/* 8218D7E4h case   29:*/		cpu::op::nop();
		/* 8218D7E4h case   29:*/		return 0x8218D7E8;
	}
	return 0x8218D7E8;
} // Block from 8218D770h-8218D7E8h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8218D7E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D7E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D7E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D7E8);
		  /* 8218D7E8h */ case    0:  		/* mfspr R12, LR */
		/* 8218D7E8h case    0:*/		regs.R12 = regs.LR;
		/* 8218D7E8h case    0:*/		return 0x8218D7EC;
		  /* 8218D7ECh */ case    1:  		/* bl -1033620 */
		/* 8218D7ECh case    1:*/		regs.LR = 0x8218D7F0; return 0x82091258;
		/* 8218D7ECh case    1:*/		return 0x8218D7F0;
		  /* 8218D7F0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8218D7F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8218D7F0h case    2:*/		return 0x8218D7F4;
		  /* 8218D7F4h */ case    3:  		/* mr R29, R4 */
		/* 8218D7F4h case    3:*/		regs.R29 = regs.R4;
		/* 8218D7F4h case    3:*/		return 0x8218D7F8;
		  /* 8218D7F8h */ case    4:  		/* li R11, 0 */
		/* 8218D7F8h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218D7F8h case    4:*/		return 0x8218D7FC;
		  /* 8218D7FCh */ case    5:  		/* addi R28, R4, 8 */
		/* 8218D7FCh case    5:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R4,0x8);
		/* 8218D7FCh case    5:*/		return 0x8218D800;
		  /* 8218D800h */ case    6:  		/* rlwinm R4, R11, 2, 0, 29 */
		/* 8218D800h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R11);
		/* 8218D800h case    6:*/		return 0x8218D804;
		  /* 8218D804h */ case    7:  		/* mr R3, R28 */
		/* 8218D804h case    7:*/		regs.R3 = regs.R28;
		/* 8218D804h case    7:*/		return 0x8218D808;
		  /* 8218D808h */ case    8:  		/* bl -8336 */
		/* 8218D808h case    8:*/		regs.LR = 0x8218D80C; return 0x8218B778;
		/* 8218D808h case    8:*/		return 0x8218D80C;
		  /* 8218D80Ch */ case    9:  		/* cmpwi CR6, R3, -1 */
		/* 8218D80Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218D80Ch case    9:*/		return 0x8218D810;
		  /* 8218D810h */ case   10:  		/* bc 12, CR6_EQ, 88 */
		/* 8218D810h case   10:*/		if ( regs.CR[6].eq ) { return 0x8218D868;  }
		/* 8218D810h case   10:*/		return 0x8218D814;
		  /* 8218D814h */ case   11:  		/* rlwinm R30, R3, 30, 2, 31 */
		/* 8218D814h case   11:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R30,regs.R3);
		/* 8218D814h case   11:*/		return 0x8218D818;
		  /* 8218D818h */ case   12:  		/* cmpwi CR6, R30, -1 */
		/* 8218D818h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R30,0xFFFFFFFF);
		/* 8218D818h case   12:*/		return 0x8218D81C;
		  /* 8218D81Ch */ case   13:  		/* bc 12, CR6_EQ, 76 */
		/* 8218D81Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x8218D868;  }
		/* 8218D81Ch case   13:*/		return 0x8218D820;
		  /* 8218D820h */ case   14:  		/* li R6, 4 */
		/* 8218D820h case   14:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 8218D820h case   14:*/		return 0x8218D824;
		  /* 8218D824h */ case   15:  		/* li R5, 1 */
		/* 8218D824h case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8218D824h case   15:*/		return 0x8218D828;
		  /* 8218D828h */ case   16:  		/* mr R4, R30 */
		/* 8218D828h case   16:*/		regs.R4 = regs.R30;
		/* 8218D828h case   16:*/		return 0x8218D82C;
		  /* 8218D82Ch */ case   17:  		/* mr R3, R29 */
		/* 8218D82Ch case   17:*/		regs.R3 = regs.R29;
		/* 8218D82Ch case   17:*/		return 0x8218D830;
		  /* 8218D830h */ case   18:  		/* bl -7528 */
		/* 8218D830h case   18:*/		regs.LR = 0x8218D834; return 0x8218BAC8;
		/* 8218D830h case   18:*/		return 0x8218D834;
		  /* 8218D834h */ case   19:  		/* cmpwi CR6, R3, -1 */
		/* 8218D834h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218D834h case   19:*/		return 0x8218D838;
		  /* 8218D838h */ case   20:  		/* li R31, 256 */
		/* 8218D838h case   20:*/		cpu::op::li<0>(regs,&regs.R31,0x100);
		/* 8218D838h case   20:*/		return 0x8218D83C;
		  /* 8218D83Ch */ case   21:  		/* bc 12, CR6_EQ, 8 */
		/* 8218D83Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x8218D844;  }
		/* 8218D83Ch case   21:*/		return 0x8218D840;
		  /* 8218D840h */ case   22:  		/* rlwinm R31, R3, 28, 4, 31 */
		/* 8218D840h case   22:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R31,regs.R3);
		/* 8218D840h case   22:*/		return 0x8218D844;
	}
	return 0x8218D844;
} // Block from 8218D7E8h-8218D844h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8218D844h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D844( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D844) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D844);
		  /* 8218D844h */ case    0:  		/* addi R11, R31, 3 */
		/* 8218D844h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x3);
		/* 8218D844h case    0:*/		return 0x8218D848;
		  /* 8218D848h */ case    1:  		/* rlwinm R4, R30, 0, 0, 29 */
		/* 8218D848h case    1:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R4,regs.R30);
		/* 8218D848h case    1:*/		return 0x8218D84C;
		  /* 8218D84Ch */ case    2:  		/* rlwinm R11, R11, 0, 0, 29 */
		/* 8218D84Ch case    2:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R11);
		/* 8218D84Ch case    2:*/		return 0x8218D850;
		  /* 8218D850h */ case    3:  		/* mr R3, R29 */
		/* 8218D850h case    3:*/		regs.R3 = regs.R29;
		/* 8218D850h case    3:*/		return 0x8218D854;
		  /* 8218D854h */ case    4:  		/* subf R5, R4, R11 */
		/* 8218D854h case    4:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R4,regs.R11);
		/* 8218D854h case    4:*/		return 0x8218D858;
		  /* 8218D858h */ case    5:  		/* bl -808 */
		/* 8218D858h case    5:*/		regs.LR = 0x8218D85C; return 0x8218D530;
		/* 8218D858h case    5:*/		return 0x8218D85C;
		  /* 8218D85Ch */ case    6:  		/* mr R11, R31 */
		/* 8218D85Ch case    6:*/		regs.R11 = regs.R31;
		/* 8218D85Ch case    6:*/		return 0x8218D860;
		  /* 8218D860h */ case    7:  		/* cmplwi CR6, R31, 256 */
		/* 8218D860h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000100);
		/* 8218D860h case    7:*/		return 0x8218D864;
		  /* 8218D864h */ case    8:  		/* bc 12, CR6_LT, -100 */
		/* 8218D864h case    8:*/		if ( regs.CR[6].lt ) { return 0x8218D800;  }
		/* 8218D864h case    8:*/		return 0x8218D868;
	}
	return 0x8218D868;
} // Block from 8218D844h-8218D868h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218D868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D868);
		  /* 8218D868h */ case    0:  		/* addi R1, R1, 128 */
		/* 8218D868h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8218D868h case    0:*/		return 0x8218D86C;
		  /* 8218D86Ch */ case    1:  		/* b -1033668 */
		/* 8218D86Ch case    1:*/		return 0x820912A8;
		/* 8218D86Ch case    1:*/		return 0x8218D870;
	}
	return 0x8218D870;
} // Block from 8218D868h-8218D870h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218D870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D870);
		  /* 8218D870h */ case    0:  		/* mfspr R12, LR */
		/* 8218D870h case    0:*/		regs.R12 = regs.LR;
		/* 8218D870h case    0:*/		return 0x8218D874;
		  /* 8218D874h */ case    1:  		/* bl -1033752 */
		/* 8218D874h case    1:*/		regs.LR = 0x8218D878; return 0x8209125C;
		/* 8218D874h case    1:*/		return 0x8218D878;
		  /* 8218D878h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8218D878h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8218D878h case    2:*/		return 0x8218D87C;
		  /* 8218D87Ch */ case    3:  		/* lwz R11, <#[R3 + 2484]> */
		/* 8218D87Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000009B4) );
		/* 8218D87Ch case    3:*/		return 0x8218D880;
		  /* 8218D880h */ case    4:  		/* mr R31, R3 */
		/* 8218D880h case    4:*/		regs.R31 = regs.R3;
		/* 8218D880h case    4:*/		return 0x8218D884;
		  /* 8218D884h */ case    5:  		/* mr R30, R4 */
		/* 8218D884h case    5:*/		regs.R30 = regs.R4;
		/* 8218D884h case    5:*/		return 0x8218D888;
		  /* 8218D888h */ case    6:  		/* mr R29, R5 */
		/* 8218D888h case    6:*/		regs.R29 = regs.R5;
		/* 8218D888h case    6:*/		return 0x8218D88C;
		  /* 8218D88Ch */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8218D88Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218D88Ch case    7:*/		return 0x8218D890;
		  /* 8218D890h */ case    8:  		/* bc 4, CR6_EQ, 40 */
		/* 8218D890h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8218D8B8;  }
		/* 8218D890h case    8:*/		return 0x8218D894;
		  /* 8218D894h */ case    9:  		/* li R5, 46 */
		/* 8218D894h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x2E);
		/* 8218D894h case    9:*/		return 0x8218D898;
		  /* 8218D898h */ case   10:  		/* li R4, 8 */
		/* 8218D898h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 8218D898h case   10:*/		return 0x8218D89C;
		  /* 8218D89Ch */ case   11:  		/* bl -134388 */
		/* 8218D89Ch case   11:*/		regs.LR = 0x8218D8A0; return 0x8216CBA8;
		/* 8218D89Ch case   11:*/		return 0x8218D8A0;
		  /* 8218D8A0h */ case   12:  		/* addi R11, R3, 4 */
		/* 8218D8A0h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x4);
		/* 8218D8A0h case   12:*/		return 0x8218D8A4;
		  /* 8218D8A4h */ case   13:  		/* ori R10, R3, 1 */
		/* 8218D8A4h case   13:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R3,0x1);
		/* 8218D8A4h case   13:*/		return 0x8218D8A8;
		  /* 8218D8A8h */ case   14:  		/* stw R3, <#[R31 + 2484]> */
		/* 8218D8A8h case   14:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000009B4) );
		/* 8218D8A8h case   14:*/		return 0x8218D8AC;
		  /* 8218D8ACh */ case   15:  		/* ori R11, R11, 1 */
		/* 8218D8ACh case   15:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218D8ACh case   15:*/		return 0x8218D8B0;
		  /* 8218D8B0h */ case   16:  		/* stw R10, <#[R3 + 4]> */
		/* 8218D8B0h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 8218D8B0h case   16:*/		return 0x8218D8B4;
		  /* 8218D8B4h */ case   17:  		/* stw R11, <#[R3]> */
		/* 8218D8B4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8218D8B4h case   17:*/		return 0x8218D8B8;
	}
	return 0x8218D8B8;
} // Block from 8218D870h-8218D8B8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8218D8B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D8B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D8B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D8B8);
		  /* 8218D8B8h */ case    0:  		/* lwz R3, <#[R31 + 2484]> */
		/* 8218D8B8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000009B4) );
		/* 8218D8B8h case    0:*/		return 0x8218D8BC;
		  /* 8218D8BCh */ case    1:  		/* lwz R11, <#[R3 + 4]> */
		/* 8218D8BCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8218D8BCh case    1:*/		return 0x8218D8C0;
		  /* 8218D8C0h */ case    2:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8218D8C0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8218D8C0h case    2:*/		return 0x8218D8C4;
		  /* 8218D8C4h */ case    3:  		/* bc 4, CR0_EQ, 40 */
		/* 8218D8C4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8218D8EC;  }
		/* 8218D8C4h case    3:*/		return 0x8218D8C8;
		  /* 8218D8C8h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 8218D8C8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8218D8C8h case    4:*/		return 0x8218D8CC;
		  /* 8218D8CCh */ case    5:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8218D8CCh case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8218D8CCh case    5:*/		return 0x8218D8D0;
		  /* 8218D8D0h */ case    6:  		/* addic. R11, R11, -4 */
		/* 8218D8D0h case    6:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8218D8D0h case    6:*/		return 0x8218D8D4;
		  /* 8218D8D4h */ case    7:  		/* bc 12, CR0_EQ, 24 */
		/* 8218D8D4h case    7:*/		if ( regs.CR[0].eq ) { return 0x8218D8EC;  }
		/* 8218D8D4h case    7:*/		return 0x8218D8D8;
		  /* 8218D8D8h */ case    8:  		/* lwz R10, <#[R11 + 8]> */
		/* 8218D8D8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8218D8D8h case    8:*/		return 0x8218D8DC;
		  /* 8218D8DCh */ case    9:  		/* lwz R9, <#[R11 + 12]> */
		/* 8218D8DCh case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 8218D8DCh case    9:*/		return 0x8218D8E0;
		  /* 8218D8E0h */ case   10:  		/* addi R10, R10, 1 */
		/* 8218D8E0h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8218D8E0h case   10:*/		return 0x8218D8E4;
		  /* 8218D8E4h */ case   11:  		/* cmplw CR6, R10, R9 */
		/* 8218D8E4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8218D8E4h case   11:*/		return 0x8218D8E8;
		  /* 8218D8E8h */ case   12:  		/* bc 4, CR6_GT, 16 */
		/* 8218D8E8h case   12:*/		if ( !regs.CR[6].gt ) { return 0x8218D8F8;  }
		/* 8218D8E8h case   12:*/		return 0x8218D8EC;
	}
	return 0x8218D8EC;
} // Block from 8218D8B8h-8218D8ECh (13 instructions)

//////////////////////////////////////////////////////
// Block at 8218D8ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D8EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D8EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D8EC);
		  /* 8218D8ECh */ case    0:  		/* li R4, 1 */
		/* 8218D8ECh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8218D8ECh case    0:*/		return 0x8218D8F0;
		  /* 8218D8F0h */ case    1:  		/* bl -2088 */
		/* 8218D8F0h case    1:*/		regs.LR = 0x8218D8F4; return 0x8218D0C8;
		/* 8218D8F0h case    1:*/		return 0x8218D8F4;
		  /* 8218D8F4h */ case    2:  		/* mr R11, R3 */
		/* 8218D8F4h case    2:*/		regs.R11 = regs.R3;
		/* 8218D8F4h case    2:*/		return 0x8218D8F8;
	}
	return 0x8218D8F8;
} // Block from 8218D8ECh-8218D8F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218D8F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D8F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D8F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D8F8);
		  /* 8218D8F8h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 8218D8F8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8218D8F8h case    0:*/		return 0x8218D8FC;
		  /* 8218D8FCh */ case    1:  		/* addi R9, R10, 4 */
		/* 8218D8FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 8218D8FCh case    1:*/		return 0x8218D900;
		  /* 8218D900h */ case    2:  		/* addi R8, R10, 1 */
		/* 8218D900h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x1);
		/* 8218D900h case    2:*/		return 0x8218D904;
		  /* 8218D904h */ case    3:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 8218D904h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 8218D904h case    3:*/		return 0x8218D908;
	}
	return 0x8218D908;
} // Block from 8218D8F8h-8218D908h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218D908h
// Function '?AllocRegsForUniformVariable@Compiler@D3DXShader@@AAAIPAV?$RegisterSet@V?$FixedSizeBitSet@_K$0BA@@D3DXShader@@$1?PrintConstantRegister@2@YAXPAVCompiler@2@I@Z$0BAA@$03$1?ReportOutOfConstantRegistersError@2@YAX0@Z@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D908);
		  /* 8218D908h */ case    0:  		/* stw R8, <#[R11 + 8]> */
		/* 8218D908h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 8218D908h case    0:*/		return 0x8218D90C;
		  /* 8218D90Ch */ case    1:  		/* stwx R30, <#[R10 + R11]> */
		/* 8218D90Ch case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8218D90Ch case    1:*/		return 0x8218D910;
		  /* 8218D910h */ case    2:  		/* lwz R3, <#[R31 + 2484]> */
		/* 8218D910h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000009B4) );
		/* 8218D910h case    2:*/		return 0x8218D914;
		  /* 8218D914h */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 8218D914h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8218D914h case    3:*/		return 0x8218D918;
		  /* 8218D918h */ case    4:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8218D918h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8218D918h case    4:*/		return 0x8218D91C;
		  /* 8218D91Ch */ case    5:  		/* bc 4, CR0_EQ, 40 */
		/* 8218D91Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x8218D944;  }
		/* 8218D91Ch case    5:*/		return 0x8218D920;
		  /* 8218D920h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 8218D920h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8218D920h case    6:*/		return 0x8218D924;
		  /* 8218D924h */ case    7:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8218D924h case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8218D924h case    7:*/		return 0x8218D928;
		  /* 8218D928h */ case    8:  		/* addic. R11, R11, -4 */
		/* 8218D928h case    8:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8218D928h case    8:*/		return 0x8218D92C;
		  /* 8218D92Ch */ case    9:  		/* bc 12, CR0_EQ, 24 */
		/* 8218D92Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x8218D944;  }
		/* 8218D92Ch case    9:*/		return 0x8218D930;
		  /* 8218D930h */ case   10:  		/* lwz R10, <#[R11 + 8]> */
		/* 8218D930h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8218D930h case   10:*/		return 0x8218D934;
		  /* 8218D934h */ case   11:  		/* lwz R9, <#[R11 + 12]> */
		/* 8218D934h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 8218D934h case   11:*/		return 0x8218D938;
		  /* 8218D938h */ case   12:  		/* addi R10, R10, 1 */
		/* 8218D938h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8218D938h case   12:*/		return 0x8218D93C;
		  /* 8218D93Ch */ case   13:  		/* cmplw CR6, R10, R9 */
		/* 8218D93Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8218D93Ch case   13:*/		return 0x8218D940;
		  /* 8218D940h */ case   14:  		/* bc 4, CR6_GT, 16 */
		/* 8218D940h case   14:*/		if ( !regs.CR[6].gt ) { return 0x8218D950;  }
		/* 8218D940h case   14:*/		return 0x8218D944;
	}
	return 0x8218D944;
} // Block from 8218D908h-8218D944h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8218D944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D944);
		  /* 8218D944h */ case    0:  		/* li R4, 1 */
		/* 8218D944h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8218D944h case    0:*/		return 0x8218D948;
		  /* 8218D948h */ case    1:  		/* bl -2176 */
		/* 8218D948h case    1:*/		regs.LR = 0x8218D94C; return 0x8218D0C8;
		/* 8218D948h case    1:*/		return 0x8218D94C;
		  /* 8218D94Ch */ case    2:  		/* mr R11, R3 */
		/* 8218D94Ch case    2:*/		regs.R11 = regs.R3;
		/* 8218D94Ch case    2:*/		return 0x8218D950;
	}
	return 0x8218D950;
} // Block from 8218D944h-8218D950h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218D950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D950);
		  /* 8218D950h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 8218D950h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8218D950h case    0:*/		return 0x8218D954;
		  /* 8218D954h */ case    1:  		/* addi R9, R10, 4 */
		/* 8218D954h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 8218D954h case    1:*/		return 0x8218D958;
		  /* 8218D958h */ case    2:  		/* addi R8, R10, 1 */
		/* 8218D958h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x1);
		/* 8218D958h case    2:*/		return 0x8218D95C;
		  /* 8218D95Ch */ case    3:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 8218D95Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 8218D95Ch case    3:*/		return 0x8218D960;
		  /* 8218D960h */ case    4:  		/* stw R8, <#[R11 + 8]> */
		/* 8218D960h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 8218D960h case    4:*/		return 0x8218D964;
		  /* 8218D964h */ case    5:  		/* stwx R29, <#[R10 + R11]> */
		/* 8218D964h case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8218D964h case    5:*/		return 0x8218D968;
		  /* 8218D968h */ case    6:  		/* addi R1, R1, 112 */
		/* 8218D968h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8218D968h case    6:*/		return 0x8218D96C;
		  /* 8218D96Ch */ case    7:  		/* b -1033920 */
		/* 8218D96Ch case    7:*/		return 0x820912AC;
		/* 8218D96Ch case    7:*/		return 0x8218D970;
	}
	return 0x8218D970;
} // Block from 8218D950h-8218D970h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218D970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D970);
		  /* 8218D970h */ case    0:  		/* mfspr R12, LR */
		/* 8218D970h case    0:*/		regs.R12 = regs.LR;
		/* 8218D970h case    0:*/		return 0x8218D974;
		  /* 8218D974h */ case    1:  		/* bl -1034068 */
		/* 8218D974h case    1:*/		regs.LR = 0x8218D978; return 0x82091220;
		/* 8218D974h case    1:*/		return 0x8218D978;
		  /* 8218D978h */ case    2:  		/* stwu R1, <#[R1 - 256]> */
		/* 8218D978h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 8218D978h case    2:*/		return 0x8218D97C;
		  /* 8218D97Ch */ case    3:  		/* lwz R11, <#[R3 + 12]> */
		/* 8218D97Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8218D97Ch case    3:*/		return 0x8218D980;
		  /* 8218D980h */ case    4:  		/* mulli R10, R4, 40 */
		/* 8218D980h case    4:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R4,0x28);
		/* 8218D980h case    4:*/		return 0x8218D984;
		  /* 8218D984h */ case    5:  		/* stw R4, <#[R1 + 284]> */
		/* 8218D984h case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000011C) );
		/* 8218D984h case    5:*/		return 0x8218D988;
		  /* 8218D988h */ case    6:  		/* lwzx R9, <#[R10 + R11]> */
		/* 8218D988h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8218D988h case    6:*/		return 0x8218D98C;
		  /* 8218D98Ch */ case    7:  		/* mr R27, R4 */
		/* 8218D98Ch case    7:*/		regs.R27 = regs.R4;
		/* 8218D98Ch case    7:*/		return 0x8218D990;
		  /* 8218D990h */ case    8:  		/* li R5, 0 */
		/* 8218D990h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8218D990h case    8:*/		return 0x8218D994;
		  /* 8218D994h */ case    9:  		/* rlwinm R4, R9, 0, 15, 28 */
		/* 8218D994h case    9:*/		cpu::op::rlwinm<0,0,15,28>(regs,&regs.R4,regs.R9);
		/* 8218D994h case    9:*/		return 0x8218D998;
		  /* 8218D998h */ case   10:  		/* mr R17, R3 */
		/* 8218D998h case   10:*/		regs.R17 = regs.R3;
		/* 8218D998h case   10:*/		return 0x8218D99C;
		  /* 8218D99Ch */ case   11:  		/* add R20, R10, R11 */
		/* 8218D99Ch case   11:*/		cpu::op::add<0>(regs,&regs.R20,regs.R10,regs.R11);
		/* 8218D99Ch case   11:*/		return 0x8218D9A0;
		  /* 8218D9A0h */ case   12:  		/* bl -4984 */
		/* 8218D9A0h case   12:*/		regs.LR = 0x8218D9A4; return 0x8218C628;
		/* 8218D9A0h case   12:*/		return 0x8218D9A4;
		  /* 8218D9A4h */ case   13:  		/* lwz R11, <#[R20 + 16]> */
		/* 8218D9A4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000010) );
		/* 8218D9A4h case   13:*/		return 0x8218D9A8;
		  /* 8218D9A8h */ case   14:  		/* mr R18, R3 */
		/* 8218D9A8h case   14:*/		regs.R18 = regs.R3;
		/* 8218D9A8h case   14:*/		return 0x8218D9AC;
		  /* 8218D9ACh */ case   15:  		/* stw R3, <#[R20 + 28]> */
		/* 8218D9ACh case   15:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R20 + 0x0000001C) );
		/* 8218D9ACh case   15:*/		return 0x8218D9B0;
		  /* 8218D9B0h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 8218D9B0h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218D9B0h case   16:*/		return 0x8218D9B4;
		  /* 8218D9B4h */ case   17:  		/* bc 12, CR6_EQ, 12 */
		/* 8218D9B4h case   17:*/		if ( regs.CR[6].eq ) { return 0x8218D9C0;  }
		/* 8218D9B4h case   17:*/		return 0x8218D9B8;
		  /* 8218D9B8h */ case   18:  		/* lwz R6, <#[R11 + 64]> */
		/* 8218D9B8h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000040) );
		/* 8218D9B8h case   18:*/		return 0x8218D9BC;
		  /* 8218D9BCh */ case   19:  		/* b 8 */
		/* 8218D9BCh case   19:*/		return 0x8218D9C4;
		/* 8218D9BCh case   19:*/		return 0x8218D9C0;
	}
	return 0x8218D9C0;
} // Block from 8218D970h-8218D9C0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8218D9C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D9C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D9C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D9C0);
		  /* 8218D9C0h */ case    0:  		/* li R6, 0 */
		/* 8218D9C0h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8218D9C0h case    0:*/		return 0x8218D9C4;
	}
	return 0x8218D9C4;
} // Block from 8218D9C0h-8218D9C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218D9C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D9C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D9C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D9C4);
		  /* 8218D9C4h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8218D9C4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218D9C4h case    0:*/		return 0x8218D9C8;
		  /* 8218D9C8h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8218D9C8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8218D9D4;  }
		/* 8218D9C8h case    1:*/		return 0x8218D9CC;
		  /* 8218D9CCh */ case    2:  		/* lwz R5, <#[R11 + 60]> */
		/* 8218D9CCh case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x0000003C) );
		/* 8218D9CCh case    2:*/		return 0x8218D9D0;
		  /* 8218D9D0h */ case    3:  		/* b 36 */
		/* 8218D9D0h case    3:*/		return 0x8218D9F4;
		/* 8218D9D0h case    3:*/		return 0x8218D9D4;
	}
	return 0x8218D9D4;
} // Block from 8218D9C4h-8218D9D4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218D9D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D9D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D9D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D9D4);
		  /* 8218D9D4h */ case    0:  		/* lwz R11, <#[R20]> */
		/* 8218D9D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 8218D9D4h case    0:*/		return 0x8218D9D8;
		  /* 8218D9D8h */ case    1:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 8218D9D8h case    1:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 8218D9D8h case    1:*/		return 0x8218D9DC;
		  /* 8218D9DCh */ case    2:  		/* cmplwi CR6, R11, 4 */
		/* 8218D9DCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 8218D9DCh case    2:*/		return 0x8218D9E0;
		  /* 8218D9E0h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 8218D9E0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8218D9F0;  }
		/* 8218D9E0h case    3:*/		return 0x8218D9E4;
		  /* 8218D9E4h */ case    4:  		/* lwz R11, <#[R17 + 28]> */
		/* 8218D9E4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000001C) );
		/* 8218D9E4h case    4:*/		return 0x8218D9E8;
		  /* 8218D9E8h */ case    5:  		/* lwz R5, <#[R11 + 56]> */
		/* 8218D9E8h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000038) );
		/* 8218D9E8h case    5:*/		return 0x8218D9EC;
		  /* 8218D9ECh */ case    6:  		/* b 8 */
		/* 8218D9ECh case    6:*/		return 0x8218D9F4;
		/* 8218D9ECh case    6:*/		return 0x8218D9F0;
	}
	return 0x8218D9F0;
} // Block from 8218D9D4h-8218D9F0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218D9F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D9F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D9F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D9F0);
		  /* 8218D9F0h */ case    0:  		/* li R5, 0 */
		/* 8218D9F0h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8218D9F0h case    0:*/		return 0x8218D9F4;
	}
	return 0x8218D9F4;
} // Block from 8218D9F0h-8218D9F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218D9F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218D9F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218D9F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218D9F4);
		  /* 8218D9F4h */ case    0:  		/* mr R3, R17 */
		/* 8218D9F4h case    0:*/		regs.R3 = regs.R17;
		/* 8218D9F4h case    0:*/		return 0x8218D9F8;
		  /* 8218D9F8h */ case    1:  		/* lwz R4, <#[R20 + 20]> */
		/* 8218D9F8h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R20 + 0x00000014) );
		/* 8218D9F8h case    1:*/		return 0x8218D9FC;
		  /* 8218D9FCh */ case    2:  		/* bl -652 */
		/* 8218D9FCh case    2:*/		regs.LR = 0x8218DA00; return 0x8218D770;
		/* 8218D9FCh case    2:*/		return 0x8218DA00;
		  /* 8218DA00h */ case    3:  		/* mr R22, R3 */
		/* 8218DA00h case    3:*/		regs.R22 = regs.R3;
		/* 8218DA00h case    3:*/		return 0x8218DA04;
		  /* 8218DA04h */ case    4:  		/* li R25, 0 */
		/* 8218DA04h case    4:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 8218DA04h case    4:*/		return 0x8218DA08;
		  /* 8218DA08h */ case    5:  		/* li R16, 0 */
		/* 8218DA08h case    5:*/		cpu::op::li<0>(regs,&regs.R16,0x0);
		/* 8218DA08h case    5:*/		return 0x8218DA0C;
		  /* 8218DA0Ch */ case    6:  		/* li R15, 0 */
		/* 8218DA0Ch case    6:*/		cpu::op::li<0>(regs,&regs.R15,0x0);
		/* 8218DA0Ch case    6:*/		return 0x8218DA10;
		  /* 8218DA10h */ case    7:  		/* li R14, 0 */
		/* 8218DA10h case    7:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 8218DA10h case    7:*/		return 0x8218DA14;
		  /* 8218DA14h */ case    8:  		/* lwz R11, <#[R22 + 4]> */
		/* 8218DA14h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 8218DA14h case    8:*/		return 0x8218DA18;
		  /* 8218DA18h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 8218DA18h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218DA18h case    9:*/		return 0x8218DA1C;
		  /* 8218DA1Ch */ case   10:  		/* bc 4, CR6_EQ, 24 */
		/* 8218DA1Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x8218DA34;  }
		/* 8218DA1Ch case   10:*/		return 0x8218DA20;
		  /* 8218DA20h */ case   11:  		/* mr R3, R22 */
		/* 8218DA20h case   11:*/		regs.R3 = regs.R22;
		/* 8218DA20h case   11:*/		return 0x8218DA24;
		  /* 8218DA24h */ case   12:  		/* bl 432516 */
		/* 8218DA24h case   12:*/		regs.LR = 0x8218DA28; return 0x821F73A8;
		/* 8218DA24h case   12:*/		return 0x8218DA28;
		  /* 8218DA28h */ case   13:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8218DA28h case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8218DA28h case   13:*/		return 0x8218DA2C;
		  /* 8218DA2Ch */ case   14:  		/* li R11, 1 */
		/* 8218DA2Ch case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218DA2Ch case   14:*/		return 0x8218DA30;
		  /* 8218DA30h */ case   15:  		/* bc 12, CR0_EQ, 8 */
		/* 8218DA30h case   15:*/		if ( regs.CR[0].eq ) { return 0x8218DA38;  }
		/* 8218DA30h case   15:*/		return 0x8218DA34;
	}
	return 0x8218DA34;
} // Block from 8218D9F4h-8218DA34h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8218DA34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DA34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DA34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DA34);
		  /* 8218DA34h */ case    0:  		/* li R11, 0 */
		/* 8218DA34h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218DA34h case    0:*/		return 0x8218DA38;
	}
	return 0x8218DA38;
} // Block from 8218DA34h-8218DA38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218DA38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DA38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DA38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DA38);
		  /* 8218DA38h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8218DA38h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8218DA38h case    0:*/		return 0x8218DA3C;
		  /* 8218DA3Ch */ case    1:  		/* bc 4, CR0_EQ, 1120 */
		/* 8218DA3Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x8218DE9C;  }
		/* 8218DA3Ch case    1:*/		return 0x8218DA40;
		  /* 8218DA40h */ case    2:  		/* rlwinm R11, R25, 3, 0, 28 */
		/* 8218DA40h case    2:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R25);
		/* 8218DA40h case    2:*/		return 0x8218DA44;
		  /* 8218DA44h */ case    3:  		/* lbz R9, <#[R22 + 36]> */
		/* 8218DA44h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R22 + 0x00000024) );
		/* 8218DA44h case    3:*/		return 0x8218DA48;
		  /* 8218DA48h */ case    4:  		/* mr R3, R22 */
		/* 8218DA48h case    4:*/		regs.R3 = regs.R22;
		/* 8218DA48h case    4:*/		return 0x8218DA4C;
		  /* 8218DA4Ch */ case    5:  		/* add R11, R11, R18 */
		/* 8218DA4Ch case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R18);
		/* 8218DA4Ch case    5:*/		return 0x8218DA50;
		  /* 8218DA50h */ case    6:  		/* addi R10, R11, 4 */
		/* 8218DA50h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8218DA50h case    6:*/		return 0x8218DA54;
		  /* 8218DA54h */ case    7:  		/* lwz R10, <#[R11 + 4]> */
		/* 8218DA54h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8218DA54h case    7:*/		return 0x8218DA58;
		  /* 8218DA58h */ case    8:  		/* rlwimi R9, R10, 0, 0, 30 */
		/* 8218DA58h case    8:*/		cpu::op::rlwimi<0,0,0,30>(regs,&regs.R9,regs.R10);
		/* 8218DA58h case    8:*/		return 0x8218DA5C;
		  /* 8218DA5Ch */ case    9:  		/* stw R9, <#[R11 + 4]> */
		/* 8218DA5Ch case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8218DA5Ch case    9:*/		return 0x8218DA60;
		  /* 8218DA60h */ case   10:  		/* bl 432544 */
		/* 8218DA60h case   10:*/		regs.LR = 0x8218DA64; return 0x821F7400;
		/* 8218DA60h case   10:*/		return 0x8218DA64;
		  /* 8218DA64h */ case   11:  		/* li R11, 0 */
		/* 8218DA64h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218DA64h case   11:*/		return 0x8218DA68;
		  /* 8218DA68h */ case   12:  		/* mr R19, R3 */
		/* 8218DA68h case   12:*/		regs.R19 = regs.R3;
		/* 8218DA68h case   12:*/		return 0x8218DA6C;
		  /* 8218DA6Ch */ case   13:  		/* cmpwi CR6, R3, 30 */
		/* 8218DA6Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x0000001E);
		/* 8218DA6Ch case   13:*/		return 0x8218DA70;
		  /* 8218DA70h */ case   14:  		/* stb R11, <#[R1 + 80]> */
		/* 8218DA70h case   14:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8218DA70h case   14:*/		return 0x8218DA74;
		  /* 8218DA74h */ case   15:  		/* bc 12, CR6_GT, 60 */
		/* 8218DA74h case   15:*/		if ( regs.CR[6].gt ) { return 0x8218DAB0;  }
		/* 8218DA74h case   15:*/		return 0x8218DA78;
		  /* 8218DA78h */ case   16:  		/* cmpwi CR6, R3, 29 */
		/* 8218DA78h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x0000001D);
		/* 8218DA78h case   16:*/		return 0x8218DA7C;
		  /* 8218DA7Ch */ case   17:  		/* bc 4, CR6_LT, 28 */
		/* 8218DA7Ch case   17:*/		if ( !regs.CR[6].lt ) { return 0x8218DA98;  }
		/* 8218DA7Ch case   17:*/		return 0x8218DA80;
		  /* 8218DA80h */ case   18:  		/* cmpwi CR6, R3, 24 */
		/* 8218DA80h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000018);
		/* 8218DA80h case   18:*/		return 0x8218DA84;
		  /* 8218DA84h */ case   19:  		/* bc 12, CR6_LT, 64 */
		/* 8218DA84h case   19:*/		if ( regs.CR[6].lt ) { return 0x8218DAC4;  }
		/* 8218DA84h case   19:*/		return 0x8218DA88;
		  /* 8218DA88h */ case   20:  		/* cmpwi CR6, R3, 25 */
		/* 8218DA88h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000019);
		/* 8218DA88h case   20:*/		return 0x8218DA8C;
		  /* 8218DA8Ch */ case   21:  		/* bc 4, CR6_GT, 12 */
		/* 8218DA8Ch case   21:*/		if ( !regs.CR[6].gt ) { return 0x8218DA98;  }
		/* 8218DA8Ch case   21:*/		return 0x8218DA90;
		  /* 8218DA90h */ case   22:  		/* cmpwi CR6, R3, 27 */
		/* 8218DA90h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x0000001B);
		/* 8218DA90h case   22:*/		return 0x8218DA94;
		  /* 8218DA94h */ case   23:  		/* bc 4, CR6_EQ, 48 */
		/* 8218DA94h case   23:*/		if ( !regs.CR[6].eq ) { return 0x8218DAC4;  }
		/* 8218DA94h case   23:*/		return 0x8218DA98;
	}
	return 0x8218DA98;
} // Block from 8218DA38h-8218DA98h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8218DA98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DA98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DA98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DA98);
		  /* 8218DA98h */ case    0:  		/* lwz R11, <#[R20 + 4]> */
		/* 8218DA98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000004) );
		/* 8218DA98h case    0:*/		return 0x8218DA9C;
		  /* 8218DA9Ch */ case    1:  		/* rlwinm R11, R11, 0, 25, 27 */
		/* 8218DA9Ch case    1:*/		cpu::op::rlwinm<0,0,25,27>(regs,&regs.R11,regs.R11);
		/* 8218DA9Ch case    1:*/		return 0x8218DAA0;
		  /* 8218DAA0h */ case    2:  		/* cmplwi CR6, R11, 112 */
		/* 8218DAA0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000070);
		/* 8218DAA0h case    2:*/		return 0x8218DAA4;
		  /* 8218DAA4h */ case    3:  		/* bc 4, CR6_EQ, 940 */
		/* 8218DAA4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8218DE50;  }
		/* 8218DAA4h case    3:*/		return 0x8218DAA8;
		  /* 8218DAA8h */ case    4:  		/* li R16, 256 */
		/* 8218DAA8h case    4:*/		cpu::op::li<0>(regs,&regs.R16,0x100);
		/* 8218DAA8h case    4:*/		return 0x8218DAAC;
		  /* 8218DAACh */ case    5:  		/* b 68 */
		/* 8218DAACh case    5:*/		return 0x8218DAF0;
		/* 8218DAACh case    5:*/		return 0x8218DAB0;
	}
	return 0x8218DAB0;
} // Block from 8218DA98h-8218DAB0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218DAB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DAB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DAB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DAB0);
		  /* 8218DAB0h */ case    0:  		/* cmpwi CR6, R19, 33 */
		/* 8218DAB0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000021);
		/* 8218DAB0h case    0:*/		return 0x8218DAB4;
		  /* 8218DAB4h */ case    1:  		/* bc 12, CR6_EQ, 44 */
		/* 8218DAB4h case    1:*/		if ( regs.CR[6].eq ) { return 0x8218DAE0;  }
		/* 8218DAB4h case    1:*/		return 0x8218DAB8;
		  /* 8218DAB8h */ case    2:  		/* bc 4, CR6_GT, 12 */
		/* 8218DAB8h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8218DAC4;  }
		/* 8218DAB8h case    2:*/		return 0x8218DABC;
		  /* 8218DABCh */ case    3:  		/* cmpwi CR6, R19, 37 */
		/* 8218DABCh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000025);
		/* 8218DABCh case    3:*/		return 0x8218DAC0;
		  /* 8218DAC0h */ case    4:  		/* bc 4, CR6_GT, 32 */
		/* 8218DAC0h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8218DAE0;  }
		/* 8218DAC0h case    4:*/		return 0x8218DAC4;
	}
	return 0x8218DAC4;
} // Block from 8218DAB0h-8218DAC4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218DAC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DAC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DAC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DAC4);
		  /* 8218DAC4h */ case    0:  		/* lwz R11, <#[R20 + 4]> */
		/* 8218DAC4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000004) );
		/* 8218DAC4h case    0:*/		return 0x8218DAC8;
		  /* 8218DAC8h */ case    1:  		/* rlwinm R11, R11, 0, 25, 27 */
		/* 8218DAC8h case    1:*/		cpu::op::rlwinm<0,0,25,27>(regs,&regs.R11,regs.R11);
		/* 8218DAC8h case    1:*/		return 0x8218DACC;
		  /* 8218DACCh */ case    2:  		/* cmplwi CR6, R11, 48 */
		/* 8218DACCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 8218DACCh case    2:*/		return 0x8218DAD0;
		  /* 8218DAD0h */ case    3:  		/* bc 4, CR6_EQ, 32 */
		/* 8218DAD0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8218DAF0;  }
		/* 8218DAD0h case    3:*/		return 0x8218DAD4;
		  /* 8218DAD4h */ case    4:  		/* li R4, 3533 */
		/* 8218DAD4h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0xDCD);
		/* 8218DAD4h case    4:*/		return 0x8218DAD8;
		  /* 8218DAD8h */ case    5:  		/* mr R3, R17 */
		/* 8218DAD8h case    5:*/		regs.R3 = regs.R17;
		/* 8218DAD8h case    5:*/		return 0x8218DADC;
		  /* 8218DADCh */ case    6:  		/* bl -244852 */
		/* 8218DADCh case    6:*/		regs.LR = 0x8218DAE0; return 0x82151E68;
		/* 8218DADCh case    6:*/		return 0x8218DAE0;
	}
	return 0x8218DAE0;
} // Block from 8218DAC4h-8218DAE0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218DAE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DAE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DAE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DAE0);
		  /* 8218DAE0h */ case    0:  		/* lwz R11, <#[R20 + 4]> */
		/* 8218DAE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000004) );
		/* 8218DAE0h case    0:*/		return 0x8218DAE4;
		  /* 8218DAE4h */ case    1:  		/* rlwinm R11, R11, 0, 25, 27 */
		/* 8218DAE4h case    1:*/		cpu::op::rlwinm<0,0,25,27>(regs,&regs.R11,regs.R11);
		/* 8218DAE4h case    1:*/		return 0x8218DAE8;
		  /* 8218DAE8h */ case    2:  		/* cmplwi CR6, R11, 48 */
		/* 8218DAE8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 8218DAE8h case    2:*/		return 0x8218DAEC;
		  /* 8218DAECh */ case    3:  		/* bc 4, CR6_EQ, 880 */
		/* 8218DAECh case    3:*/		if ( !regs.CR[6].eq ) { return 0x8218DE5C;  }
		/* 8218DAECh case    3:*/		return 0x8218DAF0;
	}
	return 0x8218DAF0;
} // Block from 8218DAE0h-8218DAF0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218DAF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DAF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DAF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DAF0);
		  /* 8218DAF0h */ case    0:  		/* lwz R4, <#[R22 + 12]> */
		/* 8218DAF0h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R22 + 0x0000000C) );
		/* 8218DAF0h case    0:*/		return 0x8218DAF4;
		  /* 8218DAF4h */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 8218DAF4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8218DAF4h case    1:*/		return 0x8218DAF8;
		  /* 8218DAF8h */ case    2:  		/* bc 12, CR6_EQ, 260 */
		/* 8218DAF8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8218DBFC;  }
		/* 8218DAF8h case    2:*/		return 0x8218DAFC;
		  /* 8218DAFCh */ case    3:  		/* rlwinm. R11, R15, 0, 24, 31 */
		/* 8218DAFCh case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R15);
		/* 8218DAFCh case    3:*/		return 0x8218DB00;
	}
	return 0x8218DB00;
} // Block from 8218DAF0h-8218DB00h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218DB00h
// Function '?Find@?$ArrayList@PAX$1?AllocInContext@CompilerHeap@D3DXShader@@SAPAXPAXK@Z$1?FreeInContext@23@SAX00K@Z@D3DXShader@@QAAIPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DB00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DB00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DB00);
		  /* 8218DB00h */ case    0:  		/* bc 4, CR0_EQ, 256 */
		/* 8218DB00h case    0:*/		if ( !regs.CR[0].eq ) { return 0x8218DC00;  }
		/* 8218DB00h case    0:*/		return 0x8218DB04;
		  /* 8218DB04h */ case    1:  		/* mr R3, R17 */
		/* 8218DB04h case    1:*/		regs.R3 = regs.R17;
		/* 8218DB04h case    1:*/		return 0x8218DB08;
		  /* 8218DB08h */ case    2:  		/* li R28, 0 */
		/* 8218DB08h case    2:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8218DB08h case    2:*/		return 0x8218DB0C;
		  /* 8218DB0Ch */ case    3:  		/* bl 385588 */
		/* 8218DB0Ch case    3:*/		regs.LR = 0x8218DB10; return 0x821EBD40;
		/* 8218DB0Ch case    3:*/		return 0x8218DB10;
		  /* 8218DB10h */ case    4:  		/* or. R29, R3, R3 */
		/* 8218DB10h case    4:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 8218DB10h case    4:*/		return 0x8218DB14;
		  /* 8218DB14h */ case    5:  		/* bc 12, CR0_EQ, 236 */
		/* 8218DB14h case    5:*/		if ( regs.CR[0].eq ) { return 0x8218DC00;  }
		/* 8218DB14h case    5:*/		return 0x8218DB18;
		  /* 8218DB18h */ case    6:  		/* lwz R31, <#[R29 + 8]> */
		/* 8218DB18h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000008) );
		/* 8218DB18h case    6:*/		return 0x8218DB1C;
		  /* 8218DB1Ch */ case    7:  		/* lwz R11, <#[R31 + 4]> */
		/* 8218DB1Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8218DB1Ch case    7:*/		return 0x8218DB20;
		  /* 8218DB20h */ case    8:  		/* cmpwi CR6, R11, 18 */
		/* 8218DB20h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000012);
		/* 8218DB20h case    8:*/		return 0x8218DB24;
		  /* 8218DB24h */ case    9:  		/* bc 4, CR6_EQ, 156 */
		/* 8218DB24h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8218DBC0;  }
		/* 8218DB24h case    9:*/		return 0x8218DB28;
		  /* 8218DB28h */ case   10:  		/* lwz R11, <#[R31 + 20]> */
		/* 8218DB28h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8218DB28h case   10:*/		return 0x8218DB2C;
		  /* 8218DB2Ch */ case   11:  		/* mr R3, R17 */
		/* 8218DB2Ch case   11:*/		regs.R3 = regs.R17;
		/* 8218DB2Ch case   11:*/		return 0x8218DB30;
		  /* 8218DB30h */ case   12:  		/* lwz R11, <#[R11 + 4]> */
		/* 8218DB30h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8218DB30h case   12:*/		return 0x8218DB34;
		  /* 8218DB34h */ case   13:  		/* cmpwi CR6, R11, 3 */
		/* 8218DB34h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8218DB34h case   13:*/		return 0x8218DB38;
		  /* 8218DB38h */ case   14:  		/* bc 4, CR6_EQ, 816 */
		/* 8218DB38h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8218DE68;  }
		/* 8218DB38h case   14:*/		return 0x8218DB3C;
		  /* 8218DB3Ch */ case   15:  		/* addi R5, R1, 92 */
		/* 8218DB3Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x5C);
		/* 8218DB3Ch case   15:*/		return 0x8218DB40;
		  /* 8218DB40h */ case   16:  		/* lwz R4, <#[R31 + 16]> */
		/* 8218DB40h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 8218DB40h case   16:*/		return 0x8218DB44;
		  /* 8218DB44h */ case   17:  		/* bl 385612 */
		/* 8218DB44h case   17:*/		regs.LR = 0x8218DB48; return 0x821EBD90;
		/* 8218DB44h case   17:*/		return 0x8218DB48;
		  /* 8218DB48h */ case   18:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8218DB48h case   18:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8218DB48h case   18:*/		return 0x8218DB4C;
		  /* 8218DB4Ch */ case   19:  		/* bc 12, CR0_EQ, 116 */
		/* 8218DB4Ch case   19:*/		if ( regs.CR[0].eq ) { return 0x8218DBC0;  }
		/* 8218DB4Ch case   19:*/		return 0x8218DB50;
		  /* 8218DB50h */ case   20:  		/* cmplwi CR6, R28, 0 */
		/* 8218DB50h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8218DB50h case   20:*/		return 0x8218DB54;
		  /* 8218DB54h */ case   21:  		/* mr R3, R17 */
		/* 8218DB54h case   21:*/		regs.R3 = regs.R17;
		/* 8218DB54h case   21:*/		return 0x8218DB58;
		  /* 8218DB58h */ case   22:  		/* bc 4, CR6_EQ, 792 */
		/* 8218DB58h case   22:*/		if ( !regs.CR[6].eq ) { return 0x8218DE70;  }
		/* 8218DB58h case   22:*/		return 0x8218DB5C;
		  /* 8218DB5Ch */ case   23:  		/* lwz R30, <#[R31 + 20]> */
		/* 8218DB5Ch case   23:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000014) );
		/* 8218DB5Ch case   23:*/		return 0x8218DB60;
		  /* 8218DB60h */ case   24:  		/* addi R8, R1, 80 */
		/* 8218DB60h case   24:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 8218DB60h case   24:*/		return 0x8218DB64;
		  /* 8218DB64h */ case   25:  		/* lwz R11, <#[R20 + 4]> */
		/* 8218DB64h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000004) );
		/* 8218DB64h case   25:*/		return 0x8218DB68;
		  /* 8218DB68h */ case   26:  		/* addi R7, R1, 84 */
		/* 8218DB68h case   26:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x54);
		/* 8218DB68h case   26:*/		return 0x8218DB6C;
		  /* 8218DB6Ch */ case   27:  		/* addi R6, R1, 88 */
		/* 8218DB6Ch case   27:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x58);
		/* 8218DB6Ch case   27:*/		return 0x8218DB70;
		  /* 8218DB70h */ case   28:  		/* rlwinm R5, R11, 28, 29, 31 */
		/* 8218DB70h case   28:*/		cpu::op::rlwinm<0,28,29,31>(regs,&regs.R5,regs.R11);
		/* 8218DB70h case   28:*/		return 0x8218DB74;
		  /* 8218DB74h */ case   29:  		/* mr R4, R30 */
		/* 8218DB74h case   29:*/		regs.R4 = regs.R30;
		/* 8218DB74h case   29:*/		return 0x8218DB78;
		  /* 8218DB78h */ case   30:  		/* mr R28, R31 */
		/* 8218DB78h case   30:*/		regs.R28 = regs.R31;
		/* 8218DB78h case   30:*/		return 0x8218DB7C;
		  /* 8218DB7Ch */ case   31:  		/* bl -9772 */
		/* 8218DB7Ch case   31:*/		regs.LR = 0x8218DB80; return 0x8218B550;
		/* 8218DB7Ch case   31:*/		return 0x8218DB80;
	}
	return 0x8218DB80;
} // Block from 8218DB00h-8218DB80h (32 instructions)

//////////////////////////////////////////////////////
// Block at 8218DB80h
// Function '?AllocContiguousRegisters@?$RegisterSet@V?$FixedSizeBitSet@I$00@D3DXShader@@$1?PrintSamplerRegister@2@YAXPAVCompiler@2@I@Z$0CA@$00$1?ReportOutOfSamplerRegistersError@2@YAX0@Z@D3DXShader@@QAAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DB80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DB80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DB80);
		  /* 8218DB80h */ case    0:  		/* lwz R10, <#[R20]> */
		/* 8218DB80h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x00000000) );
		/* 8218DB80h case    0:*/		return 0x8218DB84;
		  /* 8218DB84h */ case    1:  		/* lwz R9, <#[R1 + 84]> */
		/* 8218DB84h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 8218DB84h case    1:*/		return 0x8218DB88;
		  /* 8218DB88h */ case    2:  		/* lis R11, 4080 */
		/* 8218DB88h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFF0);
		/* 8218DB88h case    2:*/		return 0x8218DB8C;
		  /* 8218DB8Ch */ case    3:  		/* lwz R8, <#[R20 + 4]> */
		/* 8218DB8Ch case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R20 + 0x00000004) );
		/* 8218DB8Ch case    3:*/		return 0x8218DB90;
		  /* 8218DB90h */ case    4:  		/* rlwimi R10, R9, 20, 3, 11 */
		/* 8218DB90h case    4:*/		cpu::op::rlwimi<0,20,3,11>(regs,&regs.R10,regs.R9);
		/* 8218DB90h case    4:*/		return 0x8218DB94;
		  /* 8218DB94h */ case    5:  		/* stw R10, <#[R20]> */
		/* 8218DB94h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R20 + 0x00000000) );
		/* 8218DB94h case    5:*/		return 0x8218DB98;
		  /* 8218DB98h */ case    6:  		/* lwz R9, <#[R1 + 88]> */
		/* 8218DB98h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 8218DB98h case    6:*/		return 0x8218DB9C;
		  /* 8218DB9Ch */ case    7:  		/* rlwimi R8, R9, 4, 25, 27 */
		/* 8218DB9Ch case    7:*/		cpu::op::rlwimi<0,4,25,27>(regs,&regs.R8,regs.R9);
		/* 8218DB9Ch case    7:*/		return 0x8218DBA0;
		  /* 8218DBA0h */ case    8:  		/* rlwinm R9, R10, 0, 3, 11 */
		/* 8218DBA0h case    8:*/		cpu::op::rlwinm<0,0,3,11>(regs,&regs.R9,regs.R10);
		/* 8218DBA0h case    8:*/		return 0x8218DBA4;
		  /* 8218DBA4h */ case    9:  		/* stw R8, <#[R20 + 4]> */
		/* 8218DBA4h case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R20 + 0x00000004) );
		/* 8218DBA4h case    9:*/		return 0x8218DBA8;
		  /* 8218DBA8h */ case   10:  		/* cmplw CR6, R9, R11 */
		/* 8218DBA8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8218DBA8h case   10:*/		return 0x8218DBAC;
		  /* 8218DBACh */ case   11:  		/* bc 4, CR6_GT, 20 */
		/* 8218DBACh case   11:*/		if ( !regs.CR[6].gt ) { return 0x8218DBC0;  }
		/* 8218DBACh case   11:*/		return 0x8218DBB0;
		  /* 8218DBB0h */ case   12:  		/* mr R5, R30 */
		/* 8218DBB0h case   12:*/		regs.R5 = regs.R30;
		/* 8218DBB0h case   12:*/		return 0x8218DBB4;
		  /* 8218DBB4h */ case   13:  		/* mr R4, R27 */
		/* 8218DBB4h case   13:*/		regs.R4 = regs.R27;
		/* 8218DBB4h case   13:*/		return 0x8218DBB8;
		  /* 8218DBB8h */ case   14:  		/* mr R3, R17 */
		/* 8218DBB8h case   14:*/		regs.R3 = regs.R17;
		/* 8218DBB8h case   14:*/		return 0x8218DBBC;
		  /* 8218DBBCh */ case   15:  		/* bl -844 */
		/* 8218DBBCh case   15:*/		regs.LR = 0x8218DBC0; return 0x8218D870;
		/* 8218DBBCh case   15:*/		return 0x8218DBC0;
	}
	return 0x8218DBC0;
} // Block from 8218DB80h-8218DBC0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8218DBC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DBC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DBC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DBC0);
		  /* 8218DBC0h */ case    0:  		/* mr R3, R17 */
		/* 8218DBC0h case    0:*/		regs.R3 = regs.R17;
		/* 8218DBC0h case    0:*/		return 0x8218DBC4;
		  /* 8218DBC4h */ case    1:  		/* lwz R4, <#[R29 + 12]> */
		/* 8218DBC4h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x0000000C) );
		/* 8218DBC4h case    1:*/		return 0x8218DBC8;
		  /* 8218DBC8h */ case    2:  		/* bl 385440 */
		/* 8218DBC8h case    2:*/		regs.LR = 0x8218DBCC; return 0x821EBD68;
		/* 8218DBC8h case    2:*/		return 0x8218DBCC;
		  /* 8218DBCCh */ case    3:  		/* or. R29, R3, R3 */
		/* 8218DBCCh case    3:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 8218DBCCh case    3:*/		return 0x8218DBD0;
		  /* 8218DBD0h */ case    4:  		/* bc 4, CR0_EQ, -184 */
		/* 8218DBD0h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8218DB18;  }
		/* 8218DBD0h case    4:*/		return 0x8218DBD4;
		  /* 8218DBD4h */ case    5:  		/* cmplwi CR6, R28, 0 */
		/* 8218DBD4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8218DBD4h case    5:*/		return 0x8218DBD8;
		  /* 8218DBD8h */ case    6:  		/* bc 12, CR6_EQ, 40 */
		/* 8218DBD8h case    6:*/		if ( regs.CR[6].eq ) { return 0x8218DC00;  }
		/* 8218DBD8h case    6:*/		return 0x8218DBDC;
		  /* 8218DBDCh */ case    7:  		/* lwz R11, <#[R20]> */
		/* 8218DBDCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 8218DBDCh case    7:*/		return 0x8218DBE0;
		  /* 8218DBE0h */ case    8:  		/* rlwinm R10, R11, 0, 29, 31 */
		/* 8218DBE0h case    8:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R11);
		/* 8218DBE0h case    8:*/		return 0x8218DBE4;
		  /* 8218DBE4h */ case    9:  		/* cmplwi CR6, R10, 1 */
		/* 8218DBE4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 8218DBE4h case    9:*/		return 0x8218DBE8;
		  /* 8218DBE8h */ case   10:  		/* bc 4, CR6_EQ, 656 */
		/* 8218DBE8h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8218DE78;  }
		/* 8218DBE8h case   10:*/		return 0x8218DBEC;
		  /* 8218DBECh */ case   11:  		/* oris R11, R11, 8 */
		/* 8218DBECh case   11:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8218DBECh case   11:*/		return 0x8218DBF0;
		  /* 8218DBF0h */ case   12:  		/* li R15, 1 */
		/* 8218DBF0h case   12:*/		cpu::op::li<0>(regs,&regs.R15,0x1);
		/* 8218DBF0h case   12:*/		return 0x8218DBF4;
		  /* 8218DBF4h */ case   13:  		/* stw R11, <#[R20]> */
		/* 8218DBF4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 8218DBF4h case   13:*/		return 0x8218DBF8;
		  /* 8218DBF8h */ case   14:  		/* b 8 */
		/* 8218DBF8h case   14:*/		return 0x8218DC00;
		/* 8218DBF8h case   14:*/		return 0x8218DBFC;
	}
	return 0x8218DBFC;
} // Block from 8218DBC0h-8218DBFCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 8218DBFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DBFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DBFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DBFC);
		  /* 8218DBFCh */ case    0:  		/* li R14, 1 */
		/* 8218DBFCh case    0:*/		cpu::op::li<0>(regs,&regs.R14,0x1);
		/* 8218DBFCh case    0:*/		return 0x8218DC00;
	}
	return 0x8218DC00;
} // Block from 8218DBFCh-8218DC00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218DC00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DC00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DC00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DC00);
		  /* 8218DC00h */ case    0:  		/* lwz R11, <#[R22]> */
		/* 8218DC00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 8218DC00h case    0:*/		return 0x8218DC04;
		  /* 8218DC04h */ case    1:  		/* lwz R10, <#[R22 + 4]> */
		/* 8218DC04h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000004) );
		/* 8218DC04h case    1:*/		return 0x8218DC08;
	}
	return 0x8218DC08;
} // Block from 8218DC00h-8218DC08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218DC08h
// Function '?AllocContiguousRegisters@?$RegisterSet@V?$FixedSizeBitSet@_K$03@D3DXShader@@$1?PrintConditionRegister@2@YAXPAVCompiler@2@I@Z$0BAA@$00$1?ReportOutOfBooleanRegistersError@2@YAX0@Z@D3DXShader@@QAAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DC08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DC08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DC08);
		  /* 8218DC08h */ case    0:  		/* addi R31, R10, 1 */
		/* 8218DC08h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R10,0x1);
		/* 8218DC08h case    0:*/		return 0x8218DC0C;
		  /* 8218DC0Ch */ case    1:  		/* lwz R23, <#[R11 + 28]> */
		/* 8218DC0Ch case    1:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R11 + 0x0000001C) );
		/* 8218DC0Ch case    1:*/		return 0x8218DC10;
		  /* 8218DC10h */ case    2:  		/* lwz R28, <#[R11 + 32]> */
		/* 8218DC10h case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000020) );
		/* 8218DC10h case    2:*/		return 0x8218DC14;
		  /* 8218DC14h */ case    3:  		/* cmplwi CR6, R23, 1 */
		/* 8218DC14h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000001);
		/* 8218DC14h case    3:*/		return 0x8218DC18;
		  /* 8218DC18h */ case    4:  		/* bc 4, CR6_GT, 12 */
		/* 8218DC18h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8218DC24;  }
		/* 8218DC18h case    4:*/		return 0x8218DC1C;
		  /* 8218DC1Ch */ case    5:  		/* cmplwi CR6, R28, 4 */
		/* 8218DC1Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000004);
		/* 8218DC1Ch case    5:*/		return 0x8218DC20;
		  /* 8218DC20h */ case    6:  		/* bc 12, CR6_GT, 612 */
		/* 8218DC20h case    6:*/		if ( regs.CR[6].gt ) { return 0x8218DE84;  }
		/* 8218DC20h case    6:*/		return 0x8218DC24;
	}
	return 0x8218DC24;
} // Block from 8218DC08h-8218DC24h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218DC24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DC24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DC24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DC24);
		  /* 8218DC24h */ case    0:  		/* lwz R9, <#[R20]> */
		/* 8218DC24h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R20 + 0x00000000) );
		/* 8218DC24h case    0:*/		return 0x8218DC28;
		  /* 8218DC28h */ case    1:  		/* li R10, 0 */
		/* 8218DC28h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8218DC28h case    1:*/		return 0x8218DC2C;
		  /* 8218DC2Ch */ case    2:  		/* rlwinm R9, R9, 0, 29, 31 */
		/* 8218DC2Ch case    2:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R9,regs.R9);
		/* 8218DC2Ch case    2:*/		return 0x8218DC30;
		  /* 8218DC30h */ case    3:  		/* cmplwi CR6, R9, 2 */
		/* 8218DC30h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000002);
		/* 8218DC30h case    3:*/		return 0x8218DC34;
		  /* 8218DC34h */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 8218DC34h case    4:*/		if ( regs.CR[6].eq ) { return 0x8218DC5C;  }
		/* 8218DC34h case    4:*/		return 0x8218DC38;
		  /* 8218DC38h */ case    5:  		/* cmplwi CR6, R23, 1 */
		/* 8218DC38h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000001);
		/* 8218DC38h case    5:*/		return 0x8218DC3C;
		  /* 8218DC3Ch */ case    6:  		/* bc 4, CR6_GT, 32 */
		/* 8218DC3Ch case    6:*/		if ( !regs.CR[6].gt ) { return 0x8218DC5C;  }
		/* 8218DC3Ch case    6:*/		return 0x8218DC40;
		  /* 8218DC40h */ case    7:  		/* lwz R11, <#[R11 + 36]> */
		/* 8218DC40h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 8218DC40h case    7:*/		return 0x8218DC44;
		  /* 8218DC44h */ case    8:  		/* nor R11, R11, R11 */
		/* 8218DC44h case    8:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8218DC44h case    8:*/		return 0x8218DC48;
		  /* 8218DC48h */ case    9:  		/* rlwinm. R10, R11, 22, 31, 31 */
		/* 8218DC48h case    9:*/		cpu::op::rlwinm<1,22,31,31>(regs,&regs.R10,regs.R11);
		/* 8218DC48h case    9:*/		return 0x8218DC4C;
		  /* 8218DC4Ch */ case   10:  		/* bc 12, CR0_EQ, 16 */
		/* 8218DC4Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x8218DC5C;  }
		/* 8218DC4Ch case   10:*/		return 0x8218DC50;
		  /* 8218DC50h */ case   11:  		/* mr R11, R23 */
		/* 8218DC50h case   11:*/		regs.R11 = regs.R23;
		/* 8218DC50h case   11:*/		return 0x8218DC54;
		  /* 8218DC54h */ case   12:  		/* mr R23, R28 */
		/* 8218DC54h case   12:*/		regs.R23 = regs.R28;
		/* 8218DC54h case   12:*/		return 0x8218DC58;
		  /* 8218DC58h */ case   13:  		/* mr R28, R11 */
		/* 8218DC58h case   13:*/		regs.R28 = regs.R11;
		/* 8218DC58h case   13:*/		return 0x8218DC5C;
	}
	return 0x8218DC5C;
} // Block from 8218DC24h-8218DC5Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8218DC5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DC5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DC5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DC5C);
		  /* 8218DC5Ch */ case    0:  		/* cmplwi CR6, R28, 4 */
		/* 8218DC5Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000004);
		/* 8218DC5Ch case    0:*/		return 0x8218DC60;
	}
	return 0x8218DC60;
} // Block from 8218DC5Ch-8218DC60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218DC60h
// Function '?AllocContiguousRegisters@?$RegisterSet@V?$FixedSizeBitSet@I$00@D3DXShader@@$1?PrintIntegerRegister@2@YAXPAVCompiler@2@I@Z$0CA@$00$1?ReportOutOfIntegerRegistersError@2@YAX0@Z@D3DXShader@@QAAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DC60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DC60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DC60);
		  /* 8218DC60h */ case    0:  		/* bc 4, CR6_GT, 16 */
		/* 8218DC60h case    0:*/		if ( !regs.CR[6].gt ) { return 0x8218DC70;  }
		/* 8218DC60h case    0:*/		return 0x8218DC64;
		  /* 8218DC64h */ case    1:  		/* addi R11, R28, 3 */
		/* 8218DC64h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0x3);
		/* 8218DC64h case    1:*/		return 0x8218DC68;
		  /* 8218DC68h */ case    2:  		/* li R28, 4 */
		/* 8218DC68h case    2:*/		cpu::op::li<0>(regs,&regs.R28,0x4);
		/* 8218DC68h case    2:*/		return 0x8218DC6C;
		  /* 8218DC6Ch */ case    3:  		/* rlwinm R23, R11, 30, 2, 31 */
		/* 8218DC6Ch case    3:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R23,regs.R11);
		/* 8218DC6Ch case    3:*/		return 0x8218DC70;
	}
	return 0x8218DC70;
} // Block from 8218DC60h-8218DC70h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218DC70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DC70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DC70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DC70);
		  /* 8218DC70h */ case    0:  		/* lwz R11, <#[R20 + 4]> */
		/* 8218DC70h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000004) );
		/* 8218DC70h case    0:*/		return 0x8218DC74;
		  /* 8218DC74h */ case    1:  		/* rlwinm R11, R11, 28, 29, 31 */
		/* 8218DC74h case    1:*/		cpu::op::rlwinm<0,28,29,31>(regs,&regs.R11,regs.R11);
		/* 8218DC74h case    1:*/		return 0x8218DC78;
		  /* 8218DC78h */ case    2:  		/* cmplwi CR6, R11, 3 */
		/* 8218DC78h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8218DC78h case    2:*/		return 0x8218DC7C;
		  /* 8218DC7Ch */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 8218DC7Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8218DC98;  }
		/* 8218DC7Ch case    3:*/		return 0x8218DC80;
		  /* 8218DC80h */ case    4:  		/* rlwinm. R9, R10, 0, 24, 31 */
		/* 8218DC80h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R10);
		/* 8218DC80h case    4:*/		return 0x8218DC84;
		  /* 8218DC84h */ case    5:  		/* bc 4, CR0_EQ, 524 */
		/* 8218DC84h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8218DE90;  }
		/* 8218DC84h case    5:*/		return 0x8218DC88;
		  /* 8218DC88h */ case    6:  		/* cmplwi CR6, R23, 1 */
		/* 8218DC88h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000001);
		/* 8218DC88h case    6:*/		return 0x8218DC8C;
		  /* 8218DC8Ch */ case    7:  		/* bc 12, CR6_GT, 516 */
		/* 8218DC8Ch case    7:*/		if ( regs.CR[6].gt ) { return 0x8218DE90;  }
		/* 8218DC8Ch case    7:*/		return 0x8218DC90;
		  /* 8218DC90h */ case    8:  		/* cmplwi CR6, R28, 1 */
		/* 8218DC90h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000001);
		/* 8218DC90h case    8:*/		return 0x8218DC94;
		  /* 8218DC94h */ case    9:  		/* bc 12, CR6_GT, 508 */
		/* 8218DC94h case    9:*/		if ( regs.CR[6].gt ) { return 0x8218DE90;  }
		/* 8218DC94h case    9:*/		return 0x8218DC98;
	}
	return 0x8218DC98;
} // Block from 8218DC70h-8218DC98h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8218DC98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DC98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DC98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DC98);
		  /* 8218DC98h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8218DC98h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218DC98h case    0:*/		return 0x8218DC9C;
		  /* 8218DC9Ch */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 8218DC9Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8218DCA8;  }
		/* 8218DC9Ch case    1:*/		return 0x8218DCA0;
		  /* 8218DCA0h */ case    2:  		/* mr R23, R31 */
		/* 8218DCA0h case    2:*/		regs.R23 = regs.R31;
		/* 8218DCA0h case    2:*/		return 0x8218DCA4;
		  /* 8218DCA4h */ case    3:  		/* li R28, 1 */
		/* 8218DCA4h case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 8218DCA4h case    3:*/		return 0x8218DCA8;
	}
	return 0x8218DCA8;
} // Block from 8218DC98h-8218DCA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218DCA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DCA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DCA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DCA8);
		  /* 8218DCA8h */ case    0:  		/* mr R5, R16 */
		/* 8218DCA8h case    0:*/		regs.R5 = regs.R16;
		/* 8218DCA8h case    0:*/		return 0x8218DCAC;
		  /* 8218DCACh */ case    1:  		/* lwz R24, <#[R22 + 8]> */
		/* 8218DCACh case    1:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R22 + 0x00000008) );
		/* 8218DCACh case    1:*/		return 0x8218DCB0;
		  /* 8218DCB0h */ case    2:  		/* rlwinm. R11, R10, 0, 24, 31 */
		/* 8218DCB0h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R10);
		/* 8218DCB0h case    2:*/		return 0x8218DCB4;
		  /* 8218DCB4h */ case    3:  		/* add R16, R23, R16 */
		/* 8218DCB4h case    3:*/		cpu::op::add<0>(regs,&regs.R16,regs.R23,regs.R16);
		/* 8218DCB4h case    3:*/		return 0x8218DCB8;
	}
	return 0x8218DCB8;
} // Block from 8218DCA8h-8218DCB8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218DCB8h
// Function '?FindAssociatedErrorData@Compiler@D3DXShader@@QAAPAXPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DCB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DCB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DCB8);
		  /* 8218DCB8h */ case    0:  		/* mr R21, R25 */
		/* 8218DCB8h case    0:*/		regs.R21 = regs.R25;
		/* 8218DCB8h case    0:*/		return 0x8218DCBC;
		  /* 8218DCBCh */ case    1:  		/* bc 4, CR0_EQ, 140 */
		/* 8218DCBCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x8218DD48;  }
		/* 8218DCBCh case    1:*/		return 0x8218DCC0;
		  /* 8218DCC0h */ case    2:  		/* cmplw CR6, R31, R28 */
		/* 8218DCC0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R28);
		/* 8218DCC0h case    2:*/		return 0x8218DCC4;
		  /* 8218DCC4h */ case    3:  		/* mr R30, R31 */
		/* 8218DCC4h case    3:*/		regs.R30 = regs.R31;
		/* 8218DCC4h case    3:*/		return 0x8218DCC8;
		  /* 8218DCC8h */ case    4:  		/* bc 12, CR6_LT, 8 */
		/* 8218DCC8h case    4:*/		if ( regs.CR[6].lt ) { return 0x8218DCD0;  }
		/* 8218DCC8h case    4:*/		return 0x8218DCCC;
		  /* 8218DCCCh */ case    5:  		/* mr R30, R28 */
		/* 8218DCCCh case    5:*/		regs.R30 = regs.R28;
		/* 8218DCCCh case    5:*/		return 0x8218DCD0;
	}
	return 0x8218DCD0;
} // Block from 8218DCB8h-8218DCD0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218DCD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DCD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DCD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DCD0);
		  /* 8218DCD0h */ case    0:  		/* rlwinm R11, R25, 3, 0, 28 */
		/* 8218DCD0h case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R25);
		/* 8218DCD0h case    0:*/		return 0x8218DCD4;
		  /* 8218DCD4h */ case    1:  		/* subf R31, R30, R31 */
		/* 8218DCD4h case    1:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R30,regs.R31);
		/* 8218DCD4h case    1:*/		return 0x8218DCD8;
		  /* 8218DCD8h */ case    2:  		/* li R6, 1 */
		/* 8218DCD8h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8218DCD8h case    2:*/		return 0x8218DCDC;
		  /* 8218DCDCh */ case    3:  		/* add R29, R11, R18 */
		/* 8218DCDCh case    3:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R18);
		/* 8218DCDCh case    3:*/		return 0x8218DCE0;
		  /* 8218DCE0h */ case    4:  		/* mr R7, R19 */
		/* 8218DCE0h case    4:*/		regs.R7 = regs.R19;
		/* 8218DCE0h case    4:*/		return 0x8218DCE4;
		  /* 8218DCE4h */ case    5:  		/* lbz R8, <#[R1 + 80]> */
		/* 8218DCE4h case    5:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 8218DCE4h case    5:*/		return 0x8218DCE8;
		  /* 8218DCE8h */ case    6:  		/* mr R4, R25 */
		/* 8218DCE8h case    6:*/		regs.R4 = regs.R25;
		/* 8218DCE8h case    6:*/		return 0x8218DCEC;
		  /* 8218DCECh */ case    7:  		/* mr R3, R18 */
		/* 8218DCECh case    7:*/		regs.R3 = regs.R18;
		/* 8218DCECh case    7:*/		return 0x8218DCF0;
		  /* 8218DCF0h */ case    8:  		/* bl -10304 */
		/* 8218DCF0h case    8:*/		regs.LR = 0x8218DCF4; return 0x8218B4B0;
		/* 8218DCF0h case    8:*/		return 0x8218DCF4;
		  /* 8218DCF4h */ case    9:  		/* cmplwi CR6, R24, 0 */
		/* 8218DCF4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 8218DCF4h case    9:*/		return 0x8218DCF8;
		  /* 8218DCF8h */ case   10:  		/* bc 12, CR6_EQ, 32 */
		/* 8218DCF8h case   10:*/		if ( regs.CR[6].eq ) { return 0x8218DD18;  }
		/* 8218DCF8h case   10:*/		return 0x8218DCFC;
		  /* 8218DCFCh */ case   11:  		/* lwz R11, <#[R22 + 20]> */
		/* 8218DCFCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000014) );
		/* 8218DCFCh case   11:*/		return 0x8218DD00;
		  /* 8218DD00h */ case   12:  		/* cmplwi CR6, R11, 16 */
		/* 8218DD00h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 8218DD00h case   12:*/		return 0x8218DD04;
		  /* 8218DD04h */ case   13:  		/* bc 4, CR6_LT, 20 */
		/* 8218DD04h case   13:*/		if ( !regs.CR[6].lt ) { return 0x8218DD18;  }
		/* 8218DD04h case   13:*/		return 0x8218DD08;
		  /* 8218DD08h */ case   14:  		/* lwz R10, <#[R29]> */
		/* 8218DD08h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 8218DD08h case   14:*/		return 0x8218DD0C;
		  /* 8218DD0Ch */ case   15:  		/* rlwimi R10, R11, 27, 1, 4 */
		/* 8218DD0Ch case   15:*/		cpu::op::rlwimi<0,27,1,4>(regs,&regs.R10,regs.R11);
		/* 8218DD0Ch case   15:*/		return 0x8218DD10;
		  /* 8218DD10h */ case   16:  		/* oris R11, R10, 1024 */
		/* 8218DD10h case   16:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R10,0x400);
		/* 8218DD10h case   16:*/		return 0x8218DD14;
		  /* 8218DD14h */ case   17:  		/* stw R11, <#[R29]> */
		/* 8218DD14h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8218DD14h case   17:*/		return 0x8218DD18;
	}
	return 0x8218DD18;
} // Block from 8218DCD0h-8218DD18h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8218DD18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DD18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DD18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DD18);
		  /* 8218DD18h */ case    0:  		/* addic. R30, R30, -1 */
		/* 8218DD18h case    0:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 8218DD18h case    0:*/		return 0x8218DD1C;
		  /* 8218DD1Ch */ case    1:  		/* addi R25, R25, 1 */
		/* 8218DD1Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 8218DD1Ch case    1:*/		return 0x8218DD20;
		  /* 8218DD20h */ case    2:  		/* addi R29, R29, 8 */
		/* 8218DD20h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x8);
		/* 8218DD20h case    2:*/		return 0x8218DD24;
		  /* 8218DD24h */ case    3:  		/* rlwinm R6, R6, 1, 0, 30 */
		/* 8218DD24h case    3:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R6,regs.R6);
		/* 8218DD24h case    3:*/		return 0x8218DD28;
		  /* 8218DD28h */ case    4:  		/* bc 4, CR0_EQ, -72 */
		/* 8218DD28h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8218DCE0;  }
		/* 8218DD28h case    4:*/		return 0x8218DD2C;
		  /* 8218DD2Ch */ case    5:  		/* lwz R11, <#[R22 + 20]> */
		/* 8218DD2Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000014) );
		/* 8218DD2Ch case    5:*/		return 0x8218DD30;
		  /* 8218DD30h */ case    6:  		/* addi R5, R5, 1 */
		/* 8218DD30h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 8218DD30h case    6:*/		return 0x8218DD34;
		  /* 8218DD34h */ case    7:  		/* cmplwi CR6, R31, 0 */
		/* 8218DD34h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8218DD34h case    7:*/		return 0x8218DD38;
		  /* 8218DD38h */ case    8:  		/* addi R11, R11, 1 */
		/* 8218DD38h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218DD38h case    8:*/		return 0x8218DD3C;
		  /* 8218DD3Ch */ case    9:  		/* stw R11, <#[R22 + 20]> */
		/* 8218DD3Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R22 + 0x00000014) );
		/* 8218DD3Ch case    9:*/		return 0x8218DD40;
		  /* 8218DD40h */ case   10:  		/* bc 4, CR6_EQ, -128 */
		/* 8218DD40h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8218DCC0;  }
		/* 8218DD40h case   10:*/		return 0x8218DD44;
		  /* 8218DD44h */ case   11:  		/* b 184 */
		/* 8218DD44h case   11:*/		return 0x8218DDFC;
		/* 8218DD44h case   11:*/		return 0x8218DD48;
	}
	return 0x8218DD48;
} // Block from 8218DD18h-8218DD48h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8218DD48h
// Function '?GetVariableRegisterBounds@Compiler@D3DXShader@@AAAXIPAI0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DD48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DD48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DD48);
		  /* 8218DD48h */ case    0:  		/* lwz R26, <#[R22 + 20]> */
		/* 8218DD48h case    0:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R22 + 0x00000014) );
		/* 8218DD48h case    0:*/		return 0x8218DD4C;
		  /* 8218DD4Ch */ case    1:  		/* li R6, 1 */
		/* 8218DD4Ch case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8218DD4Ch case    1:*/		return 0x8218DD50;
		  /* 8218DD50h */ case    2:  		/* mr R27, R5 */
		/* 8218DD50h case    2:*/		regs.R27 = regs.R5;
		/* 8218DD50h case    2:*/		return 0x8218DD54;
		  /* 8218DD54h */ case    3:  		/* cmplw CR6, R31, R23 */
		/* 8218DD54h case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R23);
		/* 8218DD54h case    3:*/		return 0x8218DD58;
		  /* 8218DD58h */ case    4:  		/* mr R30, R31 */
		/* 8218DD58h case    4:*/		regs.R30 = regs.R31;
		/* 8218DD58h case    4:*/		return 0x8218DD5C;
		  /* 8218DD5Ch */ case    5:  		/* bc 12, CR6_LT, 8 */
		/* 8218DD5Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x8218DD64;  }
		/* 8218DD5Ch case    5:*/		return 0x8218DD60;
		  /* 8218DD60h */ case    6:  		/* mr R30, R23 */
		/* 8218DD60h case    6:*/		regs.R30 = regs.R23;
		/* 8218DD60h case    6:*/		return 0x8218DD64;
	}
	return 0x8218DD64;
} // Block from 8218DD48h-8218DD64h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218DD64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DD64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DD64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DD64);
		  /* 8218DD64h */ case    0:  		/* rlwinm R11, R25, 3, 0, 28 */
		/* 8218DD64h case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R25);
		/* 8218DD64h case    0:*/		return 0x8218DD68;
		  /* 8218DD68h */ case    1:  		/* subf R31, R30, R31 */
		/* 8218DD68h case    1:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R30,regs.R31);
		/* 8218DD68h case    1:*/		return 0x8218DD6C;
		  /* 8218DD6Ch */ case    2:  		/* add R29, R11, R18 */
		/* 8218DD6Ch case    2:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R18);
		/* 8218DD6Ch case    2:*/		return 0x8218DD70;
		  /* 8218DD70h */ case    3:  		/* subf R28, R25, R5 */
		/* 8218DD70h case    3:*/		cpu::op::subf<0>(regs,&regs.R28,regs.R25,regs.R5);
		/* 8218DD70h case    3:*/		return 0x8218DD74;
		  /* 8218DD74h */ case    4:  		/* mr R7, R19 */
		/* 8218DD74h case    4:*/		regs.R7 = regs.R19;
		/* 8218DD74h case    4:*/		return 0x8218DD78;
		  /* 8218DD78h */ case    5:  		/* lbz R8, <#[R1 + 80]> */
		/* 8218DD78h case    5:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 8218DD78h case    5:*/		return 0x8218DD7C;
		  /* 8218DD7Ch */ case    6:  		/* add R5, R28, R25 */
		/* 8218DD7Ch case    6:*/		cpu::op::add<0>(regs,&regs.R5,regs.R28,regs.R25);
		/* 8218DD7Ch case    6:*/		return 0x8218DD80;
		  /* 8218DD80h */ case    7:  		/* mr R4, R25 */
		/* 8218DD80h case    7:*/		regs.R4 = regs.R25;
		/* 8218DD80h case    7:*/		return 0x8218DD84;
		  /* 8218DD84h */ case    8:  		/* mr R3, R18 */
		/* 8218DD84h case    8:*/		regs.R3 = regs.R18;
		/* 8218DD84h case    8:*/		return 0x8218DD88;
		  /* 8218DD88h */ case    9:  		/* bl -10456 */
		/* 8218DD88h case    9:*/		regs.LR = 0x8218DD8C; return 0x8218B4B0;
		/* 8218DD88h case    9:*/		return 0x8218DD8C;
		  /* 8218DD8Ch */ case   10:  		/* cmplwi CR6, R24, 0 */
		/* 8218DD8Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 8218DD8Ch case   10:*/		return 0x8218DD90;
		  /* 8218DD90h */ case   11:  		/* bc 12, CR6_EQ, 44 */
		/* 8218DD90h case   11:*/		if ( regs.CR[6].eq ) { return 0x8218DDBC;  }
		/* 8218DD90h case   11:*/		return 0x8218DD94;
		  /* 8218DD94h */ case   12:  		/* lwz R11, <#[R22 + 20]> */
		/* 8218DD94h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000014) );
		/* 8218DD94h case   12:*/		return 0x8218DD98;
		  /* 8218DD98h */ case   13:  		/* cmplwi CR6, R11, 16 */
		/* 8218DD98h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 8218DD98h case   13:*/		return 0x8218DD9C;
		  /* 8218DD9Ch */ case   14:  		/* bc 4, CR6_LT, 20 */
		/* 8218DD9Ch case   14:*/		if ( !regs.CR[6].lt ) { return 0x8218DDB0;  }
		/* 8218DD9Ch case   14:*/		return 0x8218DDA0;
		  /* 8218DDA0h */ case   15:  		/* lwz R10, <#[R29]> */
		/* 8218DDA0h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 8218DDA0h case   15:*/		return 0x8218DDA4;
		  /* 8218DDA4h */ case   16:  		/* rlwimi R10, R11, 27, 1, 4 */
		/* 8218DDA4h case   16:*/		cpu::op::rlwimi<0,27,1,4>(regs,&regs.R10,regs.R11);
		/* 8218DDA4h case   16:*/		return 0x8218DDA8;
		  /* 8218DDA8h */ case   17:  		/* oris R11, R10, 1024 */
		/* 8218DDA8h case   17:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R10,0x400);
		/* 8218DDA8h case   17:*/		return 0x8218DDAC;
		  /* 8218DDACh */ case   18:  		/* stw R11, <#[R29]> */
		/* 8218DDACh case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8218DDACh case   18:*/		return 0x8218DDB0;
	}
	return 0x8218DDB0;
} // Block from 8218DD64h-8218DDB0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8218DDB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DDB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DDB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DDB0);
		  /* 8218DDB0h */ case    0:  		/* lwz R11, <#[R22 + 20]> */
		/* 8218DDB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000014) );
		/* 8218DDB0h case    0:*/		return 0x8218DDB4;
		  /* 8218DDB4h */ case    1:  		/* addi R11, R11, 1 */
		/* 8218DDB4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218DDB4h case    1:*/		return 0x8218DDB8;
		  /* 8218DDB8h */ case    2:  		/* stw R11, <#[R22 + 20]> */
		/* 8218DDB8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R22 + 0x00000014) );
		/* 8218DDB8h case    2:*/		return 0x8218DDBC;
	}
	return 0x8218DDBC;
} // Block from 8218DDB0h-8218DDBCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218DDBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DDBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DDBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DDBC);
		  /* 8218DDBCh */ case    0:  		/* addic. R30, R30, -1 */
		/* 8218DDBCh case    0:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 8218DDBCh case    0:*/		return 0x8218DDC0;
		  /* 8218DDC0h */ case    1:  		/* addi R25, R25, 1 */
		/* 8218DDC0h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 8218DDC0h case    1:*/		return 0x8218DDC4;
		  /* 8218DDC4h */ case    2:  		/* addi R29, R29, 8 */
		/* 8218DDC4h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x8);
		/* 8218DDC4h case    2:*/		return 0x8218DDC8;
		  /* 8218DDC8h */ case    3:  		/* bc 4, CR0_EQ, -84 */
		/* 8218DDC8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8218DD74;  }
		/* 8218DDC8h case    3:*/		return 0x8218DDCC;
		  /* 8218DDCCh */ case    4:  		/* rlwinm R6, R6, 1, 0, 30 */
		/* 8218DDCCh case    4:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R6,regs.R6);
		/* 8218DDCCh case    4:*/		return 0x8218DDD0;
		  /* 8218DDD0h */ case    5:  		/* stw R26, <#[R22 + 20]> */
		/* 8218DDD0h case    5:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R22 + 0x00000014) );
		/* 8218DDD0h case    5:*/		return 0x8218DDD4;
		  /* 8218DDD4h */ case    6:  		/* mr R5, R27 */
		/* 8218DDD4h case    6:*/		regs.R5 = regs.R27;
		/* 8218DDD4h case    6:*/		return 0x8218DDD8;
		  /* 8218DDD8h */ case    7:  		/* cmplwi CR6, R31, 0 */
		/* 8218DDD8h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8218DDD8h case    7:*/		return 0x8218DDDC;
		  /* 8218DDDCh */ case    8:  		/* bc 4, CR6_EQ, -136 */
		/* 8218DDDCh case    8:*/		if ( !regs.CR[6].eq ) { return 0x8218DD54;  }
		/* 8218DDDCh case    8:*/		return 0x8218DDE0;
		  /* 8218DDE0h */ case    9:  		/* lwz R11, <#[R20]> */
		/* 8218DDE0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 8218DDE0h case    9:*/		return 0x8218DDE4;
		  /* 8218DDE4h */ case   10:  		/* lwz R27, <#[R1 + 284]> */
		/* 8218DDE4h case   10:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x0000011C) );
		/* 8218DDE4h case   10:*/		return 0x8218DDE8;
		  /* 8218DDE8h */ case   11:  		/* oris R11, R11, 16384 */
		/* 8218DDE8h case   11:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 8218DDE8h case   11:*/		return 0x8218DDEC;
		  /* 8218DDECh */ case   12:  		/* stw R11, <#[R20]> */
		/* 8218DDECh case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 8218DDECh case   12:*/		return 0x8218DDF0;
		  /* 8218DDF0h */ case   13:  		/* lwz R11, <#[R22 + 20]> */
		/* 8218DDF0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000014) );
		/* 8218DDF0h case   13:*/		return 0x8218DDF4;
		  /* 8218DDF4h */ case   14:  		/* add R11, R11, R23 */
		/* 8218DDF4h case   14:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R23);
		/* 8218DDF4h case   14:*/		return 0x8218DDF8;
		  /* 8218DDF8h */ case   15:  		/* stw R11, <#[R22 + 20]> */
		/* 8218DDF8h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R22 + 0x00000014) );
		/* 8218DDF8h case   15:*/		return 0x8218DDFC;
	}
	return 0x8218DDFC;
} // Block from 8218DDBCh-8218DDFCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 8218DDFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DDFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DDFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DDFC);
		  /* 8218DDFCh */ case    0:  		/* cmplwi CR6, R23, 1 */
		/* 8218DDFCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000001);
		/* 8218DDFCh case    0:*/		return 0x8218DE00;
		  /* 8218DE00h */ case    1:  		/* bc 4, CR6_GT, 68 */
		/* 8218DE00h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8218DE44;  }
		/* 8218DE00h case    1:*/		return 0x8218DE04;
		  /* 8218DE04h */ case    2:  		/* cmplw CR6, R21, R25 */
		/* 8218DE04h case    2:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R25);
		/* 8218DE04h case    2:*/		return 0x8218DE08;
		  /* 8218DE08h */ case    3:  		/* bc 4, CR6_LT, 60 */
		/* 8218DE08h case    3:*/		if ( !regs.CR[6].lt ) { return 0x8218DE44;  }
		/* 8218DE08h case    3:*/		return 0x8218DE0C;
		  /* 8218DE0Ch */ case    4:  		/* rlwinm R11, R21, 3, 0, 28 */
		/* 8218DE0Ch case    4:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R21);
		/* 8218DE0Ch case    4:*/		return 0x8218DE10;
		  /* 8218DE10h */ case    5:  		/* subf R10, R21, R25 */
		/* 8218DE10h case    5:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R21,regs.R25);
		/* 8218DE10h case    5:*/		return 0x8218DE14;
		  /* 8218DE14h */ case    6:  		/* add R11, R11, R18 */
		/* 8218DE14h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R18);
		/* 8218DE14h case    6:*/		return 0x8218DE18;
		  /* 8218DE18h */ case    7:  		/* addi R11, R11, 4 */
		/* 8218DE18h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8218DE18h case    7:*/		return 0x8218DE1C;
		  /* 8218DE1Ch */ case    8:  		/* mtspr CTR, R10 */
		/* 8218DE1Ch case    8:*/		regs.CTR = regs.R10;
		/* 8218DE1Ch case    8:*/		return 0x8218DE20;
		  /* 8218DE20h */ case    9:  		/* lwz R10, <#[R11 - 4]> */
		/* 8218DE20h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 8218DE20h case    9:*/		return 0x8218DE24;
		  /* 8218DE24h */ case   10:  		/* rlwinm R10, R10, 0, 28, 31 */
		/* 8218DE24h case   10:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R10,regs.R10);
		/* 8218DE24h case   10:*/		return 0x8218DE28;
		  /* 8218DE28h */ case   11:  		/* cmplwi CR6, R10, 1 */
		/* 8218DE28h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 8218DE28h case   11:*/		return 0x8218DE2C;
		  /* 8218DE2Ch */ case   12:  		/* bc 4, CR6_EQ, 16 */
		/* 8218DE2Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x8218DE3C;  }
		/* 8218DE2Ch case   12:*/		return 0x8218DE30;
		  /* 8218DE30h */ case   13:  		/* lwz R10, <#[R11]> */
		/* 8218DE30h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218DE30h case   13:*/		return 0x8218DE34;
		  /* 8218DE34h */ case   14:  		/* ori R10, R10, 1 */
		/* 8218DE34h case   14:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8218DE34h case   14:*/		return 0x8218DE38;
		  /* 8218DE38h */ case   15:  		/* stw R10, <#[R11]> */
		/* 8218DE38h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218DE38h case   15:*/		return 0x8218DE3C;
	}
	return 0x8218DE3C;
} // Block from 8218DDFCh-8218DE3Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8218DE3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DE3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DE3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DE3C);
		  /* 8218DE3Ch */ case    0:  		/* addi R11, R11, 8 */
		/* 8218DE3Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8218DE3Ch case    0:*/		return 0x8218DE40;
		  /* 8218DE40h */ case    1:  		/* bc 16, CR0_LT, -32 */
		/* 8218DE40h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8218DE20;  }
		/* 8218DE40h case    1:*/		return 0x8218DE44;
	}
	return 0x8218DE44;
} // Block from 8218DE3Ch-8218DE44h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218DE44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DE44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DE44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DE44);
		  /* 8218DE44h */ case    0:  		/* li R11, 0 */
		/* 8218DE44h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218DE44h case    0:*/		return 0x8218DE48;
		  /* 8218DE48h */ case    1:  		/* stw R11, <#[R22 + 4]> */
		/* 8218DE48h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 8218DE48h case    1:*/		return 0x8218DE4C;
		  /* 8218DE4Ch */ case    2:  		/* b -1080 */
		/* 8218DE4Ch case    2:*/		return 0x8218DA14;
		/* 8218DE4Ch case    2:*/		return 0x8218DE50;
	}
	return 0x8218DE50;
} // Block from 8218DE44h-8218DE50h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218DE50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DE50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DE50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DE50);
		  /* 8218DE50h */ case    0:  		/* li R4, 4801 */
		/* 8218DE50h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 8218DE50h case    0:*/		return 0x8218DE54;
		  /* 8218DE54h */ case    1:  		/* mr R3, R17 */
		/* 8218DE54h case    1:*/		regs.R3 = regs.R17;
		/* 8218DE54h case    1:*/		return 0x8218DE58;
		  /* 8218DE58h */ case    2:  		/* bl -245744 */
		/* 8218DE58h case    2:*/		regs.LR = 0x8218DE5C; return 0x82151E68;
		/* 8218DE58h case    2:*/		return 0x8218DE5C;
	}
	return 0x8218DE5C;
} // Block from 8218DE50h-8218DE5Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218DE5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DE5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DE5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DE5C);
		  /* 8218DE5Ch */ case    0:  		/* li R4, 3533 */
		/* 8218DE5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xDCD);
		/* 8218DE5Ch case    0:*/		return 0x8218DE60;
		  /* 8218DE60h */ case    1:  		/* mr R3, R17 */
		/* 8218DE60h case    1:*/		regs.R3 = regs.R17;
		/* 8218DE60h case    1:*/		return 0x8218DE64;
		  /* 8218DE64h */ case    2:  		/* bl -245756 */
		/* 8218DE64h case    2:*/		regs.LR = 0x8218DE68; return 0x82151E68;
		/* 8218DE64h case    2:*/		return 0x8218DE68;
	}
	return 0x8218DE68;
} // Block from 8218DE5Ch-8218DE68h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218DE68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DE68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DE68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DE68);
		  /* 8218DE68h */ case    0:  		/* li R4, 4801 */
		/* 8218DE68h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 8218DE68h case    0:*/		return 0x8218DE6C;
		  /* 8218DE6Ch */ case    1:  		/* bl -245764 */
		/* 8218DE6Ch case    1:*/		regs.LR = 0x8218DE70; return 0x82151E68;
		/* 8218DE6Ch case    1:*/		return 0x8218DE70;
	}
	return 0x8218DE70;
} // Block from 8218DE68h-8218DE70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218DE70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DE70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DE70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DE70);
		  /* 8218DE70h */ case    0:  		/* li R4, 3650 */
		/* 8218DE70h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xE42);
		/* 8218DE70h case    0:*/		return 0x8218DE74;
		  /* 8218DE74h */ case    1:  		/* bl -245772 */
		/* 8218DE74h case    1:*/		regs.LR = 0x8218DE78; return 0x82151E68;
		/* 8218DE74h case    1:*/		return 0x8218DE78;
	}
	return 0x8218DE78;
} // Block from 8218DE70h-8218DE78h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218DE78h
// Function '?ReportInvalidRegisterSemanticError@Compiler@D3DXShader@@AAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DE78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DE78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DE78);
		  /* 8218DE78h */ case    0:  		/* li R4, 4801 */
		/* 8218DE78h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 8218DE78h case    0:*/		return 0x8218DE7C;
		  /* 8218DE7Ch */ case    1:  		/* mr R3, R17 */
		/* 8218DE7Ch case    1:*/		regs.R3 = regs.R17;
		/* 8218DE7Ch case    1:*/		return 0x8218DE80;
		  /* 8218DE80h */ case    2:  		/* bl -245784 */
		/* 8218DE80h case    2:*/		regs.LR = 0x8218DE84; return 0x82151E68;
		/* 8218DE80h case    2:*/		return 0x8218DE84;
	}
	return 0x8218DE84;
} // Block from 8218DE78h-8218DE84h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218DE84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DE84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DE84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DE84);
		  /* 8218DE84h */ case    0:  		/* li R4, 4801 */
		/* 8218DE84h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 8218DE84h case    0:*/		return 0x8218DE88;
		  /* 8218DE88h */ case    1:  		/* mr R3, R17 */
		/* 8218DE88h case    1:*/		regs.R3 = regs.R17;
		/* 8218DE88h case    1:*/		return 0x8218DE8C;
		  /* 8218DE8Ch */ case    2:  		/* bl -245796 */
		/* 8218DE8Ch case    2:*/		regs.LR = 0x8218DE90; return 0x82151E68;
		/* 8218DE8Ch case    2:*/		return 0x8218DE90;
	}
	return 0x8218DE90;
} // Block from 8218DE84h-8218DE90h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218DE90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DE90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DE90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DE90);
		  /* 8218DE90h */ case    0:  		/* li R4, 4801 */
		/* 8218DE90h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 8218DE90h case    0:*/		return 0x8218DE94;
		  /* 8218DE94h */ case    1:  		/* mr R3, R17 */
		/* 8218DE94h case    1:*/		regs.R3 = regs.R17;
		/* 8218DE94h case    1:*/		return 0x8218DE98;
		  /* 8218DE98h */ case    2:  		/* bl -245808 */
		/* 8218DE98h case    2:*/		regs.LR = 0x8218DE9C; return 0x82151E68;
		/* 8218DE98h case    2:*/		return 0x8218DE9C;
	}
	return 0x8218DE9C;
} // Block from 8218DE90h-8218DE9Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218DE9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DE9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DE9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DE9C);
		  /* 8218DE9Ch */ case    0:  		/* lwz R11, <#[R20]> */
		/* 8218DE9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 8218DE9Ch case    0:*/		return 0x8218DEA0;
		  /* 8218DEA0h */ case    1:  		/* rlwinm R11, R11, 29, 18, 31 */
		/* 8218DEA0h case    1:*/		cpu::op::rlwinm<0,29,18,31>(regs,&regs.R11,regs.R11);
		/* 8218DEA0h case    1:*/		return 0x8218DEA4;
		  /* 8218DEA4h */ case    2:  		/* cmplw CR6, R25, R11 */
		/* 8218DEA4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 8218DEA4h case    2:*/		return 0x8218DEA8;
		  /* 8218DEA8h */ case    3:  		/* bc 4, CR6_EQ, 164 */
		/* 8218DEA8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8218DF4C;  }
		/* 8218DEA8h case    3:*/		return 0x8218DEAC;
		  /* 8218DEACh */ case    4:  		/* rlwinm. R11, R14, 0, 24, 31 */
		/* 8218DEACh case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R14);
		/* 8218DEACh case    4:*/		return 0x8218DEB0;
		  /* 8218DEB0h */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 8218DEB0h case    5:*/		if ( regs.CR[0].eq ) { return 0x8218DEBC;  }
		/* 8218DEB0h case    5:*/		return 0x8218DEB4;
		  /* 8218DEB4h */ case    6:  		/* rlwinm. R11, R15, 0, 24, 31 */
		/* 8218DEB4h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R15);
		/* 8218DEB4h case    6:*/		return 0x8218DEB8;
		  /* 8218DEB8h */ case    7:  		/* bc 4, CR0_EQ, 148 */
		/* 8218DEB8h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8218DF4C;  }
		/* 8218DEB8h case    7:*/		return 0x8218DEBC;
	}
	return 0x8218DEBC;
} // Block from 8218DE9Ch-8218DEBCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218DEBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DEBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DEBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DEBC);
		  /* 8218DEBCh */ case    0:  		/* lwz R10, <#[R17 + 1008]> */
		/* 8218DEBCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x000003F0) );
		/* 8218DEBCh case    0:*/		return 0x8218DEC0;
		  /* 8218DEC0h */ case    1:  		/* addi R11, R17, 972 */
		/* 8218DEC0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R17,0x3CC);
		/* 8218DEC0h case    1:*/		return 0x8218DEC4;
		  /* 8218DEC4h */ case    2:  		/* cmplwi CR6, R16, 256 */
		/* 8218DEC4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000100);
		/* 8218DEC4h case    2:*/		return 0x8218DEC8;
		  /* 8218DEC8h */ case    3:  		/* mr R11, R16 */
		/* 8218DEC8h case    3:*/		regs.R11 = regs.R16;
		/* 8218DEC8h case    3:*/		return 0x8218DECC;
		  /* 8218DECCh */ case    4:  		/* stw R10, <#[R22]> */
		/* 8218DECCh case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R22 + 0x00000000) );
		/* 8218DECCh case    4:*/		return 0x8218DED0;
		  /* 8218DED0h */ case    5:  		/* stw R22, <#[R17 + 1008]> */
		/* 8218DED0h case    5:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R17 + 0x000003F0) );
		/* 8218DED0h case    5:*/		return 0x8218DED4;
		  /* 8218DED4h */ case    6:  		/* bc 12, CR6_LT, 8 */
		/* 8218DED4h case    6:*/		if ( regs.CR[6].lt ) { return 0x8218DEDC;  }
		/* 8218DED4h case    6:*/		return 0x8218DED8;
		  /* 8218DED8h */ case    7:  		/* li R11, 256 */
		/* 8218DED8h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x100);
		/* 8218DED8h case    7:*/		return 0x8218DEDC;
	}
	return 0x8218DEDC;
} // Block from 8218DEBCh-8218DEDCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218DEDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DEDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DEDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DEDC);
		  /* 8218DEDCh */ case    0:  		/* lwz R10, <#[R20 + 4]> */
		/* 8218DEDCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x00000004) );
		/* 8218DEDCh case    0:*/		return 0x8218DEE0;
		  /* 8218DEE0h */ case    1:  		/* rlwimi R10, R11, 16, 7, 15 */
		/* 8218DEE0h case    1:*/		cpu::op::rlwimi<0,16,7,15>(regs,&regs.R10,regs.R11);
		/* 8218DEE0h case    1:*/		return 0x8218DEE4;
		  /* 8218DEE4h */ case    2:  		/* rlwinm. R11, R10, 0, 25, 27 */
		/* 8218DEE4h case    2:*/		cpu::op::rlwinm<1,0,25,27>(regs,&regs.R11,regs.R10);
		/* 8218DEE4h case    2:*/		return 0x8218DEE8;
		  /* 8218DEE8h */ case    3:  		/* stw R10, <#[R20 + 4]> */
		/* 8218DEE8h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R20 + 0x00000004) );
		/* 8218DEE8h case    3:*/		return 0x8218DEEC;
		  /* 8218DEECh */ case    4:  		/* bc 4, CR0_EQ, 88 */
		/* 8218DEECh case    4:*/		if ( !regs.CR[0].eq ) { return 0x8218DF44;  }
		/* 8218DEECh case    4:*/		return 0x8218DEF0;
		  /* 8218DEF0h */ case    5:  		/* lwz R11, <#[R20]> */
		/* 8218DEF0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 8218DEF0h case    5:*/		return 0x8218DEF4;
		  /* 8218DEF4h */ case    6:  		/* li R10, 0 */
		/* 8218DEF4h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8218DEF4h case    6:*/		return 0x8218DEF8;
		  /* 8218DEF8h */ case    7:  		/* rlwinm. R11, R11, 0, 15, 28 */
		/* 8218DEF8h case    7:*/		cpu::op::rlwinm<1,0,15,28>(regs,&regs.R11,regs.R11);
		/* 8218DEF8h case    7:*/		return 0x8218DEFC;
		  /* 8218DEFCh */ case    8:  		/* bc 12, CR0_EQ, 72 */
		/* 8218DEFCh case    8:*/		if ( regs.CR[0].eq ) { return 0x8218DF44;  }
		/* 8218DEFCh case    8:*/		return 0x8218DF00;
		  /* 8218DF00h */ case    9:  		/* li R11, 0 */
		/* 8218DF00h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218DF00h case    9:*/		return 0x8218DF04;
		  /* 8218DF04h */ case   10:  		/* lwz R9, <#[R20 + 28]> */
		/* 8218DF04h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R20 + 0x0000001C) );
		/* 8218DF04h case   10:*/		return 0x8218DF08;
		  /* 8218DF08h */ case   11:  		/* li R8, 1 */
		/* 8218DF08h case   11:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8218DF08h case   11:*/		return 0x8218DF0C;
		  /* 8218DF0Ch */ case   12:  		/* addi R10, R10, 1 */
		/* 8218DF0Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8218DF0Ch case   12:*/		return 0x8218DF10;
		  /* 8218DF10h */ case   13:  		/* lwzx R7, <#[R9 + R11]> */
		/* 8218DF10h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8218DF10h case   13:*/		return 0x8218DF14;
		  /* 8218DF14h */ case   14:  		/* rlwimi R7, R8, 18, 12, 13 */
		/* 8218DF14h case   14:*/		cpu::op::rlwimi<0,18,12,13>(regs,&regs.R7,regs.R8);
		/* 8218DF14h case   14:*/		return 0x8218DF18;
		  /* 8218DF18h */ case   15:  		/* stwx R7, <#[R9 + R11]> */
		/* 8218DF18h case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8218DF18h case   15:*/		return 0x8218DF1C;
		  /* 8218DF1Ch */ case   16:  		/* lwz R9, <#[R20 + 28]> */
		/* 8218DF1Ch case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R20 + 0x0000001C) );
		/* 8218DF1Ch case   16:*/		return 0x8218DF20;
		  /* 8218DF20h */ case   17:  		/* add R9, R9, R11 */
		/* 8218DF20h case   17:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 8218DF20h case   17:*/		return 0x8218DF24;
		  /* 8218DF24h */ case   18:  		/* lwz R8, <#[R9]> */
		/* 8218DF24h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 8218DF24h case   18:*/		return 0x8218DF28;
		  /* 8218DF28h */ case   19:  		/* rlwinm R8, R8, 0, 12, 5 */
		/* 8218DF28h case   19:*/		cpu::op::rlwinm<0,0,12,5>(regs,&regs.R8,regs.R8);
		/* 8218DF28h case   19:*/		return 0x8218DF2C;
		  /* 8218DF2Ch */ case   20:  		/* stw R8, <#[R9]> */
		/* 8218DF2Ch case   20:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 8218DF2Ch case   20:*/		return 0x8218DF30;
		  /* 8218DF30h */ case   21:  		/* addi R11, R11, 8 */
		/* 8218DF30h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8218DF30h case   21:*/		return 0x8218DF34;
		  /* 8218DF34h */ case   22:  		/* lwz R9, <#[R20]> */
		/* 8218DF34h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R20 + 0x00000000) );
		/* 8218DF34h case   22:*/		return 0x8218DF38;
		  /* 8218DF38h */ case   23:  		/* rlwinm R9, R9, 29, 18, 31 */
		/* 8218DF38h case   23:*/		cpu::op::rlwinm<0,29,18,31>(regs,&regs.R9,regs.R9);
		/* 8218DF38h case   23:*/		return 0x8218DF3C;
		  /* 8218DF3Ch */ case   24:  		/* cmplw CR6, R10, R9 */
		/* 8218DF3Ch case   24:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8218DF3Ch case   24:*/		return 0x8218DF40;
		  /* 8218DF40h */ case   25:  		/* bc 12, CR6_LT, -60 */
		/* 8218DF40h case   25:*/		if ( regs.CR[6].lt ) { return 0x8218DF04;  }
		/* 8218DF40h case   25:*/		return 0x8218DF44;
	}
	return 0x8218DF44;
} // Block from 8218DEDCh-8218DF44h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8218DF44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DF44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DF44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DF44);
		  /* 8218DF44h */ case    0:  		/* addi R1, R1, 256 */
		/* 8218DF44h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 8218DF44h case    0:*/		return 0x8218DF48;
		  /* 8218DF48h */ case    1:  		/* b -1035480 */
		/* 8218DF48h case    1:*/		return 0x82091270;
		/* 8218DF48h case    1:*/		return 0x8218DF4C;
	}
	return 0x8218DF4C;
} // Block from 8218DF44h-8218DF4Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218DF4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DF4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DF4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DF4C);
		  /* 8218DF4Ch */ case    0:  		/* li R4, 4801 */
		/* 8218DF4Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 8218DF4Ch case    0:*/		return 0x8218DF50;
		  /* 8218DF50h */ case    1:  		/* mr R3, R17 */
		/* 8218DF50h case    1:*/		regs.R3 = regs.R17;
		/* 8218DF50h case    1:*/		return 0x8218DF54;
		  /* 8218DF54h */ case    2:  		/* bl -245996 */
		/* 8218DF54h case    2:*/		regs.LR = 0x8218DF58; return 0x82151E68;
		/* 8218DF54h case    2:*/		return 0x8218DF58;
	}
	return 0x8218DF58;
} // Block from 8218DF4Ch-8218DF58h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218DF58h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DF58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DF58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DF58);
		  /* 8218DF58h */ case    0:  		/* mfspr R12, LR */
		/* 8218DF58h case    0:*/		regs.R12 = regs.LR;
		/* 8218DF58h case    0:*/		return 0x8218DF5C;
		  /* 8218DF5Ch */ case    1:  		/* bl -1035580 */
		/* 8218DF5Ch case    1:*/		regs.LR = 0x8218DF60; return 0x82091220;
		/* 8218DF5Ch case    1:*/		return 0x8218DF60;
	}
	return 0x8218DF60;
} // Block from 8218DF58h-8218DF60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218DF60h
// Function '?EnsureContiguousRegistersFree@?$RegisterSet@V?$FixedSizeBitSet@_K$0BA@@D3DXShader@@$1?PrintConstantRegister@2@YAXPAVCompiler@2@I@Z$0BAA@$03$1?ReportOutOfConstantRegistersError@2@YAX0@Z@D3DXShader@@QAAXII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DF60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DF60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DF60);
		  /* 8218DF60h */ case    0:  		/* stwu R1, <#[R1 - 608]> */
		/* 8218DF60h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFDA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFDA0);
		/* 8218DF60h case    0:*/		return 0x8218DF64;
		  /* 8218DF64h */ case    1:  		/* lwz R11, <#[R3 + 88]> */
		/* 8218DF64h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000058) );
		/* 8218DF64h case    1:*/		return 0x8218DF68;
		  /* 8218DF68h */ case    2:  		/* mr R14, R3 */
		/* 8218DF68h case    2:*/		regs.R14 = regs.R3;
		/* 8218DF68h case    2:*/		return 0x8218DF6C;
		  /* 8218DF6Ch */ case    3:  		/* stw R3, <#[R1 + 628]> */
		/* 8218DF6Ch case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000274) );
		/* 8218DF6Ch case    3:*/		return 0x8218DF70;
		  /* 8218DF70h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8218DF70h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218DF70h case    4:*/		return 0x8218DF74;
		  /* 8218DF74h */ case    5:  		/* bc 12, CR6_EQ, 8 */
		/* 8218DF74h case    5:*/		if ( regs.CR[6].eq ) { return 0x8218DF7C;  }
		/* 8218DF74h case    5:*/		return 0x8218DF78;
		  /* 8218DF78h */ case    6:  		/* bl -6312 */
		/* 8218DF78h case    6:*/		regs.LR = 0x8218DF7C; return 0x8218C6D0;
		/* 8218DF78h case    6:*/		return 0x8218DF7C;
	}
	return 0x8218DF7C;
} // Block from 8218DF60h-8218DF7Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218DF7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218DF7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218DF7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218DF7C);
		  /* 8218DF7Ch */ case    0:  		/* li R5, 128 */
		/* 8218DF7Ch case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x80);
		/* 8218DF7Ch case    0:*/		return 0x8218DF80;
		  /* 8218DF80h */ case    1:  		/* stw R14, <#[R1 + 320]> */
		/* 8218DF80h case    1:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000140) );
		/* 8218DF80h case    1:*/		return 0x8218DF84;
		  /* 8218DF84h */ case    2:  		/* li R4, 0 */
		/* 8218DF84h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8218DF84h case    2:*/		return 0x8218DF88;
		  /* 8218DF88h */ case    3:  		/* addi R3, R1, 328 */
		/* 8218DF88h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x148);
		/* 8218DF88h case    3:*/		return 0x8218DF8C;
		  /* 8218DF8Ch */ case    4:  		/* bl -1035340 */
		/* 8218DF8Ch case    4:*/		regs.LR = 0x8218DF90; return 0x82091340;
		/* 8218DF8Ch case    4:*/		return 0x8218DF90;
		  /* 8218DF90h */ case    5:  		/* addi R11, R1, 136 */
		/* 8218DF90h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x88);
		/* 8218DF90h case    5:*/		return 0x8218DF94;
		  /* 8218DF94h */ case    6:  		/* li R17, 0 */
		/* 8218DF94h case    6:*/		cpu::op::li<0>(regs,&regs.R17,0x0);
		/* 8218DF94h case    6:*/		return 0x8218DF98;
		  /* 8218DF98h */ case    7:  		/* stw R14, <#[R1 + 128]> */
		/* 8218DF98h case    7:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000080) );
		/* 8218DF98h case    7:*/		return 0x8218DF9C;
		  /* 8218DF9Ch */ case    8:  		/* addi R10, R1, 92 */
		/* 8218DF9Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x5C);
		/* 8218DF9Ch case    8:*/		return 0x8218DFA0;
		  /* 8218DFA0h */ case    9:  		/* stw R14, <#[R1 + 88]> */
		/* 8218DFA0h case    9:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000058) );
		/* 8218DFA0h case    9:*/		return 0x8218DFA4;
		  /* 8218DFA4h */ case   10:  		/* addi R9, R1, 100 */
		/* 8218DFA4h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x64);
		/* 8218DFA4h case   10:*/		return 0x8218DFA8;
		  /* 8218DFA8h */ case   11:  		/* stw R14, <#[R1 + 96]> */
		/* 8218DFA8h case   11:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000060) );
		/* 8218DFA8h case   11:*/		return 0x8218DFAC;
		  /* 8218DFACh */ case   12:  		/* lwz R8, <#[R14 + 4]> */
		/* 8218DFACh case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R14 + 0x00000004) );
		/* 8218DFACh case   12:*/		return 0x8218DFB0;
		  /* 8218DFB0h */ case   13:  		/* mr R30, R17 */
		/* 8218DFB0h case   13:*/		regs.R30 = regs.R17;
		/* 8218DFB0h case   13:*/		return 0x8218DFB4;
		  /* 8218DFB4h */ case   14:  		/* std R17, <#[R11]> */
		/* 8218DFB4h case   14:*/		cpu::mem::store64( regs, regs.R17, (uint32)(regs.R11 + 0x00000000) );
		/* 8218DFB4h case   14:*/		return 0x8218DFB8;
		  /* 8218DFB8h */ case   15:  		/* std R17, <#[R11 + 8]> */
		/* 8218DFB8h case   15:*/		cpu::mem::store64( regs, regs.R17, (uint32)(regs.R11 + 0x00000008) );
		/* 8218DFB8h case   15:*/		return 0x8218DFBC;
		  /* 8218DFBCh */ case   16:  		/* rlwinm R7, R8, 0, 31, 31 */
		/* 8218DFBCh case   16:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R7,regs.R8);
		/* 8218DFBCh case   16:*/		return 0x8218DFC0;
		  /* 8218DFC0h */ case   17:  		/* std R17, <#[R11 + 16]> */
		/* 8218DFC0h case   17:*/		cpu::mem::store64( regs, regs.R17, (uint32)(regs.R11 + 0x00000010) );
		/* 8218DFC0h case   17:*/		return 0x8218DFC4;
		  /* 8218DFC4h */ case   18:  		/* std R17, <#[R11 + 24]> */
		/* 8218DFC4h case   18:*/		cpu::mem::store64( regs, regs.R17, (uint32)(regs.R11 + 0x00000018) );
		/* 8218DFC4h case   18:*/		return 0x8218DFC8;
		  /* 8218DFC8h */ case   19:  		/* stw R17, <#[R10]> */
		/* 8218DFC8h case   19:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R10 + 0x00000000) );
		/* 8218DFC8h case   19:*/		return 0x8218DFCC;
		  /* 8218DFCCh */ case   20:  		/* stw R17, <#[R9]> */
		/* 8218DFCCh case   20:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R9 + 0x00000000) );
		/* 8218DFCCh case   20:*/		return 0x8218DFD0;
		  /* 8218DFD0h */ case   21:  		/* addic R10, R7, -1 */
		/* 8218DFD0h case   21:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R7,0xFFFFFFFF);
		/* 8218DFD0h case   21:*/		return 0x8218DFD4;
		  /* 8218DFD4h */ case   22:  		/* subfe R11, R10, R10 */
		/* 8218DFD4h case   22:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R10,regs.R10);
		/* 8218DFD4h case   22:*/		return 0x8218DFD8;
		  /* 8218DFD8h */ case   23:  		/* and R11, R11, R8 */
		/* 8218DFD8h case   23:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8218DFD8h case   23:*/		return 0x8218DFDC;
		  /* 8218DFDCh */ case   24:  		/* lwz R31, <#[R11 + 20]> */
		/* 8218DFDCh case   24:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000014) );
		/* 8218DFDCh case   24:*/		return 0x8218DFE0;
		  /* 8218DFE0h */ case   25:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 8218DFE0h case   25:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 8218DFE0h case   25:*/		return 0x8218DFE4;
		  /* 8218DFE4h */ case   26:  		/* bc 4, CR0_EQ, 128 */
		/* 8218DFE4h case   26:*/		if ( !regs.CR[0].eq ) { return 0x8218E064;  }
		/* 8218DFE4h case   26:*/		return 0x8218DFE8;
		  /* 8218DFE8h */ case   27:  		/* cmplwi CR0, R31, 0 */
		/* 8218DFE8h case   27:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 8218DFE8h case   27:*/		return 0x8218DFEC;
		  /* 8218DFECh */ case   28:  		/* bc 12, CR0_EQ, 120 */
		/* 8218DFECh case   28:*/		if ( regs.CR[0].eq ) { return 0x8218E064;  }
		/* 8218DFECh case   28:*/		return 0x8218DFF0;
		  /* 8218DFF0h */ case   29:  		/* lwz R11, <#[R31 + 8]> */
		/* 8218DFF0h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8218DFF0h case   29:*/		return 0x8218DFF4;
		  /* 8218DFF4h */ case   30:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8218DFF4h case   30:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8218DFF4h case   30:*/		return 0x8218DFF8;
		  /* 8218DFF8h */ case   31:  		/* cmplwi CR6, R11, 15872 */
		/* 8218DFF8h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E00);
		/* 8218DFF8h case   31:*/		return 0x8218DFFC;
		  /* 8218DFFCh */ case   32:  		/* bc 4, CR6_EQ, 80 */
		/* 8218DFFCh case   32:*/		if ( !regs.CR[6].eq ) { return 0x8218E04C;  }
		/* 8218DFFCh case   32:*/		return 0x8218E000;
	}
	return 0x8218E000;
} // Block from 8218DF7Ch-8218E000h (33 instructions)

//////////////////////////////////////////////////////
// Block at 8218E000h
// Function '?EnsureContiguousRegistersInUse@?$RegisterSet@V?$FixedSizeBitSet@_K$03@D3DXShader@@$1?PrintConditionRegister@2@YAXPAVCompiler@2@I@Z$0BAA@$00$1?ReportOutOfBooleanRegistersError@2@YAX0@Z@D3DXShader@@QAAXII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E000);
		  /* 8218E000h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8218E000h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8218E000h case    0:*/		return 0x8218E004;
		  /* 8218E004h */ case    1:  		/* mr R3, R14 */
		/* 8218E004h case    1:*/		regs.R3 = regs.R14;
		/* 8218E004h case    1:*/		return 0x8218E008;
		  /* 8218E008h */ case    2:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8218E008h case    2:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8218E008h case    2:*/		return 0x8218E00C;
		  /* 8218E00Ch */ case    3:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8218E00Ch case    3:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8218E00Ch case    3:*/		return 0x8218E010;
		  /* 8218E010h */ case    4:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8218E010h case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8218E010h case    4:*/		return 0x8218E014;
		  /* 8218E014h */ case    5:  		/* bl -170980 */
		/* 8218E014h case    5:*/		regs.LR = 0x8218E018; return 0x82164430;
		/* 8218E014h case    5:*/		return 0x8218E018;
		  /* 8218E018h */ case    6:  		/* addi R10, R31, -8 */
		/* 8218E018h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFF8);
		/* 8218E018h case    6:*/		return 0x8218E01C;
		  /* 8218E01Ch */ case    7:  		/* lwz R11, <#[R14 + 12]> */
		/* 8218E01Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218E01Ch case    7:*/		return 0x8218E020;
		  /* 8218E020h */ case    8:  		/* lwzx R10, <#[R3 + R10]> */
		/* 8218E020h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + regs.R10 + 0x00000000) );
		/* 8218E020h case    8:*/		return 0x8218E024;
		  /* 8218E024h */ case    9:  		/* rlwinm R10, R10, 0, 17, 31 */
		/* 8218E024h case    9:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R10,regs.R10);
		/* 8218E024h case    9:*/		return 0x8218E028;
		  /* 8218E028h */ case   10:  		/* mulli R10, R10, 40 */
		/* 8218E028h case   10:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x28);
		/* 8218E028h case   10:*/		return 0x8218E02C;
		  /* 8218E02Ch */ case   11:  		/* add R11, R10, R11 */
		/* 8218E02Ch case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218E02Ch case   11:*/		return 0x8218E030;
		  /* 8218E030h */ case   12:  		/* lwz R10, <#[R11]> */
		/* 8218E030h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218E030h case   12:*/		return 0x8218E034;
		  /* 8218E034h */ case   13:  		/* lwz R9, <#[R11 + 36]> */
		/* 8218E034h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000024) );
		/* 8218E034h case   13:*/		return 0x8218E038;
		  /* 8218E038h */ case   14:  		/* oris R10, R10, 8192 */
		/* 8218E038h case   14:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x2000);
		/* 8218E038h case   14:*/		return 0x8218E03C;
		  /* 8218E03Ch */ case   15:  		/* cmplwi CR6, R9, 0 */
		/* 8218E03Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8218E03Ch case   15:*/		return 0x8218E040;
		  /* 8218E040h */ case   16:  		/* stw R10, <#[R11]> */
		/* 8218E040h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218E040h case   16:*/		return 0x8218E044;
		  /* 8218E044h */ case   17:  		/* bc 12, CR6_EQ, 8 */
		/* 8218E044h case   17:*/		if ( regs.CR[6].eq ) { return 0x8218E04C;  }
		/* 8218E044h case   17:*/		return 0x8218E048;
		  /* 8218E048h */ case   18:  		/* li R30, 1 */
		/* 8218E048h case   18:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 8218E048h case   18:*/		return 0x8218E04C;
	}
	return 0x8218E04C;
} // Block from 8218E000h-8218E04Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8218E04Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E04C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E04C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E04C);
		  /* 8218E04Ch */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8218E04Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8218E04Ch case    0:*/		return 0x8218E050;
		  /* 8218E050h */ case    1:  		/* lwz R31, <#[R11 + 40]> */
		/* 8218E050h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000028) );
		/* 8218E050h case    1:*/		return 0x8218E054;
		  /* 8218E054h */ case    2:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 8218E054h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 8218E054h case    2:*/		return 0x8218E058;
		  /* 8218E058h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 8218E058h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8218E064;  }
		/* 8218E058h case    3:*/		return 0x8218E05C;
		  /* 8218E05Ch */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8218E05Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8218E05Ch case    4:*/		return 0x8218E060;
		  /* 8218E060h */ case    5:  		/* bc 4, CR6_EQ, -112 */
		/* 8218E060h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8218DFF0;  }
		/* 8218E060h case    5:*/		return 0x8218E064;
	}
	return 0x8218E064;
} // Block from 8218E04Ch-8218E064h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218E064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E064);
		  /* 8218E064h */ case    0:  		/* rlwinm. R11, R30, 0, 24, 31 */
		/* 8218E064h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R30);
		/* 8218E064h case    0:*/		return 0x8218E068;
		  /* 8218E068h */ case    1:  		/* bc 12, CR0_EQ, 656 */
		/* 8218E068h case    1:*/		if ( regs.CR[0].eq ) { return 0x8218E2F8;  }
		/* 8218E068h case    1:*/		return 0x8218E06C;
		  /* 8218E06Ch */ case    2:  		/* lwz R11, <#[R14 + 16]> */
		/* 8218E06Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000010) );
		/* 8218E06Ch case    2:*/		return 0x8218E070;
		  /* 8218E070h */ case    3:  		/* mr R6, R17 */
		/* 8218E070h case    3:*/		regs.R6 = regs.R17;
		/* 8218E070h case    3:*/		return 0x8218E074;
		  /* 8218E074h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8218E074h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218E074h case    4:*/		return 0x8218E078;
		  /* 8218E078h */ case    5:  		/* bc 4, CR6_GT, 200 */
		/* 8218E078h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8218E140;  }
		/* 8218E078h case    5:*/		return 0x8218E07C;
		  /* 8218E07Ch */ case    6:  		/* mr R5, R17 */
		/* 8218E07Ch case    6:*/		regs.R5 = regs.R17;
		/* 8218E07Ch case    6:*/		return 0x8218E080;
		  /* 8218E080h */ case    7:  		/* lwz R9, <#[R14 + 12]> */
		/* 8218E080h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218E080h case    7:*/		return 0x8218E084;
		  /* 8218E084h */ case    8:  		/* add R7, R5, R9 */
		/* 8218E084h case    8:*/		cpu::op::add<0>(regs,&regs.R7,regs.R5,regs.R9);
		/* 8218E084h case    8:*/		return 0x8218E088;
	}
	return 0x8218E088;
} // Block from 8218E064h-8218E088h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218E088h
// Function '?EnsureContiguousRegistersInUse@?$RegisterSet@V?$FixedSizeBitSet@I$00@D3DXShader@@$1?PrintSamplerRegister@2@YAXPAVCompiler@2@I@Z$0CA@$00$1?ReportOutOfSamplerRegistersError@2@YAX0@Z@D3DXShader@@QAAXII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E088);
		  /* 8218E088h */ case    0:  		/* lwz R8, <#[R7 + 36]> */
		/* 8218E088h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + 0x00000024) );
		/* 8218E088h case    0:*/		return 0x8218E08C;
		  /* 8218E08Ch */ case    1:  		/* cmplwi CR6, R8, 0 */
		/* 8218E08Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8218E08Ch case    1:*/		return 0x8218E090;
		  /* 8218E090h */ case    2:  		/* bc 12, CR6_EQ, 156 */
		/* 8218E090h case    2:*/		if ( regs.CR[6].eq ) { return 0x8218E12C;  }
		/* 8218E090h case    2:*/		return 0x8218E094;
		  /* 8218E094h */ case    3:  		/* lwz R11, <#[R7]> */
		/* 8218E094h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 8218E094h case    3:*/		return 0x8218E098;
		  /* 8218E098h */ case    4:  		/* rlwinm. R11, R11, 0, 2, 2 */
		/* 8218E098h case    4:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R11,regs.R11);
		/* 8218E098h case    4:*/		return 0x8218E09C;
		  /* 8218E09Ch */ case    5:  		/* bc 12, CR0_EQ, 144 */
		/* 8218E09Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x8218E12C;  }
		/* 8218E09Ch case    5:*/		return 0x8218E0A0;
		  /* 8218E0A0h */ case    6:  		/* mr R10, R17 */
		/* 8218E0A0h case    6:*/		regs.R10 = regs.R17;
		/* 8218E0A0h case    6:*/		return 0x8218E0A4;
		  /* 8218E0A4h */ case    7:  		/* cmplwi CR6, R6, 0 */
		/* 8218E0A4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8218E0A4h case    7:*/		return 0x8218E0A8;
		  /* 8218E0A8h */ case    8:  		/* bc 12, CR6_EQ, 48 */
		/* 8218E0A8h case    8:*/		if ( regs.CR[6].eq ) { return 0x8218E0D8;  }
		/* 8218E0A8h case    8:*/		return 0x8218E0AC;
		  /* 8218E0ACh */ case    9:  		/* mr R11, R17 */
		/* 8218E0ACh case    9:*/		regs.R11 = regs.R17;
		/* 8218E0ACh case    9:*/		return 0x8218E0B0;
		  /* 8218E0B0h */ case   10:  		/* add R4, R11, R9 */
		/* 8218E0B0h case   10:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R9);
		/* 8218E0B0h case   10:*/		return 0x8218E0B4;
		  /* 8218E0B4h */ case   11:  		/* lwz R4, <#[R4 + 36]> */
		/* 8218E0B4h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000024) );
		/* 8218E0B4h case   11:*/		return 0x8218E0B8;
		  /* 8218E0B8h */ case   12:  		/* cmplw CR6, R8, R4 */
		/* 8218E0B8h case   12:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R4);
		/* 8218E0B8h case   12:*/		return 0x8218E0BC;
		  /* 8218E0BCh */ case   13:  		/* bc 12, CR6_EQ, 20 */
		/* 8218E0BCh case   13:*/		if ( regs.CR[6].eq ) { return 0x8218E0D0;  }
		/* 8218E0BCh case   13:*/		return 0x8218E0C0;
		  /* 8218E0C0h */ case   14:  		/* addi R10, R10, 1 */
		/* 8218E0C0h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8218E0C0h case   14:*/		return 0x8218E0C4;
		  /* 8218E0C4h */ case   15:  		/* addi R11, R11, 40 */
		/* 8218E0C4h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x28);
		/* 8218E0C4h case   15:*/		return 0x8218E0C8;
		  /* 8218E0C8h */ case   16:  		/* cmplw CR6, R10, R6 */
		/* 8218E0C8h case   16:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 8218E0C8h case   16:*/		return 0x8218E0CC;
		  /* 8218E0CCh */ case   17:  		/* bc 12, CR6_LT, -28 */
		/* 8218E0CCh case   17:*/		if ( regs.CR[6].lt ) { return 0x8218E0B0;  }
		/* 8218E0CCh case   17:*/		return 0x8218E0D0;
	}
	return 0x8218E0D0;
} // Block from 8218E088h-8218E0D0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8218E0D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E0D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E0D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E0D0);
		  /* 8218E0D0h */ case    0:  		/* cmplw CR6, R10, R6 */
		/* 8218E0D0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 8218E0D0h case    0:*/		return 0x8218E0D4;
		  /* 8218E0D4h */ case    1:  		/* bc 12, CR6_LT, 88 */
		/* 8218E0D4h case    1:*/		if ( regs.CR[6].lt ) { return 0x8218E12C;  }
		/* 8218E0D4h case    1:*/		return 0x8218E0D8;
	}
	return 0x8218E0D8;
} // Block from 8218E0D0h-8218E0D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218E0D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E0D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E0D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E0D8);
		  /* 8218E0D8h */ case    0:  		/* lwz R11, <#[R14 + 16]> */
		/* 8218E0D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000010) );
		/* 8218E0D8h case    0:*/		return 0x8218E0DC;
		  /* 8218E0DCh */ case    1:  		/* mr R8, R17 */
		/* 8218E0DCh case    1:*/		regs.R8 = regs.R17;
		/* 8218E0DCh case    1:*/		return 0x8218E0E0;
		  /* 8218E0E0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8218E0E0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218E0E0h case    2:*/		return 0x8218E0E4;
		  /* 8218E0E4h */ case    3:  		/* bc 4, CR6_GT, 72 */
		/* 8218E0E4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8218E12C;  }
		/* 8218E0E4h case    3:*/		return 0x8218E0E8;
		  /* 8218E0E8h */ case    4:  		/* mr R10, R17 */
		/* 8218E0E8h case    4:*/		regs.R10 = regs.R17;
		/* 8218E0E8h case    4:*/		return 0x8218E0EC;
		  /* 8218E0ECh */ case    5:  		/* lwz R11, <#[R14 + 12]> */
		/* 8218E0ECh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218E0ECh case    5:*/		return 0x8218E0F0;
		  /* 8218E0F0h */ case    6:  		/* lwz R9, <#[R7 + 36]> */
		/* 8218E0F0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000024) );
		/* 8218E0F0h case    6:*/		return 0x8218E0F4;
		  /* 8218E0F4h */ case    7:  		/* add R11, R10, R11 */
		/* 8218E0F4h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218E0F4h case    7:*/		return 0x8218E0F8;
		  /* 8218E0F8h */ case    8:  		/* lwz R4, <#[R11 + 36]> */
		/* 8218E0F8h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000024) );
		/* 8218E0F8h case    8:*/		return 0x8218E0FC;
		  /* 8218E0FCh */ case    9:  		/* cmplw CR6, R9, R4 */
		/* 8218E0FCh case    9:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R4);
		/* 8218E0FCh case    9:*/		return 0x8218E100;
		  /* 8218E100h */ case   10:  		/* bc 4, CR6_EQ, 24 */
		/* 8218E100h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8218E118;  }
		/* 8218E100h case   10:*/		return 0x8218E104;
		  /* 8218E104h */ case   11:  		/* lwz R9, <#[R11]> */
		/* 8218E104h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8218E104h case   11:*/		return 0x8218E108;
	}
	return 0x8218E108;
} // Block from 8218E0D8h-8218E108h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8218E108h
// Function '?CreateTypeEnumerator@Compiler@D3DXShader@@QAAPAVComponentTypeEnumerator@2@PAVCNode@2@00@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E108);
		  /* 8218E108h */ case    0:  		/* rlwinm. R4, R9, 0, 2, 2 */
		/* 8218E108h case    0:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R4,regs.R9);
		/* 8218E108h case    0:*/		return 0x8218E10C;
		  /* 8218E10Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 8218E10Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x8218E118;  }
		/* 8218E10Ch case    1:*/		return 0x8218E110;
		  /* 8218E110h */ case    2:  		/* oris R9, R9, 8192 */
		/* 8218E110h case    2:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R9,0x2000);
		/* 8218E110h case    2:*/		return 0x8218E114;
		  /* 8218E114h */ case    3:  		/* stw R9, <#[R11]> */
		/* 8218E114h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8218E114h case    3:*/		return 0x8218E118;
	}
	return 0x8218E118;
} // Block from 8218E108h-8218E118h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218E118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E118);
		  /* 8218E118h */ case    0:  		/* lwz R11, <#[R14 + 16]> */
		/* 8218E118h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000010) );
		/* 8218E118h case    0:*/		return 0x8218E11C;
		  /* 8218E11Ch */ case    1:  		/* addi R8, R8, 1 */
		/* 8218E11Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8218E11Ch case    1:*/		return 0x8218E120;
		  /* 8218E120h */ case    2:  		/* addi R10, R10, 40 */
		/* 8218E120h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x28);
		/* 8218E120h case    2:*/		return 0x8218E124;
		  /* 8218E124h */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 8218E124h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8218E124h case    3:*/		return 0x8218E128;
		  /* 8218E128h */ case    4:  		/* bc 12, CR6_LT, -60 */
		/* 8218E128h case    4:*/		if ( regs.CR[6].lt ) { return 0x8218E0EC;  }
		/* 8218E128h case    4:*/		return 0x8218E12C;
	}
	return 0x8218E12C;
} // Block from 8218E118h-8218E12Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218E12Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E12C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E12C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E12C);
		  /* 8218E12Ch */ case    0:  		/* lwz R11, <#[R14 + 16]> */
		/* 8218E12Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000010) );
		/* 8218E12Ch case    0:*/		return 0x8218E130;
		  /* 8218E130h */ case    1:  		/* addi R6, R6, 1 */
		/* 8218E130h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8218E130h case    1:*/		return 0x8218E134;
		  /* 8218E134h */ case    2:  		/* addi R5, R5, 40 */
		/* 8218E134h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x28);
		/* 8218E134h case    2:*/		return 0x8218E138;
		  /* 8218E138h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 8218E138h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 8218E138h case    3:*/		return 0x8218E13C;
		  /* 8218E13Ch */ case    4:  		/* bc 12, CR6_LT, -188 */
		/* 8218E13Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x8218E080;  }
		/* 8218E13Ch case    4:*/		return 0x8218E140;
	}
	return 0x8218E140;
} // Block from 8218E12Ch-8218E140h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218E140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E140);
		  /* 8218E140h */ case    0:  		/* lwz R11, <#[R14 + 16]> */
		/* 8218E140h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000010) );
		/* 8218E140h case    0:*/		return 0x8218E144;
		  /* 8218E144h */ case    1:  		/* mr R28, R17 */
		/* 8218E144h case    1:*/		regs.R28 = regs.R17;
		/* 8218E144h case    1:*/		return 0x8218E148;
		  /* 8218E148h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8218E148h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218E148h case    2:*/		return 0x8218E14C;
		  /* 8218E14Ch */ case    3:  		/* bc 4, CR6_GT, 428 */
		/* 8218E14Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x8218E2F8;  }
		/* 8218E14Ch case    3:*/		return 0x8218E150;
		  /* 8218E150h */ case    4:  		/* mr R26, R17 */
		/* 8218E150h case    4:*/		regs.R26 = regs.R17;
		/* 8218E150h case    4:*/		return 0x8218E154;
		  /* 8218E154h */ case    5:  		/* lwz R11, <#[R14 + 12]> */
		/* 8218E154h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218E154h case    5:*/		return 0x8218E158;
		  /* 8218E158h */ case    6:  		/* add R27, R26, R11 */
		/* 8218E158h case    6:*/		cpu::op::add<0>(regs,&regs.R27,regs.R26,regs.R11);
		/* 8218E158h case    6:*/		return 0x8218E15C;
		  /* 8218E15Ch */ case    7:  		/* lwz R11, <#[R27 + 36]> */
		/* 8218E15Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000024) );
		/* 8218E15Ch case    7:*/		return 0x8218E160;
		  /* 8218E160h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 8218E160h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218E160h case    8:*/		return 0x8218E164;
		  /* 8218E164h */ case    9:  		/* bc 12, CR6_EQ, 384 */
		/* 8218E164h case    9:*/		if ( regs.CR[6].eq ) { return 0x8218E2E4;  }
		/* 8218E164h case    9:*/		return 0x8218E168;
		  /* 8218E168h */ case   10:  		/* lwz R11, <#[R27]> */
		/* 8218E168h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8218E168h case   10:*/		return 0x8218E16C;
		  /* 8218E16Ch */ case   11:  		/* rlwinm. R10, R11, 0, 2, 2 */
		/* 8218E16Ch case   11:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R10,regs.R11);
		/* 8218E16Ch case   11:*/		return 0x8218E170;
		  /* 8218E170h */ case   12:  		/* bc 12, CR0_EQ, 372 */
		/* 8218E170h case   12:*/		if ( regs.CR[0].eq ) { return 0x8218E2E4;  }
		/* 8218E170h case   12:*/		return 0x8218E174;
		  /* 8218E174h */ case   13:  		/* rlwinm. R11, R11, 0, 15, 28 */
		/* 8218E174h case   13:*/		cpu::op::rlwinm<1,0,15,28>(regs,&regs.R11,regs.R11);
		/* 8218E174h case   13:*/		return 0x8218E178;
		  /* 8218E178h */ case   14:  		/* mr R31, R17 */
		/* 8218E178h case   14:*/		regs.R31 = regs.R17;
		/* 8218E178h case   14:*/		return 0x8218E17C;
		  /* 8218E17Ch */ case   15:  		/* mr R29, R17 */
		/* 8218E17Ch case   15:*/		regs.R29 = regs.R17;
		/* 8218E17Ch case   15:*/		return 0x8218E180;
	}
	return 0x8218E180;
} // Block from 8218E140h-8218E180h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8218E180h
// Function '?PadConstantRegisterBlocks@Compiler@D3DXShader@@AAAXPAV?$RegisterSet@V?$FixedSizeBitSet@_K$0BA@@D3DXShader@@$1?PrintConstantRegister@2@YAXPAVCompiler@2@I@Z$0BAA@$03$1?ReportOutOfConstantRegistersError@2@YAX0@Z@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E180);
		  /* 8218E180h */ case    0:  		/* bc 12, CR0_EQ, 356 */
		/* 8218E180h case    0:*/		if ( regs.CR[0].eq ) { return 0x8218E2E4;  }
		/* 8218E180h case    0:*/		return 0x8218E184;
		  /* 8218E184h */ case    1:  		/* li R6, 1 */
		/* 8218E184h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8218E184h case    1:*/		return 0x8218E188;
		  /* 8218E188h */ case    2:  		/* mr R5, R29 */
		/* 8218E188h case    2:*/		regs.R5 = regs.R29;
		/* 8218E188h case    2:*/		return 0x8218E18C;
		  /* 8218E18Ch */ case    3:  		/* mr R4, R28 */
		/* 8218E18Ch case    3:*/		regs.R4 = regs.R28;
		/* 8218E18Ch case    3:*/		return 0x8218E190;
		  /* 8218E190h */ case    4:  		/* mr R3, R14 */
		/* 8218E190h case    4:*/		regs.R3 = regs.R14;
		/* 8218E190h case    4:*/		return 0x8218E194;
		  /* 8218E194h */ case    5:  		/* bl 625548 */
		/* 8218E194h case    5:*/		regs.LR = 0x8218E198; return 0x82226D20;
		/* 8218E194h case    5:*/		return 0x8218E198;
		  /* 8218E198h */ case    6:  		/* lwz R11, <#[R3 + 4]> */
		/* 8218E198h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8218E198h case    6:*/		return 0x8218E19C;
		  /* 8218E19Ch */ case    7:  		/* mr R30, R3 */
		/* 8218E19Ch case    7:*/		regs.R30 = regs.R3;
		/* 8218E19Ch case    7:*/		return 0x8218E1A0;
		  /* 8218E1A0h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 8218E1A0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218E1A0h case    8:*/		return 0x8218E1A4;
		  /* 8218E1A4h */ case    9:  		/* bc 12, CR6_EQ, 36 */
		/* 8218E1A4h case    9:*/		if ( regs.CR[6].eq ) { return 0x8218E1C8;  }
		/* 8218E1A4h case    9:*/		return 0x8218E1A8;
		  /* 8218E1A8h */ case   10:  		/* lwz R10, <#[R11 + 16]> */
		/* 8218E1A8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 8218E1A8h case   10:*/		return 0x8218E1AC;
		  /* 8218E1ACh */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 8218E1ACh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8218E1ACh case   11:*/		return 0x8218E1B0;
		  /* 8218E1B0h */ case   12:  		/* bc 12, CR6_EQ, 16 */
		/* 8218E1B0h case   12:*/		if ( regs.CR[6].eq ) { return 0x8218E1C0;  }
		/* 8218E1B0h case   12:*/		return 0x8218E1B4;
		  /* 8218E1B4h */ case   13:  		/* lwz R10, <#[R11]> */
		/* 8218E1B4h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218E1B4h case   13:*/		return 0x8218E1B8;
		  /* 8218E1B8h */ case   14:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 8218E1B8h case   14:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 8218E1B8h case   14:*/		return 0x8218E1BC;
		  /* 8218E1BCh */ case   15:  		/* bc 4, CR0_EQ, 276 */
		/* 8218E1BCh case   15:*/		if ( !regs.CR[0].eq ) { return 0x8218E2D0;  }
		/* 8218E1BCh case   15:*/		return 0x8218E1C0;
	}
	return 0x8218E1C0;
} // Block from 8218E180h-8218E1C0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8218E1C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E1C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E1C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E1C0);
		  /* 8218E1C0h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 8218E1C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8218E1C0h case    0:*/		return 0x8218E1C4;
		  /* 8218E1C4h */ case    1:  		/* b -36 */
		/* 8218E1C4h case    1:*/		return 0x8218E1A0;
		/* 8218E1C4h case    1:*/		return 0x8218E1C8;
	}
	return 0x8218E1C8;
} // Block from 8218E1C0h-8218E1C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218E1C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E1C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E1C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E1C8);
		  /* 8218E1C8h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 8218E1C8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8218E1C8h case    0:*/		return 0x8218E1CC;
		  /* 8218E1CCh */ case    1:  		/* bc 4, CR6_EQ, 140 */
		/* 8218E1CCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8218E258;  }
		/* 8218E1CCh case    1:*/		return 0x8218E1D0;
		  /* 8218E1D0h */ case    2:  		/* lwz R11, <#[R14 + 4]> */
		/* 8218E1D0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000004) );
		/* 8218E1D0h case    2:*/		return 0x8218E1D4;
		  /* 8218E1D4h */ case    3:  		/* li R8, 0 */
		/* 8218E1D4h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8218E1D4h case    3:*/		return 0x8218E1D8;
		  /* 8218E1D8h */ case    4:  		/* li R7, 0 */
		/* 8218E1D8h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8218E1D8h case    4:*/		return 0x8218E1DC;
		  /* 8218E1DCh */ case    5:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8218E1DCh case    5:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8218E1DCh case    5:*/		return 0x8218E1E0;
		  /* 8218E1E0h */ case    6:  		/* li R6, 117 */
		/* 8218E1E0h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x75);
		/* 8218E1E0h case    6:*/		return 0x8218E1E4;
		  /* 8218E1E4h */ case    7:  		/* addic R10, R10, -1 */
		/* 8218E1E4h case    7:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8218E1E4h case    7:*/		return 0x8218E1E8;
		  /* 8218E1E8h */ case    8:  		/* li R5, 0 */
		/* 8218E1E8h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8218E1E8h case    8:*/		return 0x8218E1EC;
		  /* 8218E1ECh */ case    9:  		/* subfe R10, R10, R10 */
		/* 8218E1ECh case    9:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8218E1ECh case    9:*/		return 0x8218E1F0;
		  /* 8218E1F0h */ case   10:  		/* mr R3, R14 */
		/* 8218E1F0h case   10:*/		regs.R3 = regs.R14;
		/* 8218E1F0h case   10:*/		return 0x8218E1F4;
		  /* 8218E1F4h */ case   11:  		/* and R4, R10, R11 */
		/* 8218E1F4h case   11:*/		cpu::op::and<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 8218E1F4h case   11:*/		return 0x8218E1F8;
		  /* 8218E1F8h */ case   12:  		/* bl 616352 */
		/* 8218E1F8h case   12:*/		regs.LR = 0x8218E1FC; return 0x82224998;
		/* 8218E1F8h case   12:*/		return 0x8218E1FC;
		  /* 8218E1FCh */ case   13:  		/* lwz R10, <#[R14 + 4]> */
		/* 8218E1FCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000004) );
		/* 8218E1FCh case   13:*/		return 0x8218E200;
		  /* 8218E200h */ case   14:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 8218E200h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 8218E200h case   14:*/		return 0x8218E204;
		  /* 8218E204h */ case   15:  		/* rlwinm R9, R10, 0, 31, 31 */
		/* 8218E204h case   15:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R10);
		/* 8218E204h case   15:*/		return 0x8218E208;
	}
	return 0x8218E208;
} // Block from 8218E1C8h-8218E208h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8218E208h
// Function '?AssociateErrorData@Compiler@D3DXShader@@QAAXPAX0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E208);
		  /* 8218E208h */ case    0:  		/* addi R11, R11, 36 */
		/* 8218E208h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 8218E208h case    0:*/		return 0x8218E20C;
		  /* 8218E20Ch */ case    1:  		/* addic R9, R9, -1 */
		/* 8218E20Ch case    1:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8218E20Ch case    1:*/		return 0x8218E210;
		  /* 8218E210h */ case    2:  		/* addi R7, R11, -36 */
		/* 8218E210h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 8218E210h case    2:*/		return 0x8218E214;
		  /* 8218E214h */ case    3:  		/* subfe R8, R9, R9 */
		/* 8218E214h case    3:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R9,regs.R9);
		/* 8218E214h case    3:*/		return 0x8218E218;
		  /* 8218E218h */ case    4:  		/* addi R9, R11, 4 */
		/* 8218E218h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 8218E218h case    4:*/		return 0x8218E21C;
		  /* 8218E21Ch */ case    5:  		/* and R10, R8, R10 */
		/* 8218E21Ch case    5:*/		cpu::op::and<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8218E21Ch case    5:*/		return 0x8218E220;
		  /* 8218E220h */ case    6:  		/* mr R31, R3 */
		/* 8218E220h case    6:*/		regs.R31 = regs.R3;
		/* 8218E220h case    6:*/		return 0x8218E224;
		  /* 8218E224h */ case    7:  		/* addi R8, R10, 24 */
		/* 8218E224h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x18);
		/* 8218E224h case    7:*/		return 0x8218E228;
		  /* 8218E228h */ case    8:  		/* addi R8, R8, 4 */
		/* 8218E228h case    8:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 8218E228h case    8:*/		return 0x8218E22C;
		  /* 8218E22Ch */ case    9:  		/* lwz R6, <#[R10 + 28]> */
		/* 8218E22Ch case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x0000001C) );
		/* 8218E22Ch case    9:*/		return 0x8218E230;
		  /* 8218E230h */ case   10:  		/* ori R8, R8, 1 */
		/* 8218E230h case   10:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8218E230h case   10:*/		return 0x8218E234;
		  /* 8218E234h */ case   11:  		/* stw R6, <#[R11 + 4]> */
		/* 8218E234h case   11:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 8218E234h case   11:*/		return 0x8218E238;
		  /* 8218E238h */ case   12:  		/* lwz R6, <#[R10 + 28]> */
		/* 8218E238h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x0000001C) );
		/* 8218E238h case   12:*/		return 0x8218E23C;
		  /* 8218E23Ch */ case   13:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 8218E23Ch case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 8218E23Ch case   13:*/		return 0x8218E240;
		  /* 8218E240h */ case   14:  		/* stw R9, <#[R6 + 36]> */
		/* 8218E240h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R6 + 0x00000024) );
		/* 8218E240h case   14:*/		return 0x8218E244;
		  /* 8218E244h */ case   15:  		/* stw R8, <#[R11]> */
		/* 8218E244h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8218E244h case   15:*/		return 0x8218E248;
		  /* 8218E248h */ case   16:  		/* stw R7, <#[R10 + 28]> */
		/* 8218E248h case   16:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x0000001C) );
		/* 8218E248h case   16:*/		return 0x8218E24C;
		  /* 8218E24Ch */ case   17:  		/* lwz R11, <#[R3 + 8]> */
		/* 8218E24Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8218E24Ch case   17:*/		return 0x8218E250;
		  /* 8218E250h */ case   18:  		/* oris R11, R11, 768 */
		/* 8218E250h case   18:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x300);
		/* 8218E250h case   18:*/		return 0x8218E254;
		  /* 8218E254h */ case   19:  		/* stw R11, <#[R3 + 8]> */
		/* 8218E254h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8218E254h case   19:*/		return 0x8218E258;
	}
	return 0x8218E258;
} // Block from 8218E208h-8218E258h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8218E258h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E258);
		  /* 8218E258h */ case    0:  		/* mr R4, R30 */
		/* 8218E258h case    0:*/		regs.R4 = regs.R30;
		/* 8218E258h case    0:*/		return 0x8218E25C;
		  /* 8218E25Ch */ case    1:  		/* mr R3, R14 */
		/* 8218E25Ch case    1:*/		regs.R3 = regs.R14;
		/* 8218E25Ch case    1:*/		return 0x8218E260;
		  /* 8218E260h */ case    2:  		/* bl -90720 */
		/* 8218E260h case    2:*/		regs.LR = 0x8218E264; return 0x82178000;
		/* 8218E260h case    2:*/		return 0x8218E264;
		  /* 8218E264h */ case    3:  		/* mr R4, R3 */
		/* 8218E264h case    3:*/		regs.R4 = regs.R3;
		/* 8218E264h case    3:*/		return 0x8218E268;
		  /* 8218E268h */ case    4:  		/* mr R3, R31 */
		/* 8218E268h case    4:*/		regs.R3 = regs.R31;
		/* 8218E268h case    4:*/		return 0x8218E26C;
		  /* 8218E26Ch */ case    5:  		/* bl -90276 */
		/* 8218E26Ch case    5:*/		regs.LR = 0x8218E270; return 0x821781C8;
		/* 8218E26Ch case    5:*/		return 0x8218E270;
		  /* 8218E270h */ case    6:  		/* lis R11, -28311 */
		/* 8218E270h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF9169);
		/* 8218E270h case    6:*/		return 0x8218E274;
		  /* 8218E274h */ case    7:  		/* lis R10, 0 */
		/* 8218E274h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 8218E274h case    7:*/		return 0x8218E278;
		  /* 8218E278h */ case    8:  		/* ori R11, R11, 5192 */
		/* 8218E278h case    8:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1448);
		/* 8218E278h case    8:*/		return 0x8218E27C;
		  /* 8218E27Ch */ case    9:  		/* ori R10, R10, 36262 */
		/* 8218E27Ch case    9:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8DA6);
		/* 8218E27Ch case    9:*/		return 0x8218E280;
		  /* 8218E280h */ case   10:  		/* li R9, 1 */
		/* 8218E280h case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8218E280h case   10:*/		return 0x8218E284;
		  /* 8218E284h */ case   11:  		/* rldimi R11, R10, 32, 0 */
		/* 8218E284h case   11:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R11,regs.R10);
		/* 8218E284h case   11:*/		return 0x8218E288;
		  /* 8218E288h */ case   12:  		/* lis R8, 128 */
		/* 8218E288h case   12:*/		cpu::op::lis<0>(regs,&regs.R8,0x80);
		/* 8218E288h case   12:*/		return 0x8218E28C;
		  /* 8218E28Ch */ case   13:  		/* mr R10, R11 */
		/* 8218E28Ch case   13:*/		regs.R10 = regs.R11;
		/* 8218E28Ch case   13:*/		return 0x8218E290;
		  /* 8218E290h */ case   14:  		/* lwz R11, <#[R30 + 8]> */
		/* 8218E290h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8218E290h case   14:*/		return 0x8218E294;
		  /* 8218E294h */ case   15:  		/* rlwinm R7, R11, 18, 29, 31 */
		/* 8218E294h case   15:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R7,regs.R11);
		/* 8218E294h case   15:*/		return 0x8218E298;
		  /* 8218E298h */ case   16:  		/* rlwinm R6, R11, 0, 31, 26 */
		/* 8218E298h case   16:*/		cpu::op::rlwinm<0,0,31,26>(regs,&regs.R6,regs.R11);
		/* 8218E298h case   16:*/		return 0x8218E29C;
		  /* 8218E29Ch */ case   17:  		/* slw R11, R9, R7 */
		/* 8218E29Ch case   17:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R9,regs.R7);
		/* 8218E29Ch case   17:*/		return 0x8218E2A0;
		  /* 8218E2A0h */ case   18:  		/* addi R11, R11, -1 */
		/* 8218E2A0h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8218E2A0h case   18:*/		return 0x8218E2A4;
		  /* 8218E2A4h */ case   19:  		/* rlwinm R6, R6, 0, 18, 14 */
		/* 8218E2A4h case   19:*/		cpu::op::rlwinm<0,0,18,14>(regs,&regs.R6,regs.R6);
		/* 8218E2A4h case   19:*/		return 0x8218E2A8;
		  /* 8218E2A8h */ case   20:  		/* rldicl R9, R11, 0, 32 */
		/* 8218E2A8h case   20:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R11);
		/* 8218E2A8h case   20:*/		return 0x8218E2AC;
		  /* 8218E2ACh */ case   21:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 8218E2ACh case   21:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 8218E2ACh case   21:*/		return 0x8218E2B0;
		  /* 8218E2B0h */ case   22:  		/* srd R10, R10, R9 */
		/* 8218E2B0h case   22:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8218E2B0h case   22:*/		return 0x8218E2B4;
		  /* 8218E2B4h */ case   23:  		/* srd R10, R10, R9 */
		/* 8218E2B4h case   23:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8218E2B4h case   23:*/		return 0x8218E2B8;
		  /* 8218E2B8h */ case   24:  		/* srd R10, R10, R9 */
		/* 8218E2B8h case   24:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8218E2B8h case   24:*/		return 0x8218E2BC;
		  /* 8218E2BCh */ case   25:  		/* rlwimi R8, R10, 13, 16, 18 */
		/* 8218E2BCh case   25:*/		cpu::op::rlwimi<0,13,16,18>(regs,&regs.R8,regs.R10);
		/* 8218E2BCh case   25:*/		return 0x8218E2C0;
		  /* 8218E2C0h */ case   26:  		/* or R11, R8, R11 */
		/* 8218E2C0h case   26:*/		cpu::op::or<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 8218E2C0h case   26:*/		return 0x8218E2C4;
		  /* 8218E2C4h */ case   27:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 8218E2C4h case   27:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 8218E2C4h case   27:*/		return 0x8218E2C8;
		  /* 8218E2C8h */ case   28:  		/* or R11, R11, R6 */
		/* 8218E2C8h case   28:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 8218E2C8h case   28:*/		return 0x8218E2CC;
		  /* 8218E2CCh */ case   29:  		/* stw R11, <#[R30 + 8]> */
		/* 8218E2CCh case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8218E2CCh case   29:*/		return 0x8218E2D0;
	}
	return 0x8218E2D0;
} // Block from 8218E258h-8218E2D0h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8218E2D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E2D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E2D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E2D0);
		  /* 8218E2D0h */ case    0:  		/* lwz R11, <#[R27]> */
		/* 8218E2D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8218E2D0h case    0:*/		return 0x8218E2D4;
		  /* 8218E2D4h */ case    1:  		/* addi R29, R29, 1 */
		/* 8218E2D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8218E2D4h case    1:*/		return 0x8218E2D8;
		  /* 8218E2D8h */ case    2:  		/* rlwinm R11, R11, 29, 18, 31 */
		/* 8218E2D8h case    2:*/		cpu::op::rlwinm<0,29,18,31>(regs,&regs.R11,regs.R11);
		/* 8218E2D8h case    2:*/		return 0x8218E2DC;
		  /* 8218E2DCh */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 8218E2DCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8218E2DCh case    3:*/		return 0x8218E2E0;
		  /* 8218E2E0h */ case    4:  		/* bc 12, CR6_LT, -348 */
		/* 8218E2E0h case    4:*/		if ( regs.CR[6].lt ) { return 0x8218E184;  }
		/* 8218E2E0h case    4:*/		return 0x8218E2E4;
	}
	return 0x8218E2E4;
} // Block from 8218E2D0h-8218E2E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218E2E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E2E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E2E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E2E4);
		  /* 8218E2E4h */ case    0:  		/* lwz R11, <#[R14 + 16]> */
		/* 8218E2E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000010) );
		/* 8218E2E4h case    0:*/		return 0x8218E2E8;
		  /* 8218E2E8h */ case    1:  		/* addi R28, R28, 1 */
		/* 8218E2E8h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8218E2E8h case    1:*/		return 0x8218E2EC;
		  /* 8218E2ECh */ case    2:  		/* addi R26, R26, 40 */
		/* 8218E2ECh case    2:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x28);
		/* 8218E2ECh case    2:*/		return 0x8218E2F0;
		  /* 8218E2F0h */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 8218E2F0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 8218E2F0h case    3:*/		return 0x8218E2F4;
		  /* 8218E2F4h */ case    4:  		/* bc 12, CR6_LT, -416 */
		/* 8218E2F4h case    4:*/		if ( regs.CR[6].lt ) { return 0x8218E154;  }
		/* 8218E2F4h case    4:*/		return 0x8218E2F8;
	}
	return 0x8218E2F8;
} // Block from 8218E2E4h-8218E2F8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218E2F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E2F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E2F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E2F8);
		  /* 8218E2F8h */ case    0:  		/* lwz R11, <#[R14 + 4]> */
		/* 8218E2F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000004) );
		/* 8218E2F8h case    0:*/		return 0x8218E2FC;
		  /* 8218E2FCh */ case    1:  		/* mr R16, R17 */
		/* 8218E2FCh case    1:*/		regs.R16 = regs.R17;
		/* 8218E2FCh case    1:*/		return 0x8218E300;
		  /* 8218E300h */ case    2:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8218E300h case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8218E300h case    2:*/		return 0x8218E304;
		  /* 8218E304h */ case    3:  		/* addic R10, R10, -1 */
		/* 8218E304h case    3:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8218E304h case    3:*/		return 0x8218E308;
	}
	return 0x8218E308;
} // Block from 8218E2F8h-8218E308h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218E308h
// Function '?ComputeGlobalVariableLayout@Compiler@D3DXShader@@AAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E308);
		  /* 8218E308h */ case    0:  		/* subfe R10, R10, R10 */
		/* 8218E308h case    0:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8218E308h case    0:*/		return 0x8218E30C;
		  /* 8218E30Ch */ case    1:  		/* and R11, R10, R11 */
		/* 8218E30Ch case    1:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218E30Ch case    1:*/		return 0x8218E310;
		  /* 8218E310h */ case    2:  		/* lwz R11, <#[R11 + 20]> */
		/* 8218E310h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8218E310h case    2:*/		return 0x8218E314;
		  /* 8218E314h */ case    3:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8218E314h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8218E314h case    3:*/		return 0x8218E318;
		  /* 8218E318h */ case    4:  		/* bc 4, CR0_EQ, 1424 */
		/* 8218E318h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8218E8A8;  }
		/* 8218E318h case    4:*/		return 0x8218E31C;
		  /* 8218E31Ch */ case    5:  		/* mr R21, R11 */
		/* 8218E31Ch case    5:*/		regs.R21 = regs.R11;
		/* 8218E31Ch case    5:*/		return 0x8218E320;
		  /* 8218E320h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 8218E320h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8218E320h case    6:*/		return 0x8218E324;
		  /* 8218E324h */ case    7:  		/* bc 12, CR0_EQ, 1412 */
		/* 8218E324h case    7:*/		if ( regs.CR[0].eq ) { return 0x8218E8A8;  }
		/* 8218E324h case    7:*/		return 0x8218E328;
		  /* 8218E328h */ case    8:  		/* lwz R11, <#[R21 + 8]> */
		/* 8218E328h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 8218E328h case    8:*/		return 0x8218E32C;
		  /* 8218E32Ch */ case    9:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8218E32Ch case    9:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8218E32Ch case    9:*/		return 0x8218E330;
		  /* 8218E330h */ case   10:  		/* cmplwi CR6, R11, 15872 */
		/* 8218E330h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E00);
		/* 8218E330h case   10:*/		return 0x8218E334;
		  /* 8218E334h */ case   11:  		/* bc 4, CR6_EQ, 1256 */
		/* 8218E334h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8218E81C;  }
		/* 8218E334h case   11:*/		return 0x8218E338;
		  /* 8218E338h */ case   12:  		/* lwz R11, <#[R21 + 8]> */
		/* 8218E338h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 8218E338h case   12:*/		return 0x8218E33C;
		  /* 8218E33Ch */ case   13:  		/* mr R3, R14 */
		/* 8218E33Ch case   13:*/		regs.R3 = regs.R14;
		/* 8218E33Ch case   13:*/		return 0x8218E340;
		  /* 8218E340h */ case   14:  		/* addi R22, R21, -8 */
		/* 8218E340h case   14:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R21,0xFFFFFFF8);
		/* 8218E340h case   14:*/		return 0x8218E344;
		  /* 8218E344h */ case   15:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8218E344h case   15:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8218E344h case   15:*/		return 0x8218E348;
		  /* 8218E348h */ case   16:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8218E348h case   16:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8218E348h case   16:*/		return 0x8218E34C;
		  /* 8218E34Ch */ case   17:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8218E34Ch case   17:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8218E34Ch case   17:*/		return 0x8218E350;
		  /* 8218E350h */ case   18:  		/* bl -171808 */
		/* 8218E350h case   18:*/		regs.LR = 0x8218E354; return 0x82164430;
		/* 8218E350h case   18:*/		return 0x8218E354;
		  /* 8218E354h */ case   19:  		/* lwzx R11, <#[R3 + R22]> */
		/* 8218E354h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R22 + 0x00000000) );
		/* 8218E354h case   19:*/		return 0x8218E358;
		  /* 8218E358h */ case   20:  		/* lwz R10, <#[R21 + 8]> */
		/* 8218E358h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R21 + 0x00000008) );
		/* 8218E358h case   20:*/		return 0x8218E35C;
		  /* 8218E35Ch */ case   21:  		/* mr R3, R14 */
		/* 8218E35Ch case   21:*/		regs.R3 = regs.R14;
		/* 8218E35Ch case   21:*/		return 0x8218E360;
		  /* 8218E360h */ case   22:  		/* rlwinm R30, R11, 0, 17, 31 */
		/* 8218E360h case   22:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R30,regs.R11);
		/* 8218E360h case   22:*/		return 0x8218E364;
		  /* 8218E364h */ case   23:  		/* lwz R11, <#[R14 + 12]> */
		/* 8218E364h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218E364h case   23:*/		return 0x8218E368;
		  /* 8218E368h */ case   24:  		/* rlwinm R6, R10, 18, 29, 31 */
		/* 8218E368h case   24:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R10);
		/* 8218E368h case   24:*/		return 0x8218E36C;
		  /* 8218E36Ch */ case   25:  		/* mulli R20, R30, 40 */
		/* 8218E36Ch case   25:*/		cpu::op::mulli<0>(regs,&regs.R20,regs.R30,0x28);
		/* 8218E36Ch case   25:*/		return 0x8218E370;
		  /* 8218E370h */ case   26:  		/* rlwinm R5, R10, 13, 29, 31 */
		/* 8218E370h case   26:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R10);
		/* 8218E370h case   26:*/		return 0x8218E374;
		  /* 8218E374h */ case   27:  		/* rlwinm R4, R10, 25, 25, 31 */
		/* 8218E374h case   27:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R10);
		/* 8218E374h case   27:*/		return 0x8218E378;
		  /* 8218E378h */ case   28:  		/* add R25, R20, R11 */
		/* 8218E378h case   28:*/		cpu::op::add<0>(regs,&regs.R25,regs.R20,regs.R11);
		/* 8218E378h case   28:*/		return 0x8218E37C;
		  /* 8218E37Ch */ case   29:  		/* bl -171852 */
		/* 8218E37Ch case   29:*/		regs.LR = 0x8218E380; return 0x82164430;
		/* 8218E37Ch case   29:*/		return 0x8218E380;
		  /* 8218E380h */ case   30:  		/* lwzx R11, <#[R3 + R22]> */
		/* 8218E380h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R22 + 0x00000000) );
		/* 8218E380h case   30:*/		return 0x8218E384;
		  /* 8218E384h */ case   31:  		/* lwz R31, <#[R21 + 4]> */
		/* 8218E384h case   31:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R21 + 0x00000004) );
		/* 8218E384h case   31:*/		return 0x8218E388;
		  /* 8218E388h */ case   32:  		/* addi R19, R21, 4 */
		/* 8218E388h case   32:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R21,0x4);
		/* 8218E388h case   32:*/		return 0x8218E38C;
		  /* 8218E38Ch */ case   33:  		/* rlwinm R11, R11, 17, 18, 31 */
		/* 8218E38Ch case   33:*/		cpu::op::rlwinm<0,17,18,31>(regs,&regs.R11,regs.R11);
		/* 8218E38Ch case   33:*/		return 0x8218E390;
		  /* 8218E390h */ case   34:  		/* mr R28, R17 */
		/* 8218E390h case   34:*/		regs.R28 = regs.R17;
		/* 8218E390h case   34:*/		return 0x8218E394;
		  /* 8218E394h */ case   35:  		/* addi R18, R11, 1 */
		/* 8218E394h case   35:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R11,0x1);
		/* 8218E394h case   35:*/		return 0x8218E398;
		  /* 8218E398h */ case   36:  		/* cmplwi CR6, R31, 0 */
		/* 8218E398h case   36:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8218E398h case   36:*/		return 0x8218E39C;
		  /* 8218E39Ch */ case   37:  		/* bc 12, CR6_EQ, 96 */
		/* 8218E39Ch case   37:*/		if ( regs.CR[6].eq ) { return 0x8218E3FC;  }
		/* 8218E39Ch case   37:*/		return 0x8218E3A0;
		  /* 8218E3A0h */ case   38:  		/* lwz R3, <#[R31 + 16]> */
		/* 8218E3A0h case   38:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8218E3A0h case   38:*/		return 0x8218E3A4;
		  /* 8218E3A4h */ case   39:  		/* cmplwi CR6, R3, 0 */
		/* 8218E3A4h case   39:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8218E3A4h case   39:*/		return 0x8218E3A8;
		  /* 8218E3A8h */ case   40:  		/* bc 12, CR6_EQ, 76 */
		/* 8218E3A8h case   40:*/		if ( regs.CR[6].eq ) { return 0x8218E3F4;  }
		/* 8218E3A8h case   40:*/		return 0x8218E3AC;
		  /* 8218E3ACh */ case   41:  		/* lwz R11, <#[R31]> */
		/* 8218E3ACh case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8218E3ACh case   41:*/		return 0x8218E3B0;
		  /* 8218E3B0h */ case   42:  		/* rlwinm. R10, R11, 0, 4, 6 */
		/* 8218E3B0h case   42:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R11);
		/* 8218E3B0h case   42:*/		return 0x8218E3B4;
		  /* 8218E3B4h */ case   43:  		/* bc 12, CR0_EQ, 64 */
		/* 8218E3B4h case   43:*/		if ( regs.CR[0].eq ) { return 0x8218E3F4;  }
		/* 8218E3B4h case   43:*/		return 0x8218E3B8;
		  /* 8218E3B8h */ case   44:  		/* rlwinm. R11, R11, 0, 27, 28 */
		/* 8218E3B8h case   44:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R11);
		/* 8218E3B8h case   44:*/		return 0x8218E3BC;
		  /* 8218E3BCh */ case   45:  		/* bc 12, CR0_EQ, 40 */
		/* 8218E3BCh case   45:*/		if ( regs.CR[0].eq ) { return 0x8218E3E4;  }
		/* 8218E3BCh case   45:*/		return 0x8218E3C0;
		  /* 8218E3C0h */ case   46:  		/* lwz R10, <#[R25]> */
		/* 8218E3C0h case   46:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000000) );
		/* 8218E3C0h case   46:*/		return 0x8218E3C4;
		  /* 8218E3C4h */ case   47:  		/* lwz R11, <#[R25 + 28]> */
		/* 8218E3C4h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000001C) );
		/* 8218E3C4h case   47:*/		return 0x8218E3C8;
		  /* 8218E3C8h */ case   48:  		/* rlwinm R10, R10, 0, 15, 28 */
		/* 8218E3C8h case   48:*/		cpu::op::rlwinm<0,0,15,28>(regs,&regs.R10,regs.R10);
		/* 8218E3C8h case   48:*/		return 0x8218E3CC;
		  /* 8218E3CCh */ case   49:  		/* add R11, R10, R11 */
		/* 8218E3CCh case   49:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218E3CCh case   49:*/		return 0x8218E3D0;
		  /* 8218E3D0h */ case   50:  		/* lwz R11, <#[R11 - 8]> */
		/* 8218E3D0h case   50:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 8218E3D0h case   50:*/		return 0x8218E3D4;
		  /* 8218E3D4h */ case   51:  		/* rlwinm R11, R11, 28, 18, 31 */
		/* 8218E3D4h case   51:*/		cpu::op::rlwinm<0,28,18,31>(regs,&regs.R11,regs.R11);
		/* 8218E3D4h case   51:*/		return 0x8218E3D8;
		  /* 8218E3D8h */ case   52:  		/* cmplwi CR6, R11, 255 */
		/* 8218E3D8h case   52:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000FF);
		/* 8218E3D8h case   52:*/		return 0x8218E3DC;
		  /* 8218E3DCh */ case   53:  		/* bc 12, CR6_GT, 1296 */
		/* 8218E3DCh case   53:*/		if ( regs.CR[6].gt ) { return 0x8218E8EC;  }
		/* 8218E3DCh case   53:*/		return 0x8218E3E0;
		  /* 8218E3E0h */ case   54:  		/* addi R18, R11, 1 */
		/* 8218E3E0h case   54:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R11,0x1);
		/* 8218E3E0h case   54:*/		return 0x8218E3E4;
	}
	return 0x8218E3E4;
} // Block from 8218E308h-8218E3E4h (55 instructions)

//////////////////////////////////////////////////////
// Block at 8218E3E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E3E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E3E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E3E4);
		  /* 8218E3E4h */ case    0:  		/* bl -12324 */
		/* 8218E3E4h case    0:*/		regs.LR = 0x8218E3E8; return 0x8218B3C0;
		/* 8218E3E4h case    0:*/		return 0x8218E3E8;
		  /* 8218E3E8h */ case    1:  		/* li R11, 1 */
		/* 8218E3E8h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218E3E8h case    1:*/		return 0x8218E3EC;
		  /* 8218E3ECh */ case    2:  		/* slw R11, R11, R3 */
		/* 8218E3ECh case    2:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8218E3ECh case    2:*/		return 0x8218E3F0;
		  /* 8218E3F0h */ case    3:  		/* or R28, R11, R28 */
		/* 8218E3F0h case    3:*/		cpu::op::or<0>(regs,&regs.R28,regs.R11,regs.R28);
		/* 8218E3F0h case    3:*/		return 0x8218E3F4;
	}
	return 0x8218E3F4;
} // Block from 8218E3E4h-8218E3F4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218E3F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E3F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E3F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E3F4);
		  /* 8218E3F4h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 8218E3F4h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 8218E3F4h case    0:*/		return 0x8218E3F8;
		  /* 8218E3F8h */ case    1:  		/* b -96 */
		/* 8218E3F8h case    1:*/		return 0x8218E398;
		/* 8218E3F8h case    1:*/		return 0x8218E3FC;
	}
	return 0x8218E3FC;
} // Block from 8218E3F4h-8218E3FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218E3FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E3FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E3FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E3FC);
		  /* 8218E3FCh */ case    0:  		/* lwz R11, <#[R25 + 4]> */
		/* 8218E3FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 8218E3FCh case    0:*/		return 0x8218E400;
		  /* 8218E400h */ case    1:  		/* rlwinm R10, R11, 28, 29, 31 */
		/* 8218E400h case    1:*/		cpu::op::rlwinm<0,28,29,31>(regs,&regs.R10,regs.R11);
		/* 8218E400h case    1:*/		return 0x8218E404;
		  /* 8218E404h */ case    2:  		/* cmplwi CR6, R10, 7 */
		/* 8218E404h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000007);
		/* 8218E404h case    2:*/		return 0x8218E408;
		  /* 8218E408h */ case    3:  		/* bc 12, CR6_EQ, 44 */
		/* 8218E408h case    3:*/		if ( regs.CR[6].eq ) { return 0x8218E434;  }
		/* 8218E408h case    3:*/		return 0x8218E40C;
		  /* 8218E40Ch */ case    4:  		/* cmplwi CR6, R10, 3 */
		/* 8218E40Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 8218E40Ch case    4:*/		return 0x8218E410;
		  /* 8218E410h */ case    5:  		/* bc 4, CR6_EQ, 24 */
		/* 8218E410h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8218E428;  }
		/* 8218E410h case    5:*/		return 0x8218E414;
		  /* 8218E414h */ case    6:  		/* cmplwi CR6, R28, 64 */
		/* 8218E414h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000040);
		/* 8218E414h case    6:*/		return 0x8218E418;
		  /* 8218E418h */ case    7:  		/* bc 4, CR6_EQ, 16 */
		/* 8218E418h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8218E428;  }
		/* 8218E418h case    7:*/		return 0x8218E41C;
		  /* 8218E41Ch */ case    8:  		/* rlwimi R11, R10, 5, 25, 27 */
		/* 8218E41Ch case    8:*/		cpu::op::rlwimi<0,5,25,27>(regs,&regs.R11,regs.R10);
		/* 8218E41Ch case    8:*/		return 0x8218E420;
		  /* 8218E420h */ case    9:  		/* stw R11, <#[R25 + 4]> */
		/* 8218E420h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 8218E420h case    9:*/		return 0x8218E424;
		  /* 8218E424h */ case   10:  		/* b 16 */
		/* 8218E424h case   10:*/		return 0x8218E434;
		/* 8218E424h case   10:*/		return 0x8218E428;
	}
	return 0x8218E428;
} // Block from 8218E3FCh-8218E428h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8218E428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E428);
		  /* 8218E428h */ case    0:  		/* li R11, 1 */
		/* 8218E428h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218E428h case    0:*/		return 0x8218E42C;
		  /* 8218E42Ch */ case    1:  		/* slw R11, R11, R10 */
		/* 8218E42Ch case    1:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8218E42Ch case    1:*/		return 0x8218E430;
		  /* 8218E430h */ case    2:  		/* or R28, R11, R28 */
		/* 8218E430h case    2:*/		cpu::op::or<0>(regs,&regs.R28,regs.R11,regs.R28);
		/* 8218E430h case    2:*/		return 0x8218E434;
	}
	return 0x8218E434;
} // Block from 8218E428h-8218E434h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218E434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E434);
		  /* 8218E434h */ case    0:  		/* rlwinm. R11, R28, 0, 24, 24 */
		/* 8218E434h case    0:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R28);
		/* 8218E434h case    0:*/		return 0x8218E438;
		  /* 8218E438h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8218E438h case    1:*/		if ( regs.CR[0].eq ) { return 0x8218E448;  }
		/* 8218E438h case    1:*/		return 0x8218E43C;
		  /* 8218E43Ch */ case    2:  		/* rlwinm. R28, R28, 0, 25, 23 */
		/* 8218E43Ch case    2:*/		cpu::op::rlwinm<1,0,25,23>(regs,&regs.R28,regs.R28);
		/* 8218E43Ch case    2:*/		return 0x8218E440;
		  /* 8218E440h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 8218E440h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8218E450;  }
		/* 8218E440h case    3:*/		return 0x8218E444;
		  /* 8218E444h */ case    4:  		/* li R28, 4 */
		/* 8218E444h case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x4);
		/* 8218E444h case    4:*/		return 0x8218E448;
	}
	return 0x8218E448;
} // Block from 8218E434h-8218E448h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218E448h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E448);
		  /* 8218E448h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 8218E448h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8218E448h case    0:*/		return 0x8218E44C;
		  /* 8218E44Ch */ case    1:  		/* bc 12, CR6_EQ, 548 */
		/* 8218E44Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8218E670;  }
		/* 8218E44Ch case    1:*/		return 0x8218E450;
	}
	return 0x8218E450;
} // Block from 8218E448h-8218E450h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218E450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E450);
		  /* 8218E450h */ case    0:  		/* addi R11, R28, -1 */
		/* 8218E450h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0xFFFFFFFF);
		/* 8218E450h case    0:*/		return 0x8218E454;
		  /* 8218E454h */ case    1:  		/* andc R11, R28, R11 */
		/* 8218E454h case    1:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 8218E454h case    1:*/		return 0x8218E458;
		  /* 8218E458h */ case    2:  		/* subf R11, R11, R28 */
		/* 8218E458h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 8218E458h case    2:*/		return 0x8218E45C;
		  /* 8218E45Ch */ case    3:  		/* cntlzw R11, R11 */
		/* 8218E45Ch case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8218E45Ch case    3:*/		return 0x8218E460;
		  /* 8218E460h */ case    4:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 8218E460h case    4:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8218E460h case    4:*/		return 0x8218E464;
		  /* 8218E464h */ case    5:  		/* bc 4, CR0_EQ, 472 */
		/* 8218E464h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8218E63C;  }
		/* 8218E464h case    5:*/		return 0x8218E468;
		  /* 8218E468h */ case    6:  		/* lwz R31, <#[R25]> */
		/* 8218E468h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R25 + 0x00000000) );
		/* 8218E468h case    6:*/		return 0x8218E46C;
		  /* 8218E46Ch */ case    7:  		/* rlwinm. R11, R31, 0, 12, 12 */
		/* 8218E46Ch case    7:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R11,regs.R31);
		/* 8218E46Ch case    7:*/		return 0x8218E470;
		  /* 8218E470h */ case    8:  		/* bc 4, CR0_EQ, 1256 */
		/* 8218E470h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8218E958;  }
		/* 8218E470h case    8:*/		return 0x8218E474;
		  /* 8218E474h */ case    9:  		/* lwz R11, <#[R25 + 36]> */
		/* 8218E474h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000024) );
		/* 8218E474h case    9:*/		return 0x8218E478;
		  /* 8218E478h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 8218E478h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218E478h case   10:*/		return 0x8218E47C;
		  /* 8218E47Ch */ case   11:  		/* bc 4, CR6_EQ, 1244 */
		/* 8218E47Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x8218E958;  }
		/* 8218E47Ch case   11:*/		return 0x8218E480;
		  /* 8218E480h */ case   12:  		/* rlwinm R11, R31, 0, 15, 28 */
		/* 8218E480h case   12:*/		cpu::op::rlwinm<0,0,15,28>(regs,&regs.R11,regs.R31);
		/* 8218E480h case   12:*/		return 0x8218E484;
		  /* 8218E484h */ case   13:  		/* cmplwi CR6, R11, 8 */
		/* 8218E484h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000008);
		/* 8218E484h case   13:*/		return 0x8218E488;
		  /* 8218E488h */ case   14:  		/* bc 4, CR6_EQ, 1136 */
		/* 8218E488h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8218E8F8;  }
		/* 8218E488h case   14:*/		return 0x8218E48C;
		  /* 8218E48Ch */ case   15:  		/* cmplwi CR6, R28, 0 */
		/* 8218E48Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8218E48Ch case   15:*/		return 0x8218E490;
		  /* 8218E490h */ case   16:  		/* bc 12, CR6_EQ, 24 */
		/* 8218E490h case   16:*/		if ( regs.CR[6].eq ) { return 0x8218E4A8;  }
		/* 8218E490h case   16:*/		return 0x8218E494;
		  /* 8218E494h */ case   17:  		/* addi R11, R28, -1 */
		/* 8218E494h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0xFFFFFFFF);
		/* 8218E494h case   17:*/		return 0x8218E498;
		  /* 8218E498h */ case   18:  		/* andc R11, R28, R11 */
		/* 8218E498h case   18:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 8218E498h case   18:*/		return 0x8218E49C;
		  /* 8218E49Ch */ case   19:  		/* subf. R11, R11, R28 */
		/* 8218E49Ch case   19:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R11,regs.R28);
		/* 8218E49Ch case   19:*/		return 0x8218E4A0;
		  /* 8218E4A0h */ case   20:  		/* li R11, 1 */
		/* 8218E4A0h case   20:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218E4A0h case   20:*/		return 0x8218E4A4;
		  /* 8218E4A4h */ case   21:  		/* bc 12, CR0_EQ, 8 */
		/* 8218E4A4h case   21:*/		if ( regs.CR[0].eq ) { return 0x8218E4AC;  }
		/* 8218E4A4h case   21:*/		return 0x8218E4A8;
	}
	return 0x8218E4A8;
} // Block from 8218E450h-8218E4A8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8218E4A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E4A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E4A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E4A8);
		  /* 8218E4A8h */ case    0:  		/* mr R11, R17 */
		/* 8218E4A8h case    0:*/		regs.R11 = regs.R17;
		/* 8218E4A8h case    0:*/		return 0x8218E4AC;
	}
	return 0x8218E4AC;
} // Block from 8218E4A8h-8218E4ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218E4ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E4AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E4AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E4AC);
		  /* 8218E4ACh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8218E4ACh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8218E4ACh case    0:*/		return 0x8218E4B0;
		  /* 8218E4B0h */ case    1:  		/* bc 4, CR0_EQ, 388 */
		/* 8218E4B0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8218E634;  }
		/* 8218E4B0h case    1:*/		return 0x8218E4B4;
		  /* 8218E4B4h */ case    2:  		/* addi R11, R28, -1 */
		/* 8218E4B4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0xFFFFFFFF);
		/* 8218E4B4h case    2:*/		return 0x8218E4B8;
		  /* 8218E4B8h */ case    3:  		/* mr R4, R25 */
		/* 8218E4B8h case    3:*/		regs.R4 = regs.R25;
		/* 8218E4B8h case    3:*/		return 0x8218E4BC;
		  /* 8218E4BCh */ case    4:  		/* andc R11, R28, R11 */
		/* 8218E4BCh case    4:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 8218E4BCh case    4:*/		return 0x8218E4C0;
		  /* 8218E4C0h */ case    5:  		/* mr R3, R14 */
		/* 8218E4C0h case    5:*/		regs.R3 = regs.R14;
		/* 8218E4C0h case    5:*/		return 0x8218E4C4;
		  /* 8218E4C4h */ case    6:  		/* cntlzw R10, R11 */
		/* 8218E4C4h case    6:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R11);
		/* 8218E4C4h case    6:*/		return 0x8218E4C8;
		  /* 8218E4C8h */ case    7:  		/* subf R28, R11, R28 */
		/* 8218E4C8h case    7:*/		cpu::op::subf<0>(regs,&regs.R28,regs.R11,regs.R28);
		/* 8218E4C8h case    7:*/		return 0x8218E4CC;
		  /* 8218E4CCh */ case    8:  		/* subfic R24, R10, 31 */
		/* 8218E4CCh case    8:*/		cpu::op::subfic<0>(regs,&regs.R24,regs.R10,0x1F);
		/* 8218E4CCh case    8:*/		return 0x8218E4D0;
		  /* 8218E4D0h */ case    9:  		/* mr R5, R24 */
		/* 8218E4D0h case    9:*/		regs.R5 = regs.R24;
		/* 8218E4D0h case    9:*/		return 0x8218E4D4;
		  /* 8218E4D4h */ case   10:  		/* bl 618756 */
		/* 8218E4D4h case   10:*/		regs.LR = 0x8218E4D8; return 0x822255D8;
		/* 8218E4D4h case   10:*/		return 0x8218E4D8;
		  /* 8218E4D8h */ case   11:  		/* lwz R11, <#[R21 + 8]> */
		/* 8218E4D8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 8218E4D8h case   11:*/		return 0x8218E4DC;
		  /* 8218E4DCh */ case   12:  		/* mr R27, R3 */
		/* 8218E4DCh case   12:*/		regs.R27 = regs.R3;
		/* 8218E4DCh case   12:*/		return 0x8218E4E0;
		  /* 8218E4E0h */ case   13:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8218E4E0h case   13:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8218E4E0h case   13:*/		return 0x8218E4E4;
		  /* 8218E4E4h */ case   14:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8218E4E4h case   14:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8218E4E4h case   14:*/		return 0x8218E4E8;
		  /* 8218E4E8h */ case   15:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8218E4E8h case   15:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8218E4E8h case   15:*/		return 0x8218E4EC;
		  /* 8218E4ECh */ case   16:  		/* mr R3, R14 */
		/* 8218E4ECh case   16:*/		regs.R3 = regs.R14;
		/* 8218E4ECh case   16:*/		return 0x8218E4F0;
		  /* 8218E4F0h */ case   17:  		/* bl -172224 */
		/* 8218E4F0h case   17:*/		regs.LR = 0x8218E4F4; return 0x82164430;
		/* 8218E4F0h case   17:*/		return 0x8218E4F4;
		  /* 8218E4F4h */ case   18:  		/* add R26, R3, R22 */
		/* 8218E4F4h case   18:*/		cpu::op::add<0>(regs,&regs.R26,regs.R3,regs.R22);
		/* 8218E4F4h case   18:*/		return 0x8218E4F8;
		  /* 8218E4F8h */ case   19:  		/* mr R23, R19 */
		/* 8218E4F8h case   19:*/		regs.R23 = regs.R19;
		/* 8218E4F8h case   19:*/		return 0x8218E4FC;
		  /* 8218E4FCh */ case   20:  		/* lwz R31, <#[R23]> */
		/* 8218E4FCh case   20:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R23 + 0x00000000) );
		/* 8218E4FCh case   20:*/		return 0x8218E500;
		  /* 8218E500h */ case   21:  		/* cmplwi CR6, R31, 0 */
		/* 8218E500h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8218E500h case   21:*/		return 0x8218E504;
		  /* 8218E504h */ case   22:  		/* bc 12, CR6_EQ, -120 */
		/* 8218E504h case   22:*/		if ( regs.CR[6].eq ) { return 0x8218E48C;  }
		/* 8218E504h case   22:*/		return 0x8218E508;
		  /* 8218E508h */ case   23:  		/* lwz R3, <#[R31 + 16]> */
		/* 8218E508h case   23:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8218E508h case   23:*/		return 0x8218E50C;
		  /* 8218E50Ch */ case   24:  		/* cmplwi CR6, R3, 0 */
		/* 8218E50Ch case   24:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8218E50Ch case   24:*/		return 0x8218E510;
		  /* 8218E510h */ case   25:  		/* bc 12, CR6_EQ, 272 */
		/* 8218E510h case   25:*/		if ( regs.CR[6].eq ) { return 0x8218E620;  }
		/* 8218E510h case   25:*/		return 0x8218E514;
		  /* 8218E514h */ case   26:  		/* lwz R29, <#[R31]> */
		/* 8218E514h case   26:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000000) );
		/* 8218E514h case   26:*/		return 0x8218E518;
		  /* 8218E518h */ case   27:  		/* rlwinm. R30, R29, 7, 29, 31 */
		/* 8218E518h case   27:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R30,regs.R29);
		/* 8218E518h case   27:*/		return 0x8218E51C;
		  /* 8218E51Ch */ case   28:  		/* bc 12, CR0_EQ, 260 */
		/* 8218E51Ch case   28:*/		if ( regs.CR[0].eq ) { return 0x8218E620;  }
		/* 8218E51Ch case   28:*/		return 0x8218E520;
		  /* 8218E520h */ case   29:  		/* bl -12640 */
		/* 8218E520h case   29:*/		regs.LR = 0x8218E524; return 0x8218B3C0;
		/* 8218E520h case   29:*/		return 0x8218E524;
		  /* 8218E524h */ case   30:  		/* cmpw CR6, R3, R24 */
		/* 8218E524h case   30:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R24);
		/* 8218E524h case   30:*/		return 0x8218E528;
		  /* 8218E528h */ case   31:  		/* bc 4, CR6_EQ, 248 */
		/* 8218E528h case   31:*/		if ( !regs.CR[6].eq ) { return 0x8218E620;  }
		/* 8218E528h case   31:*/		return 0x8218E52C;
		  /* 8218E52Ch */ case   32:  		/* mr R9, R17 */
		/* 8218E52Ch case   32:*/		regs.R9 = regs.R17;
		/* 8218E52Ch case   32:*/		return 0x8218E530;
		  /* 8218E530h */ case   33:  		/* mr R10, R17 */
		/* 8218E530h case   33:*/		regs.R10 = regs.R17;
		/* 8218E530h case   33:*/		return 0x8218E534;
		  /* 8218E534h */ case   34:  		/* cmplwi CR6, R30, 0 */
		/* 8218E534h case   34:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8218E534h case   34:*/		return 0x8218E538;
		  /* 8218E538h */ case   35:  		/* bc 12, CR6_EQ, 84 */
		/* 8218E538h case   35:*/		if ( regs.CR[6].eq ) { return 0x8218E58C;  }
		/* 8218E538h case   35:*/		return 0x8218E53C;
		  /* 8218E53Ch */ case   36:  		/* rlwinm R7, R29, 0, 0, 31 */
		/* 8218E53Ch case   36:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R7,regs.R29);
		/* 8218E53Ch case   36:*/		return 0x8218E540;
		  /* 8218E540h */ case   37:  		/* rlwinm R8, R29, 27, 24, 31 */
		/* 8218E540h case   37:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R8,regs.R29);
		/* 8218E540h case   37:*/		return 0x8218E544;
		  /* 8218E544h */ case   38:  		/* mr R11, R17 */
		/* 8218E544h case   38:*/		regs.R11 = regs.R17;
		/* 8218E544h case   38:*/		return 0x8218E548;
		  /* 8218E548h */ case   39:  		/* rlwinm R7, R7, 7, 29, 31 */
		/* 8218E548h case   39:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R7,regs.R7);
		/* 8218E548h case   39:*/		return 0x8218E54C;
		  /* 8218E54Ch */ case   40:  		/* srw R6, R8, R11 */
		/* 8218E54Ch case   40:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R8,regs.R11);
		/* 8218E54Ch case   40:*/		return 0x8218E550;
		  /* 8218E550h */ case   41:  		/* rlwinm R6, R6, 0, 30, 31 */
		/* 8218E550h case   41:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R6,regs.R6);
		/* 8218E550h case   41:*/		return 0x8218E554;
		  /* 8218E554h */ case   42:  		/* li R5, 1 */
		/* 8218E554h case   42:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8218E554h case   42:*/		return 0x8218E558;
		  /* 8218E558h */ case   43:  		/* addi R10, R10, 1 */
		/* 8218E558h case   43:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8218E558h case   43:*/		return 0x8218E55C;
		  /* 8218E55Ch */ case   44:  		/* slw R6, R5, R6 */
		/* 8218E55Ch case   44:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R5,regs.R6);
		/* 8218E55Ch case   44:*/		return 0x8218E560;
		  /* 8218E560h */ case   45:  		/* or R9, R6, R9 */
		/* 8218E560h case   45:*/		cpu::op::or<0>(regs,&regs.R9,regs.R6,regs.R9);
		/* 8218E560h case   45:*/		return 0x8218E564;
		  /* 8218E564h */ case   46:  		/* addi R11, R11, 2 */
		/* 8218E564h case   46:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8218E564h case   46:*/		return 0x8218E568;
		  /* 8218E568h */ case   47:  		/* cmplw CR6, R10, R7 */
		/* 8218E568h case   47:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 8218E568h case   47:*/		return 0x8218E56C;
		  /* 8218E56Ch */ case   48:  		/* bc 12, CR6_LT, -32 */
		/* 8218E56Ch case   48:*/		if ( regs.CR[6].lt ) { return 0x8218E54C;  }
		/* 8218E56Ch case   48:*/		return 0x8218E570;
		  /* 8218E570h */ case   49:  		/* cmplwi CR6, R9, 0 */
		/* 8218E570h case   49:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8218E570h case   49:*/		return 0x8218E574;
		  /* 8218E574h */ case   50:  		/* bc 12, CR6_EQ, 24 */
		/* 8218E574h case   50:*/		if ( regs.CR[6].eq ) { return 0x8218E58C;  }
		/* 8218E574h case   50:*/		return 0x8218E578;
		  /* 8218E578h */ case   51:  		/* addi R11, R9, -1 */
		/* 8218E578h case   51:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 8218E578h case   51:*/		return 0x8218E57C;
		  /* 8218E57Ch */ case   52:  		/* andc R11, R9, R11 */
		/* 8218E57Ch case   52:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8218E57Ch case   52:*/		return 0x8218E580;
		  /* 8218E580h */ case   53:  		/* subf. R11, R11, R9 */
		/* 8218E580h case   53:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8218E580h case   53:*/		return 0x8218E584;
		  /* 8218E584h */ case   54:  		/* li R11, 1 */
		/* 8218E584h case   54:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218E584h case   54:*/		return 0x8218E588;
		  /* 8218E588h */ case   55:  		/* bc 12, CR0_EQ, 8 */
		/* 8218E588h case   55:*/		if ( regs.CR[0].eq ) { return 0x8218E590;  }
		/* 8218E588h case   55:*/		return 0x8218E58C;
	}
	return 0x8218E58C;
} // Block from 8218E4ACh-8218E58Ch (56 instructions)

//////////////////////////////////////////////////////
// Block at 8218E58Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E58C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E58C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E58C);
		  /* 8218E58Ch */ case    0:  		/* mr R11, R17 */
		/* 8218E58Ch case    0:*/		regs.R11 = regs.R17;
		/* 8218E58Ch case    0:*/		return 0x8218E590;
	}
	return 0x8218E590;
} // Block from 8218E58Ch-8218E590h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218E590h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E590( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E590) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E590);
		  /* 8218E590h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8218E590h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8218E590h case    0:*/		return 0x8218E594;
		  /* 8218E594h */ case    1:  		/* bc 12, CR0_EQ, 952 */
		/* 8218E594h case    1:*/		if ( regs.CR[0].eq ) { return 0x8218E94C;  }
		/* 8218E594h case    1:*/		return 0x8218E598;
		  /* 8218E598h */ case    2:  		/* lwz R10, <#[R26 + 4]> */
		/* 8218E598h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000004) );
		/* 8218E598h case    2:*/		return 0x8218E59C;
		  /* 8218E59Ch */ case    3:  		/* rlwinm R11, R29, 27, 30, 31 */
		/* 8218E59Ch case    3:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R11,regs.R29);
		/* 8218E59Ch case    3:*/		return 0x8218E5A0;
		  /* 8218E5A0h */ case    4:  		/* lwz R9, <#[R14 + 12]> */
		/* 8218E5A0h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218E5A0h case    4:*/		return 0x8218E5A4;
		  /* 8218E5A4h */ case    5:  		/* li R8, 40 */
		/* 8218E5A4h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x28);
		/* 8218E5A4h case    5:*/		return 0x8218E5A8;
		  /* 8218E5A8h */ case    6:  		/* rlwinm R10, R10, 26, 18, 31 */
		/* 8218E5A8h case    6:*/		cpu::op::rlwinm<0,26,18,31>(regs,&regs.R10,regs.R10);
		/* 8218E5A8h case    6:*/		return 0x8218E5AC;
		  /* 8218E5ACh */ case    7:  		/* subf R9, R9, R27 */
		/* 8218E5ACh case    7:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R9,regs.R27);
		/* 8218E5ACh case    7:*/		return 0x8218E5B0;
		  /* 8218E5B0h */ case    8:  		/* add R5, R10, R11 */
		/* 8218E5B0h case    8:*/		cpu::op::add<0>(regs,&regs.R5,regs.R10,regs.R11);
		/* 8218E5B0h case    8:*/		return 0x8218E5B4;
		  /* 8218E5B4h */ case    9:  		/* divw R4, R9, R8 */
		/* 8218E5B4h case    9:*/		cpu::op::divw<0>(regs,&regs.R4,regs.R9,regs.R8);
		/* 8218E5B4h case    9:*/		return 0x8218E5B8;
		  /* 8218E5B8h */ case   10:  		/* li R6, 1 */
		/* 8218E5B8h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8218E5B8h case   10:*/		return 0x8218E5BC;
		  /* 8218E5BCh */ case   11:  		/* mr R3, R14 */
		/* 8218E5BCh case   11:*/		regs.R3 = regs.R14;
		/* 8218E5BCh case   11:*/		return 0x8218E5C0;
		  /* 8218E5C0h */ case   12:  		/* bl 624480 */
		/* 8218E5C0h case   12:*/		regs.LR = 0x8218E5C4; return 0x82226D20;
		/* 8218E5C0h case   12:*/		return 0x8218E5C4;
		  /* 8218E5C4h */ case   13:  		/* lwz R11, <#[R3 + 8]> */
		/* 8218E5C4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8218E5C4h case   13:*/		return 0x8218E5C8;
		  /* 8218E5C8h */ case   14:  		/* rlwinm R11, R11, 0, 30, 26 */
		/* 8218E5C8h case   14:*/		cpu::op::rlwinm<0,0,30,26>(regs,&regs.R11,regs.R11);
		/* 8218E5C8h case   14:*/		return 0x8218E5CC;
		  /* 8218E5CCh */ case   15:  		/* rlwinm R11, R11, 0, 17, 14 */
		/* 8218E5CCh case   15:*/		cpu::op::rlwinm<0,0,17,14>(regs,&regs.R11,regs.R11);
		/* 8218E5CCh case   15:*/		return 0x8218E5D0;
		  /* 8218E5D0h */ case   16:  		/* oris R11, R11, 256 */
		/* 8218E5D0h case   16:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 8218E5D0h case   16:*/		return 0x8218E5D4;
		  /* 8218E5D4h */ case   17:  		/* ori R11, R11, 16386 */
		/* 8218E5D4h case   17:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4002);
		/* 8218E5D4h case   17:*/		return 0x8218E5D8;
		  /* 8218E5D8h */ case   18:  		/* stw R11, <#[R3 + 8]> */
		/* 8218E5D8h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8218E5D8h case   18:*/		return 0x8218E5DC;
		  /* 8218E5DCh */ case   19:  		/* lwz R11, <#[R31 + 12]> */
		/* 8218E5DCh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8218E5DCh case   19:*/		return 0x8218E5E0;
		  /* 8218E5E0h */ case   20:  		/* addi R11, R11, 4 */
		/* 8218E5E0h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8218E5E0h case   20:*/		return 0x8218E5E4;
		  /* 8218E5E4h */ case   21:  		/* lwz R10, <#[R11]> */
		/* 8218E5E4h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218E5E4h case   21:*/		return 0x8218E5E8;
		  /* 8218E5E8h */ case   22:  		/* b 12 */
		/* 8218E5E8h case   22:*/		return 0x8218E5F4;
		/* 8218E5E8h case   22:*/		return 0x8218E5EC;
		  /* 8218E5ECh */ case   23:  		/* addi R11, R10, 8 */
		/* 8218E5ECh case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 8218E5ECh case   23:*/		return 0x8218E5F0;
		  /* 8218E5F0h */ case   24:  		/* lwz R10, <#[R10 + 8]> */
		/* 8218E5F0h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8218E5F0h case   24:*/		return 0x8218E5F4;
	}
	return 0x8218E5F4;
} // Block from 8218E590h-8218E5F4h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8218E5F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E5F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E5F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E5F4);
		  /* 8218E5F4h */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 8218E5F4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 8218E5F4h case    0:*/		return 0x8218E5F8;
		  /* 8218E5F8h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 8218E5F8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8218E5EC;  }
		/* 8218E5F8h case    1:*/		return 0x8218E5FC;
		  /* 8218E5FCh */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 8218E5FCh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8218E5FCh case    2:*/		return 0x8218E600;
		  /* 8218E600h */ case    3:  		/* stw R10, <#[R11]> */
		/* 8218E600h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218E600h case    3:*/		return 0x8218E604;
		  /* 8218E604h */ case    4:  		/* lwz R11, <#[R3 + 4]> */
		/* 8218E604h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8218E604h case    4:*/		return 0x8218E608;
		  /* 8218E608h */ case    5:  		/* stw R11, <#[R31 + 8]> */
		/* 8218E608h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8218E608h case    5:*/		return 0x8218E60C;
		  /* 8218E60Ch */ case    6:  		/* stw R31, <#[R3 + 4]> */
		/* 8218E60Ch case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000004) );
		/* 8218E60Ch case    6:*/		return 0x8218E610;
		  /* 8218E610h */ case    7:  		/* lwz R11, <#[R31]> */
		/* 8218E610h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8218E610h case    7:*/		return 0x8218E614;
		  /* 8218E614h */ case    8:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 8218E614h case    8:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 8218E614h case    8:*/		return 0x8218E618;
		  /* 8218E618h */ case    9:  		/* stw R3, <#[R31 + 12]> */
		/* 8218E618h case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 8218E618h case    9:*/		return 0x8218E61C;
		  /* 8218E61Ch */ case   10:  		/* stw R11, <#[R31]> */
		/* 8218E61Ch case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8218E61Ch case   10:*/		return 0x8218E620;
	}
	return 0x8218E620;
} // Block from 8218E5F4h-8218E620h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8218E620h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E620);
		  /* 8218E620h */ case    0:  		/* lwz R11, <#[R23]> */
		/* 8218E620h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8218E620h case    0:*/		return 0x8218E624;
		  /* 8218E624h */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 8218E624h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 8218E624h case    1:*/		return 0x8218E628;
		  /* 8218E628h */ case    2:  		/* bc 4, CR6_EQ, -300 */
		/* 8218E628h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8218E4FC;  }
		/* 8218E628h case    2:*/		return 0x8218E62C;
		  /* 8218E62Ch */ case    3:  		/* addi R23, R31, 8 */
		/* 8218E62Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R31,0x8);
		/* 8218E62Ch case    3:*/		return 0x8218E630;
		  /* 8218E630h */ case    4:  		/* b -308 */
		/* 8218E630h case    4:*/		return 0x8218E4FC;
		/* 8218E630h case    4:*/		return 0x8218E634;
	}
	return 0x8218E634;
} // Block from 8218E620h-8218E634h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218E634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E634);
		  /* 8218E634h */ case    0:  		/* lwz R11, <#[R14 + 12]> */
		/* 8218E634h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218E634h case    0:*/		return 0x8218E638;
		  /* 8218E638h */ case    1:  		/* add R25, R20, R11 */
		/* 8218E638h case    1:*/		cpu::op::add<0>(regs,&regs.R25,regs.R20,regs.R11);
		/* 8218E638h case    1:*/		return 0x8218E63C;
	}
	return 0x8218E63C;
} // Block from 8218E634h-8218E63Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218E63Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E63C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E63C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E63C);
		  /* 8218E63Ch */ case    0:  		/* cmplwi CR6, R28, 64 */
		/* 8218E63Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000040);
		/* 8218E63Ch case    0:*/		return 0x8218E640;
		  /* 8218E640h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8218E640h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8218E650;  }
		/* 8218E640h case    1:*/		return 0x8218E644;
		  /* 8218E644h */ case    2:  		/* lwz R11, <#[R25]> */
		/* 8218E644h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 8218E644h case    2:*/		return 0x8218E648;
		  /* 8218E648h */ case    3:  		/* rlwinm. R11, R11, 0, 12, 12 */
		/* 8218E648h case    3:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R11,regs.R11);
		/* 8218E648h case    3:*/		return 0x8218E64C;
		  /* 8218E64Ch */ case    4:  		/* bc 12, CR0_EQ, 876 */
		/* 8218E64Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x8218E9B8;  }
		/* 8218E64Ch case    4:*/		return 0x8218E650;
	}
	return 0x8218E650;
} // Block from 8218E63Ch-8218E650h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218E650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E650);
		  /* 8218E650h */ case    0:  		/* lwz R11, <#[R25 + 4]> */
		/* 8218E650h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 8218E650h case    0:*/		return 0x8218E654;
		  /* 8218E654h */ case    1:  		/* rlwinm R10, R11, 0, 25, 27 */
		/* 8218E654h case    1:*/		cpu::op::rlwinm<0,0,25,27>(regs,&regs.R10,regs.R11);
		/* 8218E654h case    1:*/		return 0x8218E658;
		  /* 8218E658h */ case    2:  		/* cmplwi CR6, R10, 112 */
		/* 8218E658h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000070);
		/* 8218E658h case    2:*/		return 0x8218E65C;
		  /* 8218E65Ch */ case    3:  		/* bc 4, CR6_EQ, 20 */
		/* 8218E65Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8218E670;  }
		/* 8218E65Ch case    3:*/		return 0x8218E660;
		  /* 8218E660h */ case    4:  		/* cntlzw R10, R28 */
		/* 8218E660h case    4:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R28);
		/* 8218E660h case    4:*/		return 0x8218E664;
		  /* 8218E664h */ case    5:  		/* subfic R10, R10, -1 */
		/* 8218E664h case    5:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8218E664h case    5:*/		return 0x8218E668;
		  /* 8218E668h */ case    6:  		/* rlwimi R11, R10, 4, 25, 27 */
		/* 8218E668h case    6:*/		cpu::op::rlwimi<0,4,25,27>(regs,&regs.R11,regs.R10);
		/* 8218E668h case    6:*/		return 0x8218E66C;
		  /* 8218E66Ch */ case    7:  		/* stw R11, <#[R25 + 4]> */
		/* 8218E66Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 8218E66Ch case    7:*/		return 0x8218E670;
	}
	return 0x8218E670;
} // Block from 8218E650h-8218E670h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218E670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E670);
		  /* 8218E670h */ case    0:  		/* lwz R11, <#[R25 + 4]> */
		/* 8218E670h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 8218E670h case    0:*/		return 0x8218E674;
		  /* 8218E674h */ case    1:  		/* rlwinm R10, R11, 25, 23, 31 */
		/* 8218E674h case    1:*/		cpu::op::rlwinm<0,25,23,31>(regs,&regs.R10,regs.R11);
		/* 8218E674h case    1:*/		return 0x8218E678;
		  /* 8218E678h */ case    2:  		/* cmplw CR6, R18, R10 */
		/* 8218E678h case    2:*/		cpu::op::cmplw<6>(regs,regs.R18,regs.R10);
		/* 8218E678h case    2:*/		return 0x8218E67C;
		  /* 8218E67Ch */ case    3:  		/* bc 4, CR6_GT, 12 */
		/* 8218E67Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x8218E688;  }
		/* 8218E67Ch case    3:*/		return 0x8218E680;
		  /* 8218E680h */ case    4:  		/* rlwimi R11, R18, 7, 16, 24 */
		/* 8218E680h case    4:*/		cpu::op::rlwimi<0,7,16,24>(regs,&regs.R11,regs.R18);
		/* 8218E680h case    4:*/		return 0x8218E684;
		  /* 8218E684h */ case    5:  		/* stw R11, <#[R25 + 4]> */
		/* 8218E684h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 8218E684h case    5:*/		return 0x8218E688;
	}
	return 0x8218E688;
} // Block from 8218E670h-8218E688h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218E688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E688);
		  /* 8218E688h */ case    0:  		/* lwz R31, <#[R25 + 4]> */
		/* 8218E688h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R25 + 0x00000004) );
		/* 8218E688h case    0:*/		return 0x8218E68C;
		  /* 8218E68Ch */ case    1:  		/* rlwinm R11, R31, 28, 29, 31 */
		/* 8218E68Ch case    1:*/		cpu::op::rlwinm<0,28,29,31>(regs,&regs.R11,regs.R31);
		/* 8218E68Ch case    1:*/		return 0x8218E690;
		  /* 8218E690h */ case    2:  		/* cmplwi CR6, R11, 3 */
		/* 8218E690h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8218E690h case    2:*/		return 0x8218E694;
		  /* 8218E694h */ case    3:  		/* bc 4, CR6_EQ, 320 */
		/* 8218E694h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8218E7D4;  }
		/* 8218E694h case    3:*/		return 0x8218E698;
		  /* 8218E698h */ case    4:  		/* lwz R11, <#[R21 + 8]> */
		/* 8218E698h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 8218E698h case    4:*/		return 0x8218E69C;
		  /* 8218E69Ch */ case    5:  		/* mr R3, R14 */
		/* 8218E69Ch case    5:*/		regs.R3 = regs.R14;
		/* 8218E69Ch case    5:*/		return 0x8218E6A0;
		  /* 8218E6A0h */ case    6:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8218E6A0h case    6:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8218E6A0h case    6:*/		return 0x8218E6A4;
		  /* 8218E6A4h */ case    7:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8218E6A4h case    7:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8218E6A4h case    7:*/		return 0x8218E6A8;
		  /* 8218E6A8h */ case    8:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8218E6A8h case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8218E6A8h case    8:*/		return 0x8218E6AC;
		  /* 8218E6ACh */ case    9:  		/* bl -172668 */
		/* 8218E6ACh case    9:*/		regs.LR = 0x8218E6B0; return 0x82164430;
		/* 8218E6ACh case    9:*/		return 0x8218E6B0;
		  /* 8218E6B0h */ case   10:  		/* rlwinm. R11, R31, 0, 28, 28 */
		/* 8218E6B0h case   10:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R31);
		/* 8218E6B0h case   10:*/		return 0x8218E6B4;
		  /* 8218E6B4h */ case   11:  		/* add R30, R3, R22 */
		/* 8218E6B4h case   11:*/		cpu::op::add<0>(regs,&regs.R30,regs.R3,regs.R22);
		/* 8218E6B4h case   11:*/		return 0x8218E6B8;
		  /* 8218E6B8h */ case   12:  		/* bc 4, CR0_EQ, 48 */
		/* 8218E6B8h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8218E6E8;  }
		/* 8218E6B8h case   12:*/		return 0x8218E6BC;
		  /* 8218E6BCh */ case   13:  		/* lwz R11, <#[R30]> */
		/* 8218E6BCh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8218E6BCh case   13:*/		return 0x8218E6C0;
		  /* 8218E6C0h */ case   14:  		/* lwz R10, <#[R30 + 4]> */
		/* 8218E6C0h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 8218E6C0h case   14:*/		return 0x8218E6C4;
		  /* 8218E6C4h */ case   15:  		/* oris R11, R11, 32768 */
		/* 8218E6C4h case   15:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 8218E6C4h case   15:*/		return 0x8218E6C8;
		  /* 8218E6C8h */ case   16:  		/* stw R11, <#[R30]> */
		/* 8218E6C8h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8218E6C8h case   16:*/		return 0x8218E6CC;
		  /* 8218E6CCh */ case   17:  		/* rlwinm R11, R11, 20, 15, 28 */
		/* 8218E6CCh case   17:*/		cpu::op::rlwinm<0,20,15,28>(regs,&regs.R11,regs.R11);
		/* 8218E6CCh case   17:*/		return 0x8218E6D0;
		  /* 8218E6D0h */ case   18:  		/* lwz R9, <#[R25 + 28]> */
		/* 8218E6D0h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x0000001C) );
		/* 8218E6D0h case   18:*/		return 0x8218E6D4;
		  /* 8218E6D4h */ case   19:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8218E6D4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8218E6D4h case   19:*/		return 0x8218E6D8;
		  /* 8218E6D8h */ case   20:  		/* rlwinm R11, R11, 12, 20, 31 */
		/* 8218E6D8h case   20:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R11);
		/* 8218E6D8h case   20:*/		return 0x8218E6DC;
		  /* 8218E6DCh */ case   21:  		/* addi R11, R11, -2 */
		/* 8218E6DCh case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFE);
		/* 8218E6DCh case   21:*/		return 0x8218E6E0;
		  /* 8218E6E0h */ case   22:  		/* rlwimi R10, R11, 4, 26, 27 */
		/* 8218E6E0h case   22:*/		cpu::op::rlwimi<0,4,26,27>(regs,&regs.R10,regs.R11);
		/* 8218E6E0h case   22:*/		return 0x8218E6E4;
		  /* 8218E6E4h */ case   23:  		/* stw R10, <#[R30 + 4]> */
		/* 8218E6E4h case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 8218E6E4h case   23:*/		return 0x8218E6E8;
	}
	return 0x8218E6E8;
} // Block from 8218E688h-8218E6E8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8218E6E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E6E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E6E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E6E8);
		  /* 8218E6E8h */ case    0:  		/* lwz R29, <#[R19]> */
		/* 8218E6E8h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R19 + 0x00000000) );
		/* 8218E6E8h case    0:*/		return 0x8218E6EC;
		  /* 8218E6ECh */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 8218E6ECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8218E6ECh case    1:*/		return 0x8218E6F0;
		  /* 8218E6F0h */ case    2:  		/* bc 12, CR6_EQ, 300 */
		/* 8218E6F0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8218E81C;  }
		/* 8218E6F0h case    2:*/		return 0x8218E6F4;
		  /* 8218E6F4h */ case    3:  		/* lwz R31, <#[R29 + 16]> */
		/* 8218E6F4h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000010) );
		/* 8218E6F4h case    3:*/		return 0x8218E6F8;
		  /* 8218E6F8h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8218E6F8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8218E6F8h case    4:*/		return 0x8218E6FC;
		  /* 8218E6FCh */ case    5:  		/* bc 12, CR6_EQ, 208 */
		/* 8218E6FCh case    5:*/		if ( regs.CR[6].eq ) { return 0x8218E7CC;  }
		/* 8218E6FCh case    5:*/		return 0x8218E700;
		  /* 8218E700h */ case    6:  		/* lwz R11, <#[R31 + 8]> */
		/* 8218E700h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8218E700h case    6:*/		return 0x8218E704;
		  /* 8218E704h */ case    7:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8218E704h case    7:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8218E704h case    7:*/		return 0x8218E708;
		  /* 8218E708h */ case    8:  		/* cmplwi CR6, R11, 97 */
		/* 8218E708h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000061);
		/* 8218E708h case    8:*/		return 0x8218E70C;
		  /* 8218E70Ch */ case    9:  		/* bc 12, CR6_EQ, 24 */
		/* 8218E70Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x8218E724;  }
		/* 8218E70Ch case    9:*/		return 0x8218E710;
		  /* 8218E710h */ case   10:  		/* cmplwi CR6, R11, 99 */
		/* 8218E710h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000063);
		/* 8218E710h case   10:*/		return 0x8218E714;
		  /* 8218E714h */ case   11:  		/* bc 12, CR6_EQ, 16 */
		/* 8218E714h case   11:*/		if ( regs.CR[6].eq ) { return 0x8218E724;  }
		/* 8218E714h case   11:*/		return 0x8218E718;
		  /* 8218E718h */ case   12:  		/* cmplwi CR6, R11, 100 */
		/* 8218E718h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000064);
		/* 8218E718h case   12:*/		return 0x8218E71C;
		  /* 8218E71Ch */ case   13:  		/* mr R11, R17 */
		/* 8218E71Ch case   13:*/		regs.R11 = regs.R17;
		/* 8218E71Ch case   13:*/		return 0x8218E720;
		  /* 8218E720h */ case   14:  		/* bc 4, CR6_EQ, 8 */
		/* 8218E720h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8218E728;  }
		/* 8218E720h case   14:*/		return 0x8218E724;
	}
	return 0x8218E724;
} // Block from 8218E6E8h-8218E724h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8218E724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E724);
		  /* 8218E724h */ case    0:  		/* li R11, 1 */
		/* 8218E724h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218E724h case    0:*/		return 0x8218E728;
	}
	return 0x8218E728;
} // Block from 8218E724h-8218E728h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218E728h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E728);
		  /* 8218E728h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8218E728h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8218E728h case    0:*/		return 0x8218E72C;
		  /* 8218E72Ch */ case    1:  		/* mr R3, R14 */
		/* 8218E72Ch case    1:*/		regs.R3 = regs.R14;
		/* 8218E72Ch case    1:*/		return 0x8218E730;
		  /* 8218E730h */ case    2:  		/* bc 12, CR0_EQ, 660 */
		/* 8218E730h case    2:*/		if ( regs.CR[0].eq ) { return 0x8218E9C4;  }
		/* 8218E730h case    2:*/		return 0x8218E734;
		  /* 8218E734h */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 8218E734h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8218E734h case    3:*/		return 0x8218E738;
		  /* 8218E738h */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8218E738h case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8218E738h case    4:*/		return 0x8218E73C;
		  /* 8218E73Ch */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8218E73Ch case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8218E73Ch case    5:*/		return 0x8218E740;
		  /* 8218E740h */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8218E740h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8218E740h case    6:*/		return 0x8218E744;
		  /* 8218E744h */ case    7:  		/* bl -172820 */
		/* 8218E744h case    7:*/		regs.LR = 0x8218E748; return 0x82164430;
		/* 8218E744h case    7:*/		return 0x8218E748;
		  /* 8218E748h */ case    8:  		/* addi R11, R31, -24 */
		/* 8218E748h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFE8);
		/* 8218E748h case    8:*/		return 0x8218E74C;
		  /* 8218E74Ch */ case    9:  		/* add R10, R3, R11 */
		/* 8218E74Ch case    9:*/		cpu::op::add<0>(regs,&regs.R10,regs.R3,regs.R11);
		/* 8218E74Ch case    9:*/		return 0x8218E750;
		  /* 8218E750h */ case   10:  		/* lwz R11, <#[R10]> */
		/* 8218E750h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8218E750h case   10:*/		return 0x8218E754;
		  /* 8218E754h */ case   11:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8218E754h case   11:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8218E754h case   11:*/		return 0x8218E758;
		  /* 8218E758h */ case   12:  		/* cmplwi CR6, R11, 1 */
		/* 8218E758h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8218E758h case   12:*/		return 0x8218E75C;
		  /* 8218E75Ch */ case   13:  		/* bc 12, CR6_EQ, 28 */
		/* 8218E75Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x8218E778;  }
		/* 8218E75Ch case   13:*/		return 0x8218E760;
		  /* 8218E760h */ case   14:  		/* cmplwi CR6, R11, 15 */
		/* 8218E760h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000F);
		/* 8218E760h case   14:*/		return 0x8218E764;
		  /* 8218E764h */ case   15:  		/* bc 4, CR6_GT, 104 */
		/* 8218E764h case   15:*/		if ( !regs.CR[6].gt ) { return 0x8218E7CC;  }
		/* 8218E764h case   15:*/		return 0x8218E768;
		  /* 8218E768h */ case   16:  		/* cmplwi CR6, R11, 17 */
		/* 8218E768h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000011);
		/* 8218E768h case   16:*/		return 0x8218E76C;
		  /* 8218E76Ch */ case   17:  		/* bc 4, CR6_GT, 12 */
		/* 8218E76Ch case   17:*/		if ( !regs.CR[6].gt ) { return 0x8218E778;  }
		/* 8218E76Ch case   17:*/		return 0x8218E770;
		  /* 8218E770h */ case   18:  		/* cmplwi CR6, R11, 19 */
		/* 8218E770h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000013);
		/* 8218E770h case   18:*/		return 0x8218E774;
		  /* 8218E774h */ case   19:  		/* bc 4, CR6_EQ, 88 */
		/* 8218E774h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8218E7CC;  }
		/* 8218E774h case   19:*/		return 0x8218E778;
	}
	return 0x8218E778;
} // Block from 8218E728h-8218E778h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8218E778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E778);
		  /* 8218E778h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8218E778h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8218E778h case    0:*/		return 0x8218E77C;
		  /* 8218E77Ch */ case    1:  		/* rlwinm. R9, R11, 0, 0, 0 */
		/* 8218E77Ch case    1:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R9,regs.R11);
		/* 8218E77Ch case    1:*/		return 0x8218E780;
		  /* 8218E780h */ case    2:  		/* bc 4, CR0_EQ, 32 */
		/* 8218E780h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8218E7A0;  }
		/* 8218E780h case    2:*/		return 0x8218E784;
		  /* 8218E784h */ case    3:  		/* oris R11, R11, 32768 */
		/* 8218E784h case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 8218E784h case    3:*/		return 0x8218E788;
		  /* 8218E788h */ case    4:  		/* lwz R9, <#[R30 + 4]> */
		/* 8218E788h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000004) );
		/* 8218E788h case    4:*/		return 0x8218E78C;
		  /* 8218E78Ch */ case    5:  		/* stw R11, <#[R30]> */
		/* 8218E78Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8218E78Ch case    5:*/		return 0x8218E790;
		  /* 8218E790h */ case    6:  		/* lwz R11, <#[R10 + 8]> */
		/* 8218E790h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8218E790h case    6:*/		return 0x8218E794;
		  /* 8218E794h */ case    7:  		/* rlwimi R9, R11, 22, 26, 27 */
		/* 8218E794h case    7:*/		cpu::op::rlwimi<0,22,26,27>(regs,&regs.R9,regs.R11);
		/* 8218E794h case    7:*/		return 0x8218E798;
		  /* 8218E798h */ case    8:  		/* stw R9, <#[R30 + 4]> */
		/* 8218E798h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000004) );
		/* 8218E798h case    8:*/		return 0x8218E79C;
		  /* 8218E79Ch */ case    9:  		/* b 48 */
		/* 8218E79Ch case    9:*/		return 0x8218E7CC;
		/* 8218E79Ch case    9:*/		return 0x8218E7A0;
	}
	return 0x8218E7A0;
} // Block from 8218E778h-8218E7A0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8218E7A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E7A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E7A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E7A0);
		  /* 8218E7A0h */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 8218E7A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8218E7A0h case    0:*/		return 0x8218E7A4;
		  /* 8218E7A4h */ case    1:  		/* rlwinm. R11, R11, 28, 30, 31 */
		/* 8218E7A4h case    1:*/		cpu::op::rlwinm<1,28,30,31>(regs,&regs.R11,regs.R11);
		/* 8218E7A4h case    1:*/		return 0x8218E7A8;
		  /* 8218E7A8h */ case    2:  		/* bc 4, CR0_EQ, 20 */
		/* 8218E7A8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8218E7BC;  }
		/* 8218E7A8h case    2:*/		return 0x8218E7AC;
		  /* 8218E7ACh */ case    3:  		/* lwz R9, <#[R10 + 8]> */
		/* 8218E7ACh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 8218E7ACh case    3:*/		return 0x8218E7B0;
		  /* 8218E7B0h */ case    4:  		/* rlwinm R9, R9, 0, 16, 17 */
		/* 8218E7B0h case    4:*/		cpu::op::rlwinm<0,0,16,17>(regs,&regs.R9,regs.R9);
		/* 8218E7B0h case    4:*/		return 0x8218E7B4;
		  /* 8218E7B4h */ case    5:  		/* cmplwi CR6, R9, 16384 */
		/* 8218E7B4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00004000);
		/* 8218E7B4h case    5:*/		return 0x8218E7B8;
		  /* 8218E7B8h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8218E7B8h case    6:*/		if ( regs.CR[6].eq ) { return 0x8218E7CC;  }
		/* 8218E7B8h case    6:*/		return 0x8218E7BC;
	}
	return 0x8218E7BC;
} // Block from 8218E7A0h-8218E7BCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218E7BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E7BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E7BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E7BC);
		  /* 8218E7BCh */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 8218E7BCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8218E7BCh case    0:*/		return 0x8218E7C0;
		  /* 8218E7C0h */ case    1:  		/* rlwinm R10, R10, 18, 30, 31 */
		/* 8218E7C0h case    1:*/		cpu::op::rlwinm<0,18,30,31>(regs,&regs.R10,regs.R10);
		/* 8218E7C0h case    1:*/		return 0x8218E7C4;
		  /* 8218E7C4h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 8218E7C4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8218E7C4h case    2:*/		return 0x8218E7C8;
		  /* 8218E7C8h */ case    3:  		/* bc 4, CR6_EQ, 516 */
		/* 8218E7C8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8218E9CC;  }
		/* 8218E7C8h case    3:*/		return 0x8218E7CC;
	}
	return 0x8218E7CC;
} // Block from 8218E7BCh-8218E7CCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218E7CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E7CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E7CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E7CC);
		  /* 8218E7CCh */ case    0:  		/* lwz R29, <#[R29 + 8]> */
		/* 8218E7CCh case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000008) );
		/* 8218E7CCh case    0:*/		return 0x8218E7D0;
		  /* 8218E7D0h */ case    1:  		/* b -228 */
		/* 8218E7D0h case    1:*/		return 0x8218E6EC;
		/* 8218E7D0h case    1:*/		return 0x8218E7D4;
	}
	return 0x8218E7D4;
} // Block from 8218E7CCh-8218E7D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218E7D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E7D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E7D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E7D4);
		  /* 8218E7D4h */ case    0:  		/* cmplwi CR6, R11, 1 */
		/* 8218E7D4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8218E7D4h case    0:*/		return 0x8218E7D8;
		  /* 8218E7D8h */ case    1:  		/* bc 4, CR6_EQ, 68 */
		/* 8218E7D8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8218E81C;  }
		/* 8218E7D8h case    1:*/		return 0x8218E7DC;
		  /* 8218E7DCh */ case    2:  		/* lwz R30, <#[R19]> */
		/* 8218E7DCh case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R19 + 0x00000000) );
		/* 8218E7DCh case    2:*/		return 0x8218E7E0;
		  /* 8218E7E0h */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 8218E7E0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8218E7E0h case    3:*/		return 0x8218E7E4;
		  /* 8218E7E4h */ case    4:  		/* bc 12, CR6_EQ, 56 */
		/* 8218E7E4h case    4:*/		if ( regs.CR[6].eq ) { return 0x8218E81C;  }
		/* 8218E7E4h case    4:*/		return 0x8218E7E8;
		  /* 8218E7E8h */ case    5:  		/* lwz R31, <#[R30 + 16]> */
		/* 8218E7E8h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000010) );
		/* 8218E7E8h case    5:*/		return 0x8218E7EC;
		  /* 8218E7ECh */ case    6:  		/* cmplwi CR6, R31, 0 */
		/* 8218E7ECh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8218E7ECh case    6:*/		return 0x8218E7F0;
		  /* 8218E7F0h */ case    7:  		/* bc 12, CR6_EQ, 36 */
		/* 8218E7F0h case    7:*/		if ( regs.CR[6].eq ) { return 0x8218E814;  }
		/* 8218E7F0h case    7:*/		return 0x8218E7F4;
		  /* 8218E7F4h */ case    8:  		/* mr R3, R31 */
		/* 8218E7F4h case    8:*/		regs.R3 = regs.R31;
		/* 8218E7F4h case    8:*/		return 0x8218E7F8;
		  /* 8218E7F8h */ case    9:  		/* bl -137840 */
		/* 8218E7F8h case    9:*/		regs.LR = 0x8218E7FC; return 0x8216CD88;
		/* 8218E7F8h case    9:*/		return 0x8218E7FC;
		  /* 8218E7FCh */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8218E7FCh case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8218E7FCh case   10:*/		return 0x8218E800;
		  /* 8218E800h */ case   11:  		/* bc 12, CR0_EQ, 20 */
		/* 8218E800h case   11:*/		if ( regs.CR[0].eq ) { return 0x8218E814;  }
		/* 8218E800h case   11:*/		return 0x8218E804;
		  /* 8218E804h */ case   12:  		/* lwz R11, <#[R31 + 8]> */
		/* 8218E804h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8218E804h case   12:*/		return 0x8218E808;
		  /* 8218E808h */ case   13:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8218E808h case   13:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8218E808h case   13:*/		return 0x8218E80C;
		  /* 8218E80Ch */ case   14:  		/* cmplwi CR6, R11, 10752 */
		/* 8218E80Ch case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002A00);
		/* 8218E80Ch case   14:*/		return 0x8218E810;
		  /* 8218E810h */ case   15:  		/* bc 4, CR6_EQ, 456 */
		/* 8218E810h case   15:*/		if ( !regs.CR[6].eq ) { return 0x8218E9D8;  }
		/* 8218E810h case   15:*/		return 0x8218E814;
	}
	return 0x8218E814;
} // Block from 8218E7D4h-8218E814h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8218E814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E814);
		  /* 8218E814h */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 8218E814h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 8218E814h case    0:*/		return 0x8218E818;
		  /* 8218E818h */ case    1:  		/* b -56 */
		/* 8218E818h case    1:*/		return 0x8218E7E0;
		/* 8218E818h case    1:*/		return 0x8218E81C;
	}
	return 0x8218E81C;
} // Block from 8218E814h-8218E81Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218E81Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E81C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E81C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E81C);
		  /* 8218E81Ch */ case    0:  		/* cmplwi CR6, R16, 0 */
		/* 8218E81Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 8218E81Ch case    0:*/		return 0x8218E820;
		  /* 8218E820h */ case    1:  		/* bc 12, CR6_EQ, 52 */
		/* 8218E820h case    1:*/		if ( regs.CR[6].eq ) { return 0x8218E854;  }
		/* 8218E820h case    1:*/		return 0x8218E824;
		  /* 8218E824h */ case    2:  		/* rlwinm R11, R16, 0, 0, 30 */
		/* 8218E824h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R16);
		/* 8218E824h case    2:*/		return 0x8218E828;
		  /* 8218E828h */ case    3:  		/* lwz R11, <#[R11 + 40]> */
		/* 8218E828h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8218E828h case    3:*/		return 0x8218E82C;
		  /* 8218E82Ch */ case    4:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8218E82Ch case    4:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8218E82Ch case    4:*/		return 0x8218E830;
		  /* 8218E830h */ case    5:  		/* addic R10, R10, -1 */
		/* 8218E830h case    5:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8218E830h case    5:*/		return 0x8218E834;
		  /* 8218E834h */ case    6:  		/* subfe R10, R10, R10 */
		/* 8218E834h case    6:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8218E834h case    6:*/		return 0x8218E838;
		  /* 8218E838h */ case    7:  		/* and R10, R10, R11 */
		/* 8218E838h case    7:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8218E838h case    7:*/		return 0x8218E83C;
		  /* 8218E83Ch */ case    8:  		/* cmplw CR6, R21, R10 */
		/* 8218E83Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R10);
		/* 8218E83Ch case    8:*/		return 0x8218E840;
		  /* 8218E840h */ case    9:  		/* bc 4, CR6_EQ, 84 */
		/* 8218E840h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8218E894;  }
		/* 8218E840h case    9:*/		return 0x8218E844;
		  /* 8218E844h */ case   10:  		/* rlwinm R11, R21, 0, 0, 30 */
		/* 8218E844h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R21);
		/* 8218E844h case   10:*/		return 0x8218E848;
		  /* 8218E848h */ case   11:  		/* mr R16, R21 */
		/* 8218E848h case   11:*/		regs.R16 = regs.R21;
		/* 8218E848h case   11:*/		return 0x8218E84C;
		  /* 8218E84Ch */ case   12:  		/* lwz R11, <#[R11 + 40]> */
		/* 8218E84Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8218E84Ch case   12:*/		return 0x8218E850;
		  /* 8218E850h */ case   13:  		/* b 68 */
		/* 8218E850h case   13:*/		return 0x8218E894;
		/* 8218E850h case   13:*/		return 0x8218E854;
	}
	return 0x8218E854;
} // Block from 8218E81Ch-8218E854h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8218E854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E854);
		  /* 8218E854h */ case    0:  		/* lwz R11, <#[R14 + 4]> */
		/* 8218E854h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000004) );
		/* 8218E854h case    0:*/		return 0x8218E858;
		  /* 8218E858h */ case    1:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8218E858h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8218E858h case    1:*/		return 0x8218E85C;
		  /* 8218E85Ch */ case    2:  		/* addic R9, R10, -1 */
		/* 8218E85Ch case    2:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 8218E85Ch case    2:*/		return 0x8218E860;
		  /* 8218E860h */ case    3:  		/* subfe R9, R9, R9 */
		/* 8218E860h case    3:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 8218E860h case    3:*/		return 0x8218E864;
		  /* 8218E864h */ case    4:  		/* and R9, R9, R11 */
		/* 8218E864h case    4:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 8218E864h case    4:*/		return 0x8218E868;
		  /* 8218E868h */ case    5:  		/* lwz R9, <#[R9 + 20]> */
		/* 8218E868h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000014) );
		/* 8218E868h case    5:*/		return 0x8218E86C;
		  /* 8218E86Ch */ case    6:  		/* rlwinm R8, R9, 0, 31, 31 */
		/* 8218E86Ch case    6:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R8,regs.R9);
		/* 8218E86Ch case    6:*/		return 0x8218E870;
		  /* 8218E870h */ case    7:  		/* addic R8, R8, -1 */
		/* 8218E870h case    7:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 8218E870h case    7:*/		return 0x8218E874;
		  /* 8218E874h */ case    8:  		/* subfe R8, R8, R8 */
		/* 8218E874h case    8:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R8,regs.R8);
		/* 8218E874h case    8:*/		return 0x8218E878;
		  /* 8218E878h */ case    9:  		/* and R9, R8, R9 */
		/* 8218E878h case    9:*/		cpu::op::and<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8218E878h case    9:*/		return 0x8218E87C;
		  /* 8218E87Ch */ case   10:  		/* cmplw CR6, R21, R9 */
		/* 8218E87Ch case   10:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R9);
		/* 8218E87Ch case   10:*/		return 0x8218E880;
		  /* 8218E880h */ case   11:  		/* bc 12, CR6_EQ, -60 */
		/* 8218E880h case   11:*/		if ( regs.CR[6].eq ) { return 0x8218E844;  }
		/* 8218E880h case   11:*/		return 0x8218E884;
		  /* 8218E884h */ case   12:  		/* addic R10, R10, -1 */
		/* 8218E884h case   12:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8218E884h case   12:*/		return 0x8218E888;
		  /* 8218E888h */ case   13:  		/* subfe R10, R10, R10 */
		/* 8218E888h case   13:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8218E888h case   13:*/		return 0x8218E88C;
		  /* 8218E88Ch */ case   14:  		/* and R11, R10, R11 */
		/* 8218E88Ch case   14:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218E88Ch case   14:*/		return 0x8218E890;
		  /* 8218E890h */ case   15:  		/* lwz R11, <#[R11 + 20]> */
		/* 8218E890h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8218E890h case   15:*/		return 0x8218E894;
	}
	return 0x8218E894;
} // Block from 8218E854h-8218E894h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8218E894h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E894( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E894) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E894);
		  /* 8218E894h */ case    0:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8218E894h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8218E894h case    0:*/		return 0x8218E898;
		  /* 8218E898h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 8218E898h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8218E8A8;  }
		/* 8218E898h case    1:*/		return 0x8218E89C;
		  /* 8218E89Ch */ case    2:  		/* mr R21, R11 */
		/* 8218E89Ch case    2:*/		regs.R21 = regs.R11;
		/* 8218E89Ch case    2:*/		return 0x8218E8A0;
		  /* 8218E8A0h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8218E8A0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218E8A0h case    3:*/		return 0x8218E8A4;
		  /* 8218E8A4h */ case    4:  		/* bc 4, CR6_EQ, -1404 */
		/* 8218E8A4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8218E328;  }
		/* 8218E8A4h case    4:*/		return 0x8218E8A8;
	}
	return 0x8218E8A8;
} // Block from 8218E894h-8218E8A8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218E8A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E8A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E8A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E8A8);
		  /* 8218E8A8h */ case    0:  		/* mr R3, R14 */
		/* 8218E8A8h case    0:*/		regs.R3 = regs.R14;
		/* 8218E8A8h case    0:*/		return 0x8218E8AC;
		  /* 8218E8ACh */ case    1:  		/* bl -173332 */
		/* 8218E8ACh case    1:*/		regs.LR = 0x8218E8B0; return 0x82164398;
		/* 8218E8ACh case    1:*/		return 0x8218E8B0;
		  /* 8218E8B0h */ case    2:  		/* mr R31, R3 */
		/* 8218E8B0h case    2:*/		regs.R31 = regs.R3;
		/* 8218E8B0h case    2:*/		return 0x8218E8B4;
		  /* 8218E8B4h */ case    3:  		/* mr R3, R14 */
		/* 8218E8B4h case    3:*/		regs.R3 = regs.R14;
		/* 8218E8B4h case    3:*/		return 0x8218E8B8;
		  /* 8218E8B8h */ case    4:  		/* bl -13400 */
		/* 8218E8B8h case    4:*/		regs.LR = 0x8218E8BC; return 0x8218B460;
		/* 8218E8B8h case    4:*/		return 0x8218E8BC;
		  /* 8218E8BCh */ case    5:  		/* lwz R11, <#[R14 + 48]> */
		/* 8218E8BCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000030) );
		/* 8218E8BCh case    5:*/		return 0x8218E8C0;
		  /* 8218E8C0h */ case    6:  		/* lis R10, -1 */
		/* 8218E8C0h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8218E8C0h case    6:*/		return 0x8218E8C4;
		  /* 8218E8C4h */ case    7:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 8218E8C4h case    7:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 8218E8C4h case    7:*/		return 0x8218E8C8;
		  /* 8218E8C8h */ case    8:  		/* add R30, R3, R31 */
		/* 8218E8C8h case    8:*/		cpu::op::add<0>(regs,&regs.R30,regs.R3,regs.R31);
		/* 8218E8C8h case    8:*/		return 0x8218E8CC;
		  /* 8218E8CCh */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 8218E8CCh case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8218E8CCh case    9:*/		return 0x8218E8D0;
		  /* 8218E8D0h */ case   10:  		/* li R5, 128 */
		/* 8218E8D0h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x80);
		/* 8218E8D0h case   10:*/		return 0x8218E8D4;
		  /* 8218E8D4h */ case   11:  		/* addi R3, R1, 128 */
		/* 8218E8D4h case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 8218E8D4h case   11:*/		return 0x8218E8D8;
		  /* 8218E8D8h */ case   12:  		/* bc 4, CR6_EQ, 268 */
		/* 8218E8D8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8218E9E4;  }
		/* 8218E8D8h case   12:*/		return 0x8218E8DC;
		  /* 8218E8DCh */ case   13:  		/* li R4, 0 */
		/* 8218E8DCh case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8218E8DCh case   13:*/		return 0x8218E8E0;
		  /* 8218E8E0h */ case   14:  		/* bl -9456 */
		/* 8218E8E0h case   14:*/		regs.LR = 0x8218E8E4; return 0x8218C3F0;
		/* 8218E8E0h case   14:*/		return 0x8218E8E4;
		  /* 8218E8E4h */ case   15:  		/* li R4, 0 */
		/* 8218E8E4h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8218E8E4h case   15:*/		return 0x8218E8E8;
		  /* 8218E8E8h */ case   16:  		/* b 264 */
		/* 8218E8E8h case   16:*/		return 0x8218E9F0;
		/* 8218E8E8h case   16:*/		return 0x8218E8EC;
	}
	return 0x8218E8EC;
} // Block from 8218E8A8h-8218E8ECh (17 instructions)

//////////////////////////////////////////////////////
// Block at 8218E8ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E8EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E8EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E8EC);
		  /* 8218E8ECh */ case    0:  		/* li R4, 3566 */
		/* 8218E8ECh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xDEE);
		/* 8218E8ECh case    0:*/		return 0x8218E8F0;
	}
	return 0x8218E8F0;
} // Block from 8218E8ECh-8218E8F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218E8F0h
// Function '?ConstantRegisterAllocation@Compiler@D3DXShader@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E8F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E8F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E8F0);
		  /* 8218E8F0h */ case    0:  		/* mr R3, R14 */
		/* 8218E8F0h case    0:*/		regs.R3 = regs.R14;
		/* 8218E8F0h case    0:*/		return 0x8218E8F4;
		  /* 8218E8F4h */ case    1:  		/* bl -248460 */
		/* 8218E8F4h case    1:*/		regs.LR = 0x8218E8F8; return 0x82151E68;
		/* 8218E8F4h case    1:*/		return 0x8218E8F8;
	}
	return 0x8218E8F8;
} // Block from 8218E8F0h-8218E8F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218E8F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E8F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E8F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E8F8);
		  /* 8218E8F8h */ case    0:  		/* rlwinm. R11, R28, 0, 30, 30 */
		/* 8218E8F8h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R28);
		/* 8218E8F8h case    0:*/		return 0x8218E8FC;
		  /* 8218E8FCh */ case    1:  		/* mr R3, R14 */
		/* 8218E8FCh case    1:*/		regs.R3 = regs.R14;
		/* 8218E8FCh case    1:*/		return 0x8218E900;
		  /* 8218E900h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 8218E900h case    2:*/		if ( regs.CR[0].eq ) { return 0x8218E90C;  }
		/* 8218E900h case    2:*/		return 0x8218E904;
		  /* 8218E904h */ case    3:  		/* li R4, 3548 */
		/* 8218E904h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0xDDC);
		/* 8218E904h case    3:*/		return 0x8218E908;
		  /* 8218E908h */ case    4:  		/* bl -248480 */
		/* 8218E908h case    4:*/		regs.LR = 0x8218E90C; return 0x82151E68;
		/* 8218E908h case    4:*/		return 0x8218E90C;
	}
	return 0x8218E90C;
} // Block from 8218E8F8h-8218E90Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218E90Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E90C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E90C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E90C);
		  /* 8218E90Ch */ case    0:  		/* rlwinm. R11, R28, 0, 25, 25 */
		/* 8218E90Ch case    0:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R28);
		/* 8218E90Ch case    0:*/		return 0x8218E910;
		  /* 8218E910h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8218E910h case    1:*/		if ( regs.CR[0].eq ) { return 0x8218E91C;  }
		/* 8218E910h case    1:*/		return 0x8218E914;
		  /* 8218E914h */ case    2:  		/* li R4, 3598 */
		/* 8218E914h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0xE0E);
		/* 8218E914h case    2:*/		return 0x8218E918;
		  /* 8218E918h */ case    3:  		/* bl -248496 */
		/* 8218E918h case    3:*/		regs.LR = 0x8218E91C; return 0x82151E68;
		/* 8218E918h case    3:*/		return 0x8218E91C;
	}
	return 0x8218E91C;
} // Block from 8218E90Ch-8218E91Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218E91Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E91C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E91C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E91C);
		  /* 8218E91Ch */ case    0:  		/* rlwinm. R11, R28, 0, 28, 28 */
		/* 8218E91Ch case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R28);
		/* 8218E91Ch case    0:*/		return 0x8218E920;
		  /* 8218E920h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8218E920h case    1:*/		if ( regs.CR[0].eq ) { return 0x8218E92C;  }
		/* 8218E920h case    1:*/		return 0x8218E924;
		  /* 8218E924h */ case    2:  		/* li R4, 3533 */
		/* 8218E924h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0xDCD);
		/* 8218E924h case    2:*/		return 0x8218E928;
		  /* 8218E928h */ case    3:  		/* bl -248512 */
		/* 8218E928h case    3:*/		regs.LR = 0x8218E92C; return 0x82151E68;
		/* 8218E928h case    3:*/		return 0x8218E92C;
	}
	return 0x8218E92C;
} // Block from 8218E91Ch-8218E92Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218E92Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E92C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E92C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E92C);
		  /* 8218E92Ch */ case    0:  		/* rlwinm. R11, R28, 0, 31, 31 */
		/* 8218E92Ch case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R28);
		/* 8218E92Ch case    0:*/		return 0x8218E930;
		  /* 8218E930h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 8218E930h case    1:*/		if ( regs.CR[0].eq ) { return 0x8218E944;  }
		/* 8218E930h case    1:*/		return 0x8218E934;
		  /* 8218E934h */ case    2:  		/* lis R11, -32252 */
		/* 8218E934h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8218E934h case    2:*/		return 0x8218E938;
		  /* 8218E938h */ case    3:  		/* li R4, 3500 */
		/* 8218E938h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0xDAC);
		/* 8218E938h case    3:*/		return 0x8218E93C;
		  /* 8218E93Ch */ case    4:  		/* addi R5, R11, -16876 */
		/* 8218E93Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFBE14);
		/* 8218E93Ch case    4:*/		return 0x8218E940;
		  /* 8218E940h */ case    5:  		/* bl -248536 */
		/* 8218E940h case    5:*/		regs.LR = 0x8218E944; return 0x82151E68;
		/* 8218E940h case    5:*/		return 0x8218E944;
	}
	return 0x8218E944;
} // Block from 8218E92Ch-8218E944h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218E944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E944);
		  /* 8218E944h */ case    0:  		/* li R4, 4800 */
		/* 8218E944h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8218E944h case    0:*/		return 0x8218E948;
		  /* 8218E948h */ case    1:  		/* bl -248544 */
		/* 8218E948h case    1:*/		regs.LR = 0x8218E94C; return 0x82151E68;
		/* 8218E948h case    1:*/		return 0x8218E94C;
	}
	return 0x8218E94C;
} // Block from 8218E944h-8218E94Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218E94Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E94C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E94C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E94C);
		  /* 8218E94Ch */ case    0:  		/* li R4, 4800 */
		/* 8218E94Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8218E94Ch case    0:*/		return 0x8218E950;
		  /* 8218E950h */ case    1:  		/* mr R3, R14 */
		/* 8218E950h case    1:*/		regs.R3 = regs.R14;
		/* 8218E950h case    1:*/		return 0x8218E954;
		  /* 8218E954h */ case    2:  		/* bl -248556 */
		/* 8218E954h case    2:*/		regs.LR = 0x8218E958; return 0x82151E68;
		/* 8218E954h case    2:*/		return 0x8218E958;
	}
	return 0x8218E958;
} // Block from 8218E94Ch-8218E958h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218E958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E958);
		  /* 8218E958h */ case    0:  		/* mr R4, R30 */
		/* 8218E958h case    0:*/		regs.R4 = regs.R30;
		/* 8218E958h case    0:*/		return 0x8218E95C;
		  /* 8218E95Ch */ case    1:  		/* mr R3, R14 */
		/* 8218E95Ch case    1:*/		regs.R3 = regs.R14;
		/* 8218E95Ch case    1:*/		return 0x8218E960;
		  /* 8218E960h */ case    2:  		/* bl -5848 */
		/* 8218E960h case    2:*/		regs.LR = 0x8218E964; return 0x8218D288;
		/* 8218E960h case    2:*/		return 0x8218E964;
		  /* 8218E964h */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 8218E964h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8218E964h case    3:*/		return 0x8218E968;
		  /* 8218E968h */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 8218E968h case    4:*/		if ( regs.CR[0].eq ) { return 0x8218E97C;  }
		/* 8218E968h case    4:*/		return 0x8218E96C;
		  /* 8218E96Ch */ case    5:  		/* lwz R5, <#[R3 + 24]> */
		/* 8218E96Ch case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000018) );
		/* 8218E96Ch case    5:*/		return 0x8218E970;
		  /* 8218E970h */ case    6:  		/* li R4, 4556 */
		/* 8218E970h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x11CC);
		/* 8218E970h case    6:*/		return 0x8218E974;
		  /* 8218E974h */ case    7:  		/* mr R3, R14 */
		/* 8218E974h case    7:*/		regs.R3 = regs.R14;
		/* 8218E974h case    7:*/		return 0x8218E978;
		  /* 8218E978h */ case    8:  		/* bl -248592 */
		/* 8218E978h case    8:*/		regs.LR = 0x8218E97C; return 0x82151E68;
		/* 8218E978h case    8:*/		return 0x8218E97C;
	}
	return 0x8218E97C;
} // Block from 8218E958h-8218E97Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218E97Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E97C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E97C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E97C);
		  /* 8218E97Ch */ case    0:  		/* lwz R11, <#[R25 + 4]> */
		/* 8218E97Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 8218E97Ch case    0:*/		return 0x8218E980;
		  /* 8218E980h */ case    1:  		/* lis R10, -32217 */
		/* 8218E980h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 8218E980h case    1:*/		return 0x8218E984;
		  /* 8218E984h */ case    2:  		/* lis R9, -32252 */
		/* 8218E984h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 8218E984h case    2:*/		return 0x8218E988;
		  /* 8218E988h */ case    3:  		/* addi R10, R10, 21852 */
		/* 8218E988h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x555C);
		/* 8218E988h case    3:*/		return 0x8218E98C;
		  /* 8218E98Ch */ case    4:  		/* rlwinm R11, R11, 30, 27, 29 */
		/* 8218E98Ch case    4:*/		cpu::op::rlwinm<0,30,27,29>(regs,&regs.R11,regs.R11);
		/* 8218E98Ch case    4:*/		return 0x8218E990;
		  /* 8218E990h */ case    5:  		/* addi R5, R9, -16884 */
		/* 8218E990h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R9,0xFFFFBE0C);
		/* 8218E990h case    5:*/		return 0x8218E994;
		  /* 8218E994h */ case    6:  		/* rlwinm R7, R31, 12, 23, 31 */
		/* 8218E994h case    6:*/		cpu::op::rlwinm<0,12,23,31>(regs,&regs.R7,regs.R31);
		/* 8218E994h case    6:*/		return 0x8218E998;
		  /* 8218E998h */ case    7:  		/* li R4, 10 */
		/* 8218E998h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0xA);
		/* 8218E998h case    7:*/		return 0x8218E99C;
		  /* 8218E99Ch */ case    8:  		/* addi R3, R1, 112 */
		/* 8218E99Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 8218E99Ch case    8:*/		return 0x8218E9A0;
		  /* 8218E9A0h */ case    9:  		/* lwzx R6, <#[R11 + R10]> */
		/* 8218E9A0h case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8218E9A0h case    9:*/		return 0x8218E9A4;
		  /* 8218E9A4h */ case   10:  		/* bl 893956 */
		/* 8218E9A4h case   10:*/		regs.LR = 0x8218E9A8; return 0x82268DA8;
		/* 8218E9A4h case   10:*/		return 0x8218E9A8;
		  /* 8218E9A8h */ case   11:  		/* addi R5, R1, 112 */
		/* 8218E9A8h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 8218E9A8h case   11:*/		return 0x8218E9AC;
		  /* 8218E9ACh */ case   12:  		/* li R4, 4556 */
		/* 8218E9ACh case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x11CC);
		/* 8218E9ACh case   12:*/		return 0x8218E9B0;
		  /* 8218E9B0h */ case   13:  		/* mr R3, R14 */
		/* 8218E9B0h case   13:*/		regs.R3 = regs.R14;
		/* 8218E9B0h case   13:*/		return 0x8218E9B4;
		  /* 8218E9B4h */ case   14:  		/* bl -248652 */
		/* 8218E9B4h case   14:*/		regs.LR = 0x8218E9B8; return 0x82151E68;
		/* 8218E9B4h case   14:*/		return 0x8218E9B8;
	}
	return 0x8218E9B8;
} // Block from 8218E97Ch-8218E9B8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8218E9B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E9B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E9B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E9B8);
		  /* 8218E9B8h */ case    0:  		/* li R4, 3599 */
		/* 8218E9B8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xE0F);
		/* 8218E9B8h case    0:*/		return 0x8218E9BC;
		  /* 8218E9BCh */ case    1:  		/* mr R3, R14 */
		/* 8218E9BCh case    1:*/		regs.R3 = regs.R14;
		/* 8218E9BCh case    1:*/		return 0x8218E9C0;
		  /* 8218E9C0h */ case    2:  		/* bl -248664 */
		/* 8218E9C0h case    2:*/		regs.LR = 0x8218E9C4; return 0x82151E68;
		/* 8218E9C0h case    2:*/		return 0x8218E9C4;
	}
	return 0x8218E9C4;
} // Block from 8218E9B8h-8218E9C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218E9C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E9C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E9C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E9C4);
		  /* 8218E9C4h */ case    0:  		/* li R4, 3512 */
		/* 8218E9C4h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xDB8);
		/* 8218E9C4h case    0:*/		return 0x8218E9C8;
		  /* 8218E9C8h */ case    1:  		/* bl -248672 */
		/* 8218E9C8h case    1:*/		regs.LR = 0x8218E9CC; return 0x82151E68;
		/* 8218E9C8h case    1:*/		return 0x8218E9CC;
	}
	return 0x8218E9CC;
} // Block from 8218E9C4h-8218E9CCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218E9CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E9CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E9CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E9CC);
		  /* 8218E9CCh */ case    0:  		/* li R4, 4539 */
		/* 8218E9CCh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x11BB);
		/* 8218E9CCh case    0:*/		return 0x8218E9D0;
		  /* 8218E9D0h */ case    1:  		/* mr R3, R14 */
		/* 8218E9D0h case    1:*/		regs.R3 = regs.R14;
		/* 8218E9D0h case    1:*/		return 0x8218E9D4;
		  /* 8218E9D4h */ case    2:  		/* bl -248684 */
		/* 8218E9D4h case    2:*/		regs.LR = 0x8218E9D8; return 0x82151E68;
		/* 8218E9D4h case    2:*/		return 0x8218E9D8;
	}
	return 0x8218E9D8;
} // Block from 8218E9CCh-8218E9D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218E9D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E9D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E9D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E9D8);
		  /* 8218E9D8h */ case    0:  		/* li R4, 3548 */
		/* 8218E9D8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xDDC);
		/* 8218E9D8h case    0:*/		return 0x8218E9DC;
		  /* 8218E9DCh */ case    1:  		/* mr R3, R14 */
		/* 8218E9DCh case    1:*/		regs.R3 = regs.R14;
		/* 8218E9DCh case    1:*/		return 0x8218E9E0;
		  /* 8218E9E0h */ case    2:  		/* bl -248696 */
		/* 8218E9E0h case    2:*/		regs.LR = 0x8218E9E4; return 0x82151E68;
		/* 8218E9E0h case    2:*/		return 0x8218E9E4;
	}
	return 0x8218E9E4;
} // Block from 8218E9D8h-8218E9E4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218E9E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E9E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E9E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E9E4);
		  /* 8218E9E4h */ case    0:  		/* li R4, 128 */
		/* 8218E9E4h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x80);
		/* 8218E9E4h case    0:*/		return 0x8218E9E8;
		  /* 8218E9E8h */ case    1:  		/* bl -9720 */
		/* 8218E9E8h case    1:*/		regs.LR = 0x8218E9EC; return 0x8218C3F0;
		/* 8218E9E8h case    1:*/		return 0x8218E9EC;
		  /* 8218E9ECh */ case    2:  		/* li R4, 16 */
		/* 8218E9ECh case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x10);
		/* 8218E9ECh case    2:*/		return 0x8218E9F0;
	}
	return 0x8218E9F0;
} // Block from 8218E9E4h-8218E9F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218E9F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218E9F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218E9F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218E9F0);
		  /* 8218E9F0h */ case    0:  		/* li R5, 16 */
		/* 8218E9F0h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 8218E9F0h case    0:*/		return 0x8218E9F4;
		  /* 8218E9F4h */ case    1:  		/* addi R3, R1, 96 */
		/* 8218E9F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8218E9F4h case    1:*/		return 0x8218E9F8;
		  /* 8218E9F8h */ case    2:  		/* bl -10120 */
		/* 8218E9F8h case    2:*/		regs.LR = 0x8218E9FC; return 0x8218C270;
		/* 8218E9F8h case    2:*/		return 0x8218E9FC;
		  /* 8218E9FCh */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 8218E9FCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8218E9FCh case    3:*/		return 0x8218EA00;
		  /* 8218EA00h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 8218EA00h case    4:*/		if ( regs.CR[6].eq ) { return 0x8218EA14;  }
		/* 8218EA00h case    4:*/		return 0x8218EA04;
		  /* 8218EA04h */ case    5:  		/* mr R5, R31 */
		/* 8218EA04h case    5:*/		regs.R5 = regs.R31;
		/* 8218EA04h case    5:*/		return 0x8218EA08;
		  /* 8218EA08h */ case    6:  		/* li R4, 0 */
		/* 8218EA08h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8218EA08h case    6:*/		return 0x8218EA0C;
		  /* 8218EA0Ch */ case    7:  		/* addi R3, R1, 88 */
		/* 8218EA0Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 8218EA0Ch case    7:*/		return 0x8218EA10;
		  /* 8218EA10h */ case    8:  		/* bl -10144 */
		/* 8218EA10h case    8:*/		regs.LR = 0x8218EA14; return 0x8218C270;
		/* 8218EA10h case    8:*/		return 0x8218EA14;
	}
	return 0x8218EA14;
} // Block from 8218E9F0h-8218EA14h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218EA14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EA14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EA14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EA14);
		  /* 8218EA14h */ case    0:  		/* cmplwi CR6, R30, 32 */
		/* 8218EA14h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000020);
		/* 8218EA14h case    0:*/		return 0x8218EA18;
		  /* 8218EA18h */ case    1:  		/* bc 4, CR6_LT, 20 */
		/* 8218EA18h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8218EA2C;  }
		/* 8218EA18h case    1:*/		return 0x8218EA1C;
		  /* 8218EA1Ch */ case    2:  		/* subfic R5, R30, 32 */
		/* 8218EA1Ch case    2:*/		cpu::op::subfic<0>(regs,&regs.R5,regs.R30,0x20);
		/* 8218EA1Ch case    2:*/		return 0x8218EA20;
		  /* 8218EA20h */ case    3:  		/* mr R4, R30 */
		/* 8218EA20h case    3:*/		regs.R4 = regs.R30;
		/* 8218EA20h case    3:*/		return 0x8218EA24;
		  /* 8218EA24h */ case    4:  		/* addi R3, R1, 88 */
		/* 8218EA24h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 8218EA24h case    4:*/		return 0x8218EA28;
		  /* 8218EA28h */ case    5:  		/* bl -10168 */
		/* 8218EA28h case    5:*/		regs.LR = 0x8218EA2C; return 0x8218C270;
		/* 8218EA28h case    5:*/		return 0x8218EA2C;
	}
	return 0x8218EA2C;
} // Block from 8218EA14h-8218EA2Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218EA2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EA2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EA2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EA2C);
		  /* 8218EA2Ch */ case    0:  		/* lwz R20, <#[R14 + 16]> */
		/* 8218EA2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R14 + 0x00000010) );
		/* 8218EA2Ch case    0:*/		return 0x8218EA30;
		  /* 8218EA30h */ case    1:  		/* mr R25, R17 */
		/* 8218EA30h case    1:*/		regs.R25 = regs.R17;
		/* 8218EA30h case    1:*/		return 0x8218EA34;
		  /* 8218EA34h */ case    2:  		/* mr R30, R17 */
		/* 8218EA34h case    2:*/		regs.R30 = regs.R17;
		/* 8218EA34h case    2:*/		return 0x8218EA38;
		  /* 8218EA38h */ case    3:  		/* cmplwi CR6, R20, 0 */
		/* 8218EA38h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 8218EA38h case    3:*/		return 0x8218EA3C;
		  /* 8218EA3Ch */ case    4:  		/* stw R20, <#[R1 + 84]> */
		/* 8218EA3Ch case    4:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x00000054) );
		/* 8218EA3Ch case    4:*/		return 0x8218EA40;
		  /* 8218EA40h */ case    5:  		/* bc 12, CR6_EQ, 296 */
		/* 8218EA40h case    5:*/		if ( regs.CR[6].eq ) { return 0x8218EB68;  }
		/* 8218EA40h case    5:*/		return 0x8218EA44;
		  /* 8218EA44h */ case    6:  		/* mr R29, R17 */
		/* 8218EA44h case    6:*/		regs.R29 = regs.R17;
		/* 8218EA44h case    6:*/		return 0x8218EA48;
		  /* 8218EA48h */ case    7:  		/* lwz R11, <#[R14 + 12]> */
		/* 8218EA48h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218EA48h case    7:*/		return 0x8218EA4C;
		  /* 8218EA4Ch */ case    8:  		/* add R31, R29, R11 */
		/* 8218EA4Ch case    8:*/		cpu::op::add<0>(regs,&regs.R31,regs.R29,regs.R11);
		/* 8218EA4Ch case    8:*/		return 0x8218EA50;
		  /* 8218EA50h */ case    9:  		/* lwzx R11, <#[R29 + R11]> */
		/* 8218EA50h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 8218EA50h case    9:*/		return 0x8218EA54;
		  /* 8218EA54h */ case   10:  		/* lwz R10, <#[R31 + 36]> */
		/* 8218EA54h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000024) );
		/* 8218EA54h case   10:*/		return 0x8218EA58;
		  /* 8218EA58h */ case   11:  		/* rlwinm. R11, R11, 0, 12, 12 */
		/* 8218EA58h case   11:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R11,regs.R11);
		/* 8218EA58h case   11:*/		return 0x8218EA5C;
		  /* 8218EA5Ch */ case   12:  		/* or R25, R10, R25 */
		/* 8218EA5Ch case   12:*/		cpu::op::or<0>(regs,&regs.R25,regs.R10,regs.R25);
		/* 8218EA5Ch case   12:*/		return 0x8218EA60;
		  /* 8218EA60h */ case   13:  		/* bc 12, CR0_EQ, 248 */
		/* 8218EA60h case   13:*/		if ( regs.CR[0].eq ) { return 0x8218EB58;  }
		/* 8218EA60h case   13:*/		return 0x8218EA64;
		  /* 8218EA64h */ case   14:  		/* lwz R11, <#[R31 + 28]> */
		/* 8218EA64h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 8218EA64h case   14:*/		return 0x8218EA68;
		  /* 8218EA68h */ case   15:  		/* lwz R11, <#[R11]> */
		/* 8218EA68h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8218EA68h case   15:*/		return 0x8218EA6C;
		  /* 8218EA6Ch */ case   16:  		/* rlwinm. R11, R11, 0, 14, 27 */
		/* 8218EA6Ch case   16:*/		cpu::op::rlwinm<1,0,14,27>(regs,&regs.R11,regs.R11);
		/* 8218EA6Ch case   16:*/		return 0x8218EA70;
		  /* 8218EA70h */ case   17:  		/* lwz R11, <#[R31 + 4]> */
		/* 8218EA70h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8218EA70h case   17:*/		return 0x8218EA74;
		  /* 8218EA74h */ case   18:  		/* bc 12, CR0_EQ, 20 */
		/* 8218EA74h case   18:*/		if ( regs.CR[0].eq ) { return 0x8218EA88;  }
		/* 8218EA74h case   18:*/		return 0x8218EA78;
		  /* 8218EA78h */ case   19:  		/* rlwinm. R10, R11, 0, 16, 24 */
		/* 8218EA78h case   19:*/		cpu::op::rlwinm<1,0,16,24>(regs,&regs.R10,regs.R11);
		/* 8218EA78h case   19:*/		return 0x8218EA7C;
		  /* 8218EA7Ch */ case   20:  		/* bc 4, CR0_EQ, 1420 */
		/* 8218EA7Ch case   20:*/		if ( !regs.CR[0].eq ) { return 0x8218F008;  }
		/* 8218EA7Ch case   20:*/		return 0x8218EA80;
		  /* 8218EA80h */ case   21:  		/* rlwinm R11, R11, 0, 16, 6 */
		/* 8218EA80h case   21:*/		cpu::op::rlwinm<0,0,16,6>(regs,&regs.R11,regs.R11);
		/* 8218EA80h case   21:*/		return 0x8218EA84;
		  /* 8218EA84h */ case   22:  		/* b 208 */
		/* 8218EA84h case   22:*/		return 0x8218EB54;
		/* 8218EA84h case   22:*/		return 0x8218EA88;
	}
	return 0x8218EA88;
} // Block from 8218EA2Ch-8218EA88h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8218EA88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EA88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EA88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EA88);
		  /* 8218EA88h */ case    0:  		/* rlwinm R10, R11, 0, 25, 27 */
		/* 8218EA88h case    0:*/		cpu::op::rlwinm<0,0,25,27>(regs,&regs.R10,regs.R11);
		/* 8218EA88h case    0:*/		return 0x8218EA8C;
		  /* 8218EA8Ch */ case    1:  		/* cmplwi CR6, R10, 96 */
		/* 8218EA8Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000060);
		/* 8218EA8Ch case    1:*/		return 0x8218EA90;
		  /* 8218EA90h */ case    2:  		/* bc 12, CR6_EQ, 192 */
		/* 8218EA90h case    2:*/		if ( regs.CR[6].eq ) { return 0x8218EB50;  }
		/* 8218EA90h case    2:*/		return 0x8218EA94;
		  /* 8218EA94h */ case    3:  		/* addi R6, R1, 108 */
		/* 8218EA94h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x6C);
		/* 8218EA94h case    3:*/		return 0x8218EA98;
		  /* 8218EA98h */ case    4:  		/* addi R5, R1, 104 */
		/* 8218EA98h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x68);
		/* 8218EA98h case    4:*/		return 0x8218EA9C;
		  /* 8218EA9Ch */ case    5:  		/* mr R4, R30 */
		/* 8218EA9Ch case    5:*/		regs.R4 = regs.R30;
		/* 8218EA9Ch case    5:*/		return 0x8218EAA0;
		  /* 8218EAA0h */ case    6:  		/* mr R3, R14 */
		/* 8218EAA0h case    6:*/		regs.R3 = regs.R14;
		/* 8218EAA0h case    6:*/		return 0x8218EAA4;
		  /* 8218EAA4h */ case    7:  		/* bl -6028 */
		/* 8218EAA4h case    7:*/		regs.LR = 0x8218EAA8; return 0x8218D318;
		/* 8218EAA4h case    7:*/		return 0x8218EAA8;
		  /* 8218EAA8h */ case    8:  		/* lwz R11, <#[R31 + 4]> */
		/* 8218EAA8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8218EAA8h case    8:*/		return 0x8218EAAC;
		  /* 8218EAACh */ case    9:  		/* lwz R8, <#[R1 + 108]> */
		/* 8218EAACh case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x0000006C) );
		/* 8218EAACh case    9:*/		return 0x8218EAB0;
		  /* 8218EAB0h */ case   10:  		/* rlwinm. R10, R11, 25, 23, 31 */
		/* 8218EAB0h case   10:*/		cpu::op::rlwinm<1,25,23,31>(regs,&regs.R10,regs.R11);
		/* 8218EAB0h case   10:*/		return 0x8218EAB4;
		  /* 8218EAB4h */ case   11:  		/* bc 12, CR0_EQ, 48 */
		/* 8218EAB4h case   11:*/		if ( regs.CR[0].eq ) { return 0x8218EAE4;  }
		/* 8218EAB4h case   11:*/		return 0x8218EAB8;
		  /* 8218EAB8h */ case   12:  		/* lwz R9, <#[R31]> */
		/* 8218EAB8h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8218EAB8h case   12:*/		return 0x8218EABC;
		  /* 8218EABCh */ case   13:  		/* rlwinm R9, R9, 12, 23, 31 */
		/* 8218EABCh case   13:*/		cpu::op::rlwinm<0,12,23,31>(regs,&regs.R9,regs.R9);
		/* 8218EABCh case   13:*/		return 0x8218EAC0;
		  /* 8218EAC0h */ case   14:  		/* add R10, R9, R10 */
		/* 8218EAC0h case   14:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8218EAC0h case   14:*/		return 0x8218EAC4;
		  /* 8218EAC4h */ case   15:  		/* cmplw CR6, R10, R8 */
		/* 8218EAC4h case   15:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8218EAC4h case   15:*/		return 0x8218EAC8;
		  /* 8218EAC8h */ case   16:  		/* bc 12, CR6_GT, 16 */
		/* 8218EAC8h case   16:*/		if ( regs.CR[6].gt ) { return 0x8218EAD8;  }
		/* 8218EAC8h case   16:*/		return 0x8218EACC;
		  /* 8218EACCh */ case   17:  		/* lwz R10, <#[R1 + 104]> */
		/* 8218EACCh case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000068) );
		/* 8218EACCh case   17:*/		return 0x8218EAD0;
		  /* 8218EAD0h */ case   18:  		/* cmplw CR6, R9, R10 */
		/* 8218EAD0h case   18:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 8218EAD0h case   18:*/		return 0x8218EAD4;
		  /* 8218EAD4h */ case   19:  		/* bc 4, CR6_LT, 16 */
		/* 8218EAD4h case   19:*/		if ( !regs.CR[6].lt ) { return 0x8218EAE4;  }
		/* 8218EAD4h case   19:*/		return 0x8218EAD8;
	}
	return 0x8218EAD8;
} // Block from 8218EA88h-8218EAD8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8218EAD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EAD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EAD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EAD8);
		  /* 8218EAD8h */ case    0:  		/* lwz R10, <#[R31 + 12]> */
		/* 8218EAD8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8218EAD8h case    0:*/		return 0x8218EADC;
		  /* 8218EADCh */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 8218EADCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8218EADCh case    1:*/		return 0x8218EAE0;
		  /* 8218EAE0h */ case    2:  		/* bc 4, CR6_EQ, 1332 */
		/* 8218EAE0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8218F014;  }
		/* 8218EAE0h case    2:*/		return 0x8218EAE4;
	}
	return 0x8218EAE4;
} // Block from 8218EAD8h-8218EAE4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218EAE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EAE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EAE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EAE4);
		  /* 8218EAE4h */ case    0:  		/* lwz R10, <#[R31]> */
		/* 8218EAE4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8218EAE4h case    0:*/		return 0x8218EAE8;
		  /* 8218EAE8h */ case    1:  		/* rlwinm R4, R10, 12, 23, 31 */
		/* 8218EAE8h case    1:*/		cpu::op::rlwinm<0,12,23,31>(regs,&regs.R4,regs.R10);
		/* 8218EAE8h case    1:*/		return 0x8218EAEC;
		  /* 8218EAECh */ case    2:  		/* cmplwi CR6, R4, 255 */
		/* 8218EAECh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x000000FF);
		/* 8218EAECh case    2:*/		return 0x8218EAF0;
		  /* 8218EAF0h */ case    3:  		/* bc 12, CR6_GT, 104 */
		/* 8218EAF0h case    3:*/		if ( regs.CR[6].gt ) { return 0x8218EB58;  }
		/* 8218EAF0h case    3:*/		return 0x8218EAF4;
		  /* 8218EAF4h */ case    4:  		/* subf R10, R4, R8 */
		/* 8218EAF4h case    4:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R4,regs.R8);
		/* 8218EAF4h case    4:*/		return 0x8218EAF8;
		  /* 8218EAF8h */ case    5:  		/* rlwinm R5, R11, 16, 23, 31 */
		/* 8218EAF8h case    5:*/		cpu::op::rlwinm<0,16,23,31>(regs,&regs.R5,regs.R11);
		/* 8218EAF8h case    5:*/		return 0x8218EAFC;
		  /* 8218EAFCh */ case    6:  		/* cmplw CR6, R10, R5 */
		/* 8218EAFCh case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R5);
		/* 8218EAFCh case    6:*/		return 0x8218EB00;
		  /* 8218EB00h */ case    7:  		/* bc 4, CR6_LT, 8 */
		/* 8218EB00h case    7:*/		if ( !regs.CR[6].lt ) { return 0x8218EB08;  }
		/* 8218EB00h case    7:*/		return 0x8218EB04;
		  /* 8218EB04h */ case    8:  		/* mr R5, R10 */
		/* 8218EB04h case    8:*/		regs.R5 = regs.R10;
		/* 8218EB04h case    8:*/		return 0x8218EB08;
	}
	return 0x8218EB08;
} // Block from 8218EAE4h-8218EB08h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218EB08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EB08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EB08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EB08);
		  /* 8218EB08h */ case    0:  		/* rlwimi R11, R5, 16, 7, 15 */
		/* 8218EB08h case    0:*/		cpu::op::rlwimi<0,16,7,15>(regs,&regs.R11,regs.R5);
		/* 8218EB08h case    0:*/		return 0x8218EB0C;
		  /* 8218EB0Ch */ case    1:  		/* mr R10, R11 */
		/* 8218EB0Ch case    1:*/		regs.R10 = regs.R11;
		/* 8218EB0Ch case    1:*/		return 0x8218EB10;
		  /* 8218EB10h */ case    2:  		/* rlwinm R11, R11, 28, 29, 31 */
		/* 8218EB10h case    2:*/		cpu::op::rlwinm<0,28,29,31>(regs,&regs.R11,regs.R11);
		/* 8218EB10h case    2:*/		return 0x8218EB14;
		  /* 8218EB14h */ case    3:  		/* stw R10, <#[R31 + 4]> */
		/* 8218EB14h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8218EB14h case    3:*/		return 0x8218EB18;
		  /* 8218EB18h */ case    4:  		/* cmplwi CR6, R11, 1 */
		/* 8218EB18h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8218EB18h case    4:*/		return 0x8218EB1C;
		  /* 8218EB1Ch */ case    5:  		/* bc 12, CR6_LT, 40 */
		/* 8218EB1Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x8218EB44;  }
		/* 8218EB1Ch case    5:*/		return 0x8218EB20;
		  /* 8218EB20h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 8218EB20h case    6:*/		if ( regs.CR[6].eq ) { return 0x8218EB38;  }
		/* 8218EB20h case    6:*/		return 0x8218EB24;
		  /* 8218EB24h */ case    7:  		/* cmplwi CR6, R11, 3 */
		/* 8218EB24h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8218EB24h case    7:*/		return 0x8218EB28;
		  /* 8218EB28h */ case    8:  		/* bc 4, CR6_EQ, 48 */
		/* 8218EB28h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8218EB58;  }
		/* 8218EB28h case    8:*/		return 0x8218EB2C;
		  /* 8218EB2Ch */ case    9:  		/* addi R3, R1, 88 */
		/* 8218EB2Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 8218EB2Ch case    9:*/		return 0x8218EB30;
		  /* 8218EB30h */ case   10:  		/* bl -5184 */
		/* 8218EB30h case   10:*/		regs.LR = 0x8218EB34; return 0x8218D6F0;
		/* 8218EB30h case   10:*/		return 0x8218EB34;
		  /* 8218EB34h */ case   11:  		/* b 24 */
		/* 8218EB34h case   11:*/		return 0x8218EB4C;
		/* 8218EB34h case   11:*/		return 0x8218EB38;
	}
	return 0x8218EB38;
} // Block from 8218EB08h-8218EB38h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8218EB38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EB38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EB38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EB38);
		  /* 8218EB38h */ case    0:  		/* addi R3, R1, 96 */
		/* 8218EB38h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8218EB38h case    0:*/		return 0x8218EB3C;
		  /* 8218EB3Ch */ case    1:  		/* bl -5196 */
		/* 8218EB3Ch case    1:*/		regs.LR = 0x8218EB40; return 0x8218D6F0;
		/* 8218EB3Ch case    1:*/		return 0x8218EB40;
		  /* 8218EB40h */ case    2:  		/* b 12 */
		/* 8218EB40h case    2:*/		return 0x8218EB4C;
		/* 8218EB40h case    2:*/		return 0x8218EB44;
	}
	return 0x8218EB44;
} // Block from 8218EB38h-8218EB44h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218EB44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EB44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EB44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EB44);
		  /* 8218EB44h */ case    0:  		/* addi R3, R1, 128 */
		/* 8218EB44h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 8218EB44h case    0:*/		return 0x8218EB48;
		  /* 8218EB48h */ case    1:  		/* bl -5344 */
		/* 8218EB48h case    1:*/		regs.LR = 0x8218EB4C; return 0x8218D668;
		/* 8218EB48h case    1:*/		return 0x8218EB4C;
	}
	return 0x8218EB4C;
} // Block from 8218EB44h-8218EB4Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218EB4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EB4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EB4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EB4C);
		  /* 8218EB4Ch */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8218EB4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8218EB4Ch case    0:*/		return 0x8218EB50;
	}
	return 0x8218EB50;
} // Block from 8218EB4Ch-8218EB50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218EB50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EB50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EB50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EB50);
		  /* 8218EB50h */ case    0:  		/* oris R11, R11, 512 */
		/* 8218EB50h case    0:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 8218EB50h case    0:*/		return 0x8218EB54;
	}
	return 0x8218EB54;
} // Block from 8218EB50h-8218EB54h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218EB54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EB54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EB54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EB54);
		  /* 8218EB54h */ case    0:  		/* stw R11, <#[R31 + 4]> */
		/* 8218EB54h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8218EB54h case    0:*/		return 0x8218EB58;
	}
	return 0x8218EB58;
} // Block from 8218EB54h-8218EB58h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218EB58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EB58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EB58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EB58);
		  /* 8218EB58h */ case    0:  		/* addi R30, R30, 1 */
		/* 8218EB58h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8218EB58h case    0:*/		return 0x8218EB5C;
		  /* 8218EB5Ch */ case    1:  		/* addi R29, R29, 40 */
		/* 8218EB5Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x28);
		/* 8218EB5Ch case    1:*/		return 0x8218EB60;
		  /* 8218EB60h */ case    2:  		/* cmplw CR6, R30, R20 */
		/* 8218EB60h case    2:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R20);
		/* 8218EB60h case    2:*/		return 0x8218EB64;
		  /* 8218EB64h */ case    3:  		/* bc 12, CR6_LT, -284 */
		/* 8218EB64h case    3:*/		if ( regs.CR[6].lt ) { return 0x8218EA48;  }
		/* 8218EB64h case    3:*/		return 0x8218EB68;
	}
	return 0x8218EB68;
} // Block from 8218EB58h-8218EB68h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218EB68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EB68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EB68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EB68);
		  /* 8218EB68h */ case    0:  		/* li R5, 128 */
		/* 8218EB68h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x80);
		/* 8218EB68h case    0:*/		return 0x8218EB6C;
		  /* 8218EB6Ch */ case    1:  		/* stw R14, <#[R1 + 176]> */
		/* 8218EB6Ch case    1:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x000000B0) );
		/* 8218EB6Ch case    1:*/		return 0x8218EB70;
		  /* 8218EB70h */ case    2:  		/* li R4, 0 */
		/* 8218EB70h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8218EB70h case    2:*/		return 0x8218EB74;
		  /* 8218EB74h */ case    3:  		/* addi R3, R1, 184 */
		/* 8218EB74h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xB8);
		/* 8218EB74h case    3:*/		return 0x8218EB78;
		  /* 8218EB78h */ case    4:  		/* bl -1038392 */
		/* 8218EB78h case    4:*/		regs.LR = 0x8218EB7C; return 0x82091340;
		/* 8218EB78h case    4:*/		return 0x8218EB7C;
		  /* 8218EB7Ch */ case    5:  		/* mr R26, R17 */
		/* 8218EB7Ch case    5:*/		regs.R26 = regs.R17;
		/* 8218EB7Ch case    5:*/		return 0x8218EB80;
		  /* 8218EB80h */ case    6:  		/* cmplwi CR6, R20, 0 */
		/* 8218EB80h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 8218EB80h case    6:*/		return 0x8218EB84;
		  /* 8218EB84h */ case    7:  		/* bc 12, CR6_EQ, 340 */
		/* 8218EB84h case    7:*/		if ( regs.CR[6].eq ) { return 0x8218ECD8;  }
		/* 8218EB84h case    7:*/		return 0x8218EB88;
		  /* 8218EB88h */ case    8:  		/* mr R27, R17 */
		/* 8218EB88h case    8:*/		regs.R27 = regs.R17;
		/* 8218EB88h case    8:*/		return 0x8218EB8C;
		  /* 8218EB8Ch */ case    9:  		/* lwz R11, <#[R14 + 12]> */
		/* 8218EB8Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218EB8Ch case    9:*/		return 0x8218EB90;
		  /* 8218EB90h */ case   10:  		/* add R28, R27, R11 */
		/* 8218EB90h case   10:*/		cpu::op::add<0>(regs,&regs.R28,regs.R27,regs.R11);
		/* 8218EB90h case   10:*/		return 0x8218EB94;
		  /* 8218EB94h */ case   11:  		/* lwz R11, <#[R28 + 4]> */
		/* 8218EB94h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8218EB94h case   11:*/		return 0x8218EB98;
		  /* 8218EB98h */ case   12:  		/* rlwinm. R11, R11, 0, 6, 6 */
		/* 8218EB98h case   12:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R11,regs.R11);
		/* 8218EB98h case   12:*/		return 0x8218EB9C;
		  /* 8218EB9Ch */ case   13:  		/* bc 4, CR0_EQ, 300 */
		/* 8218EB9Ch case   13:*/		if ( !regs.CR[0].eq ) { return 0x8218ECC8;  }
		/* 8218EB9Ch case   13:*/		return 0x8218EBA0;
		  /* 8218EBA0h */ case   14:  		/* lwz R11, <#[R28]> */
		/* 8218EBA0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8218EBA0h case   14:*/		return 0x8218EBA4;
		  /* 8218EBA4h */ case   15:  		/* rlwinm. R10, R11, 0, 12, 12 */
		/* 8218EBA4h case   15:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R10,regs.R11);
		/* 8218EBA4h case   15:*/		return 0x8218EBA8;
		  /* 8218EBA8h */ case   16:  		/* bc 12, CR0_EQ, 288 */
		/* 8218EBA8h case   16:*/		if ( regs.CR[0].eq ) { return 0x8218ECC8;  }
		/* 8218EBA8h case   16:*/		return 0x8218EBAC;
		  /* 8218EBACh */ case   17:  		/* rlwinm R11, R11, 0, 3, 11 */
		/* 8218EBACh case   17:*/		cpu::op::rlwinm<0,0,3,11>(regs,&regs.R11,regs.R11);
		/* 8218EBACh case   17:*/		return 0x8218EBB0;
		  /* 8218EBB0h */ case   18:  		/* lis R10, 4080 */
		/* 8218EBB0h case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0xFF0);
		/* 8218EBB0h case   18:*/		return 0x8218EBB4;
		  /* 8218EBB4h */ case   19:  		/* cmplw CR6, R11, R10 */
		/* 8218EBB4h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8218EBB4h case   19:*/		return 0x8218EBB8;
		  /* 8218EBB8h */ case   20:  		/* bc 12, CR6_GT, 272 */
		/* 8218EBB8h case   20:*/		if ( regs.CR[6].gt ) { return 0x8218ECC8;  }
		/* 8218EBB8h case   20:*/		return 0x8218EBBC;
		  /* 8218EBBCh */ case   21:  		/* addi R3, R1, 184 */
		/* 8218EBBCh case   21:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xB8);
		/* 8218EBBCh case   21:*/		return 0x8218EBC0;
		  /* 8218EBC0h */ case   22:  		/* addi R4, R1, 328 */
		/* 8218EBC0h case   22:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x148);
		/* 8218EBC0h case   22:*/		return 0x8218EBC4;
		  /* 8218EBC4h */ case   23:  		/* li R5, 128 */
		/* 8218EBC4h case   23:*/		cpu::op::li<0>(regs,&regs.R5,0x80);
		/* 8218EBC4h case   23:*/		return 0x8218EBC8;
		  /* 8218EBC8h */ case   24:  		/* bl -1036824 */
		/* 8218EBC8h case   24:*/		regs.LR = 0x8218EBCC; return 0x820919B0;
		/* 8218EBC8h case   24:*/		return 0x8218EBCC;
		  /* 8218EBCCh */ case   25:  		/* addi R4, R1, 176 */
		/* 8218EBCCh case   25:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xB0);
		/* 8218EBCCh case   25:*/		return 0x8218EBD0;
		  /* 8218EBD0h */ case   26:  		/* mr R3, R14 */
		/* 8218EBD0h case   26:*/		regs.R3 = regs.R14;
		/* 8218EBD0h case   26:*/		return 0x8218EBD4;
		  /* 8218EBD4h */ case   27:  		/* bl -5100 */
		/* 8218EBD4h case   27:*/		regs.LR = 0x8218EBD8; return 0x8218D7E8;
		/* 8218EBD4h case   27:*/		return 0x8218EBD8;
		  /* 8218EBD8h */ case   28:  		/* mr R29, R17 */
		/* 8218EBD8h case   28:*/		regs.R29 = regs.R17;
		/* 8218EBD8h case   28:*/		return 0x8218EBDC;
		  /* 8218EBDCh */ case   29:  		/* mr R30, R17 */
		/* 8218EBDCh case   29:*/		regs.R30 = regs.R17;
		/* 8218EBDCh case   29:*/		return 0x8218EBE0;
		  /* 8218EBE0h */ case   30:  		/* lwz R11, <#[R14 + 12]> */
		/* 8218EBE0h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218EBE0h case   30:*/		return 0x8218EBE4;
		  /* 8218EBE4h */ case   31:  		/* add R31, R30, R11 */
		/* 8218EBE4h case   31:*/		cpu::op::add<0>(regs,&regs.R31,regs.R30,regs.R11);
		/* 8218EBE4h case   31:*/		return 0x8218EBE8;
		  /* 8218EBE8h */ case   32:  		/* lwzx R11, <#[R30 + R11]> */
		/* 8218EBE8h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8218EBE8h case   32:*/		return 0x8218EBEC;
		  /* 8218EBECh */ case   33:  		/* rlwinm. R10, R11, 0, 12, 12 */
		/* 8218EBECh case   33:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R10,regs.R11);
		/* 8218EBECh case   33:*/		return 0x8218EBF0;
		  /* 8218EBF0h */ case   34:  		/* bc 12, CR0_EQ, 200 */
		/* 8218EBF0h case   34:*/		if ( regs.CR[0].eq ) { return 0x8218ECB8;  }
		/* 8218EBF0h case   34:*/		return 0x8218EBF4;
		  /* 8218EBF4h */ case   35:  		/* lwz R10, <#[R31 + 4]> */
		/* 8218EBF4h case   35:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8218EBF4h case   35:*/		return 0x8218EBF8;
		  /* 8218EBF8h */ case   36:  		/* rlwinm. R9, R10, 0, 6, 6 */
		/* 8218EBF8h case   36:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R9,regs.R10);
		/* 8218EBF8h case   36:*/		return 0x8218EBFC;
		  /* 8218EBFCh */ case   37:  		/* bc 4, CR0_EQ, 188 */
		/* 8218EBFCh case   37:*/		if ( !regs.CR[0].eq ) { return 0x8218ECB8;  }
		/* 8218EBFCh case   37:*/		return 0x8218EC00;
		  /* 8218EC00h */ case   38:  		/* lwz R9, <#[R31 + 36]> */
		/* 8218EC00h case   38:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000024) );
		/* 8218EC00h case   38:*/		return 0x8218EC04;
		  /* 8218EC04h */ case   39:  		/* lwz R8, <#[R28 + 36]> */
		/* 8218EC04h case   39:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R28 + 0x00000024) );
		/* 8218EC04h case   39:*/		return 0x8218EC08;
		  /* 8218EC08h */ case   40:  		/* cmplw CR6, R9, R8 */
		/* 8218EC08h case   40:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 8218EC08h case   40:*/		return 0x8218EC0C;
		  /* 8218EC0Ch */ case   41:  		/* bc 4, CR6_EQ, 172 */
		/* 8218EC0Ch case   41:*/		if ( !regs.CR[6].eq ) { return 0x8218ECB8;  }
		/* 8218EC0Ch case   41:*/		return 0x8218EC10;
		  /* 8218EC10h */ case   42:  		/* rlwinm R4, R11, 12, 23, 31 */
		/* 8218EC10h case   42:*/		cpu::op::rlwinm<0,12,23,31>(regs,&regs.R4,regs.R11);
		/* 8218EC10h case   42:*/		return 0x8218EC14;
		  /* 8218EC14h */ case   43:  		/* cmplwi CR6, R4, 255 */
		/* 8218EC14h case   43:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x000000FF);
		/* 8218EC14h case   43:*/		return 0x8218EC18;
		  /* 8218EC18h */ case   44:  		/* bc 12, CR6_GT, 160 */
		/* 8218EC18h case   44:*/		if ( regs.CR[6].gt ) { return 0x8218ECB8;  }
		/* 8218EC18h case   44:*/		return 0x8218EC1C;
		  /* 8218EC1Ch */ case   45:  		/* rlwinm R5, R10, 16, 23, 31 */
		/* 8218EC1Ch case   45:*/		cpu::op::rlwinm<0,16,23,31>(regs,&regs.R5,regs.R10);
		/* 8218EC1Ch case   45:*/		return 0x8218EC20;
		  /* 8218EC20h */ case   46:  		/* mr R11, R4 */
		/* 8218EC20h case   46:*/		regs.R11 = regs.R4;
		/* 8218EC20h case   46:*/		return 0x8218EC24;
		  /* 8218EC24h */ case   47:  		/* add R10, R5, R4 */
		/* 8218EC24h case   47:*/		cpu::op::add<0>(regs,&regs.R10,regs.R5,regs.R4);
		/* 8218EC24h case   47:*/		return 0x8218EC28;
		  /* 8218EC28h */ case   48:  		/* cmplw CR6, R4, R10 */
		/* 8218EC28h case   48:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 8218EC28h case   48:*/		return 0x8218EC2C;
		  /* 8218EC2Ch */ case   49:  		/* bc 4, CR6_LT, 120 */
		/* 8218EC2Ch case   49:*/		if ( !regs.CR[6].lt ) { return 0x8218ECA4;  }
		/* 8218EC2Ch case   49:*/		return 0x8218EC30;
		  /* 8218EC30h */ case   50:  		/* rlwinm R10, R11, 4, 0, 27 */
		/* 8218EC30h case   50:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R11);
		/* 8218EC30h case   50:*/		return 0x8218EC34;
		  /* 8218EC34h */ case   51:  		/* li R9, 2 */
		/* 8218EC34h case   51:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 8218EC34h case   51:*/		return 0x8218EC38;
		  /* 8218EC38h */ case   52:  		/* ori R8, R10, 4 */
		/* 8218EC38h case   52:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x4);
		/* 8218EC38h case   52:*/		return 0x8218EC3C;
		  /* 8218EC3Ch */ case   53:  		/* addi R7, R1, 184 */
		/* 8218EC3Ch case   53:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xB8);
		/* 8218EC3Ch case   53:*/		return 0x8218EC40;
		  /* 8218EC40h */ case   54:  		/* rlwinm R10, R8, 30, 2, 29 */
		/* 8218EC40h case   54:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R10,regs.R8);
		/* 8218EC40h case   54:*/		return 0x8218EC44;
		  /* 8218EC44h */ case   55:  		/* rlwinm R6, R8, 27, 5, 28 */
		/* 8218EC44h case   55:*/		cpu::op::rlwinm<0,27,5,28>(regs,&regs.R6,regs.R8);
		/* 8218EC44h case   55:*/		return 0x8218EC48;
		  /* 8218EC48h */ case   56:  		/* addi R3, R10, 3 */
		/* 8218EC48h case   56:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0x3);
		/* 8218EC48h case   56:*/		return 0x8218EC4C;
		  /* 8218EC4Ch */ case   57:  		/* rldicl R24, R10, 0, 58 */
		/* 8218EC4Ch case   57:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R24,regs.R10);
		/* 8218EC4Ch case   57:*/		return 0x8218EC50;
		  /* 8218EC50h */ case   58:  		/* rldicl R10, R3, 0, 58 */
		/* 8218EC50h case   58:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R10,regs.R3);
		/* 8218EC50h case   58:*/		return 0x8218EC54;
		  /* 8218EC54h */ case   59:  		/* li R3, -1 */
		/* 8218EC54h case   59:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8218EC54h case   59:*/		return 0x8218EC58;
		  /* 8218EC58h */ case   60:  		/* sld R10, R9, R10 */
		/* 8218EC58h case   60:*/		cpu::op::sld<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8218EC58h case   60:*/		return 0x8218EC5C;
		  /* 8218EC5Ch */ case   61:  		/* ldx R9, <#[R6 + R7]> */
		/* 8218EC5Ch case   61:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R6 + regs.R7 + 0x00000000) );
		/* 8218EC5Ch case   61:*/		return 0x8218EC60;
		  /* 8218EC60h */ case   62:  		/* addi R10, R10, -1 */
		/* 8218EC60h case   62:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8218EC60h case   62:*/		return 0x8218EC64;
		  /* 8218EC64h */ case   63:  		/* sld R7, R3, R24 */
		/* 8218EC64h case   63:*/		cpu::op::sld<0>(regs,&regs.R7,regs.R3,regs.R24);
		/* 8218EC64h case   63:*/		return 0x8218EC68;
		  /* 8218EC68h */ case   64:  		/* and R10, R10, R9 */
		/* 8218EC68h case   64:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8218EC68h case   64:*/		return 0x8218EC6C;
		  /* 8218EC6Ch */ case   65:  		/* and R10, R10, R7 */
		/* 8218EC6Ch case   65:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 8218EC6Ch case   65:*/		return 0x8218EC70;
		  /* 8218EC70h */ case   66:  		/* srd R10, R10, R24 */
		/* 8218EC70h case   66:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R24);
		/* 8218EC70h case   66:*/		return 0x8218EC74;
		  /* 8218EC74h */ case   67:  		/* rlwinm R10, R10, 0, 0, 31 */
		/* 8218EC74h case   67:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R10);
		/* 8218EC74h case   67:*/		return 0x8218EC78;
		  /* 8218EC78h */ case   68:  		/* and R10, R10, R8 */
		/* 8218EC78h case   68:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8218EC78h case   68:*/		return 0x8218EC7C;
		  /* 8218EC7Ch */ case   69:  		/* rlwinm. R10, R10, 0, 28, 31 */
		/* 8218EC7Ch case   69:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R10,regs.R10);
		/* 8218EC7Ch case   69:*/		return 0x8218EC80;
		  /* 8218EC80h */ case   70:  		/* bc 4, CR0_EQ, 928 */
		/* 8218EC80h case   70:*/		if ( !regs.CR[0].eq ) { return 0x8218F020;  }
		/* 8218EC80h case   70:*/		return 0x8218EC84;
		  /* 8218EC84h */ case   71:  		/* lhz R10, <#[R31 + 4]> */
		/* 8218EC84h case   71:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8218EC84h case   71:*/		return 0x8218EC88;
		  /* 8218EC88h */ case   72:  		/* addi R11, R11, 1 */
		/* 8218EC88h case   72:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218EC88h case   72:*/		return 0x8218EC8C;
		  /* 8218EC8Ch */ case   73:  		/* lwz R9, <#[R31]> */
		/* 8218EC8Ch case   73:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8218EC8Ch case   73:*/		return 0x8218EC90;
		  /* 8218EC90h */ case   74:  		/* rlwinm R10, R10, 0, 23, 31 */
		/* 8218EC90h case   74:*/		cpu::op::rlwinm<0,0,23,31>(regs,&regs.R10,regs.R10);
		/* 8218EC90h case   74:*/		return 0x8218EC94;
		  /* 8218EC94h */ case   75:  		/* rlwinm R9, R9, 12, 23, 31 */
		/* 8218EC94h case   75:*/		cpu::op::rlwinm<0,12,23,31>(regs,&regs.R9,regs.R9);
		/* 8218EC94h case   75:*/		return 0x8218EC98;
		  /* 8218EC98h */ case   76:  		/* add R10, R9, R10 */
		/* 8218EC98h case   76:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8218EC98h case   76:*/		return 0x8218EC9C;
		  /* 8218EC9Ch */ case   77:  		/* cmplw CR6, R11, R10 */
		/* 8218EC9Ch case   77:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8218EC9Ch case   77:*/		return 0x8218ECA0;
		  /* 8218ECA0h */ case   78:  		/* bc 12, CR6_LT, -112 */
		/* 8218ECA0h case   78:*/		if ( regs.CR[6].lt ) { return 0x8218EC30;  }
		/* 8218ECA0h case   78:*/		return 0x8218ECA4;
	}
	return 0x8218ECA4;
} // Block from 8218EB68h-8218ECA4h (79 instructions)

//////////////////////////////////////////////////////
// Block at 8218ECA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218ECA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218ECA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218ECA4);
		  /* 8218ECA4h */ case    0:  		/* addi R3, R1, 320 */
		/* 8218ECA4h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x140);
		/* 8218ECA4h case    0:*/		return 0x8218ECA8;
		  /* 8218ECA8h */ case    1:  		/* bl -6008 */
		/* 8218ECA8h case    1:*/		regs.LR = 0x8218ECAC; return 0x8218D530;
		/* 8218ECA8h case    1:*/		return 0x8218ECAC;
		  /* 8218ECACh */ case    2:  		/* lwz R11, <#[R31 + 4]> */
		/* 8218ECACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8218ECACh case    2:*/		return 0x8218ECB0;
		  /* 8218ECB0h */ case    3:  		/* oris R11, R11, 512 */
		/* 8218ECB0h case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 8218ECB0h case    3:*/		return 0x8218ECB4;
		  /* 8218ECB4h */ case    4:  		/* stw R11, <#[R31 + 4]> */
		/* 8218ECB4h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8218ECB4h case    4:*/		return 0x8218ECB8;
	}
	return 0x8218ECB8;
} // Block from 8218ECA4h-8218ECB8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218ECB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218ECB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218ECB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218ECB8);
		  /* 8218ECB8h */ case    0:  		/* addi R29, R29, 1 */
		/* 8218ECB8h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8218ECB8h case    0:*/		return 0x8218ECBC;
		  /* 8218ECBCh */ case    1:  		/* addi R30, R30, 40 */
		/* 8218ECBCh case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x28);
		/* 8218ECBCh case    1:*/		return 0x8218ECC0;
		  /* 8218ECC0h */ case    2:  		/* cmplw CR6, R29, R20 */
		/* 8218ECC0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R20);
		/* 8218ECC0h case    2:*/		return 0x8218ECC4;
		  /* 8218ECC4h */ case    3:  		/* bc 12, CR6_LT, -228 */
		/* 8218ECC4h case    3:*/		if ( regs.CR[6].lt ) { return 0x8218EBE0;  }
		/* 8218ECC4h case    3:*/		return 0x8218ECC8;
	}
	return 0x8218ECC8;
} // Block from 8218ECB8h-8218ECC8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218ECC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218ECC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218ECC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218ECC8);
		  /* 8218ECC8h */ case    0:  		/* addi R26, R26, 1 */
		/* 8218ECC8h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 8218ECC8h case    0:*/		return 0x8218ECCC;
		  /* 8218ECCCh */ case    1:  		/* addi R27, R27, 40 */
		/* 8218ECCCh case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x28);
		/* 8218ECCCh case    1:*/		return 0x8218ECD0;
		  /* 8218ECD0h */ case    2:  		/* cmplw CR6, R26, R20 */
		/* 8218ECD0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R20);
		/* 8218ECD0h case    2:*/		return 0x8218ECD4;
		  /* 8218ECD4h */ case    3:  		/* bc 12, CR6_LT, -328 */
		/* 8218ECD4h case    3:*/		if ( regs.CR[6].lt ) { return 0x8218EB8C;  }
		/* 8218ECD4h case    3:*/		return 0x8218ECD8;
	}
	return 0x8218ECD8;
} // Block from 8218ECC8h-8218ECD8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218ECD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218ECD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218ECD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218ECD8);
		  /* 8218ECD8h */ case    0:  		/* li R21, -1 */
		/* 8218ECD8h case    0:*/		cpu::op::li<0>(regs,&regs.R21,0xFFFFFFFF);
		/* 8218ECD8h case    0:*/		return 0x8218ECDC;
		  /* 8218ECDCh */ case    1:  		/* cmplwi CR6, R25, 0 */
		/* 8218ECDCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 8218ECDCh case    1:*/		return 0x8218ECE0;
		  /* 8218ECE0h */ case    2:  		/* bc 12, CR6_EQ, 532 */
		/* 8218ECE0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8218EEF4;  }
		/* 8218ECE0h case    2:*/		return 0x8218ECE4;
		  /* 8218ECE4h */ case    3:  		/* mr R22, R17 */
		/* 8218ECE4h case    3:*/		regs.R22 = regs.R17;
		/* 8218ECE4h case    3:*/		return 0x8218ECE8;
		  /* 8218ECE8h */ case    4:  		/* cmplwi CR6, R20, 0 */
		/* 8218ECE8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 8218ECE8h case    4:*/		return 0x8218ECEC;
		  /* 8218ECECh */ case    5:  		/* bc 12, CR6_EQ, 508 */
		/* 8218ECECh case    5:*/		if ( regs.CR[6].eq ) { return 0x8218EEE8;  }
		/* 8218ECECh case    5:*/		return 0x8218ECF0;
		  /* 8218ECF0h */ case    6:  		/* mr R23, R17 */
		/* 8218ECF0h case    6:*/		regs.R23 = regs.R17;
		/* 8218ECF0h case    6:*/		return 0x8218ECF4;
		  /* 8218ECF4h */ case    7:  		/* lwz R11, <#[R14 + 12]> */
		/* 8218ECF4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218ECF4h case    7:*/		return 0x8218ECF8;
		  /* 8218ECF8h */ case    8:  		/* add R24, R23, R11 */
		/* 8218ECF8h case    8:*/		cpu::op::add<0>(regs,&regs.R24,regs.R23,regs.R11);
		/* 8218ECF8h case    8:*/		return 0x8218ECFC;
		  /* 8218ECFCh */ case    9:  		/* lwz R11, <#[R24 + 4]> */
		/* 8218ECFCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 8218ECFCh case    9:*/		return 0x8218ED00;
		  /* 8218ED00h */ case   10:  		/* rlwinm. R10, R11, 0, 6, 6 */
		/* 8218ED00h case   10:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R10,regs.R11);
		/* 8218ED00h case   10:*/		return 0x8218ED04;
		  /* 8218ED04h */ case   11:  		/* bc 4, CR0_EQ, 468 */
		/* 8218ED04h case   11:*/		if ( !regs.CR[0].eq ) { return 0x8218EED8;  }
		/* 8218ED04h case   11:*/		return 0x8218ED08;
		  /* 8218ED08h */ case   12:  		/* lwz R10, <#[R24 + 36]> */
		/* 8218ED08h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000024) );
		/* 8218ED08h case   12:*/		return 0x8218ED0C;
		  /* 8218ED0Ch */ case   13:  		/* cmplwi CR6, R10, 0 */
		/* 8218ED0Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8218ED0Ch case   13:*/		return 0x8218ED10;
		  /* 8218ED10h */ case   14:  		/* bc 12, CR6_EQ, 456 */
		/* 8218ED10h case   14:*/		if ( regs.CR[6].eq ) { return 0x8218EED8;  }
		/* 8218ED10h case   14:*/		return 0x8218ED14;
		  /* 8218ED14h */ case   15:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 8218ED14h case   15:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 8218ED14h case   15:*/		return 0x8218ED18;
		  /* 8218ED18h */ case   16:  		/* bc 4, CR0_EQ, 448 */
		/* 8218ED18h case   16:*/		if ( !regs.CR[0].eq ) { return 0x8218EED8;  }
		/* 8218ED18h case   16:*/		return 0x8218ED1C;
		  /* 8218ED1Ch */ case   17:  		/* addi R3, R1, 184 */
		/* 8218ED1Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xB8);
		/* 8218ED1Ch case   17:*/		return 0x8218ED20;
		  /* 8218ED20h */ case   18:  		/* addi R4, R1, 328 */
		/* 8218ED20h case   18:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x148);
		/* 8218ED20h case   18:*/		return 0x8218ED24;
		  /* 8218ED24h */ case   19:  		/* li R5, 128 */
		/* 8218ED24h case   19:*/		cpu::op::li<0>(regs,&regs.R5,0x80);
		/* 8218ED24h case   19:*/		return 0x8218ED28;
		  /* 8218ED28h */ case   20:  		/* bl -1037176 */
		/* 8218ED28h case   20:*/		regs.LR = 0x8218ED2C; return 0x820919B0;
		/* 8218ED28h case   20:*/		return 0x8218ED2C;
		  /* 8218ED2Ch */ case   21:  		/* mr R26, R21 */
		/* 8218ED2Ch case   21:*/		regs.R26 = regs.R21;
		/* 8218ED2Ch case   21:*/		return 0x8218ED30;
		  /* 8218ED30h */ case   22:  		/* mr R25, R17 */
		/* 8218ED30h case   22:*/		regs.R25 = regs.R17;
		/* 8218ED30h case   22:*/		return 0x8218ED34;
		  /* 8218ED34h */ case   23:  		/* mr R31, R17 */
		/* 8218ED34h case   23:*/		regs.R31 = regs.R17;
		/* 8218ED34h case   23:*/		return 0x8218ED38;
		  /* 8218ED38h */ case   24:  		/* mr R30, R20 */
		/* 8218ED38h case   24:*/		regs.R30 = regs.R20;
		/* 8218ED38h case   24:*/		return 0x8218ED3C;
		  /* 8218ED3Ch */ case   25:  		/* lwz R11, <#[R14 + 12]> */
		/* 8218ED3Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218ED3Ch case   25:*/		return 0x8218ED40;
		  /* 8218ED40h */ case   26:  		/* add R11, R31, R11 */
		/* 8218ED40h case   26:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 8218ED40h case   26:*/		return 0x8218ED44;
		  /* 8218ED44h */ case   27:  		/* lwz R10, <#[R11 + 4]> */
		/* 8218ED44h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8218ED44h case   27:*/		return 0x8218ED48;
		  /* 8218ED48h */ case   28:  		/* rlwinm. R9, R10, 0, 6, 6 */
		/* 8218ED48h case   28:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R9,regs.R10);
		/* 8218ED48h case   28:*/		return 0x8218ED4C;
		  /* 8218ED4Ch */ case   29:  		/* bc 12, CR0_EQ, 40 */
		/* 8218ED4Ch case   29:*/		if ( regs.CR[0].eq ) { return 0x8218ED74;  }
		/* 8218ED4Ch case   29:*/		return 0x8218ED50;
		  /* 8218ED50h */ case   30:  		/* lwz R9, <#[R11 + 36]> */
		/* 8218ED50h case   30:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000024) );
		/* 8218ED50h case   30:*/		return 0x8218ED54;
		  /* 8218ED54h */ case   31:  		/* lwz R8, <#[R24 + 36]> */
		/* 8218ED54h case   31:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R24 + 0x00000024) );
		/* 8218ED54h case   31:*/		return 0x8218ED58;
		  /* 8218ED58h */ case   32:  		/* cmplw CR6, R9, R8 */
		/* 8218ED58h case   32:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 8218ED58h case   32:*/		return 0x8218ED5C;
		  /* 8218ED5Ch */ case   33:  		/* bc 4, CR6_EQ, 24 */
		/* 8218ED5Ch case   33:*/		if ( !regs.CR[6].eq ) { return 0x8218ED74;  }
		/* 8218ED5Ch case   33:*/		return 0x8218ED60;
		  /* 8218ED60h */ case   34:  		/* lwz R11, <#[R11]> */
		/* 8218ED60h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8218ED60h case   34:*/		return 0x8218ED64;
		  /* 8218ED64h */ case   35:  		/* rlwinm R5, R10, 16, 23, 31 */
		/* 8218ED64h case   35:*/		cpu::op::rlwinm<0,16,23,31>(regs,&regs.R5,regs.R10);
		/* 8218ED64h case   35:*/		return 0x8218ED68;
		  /* 8218ED68h */ case   36:  		/* addi R3, R1, 176 */
		/* 8218ED68h case   36:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xB0);
		/* 8218ED68h case   36:*/		return 0x8218ED6C;
		  /* 8218ED6Ch */ case   37:  		/* rlwinm R4, R11, 12, 23, 31 */
		/* 8218ED6Ch case   37:*/		cpu::op::rlwinm<0,12,23,31>(regs,&regs.R4,regs.R11);
		/* 8218ED6Ch case   37:*/		return 0x8218ED70;
		  /* 8218ED70h */ case   38:  		/* bl -6056 */
		/* 8218ED70h case   38:*/		regs.LR = 0x8218ED74; return 0x8218D5C8;
		/* 8218ED70h case   38:*/		return 0x8218ED74;
	}
	return 0x8218ED74;
} // Block from 8218ECD8h-8218ED74h (39 instructions)

//////////////////////////////////////////////////////
// Block at 8218ED74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218ED74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218ED74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218ED74);
		  /* 8218ED74h */ case    0:  		/* addic. R30, R30, -1 */
		/* 8218ED74h case    0:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 8218ED74h case    0:*/		return 0x8218ED78;
		  /* 8218ED78h */ case    1:  		/* addi R31, R31, 40 */
		/* 8218ED78h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x28);
		/* 8218ED78h case    1:*/		return 0x8218ED7C;
		  /* 8218ED7Ch */ case    2:  		/* bc 4, CR0_EQ, -64 */
		/* 8218ED7Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x8218ED3C;  }
		/* 8218ED7Ch case    2:*/		return 0x8218ED80;
		  /* 8218ED80h */ case    3:  		/* addi R4, R1, 176 */
		/* 8218ED80h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xB0);
		/* 8218ED80h case    3:*/		return 0x8218ED84;
		  /* 8218ED84h */ case    4:  		/* mr R3, R14 */
		/* 8218ED84h case    4:*/		regs.R3 = regs.R14;
		/* 8218ED84h case    4:*/		return 0x8218ED88;
		  /* 8218ED88h */ case    5:  		/* bl -5536 */
		/* 8218ED88h case    5:*/		regs.LR = 0x8218ED8C; return 0x8218D7E8;
		/* 8218ED88h case    5:*/		return 0x8218ED8C;
		  /* 8218ED8Ch */ case    6:  		/* mr R30, R17 */
		/* 8218ED8Ch case    6:*/		regs.R30 = regs.R17;
		/* 8218ED8Ch case    6:*/		return 0x8218ED90;
		  /* 8218ED90h */ case    7:  		/* mr R29, R20 */
		/* 8218ED90h case    7:*/		regs.R29 = regs.R20;
		/* 8218ED90h case    7:*/		return 0x8218ED94;
		  /* 8218ED94h */ case    8:  		/* lwz R11, <#[R14 + 12]> */
		/* 8218ED94h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218ED94h case    8:*/		return 0x8218ED98;
		  /* 8218ED98h */ case    9:  		/* add R31, R30, R11 */
		/* 8218ED98h case    9:*/		cpu::op::add<0>(regs,&regs.R31,regs.R30,regs.R11);
		/* 8218ED98h case    9:*/		return 0x8218ED9C;
		  /* 8218ED9Ch */ case   10:  		/* lwz R11, <#[R31 + 4]> */
		/* 8218ED9Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8218ED9Ch case   10:*/		return 0x8218EDA0;
		  /* 8218EDA0h */ case   11:  		/* rlwinm. R10, R11, 0, 6, 6 */
		/* 8218EDA0h case   11:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R10,regs.R11);
		/* 8218EDA0h case   11:*/		return 0x8218EDA4;
		  /* 8218EDA4h */ case   12:  		/* bc 12, CR0_EQ, 84 */
		/* 8218EDA4h case   12:*/		if ( regs.CR[0].eq ) { return 0x8218EDF8;  }
		/* 8218EDA4h case   12:*/		return 0x8218EDA8;
		  /* 8218EDA8h */ case   13:  		/* lwz R10, <#[R31 + 36]> */
		/* 8218EDA8h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000024) );
		/* 8218EDA8h case   13:*/		return 0x8218EDAC;
		  /* 8218EDACh */ case   14:  		/* lwz R9, <#[R24 + 36]> */
		/* 8218EDACh case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000024) );
		/* 8218EDACh case   14:*/		return 0x8218EDB0;
		  /* 8218EDB0h */ case   15:  		/* cmplw CR6, R10, R9 */
		/* 8218EDB0h case   15:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8218EDB0h case   15:*/		return 0x8218EDB4;
		  /* 8218EDB4h */ case   16:  		/* bc 4, CR6_EQ, 68 */
		/* 8218EDB4h case   16:*/		if ( !regs.CR[6].eq ) { return 0x8218EDF8;  }
		/* 8218EDB4h case   16:*/		return 0x8218EDB8;
		  /* 8218EDB8h */ case   17:  		/* lwz R10, <#[R31]> */
		/* 8218EDB8h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8218EDB8h case   17:*/		return 0x8218EDBC;
		  /* 8218EDBCh */ case   18:  		/* rlwinm R5, R11, 16, 23, 31 */
		/* 8218EDBCh case   18:*/		cpu::op::rlwinm<0,16,23,31>(regs,&regs.R5,regs.R11);
		/* 8218EDBCh case   18:*/		return 0x8218EDC0;
		  /* 8218EDC0h */ case   19:  		/* addi R3, R1, 176 */
		/* 8218EDC0h case   19:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xB0);
		/* 8218EDC0h case   19:*/		return 0x8218EDC4;
		  /* 8218EDC4h */ case   20:  		/* rlwinm R4, R10, 12, 23, 31 */
		/* 8218EDC4h case   20:*/		cpu::op::rlwinm<0,12,23,31>(regs,&regs.R4,regs.R10);
		/* 8218EDC4h case   20:*/		return 0x8218EDC8;
		  /* 8218EDC8h */ case   21:  		/* bl -6296 */
		/* 8218EDC8h case   21:*/		regs.LR = 0x8218EDCC; return 0x8218D530;
		/* 8218EDC8h case   21:*/		return 0x8218EDCC;
		  /* 8218EDCCh */ case   22:  		/* lwz R11, <#[R31]> */
		/* 8218EDCCh case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8218EDCCh case   22:*/		return 0x8218EDD0;
		  /* 8218EDD0h */ case   23:  		/* rlwinm R11, R11, 12, 23, 31 */
		/* 8218EDD0h case   23:*/		cpu::op::rlwinm<0,12,23,31>(regs,&regs.R11,regs.R11);
		/* 8218EDD0h case   23:*/		return 0x8218EDD4;
		  /* 8218EDD4h */ case   24:  		/* cmplw CR6, R11, R26 */
		/* 8218EDD4h case   24:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 8218EDD4h case   24:*/		return 0x8218EDD8;
		  /* 8218EDD8h */ case   25:  		/* bc 4, CR6_LT, 8 */
		/* 8218EDD8h case   25:*/		if ( !regs.CR[6].lt ) { return 0x8218EDE0;  }
		/* 8218EDD8h case   25:*/		return 0x8218EDDC;
		  /* 8218EDDCh */ case   26:  		/* mr R26, R11 */
		/* 8218EDDCh case   26:*/		regs.R26 = regs.R11;
		/* 8218EDDCh case   26:*/		return 0x8218EDE0;
	}
	return 0x8218EDE0;
} // Block from 8218ED74h-8218EDE0h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8218EDE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EDE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EDE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EDE0);
		  /* 8218EDE0h */ case    0:  		/* lhz R10, <#[R31 + 4]> */
		/* 8218EDE0h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8218EDE0h case    0:*/		return 0x8218EDE4;
		  /* 8218EDE4h */ case    1:  		/* rlwinm R10, R10, 0, 23, 31 */
		/* 8218EDE4h case    1:*/		cpu::op::rlwinm<0,0,23,31>(regs,&regs.R10,regs.R10);
		/* 8218EDE4h case    1:*/		return 0x8218EDE8;
		  /* 8218EDE8h */ case    2:  		/* add R11, R10, R11 */
		/* 8218EDE8h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218EDE8h case    2:*/		return 0x8218EDEC;
		  /* 8218EDECh */ case    3:  		/* cmplw CR6, R11, R25 */
		/* 8218EDECh case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 8218EDECh case    3:*/		return 0x8218EDF0;
		  /* 8218EDF0h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 8218EDF0h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8218EDF8;  }
		/* 8218EDF0h case    4:*/		return 0x8218EDF4;
		  /* 8218EDF4h */ case    5:  		/* mr R25, R11 */
		/* 8218EDF4h case    5:*/		regs.R25 = regs.R11;
		/* 8218EDF4h case    5:*/		return 0x8218EDF8;
	}
	return 0x8218EDF8;
} // Block from 8218EDE0h-8218EDF8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218EDF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EDF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EDF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EDF8);
		  /* 8218EDF8h */ case    0:  		/* addic. R29, R29, -1 */
		/* 8218EDF8h case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 8218EDF8h case    0:*/		return 0x8218EDFC;
		  /* 8218EDFCh */ case    1:  		/* addi R30, R30, 40 */
		/* 8218EDFCh case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x28);
		/* 8218EDFCh case    1:*/		return 0x8218EE00;
		  /* 8218EE00h */ case    2:  		/* bc 4, CR0_EQ, -108 */
		/* 8218EE00h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8218ED94;  }
		/* 8218EE00h case    2:*/		return 0x8218EE04;
		  /* 8218EE04h */ case    3:  		/* mr R27, R17 */
		/* 8218EE04h case    3:*/		regs.R27 = regs.R17;
		/* 8218EE04h case    3:*/		return 0x8218EE08;
		  /* 8218EE08h */ case    4:  		/* mr R28, R17 */
		/* 8218EE08h case    4:*/		regs.R28 = regs.R17;
		/* 8218EE08h case    4:*/		return 0x8218EE0C;
		  /* 8218EE0Ch */ case    5:  		/* lwz R11, <#[R14 + 12]> */
		/* 8218EE0Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218EE0Ch case    5:*/		return 0x8218EE10;
		  /* 8218EE10h */ case    6:  		/* add R31, R28, R11 */
		/* 8218EE10h case    6:*/		cpu::op::add<0>(regs,&regs.R31,regs.R28,regs.R11);
		/* 8218EE10h case    6:*/		return 0x8218EE14;
		  /* 8218EE14h */ case    7:  		/* lwz R29, <#[R31 + 4]> */
		/* 8218EE14h case    7:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000004) );
		/* 8218EE14h case    7:*/		return 0x8218EE18;
		  /* 8218EE18h */ case    8:  		/* rlwinm. R11, R29, 0, 6, 6 */
		/* 8218EE18h case    8:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R11,regs.R29);
		/* 8218EE18h case    8:*/		return 0x8218EE1C;
		  /* 8218EE1Ch */ case    9:  		/* bc 4, CR0_EQ, 172 */
		/* 8218EE1Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x8218EEC8;  }
		/* 8218EE1Ch case    9:*/		return 0x8218EE20;
		  /* 8218EE20h */ case   10:  		/* lwz R11, <#[R31 + 36]> */
		/* 8218EE20h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 8218EE20h case   10:*/		return 0x8218EE24;
		  /* 8218EE24h */ case   11:  		/* lwz R10, <#[R24 + 36]> */
		/* 8218EE24h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000024) );
		/* 8218EE24h case   11:*/		return 0x8218EE28;
		  /* 8218EE28h */ case   12:  		/* cmplw CR6, R11, R10 */
		/* 8218EE28h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8218EE28h case   12:*/		return 0x8218EE2C;
		  /* 8218EE2Ch */ case   13:  		/* bc 4, CR6_EQ, 156 */
		/* 8218EE2Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x8218EEC8;  }
		/* 8218EE2Ch case   13:*/		return 0x8218EE30;
		  /* 8218EE30h */ case   14:  		/* mr R3, R21 */
		/* 8218EE30h case   14:*/		regs.R3 = regs.R21;
		/* 8218EE30h case   14:*/		return 0x8218EE34;
		  /* 8218EE34h */ case   15:  		/* cmpwi CR6, R26, -1 */
		/* 8218EE34h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R26,0xFFFFFFFF);
		/* 8218EE34h case   15:*/		return 0x8218EE38;
		  /* 8218EE38h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 8218EE38h case   16:*/		if ( regs.CR[6].eq ) { return 0x8218EE4C;  }
		/* 8218EE38h case   16:*/		return 0x8218EE3C;
		  /* 8218EE3Ch */ case   17:  		/* rlwinm R5, R29, 16, 23, 31 */
		/* 8218EE3Ch case   17:*/		cpu::op::rlwinm<0,16,23,31>(regs,&regs.R5,regs.R29);
		/* 8218EE3Ch case   17:*/		return 0x8218EE40;
		  /* 8218EE40h */ case   18:  		/* mr R4, R26 */
		/* 8218EE40h case   18:*/		regs.R4 = regs.R26;
		/* 8218EE40h case   18:*/		return 0x8218EE44;
		  /* 8218EE44h */ case   19:  		/* addi R3, R1, 176 */
		/* 8218EE44h case   19:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xB0);
		/* 8218EE44h case   19:*/		return 0x8218EE48;
		  /* 8218EE48h */ case   20:  		/* bl -11464 */
		/* 8218EE48h case   20:*/		regs.LR = 0x8218EE4C; return 0x8218C180;
		/* 8218EE48h case   20:*/		return 0x8218EE4C;
	}
	return 0x8218EE4C;
} // Block from 8218EDF8h-8218EE4Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8218EE4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EE4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EE4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EE4C);
		  /* 8218EE4Ch */ case    0:  		/* mr R30, R3 */
		/* 8218EE4Ch case    0:*/		regs.R30 = regs.R3;
		/* 8218EE4Ch case    0:*/		return 0x8218EE50;
		  /* 8218EE50h */ case    1:  		/* cmpwi CR6, R3, -1 */
		/* 8218EE50h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218EE50h case    1:*/		return 0x8218EE54;
		  /* 8218EE54h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 8218EE54h case    2:*/		if ( regs.CR[6].eq ) { return 0x8218EE68;  }
		/* 8218EE54h case    2:*/		return 0x8218EE58;
		  /* 8218EE58h */ case    3:  		/* cmpwi CR6, R26, -1 */
		/* 8218EE58h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R26,0xFFFFFFFF);
		/* 8218EE58h case    3:*/		return 0x8218EE5C;
		  /* 8218EE5Ch */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 8218EE5Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x8218EE84;  }
		/* 8218EE5Ch case    4:*/		return 0x8218EE60;
		  /* 8218EE60h */ case    5:  		/* cmplw CR6, R3, R25 */
		/* 8218EE60h case    5:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R25);
		/* 8218EE60h case    5:*/		return 0x8218EE64;
		  /* 8218EE64h */ case    6:  		/* bc 4, CR6_GT, 32 */
		/* 8218EE64h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8218EE84;  }
		/* 8218EE64h case    6:*/		return 0x8218EE68;
	}
	return 0x8218EE68;
} // Block from 8218EE4Ch-8218EE68h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218EE68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EE68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EE68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EE68);
		  /* 8218EE68h */ case    0:  		/* rlwinm R5, R29, 16, 23, 31 */
		/* 8218EE68h case    0:*/		cpu::op::rlwinm<0,16,23,31>(regs,&regs.R5,regs.R29);
		/* 8218EE68h case    0:*/		return 0x8218EE6C;
		  /* 8218EE6Ch */ case    1:  		/* li R4, 0 */
		/* 8218EE6Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8218EE6Ch case    1:*/		return 0x8218EE70;
		  /* 8218EE70h */ case    2:  		/* addi R3, R1, 176 */
		/* 8218EE70h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xB0);
		/* 8218EE70h case    2:*/		return 0x8218EE74;
		  /* 8218EE74h */ case    3:  		/* bl -11508 */
		/* 8218EE74h case    3:*/		regs.LR = 0x8218EE78; return 0x8218C180;
		/* 8218EE74h case    3:*/		return 0x8218EE78;
		  /* 8218EE78h */ case    4:  		/* cmpwi CR6, R3, -1 */
		/* 8218EE78h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218EE78h case    4:*/		return 0x8218EE7C;
		  /* 8218EE7Ch */ case    5:  		/* bc 12, CR6_EQ, 8 */
		/* 8218EE7Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x8218EE84;  }
		/* 8218EE7Ch case    5:*/		return 0x8218EE80;
		  /* 8218EE80h */ case    6:  		/* mr R30, R3 */
		/* 8218EE80h case    6:*/		regs.R30 = regs.R3;
		/* 8218EE80h case    6:*/		return 0x8218EE84;
	}
	return 0x8218EE84;
} // Block from 8218EE68h-8218EE84h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218EE84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EE84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EE84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EE84);
		  /* 8218EE84h */ case    0:  		/* cmpwi CR6, R30, -1 */
		/* 8218EE84h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0xFFFFFFFF);
		/* 8218EE84h case    0:*/		return 0x8218EE88;
		  /* 8218EE88h */ case    1:  		/* bc 12, CR6_EQ, 420 */
		/* 8218EE88h case    1:*/		if ( regs.CR[6].eq ) { return 0x8218F02C;  }
		/* 8218EE88h case    1:*/		return 0x8218EE8C;
		  /* 8218EE8Ch */ case    2:  		/* rlwinm R5, R29, 16, 23, 31 */
		/* 8218EE8Ch case    2:*/		cpu::op::rlwinm<0,16,23,31>(regs,&regs.R5,regs.R29);
		/* 8218EE8Ch case    2:*/		return 0x8218EE90;
		  /* 8218EE90h */ case    3:  		/* mr R4, R30 */
		/* 8218EE90h case    3:*/		regs.R4 = regs.R30;
		/* 8218EE90h case    3:*/		return 0x8218EE94;
		  /* 8218EE94h */ case    4:  		/* addi R3, R1, 320 */
		/* 8218EE94h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x140);
		/* 8218EE94h case    4:*/		return 0x8218EE98;
		  /* 8218EE98h */ case    5:  		/* bl -129472 */
		/* 8218EE98h case    5:*/		regs.LR = 0x8218EE9C; return 0x8216F4D8;
		/* 8218EE98h case    5:*/		return 0x8218EE9C;
		  /* 8218EE9Ch */ case    6:  		/* lhz R11, <#[R31 + 4]> */
		/* 8218EE9Ch case    6:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8218EE9Ch case    6:*/		return 0x8218EEA0;
		  /* 8218EEA0h */ case    7:  		/* mr R4, R30 */
		/* 8218EEA0h case    7:*/		regs.R4 = regs.R30;
		/* 8218EEA0h case    7:*/		return 0x8218EEA4;
		  /* 8218EEA4h */ case    8:  		/* addi R3, R1, 176 */
		/* 8218EEA4h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xB0);
		/* 8218EEA4h case    8:*/		return 0x8218EEA8;
		  /* 8218EEA8h */ case    9:  		/* rlwinm R5, R11, 0, 23, 31 */
		/* 8218EEA8h case    9:*/		cpu::op::rlwinm<0,0,23,31>(regs,&regs.R5,regs.R11);
		/* 8218EEA8h case    9:*/		return 0x8218EEAC;
		  /* 8218EEACh */ case   10:  		/* bl -129492 */
		/* 8218EEACh case   10:*/		regs.LR = 0x8218EEB0; return 0x8216F4D8;
		/* 8218EEACh case   10:*/		return 0x8218EEB0;
		  /* 8218EEB0h */ case   11:  		/* lwz R11, <#[R31]> */
		/* 8218EEB0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8218EEB0h case   11:*/		return 0x8218EEB4;
		  /* 8218EEB4h */ case   12:  		/* lwz R10, <#[R31 + 4]> */
		/* 8218EEB4h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8218EEB4h case   12:*/		return 0x8218EEB8;
		  /* 8218EEB8h */ case   13:  		/* rlwimi R11, R30, 20, 3, 11 */
		/* 8218EEB8h case   13:*/		cpu::op::rlwimi<0,20,3,11>(regs,&regs.R11,regs.R30);
		/* 8218EEB8h case   13:*/		return 0x8218EEBC;
		  /* 8218EEBCh */ case   14:  		/* oris R10, R10, 512 */
		/* 8218EEBCh case   14:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x200);
		/* 8218EEBCh case   14:*/		return 0x8218EEC0;
		  /* 8218EEC0h */ case   15:  		/* stw R11, <#[R31]> */
		/* 8218EEC0h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8218EEC0h case   15:*/		return 0x8218EEC4;
		  /* 8218EEC4h */ case   16:  		/* stw R10, <#[R31 + 4]> */
		/* 8218EEC4h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8218EEC4h case   16:*/		return 0x8218EEC8;
	}
	return 0x8218EEC8;
} // Block from 8218EE84h-8218EEC8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8218EEC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EEC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EEC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EEC8);
		  /* 8218EEC8h */ case    0:  		/* addi R27, R27, 1 */
		/* 8218EEC8h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8218EEC8h case    0:*/		return 0x8218EECC;
		  /* 8218EECCh */ case    1:  		/* addi R28, R28, 40 */
		/* 8218EECCh case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x28);
		/* 8218EECCh case    1:*/		return 0x8218EED0;
		  /* 8218EED0h */ case    2:  		/* cmplw CR6, R27, R20 */
		/* 8218EED0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R20);
		/* 8218EED0h case    2:*/		return 0x8218EED4;
		  /* 8218EED4h */ case    3:  		/* bc 12, CR6_LT, -200 */
		/* 8218EED4h case    3:*/		if ( regs.CR[6].lt ) { return 0x8218EE0C;  }
		/* 8218EED4h case    3:*/		return 0x8218EED8;
	}
	return 0x8218EED8;
} // Block from 8218EEC8h-8218EED8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218EED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EED8);
		  /* 8218EED8h */ case    0:  		/* addi R22, R22, 1 */
		/* 8218EED8h case    0:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 8218EED8h case    0:*/		return 0x8218EEDC;
		  /* 8218EEDCh */ case    1:  		/* addi R23, R23, 40 */
		/* 8218EEDCh case    1:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x28);
		/* 8218EEDCh case    1:*/		return 0x8218EEE0;
		  /* 8218EEE0h */ case    2:  		/* cmplw CR6, R22, R20 */
		/* 8218EEE0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R20);
		/* 8218EEE0h case    2:*/		return 0x8218EEE4;
		  /* 8218EEE4h */ case    3:  		/* bc 12, CR6_LT, -496 */
		/* 8218EEE4h case    3:*/		if ( regs.CR[6].lt ) { return 0x8218ECF4;  }
		/* 8218EEE4h case    3:*/		return 0x8218EEE8;
	}
	return 0x8218EEE8;
} // Block from 8218EED8h-8218EEE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218EEE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EEE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EEE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EEE8);
		  /* 8218EEE8h */ case    0:  		/* addi R4, R1, 320 */
		/* 8218EEE8h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x140);
		/* 8218EEE8h case    0:*/		return 0x8218EEEC;
		  /* 8218EEECh */ case    1:  		/* mr R3, R14 */
		/* 8218EEECh case    1:*/		regs.R3 = regs.R14;
		/* 8218EEECh case    1:*/		return 0x8218EEF0;
		  /* 8218EEF0h */ case    2:  		/* bl -5896 */
		/* 8218EEF0h case    2:*/		regs.LR = 0x8218EEF4; return 0x8218D7E8;
		/* 8218EEF0h case    2:*/		return 0x8218EEF4;
	}
	return 0x8218EEF4;
} // Block from 8218EEE8h-8218EEF4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218EEF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EEF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EEF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EEF4);
		  /* 8218EEF4h */ case    0:  		/* lwz R11, <#[R14 + 44]> */
		/* 8218EEF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000002C) );
		/* 8218EEF4h case    0:*/		return 0x8218EEF8;
		  /* 8218EEF8h */ case    1:  		/* stb R17, <#[R1 + 80]> */
		/* 8218EEF8h case    1:*/		cpu::mem::store8( regs, regs.R17, (uint32)(regs.R1 + 0x00000050) );
		/* 8218EEF8h case    1:*/		return 0x8218EEFC;
		  /* 8218EEFCh */ case    2:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 8218EEFCh case    2:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 8218EEFCh case    2:*/		return 0x8218EF00;
		  /* 8218EF00h */ case    3:  		/* bc 12, CR0_EQ, 1184 */
		/* 8218EF00h case    3:*/		if ( regs.CR[0].eq ) { return 0x8218F3A0;  }
		/* 8218EF00h case    3:*/		return 0x8218EF04;
		  /* 8218EF04h */ case    4:  		/* lwz R11, <#[R14 + 4]> */
		/* 8218EF04h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000004) );
		/* 8218EF04h case    4:*/		return 0x8218EF08;
		  /* 8218EF08h */ case    5:  		/* mr R23, R17 */
		/* 8218EF08h case    5:*/		regs.R23 = regs.R17;
		/* 8218EF08h case    5:*/		return 0x8218EF0C;
		  /* 8218EF0Ch */ case    6:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8218EF0Ch case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8218EF0Ch case    6:*/		return 0x8218EF10;
		  /* 8218EF10h */ case    7:  		/* bc 4, CR0_EQ, 1168 */
		/* 8218EF10h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8218F3A0;  }
		/* 8218EF10h case    7:*/		return 0x8218EF14;
		  /* 8218EF14h */ case    8:  		/* mr R15, R11 */
		/* 8218EF14h case    8:*/		regs.R15 = regs.R11;
		/* 8218EF14h case    8:*/		return 0x8218EF18;
		  /* 8218EF18h */ case    9:  		/* cmplwi CR0, R11, 0 */
		/* 8218EF18h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8218EF18h case    9:*/		return 0x8218EF1C;
		  /* 8218EF1Ch */ case   10:  		/* bc 12, CR0_EQ, 1156 */
		/* 8218EF1Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x8218F3A0;  }
		/* 8218EF1Ch case   10:*/		return 0x8218EF20;
		  /* 8218EF20h */ case   11:  		/* lwz R11, <#[R15 + 28]> */
		/* 8218EF20h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x0000001C) );
		/* 8218EF20h case   11:*/		return 0x8218EF24;
		  /* 8218EF24h */ case   12:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8218EF24h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8218EF24h case   12:*/		return 0x8218EF28;
		  /* 8218EF28h */ case   13:  		/* bc 4, CR0_EQ, 908 */
		/* 8218EF28h case   13:*/		if ( !regs.CR[0].eq ) { return 0x8218F2B4;  }
		/* 8218EF28h case   13:*/		return 0x8218EF2C;
		  /* 8218EF2Ch */ case   14:  		/* mr R16, R11 */
		/* 8218EF2Ch case   14:*/		regs.R16 = regs.R11;
		/* 8218EF2Ch case   14:*/		return 0x8218EF30;
		  /* 8218EF30h */ case   15:  		/* cmplwi CR0, R11, 0 */
		/* 8218EF30h case   15:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8218EF30h case   15:*/		return 0x8218EF34;
		  /* 8218EF34h */ case   16:  		/* bc 12, CR0_EQ, 896 */
		/* 8218EF34h case   16:*/		if ( regs.CR[0].eq ) { return 0x8218F2B4;  }
		/* 8218EF34h case   16:*/		return 0x8218EF38;
		  /* 8218EF38h */ case   17:  		/* lwz R11, <#[R16 + 8]> */
		/* 8218EF38h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 8218EF38h case   17:*/		return 0x8218EF3C;
		  /* 8218EF3Ch */ case   18:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8218EF3Ch case   18:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8218EF3Ch case   18:*/		return 0x8218EF40;
		  /* 8218EF40h */ case   19:  		/* cmplwi CR6, R11, 12800 */
		/* 8218EF40h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003200);
		/* 8218EF40h case   19:*/		return 0x8218EF44;
		  /* 8218EF44h */ case   20:  		/* bc 4, CR6_EQ, 844 */
		/* 8218EF44h case   20:*/		if ( !regs.CR[6].eq ) { return 0x8218F290;  }
		/* 8218EF44h case   20:*/		return 0x8218EF48;
		  /* 8218EF48h */ case   21:  		/* lwz R18, <#[R16 + 44]> */
		/* 8218EF48h case   21:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R16 + 0x0000002C) );
		/* 8218EF48h case   21:*/		return 0x8218EF4C;
		  /* 8218EF4Ch */ case   22:  		/* lwz R17, <#[R18 + 12]> */
		/* 8218EF4Ch case   22:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R18 + 0x0000000C) );
		/* 8218EF4Ch case   22:*/		return 0x8218EF50;
		  /* 8218EF50h */ case   23:  		/* lwz R11, <#[R17 + 8]> */
		/* 8218EF50h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000008) );
		/* 8218EF50h case   23:*/		return 0x8218EF54;
		  /* 8218EF54h */ case   24:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8218EF54h case   24:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8218EF54h case   24:*/		return 0x8218EF58;
		  /* 8218EF58h */ case   25:  		/* cmplwi CR6, R11, 124 */
		/* 8218EF58h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 8218EF58h case   25:*/		return 0x8218EF5C;
		  /* 8218EF5Ch */ case   26:  		/* bc 12, CR6_EQ, 820 */
		/* 8218EF5Ch case   26:*/		if ( regs.CR[6].eq ) { return 0x8218F290;  }
		/* 8218EF5Ch case   26:*/		return 0x8218EF60;
		  /* 8218EF60h */ case   27:  		/* cmplwi CR6, R11, 120 */
		/* 8218EF60h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000078);
		/* 8218EF60h case   27:*/		return 0x8218EF64;
		  /* 8218EF64h */ case   28:  		/* bc 4, CR6_EQ, 880 */
		/* 8218EF64h case   28:*/		if ( !regs.CR[6].eq ) { return 0x8218F2D4;  }
		/* 8218EF64h case   28:*/		return 0x8218EF68;
		  /* 8218EF68h */ case   29:  		/* cmplwi CR6, R23, 0 */
		/* 8218EF68h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 8218EF68h case   29:*/		return 0x8218EF6C;
		  /* 8218EF6Ch */ case   30:  		/* bc 4, CR6_EQ, 696 */
		/* 8218EF6Ch case   30:*/		if ( !regs.CR[6].eq ) { return 0x8218F224;  }
		/* 8218EF6Ch case   30:*/		return 0x8218EF70;
		  /* 8218EF70h */ case   31:  		/* lwz R11, <#[R14 + 4]> */
		/* 8218EF70h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000004) );
		/* 8218EF70h case   31:*/		return 0x8218EF74;
		  /* 8218EF74h */ case   32:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8218EF74h case   32:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8218EF74h case   32:*/		return 0x8218EF78;
		  /* 8218EF78h */ case   33:  		/* addic R10, R10, -1 */
		/* 8218EF78h case   33:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8218EF78h case   33:*/		return 0x8218EF7C;
		  /* 8218EF7Ch */ case   34:  		/* subfe R10, R10, R10 */
		/* 8218EF7Ch case   34:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8218EF7Ch case   34:*/		return 0x8218EF80;
		  /* 8218EF80h */ case   35:  		/* and R11, R10, R11 */
		/* 8218EF80h case   35:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218EF80h case   35:*/		return 0x8218EF84;
		  /* 8218EF84h */ case   36:  		/* lwz R11, <#[R11 + 20]> */
		/* 8218EF84h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8218EF84h case   36:*/		return 0x8218EF88;
		  /* 8218EF88h */ case   37:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8218EF88h case   37:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8218EF88h case   37:*/		return 0x8218EF8C;
		  /* 8218EF8Ch */ case   38:  		/* bc 4, CR0_EQ, 172 */
		/* 8218EF8Ch case   38:*/		if ( !regs.CR[0].eq ) { return 0x8218F038;  }
		/* 8218EF8Ch case   38:*/		return 0x8218EF90;
		  /* 8218EF90h */ case   39:  		/* mr R23, R11 */
		/* 8218EF90h case   39:*/		regs.R23 = regs.R11;
		/* 8218EF90h case   39:*/		return 0x8218EF94;
		  /* 8218EF94h */ case   40:  		/* cmplwi CR0, R11, 0 */
		/* 8218EF94h case   40:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8218EF94h case   40:*/		return 0x8218EF98;
		  /* 8218EF98h */ case   41:  		/* bc 12, CR0_EQ, 164 */
		/* 8218EF98h case   41:*/		if ( regs.CR[0].eq ) { return 0x8218F03C;  }
		/* 8218EF98h case   41:*/		return 0x8218EF9C;
		  /* 8218EF9Ch */ case   42:  		/* lwz R11, <#[R23 + 8]> */
		/* 8218EF9Ch case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 8218EF9Ch case   42:*/		return 0x8218EFA0;
		  /* 8218EFA0h */ case   43:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8218EFA0h case   43:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8218EFA0h case   43:*/		return 0x8218EFA4;
		  /* 8218EFA4h */ case   44:  		/* cmplwi CR6, R11, 15872 */
		/* 8218EFA4h case   44:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E00);
		/* 8218EFA4h case   44:*/		return 0x8218EFA8;
		  /* 8218EFA8h */ case   45:  		/* bc 4, CR6_EQ, 64 */
		/* 8218EFA8h case   45:*/		if ( !regs.CR[6].eq ) { return 0x8218EFE8;  }
		/* 8218EFA8h case   45:*/		return 0x8218EFAC;
		  /* 8218EFACh */ case   46:  		/* lwz R11, <#[R23 + 8]> */
		/* 8218EFACh case   46:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 8218EFACh case   46:*/		return 0x8218EFB0;
		  /* 8218EFB0h */ case   47:  		/* mr R3, R14 */
		/* 8218EFB0h case   47:*/		regs.R3 = regs.R14;
		/* 8218EFB0h case   47:*/		return 0x8218EFB4;
		  /* 8218EFB4h */ case   48:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8218EFB4h case   48:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8218EFB4h case   48:*/		return 0x8218EFB8;
		  /* 8218EFB8h */ case   49:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8218EFB8h case   49:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8218EFB8h case   49:*/		return 0x8218EFBC;
		  /* 8218EFBCh */ case   50:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8218EFBCh case   50:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8218EFBCh case   50:*/		return 0x8218EFC0;
		  /* 8218EFC0h */ case   51:  		/* bl -174992 */
		/* 8218EFC0h case   51:*/		regs.LR = 0x8218EFC4; return 0x82164430;
		/* 8218EFC0h case   51:*/		return 0x8218EFC4;
		  /* 8218EFC4h */ case   52:  		/* addi R11, R23, -8 */
		/* 8218EFC4h case   52:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R23,0xFFFFFFF8);
		/* 8218EFC4h case   52:*/		return 0x8218EFC8;
		  /* 8218EFC8h */ case   53:  		/* add R11, R3, R11 */
		/* 8218EFC8h case   53:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 8218EFC8h case   53:*/		return 0x8218EFCC;
		  /* 8218EFCCh */ case   54:  		/* lwz R10, <#[R11]> */
		/* 8218EFCCh case   54:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218EFCCh case   54:*/		return 0x8218EFD0;
		  /* 8218EFD0h */ case   55:  		/* rlwinm. R10, R10, 0, 0, 0 */
		/* 8218EFD0h case   55:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R10,regs.R10);
		/* 8218EFD0h case   55:*/		return 0x8218EFD4;
		  /* 8218EFD4h */ case   56:  		/* bc 12, CR0_EQ, 20 */
		/* 8218EFD4h case   56:*/		if ( regs.CR[0].eq ) { return 0x8218EFE8;  }
		/* 8218EFD4h case   56:*/		return 0x8218EFD8;
		  /* 8218EFD8h */ case   57:  		/* lwz R11, <#[R11 + 4]> */
		/* 8218EFD8h case   57:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8218EFD8h case   57:*/		return 0x8218EFDC;
		  /* 8218EFDCh */ case   58:  		/* rlwinm R11, R11, 0, 26, 27 */
		/* 8218EFDCh case   58:*/		cpu::op::rlwinm<0,0,26,27>(regs,&regs.R11,regs.R11);
		/* 8218EFDCh case   58:*/		return 0x8218EFE0;
		  /* 8218EFE0h */ case   59:  		/* cmplwi CR6, R11, 48 */
		/* 8218EFE0h case   59:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 8218EFE0h case   59:*/		return 0x8218EFE4;
		  /* 8218EFE4h */ case   60:  		/* bc 4, CR6_EQ, 576 */
		/* 8218EFE4h case   60:*/		if ( !regs.CR[6].eq ) { return 0x8218F224;  }
		/* 8218EFE4h case   60:*/		return 0x8218EFE8;
	}
	return 0x8218EFE8;
} // Block from 8218EEF4h-8218EFE8h (61 instructions)

//////////////////////////////////////////////////////
// Block at 8218EFE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218EFE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218EFE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218EFE8);
		  /* 8218EFE8h */ case    0:  		/* rlwinm R11, R23, 0, 0, 30 */
		/* 8218EFE8h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R23);
		/* 8218EFE8h case    0:*/		return 0x8218EFEC;
		  /* 8218EFECh */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8218EFECh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8218EFECh case    1:*/		return 0x8218EFF0;
		  /* 8218EFF0h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8218EFF0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8218EFF0h case    2:*/		return 0x8218EFF4;
		  /* 8218EFF4h */ case    3:  		/* bc 4, CR0_EQ, 68 */
		/* 8218EFF4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8218F038;  }
		/* 8218EFF4h case    3:*/		return 0x8218EFF8;
		  /* 8218EFF8h */ case    4:  		/* mr R23, R11 */
		/* 8218EFF8h case    4:*/		regs.R23 = regs.R11;
		/* 8218EFF8h case    4:*/		return 0x8218EFFC;
		  /* 8218EFFCh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8218EFFCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218EFFCh case    5:*/		return 0x8218F000;
		  /* 8218F000h */ case    6:  		/* bc 4, CR6_EQ, -100 */
		/* 8218F000h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8218EF9C;  }
		/* 8218F000h case    6:*/		return 0x8218F004;
		  /* 8218F004h */ case    7:  		/* b 56 */
		/* 8218F004h case    7:*/		return 0x8218F03C;
		/* 8218F004h case    7:*/		return 0x8218F008;
	}
	return 0x8218F008;
} // Block from 8218EFE8h-8218F008h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218F008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F008);
		  /* 8218F008h */ case    0:  		/* li R4, 4801 */
		/* 8218F008h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 8218F008h case    0:*/		return 0x8218F00C;
		  /* 8218F00Ch */ case    1:  		/* mr R3, R14 */
		/* 8218F00Ch case    1:*/		regs.R3 = regs.R14;
		/* 8218F00Ch case    1:*/		return 0x8218F010;
		  /* 8218F010h */ case    2:  		/* bl -250280 */
		/* 8218F010h case    2:*/		regs.LR = 0x8218F014; return 0x82151E68;
		/* 8218F010h case    2:*/		return 0x8218F014;
	}
	return 0x8218F014;
} // Block from 8218F008h-8218F014h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218F014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F014);
		  /* 8218F014h */ case    0:  		/* mr R4, R30 */
		/* 8218F014h case    0:*/		regs.R4 = regs.R30;
		/* 8218F014h case    0:*/		return 0x8218F018;
		  /* 8218F018h */ case    1:  		/* mr R3, R14 */
		/* 8218F018h case    1:*/		regs.R3 = regs.R14;
		/* 8218F018h case    1:*/		return 0x8218F01C;
		  /* 8218F01Ch */ case    2:  		/* bl -7124 */
		/* 8218F01Ch case    2:*/		regs.LR = 0x8218F020; return 0x8218D448;
		/* 8218F01Ch case    2:*/		return 0x8218F020;
	}
	return 0x8218F020;
} // Block from 8218F014h-8218F020h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218F020h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F020);
		  /* 8218F020h */ case    0:  		/* li R4, 3613 */
		/* 8218F020h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xE1D);
		/* 8218F020h case    0:*/		return 0x8218F024;
		  /* 8218F024h */ case    1:  		/* mr R3, R14 */
		/* 8218F024h case    1:*/		regs.R3 = regs.R14;
		/* 8218F024h case    1:*/		return 0x8218F028;
		  /* 8218F028h */ case    2:  		/* bl -250304 */
		/* 8218F028h case    2:*/		regs.LR = 0x8218F02C; return 0x82151E68;
		/* 8218F028h case    2:*/		return 0x8218F02C;
	}
	return 0x8218F02C;
} // Block from 8218F020h-8218F02Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218F02Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F02C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F02C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F02C);
		  /* 8218F02Ch */ case    0:  		/* li R4, 3566 */
		/* 8218F02Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xDEE);
		/* 8218F02Ch case    0:*/		return 0x8218F030;
		  /* 8218F030h */ case    1:  		/* mr R3, R14 */
		/* 8218F030h case    1:*/		regs.R3 = regs.R14;
		/* 8218F030h case    1:*/		return 0x8218F034;
		  /* 8218F034h */ case    2:  		/* bl -250316 */
		/* 8218F034h case    2:*/		regs.LR = 0x8218F038; return 0x82151E68;
		/* 8218F034h case    2:*/		return 0x8218F038;
	}
	return 0x8218F038;
} // Block from 8218F02Ch-8218F038h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218F038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F038);
		  /* 8218F038h */ case    0:  		/* li R23, 0 */
		/* 8218F038h case    0:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 8218F038h case    0:*/		return 0x8218F03C;
	}
	return 0x8218F03C;
} // Block from 8218F038h-8218F03Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218F03Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F03C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F03C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F03C);
		  /* 8218F03Ch */ case    0:  		/* lwz R31, <#[R1 + 84]> */
		/* 8218F03Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 8218F03Ch case    0:*/		return 0x8218F040;
		  /* 8218F040h */ case    1:  		/* li R5, -1 */
		/* 8218F040h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0xFFFFFFFF);
		/* 8218F040h case    1:*/		return 0x8218F044;
		  /* 8218F044h */ case    2:  		/* li R20, 0 */
		/* 8218F044h case    2:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 8218F044h case    2:*/		return 0x8218F048;
		  /* 8218F048h */ case    3:  		/* mr R24, R5 */
		/* 8218F048h case    3:*/		regs.R24 = regs.R5;
		/* 8218F048h case    3:*/		return 0x8218F04C;
		  /* 8218F04Ch */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8218F04Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8218F04Ch case    4:*/		return 0x8218F050;
		  /* 8218F050h */ case    5:  		/* bc 12, CR6_EQ, 460 */
		/* 8218F050h case    5:*/		if ( regs.CR[6].eq ) { return 0x8218F21C;  }
		/* 8218F050h case    5:*/		return 0x8218F054;
		  /* 8218F054h */ case    6:  		/* lwz R19, <#[R14 + 12]> */
		/* 8218F054h case    6:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218F054h case    6:*/		return 0x8218F058;
		  /* 8218F058h */ case    7:  		/* mr R22, R19 */
		/* 8218F058h case    7:*/		regs.R22 = regs.R19;
		/* 8218F058h case    7:*/		return 0x8218F05C;
		  /* 8218F05Ch */ case    8:  		/* lwz R11, <#[R22 + 4]> */
		/* 8218F05Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 8218F05Ch case    8:*/		return 0x8218F060;
		  /* 8218F060h */ case    9:  		/* rlwinm R10, R11, 0, 25, 27 */
		/* 8218F060h case    9:*/		cpu::op::rlwinm<0,0,25,27>(regs,&regs.R10,regs.R11);
		/* 8218F060h case    9:*/		return 0x8218F064;
		  /* 8218F064h */ case   10:  		/* cmplwi CR6, R10, 48 */
		/* 8218F064h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000030);
		/* 8218F064h case   10:*/		return 0x8218F068;
		  /* 8218F068h */ case   11:  		/* bc 4, CR6_EQ, 316 */
		/* 8218F068h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8218F1A4;  }
		/* 8218F068h case   11:*/		return 0x8218F06C;
		  /* 8218F06Ch */ case   12:  		/* lwz R27, <#[R22]> */
		/* 8218F06Ch case   12:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R22 + 0x00000000) );
		/* 8218F06Ch case   12:*/		return 0x8218F070;
		  /* 8218F070h */ case   13:  		/* rlwinm. R10, R27, 0, 2, 2 */
		/* 8218F070h case   13:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R10,regs.R27);
		/* 8218F070h case   13:*/		return 0x8218F074;
		  /* 8218F074h */ case   14:  		/* bc 4, CR0_EQ, 304 */
		/* 8218F074h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8218F1A4;  }
		/* 8218F074h case   14:*/		return 0x8218F078;
		  /* 8218F078h */ case   15:  		/* rlwinm. R21, R11, 16, 23, 31 */
		/* 8218F078h case   15:*/		cpu::op::rlwinm<1,16,23,31>(regs,&regs.R21,regs.R11);
		/* 8218F078h case   15:*/		return 0x8218F07C;
		  /* 8218F07Ch */ case   16:  		/* bc 12, CR0_EQ, 296 */
		/* 8218F07Ch case   16:*/		if ( regs.CR[0].eq ) { return 0x8218F1A4;  }
		/* 8218F07Ch case   16:*/		return 0x8218F080;
		  /* 8218F080h */ case   17:  		/* rlwinm. R25, R27, 29, 18, 31 */
		/* 8218F080h case   17:*/		cpu::op::rlwinm<1,29,18,31>(regs,&regs.R25,regs.R27);
		/* 8218F080h case   17:*/		return 0x8218F084;
		  /* 8218F084h */ case   18:  		/* li R28, 0 */
		/* 8218F084h case   18:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8218F084h case   18:*/		return 0x8218F088;
		  /* 8218F088h */ case   19:  		/* bc 12, CR0_EQ, 260 */
		/* 8218F088h case   19:*/		if ( regs.CR[0].eq ) { return 0x8218F18C;  }
		/* 8218F088h case   19:*/		return 0x8218F08C;
		  /* 8218F08Ch */ case   20:  		/* lwz R26, <#[R22 + 28]> */
		/* 8218F08Ch case   20:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R22 + 0x0000001C) );
		/* 8218F08Ch case   20:*/		return 0x8218F090;
		  /* 8218F090h */ case   21:  		/* lwz R11, <#[R26]> */
		/* 8218F090h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8218F090h case   21:*/		return 0x8218F094;
		  /* 8218F094h */ case   22:  		/* rlwinm R10, R11, 12, 26, 31 */
		/* 8218F094h case   22:*/		cpu::op::rlwinm<0,12,26,31>(regs,&regs.R10,regs.R11);
		/* 8218F094h case   22:*/		return 0x8218F098;
		  /* 8218F098h */ case   23:  		/* cmpwi CR6, R10, 33 */
		/* 8218F098h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000021);
		/* 8218F098h case   23:*/		return 0x8218F09C;
		  /* 8218F09Ch */ case   24:  		/* bc 12, CR6_EQ, 224 */
		/* 8218F09Ch case   24:*/		if ( regs.CR[6].eq ) { return 0x8218F17C;  }
		/* 8218F09Ch case   24:*/		return 0x8218F0A0;
		  /* 8218F0A0h */ case   25:  		/* cmpwi CR6, R10, 37 */
		/* 8218F0A0h case   25:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000025);
		/* 8218F0A0h case   25:*/		return 0x8218F0A4;
		  /* 8218F0A4h */ case   26:  		/* bc 12, CR6_EQ, 216 */
		/* 8218F0A4h case   26:*/		if ( regs.CR[6].eq ) { return 0x8218F17C;  }
		/* 8218F0A4h case   26:*/		return 0x8218F0A8;
		  /* 8218F0A8h */ case   27:  		/* rlwinm. R10, R27, 0, 12, 12 */
		/* 8218F0A8h case   27:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R10,regs.R27);
		/* 8218F0A8h case   27:*/		return 0x8218F0AC;
		  /* 8218F0ACh */ case   28:  		/* bc 12, CR0_EQ, 224 */
		/* 8218F0ACh case   28:*/		if ( regs.CR[0].eq ) { return 0x8218F18C;  }
		/* 8218F0ACh case   28:*/		return 0x8218F0B0;
		  /* 8218F0B0h */ case   29:  		/* rlwinm R10, R11, 28, 18, 31 */
		/* 8218F0B0h case   29:*/		cpu::op::rlwinm<0,28,18,31>(regs,&regs.R10,regs.R11);
		/* 8218F0B0h case   29:*/		return 0x8218F0B4;
		  /* 8218F0B4h */ case   30:  		/* cmplw CR6, R10, R21 */
		/* 8218F0B4h case   30:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R21);
		/* 8218F0B4h case   30:*/		return 0x8218F0B8;
		  /* 8218F0B8h */ case   31:  		/* bc 4, CR6_LT, 196 */
		/* 8218F0B8h case   31:*/		if ( !regs.CR[6].lt ) { return 0x8218F17C;  }
		/* 8218F0B8h case   31:*/		return 0x8218F0BC;
		  /* 8218F0BCh */ case   32:  		/* rlwinm R11, R27, 12, 23, 31 */
		/* 8218F0BCh case   32:*/		cpu::op::rlwinm<0,12,23,31>(regs,&regs.R11,regs.R27);
		/* 8218F0BCh case   32:*/		return 0x8218F0C0;
		  /* 8218F0C0h */ case   33:  		/* li R31, 0 */
		/* 8218F0C0h case   33:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8218F0C0h case   33:*/		return 0x8218F0C4;
		  /* 8218F0C4h */ case   34:  		/* add R29, R11, R10 */
		/* 8218F0C4h case   34:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R10);
		/* 8218F0C4h case   34:*/		return 0x8218F0C8;
		  /* 8218F0C8h */ case   35:  		/* mr R8, R19 */
		/* 8218F0C8h case   35:*/		regs.R8 = regs.R19;
		/* 8218F0C8h case   35:*/		return 0x8218F0CC;
		  /* 8218F0CCh */ case   36:  		/* lwz R30, <#[R8 + 4]> */
		/* 8218F0CCh case   36:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R8 + 0x00000004) );
		/* 8218F0CCh case   36:*/		return 0x8218F0D0;
		  /* 8218F0D0h */ case   37:  		/* rlwinm R11, R30, 0, 25, 27 */
		/* 8218F0D0h case   37:*/		cpu::op::rlwinm<0,0,25,27>(regs,&regs.R11,regs.R30);
		/* 8218F0D0h case   37:*/		return 0x8218F0D4;
		  /* 8218F0D4h */ case   38:  		/* cmplwi CR6, R11, 48 */
		/* 8218F0D4h case   38:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 8218F0D4h case   38:*/		return 0x8218F0D8;
		  /* 8218F0D8h */ case   39:  		/* bc 4, CR6_EQ, 132 */
		/* 8218F0D8h case   39:*/		if ( !regs.CR[6].eq ) { return 0x8218F15C;  }
		/* 8218F0D8h case   39:*/		return 0x8218F0DC;
		  /* 8218F0DCh */ case   40:  		/* lwz R4, <#[R8]> */
		/* 8218F0DCh case   40:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R8 + 0x00000000) );
		/* 8218F0DCh case   40:*/		return 0x8218F0E0;
		  /* 8218F0E0h */ case   41:  		/* rlwinm. R11, R4, 0, 12, 12 */
		/* 8218F0E0h case   41:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R11,regs.R4);
		/* 8218F0E0h case   41:*/		return 0x8218F0E4;
		  /* 8218F0E4h */ case   42:  		/* bc 12, CR0_EQ, 120 */
		/* 8218F0E4h case   42:*/		if ( regs.CR[0].eq ) { return 0x8218F15C;  }
		/* 8218F0E4h case   42:*/		return 0x8218F0E8;
		  /* 8218F0E8h */ case   43:  		/* rlwinm. R11, R4, 0, 2, 2 */
		/* 8218F0E8h case   43:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R11,regs.R4);
		/* 8218F0E8h case   43:*/		return 0x8218F0EC;
		  /* 8218F0ECh */ case   44:  		/* bc 12, CR0_EQ, 112 */
		/* 8218F0ECh case   44:*/		if ( regs.CR[0].eq ) { return 0x8218F15C;  }
		/* 8218F0ECh case   44:*/		return 0x8218F0F0;
		  /* 8218F0F0h */ case   45:  		/* cmplw CR6, R8, R22 */
		/* 8218F0F0h case   45:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R22);
		/* 8218F0F0h case   45:*/		return 0x8218F0F4;
		  /* 8218F0F4h */ case   46:  		/* bc 12, CR6_EQ, 104 */
		/* 8218F0F4h case   46:*/		if ( regs.CR[6].eq ) { return 0x8218F15C;  }
		/* 8218F0F4h case   46:*/		return 0x8218F0F8;
		  /* 8218F0F8h */ case   47:  		/* rlwinm. R6, R4, 29, 18, 31 */
		/* 8218F0F8h case   47:*/		cpu::op::rlwinm<1,29,18,31>(regs,&regs.R6,regs.R4);
		/* 8218F0F8h case   47:*/		return 0x8218F0FC;
		  /* 8218F0FCh */ case   48:  		/* li R7, 0 */
		/* 8218F0FCh case   48:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8218F0FCh case   48:*/		return 0x8218F100;
		  /* 8218F100h */ case   49:  		/* bc 12, CR0_EQ, 84 */
		/* 8218F100h case   49:*/		if ( regs.CR[0].eq ) { return 0x8218F154;  }
		/* 8218F100h case   49:*/		return 0x8218F104;
		  /* 8218F104h */ case   50:  		/* lwz R3, <#[R8 + 28]> */
		/* 8218F104h case   50:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R8 + 0x0000001C) );
		/* 8218F104h case   50:*/		return 0x8218F108;
		  /* 8218F108h */ case   51:  		/* li R9, 0 */
		/* 8218F108h case   51:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8218F108h case   51:*/		return 0x8218F10C;
		  /* 8218F10Ch */ case   52:  		/* lwzx R11, <#[R3 + R9]> */
		/* 8218F10Ch case   52:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R9 + 0x00000000) );
		/* 8218F10Ch case   52:*/		return 0x8218F110;
		  /* 8218F110h */ case   53:  		/* lis R10, 592 */
		/* 8218F110h case   53:*/		cpu::op::lis<0>(regs,&regs.R10,0x250);
		/* 8218F110h case   53:*/		return 0x8218F114;
		  /* 8218F114h */ case   54:  		/* rlwinm R14, R11, 0, 6, 11 */
		/* 8218F114h case   54:*/		cpu::op::rlwinm<0,0,6,11>(regs,&regs.R14,regs.R11);
		/* 8218F114h case   54:*/		return 0x8218F118;
		  /* 8218F118h */ case   55:  		/* cmplw CR6, R14, R10 */
		/* 8218F118h case   55:*/		cpu::op::cmplw<6>(regs,regs.R14,regs.R10);
		/* 8218F118h case   55:*/		return 0x8218F11C;
		  /* 8218F11Ch */ case   56:  		/* bc 4, CR6_EQ, 36 */
		/* 8218F11Ch case   56:*/		if ( !regs.CR[6].eq ) { return 0x8218F140;  }
		/* 8218F11Ch case   56:*/		return 0x8218F120;
		  /* 8218F120h */ case   57:  		/* rlwinm R11, R11, 28, 18, 31 */
		/* 8218F120h case   57:*/		cpu::op::rlwinm<0,28,18,31>(regs,&regs.R11,regs.R11);
		/* 8218F120h case   57:*/		return 0x8218F124;
		  /* 8218F124h */ case   58:  		/* rlwinm R10, R30, 16, 23, 31 */
		/* 8218F124h case   58:*/		cpu::op::rlwinm<0,16,23,31>(regs,&regs.R10,regs.R30);
		/* 8218F124h case   58:*/		return 0x8218F128;
		  /* 8218F128h */ case   59:  		/* cmplw CR6, R11, R10 */
		/* 8218F128h case   59:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8218F128h case   59:*/		return 0x8218F12C;
		  /* 8218F12Ch */ case   60:  		/* bc 4, CR6_LT, 20 */
		/* 8218F12Ch case   60:*/		if ( !regs.CR[6].lt ) { return 0x8218F140;  }
		/* 8218F12Ch case   60:*/		return 0x8218F130;
		  /* 8218F130h */ case   61:  		/* rlwinm R10, R4, 12, 23, 31 */
		/* 8218F130h case   61:*/		cpu::op::rlwinm<0,12,23,31>(regs,&regs.R10,regs.R4);
		/* 8218F130h case   61:*/		return 0x8218F134;
		  /* 8218F134h */ case   62:  		/* add R11, R10, R11 */
		/* 8218F134h case   62:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218F134h case   62:*/		return 0x8218F138;
		  /* 8218F138h */ case   63:  		/* cmplw CR6, R29, R11 */
		/* 8218F138h case   63:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8218F138h case   63:*/		return 0x8218F13C;
		  /* 8218F13Ch */ case   64:  		/* bc 12, CR6_EQ, 20 */
		/* 8218F13Ch case   64:*/		if ( regs.CR[6].eq ) { return 0x8218F150;  }
		/* 8218F13Ch case   64:*/		return 0x8218F140;
	}
	return 0x8218F140;
} // Block from 8218F03Ch-8218F140h (65 instructions)

//////////////////////////////////////////////////////
// Block at 8218F140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F140);
		  /* 8218F140h */ case    0:  		/* addi R7, R7, 1 */
		/* 8218F140h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8218F140h case    0:*/		return 0x8218F144;
		  /* 8218F144h */ case    1:  		/* addi R9, R9, 8 */
		/* 8218F144h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x8);
		/* 8218F144h case    1:*/		return 0x8218F148;
		  /* 8218F148h */ case    2:  		/* cmplw CR6, R7, R6 */
		/* 8218F148h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 8218F148h case    2:*/		return 0x8218F14C;
		  /* 8218F14Ch */ case    3:  		/* bc 12, CR6_LT, -64 */
		/* 8218F14Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8218F10C;  }
		/* 8218F14Ch case    3:*/		return 0x8218F150;
	}
	return 0x8218F150;
} // Block from 8218F140h-8218F150h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218F150h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F150);
		  /* 8218F150h */ case    0:  		/* lwz R14, <#[R1 + 628]> */
		/* 8218F150h case    0:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R1 + 0x00000274) );
		/* 8218F150h case    0:*/		return 0x8218F154;
	}
	return 0x8218F154;
} // Block from 8218F150h-8218F154h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218F154h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F154( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F154) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F154);
		  /* 8218F154h */ case    0:  		/* cmplw CR6, R7, R6 */
		/* 8218F154h case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 8218F154h case    0:*/		return 0x8218F158;
		  /* 8218F158h */ case    1:  		/* bc 12, CR6_LT, 24 */
		/* 8218F158h case    1:*/		if ( regs.CR[6].lt ) { return 0x8218F170;  }
		/* 8218F158h case    1:*/		return 0x8218F15C;
	}
	return 0x8218F15C;
} // Block from 8218F154h-8218F15Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218F15Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F15C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F15C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F15C);
		  /* 8218F15Ch */ case    0:  		/* lwz R11, <#[R1 + 84]> */
		/* 8218F15Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8218F15Ch case    0:*/		return 0x8218F160;
		  /* 8218F160h */ case    1:  		/* addi R31, R31, 1 */
		/* 8218F160h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8218F160h case    1:*/		return 0x8218F164;
		  /* 8218F164h */ case    2:  		/* addi R8, R8, 40 */
		/* 8218F164h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x28);
		/* 8218F164h case    2:*/		return 0x8218F168;
		  /* 8218F168h */ case    3:  		/* cmplw CR6, R31, R11 */
		/* 8218F168h case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8218F168h case    3:*/		return 0x8218F16C;
		  /* 8218F16Ch */ case    4:  		/* bc 12, CR6_LT, -160 */
		/* 8218F16Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x8218F0CC;  }
		/* 8218F16Ch case    4:*/		return 0x8218F170;
	}
	return 0x8218F170;
} // Block from 8218F15Ch-8218F170h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218F170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F170);
		  /* 8218F170h */ case    0:  		/* lwz R11, <#[R1 + 84]> */
		/* 8218F170h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8218F170h case    0:*/		return 0x8218F174;
		  /* 8218F174h */ case    1:  		/* cmplw CR6, R31, R11 */
		/* 8218F174h case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8218F174h case    1:*/		return 0x8218F178;
		  /* 8218F178h */ case    2:  		/* bc 4, CR6_LT, 20 */
		/* 8218F178h case    2:*/		if ( !regs.CR[6].lt ) { return 0x8218F18C;  }
		/* 8218F178h case    2:*/		return 0x8218F17C;
	}
	return 0x8218F17C;
} // Block from 8218F170h-8218F17Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218F17Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F17C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F17C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F17C);
		  /* 8218F17Ch */ case    0:  		/* addi R28, R28, 1 */
		/* 8218F17Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8218F17Ch case    0:*/		return 0x8218F180;
		  /* 8218F180h */ case    1:  		/* addi R26, R26, 8 */
		/* 8218F180h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x8);
		/* 8218F180h case    1:*/		return 0x8218F184;
		  /* 8218F184h */ case    2:  		/* cmplw CR6, R28, R25 */
		/* 8218F184h case    2:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R25);
		/* 8218F184h case    2:*/		return 0x8218F188;
		  /* 8218F188h */ case    3:  		/* bc 12, CR6_LT, -248 */
		/* 8218F188h case    3:*/		if ( regs.CR[6].lt ) { return 0x8218F090;  }
		/* 8218F188h case    3:*/		return 0x8218F18C;
	}
	return 0x8218F18C;
} // Block from 8218F17Ch-8218F18Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218F18Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F18C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F18C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F18C);
		  /* 8218F18Ch */ case    0:  		/* cmplw CR6, R28, R25 */
		/* 8218F18Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R25);
		/* 8218F18Ch case    0:*/		return 0x8218F190;
		  /* 8218F190h */ case    1:  		/* bc 4, CR6_LT, 20 */
		/* 8218F190h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8218F1A4;  }
		/* 8218F190h case    1:*/		return 0x8218F194;
		  /* 8218F194h */ case    2:  		/* cmplw CR6, R28, R5 */
		/* 8218F194h case    2:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R5);
		/* 8218F194h case    2:*/		return 0x8218F198;
		  /* 8218F198h */ case    3:  		/* bc 4, CR6_LT, 12 */
		/* 8218F198h case    3:*/		if ( !regs.CR[6].lt ) { return 0x8218F1A4;  }
		/* 8218F198h case    3:*/		return 0x8218F19C;
		  /* 8218F19Ch */ case    4:  		/* mr R5, R28 */
		/* 8218F19Ch case    4:*/		regs.R5 = regs.R28;
		/* 8218F19Ch case    4:*/		return 0x8218F1A0;
		  /* 8218F1A0h */ case    5:  		/* mr R24, R20 */
		/* 8218F1A0h case    5:*/		regs.R24 = regs.R20;
		/* 8218F1A0h case    5:*/		return 0x8218F1A4;
	}
	return 0x8218F1A4;
} // Block from 8218F18Ch-8218F1A4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218F1A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F1A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F1A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F1A4);
		  /* 8218F1A4h */ case    0:  		/* lwz R31, <#[R1 + 84]> */
		/* 8218F1A4h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 8218F1A4h case    0:*/		return 0x8218F1A8;
		  /* 8218F1A8h */ case    1:  		/* addi R20, R20, 1 */
		/* 8218F1A8h case    1:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0x1);
		/* 8218F1A8h case    1:*/		return 0x8218F1AC;
		  /* 8218F1ACh */ case    2:  		/* addi R22, R22, 40 */
		/* 8218F1ACh case    2:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x28);
		/* 8218F1ACh case    2:*/		return 0x8218F1B0;
		  /* 8218F1B0h */ case    3:  		/* cmplw CR6, R20, R31 */
		/* 8218F1B0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R20,regs.R31);
		/* 8218F1B0h case    3:*/		return 0x8218F1B4;
		  /* 8218F1B4h */ case    4:  		/* bc 12, CR6_LT, -344 */
		/* 8218F1B4h case    4:*/		if ( regs.CR[6].lt ) { return 0x8218F05C;  }
		/* 8218F1B4h case    4:*/		return 0x8218F1B8;
		  /* 8218F1B8h */ case    5:  		/* cmpwi CR6, R24, -1 */
		/* 8218F1B8h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R24,0xFFFFFFFF);
		/* 8218F1B8h case    5:*/		return 0x8218F1BC;
		  /* 8218F1BCh */ case    6:  		/* bc 12, CR6_EQ, 96 */
		/* 8218F1BCh case    6:*/		if ( regs.CR[6].eq ) { return 0x8218F21C;  }
		/* 8218F1BCh case    6:*/		return 0x8218F1C0;
		  /* 8218F1C0h */ case    7:  		/* li R6, 1 */
		/* 8218F1C0h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8218F1C0h case    7:*/		return 0x8218F1C4;
		  /* 8218F1C4h */ case    8:  		/* mr R4, R24 */
		/* 8218F1C4h case    8:*/		regs.R4 = regs.R24;
		/* 8218F1C4h case    8:*/		return 0x8218F1C8;
		  /* 8218F1C8h */ case    9:  		/* mr R3, R14 */
		/* 8218F1C8h case    9:*/		regs.R3 = regs.R14;
		/* 8218F1C8h case    9:*/		return 0x8218F1CC;
		  /* 8218F1CCh */ case   10:  		/* bl 621396 */
		/* 8218F1CCh case   10:*/		regs.LR = 0x8218F1D0; return 0x82226D20;
		/* 8218F1CCh case   10:*/		return 0x8218F1D0;
		  /* 8218F1D0h */ case   11:  		/* lwz R10, <#[R3 + 8]> */
		/* 8218F1D0h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 8218F1D0h case   11:*/		return 0x8218F1D4;
		  /* 8218F1D4h */ case   12:  		/* mulli R11, R24, 40 */
		/* 8218F1D4h case   12:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R24,0x28);
		/* 8218F1D4h case   12:*/		return 0x8218F1D8;
		  /* 8218F1D8h */ case   13:  		/* rlwinm R10, R10, 0, 30, 26 */
		/* 8218F1D8h case   13:*/		cpu::op::rlwinm<0,0,30,26>(regs,&regs.R10,regs.R10);
		/* 8218F1D8h case   13:*/		return 0x8218F1DC;
		  /* 8218F1DCh */ case   14:  		/* li R9, 1 */
		/* 8218F1DCh case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8218F1DCh case   14:*/		return 0x8218F1E0;
		  /* 8218F1E0h */ case   15:  		/* rlwinm R10, R10, 0, 17, 14 */
		/* 8218F1E0h case   15:*/		cpu::op::rlwinm<0,0,17,14>(regs,&regs.R10,regs.R10);
		/* 8218F1E0h case   15:*/		return 0x8218F1E4;
		  /* 8218F1E4h */ case   16:  		/* mr R23, R3 */
		/* 8218F1E4h case   16:*/		regs.R23 = regs.R3;
		/* 8218F1E4h case   16:*/		return 0x8218F1E8;
		  /* 8218F1E8h */ case   17:  		/* oris R10, R10, 256 */
		/* 8218F1E8h case   17:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x100);
		/* 8218F1E8h case   17:*/		return 0x8218F1EC;
		  /* 8218F1ECh */ case   18:  		/* ori R10, R10, 16386 */
		/* 8218F1ECh case   18:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x4002);
		/* 8218F1ECh case   18:*/		return 0x8218F1F0;
		  /* 8218F1F0h */ case   19:  		/* stw R10, <#[R3 + 8]> */
		/* 8218F1F0h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 8218F1F0h case   19:*/		return 0x8218F1F4;
		  /* 8218F1F4h */ case   20:  		/* lwz R10, <#[R14 + 12]> */
		/* 8218F1F4h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218F1F4h case   20:*/		return 0x8218F1F8;
		  /* 8218F1F8h */ case   21:  		/* lwzx R8, <#[R11 + R10]> */
		/* 8218F1F8h case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8218F1F8h case   21:*/		return 0x8218F1FC;
		  /* 8218F1FCh */ case   22:  		/* oris R8, R8, 8192 */
		/* 8218F1FCh case   22:*/		cpu::op::oris<0>(regs,&regs.R8,regs.R8,0x2000);
		/* 8218F1FCh case   22:*/		return 0x8218F200;
		  /* 8218F200h */ case   23:  		/* stwx R8, <#[R11 + R10]> */
		/* 8218F200h case   23:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8218F200h case   23:*/		return 0x8218F204;
		  /* 8218F204h */ case   24:  		/* lwz R10, <#[R14 + 12]> */
		/* 8218F204h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218F204h case   24:*/		return 0x8218F208;
		  /* 8218F208h */ case   25:  		/* add R11, R11, R10 */
		/* 8218F208h case   25:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8218F208h case   25:*/		return 0x8218F20C;
		  /* 8218F20Ch */ case   26:  		/* lwz R8, <#[R11 + 4]> */
		/* 8218F20Ch case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8218F20Ch case   26:*/		return 0x8218F210;
		  /* 8218F210h */ case   27:  		/* rlwimi R8, R9, 7, 16, 24 */
		/* 8218F210h case   27:*/		cpu::op::rlwimi<0,7,16,24>(regs,&regs.R8,regs.R9);
		/* 8218F210h case   27:*/		return 0x8218F214;
		  /* 8218F214h */ case   28:  		/* addi R10, R11, 4 */
		/* 8218F214h case   28:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8218F214h case   28:*/		return 0x8218F218;
		  /* 8218F218h */ case   29:  		/* stw R8, <#[R11 + 4]> */
		/* 8218F218h case   29:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8218F218h case   29:*/		return 0x8218F21C;
	}
	return 0x8218F21C;
} // Block from 8218F1A4h-8218F21Ch (30 instructions)

//////////////////////////////////////////////////////
// Block at 8218F21Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F21C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F21C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F21C);
		  /* 8218F21Ch */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 8218F21Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 8218F21Ch case    0:*/		return 0x8218F220;
		  /* 8218F220h */ case    1:  		/* bc 12, CR6_EQ, 192 */
		/* 8218F220h case    1:*/		if ( regs.CR[6].eq ) { return 0x8218F2E0;  }
		/* 8218F220h case    1:*/		return 0x8218F224;
	}
	return 0x8218F224;
} // Block from 8218F21Ch-8218F224h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218F224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F224);
		  /* 8218F224h */ case    0:  		/* lwz R11, <#[R18 + 12]> */
		/* 8218F224h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x0000000C) );
		/* 8218F224h case    0:*/		return 0x8218F228;
		  /* 8218F228h */ case    1:  		/* addi R11, R11, 4 */
		/* 8218F228h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8218F228h case    1:*/		return 0x8218F22C;
		  /* 8218F22Ch */ case    2:  		/* lwz R10, <#[R11]> */
		/* 8218F22Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218F22Ch case    2:*/		return 0x8218F230;
		  /* 8218F230h */ case    3:  		/* b 12 */
		/* 8218F230h case    3:*/		return 0x8218F23C;
		/* 8218F230h case    3:*/		return 0x8218F234;
		  /* 8218F234h */ case    4:  		/* addi R11, R10, 8 */
		/* 8218F234h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 8218F234h case    4:*/		return 0x8218F238;
		  /* 8218F238h */ case    5:  		/* lwz R10, <#[R10 + 8]> */
		/* 8218F238h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8218F238h case    5:*/		return 0x8218F23C;
	}
	return 0x8218F23C;
} // Block from 8218F224h-8218F23Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218F23Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F23C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F23C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F23C);
		  /* 8218F23Ch */ case    0:  		/* cmplw CR6, R10, R18 */
		/* 8218F23Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R18);
		/* 8218F23Ch case    0:*/		return 0x8218F240;
		  /* 8218F240h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 8218F240h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8218F234;  }
		/* 8218F240h case    1:*/		return 0x8218F244;
		  /* 8218F244h */ case    2:  		/* lwz R10, <#[R18 + 8]> */
		/* 8218F244h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R18 + 0x00000008) );
		/* 8218F244h case    2:*/		return 0x8218F248;
		  /* 8218F248h */ case    3:  		/* mr R3, R17 */
		/* 8218F248h case    3:*/		regs.R3 = regs.R17;
		/* 8218F248h case    3:*/		return 0x8218F24C;
		  /* 8218F24Ch */ case    4:  		/* stw R10, <#[R11]> */
		/* 8218F24Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218F24Ch case    4:*/		return 0x8218F250;
		  /* 8218F250h */ case    5:  		/* lwz R11, <#[R23 + 4]> */
		/* 8218F250h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 8218F250h case    5:*/		return 0x8218F254;
		  /* 8218F254h */ case    6:  		/* stw R11, <#[R18 + 8]> */
		/* 8218F254h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R18 + 0x00000008) );
		/* 8218F254h case    6:*/		return 0x8218F258;
		  /* 8218F258h */ case    7:  		/* stw R18, <#[R23 + 4]> */
		/* 8218F258h case    7:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R23 + 0x00000004) );
		/* 8218F258h case    7:*/		return 0x8218F25C;
		  /* 8218F25Ch */ case    8:  		/* lwz R11, <#[R18]> */
		/* 8218F25Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 8218F25Ch case    8:*/		return 0x8218F260;
		  /* 8218F260h */ case    9:  		/* rlwinm R11, R11, 0, 19, 6 */
		/* 8218F260h case    9:*/		cpu::op::rlwinm<0,0,19,6>(regs,&regs.R11,regs.R11);
		/* 8218F260h case    9:*/		return 0x8218F264;
		  /* 8218F264h */ case   10:  		/* rlwinm R11, R11, 0, 2, 0 */
		/* 8218F264h case   10:*/		cpu::op::rlwinm<0,0,2,0>(regs,&regs.R11,regs.R11);
		/* 8218F264h case   10:*/		return 0x8218F268;
		  /* 8218F268h */ case   11:  		/* stw R23, <#[R18 + 12]> */
		/* 8218F268h case   11:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R18 + 0x0000000C) );
		/* 8218F268h case   11:*/		return 0x8218F26C;
		  /* 8218F26Ch */ case   12:  		/* stw R11, <#[R18]> */
		/* 8218F26Ch case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 8218F26Ch case   12:*/		return 0x8218F270;
		  /* 8218F270h */ case   13:  		/* bl -174320 */
		/* 8218F270h case   13:*/		regs.LR = 0x8218F274; return 0x82164980;
		/* 8218F270h case   13:*/		return 0x8218F274;
		  /* 8218F274h */ case   14:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8218F274h case   14:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8218F274h case   14:*/		return 0x8218F278;
		  /* 8218F278h */ case   15:  		/* bc 12, CR0_EQ, 24 */
		/* 8218F278h case   15:*/		if ( regs.CR[0].eq ) { return 0x8218F290;  }
		/* 8218F278h case   15:*/		return 0x8218F27C;
		  /* 8218F27Ch */ case   16:  		/* li R6, 1 */
		/* 8218F27Ch case   16:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8218F27Ch case   16:*/		return 0x8218F280;
		  /* 8218F280h */ case   17:  		/* li R5, 0 */
		/* 8218F280h case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8218F280h case   17:*/		return 0x8218F284;
		  /* 8218F284h */ case   18:  		/* mr R4, R17 */
		/* 8218F284h case   18:*/		regs.R4 = regs.R17;
		/* 8218F284h case   18:*/		return 0x8218F288;
		  /* 8218F288h */ case   19:  		/* mr R3, R14 */
		/* 8218F288h case   19:*/		regs.R3 = regs.R14;
		/* 8218F288h case   19:*/		return 0x8218F28C;
		  /* 8218F28Ch */ case   20:  		/* bl 639292 */
		/* 8218F28Ch case   20:*/		regs.LR = 0x8218F290; return 0x8222B3C8;
		/* 8218F28Ch case   20:*/		return 0x8218F290;
	}
	return 0x8218F290;
} // Block from 8218F23Ch-8218F290h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8218F290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F290);
		  /* 8218F290h */ case    0:  		/* rlwinm R11, R16, 0, 0, 30 */
		/* 8218F290h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R16);
		/* 8218F290h case    0:*/		return 0x8218F294;
		  /* 8218F294h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8218F294h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8218F294h case    1:*/		return 0x8218F298;
		  /* 8218F298h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8218F298h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8218F298h case    2:*/		return 0x8218F29C;
		  /* 8218F29Ch */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 8218F29Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8218F2AC;  }
		/* 8218F29Ch case    3:*/		return 0x8218F2A0;
		  /* 8218F2A0h */ case    4:  		/* mr R16, R11 */
		/* 8218F2A0h case    4:*/		regs.R16 = regs.R11;
		/* 8218F2A0h case    4:*/		return 0x8218F2A4;
		  /* 8218F2A4h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8218F2A4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218F2A4h case    5:*/		return 0x8218F2A8;
		  /* 8218F2A8h */ case    6:  		/* bc 4, CR6_EQ, -880 */
		/* 8218F2A8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8218EF38;  }
		/* 8218F2A8h case    6:*/		return 0x8218F2AC;
	}
	return 0x8218F2AC;
} // Block from 8218F290h-8218F2ACh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218F2ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F2AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F2AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F2AC);
		  /* 8218F2ACh */ case    0:  		/* lwz R20, <#[R1 + 84]> */
		/* 8218F2ACh case    0:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x00000054) );
		/* 8218F2ACh case    0:*/		return 0x8218F2B0;
		  /* 8218F2B0h */ case    1:  		/* li R17, 0 */
		/* 8218F2B0h case    1:*/		cpu::op::li<0>(regs,&regs.R17,0x0);
		/* 8218F2B0h case    1:*/		return 0x8218F2B4;
	}
	return 0x8218F2B4;
} // Block from 8218F2ACh-8218F2B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218F2B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F2B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F2B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F2B4);
		  /* 8218F2B4h */ case    0:  		/* rlwinm R11, R15, 0, 0, 30 */
		/* 8218F2B4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R15);
		/* 8218F2B4h case    0:*/		return 0x8218F2B8;
		  /* 8218F2B8h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8218F2B8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8218F2B8h case    1:*/		return 0x8218F2BC;
		  /* 8218F2BCh */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8218F2BCh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8218F2BCh case    2:*/		return 0x8218F2C0;
		  /* 8218F2C0h */ case    3:  		/* bc 4, CR0_EQ, 224 */
		/* 8218F2C0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8218F3A0;  }
		/* 8218F2C0h case    3:*/		return 0x8218F2C4;
		  /* 8218F2C4h */ case    4:  		/* mr R15, R11 */
		/* 8218F2C4h case    4:*/		regs.R15 = regs.R11;
		/* 8218F2C4h case    4:*/		return 0x8218F2C8;
		  /* 8218F2C8h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8218F2C8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218F2C8h case    5:*/		return 0x8218F2CC;
		  /* 8218F2CCh */ case    6:  		/* bc 4, CR6_EQ, -940 */
		/* 8218F2CCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x8218EF20;  }
		/* 8218F2CCh case    6:*/		return 0x8218F2D0;
		  /* 8218F2D0h */ case    7:  		/* b 208 */
		/* 8218F2D0h case    7:*/		return 0x8218F3A0;
		/* 8218F2D0h case    7:*/		return 0x8218F2D4;
	}
	return 0x8218F2D4;
} // Block from 8218F2B4h-8218F2D4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218F2D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F2D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F2D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F2D4);
		  /* 8218F2D4h */ case    0:  		/* li R4, 4800 */
		/* 8218F2D4h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8218F2D4h case    0:*/		return 0x8218F2D8;
		  /* 8218F2D8h */ case    1:  		/* mr R3, R14 */
		/* 8218F2D8h case    1:*/		regs.R3 = regs.R14;
		/* 8218F2D8h case    1:*/		return 0x8218F2DC;
		  /* 8218F2DCh */ case    2:  		/* bl -250996 */
		/* 8218F2DCh case    2:*/		regs.LR = 0x8218F2E0; return 0x82151E68;
		/* 8218F2DCh case    2:*/		return 0x8218F2E0;
	}
	return 0x8218F2E0;
} // Block from 8218F2D4h-8218F2E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218F2E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F2E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F2E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F2E0);
		  /* 8218F2E0h */ case    0:  		/* lwz R11, <#[R1 + 92]> */
		/* 8218F2E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8218F2E0h case    0:*/		return 0x8218F2E4;
		  /* 8218F2E4h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8218F2E4h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8218F2E4h case    1:*/		return 0x8218F2E8;
		  /* 8218F2E8h */ case    2:  		/* bc 12, CR0_EQ, 156 */
		/* 8218F2E8h case    2:*/		if ( regs.CR[0].eq ) { return 0x8218F384;  }
		/* 8218F2E8h case    2:*/		return 0x8218F2EC;
		  /* 8218F2ECh */ case    3:  		/* li R6, 0 */
		/* 8218F2ECh case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8218F2ECh case    3:*/		return 0x8218F2F0;
		  /* 8218F2F0h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8218F2F0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8218F2F0h case    4:*/		return 0x8218F2F4;
		  /* 8218F2F4h */ case    5:  		/* bc 12, CR6_EQ, 152 */
		/* 8218F2F4h case    5:*/		if ( regs.CR[6].eq ) { return 0x8218F38C;  }
		/* 8218F2F4h case    5:*/		return 0x8218F2F8;
		  /* 8218F2F8h */ case    6:  		/* lwz R7, <#[R14 + 12]> */
		/* 8218F2F8h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218F2F8h case    6:*/		return 0x8218F2FC;
		  /* 8218F2FCh */ case    7:  		/* li R9, 0 */
		/* 8218F2FCh case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8218F2FCh case    7:*/		return 0x8218F300;
		  /* 8218F300h */ case    8:  		/* lwzx R10, <#[R7 + R9]> */
		/* 8218F300h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 8218F300h case    8:*/		return 0x8218F304;
		  /* 8218F304h */ case    9:  		/* add R11, R7, R9 */
		/* 8218F304h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R7,regs.R9);
		/* 8218F304h case    9:*/		return 0x8218F308;
		  /* 8218F308h */ case   10:  		/* rlwinm. R8, R10, 0, 12, 12 */
		/* 8218F308h case   10:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R8,regs.R10);
		/* 8218F308h case   10:*/		return 0x8218F30C;
		  /* 8218F30Ch */ case   11:  		/* bc 12, CR0_EQ, 76 */
		/* 8218F30Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x8218F358;  }
		/* 8218F30Ch case   11:*/		return 0x8218F310;
		  /* 8218F310h */ case   12:  		/* lwz R8, <#[R11 + 28]> */
		/* 8218F310h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000001C) );
		/* 8218F310h case   12:*/		return 0x8218F314;
		  /* 8218F314h */ case   13:  		/* lwz R5, <#[R8]> */
		/* 8218F314h case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R8 + 0x00000000) );
		/* 8218F314h case   13:*/		return 0x8218F318;
		  /* 8218F318h */ case   14:  		/* rlwinm. R5, R5, 0, 14, 27 */
		/* 8218F318h case   14:*/		cpu::op::rlwinm<1,0,14,27>(regs,&regs.R5,regs.R5);
		/* 8218F318h case   14:*/		return 0x8218F31C;
		  /* 8218F31Ch */ case   15:  		/* bc 4, CR0_EQ, 60 */
		/* 8218F31Ch case   15:*/		if ( !regs.CR[0].eq ) { return 0x8218F358;  }
		/* 8218F31Ch case   15:*/		return 0x8218F320;
		  /* 8218F320h */ case   16:  		/* rlwinm. R10, R10, 12, 23, 31 */
		/* 8218F320h case   16:*/		cpu::op::rlwinm<1,12,23,31>(regs,&regs.R10,regs.R10);
		/* 8218F320h case   16:*/		return 0x8218F324;
		  /* 8218F324h */ case   17:  		/* bc 4, CR0_EQ, 52 */
		/* 8218F324h case   17:*/		if ( !regs.CR[0].eq ) { return 0x8218F358;  }
		/* 8218F324h case   17:*/		return 0x8218F328;
		  /* 8218F328h */ case   18:  		/* lhz R11, <#[R11 + 4]> */
		/* 8218F328h case   18:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8218F328h case   18:*/		return 0x8218F32C;
		  /* 8218F32Ch */ case   19:  		/* rlwinm R11, R11, 0, 23, 31 */
		/* 8218F32Ch case   19:*/		cpu::op::rlwinm<0,0,23,31>(regs,&regs.R11,regs.R11);
		/* 8218F32Ch case   19:*/		return 0x8218F330;
		  /* 8218F330h */ case   20:  		/* add. R11, R11, R10 */
		/* 8218F330h case   20:*/		cpu::op::add<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8218F330h case   20:*/		return 0x8218F334;
		  /* 8218F334h */ case   21:  		/* bc 12, CR0_EQ, 36 */
		/* 8218F334h case   21:*/		if ( regs.CR[0].eq ) { return 0x8218F358;  }
		/* 8218F334h case   21:*/		return 0x8218F338;
		  /* 8218F338h */ case   22:  		/* rlwinm R11, R10, 3, 0, 28 */
		/* 8218F338h case   22:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R10);
		/* 8218F338h case   22:*/		return 0x8218F33C;
		  /* 8218F33Ch */ case   23:  		/* subf R11, R11, R8 */
		/* 8218F33Ch case   23:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8218F33Ch case   23:*/		return 0x8218F340;
		  /* 8218F340h */ case   24:  		/* lwz R11, <#[R11]> */
		/* 8218F340h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8218F340h case   24:*/		return 0x8218F344;
		  /* 8218F344h */ case   25:  		/* rlwinm R11, R11, 12, 26, 31 */
		/* 8218F344h case   25:*/		cpu::op::rlwinm<0,12,26,31>(regs,&regs.R11,regs.R11);
		/* 8218F344h case   25:*/		return 0x8218F348;
		  /* 8218F348h */ case   26:  		/* cmpwi CR6, R11, 37 */
		/* 8218F348h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000025);
		/* 8218F348h case   26:*/		return 0x8218F34C;
		  /* 8218F34Ch */ case   27:  		/* bc 12, CR6_EQ, 32 */
		/* 8218F34Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x8218F36C;  }
		/* 8218F34Ch case   27:*/		return 0x8218F350;
		  /* 8218F350h */ case   28:  		/* cmpwi CR6, R11, 33 */
		/* 8218F350h case   28:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000021);
		/* 8218F350h case   28:*/		return 0x8218F354;
		  /* 8218F354h */ case   29:  		/* bc 12, CR6_EQ, 36 */
		/* 8218F354h case   29:*/		if ( regs.CR[6].eq ) { return 0x8218F378;  }
		/* 8218F354h case   29:*/		return 0x8218F358;
	}
	return 0x8218F358;
} // Block from 8218F2E0h-8218F358h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8218F358h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F358);
		  /* 8218F358h */ case    0:  		/* addi R6, R6, 1 */
		/* 8218F358h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8218F358h case    0:*/		return 0x8218F35C;
		  /* 8218F35Ch */ case    1:  		/* addi R9, R9, 40 */
		/* 8218F35Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x28);
		/* 8218F35Ch case    1:*/		return 0x8218F360;
		  /* 8218F360h */ case    2:  		/* cmplw CR6, R6, R31 */
		/* 8218F360h case    2:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R31);
		/* 8218F360h case    2:*/		return 0x8218F364;
		  /* 8218F364h */ case    3:  		/* bc 12, CR6_LT, -100 */
		/* 8218F364h case    3:*/		if ( regs.CR[6].lt ) { return 0x8218F300;  }
		/* 8218F364h case    3:*/		return 0x8218F368;
		  /* 8218F368h */ case    4:  		/* b 36 */
		/* 8218F368h case    4:*/		return 0x8218F38C;
		/* 8218F368h case    4:*/		return 0x8218F36C;
	}
	return 0x8218F36C;
} // Block from 8218F358h-8218F36Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218F36Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F36C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F36C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F36C);
		  /* 8218F36Ch */ case    0:  		/* li R4, 3601 */
		/* 8218F36Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xE11);
		/* 8218F36Ch case    0:*/		return 0x8218F370;
		  /* 8218F370h */ case    1:  		/* mr R3, R14 */
		/* 8218F370h case    1:*/		regs.R3 = regs.R14;
		/* 8218F370h case    1:*/		return 0x8218F374;
		  /* 8218F374h */ case    2:  		/* bl -251148 */
		/* 8218F374h case    2:*/		regs.LR = 0x8218F378; return 0x82151E68;
		/* 8218F374h case    2:*/		return 0x8218F378;
	}
	return 0x8218F378;
} // Block from 8218F36Ch-8218F378h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218F378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F378);
		  /* 8218F378h */ case    0:  		/* li R4, 3602 */
		/* 8218F378h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xE12);
		/* 8218F378h case    0:*/		return 0x8218F37C;
		  /* 8218F37Ch */ case    1:  		/* mr R3, R14 */
		/* 8218F37Ch case    1:*/		regs.R3 = regs.R14;
		/* 8218F37Ch case    1:*/		return 0x8218F380;
		  /* 8218F380h */ case    2:  		/* bl -251160 */
		/* 8218F380h case    2:*/		regs.LR = 0x8218F384; return 0x82151E68;
		/* 8218F380h case    2:*/		return 0x8218F384;
	}
	return 0x8218F384;
} // Block from 8218F378h-8218F384h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218F384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F384);
		  /* 8218F384h */ case    0:  		/* li R11, 1 */
		/* 8218F384h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218F384h case    0:*/		return 0x8218F388;
		  /* 8218F388h */ case    1:  		/* stb R11, <#[R1 + 80]> */
		/* 8218F388h case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8218F388h case    1:*/		return 0x8218F38C;
	}
	return 0x8218F38C;
} // Block from 8218F384h-8218F38Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218F38Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F38C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F38C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F38C);
		  /* 8218F38Ch */ case    0:  		/* li R4, 3600 */
		/* 8218F38Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xE10);
		/* 8218F38Ch case    0:*/		return 0x8218F390;
		  /* 8218F390h */ case    1:  		/* mr R3, R14 */
		/* 8218F390h case    1:*/		regs.R3 = regs.R14;
		/* 8218F390h case    1:*/		return 0x8218F394;
		  /* 8218F394h */ case    2:  		/* bl -251420 */
		/* 8218F394h case    2:*/		regs.LR = 0x8218F398; return 0x82151D78;
		/* 8218F394h case    2:*/		return 0x8218F398;
		  /* 8218F398h */ case    3:  		/* lwz R20, <#[R1 + 84]> */
		/* 8218F398h case    3:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x00000054) );
		/* 8218F398h case    3:*/		return 0x8218F39C;
		  /* 8218F39Ch */ case    4:  		/* li R17, 0 */
		/* 8218F39Ch case    4:*/		cpu::op::li<0>(regs,&regs.R17,0x0);
		/* 8218F39Ch case    4:*/		return 0x8218F3A0;
	}
	return 0x8218F3A0;
} // Block from 8218F38Ch-8218F3A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218F3A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F3A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F3A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F3A0);
		  /* 8218F3A0h */ case    0:  		/* mr R27, R17 */
		/* 8218F3A0h case    0:*/		regs.R27 = regs.R17;
		/* 8218F3A0h case    0:*/		return 0x8218F3A4;
		  /* 8218F3A4h */ case    1:  		/* cmplwi CR6, R20, 0 */
		/* 8218F3A4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 8218F3A4h case    1:*/		return 0x8218F3A8;
		  /* 8218F3A8h */ case    2:  		/* bc 12, CR6_EQ, 420 */
		/* 8218F3A8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8218F54C;  }
		/* 8218F3A8h case    2:*/		return 0x8218F3AC;
		  /* 8218F3ACh */ case    3:  		/* mr R26, R17 */
		/* 8218F3ACh case    3:*/		regs.R26 = regs.R17;
		/* 8218F3ACh case    3:*/		return 0x8218F3B0;
		  /* 8218F3B0h */ case    4:  		/* lwz R11, <#[R14 + 12]> */
		/* 8218F3B0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218F3B0h case    4:*/		return 0x8218F3B4;
		  /* 8218F3B4h */ case    5:  		/* add R31, R11, R26 */
		/* 8218F3B4h case    5:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R26);
		/* 8218F3B4h case    5:*/		return 0x8218F3B8;
		  /* 8218F3B8h */ case    6:  		/* lwz R11, <#[R31 + 4]> */
		/* 8218F3B8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8218F3B8h case    6:*/		return 0x8218F3BC;
		  /* 8218F3BCh */ case    7:  		/* rlwinm. R10, R11, 0, 6, 6 */
		/* 8218F3BCh case    7:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R10,regs.R11);
		/* 8218F3BCh case    7:*/		return 0x8218F3C0;
		  /* 8218F3C0h */ case    8:  		/* bc 4, CR0_EQ, 380 */
		/* 8218F3C0h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8218F53C;  }
		/* 8218F3C0h case    8:*/		return 0x8218F3C4;
		  /* 8218F3C4h */ case    9:  		/* lwz R10, <#[R31]> */
		/* 8218F3C4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8218F3C4h case    9:*/		return 0x8218F3C8;
		  /* 8218F3C8h */ case   10:  		/* rlwinm. R10, R10, 0, 2, 2 */
		/* 8218F3C8h case   10:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R10,regs.R10);
		/* 8218F3C8h case   10:*/		return 0x8218F3CC;
		  /* 8218F3CCh */ case   11:  		/* bc 12, CR0_EQ, 368 */
		/* 8218F3CCh case   11:*/		if ( regs.CR[0].eq ) { return 0x8218F53C;  }
		/* 8218F3CCh case   11:*/		return 0x8218F3D0;
		  /* 8218F3D0h */ case   12:  		/* rlwinm R10, R11, 28, 29, 31 */
		/* 8218F3D0h case   12:*/		cpu::op::rlwinm<0,28,29,31>(regs,&regs.R10,regs.R11);
		/* 8218F3D0h case   12:*/		return 0x8218F3D4;
		  /* 8218F3D4h */ case   13:  		/* rlwinm R28, R11, 25, 23, 31 */
		/* 8218F3D4h case   13:*/		cpu::op::rlwinm<0,25,23,31>(regs,&regs.R28,regs.R11);
		/* 8218F3D4h case   13:*/		return 0x8218F3D8;
		  /* 8218F3D8h */ case   14:  		/* cmplwi CR6, R10, 1 */
		/* 8218F3D8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 8218F3D8h case   14:*/		return 0x8218F3DC;
		  /* 8218F3DCh */ case   15:  		/* bc 12, CR6_LT, 316 */
		/* 8218F3DCh case   15:*/		if ( regs.CR[6].lt ) { return 0x8218F518;  }
		/* 8218F3DCh case   15:*/		return 0x8218F3E0;
		  /* 8218F3E0h */ case   16:  		/* bc 12, CR6_EQ, 296 */
		/* 8218F3E0h case   16:*/		if ( regs.CR[6].eq ) { return 0x8218F508;  }
		/* 8218F3E0h case   16:*/		return 0x8218F3E4;
		  /* 8218F3E4h */ case   17:  		/* cmplwi CR6, R10, 3 */
		/* 8218F3E4h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 8218F3E4h case   17:*/		return 0x8218F3E8;
		  /* 8218F3E8h */ case   18:  		/* bc 12, CR6_LT, 268 */
		/* 8218F3E8h case   18:*/		if ( regs.CR[6].lt ) { return 0x8218F4F4;  }
		/* 8218F3E8h case   18:*/		return 0x8218F3EC;
		  /* 8218F3ECh */ case   19:  		/* bc 4, CR6_EQ, 488 */
		/* 8218F3ECh case   19:*/		if ( !regs.CR[6].eq ) { return 0x8218F5D4;  }
		/* 8218F3ECh case   19:*/		return 0x8218F3F0;
		  /* 8218F3F0h */ case   20:  		/* lbz R11, <#[R1 + 80]> */
		/* 8218F3F0h case   20:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8218F3F0h case   20:*/		return 0x8218F3F4;
		  /* 8218F3F4h */ case   21:  		/* mr R29, R17 */
		/* 8218F3F4h case   21:*/		regs.R29 = regs.R17;
		/* 8218F3F4h case   21:*/		return 0x8218F3F8;
		  /* 8218F3F8h */ case   22:  		/* cmplwi CR0, R11, 0 */
		/* 8218F3F8h case   22:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8218F3F8h case   22:*/		return 0x8218F3FC;
		  /* 8218F3FCh */ case   23:  		/* bc 12, CR0_EQ, 188 */
		/* 8218F3FCh case   23:*/		if ( regs.CR[0].eq ) { return 0x8218F4B8;  }
		/* 8218F3FCh case   23:*/		return 0x8218F400;
		  /* 8218F400h */ case   24:  		/* lwz R11, <#[R14 + 4]> */
		/* 8218F400h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000004) );
		/* 8218F400h case   24:*/		return 0x8218F404;
		  /* 8218F404h */ case   25:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8218F404h case   25:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8218F404h case   25:*/		return 0x8218F408;
		  /* 8218F408h */ case   26:  		/* addic R10, R10, -1 */
		/* 8218F408h case   26:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8218F408h case   26:*/		return 0x8218F40C;
		  /* 8218F40Ch */ case   27:  		/* subfe R10, R10, R10 */
		/* 8218F40Ch case   27:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8218F40Ch case   27:*/		return 0x8218F410;
		  /* 8218F410h */ case   28:  		/* and R11, R10, R11 */
		/* 8218F410h case   28:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218F410h case   28:*/		return 0x8218F414;
		  /* 8218F414h */ case   29:  		/* lwz R30, <#[R11 + 20]> */
		/* 8218F414h case   29:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000014) );
		/* 8218F414h case   29:*/		return 0x8218F418;
		  /* 8218F418h */ case   30:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 8218F418h case   30:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 8218F418h case   30:*/		return 0x8218F41C;
		  /* 8218F41Ch */ case   31:  		/* bc 4, CR0_EQ, 156 */
		/* 8218F41Ch case   31:*/		if ( !regs.CR[0].eq ) { return 0x8218F4B8;  }
		/* 8218F41Ch case   31:*/		return 0x8218F420;
		  /* 8218F420h */ case   32:  		/* cmplwi CR0, R30, 0 */
		/* 8218F420h case   32:*/		cpu::op::cmplwi<0>(regs,regs.R30,0x00000000);
		/* 8218F420h case   32:*/		return 0x8218F424;
		  /* 8218F424h */ case   33:  		/* bc 12, CR0_EQ, 148 */
		/* 8218F424h case   33:*/		if ( regs.CR[0].eq ) { return 0x8218F4B8;  }
		/* 8218F424h case   33:*/		return 0x8218F428;
		  /* 8218F428h */ case   34:  		/* lwz R11, <#[R30 + 8]> */
		/* 8218F428h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8218F428h case   34:*/		return 0x8218F42C;
		  /* 8218F42Ch */ case   35:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8218F42Ch case   35:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8218F42Ch case   35:*/		return 0x8218F430;
		  /* 8218F430h */ case   36:  		/* cmplwi CR6, R11, 15872 */
		/* 8218F430h case   36:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E00);
		/* 8218F430h case   36:*/		return 0x8218F434;
		  /* 8218F434h */ case   37:  		/* bc 4, CR6_EQ, 76 */
		/* 8218F434h case   37:*/		if ( !regs.CR[6].eq ) { return 0x8218F480;  }
		/* 8218F434h case   37:*/		return 0x8218F438;
		  /* 8218F438h */ case   38:  		/* lwz R11, <#[R30 + 8]> */
		/* 8218F438h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8218F438h case   38:*/		return 0x8218F43C;
		  /* 8218F43Ch */ case   39:  		/* mr R3, R14 */
		/* 8218F43Ch case   39:*/		regs.R3 = regs.R14;
		/* 8218F43Ch case   39:*/		return 0x8218F440;
		  /* 8218F440h */ case   40:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8218F440h case   40:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8218F440h case   40:*/		return 0x8218F444;
		  /* 8218F444h */ case   41:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8218F444h case   41:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8218F444h case   41:*/		return 0x8218F448;
		  /* 8218F448h */ case   42:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8218F448h case   42:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8218F448h case   42:*/		return 0x8218F44C;
		  /* 8218F44Ch */ case   43:  		/* bl -176156 */
		/* 8218F44Ch case   43:*/		regs.LR = 0x8218F450; return 0x82164430;
		/* 8218F44Ch case   43:*/		return 0x8218F450;
		  /* 8218F450h */ case   44:  		/* addi R11, R30, -8 */
		/* 8218F450h case   44:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFF8);
		/* 8218F450h case   44:*/		return 0x8218F454;
		  /* 8218F454h */ case   45:  		/* add R10, R3, R11 */
		/* 8218F454h case   45:*/		cpu::op::add<0>(regs,&regs.R10,regs.R3,regs.R11);
		/* 8218F454h case   45:*/		return 0x8218F458;
		  /* 8218F458h */ case   46:  		/* lwz R11, <#[R10]> */
		/* 8218F458h case   46:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8218F458h case   46:*/		return 0x8218F45C;
		  /* 8218F45Ch */ case   47:  		/* rlwinm R9, R11, 0, 17, 31 */
		/* 8218F45Ch case   47:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R9,regs.R11);
		/* 8218F45Ch case   47:*/		return 0x8218F460;
		  /* 8218F460h */ case   48:  		/* cmplw CR6, R9, R27 */
		/* 8218F460h case   48:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R27);
		/* 8218F460h case   48:*/		return 0x8218F464;
		  /* 8218F464h */ case   49:  		/* bc 4, CR6_EQ, 28 */
		/* 8218F464h case   49:*/		if ( !regs.CR[6].eq ) { return 0x8218F480;  }
		/* 8218F464h case   49:*/		return 0x8218F468;
		  /* 8218F468h */ case   50:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 8218F468h case   50:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 8218F468h case   50:*/		return 0x8218F46C;
		  /* 8218F46Ch */ case   51:  		/* bc 12, CR0_EQ, 20 */
		/* 8218F46Ch case   51:*/		if ( regs.CR[0].eq ) { return 0x8218F480;  }
		/* 8218F46Ch case   51:*/		return 0x8218F470;
		  /* 8218F470h */ case   52:  		/* lwz R11, <#[R10 + 4]> */
		/* 8218F470h case   52:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8218F470h case   52:*/		return 0x8218F474;
		  /* 8218F474h */ case   53:  		/* rlwinm R11, R11, 0, 26, 27 */
		/* 8218F474h case   53:*/		cpu::op::rlwinm<0,0,26,27>(regs,&regs.R11,regs.R11);
		/* 8218F474h case   53:*/		return 0x8218F478;
		  /* 8218F478h */ case   54:  		/* cmplwi CR6, R11, 48 */
		/* 8218F478h case   54:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 8218F478h case   54:*/		return 0x8218F47C;
		  /* 8218F47Ch */ case   55:  		/* bc 12, CR6_EQ, 32 */
		/* 8218F47Ch case   55:*/		if ( regs.CR[6].eq ) { return 0x8218F49C;  }
		/* 8218F47Ch case   55:*/		return 0x8218F480;
	}
	return 0x8218F480;
} // Block from 8218F3A0h-8218F480h (56 instructions)

//////////////////////////////////////////////////////
// Block at 8218F480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F480);
		  /* 8218F480h */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 8218F480h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 8218F480h case    0:*/		return 0x8218F484;
		  /* 8218F484h */ case    1:  		/* lwz R30, <#[R11 + 40]> */
		/* 8218F484h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000028) );
		/* 8218F484h case    1:*/		return 0x8218F488;
		  /* 8218F488h */ case    2:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 8218F488h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 8218F488h case    2:*/		return 0x8218F48C;
		  /* 8218F48Ch */ case    3:  		/* bc 4, CR0_EQ, 44 */
		/* 8218F48Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8218F4B8;  }
		/* 8218F48Ch case    3:*/		return 0x8218F490;
		  /* 8218F490h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 8218F490h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8218F490h case    4:*/		return 0x8218F494;
		  /* 8218F494h */ case    5:  		/* bc 4, CR6_EQ, -108 */
		/* 8218F494h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8218F428;  }
		/* 8218F494h case    5:*/		return 0x8218F498;
		  /* 8218F498h */ case    6:  		/* b 32 */
		/* 8218F498h case    6:*/		return 0x8218F4B8;
		/* 8218F498h case    6:*/		return 0x8218F49C;
	}
	return 0x8218F49C;
} // Block from 8218F480h-8218F49Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218F49Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F49C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F49C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F49C);
		  /* 8218F49Ch */ case    0:  		/* lwz R11, <#[R1 + 92]> */
		/* 8218F49Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8218F49Ch case    0:*/		return 0x8218F4A0;
		  /* 8218F4A0h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8218F4A0h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8218F4A0h case    1:*/		return 0x8218F4A4;
		  /* 8218F4A4h */ case    2:  		/* bc 4, CR0_EQ, 20 */
		/* 8218F4A4h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8218F4B8;  }
		/* 8218F4A4h case    2:*/		return 0x8218F4A8;
		  /* 8218F4A8h */ case    3:  		/* li R4, 1 */
		/* 8218F4A8h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8218F4A8h case    3:*/		return 0x8218F4AC;
		  /* 8218F4ACh */ case    4:  		/* addi R3, R1, 88 */
		/* 8218F4ACh case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 8218F4ACh case    4:*/		return 0x8218F4B0;
		  /* 8218F4B0h */ case    5:  		/* bl -12968 */
		/* 8218F4B0h case    5:*/		regs.LR = 0x8218F4B4; return 0x8218C208;
		/* 8218F4B0h case    5:*/		return 0x8218F4B4;
		  /* 8218F4B4h */ case    6:  		/* li R29, 1 */
		/* 8218F4B4h case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 8218F4B4h case    6:*/		return 0x8218F4B8;
	}
	return 0x8218F4B8;
} // Block from 8218F49Ch-8218F4B8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218F4B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F4B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F4B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F4B8);
		  /* 8218F4B8h */ case    0:  		/* mr R4, R28 */
		/* 8218F4B8h case    0:*/		regs.R4 = regs.R28;
		/* 8218F4B8h case    0:*/		return 0x8218F4BC;
		  /* 8218F4BCh */ case    1:  		/* addi R3, R1, 88 */
		/* 8218F4BCh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 8218F4BCh case    1:*/		return 0x8218F4C0;
		  /* 8218F4C0h */ case    2:  		/* bl -9072 */
		/* 8218F4C0h case    2:*/		regs.LR = 0x8218F4C4; return 0x8218D150;
		/* 8218F4C0h case    2:*/		return 0x8218F4C4;
		  /* 8218F4C4h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 8218F4C4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8218F4C4h case    3:*/		return 0x8218F4C8;
		  /* 8218F4C8h */ case    4:  		/* lwz R10, <#[R31 + 4]> */
		/* 8218F4C8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8218F4C8h case    4:*/		return 0x8218F4CC;
		  /* 8218F4CCh */ case    5:  		/* rlwinm. R9, R29, 0, 24, 31 */
		/* 8218F4CCh case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R29);
		/* 8218F4CCh case    5:*/		return 0x8218F4D0;
		  /* 8218F4D0h */ case    6:  		/* rlwimi R11, R3, 20, 3, 11 */
		/* 8218F4D0h case    6:*/		cpu::op::rlwimi<0,20,3,11>(regs,&regs.R11,regs.R3);
		/* 8218F4D0h case    6:*/		return 0x8218F4D4;
		  /* 8218F4D4h */ case    7:  		/* oris R10, R10, 512 */
		/* 8218F4D4h case    7:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x200);
		/* 8218F4D4h case    7:*/		return 0x8218F4D8;
		  /* 8218F4D8h */ case    8:  		/* stw R11, <#[R31]> */
		/* 8218F4D8h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8218F4D8h case    8:*/		return 0x8218F4DC;
		  /* 8218F4DCh */ case    9:  		/* stw R10, <#[R31 + 4]> */
		/* 8218F4DCh case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8218F4DCh case    9:*/		return 0x8218F4E0;
		  /* 8218F4E0h */ case   10:  		/* bc 12, CR0_EQ, 92 */
		/* 8218F4E0h case   10:*/		if ( regs.CR[0].eq ) { return 0x8218F53C;  }
		/* 8218F4E0h case   10:*/		return 0x8218F4E4;
		  /* 8218F4E4h */ case   11:  		/* lwz R11, <#[R1 + 92]> */
		/* 8218F4E4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8218F4E4h case   11:*/		return 0x8218F4E8;
		  /* 8218F4E8h */ case   12:  		/* addi R11, R11, -1 */
		/* 8218F4E8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8218F4E8h case   12:*/		return 0x8218F4EC;
		  /* 8218F4ECh */ case   13:  		/* stw R11, <#[R1 + 92]> */
		/* 8218F4ECh case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8218F4ECh case   13:*/		return 0x8218F4F0;
		  /* 8218F4F0h */ case   14:  		/* b 76 */
		/* 8218F4F0h case   14:*/		return 0x8218F53C;
		/* 8218F4F0h case   14:*/		return 0x8218F4F4;
	}
	return 0x8218F4F4;
} // Block from 8218F4B8h-8218F4F4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8218F4F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F4F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F4F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F4F4);
		  /* 8218F4F4h */ case    0:  		/* mr R5, R28 */
		/* 8218F4F4h case    0:*/		regs.R5 = regs.R28;
		/* 8218F4F4h case    0:*/		return 0x8218F4F8;
		  /* 8218F4F8h */ case    1:  		/* addi R4, R1, 320 */
		/* 8218F4F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x140);
		/* 8218F4F8h case    1:*/		return 0x8218F4FC;
		  /* 8218F4FCh */ case    2:  		/* mr R3, R14 */
		/* 8218F4FCh case    2:*/		regs.R3 = regs.R14;
		/* 8218F4FCh case    2:*/		return 0x8218F500;
		  /* 8218F500h */ case    3:  		/* bl -9904 */
		/* 8218F500h case    3:*/		regs.LR = 0x8218F504; return 0x8218CE50;
		/* 8218F500h case    3:*/		return 0x8218F504;
		  /* 8218F504h */ case    4:  		/* b 32 */
		/* 8218F504h case    4:*/		return 0x8218F524;
		/* 8218F504h case    4:*/		return 0x8218F508;
	}
	return 0x8218F508;
} // Block from 8218F4F4h-8218F508h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218F508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F508);
		  /* 8218F508h */ case    0:  		/* mr R4, R28 */
		/* 8218F508h case    0:*/		regs.R4 = regs.R28;
		/* 8218F508h case    0:*/		return 0x8218F50C;
		  /* 8218F50Ch */ case    1:  		/* addi R3, R1, 96 */
		/* 8218F50Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8218F50Ch case    1:*/		return 0x8218F510;
		  /* 8218F510h */ case    2:  		/* bl -8928 */
		/* 8218F510h case    2:*/		regs.LR = 0x8218F514; return 0x8218D230;
		/* 8218F510h case    2:*/		return 0x8218F514;
		  /* 8218F514h */ case    3:  		/* b 16 */
		/* 8218F514h case    3:*/		return 0x8218F524;
		/* 8218F514h case    3:*/		return 0x8218F518;
	}
	return 0x8218F518;
} // Block from 8218F508h-8218F518h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218F518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F518);
		  /* 8218F518h */ case    0:  		/* mr R4, R28 */
		/* 8218F518h case    0:*/		regs.R4 = regs.R28;
		/* 8218F518h case    0:*/		return 0x8218F51C;
		  /* 8218F51Ch */ case    1:  		/* addi R3, R1, 128 */
		/* 8218F51Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 8218F51Ch case    1:*/		return 0x8218F520;
		  /* 8218F520h */ case    2:  		/* bl -9032 */
		/* 8218F520h case    2:*/		regs.LR = 0x8218F524; return 0x8218D1D8;
		/* 8218F520h case    2:*/		return 0x8218F524;
	}
	return 0x8218F524;
} // Block from 8218F518h-8218F524h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218F524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F524);
		  /* 8218F524h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8218F524h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8218F524h case    0:*/		return 0x8218F528;
		  /* 8218F528h */ case    1:  		/* lwz R10, <#[R31 + 4]> */
		/* 8218F528h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8218F528h case    1:*/		return 0x8218F52C;
		  /* 8218F52Ch */ case    2:  		/* rlwimi R11, R3, 20, 3, 11 */
		/* 8218F52Ch case    2:*/		cpu::op::rlwimi<0,20,3,11>(regs,&regs.R11,regs.R3);
		/* 8218F52Ch case    2:*/		return 0x8218F530;
		  /* 8218F530h */ case    3:  		/* oris R10, R10, 512 */
		/* 8218F530h case    3:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x200);
		/* 8218F530h case    3:*/		return 0x8218F534;
		  /* 8218F534h */ case    4:  		/* stw R11, <#[R31]> */
		/* 8218F534h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8218F534h case    4:*/		return 0x8218F538;
		  /* 8218F538h */ case    5:  		/* stw R10, <#[R31 + 4]> */
		/* 8218F538h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8218F538h case    5:*/		return 0x8218F53C;
	}
	return 0x8218F53C;
} // Block from 8218F524h-8218F53Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218F53Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F53C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F53C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F53C);
		  /* 8218F53Ch */ case    0:  		/* addi R27, R27, 1 */
		/* 8218F53Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8218F53Ch case    0:*/		return 0x8218F540;
		  /* 8218F540h */ case    1:  		/* addi R26, R26, 40 */
		/* 8218F540h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x28);
		/* 8218F540h case    1:*/		return 0x8218F544;
		  /* 8218F544h */ case    2:  		/* cmplw CR6, R27, R20 */
		/* 8218F544h case    2:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R20);
		/* 8218F544h case    2:*/		return 0x8218F548;
		  /* 8218F548h */ case    3:  		/* bc 12, CR6_LT, -408 */
		/* 8218F548h case    3:*/		if ( regs.CR[6].lt ) { return 0x8218F3B0;  }
		/* 8218F548h case    3:*/		return 0x8218F54C;
	}
	return 0x8218F54C;
} // Block from 8218F53Ch-8218F54Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218F54Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F54C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F54C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F54C);
		  /* 8218F54Ch */ case    0:  		/* addi R4, R1, 320 */
		/* 8218F54Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x140);
		/* 8218F54Ch case    0:*/		return 0x8218F550;
		  /* 8218F550h */ case    1:  		/* mr R3, R14 */
		/* 8218F550h case    1:*/		regs.R3 = regs.R14;
		/* 8218F550h case    1:*/		return 0x8218F554;
		  /* 8218F554h */ case    2:  		/* bl -7532 */
		/* 8218F554h case    2:*/		regs.LR = 0x8218F558; return 0x8218D7E8;
		/* 8218F554h case    2:*/		return 0x8218F558;
		  /* 8218F558h */ case    3:  		/* lwz R11, <#[R14 + 4]> */
		/* 8218F558h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000004) );
		/* 8218F558h case    3:*/		return 0x8218F55C;
		  /* 8218F55Ch */ case    4:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8218F55Ch case    4:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8218F55Ch case    4:*/		return 0x8218F560;
		  /* 8218F560h */ case    5:  		/* addic R10, R10, -1 */
		/* 8218F560h case    5:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8218F560h case    5:*/		return 0x8218F564;
		  /* 8218F564h */ case    6:  		/* subfe R10, R10, R10 */
		/* 8218F564h case    6:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8218F564h case    6:*/		return 0x8218F568;
		  /* 8218F568h */ case    7:  		/* and R11, R10, R11 */
		/* 8218F568h case    7:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218F568h case    7:*/		return 0x8218F56C;
		  /* 8218F56Ch */ case    8:  		/* lwz R31, <#[R11 + 20]> */
		/* 8218F56Ch case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000014) );
		/* 8218F56Ch case    8:*/		return 0x8218F570;
		  /* 8218F570h */ case    9:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 8218F570h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 8218F570h case    9:*/		return 0x8218F574;
		  /* 8218F574h */ case   10:  		/* bc 4, CR0_EQ, 280 */
		/* 8218F574h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8218F68C;  }
		/* 8218F574h case   10:*/		return 0x8218F578;
		  /* 8218F578h */ case   11:  		/* cmplwi CR0, R31, 0 */
		/* 8218F578h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 8218F578h case   11:*/		return 0x8218F57C;
		  /* 8218F57Ch */ case   12:  		/* bc 12, CR0_EQ, 272 */
		/* 8218F57Ch case   12:*/		if ( regs.CR[0].eq ) { return 0x8218F68C;  }
		/* 8218F57Ch case   12:*/		return 0x8218F580;
		  /* 8218F580h */ case   13:  		/* lis R11, -32252 */
		/* 8218F580h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8218F580h case   13:*/		return 0x8218F584;
		  /* 8218F584h */ case   14:  		/* lwz R28, <#[R1 + 104]> */
		/* 8218F584h case   14:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000068) );
		/* 8218F584h case   14:*/		return 0x8218F588;
		  /* 8218F588h */ case   15:  		/* addi R27, R11, -17164 */
		/* 8218F588h case   15:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFFBCF4);
		/* 8218F588h case   15:*/		return 0x8218F58C;
		  /* 8218F58Ch */ case   16:  		/* lwz R11, <#[R31 + 8]> */
		/* 8218F58Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8218F58Ch case   16:*/		return 0x8218F590;
		  /* 8218F590h */ case   17:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8218F590h case   17:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8218F590h case   17:*/		return 0x8218F594;
		  /* 8218F594h */ case   18:  		/* cmplwi CR6, R11, 125 */
		/* 8218F594h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 8218F594h case   18:*/		return 0x8218F598;
		  /* 8218F598h */ case   19:  		/* bc 4, CR6_EQ, 72 */
		/* 8218F598h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8218F5E0;  }
		/* 8218F598h case   19:*/		return 0x8218F59C;
		  /* 8218F59Ch */ case   20:  		/* li R4, 4 */
		/* 8218F59Ch case   20:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 8218F59Ch case   20:*/		return 0x8218F5A0;
		  /* 8218F5A0h */ case   21:  		/* addi R3, R1, 320 */
		/* 8218F5A0h case   21:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x140);
		/* 8218F5A0h case   21:*/		return 0x8218F5A4;
		  /* 8218F5A4h */ case   22:  		/* bl -13476 */
		/* 8218F5A4h case   22:*/		regs.LR = 0x8218F5A8; return 0x8218C100;
		/* 8218F5A4h case   22:*/		return 0x8218F5A8;
		  /* 8218F5A8h */ case   23:  		/* lwz R11, <#[R31 + 8]> */
		/* 8218F5A8h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8218F5A8h case   23:*/		return 0x8218F5AC;
		  /* 8218F5ACh */ case   24:  		/* li R10, 1 */
		/* 8218F5ACh case   24:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8218F5ACh case   24:*/		return 0x8218F5B0;
		  /* 8218F5B0h */ case   25:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 8218F5B0h case   25:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 8218F5B0h case   25:*/		return 0x8218F5B4;
		  /* 8218F5B4h */ case   26:  		/* rlwimi R3, R28, 0, 28, 31 */
		/* 8218F5B4h case   26:*/		cpu::op::rlwimi<0,0,28,31>(regs,&regs.R3,regs.R28);
		/* 8218F5B4h case   26:*/		return 0x8218F5B8;
		  /* 8218F5B8h */ case   27:  		/* slw R11, R10, R11 */
		/* 8218F5B8h case   27:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218F5B8h case   27:*/		return 0x8218F5BC;
		  /* 8218F5BCh */ case   28:  		/* addi R28, R11, -1 */
		/* 8218F5BCh case   28:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0xFFFFFFFF);
		/* 8218F5BCh case   28:*/		return 0x8218F5C0;
		  /* 8218F5C0h */ case   29:  		/* mr R11, R3 */
		/* 8218F5C0h case   29:*/		regs.R11 = regs.R3;
		/* 8218F5C0h case   29:*/		return 0x8218F5C4;
		  /* 8218F5C4h */ case   30:  		/* rlwimi R28, R3, 0, 0, 27 */
		/* 8218F5C4h case   30:*/		cpu::op::rlwimi<0,0,0,27>(regs,&regs.R28,regs.R3);
		/* 8218F5C4h case   30:*/		return 0x8218F5C8;
		  /* 8218F5C8h */ case   31:  		/* rlwinm R11, R28, 0, 28, 31 */
		/* 8218F5C8h case   31:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R28);
		/* 8218F5C8h case   31:*/		return 0x8218F5CC;
		  /* 8218F5CCh */ case   32:  		/* mr R4, R28 */
		/* 8218F5CCh case   32:*/		regs.R4 = regs.R28;
		/* 8218F5CCh case   32:*/		return 0x8218F5D0;
		  /* 8218F5D0h */ case   33:  		/* b 148 */
		/* 8218F5D0h case   33:*/		return 0x8218F664;
		/* 8218F5D0h case   33:*/		return 0x8218F5D4;
	}
	return 0x8218F5D4;
} // Block from 8218F54Ch-8218F5D4h (34 instructions)

//////////////////////////////////////////////////////
// Block at 8218F5D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F5D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F5D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F5D4);
		  /* 8218F5D4h */ case    0:  		/* li R4, 4800 */
		/* 8218F5D4h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8218F5D4h case    0:*/		return 0x8218F5D8;
		  /* 8218F5D8h */ case    1:  		/* mr R3, R14 */
		/* 8218F5D8h case    1:*/		regs.R3 = regs.R14;
		/* 8218F5D8h case    1:*/		return 0x8218F5DC;
		  /* 8218F5DCh */ case    2:  		/* bl -251764 */
		/* 8218F5DCh case    2:*/		regs.LR = 0x8218F5E0; return 0x82151E68;
		/* 8218F5DCh case    2:*/		return 0x8218F5E0;
	}
	return 0x8218F5E0;
} // Block from 8218F5D4h-8218F5E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218F5E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F5E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F5E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F5E0);
		  /* 8218F5E0h */ case    0:  		/* cmplwi CR6, R11, 124 */
		/* 8218F5E0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 8218F5E0h case    0:*/		return 0x8218F5E4;
		  /* 8218F5E4h */ case    1:  		/* bc 4, CR6_EQ, 144 */
		/* 8218F5E4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8218F674;  }
		/* 8218F5E4h case    1:*/		return 0x8218F5E8;
		  /* 8218F5E8h */ case    2:  		/* mr R4, R14 */
		/* 8218F5E8h case    2:*/		regs.R4 = regs.R14;
		/* 8218F5E8h case    2:*/		return 0x8218F5EC;
		  /* 8218F5ECh */ case    3:  		/* mr R3, R31 */
		/* 8218F5ECh case    3:*/		regs.R3 = regs.R31;
		/* 8218F5ECh case    3:*/		return 0x8218F5F0;
		  /* 8218F5F0h */ case    4:  		/* bl 30136 */
		/* 8218F5F0h case    4:*/		regs.LR = 0x8218F5F4; return 0x82196BA8;
		/* 8218F5F0h case    4:*/		return 0x8218F5F4;
		  /* 8218F5F4h */ case    5:  		/* lwz R11, <#[R31 + 8]> */
		/* 8218F5F4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8218F5F4h case    5:*/		return 0x8218F5F8;
		  /* 8218F5F8h */ case    6:  		/* mr R3, R14 */
		/* 8218F5F8h case    6:*/		regs.R3 = regs.R14;
		/* 8218F5F8h case    6:*/		return 0x8218F5FC;
		  /* 8218F5FCh */ case    7:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8218F5FCh case    7:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8218F5FCh case    7:*/		return 0x8218F600;
		  /* 8218F600h */ case    8:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8218F600h case    8:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8218F600h case    8:*/		return 0x8218F604;
		  /* 8218F604h */ case    9:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8218F604h case    9:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8218F604h case    9:*/		return 0x8218F608;
		  /* 8218F608h */ case   10:  		/* addi R30, R31, -8 */
		/* 8218F608h case   10:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0xFFFFFFF8);
		/* 8218F608h case   10:*/		return 0x8218F60C;
		  /* 8218F60Ch */ case   11:  		/* bl -176604 */
		/* 8218F60Ch case   11:*/		regs.LR = 0x8218F610; return 0x82164430;
		/* 8218F60Ch case   11:*/		return 0x8218F610;
		  /* 8218F610h */ case   12:  		/* add R11, R3, R30 */
		/* 8218F610h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R30);
		/* 8218F610h case   12:*/		return 0x8218F614;
		  /* 8218F614h */ case   13:  		/* lwz R10, <#[R31 + 8]> */
		/* 8218F614h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8218F614h case   13:*/		return 0x8218F618;
		  /* 8218F618h */ case   14:  		/* mr R3, R14 */
		/* 8218F618h case   14:*/		regs.R3 = regs.R14;
		/* 8218F618h case   14:*/		return 0x8218F61C;
		  /* 8218F61Ch */ case   15:  		/* rlwinm R6, R10, 18, 29, 31 */
		/* 8218F61Ch case   15:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R10);
		/* 8218F61Ch case   15:*/		return 0x8218F620;
		  /* 8218F620h */ case   16:  		/* rlwinm R5, R10, 13, 29, 31 */
		/* 8218F620h case   16:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R10);
		/* 8218F620h case   16:*/		return 0x8218F624;
		  /* 8218F624h */ case   17:  		/* lwz R9, <#[R11]> */
		/* 8218F624h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8218F624h case   17:*/		return 0x8218F628;
		  /* 8218F628h */ case   18:  		/* rlwinm R4, R10, 25, 25, 31 */
		/* 8218F628h case   18:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R10);
		/* 8218F628h case   18:*/		return 0x8218F62C;
		  /* 8218F62Ch */ case   19:  		/* lwz R11, <#[R11 + 4]> */
		/* 8218F62Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8218F62Ch case   19:*/		return 0x8218F630;
		  /* 8218F630h */ case   20:  		/* rlwimi R11, R9, 21, 14, 27 */
		/* 8218F630h case   20:*/		cpu::op::rlwimi<0,21,14,27>(regs,&regs.R11,regs.R9);
		/* 8218F630h case   20:*/		return 0x8218F634;
		  /* 8218F634h */ case   21:  		/* rlwinm R29, R11, 0, 14, 31 */
		/* 8218F634h case   21:*/		cpu::op::rlwinm<0,0,14,31>(regs,&regs.R29,regs.R11);
		/* 8218F634h case   21:*/		return 0x8218F638;
		  /* 8218F638h */ case   22:  		/* bl -176648 */
		/* 8218F638h case   22:*/		regs.LR = 0x8218F63C; return 0x82164430;
		/* 8218F638h case   22:*/		return 0x8218F63C;
		  /* 8218F63Ch */ case   23:  		/* lwzx R11, <#[R3 + R30]> */
		/* 8218F63Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R30 + 0x00000000) );
		/* 8218F63Ch case   23:*/		return 0x8218F640;
		  /* 8218F640h */ case   24:  		/* lwz R10, <#[R14 + 12]> */
		/* 8218F640h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218F640h case   24:*/		return 0x8218F644;
		  /* 8218F644h */ case   25:  		/* rlwinm R11, R11, 0, 17, 31 */
		/* 8218F644h case   25:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R11,regs.R11);
		/* 8218F644h case   25:*/		return 0x8218F648;
		  /* 8218F648h */ case   26:  		/* mulli R11, R11, 40 */
		/* 8218F648h case   26:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x28);
		/* 8218F648h case   26:*/		return 0x8218F64C;
		  /* 8218F64Ch */ case   27:  		/* lhzx R11, <#[R11 + R10]> */
		/* 8218F64Ch case   27:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8218F64Ch case   27:*/		return 0x8218F650;
		  /* 8218F650h */ case   28:  		/* rlwinm R11, R11, 0, 19, 27 */
		/* 8218F650h case   28:*/		cpu::op::rlwinm<0,0,19,27>(regs,&regs.R11,regs.R11);
		/* 8218F650h case   28:*/		return 0x8218F654;
		  /* 8218F654h */ case   29:  		/* add R11, R11, R29 */
		/* 8218F654h case   29:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8218F654h case   29:*/		return 0x8218F658;
		  /* 8218F658h */ case   30:  		/* rlwimi R11, R29, 0, 28, 31 */
		/* 8218F658h case   30:*/		cpu::op::rlwimi<0,0,28,31>(regs,&regs.R11,regs.R29);
		/* 8218F658h case   30:*/		return 0x8218F65C;
		  /* 8218F65Ch */ case   31:  		/* mr R4, R11 */
		/* 8218F65Ch case   31:*/		regs.R4 = regs.R11;
		/* 8218F65Ch case   31:*/		return 0x8218F660;
		  /* 8218F660h */ case   32:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 8218F660h case   32:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 8218F660h case   32:*/		return 0x8218F664;
	}
	return 0x8218F664;
} // Block from 8218F5E0h-8218F664h (33 instructions)

//////////////////////////////////////////////////////
// Block at 8218F664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F664);
		  /* 8218F664h */ case    0:  		/* add R11, R11, R27 */
		/* 8218F664h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 8218F664h case    0:*/		return 0x8218F668;
		  /* 8218F668h */ case    1:  		/* mr R3, R31 */
		/* 8218F668h case    1:*/		regs.R3 = regs.R31;
		/* 8218F668h case    1:*/		return 0x8218F66C;
		  /* 8218F66Ch */ case    2:  		/* lbz R5, <#[R11 - 1]> */
		/* 8218F66Ch case    2:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R11 + 0xFFFFFFFF) );
		/* 8218F66Ch case    2:*/		return 0x8218F670;
		  /* 8218F670h */ case    3:  		/* bl 601784 */
		/* 8218F670h case    3:*/		regs.LR = 0x8218F674; return 0x82222528;
		/* 8218F670h case    3:*/		return 0x8218F674;
	}
	return 0x8218F674;
} // Block from 8218F664h-8218F674h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218F674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F674);
		  /* 8218F674h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8218F674h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8218F674h case    0:*/		return 0x8218F678;
		  /* 8218F678h */ case    1:  		/* lwz R31, <#[R11 + 40]> */
		/* 8218F678h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000028) );
		/* 8218F678h case    1:*/		return 0x8218F67C;
		  /* 8218F67Ch */ case    2:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 8218F67Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 8218F67Ch case    2:*/		return 0x8218F680;
		  /* 8218F680h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 8218F680h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8218F68C;  }
		/* 8218F680h case    3:*/		return 0x8218F684;
		  /* 8218F684h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8218F684h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8218F684h case    4:*/		return 0x8218F688;
		  /* 8218F688h */ case    5:  		/* bc 4, CR6_EQ, -252 */
		/* 8218F688h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8218F58C;  }
		/* 8218F688h case    5:*/		return 0x8218F68C;
	}
	return 0x8218F68C;
} // Block from 8218F674h-8218F68Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218F68Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F68C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F68C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F68C);
		  /* 8218F68Ch */ case    0:  		/* lwz R11, <#[R14 + 40]> */
		/* 8218F68Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000028) );
		/* 8218F68Ch case    0:*/		return 0x8218F690;
		  /* 8218F690h */ case    1:  		/* rlwinm. R11, R11, 0, 22, 22 */
		/* 8218F690h case    1:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R11,regs.R11);
		/* 8218F690h case    1:*/		return 0x8218F694;
		  /* 8218F694h */ case    2:  		/* bc 12, CR0_EQ, 276 */
		/* 8218F694h case    2:*/		if ( regs.CR[0].eq ) { return 0x8218F7A8;  }
		/* 8218F694h case    2:*/		return 0x8218F698;
		  /* 8218F698h */ case    3:  		/* lwz R11, <#[R14 + 4]> */
		/* 8218F698h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000004) );
		/* 8218F698h case    3:*/		return 0x8218F69C;
		  /* 8218F69Ch */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8218F69Ch case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8218F69Ch case    4:*/		return 0x8218F6A0;
		  /* 8218F6A0h */ case    5:  		/* bc 4, CR0_EQ, 264 */
		/* 8218F6A0h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8218F7A8;  }
		/* 8218F6A0h case    5:*/		return 0x8218F6A4;
		  /* 8218F6A4h */ case    6:  		/* mr R28, R11 */
		/* 8218F6A4h case    6:*/		regs.R28 = regs.R11;
		/* 8218F6A4h case    6:*/		return 0x8218F6A8;
		  /* 8218F6A8h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 8218F6A8h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8218F6A8h case    7:*/		return 0x8218F6AC;
		  /* 8218F6ACh */ case    8:  		/* bc 12, CR0_EQ, 252 */
		/* 8218F6ACh case    8:*/		if ( regs.CR[0].eq ) { return 0x8218F7A8;  }
		/* 8218F6ACh case    8:*/		return 0x8218F6B0;
		  /* 8218F6B0h */ case    9:  		/* lwz R11, <#[R28 + 28]> */
		/* 8218F6B0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000001C) );
		/* 8218F6B0h case    9:*/		return 0x8218F6B4;
		  /* 8218F6B4h */ case   10:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8218F6B4h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8218F6B4h case   10:*/		return 0x8218F6B8;
		  /* 8218F6B8h */ case   11:  		/* bc 4, CR0_EQ, 212 */
		/* 8218F6B8h case   11:*/		if ( !regs.CR[0].eq ) { return 0x8218F78C;  }
		/* 8218F6B8h case   11:*/		return 0x8218F6BC;
		  /* 8218F6BCh */ case   12:  		/* lwz R11, <#[R28 + 24]> */
		/* 8218F6BCh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000018) );
		/* 8218F6BCh case   12:*/		return 0x8218F6C0;
		  /* 8218F6C0h */ case   13:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8218F6C0h case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8218F6C0h case   13:*/		return 0x8218F6C4;
		  /* 8218F6C4h */ case   14:  		/* addic. R31, R11, -40 */
		/* 8218F6C4h case   14:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 8218F6C4h case   14:*/		return 0x8218F6C8;
		  /* 8218F6C8h */ case   15:  		/* bc 12, CR0_EQ, 196 */
		/* 8218F6C8h case   15:*/		if ( regs.CR[0].eq ) { return 0x8218F78C;  }
		/* 8218F6C8h case   15:*/		return 0x8218F6CC;
		  /* 8218F6CCh */ case   16:  		/* lwz R11, <#[R31 + 8]> */
		/* 8218F6CCh case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8218F6CCh case   16:*/		return 0x8218F6D0;
		  /* 8218F6D0h */ case   17:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8218F6D0h case   17:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8218F6D0h case   17:*/		return 0x8218F6D4;
		  /* 8218F6D4h */ case   18:  		/* cmplwi CR6, R11, 10752 */
		/* 8218F6D4h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002A00);
		/* 8218F6D4h case   18:*/		return 0x8218F6D8;
		  /* 8218F6D8h */ case   19:  		/* bc 4, CR6_EQ, 180 */
		/* 8218F6D8h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8218F78C;  }
		/* 8218F6D8h case   19:*/		return 0x8218F6DC;
		  /* 8218F6DCh */ case   20:  		/* li R6, 0 */
		/* 8218F6DCh case   20:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8218F6DCh case   20:*/		return 0x8218F6E0;
		  /* 8218F6E0h */ case   21:  		/* li R5, 0 */
		/* 8218F6E0h case   21:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8218F6E0h case   21:*/		return 0x8218F6E4;
		  /* 8218F6E4h */ case   22:  		/* li R4, 84 */
		/* 8218F6E4h case   22:*/		cpu::op::li<0>(regs,&regs.R4,0x54);
		/* 8218F6E4h case   22:*/		return 0x8218F6E8;
		  /* 8218F6E8h */ case   23:  		/* mr R3, R14 */
		/* 8218F6E8h case   23:*/		regs.R3 = regs.R14;
		/* 8218F6E8h case   23:*/		return 0x8218F6EC;
		  /* 8218F6ECh */ case   24:  		/* bl -176828 */
		/* 8218F6ECh case   24:*/		regs.LR = 0x8218F6F0; return 0x82164430;
		/* 8218F6ECh case   24:*/		return 0x8218F6F0;
		  /* 8218F6F0h */ case   25:  		/* addi R11, R31, -32 */
		/* 8218F6F0h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFE0);
		/* 8218F6F0h case   25:*/		return 0x8218F6F4;
		  /* 8218F6F4h */ case   26:  		/* lwz R30, <#[R31]> */
		/* 8218F6F4h case   26:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000000) );
		/* 8218F6F4h case   26:*/		return 0x8218F6F8;
		  /* 8218F6F8h */ case   27:  		/* add R29, R3, R11 */
		/* 8218F6F8h case   27:*/		cpu::op::add<0>(regs,&regs.R29,regs.R3,regs.R11);
		/* 8218F6F8h case   27:*/		return 0x8218F6FC;
		  /* 8218F6FCh */ case   28:  		/* cmplwi CR6, R30, 0 */
		/* 8218F6FCh case   28:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8218F6FCh case   28:*/		return 0x8218F700;
		  /* 8218F700h */ case   29:  		/* bc 12, CR6_EQ, 116 */
		/* 8218F700h case   29:*/		if ( regs.CR[6].eq ) { return 0x8218F774;  }
		/* 8218F700h case   29:*/		return 0x8218F704;
		  /* 8218F704h */ case   30:  		/* lwz R31, <#[R30 + 12]> */
		/* 8218F704h case   30:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x0000000C) );
		/* 8218F704h case   30:*/		return 0x8218F708;
		  /* 8218F708h */ case   31:  		/* lwz R11, <#[R31 + 8]> */
		/* 8218F708h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8218F708h case   31:*/		return 0x8218F70C;
		  /* 8218F70Ch */ case   32:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8218F70Ch case   32:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8218F70Ch case   32:*/		return 0x8218F710;
		  /* 8218F710h */ case   33:  		/* cmplwi CR6, R11, 15872 */
		/* 8218F710h case   33:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E00);
		/* 8218F710h case   33:*/		return 0x8218F714;
		  /* 8218F714h */ case   34:  		/* bc 4, CR6_EQ, 68 */
		/* 8218F714h case   34:*/		if ( !regs.CR[6].eq ) { return 0x8218F758;  }
		/* 8218F714h case   34:*/		return 0x8218F718;
		  /* 8218F718h */ case   35:  		/* lwz R11, <#[R31 + 8]> */
		/* 8218F718h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8218F718h case   35:*/		return 0x8218F71C;
		  /* 8218F71Ch */ case   36:  		/* mr R3, R14 */
		/* 8218F71Ch case   36:*/		regs.R3 = regs.R14;
		/* 8218F71Ch case   36:*/		return 0x8218F720;
		  /* 8218F720h */ case   37:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8218F720h case   37:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8218F720h case   37:*/		return 0x8218F724;
		  /* 8218F724h */ case   38:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8218F724h case   38:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8218F724h case   38:*/		return 0x8218F728;
		  /* 8218F728h */ case   39:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8218F728h case   39:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8218F728h case   39:*/		return 0x8218F72C;
		  /* 8218F72Ch */ case   40:  		/* bl -176892 */
		/* 8218F72Ch case   40:*/		regs.LR = 0x8218F730; return 0x82164430;
		/* 8218F72Ch case   40:*/		return 0x8218F730;
		  /* 8218F730h */ case   41:  		/* addi R10, R31, -8 */
		/* 8218F730h case   41:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFF8);
		/* 8218F730h case   41:*/		return 0x8218F734;
		  /* 8218F734h */ case   42:  		/* lwz R11, <#[R14 + 12]> */
		/* 8218F734h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000000C) );
		/* 8218F734h case   42:*/		return 0x8218F738;
		  /* 8218F738h */ case   43:  		/* lwzx R10, <#[R3 + R10]> */
		/* 8218F738h case   43:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + regs.R10 + 0x00000000) );
		/* 8218F738h case   43:*/		return 0x8218F73C;
		  /* 8218F73Ch */ case   44:  		/* rlwinm R10, R10, 0, 17, 31 */
		/* 8218F73Ch case   44:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R10,regs.R10);
		/* 8218F73Ch case   44:*/		return 0x8218F740;
		  /* 8218F740h */ case   45:  		/* mulli R10, R10, 40 */
		/* 8218F740h case   45:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x28);
		/* 8218F740h case   45:*/		return 0x8218F744;
		  /* 8218F744h */ case   46:  		/* add R11, R10, R11 */
		/* 8218F744h case   46:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218F744h case   46:*/		return 0x8218F748;
		  /* 8218F748h */ case   47:  		/* lwz R11, <#[R11 + 4]> */
		/* 8218F748h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8218F748h case   47:*/		return 0x8218F74C;
		  /* 8218F74Ch */ case   48:  		/* rlwinm R11, R11, 0, 25, 27 */
		/* 8218F74Ch case   48:*/		cpu::op::rlwinm<0,0,25,27>(regs,&regs.R11,regs.R11);
		/* 8218F74Ch case   48:*/		return 0x8218F750;
		  /* 8218F750h */ case   49:  		/* cmplwi CR6, R11, 16 */
		/* 8218F750h case   49:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 8218F750h case   49:*/		return 0x8218F754;
		  /* 8218F754h */ case   50:  		/* bc 12, CR6_EQ, 12 */
		/* 8218F754h case   50:*/		if ( regs.CR[6].eq ) { return 0x8218F760;  }
		/* 8218F754h case   50:*/		return 0x8218F758;
	}
	return 0x8218F758;
} // Block from 8218F68Ch-8218F758h (51 instructions)

//////////////////////////////////////////////////////
// Block at 8218F758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F758);
		  /* 8218F758h */ case    0:  		/* lwz R30, <#[R30 + 4]> */
		/* 8218F758h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 8218F758h case    0:*/		return 0x8218F75C;
		  /* 8218F75Ch */ case    1:  		/* b -96 */
		/* 8218F75Ch case    1:*/		return 0x8218F6FC;
		/* 8218F75Ch case    1:*/		return 0x8218F760;
	}
	return 0x8218F760;
} // Block from 8218F758h-8218F760h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218F760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F760);
		  /* 8218F760h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8218F760h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8218F760h case    0:*/		return 0x8218F764;
		  /* 8218F764h */ case    1:  		/* lwz R10, <#[R29 + 12]> */
		/* 8218F764h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000000C) );
		/* 8218F764h case    1:*/		return 0x8218F768;
		  /* 8218F768h */ case    2:  		/* rlwimi R10, R11, 15, 27, 31 */
		/* 8218F768h case    2:*/		cpu::op::rlwimi<0,15,27,31>(regs,&regs.R10,regs.R11);
		/* 8218F768h case    2:*/		return 0x8218F76C;
		  /* 8218F76Ch */ case    3:  		/* stw R10, <#[R29 + 12]> */
		/* 8218F76Ch case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x0000000C) );
		/* 8218F76Ch case    3:*/		return 0x8218F770;
		  /* 8218F770h */ case    4:  		/* b 28 */
		/* 8218F770h case    4:*/		return 0x8218F78C;
		/* 8218F770h case    4:*/		return 0x8218F774;
	}
	return 0x8218F774;
} // Block from 8218F760h-8218F774h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218F774h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F774( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F774) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F774);
		  /* 8218F774h */ case    0:  		/* li R4, 1 */
		/* 8218F774h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8218F774h case    0:*/		return 0x8218F778;
		  /* 8218F778h */ case    1:  		/* addi R3, R1, 96 */
		/* 8218F778h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8218F778h case    1:*/		return 0x8218F77C;
		  /* 8218F77Ch */ case    2:  		/* bl -12956 */
		/* 8218F77Ch case    2:*/		regs.LR = 0x8218F780; return 0x8218C4E0;
		/* 8218F77Ch case    2:*/		return 0x8218F780;
		  /* 8218F780h */ case    3:  		/* lwz R11, <#[R29 + 12]> */
		/* 8218F780h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 8218F780h case    3:*/		return 0x8218F784;
		  /* 8218F784h */ case    4:  		/* rlwimi R11, R3, 28, 27, 31 */
		/* 8218F784h case    4:*/		cpu::op::rlwimi<0,28,27,31>(regs,&regs.R11,regs.R3);
		/* 8218F784h case    4:*/		return 0x8218F788;
		  /* 8218F788h */ case    5:  		/* stw R11, <#[R29 + 12]> */
		/* 8218F788h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 8218F788h case    5:*/		return 0x8218F78C;
	}
	return 0x8218F78C;
} // Block from 8218F774h-8218F78Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218F78Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F78C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F78C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F78C);
		  /* 8218F78Ch */ case    0:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 8218F78Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 8218F78Ch case    0:*/		return 0x8218F790;
		  /* 8218F790h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8218F790h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8218F790h case    1:*/		return 0x8218F794;
		  /* 8218F794h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8218F794h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8218F794h case    2:*/		return 0x8218F798;
		  /* 8218F798h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 8218F798h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8218F7A8;  }
		/* 8218F798h case    3:*/		return 0x8218F79C;
		  /* 8218F79Ch */ case    4:  		/* mr R28, R11 */
		/* 8218F79Ch case    4:*/		regs.R28 = regs.R11;
		/* 8218F79Ch case    4:*/		return 0x8218F7A0;
		  /* 8218F7A0h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8218F7A0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218F7A0h case    5:*/		return 0x8218F7A4;
		  /* 8218F7A4h */ case    6:  		/* bc 4, CR6_EQ, -244 */
		/* 8218F7A4h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8218F6B0;  }
		/* 8218F7A4h case    6:*/		return 0x8218F7A8;
	}
	return 0x8218F7A8;
} // Block from 8218F78Ch-8218F7A8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218F7A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F7A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F7A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F7A8);
		  /* 8218F7A8h */ case    0:  		/* lwz R10, <#[R14 + 44]> */
		/* 8218F7A8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x0000002C) );
		/* 8218F7A8h case    0:*/		return 0x8218F7AC;
		  /* 8218F7ACh */ case    1:  		/* rlwinm. R11, R10, 0, 8, 8 */
		/* 8218F7ACh case    1:*/		cpu::op::rlwinm<1,0,8,8>(regs,&regs.R11,regs.R10);
		/* 8218F7ACh case    1:*/		return 0x8218F7B0;
		  /* 8218F7B0h */ case    2:  		/* bc 12, CR0_EQ, 36 */
		/* 8218F7B0h case    2:*/		if ( regs.CR[0].eq ) { return 0x8218F7D4;  }
		/* 8218F7B0h case    2:*/		return 0x8218F7B4;
		  /* 8218F7B4h */ case    3:  		/* lwz R11, <#[R14 + 56]> */
		/* 8218F7B4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000038) );
		/* 8218F7B4h case    3:*/		return 0x8218F7B8;
		  /* 8218F7B8h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8218F7B8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218F7B8h case    4:*/		return 0x8218F7BC;
		  /* 8218F7BCh */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 8218F7BCh case    5:*/		if ( regs.CR[6].eq ) { return 0x8218F7CC;  }
		/* 8218F7BCh case    5:*/		return 0x8218F7C0;
		  /* 8218F7C0h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 8218F7C0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8218F7C0h case    6:*/		return 0x8218F7C4;
		  /* 8218F7C4h */ case    7:  		/* rlwinm. R11, R11, 0, 21, 21 */
		/* 8218F7C4h case    7:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R11,regs.R11);
		/* 8218F7C4h case    7:*/		return 0x8218F7C8;
		  /* 8218F7C8h */ case    8:  		/* bc 4, CR0_EQ, 12 */
		/* 8218F7C8h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8218F7D4;  }
		/* 8218F7C8h case    8:*/		return 0x8218F7CC;
	}
	return 0x8218F7CC;
} // Block from 8218F7A8h-8218F7CCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218F7CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F7CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F7CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F7CC);
		  /* 8218F7CCh */ case    0:  		/* li R11, 1 */
		/* 8218F7CCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218F7CCh case    0:*/		return 0x8218F7D0;
		  /* 8218F7D0h */ case    1:  		/* b 8 */
		/* 8218F7D0h case    1:*/		return 0x8218F7D8;
		/* 8218F7D0h case    1:*/		return 0x8218F7D4;
	}
	return 0x8218F7D4;
} // Block from 8218F7CCh-8218F7D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218F7D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F7D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F7D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F7D4);
		  /* 8218F7D4h */ case    0:  		/* mr R11, R17 */
		/* 8218F7D4h case    0:*/		regs.R11 = regs.R17;
		/* 8218F7D4h case    0:*/		return 0x8218F7D8;
	}
	return 0x8218F7D8;
} // Block from 8218F7D4h-8218F7D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218F7D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F7D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F7D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F7D8);
		  /* 8218F7D8h */ case    0:  		/* rlwinm. R9, R10, 0, 7, 7 */
		/* 8218F7D8h case    0:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R9,regs.R10);
		/* 8218F7D8h case    0:*/		return 0x8218F7DC;
		  /* 8218F7DCh */ case    1:  		/* rlwinm R10, R11, 0, 24, 31 */
		/* 8218F7DCh case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R11);
		/* 8218F7DCh case    1:*/		return 0x8218F7E0;
		  /* 8218F7E0h */ case    2:  		/* bc 12, CR0_EQ, 48 */
		/* 8218F7E0h case    2:*/		if ( regs.CR[0].eq ) { return 0x8218F810;  }
		/* 8218F7E0h case    2:*/		return 0x8218F7E4;
		  /* 8218F7E4h */ case    3:  		/* lwz R11, <#[R14 + 56]> */
		/* 8218F7E4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000038) );
		/* 8218F7E4h case    3:*/		return 0x8218F7E8;
		  /* 8218F7E8h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8218F7E8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218F7E8h case    4:*/		return 0x8218F7EC;
		  /* 8218F7ECh */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 8218F7ECh case    5:*/		if ( regs.CR[6].eq ) { return 0x8218F800;  }
		/* 8218F7ECh case    5:*/		return 0x8218F7F0;
		  /* 8218F7F0h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 8218F7F0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8218F7F0h case    6:*/		return 0x8218F7F4;
		  /* 8218F7F4h */ case    7:  		/* rlwinm. R11, R11, 0, 20, 20 */
		/* 8218F7F4h case    7:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R11);
		/* 8218F7F4h case    7:*/		return 0x8218F7F8;
		  /* 8218F7F8h */ case    8:  		/* li R11, 1 */
		/* 8218F7F8h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218F7F8h case    8:*/		return 0x8218F7FC;
		  /* 8218F7FCh */ case    9:  		/* bc 4, CR0_EQ, 8 */
		/* 8218F7FCh case    9:*/		if ( !regs.CR[0].eq ) { return 0x8218F804;  }
		/* 8218F7FCh case    9:*/		return 0x8218F800;
	}
	return 0x8218F800;
} // Block from 8218F7D8h-8218F800h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8218F800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F800);
		  /* 8218F800h */ case    0:  		/* mr R11, R17 */
		/* 8218F800h case    0:*/		regs.R11 = regs.R17;
		/* 8218F800h case    0:*/		return 0x8218F804;
	}
	return 0x8218F804;
} // Block from 8218F800h-8218F804h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218F804h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F804( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F804) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F804);
		  /* 8218F804h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8218F804h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8218F804h case    0:*/		return 0x8218F808;
		  /* 8218F808h */ case    1:  		/* li R11, 1 */
		/* 8218F808h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218F808h case    1:*/		return 0x8218F80C;
		  /* 8218F80Ch */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 8218F80Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8218F814;  }
		/* 8218F80Ch case    2:*/		return 0x8218F810;
	}
	return 0x8218F810;
} // Block from 8218F804h-8218F810h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218F810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F810);
		  /* 8218F810h */ case    0:  		/* mr R11, R17 */
		/* 8218F810h case    0:*/		regs.R11 = regs.R17;
		/* 8218F810h case    0:*/		return 0x8218F814;
	}
	return 0x8218F814;
} // Block from 8218F810h-8218F814h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218F814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F814);
		  /* 8218F814h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 8218F814h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 8218F814h case    0:*/		return 0x8218F818;
		  /* 8218F818h */ case    1:  		/* rlwinm R31, R11, 0, 24, 31 */
		/* 8218F818h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R31,regs.R11);
		/* 8218F818h case    1:*/		return 0x8218F81C;
		  /* 8218F81Ch */ case    2:  		/* bc 4, CR0_EQ, 12 */
		/* 8218F81Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x8218F828;  }
		/* 8218F81Ch case    2:*/		return 0x8218F820;
		  /* 8218F820h */ case    3:  		/* rlwinm. R11, R31, 0, 24, 31 */
		/* 8218F820h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R31);
		/* 8218F820h case    3:*/		return 0x8218F824;
		  /* 8218F824h */ case    4:  		/* bc 12, CR0_EQ, 144 */
		/* 8218F824h case    4:*/		if ( regs.CR[0].eq ) { return 0x8218F8B4;  }
		/* 8218F824h case    4:*/		return 0x8218F828;
	}
	return 0x8218F828;
} // Block from 8218F814h-8218F828h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218F828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F828);
		  /* 8218F828h */ case    0:  		/* li R5, 0 */
		/* 8218F828h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8218F828h case    0:*/		return 0x8218F82C;
		  /* 8218F82Ch */ case    1:  		/* li R4, 3 */
		/* 8218F82Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8218F82Ch case    1:*/		return 0x8218F830;
		  /* 8218F830h */ case    2:  		/* addi R3, R1, 320 */
		/* 8218F830h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x140);
		/* 8218F830h case    2:*/		return 0x8218F834;
		  /* 8218F834h */ case    3:  		/* bl -14276 */
		/* 8218F834h case    3:*/		regs.LR = 0x8218F838; return 0x8218C070;
		/* 8218F834h case    3:*/		return 0x8218F838;
		  /* 8218F838h */ case    4:  		/* cmpwi CR6, R3, -1 */
		/* 8218F838h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218F838h case    4:*/		return 0x8218F83C;
		  /* 8218F83Ch */ case    5:  		/* bc 12, CR6_EQ, 108 */
		/* 8218F83Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x8218F8A8;  }
		/* 8218F83Ch case    5:*/		return 0x8218F840;
		  /* 8218F840h */ case    6:  		/* li R5, 0 */
		/* 8218F840h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8218F840h case    6:*/		return 0x8218F844;
		  /* 8218F844h */ case    7:  		/* li R4, 4 */
		/* 8218F844h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 8218F844h case    7:*/		return 0x8218F848;
		  /* 8218F848h */ case    8:  		/* addi R3, R1, 320 */
		/* 8218F848h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x140);
		/* 8218F848h case    8:*/		return 0x8218F84C;
		  /* 8218F84Ch */ case    9:  		/* bl -14300 */
		/* 8218F84Ch case    9:*/		regs.LR = 0x8218F850; return 0x8218C070;
		/* 8218F84Ch case    9:*/		return 0x8218F850;
		  /* 8218F850h */ case   10:  		/* cmpwi CR6, R3, -1 */
		/* 8218F850h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218F850h case   10:*/		return 0x8218F854;
		  /* 8218F854h */ case   11:  		/* bc 12, CR6_EQ, 84 */
		/* 8218F854h case   11:*/		if ( regs.CR[6].eq ) { return 0x8218F8A8;  }
		/* 8218F854h case   11:*/		return 0x8218F858;
		  /* 8218F858h */ case   12:  		/* rlwinm. R11, R31, 0, 24, 31 */
		/* 8218F858h case   12:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R31);
		/* 8218F858h case   12:*/		return 0x8218F85C;
		  /* 8218F85Ch */ case   13:  		/* bc 12, CR0_EQ, 88 */
		/* 8218F85Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x8218F8B4;  }
		/* 8218F85Ch case   13:*/		return 0x8218F860;
		  /* 8218F860h */ case   14:  		/* li R5, 0 */
		/* 8218F860h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8218F860h case   14:*/		return 0x8218F864;
		  /* 8218F864h */ case   15:  		/* li R4, 1 */
		/* 8218F864h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8218F864h case   15:*/		return 0x8218F868;
		  /* 8218F868h */ case   16:  		/* addi R3, R1, 88 */
		/* 8218F868h case   16:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 8218F868h case   16:*/		return 0x8218F86C;
		  /* 8218F86Ch */ case   17:  		/* bl -13724 */
		/* 8218F86Ch case   17:*/		regs.LR = 0x8218F870; return 0x8218C2D0;
		/* 8218F86Ch case   17:*/		return 0x8218F870;
		  /* 8218F870h */ case   18:  		/* cmpwi CR6, R3, -1 */
		/* 8218F870h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218F870h case   18:*/		return 0x8218F874;
		  /* 8218F874h */ case   19:  		/* bc 4, CR6_EQ, 16 */
		/* 8218F874h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8218F884;  }
		/* 8218F874h case   19:*/		return 0x8218F878;
		  /* 8218F878h */ case   20:  		/* li R4, 3645 */
		/* 8218F878h case   20:*/		cpu::op::li<0>(regs,&regs.R4,0xE3D);
		/* 8218F878h case   20:*/		return 0x8218F87C;
		  /* 8218F87Ch */ case   21:  		/* mr R3, R14 */
		/* 8218F87Ch case   21:*/		regs.R3 = regs.R14;
		/* 8218F87Ch case   21:*/		return 0x8218F880;
		  /* 8218F880h */ case   22:  		/* bl -252440 */
		/* 8218F880h case   22:*/		regs.LR = 0x8218F884; return 0x82151E68;
		/* 8218F880h case   22:*/		return 0x8218F884;
	}
	return 0x8218F884;
} // Block from 8218F828h-8218F884h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8218F884h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F884( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F884) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F884);
		  /* 8218F884h */ case    0:  		/* li R5, 0 */
		/* 8218F884h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8218F884h case    0:*/		return 0x8218F888;
		  /* 8218F888h */ case    1:  		/* li R4, 1 */
		/* 8218F888h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8218F888h case    1:*/		return 0x8218F88C;
		  /* 8218F88Ch */ case    2:  		/* addi R3, R1, 128 */
		/* 8218F88Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 8218F88Ch case    2:*/		return 0x8218F890;
		  /* 8218F890h */ case    3:  		/* bl -13376 */
		/* 8218F890h case    3:*/		regs.LR = 0x8218F894; return 0x8218C450;
		/* 8218F890h case    3:*/		return 0x8218F894;
		  /* 8218F894h */ case    4:  		/* cmpwi CR6, R3, -1 */
		/* 8218F894h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8218F894h case    4:*/		return 0x8218F898;
		  /* 8218F898h */ case    5:  		/* bc 4, CR6_EQ, 28 */
		/* 8218F898h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8218F8B4;  }
		/* 8218F898h case    5:*/		return 0x8218F89C;
		  /* 8218F89Ch */ case    6:  		/* li R4, 3646 */
		/* 8218F89Ch case    6:*/		cpu::op::li<0>(regs,&regs.R4,0xE3E);
		/* 8218F89Ch case    6:*/		return 0x8218F8A0;
		  /* 8218F8A0h */ case    7:  		/* mr R3, R14 */
		/* 8218F8A0h case    7:*/		regs.R3 = regs.R14;
		/* 8218F8A0h case    7:*/		return 0x8218F8A4;
		  /* 8218F8A4h */ case    8:  		/* bl -252476 */
		/* 8218F8A4h case    8:*/		regs.LR = 0x8218F8A8; return 0x82151E68;
		/* 8218F8A4h case    8:*/		return 0x8218F8A8;
	}
	return 0x8218F8A8;
} // Block from 8218F884h-8218F8A8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218F8A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F8A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F8A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F8A8);
		  /* 8218F8A8h */ case    0:  		/* li R4, 3644 */
		/* 8218F8A8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xE3C);
		/* 8218F8A8h case    0:*/		return 0x8218F8AC;
		  /* 8218F8ACh */ case    1:  		/* mr R3, R14 */
		/* 8218F8ACh case    1:*/		regs.R3 = regs.R14;
		/* 8218F8ACh case    1:*/		return 0x8218F8B0;
		  /* 8218F8B0h */ case    2:  		/* bl -252488 */
		/* 8218F8B0h case    2:*/		regs.LR = 0x8218F8B4; return 0x82151E68;
		/* 8218F8B0h case    2:*/		return 0x8218F8B4;
	}
	return 0x8218F8B4;
} // Block from 8218F8A8h-8218F8B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218F8B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F8B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F8B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F8B4);
		  /* 8218F8B4h */ case    0:  		/* addi R1, R1, 608 */
		/* 8218F8B4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x260);
		/* 8218F8B4h case    0:*/		return 0x8218F8B8;
		  /* 8218F8B8h */ case    1:  		/* b -1041992 */
		/* 8218F8B8h case    1:*/		return 0x82091270;
		/* 8218F8B8h case    1:*/		return 0x8218F8BC;
		  /* 8218F8BCh */ case    2:  		/* nop */
		/* 8218F8BCh case    2:*/		cpu::op::nop();
		/* 8218F8BCh case    2:*/		return 0x8218F8C0;
	}
	return 0x8218F8C0;
} // Block from 8218F8B4h-8218F8C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218F8C0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F8C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F8C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F8C0);
		  /* 8218F8C0h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 8218F8C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8218F8C0h case    0:*/		return 0x8218F8C4;
		  /* 8218F8C4h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8218F8C4h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8218F8C4h case    1:*/		return 0x8218F8C8;
		  /* 8218F8C8h */ case    2:  		/* cmplwi CR6, R11, 1 */
		/* 8218F8C8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8218F8C8h case    2:*/		return 0x8218F8CC;
		  /* 8218F8CCh */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 8218F8CCh case    3:*/		if ( regs.CR[6].lt ) { return 0x8218F8DC;  }
		/* 8218F8CCh case    3:*/		return 0x8218F8D0;
		  /* 8218F8D0h */ case    4:  		/* cmplwi CR6, R11, 82 */
		/* 8218F8D0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 8218F8D0h case    4:*/		return 0x8218F8D4;
		  /* 8218F8D4h */ case    5:  		/* li R11, 1 */
		/* 8218F8D4h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218F8D4h case    5:*/		return 0x8218F8D8;
		  /* 8218F8D8h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 8218F8D8h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8218F8E0;  }
		/* 8218F8D8h case    6:*/		return 0x8218F8DC;
	}
	return 0x8218F8DC;
} // Block from 8218F8C0h-8218F8DCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218F8DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F8DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F8DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F8DC);
		  /* 8218F8DCh */ case    0:  		/* li R11, 0 */
		/* 8218F8DCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218F8DCh case    0:*/		return 0x8218F8E0;
	}
	return 0x8218F8E0;
} // Block from 8218F8DCh-8218F8E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218F8E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F8E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F8E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F8E0);
		  /* 8218F8E0h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 8218F8E0h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8218F8E0h case    0:*/		return 0x8218F8E4;
		  /* 8218F8E4h */ case    1:  		/* addic R10, R11, -1 */
		/* 8218F8E4h case    1:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 8218F8E4h case    1:*/		return 0x8218F8E8;
		  /* 8218F8E8h */ case    2:  		/* subfe R3, R10, R11 */
		/* 8218F8E8h case    2:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8218F8E8h case    2:*/		return 0x8218F8EC;
		  /* 8218F8ECh */ case    3:  		/* bclr 20, CR0_LT */
		/* 8218F8ECh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218F8ECh case    3:*/		return 0x8218F8F0;
	}
	return 0x8218F8F0;
} // Block from 8218F8E0h-8218F8F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218F8F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F8F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F8F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F8F0);
		  /* 8218F8F0h */ case    0:  		/* mfspr R12, LR */
		/* 8218F8F0h case    0:*/		regs.R12 = regs.LR;
		/* 8218F8F0h case    0:*/		return 0x8218F8F4;
		  /* 8218F8F4h */ case    1:  		/* bl -1042080 */
		/* 8218F8F4h case    1:*/		regs.LR = 0x8218F8F8; return 0x82091254;
		/* 8218F8F4h case    1:*/		return 0x8218F8F8;
		  /* 8218F8F8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8218F8F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8218F8F8h case    2:*/		return 0x8218F8FC;
		  /* 8218F8FCh */ case    3:  		/* lwz R7, <#[R3 + 4]> */
		/* 8218F8FCh case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000004) );
		/* 8218F8FCh case    3:*/		return 0x8218F900;
		  /* 8218F900h */ case    4:  		/* mr R29, R3 */
		/* 8218F900h case    4:*/		regs.R29 = regs.R3;
		/* 8218F900h case    4:*/		return 0x8218F904;
		  /* 8218F904h */ case    5:  		/* mr R28, R4 */
		/* 8218F904h case    5:*/		regs.R28 = regs.R4;
		/* 8218F904h case    5:*/		return 0x8218F908;
		  /* 8218F908h */ case    6:  		/* mr R27, R5 */
		/* 8218F908h case    6:*/		regs.R27 = regs.R5;
		/* 8218F908h case    6:*/		return 0x8218F90C;
		  /* 8218F90Ch */ case    7:  		/* li R3, 0 */
		/* 8218F90Ch case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8218F90Ch case    7:*/		return 0x8218F910;
		  /* 8218F910h */ case    8:  		/* cmplwi CR6, R7, 0 */
		/* 8218F910h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8218F910h case    8:*/		return 0x8218F914;
		  /* 8218F914h */ case    9:  		/* bc 12, CR6_EQ, 176 */
		/* 8218F914h case    9:*/		if ( regs.CR[6].eq ) { return 0x8218F9C4;  }
		/* 8218F914h case    9:*/		return 0x8218F918;
		  /* 8218F918h */ case   10:  		/* lwz R9, <#[R7 + 16]> */
		/* 8218F918h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000010) );
		/* 8218F918h case   10:*/		return 0x8218F91C;
		  /* 8218F91Ch */ case   11:  		/* cmplwi CR6, R9, 0 */
		/* 8218F91Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8218F91Ch case   11:*/		return 0x8218F920;
		  /* 8218F920h */ case   12:  		/* bc 12, CR6_EQ, 156 */
		/* 8218F920h case   12:*/		if ( regs.CR[6].eq ) { return 0x8218F9BC;  }
		/* 8218F920h case   12:*/		return 0x8218F924;
		  /* 8218F924h */ case   13:  		/* lwz R11, <#[R7]> */
		/* 8218F924h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 8218F924h case   13:*/		return 0x8218F928;
		  /* 8218F928h */ case   14:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 8218F928h case   14:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 8218F928h case   14:*/		return 0x8218F92C;
		  /* 8218F92Ch */ case   15:  		/* bc 12, CR0_EQ, 144 */
		/* 8218F92Ch case   15:*/		if ( regs.CR[0].eq ) { return 0x8218F9BC;  }
		/* 8218F92Ch case   15:*/		return 0x8218F930;
		  /* 8218F930h */ case   16:  		/* lwz R8, <#[R9 + 8]> */
		/* 8218F930h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000008) );
		/* 8218F930h case   16:*/		return 0x8218F934;
		  /* 8218F934h */ case   17:  		/* rlwinm R10, R8, 25, 25, 31 */
		/* 8218F934h case   17:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R8);
		/* 8218F934h case   17:*/		return 0x8218F938;
		  /* 8218F938h */ case   18:  		/* cmplwi CR6, R10, 32 */
		/* 8218F938h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000020);
		/* 8218F938h case   18:*/		return 0x8218F93C;
		  /* 8218F93Ch */ case   19:  		/* bc 12, CR6_LT, 16 */
		/* 8218F93Ch case   19:*/		if ( regs.CR[6].lt ) { return 0x8218F94C;  }
		/* 8218F93Ch case   19:*/		return 0x8218F940;
		  /* 8218F940h */ case   20:  		/* cmplwi CR6, R10, 82 */
		/* 8218F940h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000052);
		/* 8218F940h case   20:*/		return 0x8218F944;
		  /* 8218F944h */ case   21:  		/* li R11, 1 */
		/* 8218F944h case   21:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218F944h case   21:*/		return 0x8218F948;
		  /* 8218F948h */ case   22:  		/* bc 4, CR6_GT, 8 */
		/* 8218F948h case   22:*/		if ( !regs.CR[6].gt ) { return 0x8218F950;  }
		/* 8218F948h case   22:*/		return 0x8218F94C;
	}
	return 0x8218F94C;
} // Block from 8218F8F0h-8218F94Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 8218F94Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F94C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F94C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F94C);
		  /* 8218F94Ch */ case    0:  		/* li R11, 0 */
		/* 8218F94Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218F94Ch case    0:*/		return 0x8218F950;
	}
	return 0x8218F950;
} // Block from 8218F94Ch-8218F950h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218F950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F950);
		  /* 8218F950h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8218F950h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8218F950h case    0:*/		return 0x8218F954;
		  /* 8218F954h */ case    1:  		/* bc 12, CR0_EQ, 92 */
		/* 8218F954h case    1:*/		if ( regs.CR[0].eq ) { return 0x8218F9B0;  }
		/* 8218F954h case    1:*/		return 0x8218F958;
		  /* 8218F958h */ case    2:  		/* rlwinm R11, R8, 0, 10, 12 */
		/* 8218F958h case    2:*/		cpu::op::rlwinm<0,0,10,12>(regs,&regs.R11,regs.R8);
		/* 8218F958h case    2:*/		return 0x8218F95C;
		  /* 8218F95Ch */ case    3:  		/* lis R8, 16 */
		/* 8218F95Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R8,0x10);
		/* 8218F95Ch case    3:*/		return 0x8218F960;
		  /* 8218F960h */ case    4:  		/* cmplw CR6, R11, R8 */
		/* 8218F960h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8218F960h case    4:*/		return 0x8218F964;
		  /* 8218F964h */ case    5:  		/* bc 4, CR6_EQ, 76 */
		/* 8218F964h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8218F9B0;  }
		/* 8218F964h case    5:*/		return 0x8218F968;
		  /* 8218F968h */ case    6:  		/* lwz R11, <#[R9 + 44]> */
		/* 8218F968h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000002C) );
		/* 8218F968h case    6:*/		return 0x8218F96C;
		  /* 8218F96Ch */ case    7:  		/* lwz R10, <#[R11 + 12]> */
		/* 8218F96Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8218F96Ch case    7:*/		return 0x8218F970;
		  /* 8218F970h */ case    8:  		/* lwz R10, <#[R10 + 8]> */
		/* 8218F970h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8218F970h case    8:*/		return 0x8218F974;
		  /* 8218F974h */ case    9:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 8218F974h case    9:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 8218F974h case    9:*/		return 0x8218F978;
		  /* 8218F978h */ case   10:  		/* cmplwi CR6, R10, 15872 */
		/* 8218F978h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003E00);
		/* 8218F978h case   10:*/		return 0x8218F97C;
		  /* 8218F97Ch */ case   11:  		/* bc 4, CR6_EQ, 36 */
		/* 8218F97Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x8218F9A0;  }
		/* 8218F97Ch case   11:*/		return 0x8218F980;
		  /* 8218F980h */ case   12:  		/* lwz R11, <#[R11]> */
		/* 8218F980h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8218F980h case   12:*/		return 0x8218F984;
		  /* 8218F984h */ case   13:  		/* li R10, 1 */
		/* 8218F984h case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8218F984h case   13:*/		return 0x8218F988;
		  /* 8218F988h */ case   14:  		/* lwz R9, <#[R28]> */
		/* 8218F988h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000000) );
		/* 8218F988h case   14:*/		return 0x8218F98C;
		  /* 8218F98Ch */ case   15:  		/* rlwinm R11, R11, 27, 30, 31 */
		/* 8218F98Ch case   15:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R11,regs.R11);
		/* 8218F98Ch case   15:*/		return 0x8218F990;
		  /* 8218F990h */ case   16:  		/* slw R11, R10, R11 */
		/* 8218F990h case   16:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218F990h case   16:*/		return 0x8218F994;
		  /* 8218F994h */ case   17:  		/* or R11, R11, R9 */
		/* 8218F994h case   17:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8218F994h case   17:*/		return 0x8218F998;
		  /* 8218F998h */ case   18:  		/* stw R11, <#[R28]> */
		/* 8218F998h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8218F998h case   18:*/		return 0x8218F99C;
		  /* 8218F99Ch */ case   19:  		/* b 32 */
		/* 8218F99Ch case   19:*/		return 0x8218F9BC;
		/* 8218F99Ch case   19:*/		return 0x8218F9A0;
	}
	return 0x8218F9A0;
} // Block from 8218F950h-8218F9A0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8218F9A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F9A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F9A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F9A0);
		  /* 8218F9A0h */ case    0:  		/* lwz R11, <#[R27]> */
		/* 8218F9A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8218F9A0h case    0:*/		return 0x8218F9A4;
		  /* 8218F9A4h */ case    1:  		/* addi R11, R11, 1 */
		/* 8218F9A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8218F9A4h case    1:*/		return 0x8218F9A8;
		  /* 8218F9A8h */ case    2:  		/* stw R11, <#[R27]> */
		/* 8218F9A8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8218F9A8h case    2:*/		return 0x8218F9AC;
		  /* 8218F9ACh */ case    3:  		/* b 16 */
		/* 8218F9ACh case    3:*/		return 0x8218F9BC;
		/* 8218F9ACh case    3:*/		return 0x8218F9B0;
	}
	return 0x8218F9B0;
} // Block from 8218F9A0h-8218F9B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218F9B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F9B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F9B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F9B0);
		  /* 8218F9B0h */ case    0:  		/* cmplwi CR6, R10, 110 */
		/* 8218F9B0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000006E);
		/* 8218F9B0h case    0:*/		return 0x8218F9B4;
		  /* 8218F9B4h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 8218F9B4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8218F9BC;  }
		/* 8218F9B4h case    1:*/		return 0x8218F9B8;
		  /* 8218F9B8h */ case    2:  		/* mr R3, R9 */
		/* 8218F9B8h case    2:*/		regs.R3 = regs.R9;
		/* 8218F9B8h case    2:*/		return 0x8218F9BC;
	}
	return 0x8218F9BC;
} // Block from 8218F9B0h-8218F9BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218F9BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F9BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F9BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F9BC);
		  /* 8218F9BCh */ case    0:  		/* lwz R7, <#[R7 + 8]> */
		/* 8218F9BCh case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000008) );
		/* 8218F9BCh case    0:*/		return 0x8218F9C0;
		  /* 8218F9C0h */ case    1:  		/* b -176 */
		/* 8218F9C0h case    1:*/		return 0x8218F910;
		/* 8218F9C0h case    1:*/		return 0x8218F9C4;
	}
	return 0x8218F9C4;
} // Block from 8218F9BCh-8218F9C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218F9C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218F9C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218F9C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218F9C4);
		  /* 8218F9C4h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 8218F9C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8218F9C4h case    0:*/		return 0x8218F9C8;
		  /* 8218F9C8h */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8218F9C8h case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8218F9C8h case    1:*/		return 0x8218F9CC;
		  /* 8218F9CCh */ case    2:  		/* cmplwi CR6, R11, 14080 */
		/* 8218F9CCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 8218F9CCh case    2:*/		return 0x8218F9D0;
		  /* 8218F9D0h */ case    3:  		/* bc 4, CR6_EQ, 60 */
		/* 8218F9D0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8218FA0C;  }
		/* 8218F9D0h case    3:*/		return 0x8218F9D4;
		  /* 8218F9D4h */ case    4:  		/* li R31, 0 */
		/* 8218F9D4h case    4:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8218F9D4h case    4:*/		return 0x8218F9D8;
		  /* 8218F9D8h */ case    5:  		/* addi R30, R29, 40 */
		/* 8218F9D8h case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R29,0x28);
		/* 8218F9D8h case    5:*/		return 0x8218F9DC;
		  /* 8218F9DCh */ case    6:  		/* lwz R11, <#[R29 + 8]> */
		/* 8218F9DCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8218F9DCh case    6:*/		return 0x8218F9E0;
		  /* 8218F9E0h */ case    7:  		/* rlwinm R11, R11, 13, 29, 31 */
		/* 8218F9E0h case    7:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R11,regs.R11);
		/* 8218F9E0h case    7:*/		return 0x8218F9E4;
		  /* 8218F9E4h */ case    8:  		/* cmplw CR6, R31, R11 */
		/* 8218F9E4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8218F9E4h case    8:*/		return 0x8218F9E8;
		  /* 8218F9E8h */ case    9:  		/* bc 4, CR6_LT, 32 */
		/* 8218F9E8h case    9:*/		if ( !regs.CR[6].lt ) { return 0x8218FA08;  }
		/* 8218F9E8h case    9:*/		return 0x8218F9EC;
		  /* 8218F9ECh */ case   10:  		/* lwzu R11, <#[R30 + 4]> */
		/* 8218F9ECh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8218F9ECh case   10:*/		return 0x8218F9F0;
		  /* 8218F9F0h */ case   11:  		/* mr R5, R27 */
		/* 8218F9F0h case   11:*/		regs.R5 = regs.R27;
		/* 8218F9F0h case   11:*/		return 0x8218F9F4;
		  /* 8218F9F4h */ case   12:  		/* mr R4, R28 */
		/* 8218F9F4h case   12:*/		regs.R4 = regs.R28;
		/* 8218F9F4h case   12:*/		return 0x8218F9F8;
		  /* 8218F9F8h */ case   13:  		/* lwz R3, <#[R11 + 12]> */
		/* 8218F9F8h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x0000000C) );
		/* 8218F9F8h case   13:*/		return 0x8218F9FC;
		  /* 8218F9FCh */ case   14:  		/* bl -268 */
		/* 8218F9FCh case   14:*/		regs.LR = 0x8218FA00; return 0x8218F8F0;
		/* 8218F9FCh case   14:*/		return 0x8218FA00;
		  /* 8218FA00h */ case   15:  		/* addi R31, R31, 1 */
		/* 8218FA00h case   15:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8218FA00h case   15:*/		return 0x8218FA04;
		  /* 8218FA04h */ case   16:  		/* b -40 */
		/* 8218FA04h case   16:*/		return 0x8218F9DC;
		/* 8218FA04h case   16:*/		return 0x8218FA08;
	}
	return 0x8218FA08;
} // Block from 8218F9C4h-8218FA08h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8218FA08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FA08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FA08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FA08);
		  /* 8218FA08h */ case    0:  		/* li R3, 0 */
		/* 8218FA08h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8218FA08h case    0:*/		return 0x8218FA0C;
	}
	return 0x8218FA0C;
} // Block from 8218FA08h-8218FA0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218FA0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FA0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FA0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FA0C);
		  /* 8218FA0Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 8218FA0Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8218FA0Ch case    0:*/		return 0x8218FA10;
		  /* 8218FA10h */ case    1:  		/* b -1042284 */
		/* 8218FA10h case    1:*/		return 0x820912A4;
		/* 8218FA10h case    1:*/		return 0x8218FA14;
		  /* 8218FA14h */ case    2:  		/* nop */
		/* 8218FA14h case    2:*/		cpu::op::nop();
		/* 8218FA14h case    2:*/		return 0x8218FA18;
	}
	return 0x8218FA18;
} // Block from 8218FA0Ch-8218FA18h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218FA18h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FA18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FA18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FA18);
		  /* 8218FA18h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 8218FA18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8218FA18h case    0:*/		return 0x8218FA1C;
		  /* 8218FA1Ch */ case    1:  		/* li R9, 0 */
		/* 8218FA1Ch case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8218FA1Ch case    1:*/		return 0x8218FA20;
		  /* 8218FA20h */ case    2:  		/* rlwinm. R7, R11, 13, 29, 31 */
		/* 8218FA20h case    2:*/		cpu::op::rlwinm<1,13,29,31>(regs,&regs.R7,regs.R11);
		/* 8218FA20h case    2:*/		return 0x8218FA24;
		  /* 8218FA24h */ case    3:  		/* bc 12, CR0_EQ, 84 */
		/* 8218FA24h case    3:*/		if ( regs.CR[0].eq ) { return 0x8218FA78;  }
		/* 8218FA24h case    3:*/		return 0x8218FA28;
		  /* 8218FA28h */ case    4:  		/* addi R10, R3, 44 */
		/* 8218FA28h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0x2C);
		/* 8218FA28h case    4:*/		return 0x8218FA2C;
		  /* 8218FA2Ch */ case    5:  		/* lwz R8, <#[R10]> */
		/* 8218FA2Ch case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8218FA2Ch case    5:*/		return 0x8218FA30;
		  /* 8218FA30h */ case    6:  		/* lwz R11, <#[R8 + 12]> */
		/* 8218FA30h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x0000000C) );
		/* 8218FA30h case    6:*/		return 0x8218FA34;
		  /* 8218FA34h */ case    7:  		/* lwz R11, <#[R11 + 8]> */
		/* 8218FA34h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8218FA34h case    7:*/		return 0x8218FA38;
		  /* 8218FA38h */ case    8:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8218FA38h case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8218FA38h case    8:*/		return 0x8218FA3C;
		  /* 8218FA3Ch */ case    9:  		/* cmplwi CR6, R11, 125 */
		/* 8218FA3Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 8218FA3Ch case    9:*/		return 0x8218FA40;
		  /* 8218FA40h */ case   10:  		/* bc 12, CR6_EQ, 16 */
		/* 8218FA40h case   10:*/		if ( regs.CR[6].eq ) { return 0x8218FA50;  }
		/* 8218FA40h case   10:*/		return 0x8218FA44;
		  /* 8218FA44h */ case   11:  		/* cmplwi CR6, R11, 124 */
		/* 8218FA44h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 8218FA44h case   11:*/		return 0x8218FA48;
		  /* 8218FA48h */ case   12:  		/* li R11, 0 */
		/* 8218FA48h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218FA48h case   12:*/		return 0x8218FA4C;
		  /* 8218FA4Ch */ case   13:  		/* bc 4, CR6_EQ, 8 */
		/* 8218FA4Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x8218FA54;  }
		/* 8218FA4Ch case   13:*/		return 0x8218FA50;
	}
	return 0x8218FA50;
} // Block from 8218FA18h-8218FA50h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8218FA50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FA50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FA50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FA50);
		  /* 8218FA50h */ case    0:  		/* li R11, 1 */
		/* 8218FA50h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218FA50h case    0:*/		return 0x8218FA54;
	}
	return 0x8218FA54;
} // Block from 8218FA50h-8218FA54h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218FA54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FA54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FA54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FA54);
		  /* 8218FA54h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8218FA54h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8218FA54h case    0:*/		return 0x8218FA58;
		  /* 8218FA58h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8218FA58h case    1:*/		if ( regs.CR[0].eq ) { return 0x8218FA68;  }
		/* 8218FA58h case    1:*/		return 0x8218FA5C;
		  /* 8218FA5Ch */ case    2:  		/* lwz R11, <#[R8]> */
		/* 8218FA5Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8218FA5Ch case    2:*/		return 0x8218FA60;
		  /* 8218FA60h */ case    3:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 8218FA60h case    3:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 8218FA60h case    3:*/		return 0x8218FA64;
		  /* 8218FA64h */ case    4:  		/* bc 4, CR0_EQ, 28 */
		/* 8218FA64h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8218FA80;  }
		/* 8218FA64h case    4:*/		return 0x8218FA68;
	}
	return 0x8218FA68;
} // Block from 8218FA54h-8218FA68h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218FA68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FA68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FA68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FA68);
		  /* 8218FA68h */ case    0:  		/* addi R9, R9, 1 */
		/* 8218FA68h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8218FA68h case    0:*/		return 0x8218FA6C;
		  /* 8218FA6Ch */ case    1:  		/* addi R10, R10, 4 */
		/* 8218FA6Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8218FA6Ch case    1:*/		return 0x8218FA70;
		  /* 8218FA70h */ case    2:  		/* cmplw CR6, R9, R7 */
		/* 8218FA70h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 8218FA70h case    2:*/		return 0x8218FA74;
		  /* 8218FA74h */ case    3:  		/* bc 12, CR6_LT, -72 */
		/* 8218FA74h case    3:*/		if ( regs.CR[6].lt ) { return 0x8218FA2C;  }
		/* 8218FA74h case    3:*/		return 0x8218FA78;
	}
	return 0x8218FA78;
} // Block from 8218FA68h-8218FA78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218FA78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FA78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FA78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FA78);
		  /* 8218FA78h */ case    0:  		/* li R3, 0 */
		/* 8218FA78h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8218FA78h case    0:*/		return 0x8218FA7C;
		  /* 8218FA7Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8218FA7Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218FA7Ch case    1:*/		return 0x8218FA80;
	}
	return 0x8218FA80;
} // Block from 8218FA78h-8218FA80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218FA80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FA80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FA80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FA80);
		  /* 8218FA80h */ case    0:  		/* li R3, 1 */
		/* 8218FA80h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8218FA80h case    0:*/		return 0x8218FA84;
		  /* 8218FA84h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8218FA84h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218FA84h case    1:*/		return 0x8218FA88;
	}
	return 0x8218FA88;
} // Block from 8218FA80h-8218FA88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218FA88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FA88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FA88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FA88);
		  /* 8218FA88h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 8218FA88h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8218FA88h case    0:*/		return 0x8218FA8C;
		  /* 8218FA8Ch */ case    1:  		/* li R8, 0 */
		/* 8218FA8Ch case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8218FA8Ch case    1:*/		return 0x8218FA90;
		  /* 8218FA90h */ case    2:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8218FA90h case    2:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8218FA90h case    2:*/		return 0x8218FA94;
		  /* 8218FA94h */ case    3:  		/* cmplwi CR6, R11, 96 */
		/* 8218FA94h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000060);
		/* 8218FA94h case    3:*/		return 0x8218FA98;
		  /* 8218FA98h */ case    4:  		/* bc 12, CR6_LT, 16 */
		/* 8218FA98h case    4:*/		if ( regs.CR[6].lt ) { return 0x8218FAA8;  }
		/* 8218FA98h case    4:*/		return 0x8218FA9C;
		  /* 8218FA9Ch */ case    5:  		/* cmplwi CR6, R11, 102 */
		/* 8218FA9Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000066);
		/* 8218FA9Ch case    5:*/		return 0x8218FAA0;
		  /* 8218FAA0h */ case    6:  		/* li R11, 1 */
		/* 8218FAA0h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218FAA0h case    6:*/		return 0x8218FAA4;
		  /* 8218FAA4h */ case    7:  		/* bc 4, CR6_GT, 8 */
		/* 8218FAA4h case    7:*/		if ( !regs.CR[6].gt ) { return 0x8218FAAC;  }
		/* 8218FAA4h case    7:*/		return 0x8218FAA8;
	}
	return 0x8218FAA8;
} // Block from 8218FA88h-8218FAA8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218FAA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FAA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FAA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FAA8);
		  /* 8218FAA8h */ case    0:  		/* li R11, 0 */
		/* 8218FAA8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218FAA8h case    0:*/		return 0x8218FAAC;
	}
	return 0x8218FAAC;
} // Block from 8218FAA8h-8218FAACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218FAACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FAAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FAAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FAAC);
		  /* 8218FAACh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8218FAACh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8218FAACh case    0:*/		return 0x8218FAB0;
		  /* 8218FAB0h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 8218FAB0h case    1:*/		if ( regs.CR[0].eq ) { return 0x8218FAC8;  }
		/* 8218FAB0h case    1:*/		return 0x8218FAB4;
		  /* 8218FAB4h */ case    2:  		/* li R8, 1 */
		/* 8218FAB4h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8218FAB4h case    2:*/		return 0x8218FAB8;
		  /* 8218FAB8h */ case    3:  		/* lwz R11, <#[R3 + 20]> */
		/* 8218FAB8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 8218FAB8h case    3:*/		return 0x8218FABC;
		  /* 8218FABCh */ case    4:  		/* rlwimi R11, R8, 13, 6, 18 */
		/* 8218FABCh case    4:*/		cpu::op::rlwimi<0,13,6,18>(regs,&regs.R11,regs.R8);
		/* 8218FABCh case    4:*/		return 0x8218FAC0;
		  /* 8218FAC0h */ case    5:  		/* stw R11, <#[R3 + 20]> */
		/* 8218FAC0h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 8218FAC0h case    5:*/		return 0x8218FAC4;
		  /* 8218FAC4h */ case    6:  		/* bclr 20, CR0_LT */
		/* 8218FAC4h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218FAC4h case    6:*/		return 0x8218FAC8;
	}
	return 0x8218FAC8;
} // Block from 8218FAACh-8218FAC8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218FAC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FAC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FAC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FAC8);
		  /* 8218FAC8h */ case    0:  		/* lwz R9, <#[R3]> */
		/* 8218FAC8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 8218FAC8h case    0:*/		return 0x8218FACC;
		  /* 8218FACCh */ case    1:  		/* cmplwi CR6, R9, 0 */
		/* 8218FACCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8218FACCh case    1:*/		return 0x8218FAD0;
		  /* 8218FAD0h */ case    2:  		/* bc 12, CR6_EQ, -24 */
		/* 8218FAD0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8218FAB8;  }
		/* 8218FAD0h case    2:*/		return 0x8218FAD4;
		  /* 8218FAD4h */ case    3:  		/* lwz R10, <#[R9 + 12]> */
		/* 8218FAD4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x0000000C) );
		/* 8218FAD4h case    3:*/		return 0x8218FAD8;
		  /* 8218FAD8h */ case    4:  		/* lwz R11, <#[R10 + 8]> */
		/* 8218FAD8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8218FAD8h case    4:*/		return 0x8218FADC;
		  /* 8218FADCh */ case    5:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8218FADCh case    5:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8218FADCh case    5:*/		return 0x8218FAE0;
		  /* 8218FAE0h */ case    6:  		/* cmplwi CR6, R11, 96 */
		/* 8218FAE0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000060);
		/* 8218FAE0h case    6:*/		return 0x8218FAE4;
		  /* 8218FAE4h */ case    7:  		/* bc 12, CR6_LT, 16 */
		/* 8218FAE4h case    7:*/		if ( regs.CR[6].lt ) { return 0x8218FAF4;  }
		/* 8218FAE4h case    7:*/		return 0x8218FAE8;
		  /* 8218FAE8h */ case    8:  		/* cmplwi CR6, R11, 102 */
		/* 8218FAE8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000066);
		/* 8218FAE8h case    8:*/		return 0x8218FAEC;
		  /* 8218FAECh */ case    9:  		/* li R11, 1 */
		/* 8218FAECh case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218FAECh case    9:*/		return 0x8218FAF0;
		  /* 8218FAF0h */ case   10:  		/* bc 4, CR6_GT, 8 */
		/* 8218FAF0h case   10:*/		if ( !regs.CR[6].gt ) { return 0x8218FAF8;  }
		/* 8218FAF0h case   10:*/		return 0x8218FAF4;
	}
	return 0x8218FAF4;
} // Block from 8218FAC8h-8218FAF4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8218FAF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FAF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FAF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FAF4);
		  /* 8218FAF4h */ case    0:  		/* li R11, 0 */
		/* 8218FAF4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218FAF4h case    0:*/		return 0x8218FAF8;
	}
	return 0x8218FAF8;
} // Block from 8218FAF4h-8218FAF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218FAF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FAF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FAF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FAF8);
		  /* 8218FAF8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8218FAF8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8218FAF8h case    0:*/		return 0x8218FAFC;
		  /* 8218FAFCh */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8218FAFCh case    1:*/		if ( regs.CR[0].eq ) { return 0x8218FB08;  }
		/* 8218FAFCh case    1:*/		return 0x8218FB00;
		  /* 8218FB00h */ case    2:  		/* li R11, 1 */
		/* 8218FB00h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218FB00h case    2:*/		return 0x8218FB04;
		  /* 8218FB04h */ case    3:  		/* b 44 */
		/* 8218FB04h case    3:*/		return 0x8218FB30;
		/* 8218FB04h case    3:*/		return 0x8218FB08;
	}
	return 0x8218FB08;
} // Block from 8218FAF8h-8218FB08h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218FB08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FB08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FB08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FB08);
		  /* 8218FB08h */ case    0:  		/* lwz R11, <#[R9]> */
		/* 8218FB08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8218FB08h case    0:*/		return 0x8218FB0C;
		  /* 8218FB0Ch */ case    1:  		/* lwz R10, <#[R10 + 20]> */
		/* 8218FB0Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 8218FB0Ch case    1:*/		return 0x8218FB10;
		  /* 8218FB10h */ case    2:  		/* rlwinm R11, R11, 4, 30, 31 */
		/* 8218FB10h case    2:*/		cpu::op::rlwinm<0,4,30,31>(regs,&regs.R11,regs.R11);
		/* 8218FB10h case    2:*/		return 0x8218FB14;
		  /* 8218FB14h */ case    3:  		/* rlwinm R10, R10, 19, 19, 31 */
		/* 8218FB14h case    3:*/		cpu::op::rlwinm<0,19,19,31>(regs,&regs.R10,regs.R10);
		/* 8218FB14h case    3:*/		return 0x8218FB18;
		  /* 8218FB18h */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 8218FB18h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8218FB18h case    4:*/		return 0x8218FB1C;
		  /* 8218FB1Ch */ case    5:  		/* add R11, R10, R11 */
		/* 8218FB1Ch case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8218FB1Ch case    5:*/		return 0x8218FB20;
		  /* 8218FB20h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 8218FB20h case    6:*/		if ( regs.CR[6].eq ) { return 0x8218FB2C;  }
		/* 8218FB20h case    6:*/		return 0x8218FB24;
		  /* 8218FB24h */ case    7:  		/* cmplwi CR6, R11, 8191 */
		/* 8218FB24h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001FFF);
		/* 8218FB24h case    7:*/		return 0x8218FB28;
		  /* 8218FB28h */ case    8:  		/* bc 4, CR6_GT, 8 */
		/* 8218FB28h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8218FB30;  }
		/* 8218FB28h case    8:*/		return 0x8218FB2C;
	}
	return 0x8218FB2C;
} // Block from 8218FB08h-8218FB2Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218FB2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FB2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FB2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FB2C);
		  /* 8218FB2Ch */ case    0:  		/* li R11, 8191 */
		/* 8218FB2Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1FFF);
		/* 8218FB2Ch case    0:*/		return 0x8218FB30;
	}
	return 0x8218FB30;
} // Block from 8218FB2Ch-8218FB30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218FB30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FB30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FB30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FB30);
		  /* 8218FB30h */ case    0:  		/* cmplw CR6, R11, R8 */
		/* 8218FB30h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8218FB30h case    0:*/		return 0x8218FB34;
		  /* 8218FB34h */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 8218FB34h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8218FB3C;  }
		/* 8218FB34h case    1:*/		return 0x8218FB38;
		  /* 8218FB38h */ case    2:  		/* mr R8, R11 */
		/* 8218FB38h case    2:*/		regs.R8 = regs.R11;
		/* 8218FB38h case    2:*/		return 0x8218FB3C;
	}
	return 0x8218FB3C;
} // Block from 8218FB30h-8218FB3Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218FB3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FB3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FB3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FB3C);
		  /* 8218FB3Ch */ case    0:  		/* lwz R9, <#[R9 + 4]> */
		/* 8218FB3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 8218FB3Ch case    0:*/		return 0x8218FB40;
		  /* 8218FB40h */ case    1:  		/* b -116 */
		/* 8218FB40h case    1:*/		return 0x8218FACC;
		/* 8218FB40h case    1:*/		return 0x8218FB44;
		  /* 8218FB44h */ case    2:  		/* nop */
		/* 8218FB44h case    2:*/		cpu::op::nop();
		/* 8218FB44h case    2:*/		return 0x8218FB48;
	}
	return 0x8218FB48;
} // Block from 8218FB3Ch-8218FB48h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218FB48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FB48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FB48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FB48);
		  /* 8218FB48h */ case    0:  		/* mfspr R12, LR */
		/* 8218FB48h case    0:*/		regs.R12 = regs.LR;
		/* 8218FB48h case    0:*/		return 0x8218FB4C;
		  /* 8218FB4Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8218FB4Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8218FB4Ch case    1:*/		return 0x8218FB50;
		  /* 8218FB50h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8218FB50h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8218FB50h case    2:*/		return 0x8218FB54;
		  /* 8218FB54h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8218FB54h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8218FB54h case    3:*/		return 0x8218FB58;
		  /* 8218FB58h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8218FB58h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8218FB58h case    4:*/		return 0x8218FB5C;
		  /* 8218FB5Ch */ case    5:  		/* mr R31, R3 */
		/* 8218FB5Ch case    5:*/		regs.R31 = regs.R3;
		/* 8218FB5Ch case    5:*/		return 0x8218FB60;
		  /* 8218FB60h */ case    6:  		/* mr R30, R4 */
		/* 8218FB60h case    6:*/		regs.R30 = regs.R4;
		/* 8218FB60h case    6:*/		return 0x8218FB64;
		  /* 8218FB64h */ case    7:  		/* li R10, 0 */
		/* 8218FB64h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8218FB64h case    7:*/		return 0x8218FB68;
		  /* 8218FB68h */ case    8:  		/* addi R11, R3, 4 */
		/* 8218FB68h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x4);
		/* 8218FB68h case    8:*/		return 0x8218FB6C;
		  /* 8218FB6Ch */ case    9:  		/* lwz R9, <#[R11]> */
		/* 8218FB6Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8218FB6Ch case    9:*/		return 0x8218FB70;
		  /* 8218FB70h */ case   10:  		/* cmplw CR6, R30, R9 */
		/* 8218FB70h case   10:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R9);
		/* 8218FB70h case   10:*/		return 0x8218FB74;
		  /* 8218FB74h */ case   11:  		/* bc 4, CR6_EQ, 12 */
		/* 8218FB74h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8218FB80;  }
		/* 8218FB74h case   11:*/		return 0x8218FB78;
		  /* 8218FB78h */ case   12:  		/* li R9, 0 */
		/* 8218FB78h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8218FB78h case   12:*/		return 0x8218FB7C;
		  /* 8218FB7Ch */ case   13:  		/* stw R9, <#[R11]> */
		/* 8218FB7Ch case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8218FB7Ch case   13:*/		return 0x8218FB80;
	}
	return 0x8218FB80;
} // Block from 8218FB48h-8218FB80h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8218FB80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FB80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FB80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FB80);
		  /* 8218FB80h */ case    0:  		/* addi R10, R10, 1 */
		/* 8218FB80h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8218FB80h case    0:*/		return 0x8218FB84;
		  /* 8218FB84h */ case    1:  		/* addi R11, R11, 4 */
		/* 8218FB84h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8218FB84h case    1:*/		return 0x8218FB88;
		  /* 8218FB88h */ case    2:  		/* cmplwi CR6, R10, 9 */
		/* 8218FB88h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000009);
		/* 8218FB88h case    2:*/		return 0x8218FB8C;
		  /* 8218FB8Ch */ case    3:  		/* bc 12, CR6_LT, -32 */
		/* 8218FB8Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8218FB6C;  }
		/* 8218FB8Ch case    3:*/		return 0x8218FB90;
		  /* 8218FB90h */ case    4:  		/* mr R4, R30 */
		/* 8218FB90h case    4:*/		regs.R4 = regs.R30;
		/* 8218FB90h case    4:*/		return 0x8218FB94;
		  /* 8218FB94h */ case    5:  		/* mr R3, R31 */
		/* 8218FB94h case    5:*/		regs.R3 = regs.R31;
		/* 8218FB94h case    5:*/		return 0x8218FB98;
		  /* 8218FB98h */ case    6:  		/* bl -134296 */
		/* 8218FB98h case    6:*/		regs.LR = 0x8218FB9C; return 0x8216EF00;
		/* 8218FB98h case    6:*/		return 0x8218FB9C;
		  /* 8218FB9Ch */ case    7:  		/* li R5, 1 */
		/* 8218FB9Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8218FB9Ch case    7:*/		return 0x8218FBA0;
		  /* 8218FBA0h */ case    8:  		/* mr R4, R30 */
		/* 8218FBA0h case    8:*/		regs.R4 = regs.R30;
		/* 8218FBA0h case    8:*/		return 0x8218FBA4;
		  /* 8218FBA4h */ case    9:  		/* mr R3, R31 */
		/* 8218FBA4h case    9:*/		regs.R3 = regs.R31;
		/* 8218FBA4h case    9:*/		return 0x8218FBA8;
		  /* 8218FBA8h */ case   10:  		/* bl -126272 */
		/* 8218FBA8h case   10:*/		regs.LR = 0x8218FBAC; return 0x82170E68;
		/* 8218FBA8h case   10:*/		return 0x8218FBAC;
		  /* 8218FBACh */ case   11:  		/* addi R1, R1, 112 */
		/* 8218FBACh case   11:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8218FBACh case   11:*/		return 0x8218FBB0;
		  /* 8218FBB0h */ case   12:  		/* lwz R12, <#[R1 - 8]> */
		/* 8218FBB0h case   12:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8218FBB0h case   12:*/		return 0x8218FBB4;
		  /* 8218FBB4h */ case   13:  		/* mtspr LR, R12 */
		/* 8218FBB4h case   13:*/		regs.LR = regs.R12;
		/* 8218FBB4h case   13:*/		return 0x8218FBB8;
		  /* 8218FBB8h */ case   14:  		/* ld R30, <#[R1 - 24]> */
		/* 8218FBB8h case   14:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8218FBB8h case   14:*/		return 0x8218FBBC;
		  /* 8218FBBCh */ case   15:  		/* ld R31, <#[R1 - 16]> */
		/* 8218FBBCh case   15:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8218FBBCh case   15:*/		return 0x8218FBC0;
		  /* 8218FBC0h */ case   16:  		/* bclr 20, CR0_LT */
		/* 8218FBC0h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218FBC0h case   16:*/		return 0x8218FBC4;
	}
	return 0x8218FBC4;
} // Block from 8218FB80h-8218FBC4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8218FBC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FBC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FBC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FBC4);
		  /* 8218FBC4h */ case    0:  		/* nop */
		/* 8218FBC4h case    0:*/		cpu::op::nop();
		/* 8218FBC4h case    0:*/		return 0x8218FBC8;
	}
	return 0x8218FBC8;
} // Block from 8218FBC4h-8218FBC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218FBC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FBC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FBC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FBC8);
		  /* 8218FBC8h */ case    0:  		/* mfspr R12, LR */
		/* 8218FBC8h case    0:*/		regs.R12 = regs.LR;
		/* 8218FBC8h case    0:*/		return 0x8218FBCC;
		  /* 8218FBCCh */ case    1:  		/* bl -1042804 */
		/* 8218FBCCh case    1:*/		regs.LR = 0x8218FBD0; return 0x82091258;
		/* 8218FBCCh case    1:*/		return 0x8218FBD0;
		  /* 8218FBD0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8218FBD0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8218FBD0h case    2:*/		return 0x8218FBD4;
		  /* 8218FBD4h */ case    3:  		/* lwz R31, <#[R3]> */
		/* 8218FBD4h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 8218FBD4h case    3:*/		return 0x8218FBD8;
		  /* 8218FBD8h */ case    4:  		/* mr R30, R3 */
		/* 8218FBD8h case    4:*/		regs.R30 = regs.R3;
		/* 8218FBD8h case    4:*/		return 0x8218FBDC;
		  /* 8218FBDCh */ case    5:  		/* mr R28, R3 */
		/* 8218FBDCh case    5:*/		regs.R28 = regs.R3;
		/* 8218FBDCh case    5:*/		return 0x8218FBE0;
		  /* 8218FBE0h */ case    6:  		/* b 28 */
		/* 8218FBE0h case    6:*/		return 0x8218FBFC;
		/* 8218FBE0h case    6:*/		return 0x8218FBE4;
		  /* 8218FBE4h */ case    7:  		/* mr R3, R31 */
		/* 8218FBE4h case    7:*/		regs.R3 = regs.R31;
		/* 8218FBE4h case    7:*/		return 0x8218FBE8;
		  /* 8218FBE8h */ case    8:  		/* bl -179000 */
		/* 8218FBE8h case    8:*/		regs.LR = 0x8218FBEC; return 0x821640B0;
		/* 8218FBE8h case    8:*/		return 0x8218FBEC;
		  /* 8218FBECh */ case    9:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8218FBECh case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8218FBECh case    9:*/		return 0x8218FBF0;
		  /* 8218FBF0h */ case   10:  		/* bc 4, CR0_EQ, 24 */
		/* 8218FBF0h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8218FC08;  }
		/* 8218FBF0h case   10:*/		return 0x8218FBF4;
		  /* 8218FBF4h */ case   11:  		/* addi R28, R31, 32 */
		/* 8218FBF4h case   11:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x20);
		/* 8218FBF4h case   11:*/		return 0x8218FBF8;
		  /* 8218FBF8h */ case   12:  		/* lwz R31, <#[R31 + 32]> */
		/* 8218FBF8h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000020) );
		/* 8218FBF8h case   12:*/		return 0x8218FBFC;
	}
	return 0x8218FBFC;
} // Block from 8218FBC8h-8218FBFCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 8218FBFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FBFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FBFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FBFC);
		  /* 8218FBFCh */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 8218FBFCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8218FBFCh case    0:*/		return 0x8218FC00;
		  /* 8218FC00h */ case    1:  		/* bc 4, CR6_EQ, -28 */
		/* 8218FC00h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8218FBE4;  }
		/* 8218FC00h case    1:*/		return 0x8218FC04;
		  /* 8218FC04h */ case    2:  		/* b 60 */
		/* 8218FC04h case    2:*/		return 0x8218FC40;
		/* 8218FC04h case    2:*/		return 0x8218FC08;
	}
	return 0x8218FC08;
} // Block from 8218FBFCh-8218FC08h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8218FC08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FC08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FC08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FC08);
		  /* 8218FC08h */ case    0:  		/* addi R29, R30, 4 */
		/* 8218FC08h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R30,0x4);
		/* 8218FC08h case    0:*/		return 0x8218FC0C;
		  /* 8218FC0Ch */ case    1:  		/* mr R4, R31 */
		/* 8218FC0Ch case    1:*/		regs.R4 = regs.R31;
		/* 8218FC0Ch case    1:*/		return 0x8218FC10;
		  /* 8218FC10h */ case    2:  		/* mr R3, R29 */
		/* 8218FC10h case    2:*/		regs.R3 = regs.R29;
		/* 8218FC10h case    2:*/		return 0x8218FC14;
		  /* 8218FC14h */ case    3:  		/* bl -133820 */
		/* 8218FC14h case    3:*/		regs.LR = 0x8218FC18; return 0x8216F158;
		/* 8218FC14h case    3:*/		return 0x8218FC18;
		  /* 8218FC18h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8218FC18h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8218FC18h case    4:*/		return 0x8218FC1C;
		  /* 8218FC1Ch */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 8218FC1Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x8218FC2C;  }
		/* 8218FC1Ch case    5:*/		return 0x8218FC20;
		  /* 8218FC20h */ case    6:  		/* li R4, 4800 */
		/* 8218FC20h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8218FC20h case    6:*/		return 0x8218FC24;
		  /* 8218FC24h */ case    7:  		/* lwz R3, <#[R30 + 56]> */
		/* 8218FC24h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000038) );
		/* 8218FC24h case    7:*/		return 0x8218FC28;
		  /* 8218FC28h */ case    8:  		/* bl -253376 */
		/* 8218FC28h case    8:*/		regs.LR = 0x8218FC2C; return 0x82151E68;
		/* 8218FC28h case    8:*/		return 0x8218FC2C;
	}
	return 0x8218FC2C;
} // Block from 8218FC08h-8218FC2Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218FC2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FC2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FC2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FC2C);
		  /* 8218FC2Ch */ case    0:  		/* lwz R11, <#[R31 + 32]> */
		/* 8218FC2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8218FC2Ch case    0:*/		return 0x8218FC30;
		  /* 8218FC30h */ case    1:  		/* mr R4, R31 */
		/* 8218FC30h case    1:*/		regs.R4 = regs.R31;
		/* 8218FC30h case    1:*/		return 0x8218FC34;
		  /* 8218FC34h */ case    2:  		/* mr R3, R29 */
		/* 8218FC34h case    2:*/		regs.R3 = regs.R29;
		/* 8218FC34h case    2:*/		return 0x8218FC38;
		  /* 8218FC38h */ case    3:  		/* stw R11, <#[R28]> */
		/* 8218FC38h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8218FC38h case    3:*/		return 0x8218FC3C;
		  /* 8218FC3Ch */ case    4:  		/* bl -244 */
		/* 8218FC3Ch case    4:*/		regs.LR = 0x8218FC40; return 0x8218FB48;
		/* 8218FC3Ch case    4:*/		return 0x8218FC40;
	}
	return 0x8218FC40;
} // Block from 8218FC2Ch-8218FC40h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218FC40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FC40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FC40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FC40);
		  /* 8218FC40h */ case    0:  		/* mr R3, R31 */
		/* 8218FC40h case    0:*/		regs.R3 = regs.R31;
		/* 8218FC40h case    0:*/		return 0x8218FC44;
		  /* 8218FC44h */ case    1:  		/* addi R1, R1, 128 */
		/* 8218FC44h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8218FC44h case    1:*/		return 0x8218FC48;
		  /* 8218FC48h */ case    2:  		/* b -1042848 */
		/* 8218FC48h case    2:*/		return 0x820912A8;
		/* 8218FC48h case    2:*/		return 0x8218FC4C;
		  /* 8218FC4Ch */ case    3:  		/* nop */
		/* 8218FC4Ch case    3:*/		cpu::op::nop();
		/* 8218FC4Ch case    3:*/		return 0x8218FC50;
		  /* 8218FC50h */ case    4:  		/* addi R11, R4, 4 */
		/* 8218FC50h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x4);
		/* 8218FC50h case    4:*/		return 0x8218FC54;
		  /* 8218FC54h */ case    5:  		/* lwz R9, <#[R11]> */
		/* 8218FC54h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8218FC54h case    5:*/		return 0x8218FC58;
		  /* 8218FC58h */ case    6:  		/* cmplwi CR6, R9, 0 */
		/* 8218FC58h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8218FC58h case    6:*/		return 0x8218FC5C;
		  /* 8218FC5Ch */ case    7:  		/* bc 12, CR6_EQ, 104 */
		/* 8218FC5Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x8218FCC4;  }
		/* 8218FC5Ch case    7:*/		return 0x8218FC60;
		  /* 8218FC60h */ case    8:  		/* lwz R11, <#[R9 + 16]> */
		/* 8218FC60h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000010) );
		/* 8218FC60h case    8:*/		return 0x8218FC64;
		  /* 8218FC64h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 8218FC64h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218FC64h case    9:*/		return 0x8218FC68;
		  /* 8218FC68h */ case   10:  		/* bc 12, CR6_EQ, 84 */
		/* 8218FC68h case   10:*/		if ( regs.CR[6].eq ) { return 0x8218FCBC;  }
		/* 8218FC68h case   10:*/		return 0x8218FC6C;
		  /* 8218FC6Ch */ case   11:  		/* lbz R10, <#[R11 + 16]> */
		/* 8218FC6Ch case   11:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 8218FC6Ch case   11:*/		return 0x8218FC70;
		  /* 8218FC70h */ case   12:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 8218FC70h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 8218FC70h case   12:*/		return 0x8218FC74;
		  /* 8218FC74h */ case   13:  		/* bc 4, CR0_EQ, 72 */
		/* 8218FC74h case   13:*/		if ( !regs.CR[0].eq ) { return 0x8218FCBC;  }
		/* 8218FC74h case   13:*/		return 0x8218FC78;
		  /* 8218FC78h */ case   14:  		/* cmplw CR6, R11, R5 */
		/* 8218FC78h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 8218FC78h case   14:*/		return 0x8218FC7C;
		  /* 8218FC7Ch */ case   15:  		/* bc 12, CR6_EQ, 64 */
		/* 8218FC7Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x8218FCBC;  }
		/* 8218FC7Ch case   15:*/		return 0x8218FC80;
		  /* 8218FC80h */ case   16:  		/* lwz R10, <#[R11 + 28]> */
		/* 8218FC80h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000001C) );
		/* 8218FC80h case   16:*/		return 0x8218FC84;
		  /* 8218FC84h */ case   17:  		/* cmplwi CR6, R10, 0 */
		/* 8218FC84h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8218FC84h case   17:*/		return 0x8218FC88;
		  /* 8218FC88h */ case   18:  		/* bc 12, CR6_EQ, 40 */
		/* 8218FC88h case   18:*/		if ( regs.CR[6].eq ) { return 0x8218FCB0;  }
		/* 8218FC88h case   18:*/		return 0x8218FC8C;
		  /* 8218FC8Ch */ case   19:  		/* lwz R8, <#[R4 + 28]> */
		/* 8218FC8Ch case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R4 + 0x0000001C) );
		/* 8218FC8Ch case   19:*/		return 0x8218FC90;
		  /* 8218FC90h */ case   20:  		/* cmplw CR6, R10, R8 */
		/* 8218FC90h case   20:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8218FC90h case   20:*/		return 0x8218FC94;
		  /* 8218FC94h */ case   21:  		/* bc 4, CR6_EQ, 20 */
		/* 8218FC94h case   21:*/		if ( !regs.CR[6].eq ) { return 0x8218FCA8;  }
		/* 8218FC94h case   21:*/		return 0x8218FC98;
		  /* 8218FC98h */ case   22:  		/* lwz R11, <#[R11 + 8]> */
		/* 8218FC98h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8218FC98h case   22:*/		return 0x8218FC9C;
		  /* 8218FC9Ch */ case   23:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8218FC9Ch case   23:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8218FC9Ch case   23:*/		return 0x8218FCA0;
		  /* 8218FCA0h */ case   24:  		/* cmplwi CR6, R11, 14336 */
		/* 8218FCA0h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 8218FCA0h case   24:*/		return 0x8218FCA4;
		  /* 8218FCA4h */ case   25:  		/* bc 4, CR6_EQ, 12 */
		/* 8218FCA4h case   25:*/		if ( !regs.CR[6].eq ) { return 0x8218FCB0;  }
		/* 8218FCA4h case   25:*/		return 0x8218FCA8;
	}
	return 0x8218FCA8;
} // Block from 8218FC40h-8218FCA8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8218FCA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FCA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FCA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FCA8);
		  /* 8218FCA8h */ case    0:  		/* li R11, 0 */
		/* 8218FCA8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218FCA8h case    0:*/		return 0x8218FCAC;
		  /* 8218FCACh */ case    1:  		/* b 8 */
		/* 8218FCACh case    1:*/		return 0x8218FCB4;
		/* 8218FCACh case    1:*/		return 0x8218FCB0;
	}
	return 0x8218FCB0;
} // Block from 8218FCA8h-8218FCB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218FCB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FCB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FCB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FCB0);
		  /* 8218FCB0h */ case    0:  		/* li R11, 1 */
		/* 8218FCB0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218FCB0h case    0:*/		return 0x8218FCB4;
	}
	return 0x8218FCB4;
} // Block from 8218FCB0h-8218FCB4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218FCB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FCB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FCB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FCB4);
		  /* 8218FCB4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8218FCB4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8218FCB4h case    0:*/		return 0x8218FCB8;
		  /* 8218FCB8h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 8218FCB8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8218FCC4;  }
		/* 8218FCB8h case    1:*/		return 0x8218FCBC;
	}
	return 0x8218FCBC;
} // Block from 8218FCB4h-8218FCBCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218FCBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FCBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FCBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FCBC);
		  /* 8218FCBCh */ case    0:  		/* addi R11, R9, 8 */
		/* 8218FCBCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x8);
		/* 8218FCBCh case    0:*/		return 0x8218FCC0;
		  /* 8218FCC0h */ case    1:  		/* b -108 */
		/* 8218FCC0h case    1:*/		return 0x8218FC54;
		/* 8218FCC0h case    1:*/		return 0x8218FCC4;
	}
	return 0x8218FCC4;
} // Block from 8218FCBCh-8218FCC4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218FCC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FCC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FCC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FCC4);
		  /* 8218FCC4h */ case    0:  		/* addi R11, R9, 0 */
		/* 8218FCC4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x0);
		/* 8218FCC4h case    0:*/		return 0x8218FCC8;
		  /* 8218FCC8h */ case    1:  		/* cntlzw R11, R11 */
		/* 8218FCC8h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8218FCC8h case    1:*/		return 0x8218FCCC;
		  /* 8218FCCCh */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 8218FCCCh case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 8218FCCCh case    2:*/		return 0x8218FCD0;
		  /* 8218FCD0h */ case    3:  		/* bclr 20, CR0_LT */
		/* 8218FCD0h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8218FCD0h case    3:*/		return 0x8218FCD4;
	}
	return 0x8218FCD4;
} // Block from 8218FCC4h-8218FCD4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218FCD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FCD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FCD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FCD4);
		  /* 8218FCD4h */ case    0:  		/* nop */
		/* 8218FCD4h case    0:*/		cpu::op::nop();
		/* 8218FCD4h case    0:*/		return 0x8218FCD8;
	}
	return 0x8218FCD8;
} // Block from 8218FCD4h-8218FCD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218FCD8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FCD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FCD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FCD8);
		  /* 8218FCD8h */ case    0:  		/* mfspr R12, LR */
		/* 8218FCD8h case    0:*/		regs.R12 = regs.LR;
		/* 8218FCD8h case    0:*/		return 0x8218FCDC;
		  /* 8218FCDCh */ case    1:  		/* bl -1043076 */
		/* 8218FCDCh case    1:*/		regs.LR = 0x8218FCE0; return 0x82091258;
		/* 8218FCDCh case    1:*/		return 0x8218FCE0;
		  /* 8218FCE0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8218FCE0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8218FCE0h case    2:*/		return 0x8218FCE4;
		  /* 8218FCE4h */ case    3:  		/* lwz R9, <#[R4 + 8]> */
		/* 8218FCE4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000008) );
		/* 8218FCE4h case    3:*/		return 0x8218FCE8;
		  /* 8218FCE8h */ case    4:  		/* mr R29, R4 */
		/* 8218FCE8h case    4:*/		regs.R29 = regs.R4;
		/* 8218FCE8h case    4:*/		return 0x8218FCEC;
		  /* 8218FCECh */ case    5:  		/* lwz R10, <#[R5 + 8]> */
		/* 8218FCECh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000008) );
		/* 8218FCECh case    5:*/		return 0x8218FCF0;
		  /* 8218FCF0h */ case    6:  		/* mr R28, R5 */
		/* 8218FCF0h case    6:*/		regs.R28 = regs.R5;
		/* 8218FCF0h case    6:*/		return 0x8218FCF4;
		  /* 8218FCF4h */ case    7:  		/* rlwinm R11, R9, 27, 31, 31 */
		/* 8218FCF4h case    7:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R9);
		/* 8218FCF4h case    7:*/		return 0x8218FCF8;
		  /* 8218FCF8h */ case    8:  		/* rlwinm R10, R10, 27, 31, 31 */
		/* 8218FCF8h case    8:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R10);
		/* 8218FCF8h case    8:*/		return 0x8218FCFC;
		  /* 8218FCFCh */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 8218FCFCh case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8218FCFCh case    9:*/		return 0x8218FD00;
		  /* 8218FD00h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 8218FD00h case   10:*/		if ( regs.CR[6].eq ) { return 0x8218FD0C;  }
		/* 8218FD00h case   10:*/		return 0x8218FD04;
		  /* 8218FD04h */ case   11:  		/* li R3, 0 */
		/* 8218FD04h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8218FD04h case   11:*/		return 0x8218FD08;
		  /* 8218FD08h */ case   12:  		/* b 1340 */
		/* 8218FD08h case   12:*/		return 0x82190244;
		/* 8218FD08h case   12:*/		return 0x8218FD0C;
	}
	return 0x8218FD0C;
} // Block from 8218FCD8h-8218FD0Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8218FD0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FD0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FD0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FD0C);
		  /* 8218FD0Ch */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8218FD0Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218FD0Ch case    0:*/		return 0x8218FD10;
		  /* 8218FD10h */ case    1:  		/* bc 12, CR6_EQ, 96 */
		/* 8218FD10h case    1:*/		if ( regs.CR[6].eq ) { return 0x8218FD70;  }
		/* 8218FD10h case    1:*/		return 0x8218FD14;
		  /* 8218FD14h */ case    2:  		/* lwz R11, <#[R29 + 4]> */
		/* 8218FD14h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8218FD14h case    2:*/		return 0x8218FD18;
		  /* 8218FD18h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8218FD18h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218FD18h case    3:*/		return 0x8218FD1C;
		  /* 8218FD1Ch */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 8218FD1Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x8218FD34;  }
		/* 8218FD1Ch case    4:*/		return 0x8218FD20;
		  /* 8218FD20h */ case    5:  		/* lwz R10, <#[R11]> */
		/* 8218FD20h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218FD20h case    5:*/		return 0x8218FD24;
		  /* 8218FD24h */ case    6:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 8218FD24h case    6:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 8218FD24h case    6:*/		return 0x8218FD28;
		  /* 8218FD28h */ case    7:  		/* bc 4, CR0_EQ, 12 */
		/* 8218FD28h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8218FD34;  }
		/* 8218FD28h case    7:*/		return 0x8218FD2C;
		  /* 8218FD2Ch */ case    8:  		/* lwz R11, <#[R11 + 8]> */
		/* 8218FD2Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8218FD2Ch case    8:*/		return 0x8218FD30;
		  /* 8218FD30h */ case    9:  		/* b -24 */
		/* 8218FD30h case    9:*/		return 0x8218FD18;
		/* 8218FD30h case    9:*/		return 0x8218FD34;
	}
	return 0x8218FD34;
} // Block from 8218FD0Ch-8218FD34h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8218FD34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FD34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FD34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FD34);
		  /* 8218FD34h */ case    0:  		/* lwz R10, <#[R11]> */
		/* 8218FD34h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8218FD34h case    0:*/		return 0x8218FD38;
		  /* 8218FD38h */ case    1:  		/* lwz R11, <#[R28 + 4]> */
		/* 8218FD38h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8218FD38h case    1:*/		return 0x8218FD3C;
		  /* 8218FD3Ch */ case    2:  		/* rlwinm R10, R10, 19, 20, 31 */
		/* 8218FD3Ch case    2:*/		cpu::op::rlwinm<0,19,20,31>(regs,&regs.R10,regs.R10);
		/* 8218FD3Ch case    2:*/		return 0x8218FD40;
		  /* 8218FD40h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8218FD40h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218FD40h case    3:*/		return 0x8218FD44;
		  /* 8218FD44h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 8218FD44h case    4:*/		if ( regs.CR[6].eq ) { return 0x8218FD5C;  }
		/* 8218FD44h case    4:*/		return 0x8218FD48;
		  /* 8218FD48h */ case    5:  		/* lwz R8, <#[R11]> */
		/* 8218FD48h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8218FD48h case    5:*/		return 0x8218FD4C;
		  /* 8218FD4Ch */ case    6:  		/* rlwinm. R8, R8, 0, 4, 6 */
		/* 8218FD4Ch case    6:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R8,regs.R8);
		/* 8218FD4Ch case    6:*/		return 0x8218FD50;
		  /* 8218FD50h */ case    7:  		/* bc 4, CR0_EQ, 12 */
		/* 8218FD50h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8218FD5C;  }
		/* 8218FD50h case    7:*/		return 0x8218FD54;
		  /* 8218FD54h */ case    8:  		/* lwz R11, <#[R11 + 8]> */
		/* 8218FD54h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8218FD54h case    8:*/		return 0x8218FD58;
		  /* 8218FD58h */ case    9:  		/* b -24 */
		/* 8218FD58h case    9:*/		return 0x8218FD40;
		/* 8218FD58h case    9:*/		return 0x8218FD5C;
	}
	return 0x8218FD5C;
} // Block from 8218FD34h-8218FD5Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8218FD5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FD5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FD5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FD5C);
		  /* 8218FD5Ch */ case    0:  		/* lwz R11, <#[R11]> */
		/* 8218FD5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8218FD5Ch case    0:*/		return 0x8218FD60;
		  /* 8218FD60h */ case    1:  		/* rlwinm R11, R11, 19, 20, 27 */
		/* 8218FD60h case    1:*/		cpu::op::rlwinm<0,19,20,27>(regs,&regs.R11,regs.R11);
		/* 8218FD60h case    1:*/		return 0x8218FD64;
		  /* 8218FD64h */ case    2:  		/* xor R11, R11, R10 */
		/* 8218FD64h case    2:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8218FD64h case    2:*/		return 0x8218FD68;
		  /* 8218FD68h */ case    3:  		/* rlwinm. R11, R11, 0, 0, 27 */
		/* 8218FD68h case    3:*/		cpu::op::rlwinm<1,0,0,27>(regs,&regs.R11,regs.R11);
		/* 8218FD68h case    3:*/		return 0x8218FD6C;
		  /* 8218FD6Ch */ case    4:  		/* bc 4, CR0_EQ, -104 */
		/* 8218FD6Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x8218FD04;  }
		/* 8218FD6Ch case    4:*/		return 0x8218FD70;
	}
	return 0x8218FD70;
} // Block from 8218FD5Ch-8218FD70h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218FD70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FD70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FD70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FD70);
		  /* 8218FD70h */ case    0:  		/* rlwinm. R11, R9, 15, 31, 31 */
		/* 8218FD70h case    0:*/		cpu::op::rlwinm<1,15,31,31>(regs,&regs.R11,regs.R9);
		/* 8218FD70h case    0:*/		return 0x8218FD74;
		  /* 8218FD74h */ case    1:  		/* li R30, 0 */
		/* 8218FD74h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8218FD74h case    1:*/		return 0x8218FD78;
		  /* 8218FD78h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8218FD78h case    2:*/		if ( regs.CR[0].eq ) { return 0x8218FD88;  }
		/* 8218FD78h case    2:*/		return 0x8218FD7C;
		  /* 8218FD7Ch */ case    3:  		/* mr R3, R29 */
		/* 8218FD7Ch case    3:*/		regs.R3 = regs.R29;
		/* 8218FD7Ch case    3:*/		return 0x8218FD80;
		  /* 8218FD80h */ case    4:  		/* bl -143688 */
		/* 8218FD80h case    4:*/		regs.LR = 0x8218FD84; return 0x8216CC38;
		/* 8218FD80h case    4:*/		return 0x8218FD84;
		  /* 8218FD84h */ case    5:  		/* lwz R30, <#[R3 + 12]> */
		/* 8218FD84h case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 8218FD84h case    5:*/		return 0x8218FD88;
	}
	return 0x8218FD88;
} // Block from 8218FD70h-8218FD88h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218FD88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FD88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FD88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FD88);
		  /* 8218FD88h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 8218FD88h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8218FD88h case    0:*/		return 0x8218FD8C;
		  /* 8218FD8Ch */ case    1:  		/* li R31, 0 */
		/* 8218FD8Ch case    1:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8218FD8Ch case    1:*/		return 0x8218FD90;
		  /* 8218FD90h */ case    2:  		/* rlwinm. R11, R11, 15, 31, 31 */
		/* 8218FD90h case    2:*/		cpu::op::rlwinm<1,15,31,31>(regs,&regs.R11,regs.R11);
		/* 8218FD90h case    2:*/		return 0x8218FD94;
		  /* 8218FD94h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 8218FD94h case    3:*/		if ( regs.CR[0].eq ) { return 0x8218FDA4;  }
		/* 8218FD94h case    3:*/		return 0x8218FD98;
		  /* 8218FD98h */ case    4:  		/* mr R3, R28 */
		/* 8218FD98h case    4:*/		regs.R3 = regs.R28;
		/* 8218FD98h case    4:*/		return 0x8218FD9C;
		  /* 8218FD9Ch */ case    5:  		/* bl -143716 */
		/* 8218FD9Ch case    5:*/		regs.LR = 0x8218FDA0; return 0x8216CC38;
		/* 8218FD9Ch case    5:*/		return 0x8218FDA0;
		  /* 8218FDA0h */ case    6:  		/* lwz R31, <#[R3 + 12]> */
		/* 8218FDA0h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x0000000C) );
		/* 8218FDA0h case    6:*/		return 0x8218FDA4;
	}
	return 0x8218FDA4;
} // Block from 8218FD88h-8218FDA4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8218FDA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FDA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FDA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FDA4);
		  /* 8218FDA4h */ case    0:  		/* cmplw CR6, R30, R31 */
		/* 8218FDA4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R31);
		/* 8218FDA4h case    0:*/		return 0x8218FDA8;
		  /* 8218FDA8h */ case    1:  		/* bc 4, CR6_EQ, -164 */
		/* 8218FDA8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8218FD04;  }
		/* 8218FDA8h case    1:*/		return 0x8218FDAC;
		  /* 8218FDACh */ case    2:  		/* lwz R11, <#[R29 + 28]> */
		/* 8218FDACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000001C) );
		/* 8218FDACh case    2:*/		return 0x8218FDB0;
		  /* 8218FDB0h */ case    3:  		/* lwz R11, <#[R11 + 76]> */
		/* 8218FDB0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 8218FDB0h case    3:*/		return 0x8218FDB4;
		  /* 8218FDB4h */ case    4:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 8218FDB4h case    4:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 8218FDB4h case    4:*/		return 0x8218FDB8;
		  /* 8218FDB8h */ case    5:  		/* bc 12, CR0_EQ, 88 */
		/* 8218FDB8h case    5:*/		if ( regs.CR[0].eq ) { return 0x8218FE10;  }
		/* 8218FDB8h case    5:*/		return 0x8218FDBC;
		  /* 8218FDBCh */ case    6:  		/* cmplwi CR6, R30, 0 */
		/* 8218FDBCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8218FDBCh case    6:*/		return 0x8218FDC0;
		  /* 8218FDC0h */ case    7:  		/* bc 4, CR6_EQ, 24 */
		/* 8218FDC0h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8218FDD8;  }
		/* 8218FDC0h case    7:*/		return 0x8218FDC4;
		  /* 8218FDC4h */ case    8:  		/* mr R3, R29 */
		/* 8218FDC4h case    8:*/		regs.R3 = regs.R29;
		/* 8218FDC4h case    8:*/		return 0x8218FDC8;
		  /* 8218FDC8h */ case    9:  		/* bl -179336 */
		/* 8218FDC8h case    9:*/		regs.LR = 0x8218FDCC; return 0x82164140;
		/* 8218FDC8h case    9:*/		return 0x8218FDCC;
		  /* 8218FDCCh */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8218FDCCh case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8218FDCCh case   10:*/		return 0x8218FDD0;
		  /* 8218FDD0h */ case   11:  		/* li R11, 1 */
		/* 8218FDD0h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218FDD0h case   11:*/		return 0x8218FDD4;
		  /* 8218FDD4h */ case   12:  		/* bc 4, CR0_EQ, 8 */
		/* 8218FDD4h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8218FDDC;  }
		/* 8218FDD4h case   12:*/		return 0x8218FDD8;
	}
	return 0x8218FDD8;
} // Block from 8218FDA4h-8218FDD8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8218FDD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FDD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FDD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FDD8);
		  /* 8218FDD8h */ case    0:  		/* li R11, 0 */
		/* 8218FDD8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218FDD8h case    0:*/		return 0x8218FDDC;
	}
	return 0x8218FDDC;
} // Block from 8218FDD8h-8218FDDCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218FDDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FDDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FDDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FDDC);
		  /* 8218FDDCh */ case    0:  		/* rlwinm R30, R11, 0, 24, 31 */
		/* 8218FDDCh case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R30,regs.R11);
		/* 8218FDDCh case    0:*/		return 0x8218FDE0;
		  /* 8218FDE0h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 8218FDE0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8218FDE0h case    1:*/		return 0x8218FDE4;
		  /* 8218FDE4h */ case    2:  		/* bc 4, CR6_EQ, 24 */
		/* 8218FDE4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8218FDFC;  }
		/* 8218FDE4h case    2:*/		return 0x8218FDE8;
		  /* 8218FDE8h */ case    3:  		/* mr R3, R28 */
		/* 8218FDE8h case    3:*/		regs.R3 = regs.R28;
		/* 8218FDE8h case    3:*/		return 0x8218FDEC;
		  /* 8218FDECh */ case    4:  		/* bl -179372 */
		/* 8218FDECh case    4:*/		regs.LR = 0x8218FDF0; return 0x82164140;
		/* 8218FDECh case    4:*/		return 0x8218FDF0;
		  /* 8218FDF0h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8218FDF0h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8218FDF0h case    5:*/		return 0x8218FDF4;
		  /* 8218FDF4h */ case    6:  		/* li R11, 1 */
		/* 8218FDF4h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218FDF4h case    6:*/		return 0x8218FDF8;
		  /* 8218FDF8h */ case    7:  		/* bc 4, CR0_EQ, 8 */
		/* 8218FDF8h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8218FE00;  }
		/* 8218FDF8h case    7:*/		return 0x8218FDFC;
	}
	return 0x8218FDFC;
} // Block from 8218FDDCh-8218FDFCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218FDFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FDFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FDFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FDFC);
		  /* 8218FDFCh */ case    0:  		/* li R11, 0 */
		/* 8218FDFCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218FDFCh case    0:*/		return 0x8218FE00;
	}
	return 0x8218FE00;
} // Block from 8218FDFCh-8218FE00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218FE00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FE00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FE00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FE00);
		  /* 8218FE00h */ case    0:  		/* rlwinm. R10, R30, 0, 24, 31 */
		/* 8218FE00h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R30);
		/* 8218FE00h case    0:*/		return 0x8218FE04;
		  /* 8218FE04h */ case    1:  		/* bc 4, CR0_EQ, -256 */
		/* 8218FE04h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8218FD04;  }
		/* 8218FE04h case    1:*/		return 0x8218FE08;
		  /* 8218FE08h */ case    2:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8218FE08h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8218FE08h case    2:*/		return 0x8218FE0C;
		  /* 8218FE0Ch */ case    3:  		/* bc 4, CR0_EQ, -264 */
		/* 8218FE0Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8218FD04;  }
		/* 8218FE0Ch case    3:*/		return 0x8218FE10;
	}
	return 0x8218FE10;
} // Block from 8218FE00h-8218FE10h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218FE10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FE10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FE10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FE10);
		  /* 8218FE10h */ case    0:  		/* mr R3, R29 */
		/* 8218FE10h case    0:*/		regs.R3 = regs.R29;
		/* 8218FE10h case    0:*/		return 0x8218FE14;
		  /* 8218FE14h */ case    1:  		/* bl -179556 */
		/* 8218FE14h case    1:*/		regs.LR = 0x8218FE18; return 0x821640B0;
		/* 8218FE14h case    1:*/		return 0x8218FE18;
		  /* 8218FE18h */ case    2:  		/* mr R31, R3 */
		/* 8218FE18h case    2:*/		regs.R31 = regs.R3;
		/* 8218FE18h case    2:*/		return 0x8218FE1C;
		  /* 8218FE1Ch */ case    3:  		/* mr R3, R28 */
		/* 8218FE1Ch case    3:*/		regs.R3 = regs.R28;
		/* 8218FE1Ch case    3:*/		return 0x8218FE20;
		  /* 8218FE20h */ case    4:  		/* bl -179568 */
		/* 8218FE20h case    4:*/		regs.LR = 0x8218FE24; return 0x821640B0;
		/* 8218FE20h case    4:*/		return 0x8218FE24;
		  /* 8218FE24h */ case    5:  		/* rlwinm. R11, R31, 0, 24, 31 */
		/* 8218FE24h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R31);
		/* 8218FE24h case    5:*/		return 0x8218FE28;
		  /* 8218FE28h */ case    6:  		/* bc 4, CR0_EQ, 12 */
		/* 8218FE28h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8218FE34;  }
		/* 8218FE28h case    6:*/		return 0x8218FE2C;
		  /* 8218FE2Ch */ case    7:  		/* rlwinm. R10, R3, 0, 24, 31 */
		/* 8218FE2Ch case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R3);
		/* 8218FE2Ch case    7:*/		return 0x8218FE30;
		  /* 8218FE30h */ case    8:  		/* bc 12, CR0_EQ, 140 */
		/* 8218FE30h case    8:*/		if ( regs.CR[0].eq ) { return 0x8218FEBC;  }
		/* 8218FE30h case    8:*/		return 0x8218FE34;
	}
	return 0x8218FE34;
} // Block from 8218FE10h-8218FE34h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218FE34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FE34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FE34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FE34);
		  /* 8218FE34h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8218FE34h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218FE34h case    0:*/		return 0x8218FE38;
		  /* 8218FE38h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8218FE38h case    1:*/		if ( regs.CR[6].eq ) { return 0x8218FE44;  }
		/* 8218FE38h case    1:*/		return 0x8218FE3C;
		  /* 8218FE3Ch */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8218FE3Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8218FE3Ch case    2:*/		return 0x8218FE40;
		  /* 8218FE40h */ case    3:  		/* bc 4, CR0_EQ, -316 */
		/* 8218FE40h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8218FD04;  }
		/* 8218FE40h case    3:*/		return 0x8218FE44;
	}
	return 0x8218FE44;
} // Block from 8218FE34h-8218FE44h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218FE44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FE44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FE44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FE44);
		  /* 8218FE44h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 8218FE44h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8218FE44h case    0:*/		return 0x8218FE48;
		  /* 8218FE48h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8218FE48h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8218FE48h case    1:*/		return 0x8218FE4C;
		  /* 8218FE4Ch */ case    2:  		/* cmplwi CR6, R11, 25 */
		/* 8218FE4Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000019);
		/* 8218FE4Ch case    2:*/		return 0x8218FE50;
		  /* 8218FE50h */ case    3:  		/* bc 12, CR6_LT, 12 */
		/* 8218FE50h case    3:*/		if ( regs.CR[6].lt ) { return 0x8218FE5C;  }
		/* 8218FE50h case    3:*/		return 0x8218FE54;
		  /* 8218FE54h */ case    4:  		/* cmplwi CR6, R11, 28 */
		/* 8218FE54h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001C);
		/* 8218FE54h case    4:*/		return 0x8218FE58;
		  /* 8218FE58h */ case    5:  		/* bc 4, CR6_GT, 20 */
		/* 8218FE58h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8218FE6C;  }
		/* 8218FE58h case    5:*/		return 0x8218FE5C;
	}
	return 0x8218FE5C;
} // Block from 8218FE44h-8218FE5Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218FE5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FE5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FE5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FE5C);
		  /* 8218FE5Ch */ case    0:  		/* cmplwi CR6, R11, 67 */
		/* 8218FE5Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000043);
		/* 8218FE5Ch case    0:*/		return 0x8218FE60;
		  /* 8218FE60h */ case    1:  		/* bc 12, CR6_LT, 20 */
		/* 8218FE60h case    1:*/		if ( regs.CR[6].lt ) { return 0x8218FE74;  }
		/* 8218FE60h case    1:*/		return 0x8218FE64;
		  /* 8218FE64h */ case    2:  		/* cmplwi CR6, R11, 71 */
		/* 8218FE64h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000047);
		/* 8218FE64h case    2:*/		return 0x8218FE68;
		  /* 8218FE68h */ case    3:  		/* bc 12, CR6_GT, 12 */
		/* 8218FE68h case    3:*/		if ( regs.CR[6].gt ) { return 0x8218FE74;  }
		/* 8218FE68h case    3:*/		return 0x8218FE6C;
	}
	return 0x8218FE6C;
} // Block from 8218FE5Ch-8218FE6Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218FE6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FE6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FE6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FE6C);
		  /* 8218FE6Ch */ case    0:  		/* li R11, 1 */
		/* 8218FE6Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218FE6Ch case    0:*/		return 0x8218FE70;
		  /* 8218FE70h */ case    1:  		/* b 8 */
		/* 8218FE70h case    1:*/		return 0x8218FE78;
		/* 8218FE70h case    1:*/		return 0x8218FE74;
	}
	return 0x8218FE74;
} // Block from 8218FE6Ch-8218FE74h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218FE74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FE74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FE74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FE74);
		  /* 8218FE74h */ case    0:  		/* li R11, 0 */
		/* 8218FE74h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218FE74h case    0:*/		return 0x8218FE78;
	}
	return 0x8218FE78;
} // Block from 8218FE74h-8218FE78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218FE78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FE78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FE78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FE78);
		  /* 8218FE78h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8218FE78h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8218FE78h case    0:*/		return 0x8218FE7C;
		  /* 8218FE7Ch */ case    1:  		/* bc 4, CR0_EQ, -376 */
		/* 8218FE7Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x8218FD04;  }
		/* 8218FE7Ch case    1:*/		return 0x8218FE80;
		  /* 8218FE80h */ case    2:  		/* lwz R11, <#[R28 + 8]> */
		/* 8218FE80h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8218FE80h case    2:*/		return 0x8218FE84;
		  /* 8218FE84h */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8218FE84h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8218FE84h case    3:*/		return 0x8218FE88;
		  /* 8218FE88h */ case    4:  		/* cmplwi CR6, R11, 25 */
		/* 8218FE88h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000019);
		/* 8218FE88h case    4:*/		return 0x8218FE8C;
		  /* 8218FE8Ch */ case    5:  		/* bc 12, CR6_LT, 12 */
		/* 8218FE8Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x8218FE98;  }
		/* 8218FE8Ch case    5:*/		return 0x8218FE90;
		  /* 8218FE90h */ case    6:  		/* cmplwi CR6, R11, 28 */
		/* 8218FE90h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001C);
		/* 8218FE90h case    6:*/		return 0x8218FE94;
		  /* 8218FE94h */ case    7:  		/* bc 4, CR6_GT, 20 */
		/* 8218FE94h case    7:*/		if ( !regs.CR[6].gt ) { return 0x8218FEA8;  }
		/* 8218FE94h case    7:*/		return 0x8218FE98;
	}
	return 0x8218FE98;
} // Block from 8218FE78h-8218FE98h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218FE98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FE98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FE98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FE98);
		  /* 8218FE98h */ case    0:  		/* cmplwi CR6, R11, 67 */
		/* 8218FE98h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000043);
		/* 8218FE98h case    0:*/		return 0x8218FE9C;
		  /* 8218FE9Ch */ case    1:  		/* bc 12, CR6_LT, 20 */
		/* 8218FE9Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x8218FEB0;  }
		/* 8218FE9Ch case    1:*/		return 0x8218FEA0;
		  /* 8218FEA0h */ case    2:  		/* cmplwi CR6, R11, 71 */
		/* 8218FEA0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000047);
		/* 8218FEA0h case    2:*/		return 0x8218FEA4;
		  /* 8218FEA4h */ case    3:  		/* bc 12, CR6_GT, 12 */
		/* 8218FEA4h case    3:*/		if ( regs.CR[6].gt ) { return 0x8218FEB0;  }
		/* 8218FEA4h case    3:*/		return 0x8218FEA8;
	}
	return 0x8218FEA8;
} // Block from 8218FE98h-8218FEA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218FEA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FEA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FEA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FEA8);
		  /* 8218FEA8h */ case    0:  		/* li R11, 1 */
		/* 8218FEA8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218FEA8h case    0:*/		return 0x8218FEAC;
		  /* 8218FEACh */ case    1:  		/* b 8 */
		/* 8218FEACh case    1:*/		return 0x8218FEB4;
		/* 8218FEACh case    1:*/		return 0x8218FEB0;
	}
	return 0x8218FEB0;
} // Block from 8218FEA8h-8218FEB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218FEB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FEB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FEB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FEB0);
		  /* 8218FEB0h */ case    0:  		/* li R11, 0 */
		/* 8218FEB0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218FEB0h case    0:*/		return 0x8218FEB4;
	}
	return 0x8218FEB4;
} // Block from 8218FEB0h-8218FEB4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218FEB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FEB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FEB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FEB4);
		  /* 8218FEB4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8218FEB4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8218FEB4h case    0:*/		return 0x8218FEB8;
		  /* 8218FEB8h */ case    1:  		/* bc 4, CR0_EQ, -436 */
		/* 8218FEB8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8218FD04;  }
		/* 8218FEB8h case    1:*/		return 0x8218FEBC;
	}
	return 0x8218FEBC;
} // Block from 8218FEB4h-8218FEBCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218FEBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FEBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FEBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FEBC);
		  /* 8218FEBCh */ case    0:  		/* lwz R31, <#[R29 + 8]> */
		/* 8218FEBCh case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000008) );
		/* 8218FEBCh case    0:*/		return 0x8218FEC0;
		  /* 8218FEC0h */ case    1:  		/* rlwinm. R11, R31, 0, 25, 25 */
		/* 8218FEC0h case    1:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R31);
		/* 8218FEC0h case    1:*/		return 0x8218FEC4;
		  /* 8218FEC4h */ case    2:  		/* bc 4, CR0_EQ, 12 */
		/* 8218FEC4h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8218FED0;  }
		/* 8218FEC4h case    2:*/		return 0x8218FEC8;
		  /* 8218FEC8h */ case    3:  		/* li R10, 0 */
		/* 8218FEC8h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8218FEC8h case    3:*/		return 0x8218FECC;
		  /* 8218FECCh */ case    4:  		/* b 44 */
		/* 8218FECCh case    4:*/		return 0x8218FEF8;
		/* 8218FECCh case    4:*/		return 0x8218FED0;
	}
	return 0x8218FED0;
} // Block from 8218FEBCh-8218FED0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218FED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FED0);
		  /* 8218FED0h */ case    0:  		/* rlwinm R11, R31, 25, 25, 31 */
		/* 8218FED0h case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R31);
		/* 8218FED0h case    0:*/		return 0x8218FED4;
		  /* 8218FED4h */ case    1:  		/* cmplwi CR6, R11, 30 */
		/* 8218FED4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001E);
		/* 8218FED4h case    1:*/		return 0x8218FED8;
		  /* 8218FED8h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 8218FED8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8218FEF0;  }
		/* 8218FED8h case    2:*/		return 0x8218FEDC;
		  /* 8218FEDCh */ case    3:  		/* cmplwi CR6, R11, 55 */
		/* 8218FEDCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000037);
		/* 8218FEDCh case    3:*/		return 0x8218FEE0;
		  /* 8218FEE0h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 8218FEE0h case    4:*/		if ( regs.CR[6].eq ) { return 0x8218FEF0;  }
		/* 8218FEE0h case    4:*/		return 0x8218FEE4;
		  /* 8218FEE4h */ case    5:  		/* cmplwi CR6, R11, 56 */
		/* 8218FEE4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000038);
		/* 8218FEE4h case    5:*/		return 0x8218FEE8;
		  /* 8218FEE8h */ case    6:  		/* li R11, 0 */
		/* 8218FEE8h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218FEE8h case    6:*/		return 0x8218FEEC;
		  /* 8218FEECh */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 8218FEECh case    7:*/		if ( !regs.CR[6].eq ) { return 0x8218FEF4;  }
		/* 8218FEECh case    7:*/		return 0x8218FEF0;
	}
	return 0x8218FEF0;
} // Block from 8218FED0h-8218FEF0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218FEF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FEF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FEF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FEF0);
		  /* 8218FEF0h */ case    0:  		/* li R11, 1 */
		/* 8218FEF0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218FEF0h case    0:*/		return 0x8218FEF4;
	}
	return 0x8218FEF4;
} // Block from 8218FEF0h-8218FEF4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218FEF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FEF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FEF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FEF4);
		  /* 8218FEF4h */ case    0:  		/* rlwinm R10, R11, 0, 24, 31 */
		/* 8218FEF4h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R11);
		/* 8218FEF4h case    0:*/		return 0x8218FEF8;
	}
	return 0x8218FEF8;
} // Block from 8218FEF4h-8218FEF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218FEF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FEF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FEF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FEF8);
		  /* 8218FEF8h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 8218FEF8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8218FEF8h case    0:*/		return 0x8218FEFC;
		  /* 8218FEFCh */ case    1:  		/* rlwinm. R9, R11, 0, 25, 25 */
		/* 8218FEFCh case    1:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R9,regs.R11);
		/* 8218FEFCh case    1:*/		return 0x8218FF00;
		  /* 8218FF00h */ case    2:  		/* bc 4, CR0_EQ, 12 */
		/* 8218FF00h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8218FF0C;  }
		/* 8218FF00h case    2:*/		return 0x8218FF04;
		  /* 8218FF04h */ case    3:  		/* li R11, 0 */
		/* 8218FF04h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218FF04h case    3:*/		return 0x8218FF08;
		  /* 8218FF08h */ case    4:  		/* b 44 */
		/* 8218FF08h case    4:*/		return 0x8218FF34;
		/* 8218FF08h case    4:*/		return 0x8218FF0C;
	}
	return 0x8218FF0C;
} // Block from 8218FEF8h-8218FF0Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218FF0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FF0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FF0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FF0C);
		  /* 8218FF0Ch */ case    0:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8218FF0Ch case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8218FF0Ch case    0:*/		return 0x8218FF10;
		  /* 8218FF10h */ case    1:  		/* cmplwi CR6, R11, 30 */
		/* 8218FF10h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001E);
		/* 8218FF10h case    1:*/		return 0x8218FF14;
		  /* 8218FF14h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 8218FF14h case    2:*/		if ( regs.CR[6].eq ) { return 0x8218FF2C;  }
		/* 8218FF14h case    2:*/		return 0x8218FF18;
		  /* 8218FF18h */ case    3:  		/* cmplwi CR6, R11, 55 */
		/* 8218FF18h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000037);
		/* 8218FF18h case    3:*/		return 0x8218FF1C;
		  /* 8218FF1Ch */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 8218FF1Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x8218FF2C;  }
		/* 8218FF1Ch case    4:*/		return 0x8218FF20;
		  /* 8218FF20h */ case    5:  		/* cmplwi CR6, R11, 56 */
		/* 8218FF20h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000038);
		/* 8218FF20h case    5:*/		return 0x8218FF24;
		  /* 8218FF24h */ case    6:  		/* li R11, 0 */
		/* 8218FF24h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218FF24h case    6:*/		return 0x8218FF28;
		  /* 8218FF28h */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 8218FF28h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8218FF30;  }
		/* 8218FF28h case    7:*/		return 0x8218FF2C;
	}
	return 0x8218FF2C;
} // Block from 8218FF0Ch-8218FF2Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8218FF2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FF2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FF2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FF2C);
		  /* 8218FF2Ch */ case    0:  		/* li R11, 1 */
		/* 8218FF2Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218FF2Ch case    0:*/		return 0x8218FF30;
	}
	return 0x8218FF30;
} // Block from 8218FF2Ch-8218FF30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218FF30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FF30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FF30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FF30);
		  /* 8218FF30h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 8218FF30h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8218FF30h case    0:*/		return 0x8218FF34;
	}
	return 0x8218FF34;
} // Block from 8218FF30h-8218FF34h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218FF34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FF34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FF34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FF34);
		  /* 8218FF34h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 8218FF34h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 8218FF34h case    0:*/		return 0x8218FF38;
		  /* 8218FF38h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8218FF38h case    1:*/		if ( regs.CR[0].eq ) { return 0x8218FF44;  }
		/* 8218FF38h case    1:*/		return 0x8218FF3C;
		  /* 8218FF3Ch */ case    2:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8218FF3Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8218FF3Ch case    2:*/		return 0x8218FF40;
		  /* 8218FF40h */ case    3:  		/* bc 4, CR0_EQ, -572 */
		/* 8218FF40h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8218FD04;  }
		/* 8218FF40h case    3:*/		return 0x8218FF44;
	}
	return 0x8218FF44;
} // Block from 8218FF34h-8218FF44h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8218FF44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FF44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FF44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FF44);
		  /* 8218FF44h */ case    0:  		/* rlwinm R11, R31, 25, 25, 31 */
		/* 8218FF44h case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R31);
		/* 8218FF44h case    0:*/		return 0x8218FF48;
		  /* 8218FF48h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 8218FF48h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8218FF48h case    1:*/		return 0x8218FF4C;
		  /* 8218FF4Ch */ case    2:  		/* bc 12, CR6_LT, 16 */
		/* 8218FF4Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x8218FF5C;  }
		/* 8218FF4Ch case    2:*/		return 0x8218FF50;
		  /* 8218FF50h */ case    3:  		/* cmplwi CR6, R11, 31 */
		/* 8218FF50h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001F);
		/* 8218FF50h case    3:*/		return 0x8218FF54;
		  /* 8218FF54h */ case    4:  		/* li R11, 1 */
		/* 8218FF54h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218FF54h case    4:*/		return 0x8218FF58;
		  /* 8218FF58h */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 8218FF58h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8218FF60;  }
		/* 8218FF58h case    5:*/		return 0x8218FF5C;
	}
	return 0x8218FF5C;
} // Block from 8218FF44h-8218FF5Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8218FF5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FF5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FF5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FF5C);
		  /* 8218FF5Ch */ case    0:  		/* li R11, 0 */
		/* 8218FF5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218FF5Ch case    0:*/		return 0x8218FF60;
	}
	return 0x8218FF60;
} // Block from 8218FF5Ch-8218FF60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218FF60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FF60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FF60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FF60);
		  /* 8218FF60h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8218FF60h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8218FF60h case    0:*/		return 0x8218FF64;
		  /* 8218FF64h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8218FF64h case    1:*/		if ( regs.CR[0].eq ) { return 0x8218FF74;  }
		/* 8218FF64h case    1:*/		return 0x8218FF68;
		  /* 8218FF68h */ case    2:  		/* mr R5, R29 */
		/* 8218FF68h case    2:*/		regs.R5 = regs.R29;
		/* 8218FF68h case    2:*/		return 0x8218FF6C;
		  /* 8218FF6Ch */ case    3:  		/* mr R6, R28 */
		/* 8218FF6Ch case    3:*/		regs.R6 = regs.R28;
		/* 8218FF6Ch case    3:*/		return 0x8218FF70;
		  /* 8218FF70h */ case    4:  		/* b 12 */
		/* 8218FF70h case    4:*/		return 0x8218FF7C;
		/* 8218FF70h case    4:*/		return 0x8218FF74;
	}
	return 0x8218FF74;
} // Block from 8218FF60h-8218FF74h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218FF74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FF74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FF74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FF74);
		  /* 8218FF74h */ case    0:  		/* mr R5, R28 */
		/* 8218FF74h case    0:*/		regs.R5 = regs.R28;
		/* 8218FF74h case    0:*/		return 0x8218FF78;
		  /* 8218FF78h */ case    1:  		/* mr R6, R29 */
		/* 8218FF78h case    1:*/		regs.R6 = regs.R29;
		/* 8218FF78h case    1:*/		return 0x8218FF7C;
	}
	return 0x8218FF7C;
} // Block from 8218FF74h-8218FF7Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8218FF7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FF7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FF7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FF7C);
		  /* 8218FF7Ch */ case    0:  		/* lwz R11, <#[R5 + 8]> */
		/* 8218FF7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 8218FF7Ch case    0:*/		return 0x8218FF80;
		  /* 8218FF80h */ case    1:  		/* rlwinm R4, R11, 13, 29, 31 */
		/* 8218FF80h case    1:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R4,regs.R11);
		/* 8218FF80h case    1:*/		return 0x8218FF84;
		  /* 8218FF84h */ case    2:  		/* cmplwi CR6, R4, 3 */
		/* 8218FF84h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000003);
		/* 8218FF84h case    2:*/		return 0x8218FF88;
		  /* 8218FF88h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 8218FF88h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8218FFA0;  }
		/* 8218FF88h case    3:*/		return 0x8218FF8C;
		  /* 8218FF8Ch */ case    4:  		/* lwz R11, <#[R6 + 8]> */
		/* 8218FF8Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000008) );
		/* 8218FF8Ch case    4:*/		return 0x8218FF90;
		  /* 8218FF90h */ case    5:  		/* lis R10, 8 */
		/* 8218FF90h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x8);
		/* 8218FF90h case    5:*/		return 0x8218FF94;
		  /* 8218FF94h */ case    6:  		/* rlwinm R11, R11, 0, 10, 12 */
		/* 8218FF94h case    6:*/		cpu::op::rlwinm<0,0,10,12>(regs,&regs.R11,regs.R11);
		/* 8218FF94h case    6:*/		return 0x8218FF98;
		  /* 8218FF98h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 8218FF98h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8218FF98h case    7:*/		return 0x8218FF9C;
		  /* 8218FF9Ch */ case    8:  		/* bc 12, CR6_GT, -664 */
		/* 8218FF9Ch case    8:*/		if ( regs.CR[6].gt ) { return 0x8218FD04;  }
		/* 8218FF9Ch case    8:*/		return 0x8218FFA0;
	}
	return 0x8218FFA0;
} // Block from 8218FF7Ch-8218FFA0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8218FFA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FFA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FFA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FFA0);
		  /* 8218FFA0h */ case    0:  		/* mr R3, R5 */
		/* 8218FFA0h case    0:*/		regs.R3 = regs.R5;
		/* 8218FFA0h case    0:*/		return 0x8218FFA4;
		  /* 8218FFA4h */ case    1:  		/* bl -1420 */
		/* 8218FFA4h case    1:*/		regs.LR = 0x8218FFA8; return 0x8218FA18;
		/* 8218FFA4h case    1:*/		return 0x8218FFA8;
		  /* 8218FFA8h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8218FFA8h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8218FFA8h case    2:*/		return 0x8218FFAC;
		  /* 8218FFACh */ case    3:  		/* bc 12, CR0_EQ, 152 */
		/* 8218FFACh case    3:*/		if ( regs.CR[0].eq ) { return 0x82190044;  }
		/* 8218FFACh case    3:*/		return 0x8218FFB0;
		  /* 8218FFB0h */ case    4:  		/* lwz R10, <#[R6 + 4]> */
		/* 8218FFB0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000004) );
		/* 8218FFB0h case    4:*/		return 0x8218FFB4;
		  /* 8218FFB4h */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 8218FFB4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8218FFB4h case    5:*/		return 0x8218FFB8;
		  /* 8218FFB8h */ case    6:  		/* bc 12, CR6_EQ, 72 */
		/* 8218FFB8h case    6:*/		if ( regs.CR[6].eq ) { return 0x82190000;  }
		/* 8218FFB8h case    6:*/		return 0x8218FFBC;
		  /* 8218FFBCh */ case    7:  		/* lwz R11, <#[R10 + 16]> */
		/* 8218FFBCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 8218FFBCh case    7:*/		return 0x8218FFC0;
		  /* 8218FFC0h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 8218FFC0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8218FFC0h case    8:*/		return 0x8218FFC4;
		  /* 8218FFC4h */ case    9:  		/* bc 12, CR6_EQ, 52 */
		/* 8218FFC4h case    9:*/		if ( regs.CR[6].eq ) { return 0x8218FFF8;  }
		/* 8218FFC4h case    9:*/		return 0x8218FFC8;
		  /* 8218FFC8h */ case   10:  		/* lwz R9, <#[R10]> */
		/* 8218FFC8h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8218FFC8h case   10:*/		return 0x8218FFCC;
		  /* 8218FFCCh */ case   11:  		/* rlwinm. R11, R9, 0, 1, 1 */
		/* 8218FFCCh case   11:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R9);
		/* 8218FFCCh case   11:*/		return 0x8218FFD0;
		  /* 8218FFD0h */ case   12:  		/* bc 12, CR0_EQ, 16 */
		/* 8218FFD0h case   12:*/		if ( regs.CR[0].eq ) { return 0x8218FFE0;  }
		/* 8218FFD0h case   12:*/		return 0x8218FFD4;
		  /* 8218FFD4h */ case   13:  		/* rlwinm. R11, R9, 0, 4, 6 */
		/* 8218FFD4h case   13:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R9);
		/* 8218FFD4h case   13:*/		return 0x8218FFD8;
		  /* 8218FFD8h */ case   14:  		/* li R11, 1 */
		/* 8218FFD8h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8218FFD8h case   14:*/		return 0x8218FFDC;
		  /* 8218FFDCh */ case   15:  		/* bc 12, CR0_EQ, 8 */
		/* 8218FFDCh case   15:*/		if ( regs.CR[0].eq ) { return 0x8218FFE4;  }
		/* 8218FFDCh case   15:*/		return 0x8218FFE0;
	}
	return 0x8218FFE0;
} // Block from 8218FFA0h-8218FFE0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8218FFE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FFE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FFE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FFE0);
		  /* 8218FFE0h */ case    0:  		/* li R11, 0 */
		/* 8218FFE0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8218FFE0h case    0:*/		return 0x8218FFE4;
	}
	return 0x8218FFE4;
} // Block from 8218FFE0h-8218FFE4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8218FFE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FFE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FFE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FFE4);
		  /* 8218FFE4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8218FFE4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8218FFE4h case    0:*/		return 0x8218FFE8;
		  /* 8218FFE8h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8218FFE8h case    1:*/		if ( regs.CR[0].eq ) { return 0x8218FFF8;  }
		/* 8218FFE8h case    1:*/		return 0x8218FFEC;
		  /* 8218FFECh */ case    2:  		/* rlwinm R11, R9, 0, 7, 18 */
		/* 8218FFECh case    2:*/		cpu::op::rlwinm<0,0,7,18>(regs,&regs.R11,regs.R9);
		/* 8218FFECh case    2:*/		return 0x8218FFF0;
		  /* 8218FFF0h */ case    3:  		/* cmplwi CR6, R11, 49152 */
		/* 8218FFF0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000C000);
		/* 8218FFF0h case    3:*/		return 0x8218FFF4;
		  /* 8218FFF4h */ case    4:  		/* bc 12, CR6_EQ, -752 */
		/* 8218FFF4h case    4:*/		if ( regs.CR[6].eq ) { return 0x8218FD04;  }
		/* 8218FFF4h case    4:*/		return 0x8218FFF8;
	}
	return 0x8218FFF8;
} // Block from 8218FFE4h-8218FFF8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8218FFF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8218FFF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8218FFF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8218FFF8);
		  /* 8218FFF8h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 8218FFF8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8218FFF8h case    0:*/		return 0x8218FFFC;
		  /* 8218FFFCh */ case    1:  		/* b -72 */
		/* 8218FFFCh case    1:*/		return 0x8218FFB4;
		/* 8218FFFCh case    1:*/		return 0x82190000;
	}
	return 0x82190000;
} // Block from 8218FFF8h-82190000h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82190000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190000);
		  /* 82190000h */ case    0:  		/* lwz R9, <#[R6]> */
		/* 82190000h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000000) );
		/* 82190000h case    0:*/		return 0x82190004;
		  /* 82190004h */ case    1:  		/* cmplwi CR6, R9, 0 */
		/* 82190004h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82190004h case    1:*/		return 0x82190008;
		  /* 82190008h */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 82190008h case    2:*/		if ( regs.CR[6].eq ) { return 0x82190044;  }
		/* 82190008h case    2:*/		return 0x8219000C;
		  /* 8219000Ch */ case    3:  		/* lwz R10, <#[R9]> */
		/* 8219000Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8219000Ch case    3:*/		return 0x82190010;
		  /* 82190010h */ case    4:  		/* rlwinm. R11, R10, 0, 1, 1 */
		/* 82190010h case    4:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R10);
		/* 82190010h case    4:*/		return 0x82190014;
		  /* 82190014h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 82190014h case    5:*/		if ( regs.CR[0].eq ) { return 0x82190024;  }
		/* 82190014h case    5:*/		return 0x82190018;
		  /* 82190018h */ case    6:  		/* rlwinm. R11, R10, 0, 4, 6 */
		/* 82190018h case    6:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R10);
		/* 82190018h case    6:*/		return 0x8219001C;
		  /* 8219001Ch */ case    7:  		/* li R11, 1 */
		/* 8219001Ch case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219001Ch case    7:*/		return 0x82190020;
		  /* 82190020h */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 82190020h case    8:*/		if ( regs.CR[0].eq ) { return 0x82190028;  }
		/* 82190020h case    8:*/		return 0x82190024;
	}
	return 0x82190024;
} // Block from 82190000h-82190024h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82190024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190024);
		  /* 82190024h */ case    0:  		/* li R11, 0 */
		/* 82190024h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82190024h case    0:*/		return 0x82190028;
	}
	return 0x82190028;
} // Block from 82190024h-82190028h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82190028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190028);
		  /* 82190028h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82190028h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82190028h case    0:*/		return 0x8219002C;
		  /* 8219002Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8219002Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8219003C;  }
		/* 8219002Ch case    1:*/		return 0x82190030;
		  /* 82190030h */ case    2:  		/* rlwinm R11, R10, 0, 7, 18 */
		/* 82190030h case    2:*/		cpu::op::rlwinm<0,0,7,18>(regs,&regs.R11,regs.R10);
		/* 82190030h case    2:*/		return 0x82190034;
		  /* 82190034h */ case    3:  		/* cmplwi CR6, R11, 49152 */
		/* 82190034h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000C000);
		/* 82190034h case    3:*/		return 0x82190038;
		  /* 82190038h */ case    4:  		/* bc 12, CR6_EQ, -820 */
		/* 82190038h case    4:*/		if ( regs.CR[6].eq ) { return 0x8218FD04;  }
		/* 82190038h case    4:*/		return 0x8219003C;
	}
	return 0x8219003C;
} // Block from 82190028h-8219003Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219003Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219003C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219003C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219003C);
		  /* 8219003Ch */ case    0:  		/* lwz R9, <#[R9 + 4]> */
		/* 8219003Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 8219003Ch case    0:*/		return 0x82190040;
		  /* 82190040h */ case    1:  		/* b -60 */
		/* 82190040h case    1:*/		return 0x82190004;
		/* 82190040h case    1:*/		return 0x82190044;
	}
	return 0x82190044;
} // Block from 8219003Ch-82190044h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82190044h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190044( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190044) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190044);
		  /* 82190044h */ case    0:  		/* lwz R11, <#[R6 + 8]> */
		/* 82190044h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000008) );
		/* 82190044h case    0:*/		return 0x82190048;
		  /* 82190048h */ case    1:  		/* rlwinm. R11, R11, 0, 10, 12 */
		/* 82190048h case    1:*/		cpu::op::rlwinm<1,0,10,12>(regs,&regs.R11,regs.R11);
		/* 82190048h case    1:*/		return 0x8219004C;
		  /* 8219004Ch */ case    2:  		/* bc 12, CR0_EQ, 356 */
		/* 8219004Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x821901B0;  }
		/* 8219004Ch case    2:*/		return 0x82190050;
		  /* 82190050h */ case    3:  		/* lwz R3, <#[R6 + 44]> */
		/* 82190050h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R6 + 0x0000002C) );
		/* 82190050h case    3:*/		return 0x82190054;
		  /* 82190054h */ case    4:  		/* cmplwi CR6, R4, 3 */
		/* 82190054h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000003);
		/* 82190054h case    4:*/		return 0x82190058;
		  /* 82190058h */ case    5:  		/* lwz R11, <#[R3 + 12]> */
		/* 82190058h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82190058h case    5:*/		return 0x8219005C;
		  /* 8219005Ch */ case    6:  		/* bc 4, CR6_EQ, 28 */
		/* 8219005Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x82190078;  }
		/* 8219005Ch case    6:*/		return 0x82190060;
		  /* 82190060h */ case    7:  		/* lwz R11, <#[R5 + 52]> */
		/* 82190060h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000034) );
		/* 82190060h case    7:*/		return 0x82190064;
		  /* 82190064h */ case    8:  		/* lwz R10, <#[R3]> */
		/* 82190064h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82190064h case    8:*/		return 0x82190068;
		  /* 82190068h */ case    9:  		/* lwz R11, <#[R11]> */
		/* 82190068h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82190068h case    9:*/		return 0x8219006C;
		  /* 8219006Ch */ case   10:  		/* xor R11, R11, R10 */
		/* 8219006Ch case   10:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219006Ch case   10:*/		return 0x82190070;
		  /* 82190070h */ case   11:  		/* rlwinm. R11, R11, 0, 27, 30 */
		/* 82190070h case   11:*/		cpu::op::rlwinm<1,0,27,30>(regs,&regs.R11,regs.R11);
		/* 82190070h case   11:*/		return 0x82190074;
		  /* 82190074h */ case   12:  		/* b -880 */
		/* 82190074h case   12:*/		return 0x8218FD04;
		/* 82190074h case   12:*/		return 0x82190078;
	}
	return 0x82190078;
} // Block from 82190044h-82190078h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82190078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190078);
		  /* 82190078h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82190078h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82190078h case    0:*/		return 0x8219007C;
		  /* 8219007Ch */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219007Ch case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219007Ch case    1:*/		return 0x82190080;
		  /* 82190080h */ case    2:  		/* cmplwi CR6, R11, 125 */
		/* 82190080h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82190080h case    2:*/		return 0x82190084;
		  /* 82190084h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 82190084h case    3:*/		if ( regs.CR[6].eq ) { return 0x82190094;  }
		/* 82190084h case    3:*/		return 0x82190088;
		  /* 82190088h */ case    4:  		/* cmplwi CR6, R11, 124 */
		/* 82190088h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82190088h case    4:*/		return 0x8219008C;
		  /* 8219008Ch */ case    5:  		/* li R11, 0 */
		/* 8219008Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219008Ch case    5:*/		return 0x82190090;
		  /* 82190090h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 82190090h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82190098;  }
		/* 82190090h case    6:*/		return 0x82190094;
	}
	return 0x82190094;
} // Block from 82190078h-82190094h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82190094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190094);
		  /* 82190094h */ case    0:  		/* li R11, 1 */
		/* 82190094h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82190094h case    0:*/		return 0x82190098;
	}
	return 0x82190098;
} // Block from 82190094h-82190098h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82190098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190098);
		  /* 82190098h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82190098h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82190098h case    0:*/		return 0x8219009C;
		  /* 8219009Ch */ case    1:  		/* bc 12, CR0_EQ, 276 */
		/* 8219009Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821901B0;  }
		/* 8219009Ch case    1:*/		return 0x821900A0;
		  /* 821900A0h */ case    2:  		/* lwz R6, <#[R5 + 44]> */
		/* 821900A0h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R5 + 0x0000002C) );
		/* 821900A0h case    2:*/		return 0x821900A4;
		  /* 821900A4h */ case    3:  		/* cmplwi CR6, R4, 1 */
		/* 821900A4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000001);
		/* 821900A4h case    3:*/		return 0x821900A8;
		  /* 821900A8h */ case    4:  		/* bc 4, CR6_GT, 12 */
		/* 821900A8h case    4:*/		if ( !regs.CR[6].gt ) { return 0x821900B4;  }
		/* 821900A8h case    4:*/		return 0x821900AC;
		  /* 821900ACh */ case    5:  		/* lwz R7, <#[R5 + 48]> */
		/* 821900ACh case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R5 + 0x00000030) );
		/* 821900ACh case    5:*/		return 0x821900B0;
		  /* 821900B0h */ case    6:  		/* b 8 */
		/* 821900B0h case    6:*/		return 0x821900B8;
		/* 821900B0h case    6:*/		return 0x821900B4;
	}
	return 0x821900B4;
} // Block from 82190098h-821900B4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821900B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821900B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821900B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821900B4);
		  /* 821900B4h */ case    0:  		/* li R7, 0 */
		/* 821900B4h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821900B4h case    0:*/		return 0x821900B8;
	}
	return 0x821900B8;
} // Block from 821900B4h-821900B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821900B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821900B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821900B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821900B8);
		  /* 821900B8h */ case    0:  		/* lwz R11, <#[R6 + 12]> */
		/* 821900B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x0000000C) );
		/* 821900B8h case    0:*/		return 0x821900BC;
		  /* 821900BCh */ case    1:  		/* cmplwi CR0, R7, 0 */
		/* 821900BCh case    1:*/		cpu::op::cmplwi<0>(regs,regs.R7,0x00000000);
		/* 821900BCh case    1:*/		return 0x821900C0;
		  /* 821900C0h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 821900C0h case    2:*/		if ( regs.CR[0].eq ) { return 0x821900CC;  }
		/* 821900C0h case    2:*/		return 0x821900C4;
		  /* 821900C4h */ case    3:  		/* lwz R10, <#[R7 + 12]> */
		/* 821900C4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x0000000C) );
		/* 821900C4h case    3:*/		return 0x821900C8;
		  /* 821900C8h */ case    4:  		/* b 8 */
		/* 821900C8h case    4:*/		return 0x821900D0;
		/* 821900C8h case    4:*/		return 0x821900CC;
	}
	return 0x821900CC;
} // Block from 821900B8h-821900CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821900CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821900CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821900CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821900CC);
		  /* 821900CCh */ case    0:  		/* li R10, 0 */
		/* 821900CCh case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821900CCh case    0:*/		return 0x821900D0;
	}
	return 0x821900D0;
} // Block from 821900CCh-821900D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821900D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821900D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821900D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821900D0);
		  /* 821900D0h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 821900D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821900D0h case    0:*/		return 0x821900D4;
		  /* 821900D4h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821900D4h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821900D4h case    1:*/		return 0x821900D8;
		  /* 821900D8h */ case    2:  		/* cmplwi CR6, R11, 125 */
		/* 821900D8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821900D8h case    2:*/		return 0x821900DC;
		  /* 821900DCh */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 821900DCh case    3:*/		if ( regs.CR[6].eq ) { return 0x821900EC;  }
		/* 821900DCh case    3:*/		return 0x821900E0;
		  /* 821900E0h */ case    4:  		/* cmplwi CR6, R11, 124 */
		/* 821900E0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821900E0h case    4:*/		return 0x821900E4;
		  /* 821900E4h */ case    5:  		/* li R11, 0 */
		/* 821900E4h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821900E4h case    5:*/		return 0x821900E8;
		  /* 821900E8h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 821900E8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821900F0;  }
		/* 821900E8h case    6:*/		return 0x821900EC;
	}
	return 0x821900EC;
} // Block from 821900D0h-821900ECh (7 instructions)

//////////////////////////////////////////////////////
// Block at 821900ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821900EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821900EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821900EC);
		  /* 821900ECh */ case    0:  		/* li R11, 1 */
		/* 821900ECh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821900ECh case    0:*/		return 0x821900F0;
	}
	return 0x821900F0;
} // Block from 821900ECh-821900F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821900F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821900F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821900F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821900F0);
		  /* 821900F0h */ case    0:  		/* rlwinm R9, R11, 0, 24, 31 */
		/* 821900F0h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R9,regs.R11);
		/* 821900F0h case    0:*/		return 0x821900F4;
		  /* 821900F4h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 821900F4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821900F4h case    1:*/		return 0x821900F8;
		  /* 821900F8h */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 821900F8h case    2:*/		if ( regs.CR[6].eq ) { return 0x82190124;  }
		/* 821900F8h case    2:*/		return 0x821900FC;
		  /* 821900FCh */ case    3:  		/* lwz R11, <#[R10 + 8]> */
		/* 821900FCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 821900FCh case    3:*/		return 0x82190100;
		  /* 82190100h */ case    4:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82190100h case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82190100h case    4:*/		return 0x82190104;
		  /* 82190104h */ case    5:  		/* cmplwi CR6, R11, 125 */
		/* 82190104h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82190104h case    5:*/		return 0x82190108;
		  /* 82190108h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 82190108h case    6:*/		if ( regs.CR[6].eq ) { return 0x82190118;  }
		/* 82190108h case    6:*/		return 0x8219010C;
		  /* 8219010Ch */ case    7:  		/* cmplwi CR6, R11, 124 */
		/* 8219010Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 8219010Ch case    7:*/		return 0x82190110;
		  /* 82190110h */ case    8:  		/* li R11, 0 */
		/* 82190110h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82190110h case    8:*/		return 0x82190114;
		  /* 82190114h */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 82190114h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8219011C;  }
		/* 82190114h case    9:*/		return 0x82190118;
	}
	return 0x82190118;
} // Block from 821900F0h-82190118h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82190118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190118);
		  /* 82190118h */ case    0:  		/* li R11, 1 */
		/* 82190118h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82190118h case    0:*/		return 0x8219011C;
	}
	return 0x8219011C;
} // Block from 82190118h-8219011Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219011Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219011C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219011C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219011C);
		  /* 8219011Ch */ case    0:  		/* rlwinm R8, R11, 0, 24, 31 */
		/* 8219011Ch case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R8,regs.R11);
		/* 8219011Ch case    0:*/		return 0x82190120;
		  /* 82190120h */ case    1:  		/* b 8 */
		/* 82190120h case    1:*/		return 0x82190128;
		/* 82190120h case    1:*/		return 0x82190124;
	}
	return 0x82190124;
} // Block from 8219011Ch-82190124h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82190124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190124);
		  /* 82190124h */ case    0:  		/* li R8, 0 */
		/* 82190124h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82190124h case    0:*/		return 0x82190128;
	}
	return 0x82190128;
} // Block from 82190124h-82190128h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82190128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190128);
		  /* 82190128h */ case    0:  		/* rlwinm. R9, R9, 0, 24, 31 */
		/* 82190128h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R9);
		/* 82190128h case    0:*/		return 0x8219012C;
		  /* 8219012Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 8219012Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x82190138;  }
		/* 8219012Ch case    1:*/		return 0x82190130;
		  /* 82190130h */ case    2:  		/* rlwinm. R11, R8, 0, 24, 31 */
		/* 82190130h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R8);
		/* 82190130h case    2:*/		return 0x82190134;
		  /* 82190134h */ case    3:  		/* bc 12, CR0_EQ, 124 */
		/* 82190134h case    3:*/		if ( regs.CR[0].eq ) { return 0x821901B0;  }
		/* 82190134h case    3:*/		return 0x82190138;
	}
	return 0x82190138;
} // Block from 82190128h-82190138h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82190138h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190138);
		  /* 82190138h */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 82190138h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82190138h case    0:*/		return 0x8219013C;
		  /* 8219013Ch */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8219013Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8219014C;  }
		/* 8219013Ch case    1:*/		return 0x82190140;
		  /* 82190140h */ case    2:  		/* lwz R11, <#[R6]> */
		/* 82190140h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 82190140h case    2:*/		return 0x82190144;
		  /* 82190144h */ case    3:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 82190144h case    3:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 82190144h case    3:*/		return 0x82190148;
		  /* 82190148h */ case    4:  		/* bc 4, CR0_EQ, 24 */
		/* 82190148h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82190160;  }
		/* 82190148h case    4:*/		return 0x8219014C;
	}
	return 0x8219014C;
} // Block from 82190138h-8219014Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219014Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219014C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219014C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219014C);
		  /* 8219014Ch */ case    0:  		/* rlwinm. R11, R8, 0, 24, 31 */
		/* 8219014Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R8);
		/* 8219014Ch case    0:*/		return 0x82190150;
		  /* 82190150h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 82190150h case    1:*/		if ( regs.CR[0].eq ) { return 0x82190168;  }
		/* 82190150h case    1:*/		return 0x82190154;
		  /* 82190154h */ case    2:  		/* lwz R11, <#[R7]> */
		/* 82190154h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 82190154h case    2:*/		return 0x82190158;
		  /* 82190158h */ case    3:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 82190158h case    3:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 82190158h case    3:*/		return 0x8219015C;
		  /* 8219015Ch */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 8219015Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x82190168;  }
		/* 8219015Ch case    4:*/		return 0x82190160;
	}
	return 0x82190160;
} // Block from 8219014Ch-82190160h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82190160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190160);
		  /* 82190160h */ case    0:  		/* li R10, 1 */
		/* 82190160h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82190160h case    0:*/		return 0x82190164;
		  /* 82190164h */ case    1:  		/* b 8 */
		/* 82190164h case    1:*/		return 0x8219016C;
		/* 82190164h case    1:*/		return 0x82190168;
	}
	return 0x82190168;
} // Block from 82190160h-82190168h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82190168h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190168);
		  /* 82190168h */ case    0:  		/* li R10, 0 */
		/* 82190168h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82190168h case    0:*/		return 0x8219016C;
	}
	return 0x8219016C;
} // Block from 82190168h-8219016Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219016Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219016C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219016C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219016C);
		  /* 8219016Ch */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8219016Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8219016Ch case    0:*/		return 0x82190170;
		  /* 82190170h */ case    1:  		/* rlwinm R10, R10, 0, 24, 31 */
		/* 82190170h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82190170h case    1:*/		return 0x82190174;
		  /* 82190174h */ case    2:  		/* rlwinm R5, R11, 31, 31, 31 */
		/* 82190174h case    2:*/		cpu::op::rlwinm<0,31,31,31>(regs,&regs.R5,regs.R11);
		/* 82190174h case    2:*/		return 0x82190178;
		  /* 82190178h */ case    3:  		/* cmplw CR6, R10, R5 */
		/* 82190178h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R5);
		/* 82190178h case    3:*/		return 0x8219017C;
		  /* 8219017Ch */ case    4:  		/* bc 4, CR6_EQ, -1144 */
		/* 8219017Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x8218FD04;  }
		/* 8219017Ch case    4:*/		return 0x82190180;
		  /* 82190180h */ case    5:  		/* cmplwi CR6, R9, 0 */
		/* 82190180h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82190180h case    5:*/		return 0x82190184;
		  /* 82190184h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 82190184h case    6:*/		if ( regs.CR[6].eq ) { return 0x82190198;  }
		/* 82190184h case    6:*/		return 0x82190188;
		  /* 82190188h */ case    7:  		/* lwz R10, <#[R6]> */
		/* 82190188h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000000) );
		/* 82190188h case    7:*/		return 0x8219018C;
		  /* 8219018Ch */ case    8:  		/* xor R10, R10, R11 */
		/* 8219018Ch case    8:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8219018Ch case    8:*/		return 0x82190190;
		  /* 82190190h */ case    9:  		/* rlwinm. R10, R10, 0, 27, 28 */
		/* 82190190h case    9:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R10);
		/* 82190190h case    9:*/		return 0x82190194;
		  /* 82190194h */ case   10:  		/* bc 4, CR0_EQ, -1168 */
		/* 82190194h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8218FD04;  }
		/* 82190194h case   10:*/		return 0x82190198;
	}
	return 0x82190198;
} // Block from 8219016Ch-82190198h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82190198h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190198);
		  /* 82190198h */ case    0:  		/* rlwinm. R10, R8, 0, 24, 31 */
		/* 82190198h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R8);
		/* 82190198h case    0:*/		return 0x8219019C;
		  /* 8219019Ch */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 8219019Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821901B0;  }
		/* 8219019Ch case    1:*/		return 0x821901A0;
		  /* 821901A0h */ case    2:  		/* lwz R10, <#[R7]> */
		/* 821901A0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 821901A0h case    2:*/		return 0x821901A4;
		  /* 821901A4h */ case    3:  		/* xor R11, R10, R11 */
		/* 821901A4h case    3:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821901A4h case    3:*/		return 0x821901A8;
		  /* 821901A8h */ case    4:  		/* rlwinm. R11, R11, 0, 27, 28 */
		/* 821901A8h case    4:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R11);
		/* 821901A8h case    4:*/		return 0x821901AC;
		  /* 821901ACh */ case    5:  		/* bc 4, CR0_EQ, -1192 */
		/* 821901ACh case    5:*/		if ( !regs.CR[0].eq ) { return 0x8218FD04;  }
		/* 821901ACh case    5:*/		return 0x821901B0;
	}
	return 0x821901B0;
} // Block from 82190198h-821901B0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821901B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821901B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821901B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821901B0);
		  /* 821901B0h */ case    0:  		/* li R11, 0 */
		/* 821901B0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821901B0h case    0:*/		return 0x821901B4;
		  /* 821901B4h */ case    1:  		/* rlwinm R9, R31, 13, 29, 31 */
		/* 821901B4h case    1:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R9,regs.R31);
		/* 821901B4h case    1:*/		return 0x821901B8;
		  /* 821901B8h */ case    2:  		/* addi R10, R29, 44 */
		/* 821901B8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0x2C);
		/* 821901B8h case    2:*/		return 0x821901BC;
		  /* 821901BCh */ case    3:  		/* cmplw CR6, R11, R9 */
		/* 821901BCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 821901BCh case    3:*/		return 0x821901C0;
		  /* 821901C0h */ case    4:  		/* bc 4, CR6_LT, 128 */
		/* 821901C0h case    4:*/		if ( !regs.CR[6].lt ) { return 0x82190240;  }
		/* 821901C0h case    4:*/		return 0x821901C4;
		  /* 821901C4h */ case    5:  		/* lwz R8, <#[R10]> */
		/* 821901C4h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 821901C4h case    5:*/		return 0x821901C8;
		  /* 821901C8h */ case    6:  		/* lwz R8, <#[R8]> */
		/* 821901C8h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 821901C8h case    6:*/		return 0x821901CC;
		  /* 821901CCh */ case    7:  		/* rlwinm. R8, R8, 0, 28, 28 */
		/* 821901CCh case    7:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R8,regs.R8);
		/* 821901CCh case    7:*/		return 0x821901D0;
		  /* 821901D0h */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 821901D0h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821901E0;  }
		/* 821901D0h case    8:*/		return 0x821901D4;
		  /* 821901D4h */ case    9:  		/* addi R11, R11, 1 */
		/* 821901D4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821901D4h case    9:*/		return 0x821901D8;
		  /* 821901D8h */ case   10:  		/* addi R10, R10, 4 */
		/* 821901D8h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821901D8h case   10:*/		return 0x821901DC;
		  /* 821901DCh */ case   11:  		/* b -32 */
		/* 821901DCh case   11:*/		return 0x821901BC;
		/* 821901DCh case   11:*/		return 0x821901E0;
	}
	return 0x821901E0;
} // Block from 821901B0h-821901E0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821901E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821901E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821901E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821901E0);
		  /* 821901E0h */ case    0:  		/* mr R3, R29 */
		/* 821901E0h case    0:*/		regs.R3 = regs.R29;
		/* 821901E0h case    0:*/		return 0x821901E4;
		  /* 821901E4h */ case    1:  		/* bl -100044 */
		/* 821901E4h case    1:*/		regs.LR = 0x821901E8; return 0x82177B18;
		/* 821901E4h case    1:*/		return 0x821901E8;
		  /* 821901E8h */ case    2:  		/* or. R31, R3, R3 */
		/* 821901E8h case    2:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 821901E8h case    2:*/		return 0x821901EC;
		  /* 821901ECh */ case    3:  		/* bc 12, CR0_EQ, 84 */
		/* 821901ECh case    3:*/		if ( regs.CR[0].eq ) { return 0x82190240;  }
		/* 821901ECh case    3:*/		return 0x821901F0;
		  /* 821901F0h */ case    4:  		/* lwz R9, <#[R28 + 8]> */
		/* 821901F0h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 821901F0h case    4:*/		return 0x821901F4;
		  /* 821901F4h */ case    5:  		/* li R11, 0 */
		/* 821901F4h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821901F4h case    5:*/		return 0x821901F8;
		  /* 821901F8h */ case    6:  		/* addi R10, R28, 44 */
		/* 821901F8h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0x2C);
		/* 821901F8h case    6:*/		return 0x821901FC;
		  /* 821901FCh */ case    7:  		/* rlwinm R9, R9, 13, 29, 31 */
		/* 821901FCh case    7:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R9,regs.R9);
		/* 821901FCh case    7:*/		return 0x82190200;
		  /* 82190200h */ case    8:  		/* cmplw CR6, R11, R9 */
		/* 82190200h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82190200h case    8:*/		return 0x82190204;
		  /* 82190204h */ case    9:  		/* bc 4, CR6_LT, 60 */
		/* 82190204h case    9:*/		if ( !regs.CR[6].lt ) { return 0x82190240;  }
		/* 82190204h case    9:*/		return 0x82190208;
		  /* 82190208h */ case   10:  		/* lwz R8, <#[R10]> */
		/* 82190208h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82190208h case   10:*/		return 0x8219020C;
		  /* 8219020Ch */ case   11:  		/* lwz R8, <#[R8]> */
		/* 8219020Ch case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 8219020Ch case   11:*/		return 0x82190210;
		  /* 82190210h */ case   12:  		/* rlwinm. R8, R8, 0, 28, 28 */
		/* 82190210h case   12:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R8,regs.R8);
		/* 82190210h case   12:*/		return 0x82190214;
		  /* 82190214h */ case   13:  		/* bc 4, CR0_EQ, 16 */
		/* 82190214h case   13:*/		if ( !regs.CR[0].eq ) { return 0x82190224;  }
		/* 82190214h case   13:*/		return 0x82190218;
		  /* 82190218h */ case   14:  		/* addi R11, R11, 1 */
		/* 82190218h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82190218h case   14:*/		return 0x8219021C;
		  /* 8219021Ch */ case   15:  		/* addi R10, R10, 4 */
		/* 8219021Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8219021Ch case   15:*/		return 0x82190220;
		  /* 82190220h */ case   16:  		/* b -32 */
		/* 82190220h case   16:*/		return 0x82190200;
		/* 82190220h case   16:*/		return 0x82190224;
	}
	return 0x82190224;
} // Block from 821901E0h-82190224h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82190224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190224);
		  /* 82190224h */ case    0:  		/* mr R3, R28 */
		/* 82190224h case    0:*/		regs.R3 = regs.R28;
		/* 82190224h case    0:*/		return 0x82190228;
		  /* 82190228h */ case    1:  		/* bl -100112 */
		/* 82190228h case    1:*/		regs.LR = 0x8219022C; return 0x82177B18;
		/* 82190228h case    1:*/		return 0x8219022C;
		  /* 8219022Ch */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 8219022Ch case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8219022Ch case    2:*/		return 0x82190230;
		  /* 82190230h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 82190230h case    3:*/		if ( regs.CR[0].eq ) { return 0x82190240;  }
		/* 82190230h case    3:*/		return 0x82190234;
		  /* 82190234h */ case    4:  		/* cmplw CR6, R3, R31 */
		/* 82190234h case    4:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R31);
		/* 82190234h case    4:*/		return 0x82190238;
		  /* 82190238h */ case    5:  		/* li R3, 0 */
		/* 82190238h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82190238h case    5:*/		return 0x8219023C;
		  /* 8219023Ch */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 8219023Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x82190244;  }
		/* 8219023Ch case    6:*/		return 0x82190240;
	}
	return 0x82190240;
} // Block from 82190224h-82190240h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82190240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190240);
		  /* 82190240h */ case    0:  		/* li R3, 1 */
		/* 82190240h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82190240h case    0:*/		return 0x82190244;
	}
	return 0x82190244;
} // Block from 82190240h-82190244h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82190244h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190244( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190244) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190244);
		  /* 82190244h */ case    0:  		/* addi R1, R1, 128 */
		/* 82190244h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82190244h case    0:*/		return 0x82190248;
		  /* 82190248h */ case    1:  		/* b -1044384 */
		/* 82190248h case    1:*/		return 0x820912A8;
		/* 82190248h case    1:*/		return 0x8219024C;
		  /* 8219024Ch */ case    2:  		/* nop */
		/* 8219024Ch case    2:*/		cpu::op::nop();
		/* 8219024Ch case    2:*/		return 0x82190250;
	}
	return 0x82190250;
} // Block from 82190244h-82190250h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82190250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190250);
		  /* 82190250h */ case    0:  		/* mfspr R12, LR */
		/* 82190250h case    0:*/		regs.R12 = regs.LR;
		/* 82190250h case    0:*/		return 0x82190254;
		  /* 82190254h */ case    1:  		/* bl -1044472 */
		/* 82190254h case    1:*/		regs.LR = 0x82190258; return 0x8209125C;
		/* 82190254h case    1:*/		return 0x82190258;
	}
	return 0x82190258;
} // Block from 82190250h-82190258h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82190258h
// Function '?CanCoIssue@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190258);
		  /* 82190258h */ case    0:  		/* stwu R1, <#[R1 - 128]> */
		/* 82190258h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82190258h case    0:*/		return 0x8219025C;
		  /* 8219025Ch */ case    1:  		/* lwz R10, <#[R3 + 44]> */
		/* 8219025Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000002C) );
		/* 8219025Ch case    1:*/		return 0x82190260;
		  /* 82190260h */ case    2:  		/* mr R11, R3 */
		/* 82190260h case    2:*/		regs.R11 = regs.R3;
		/* 82190260h case    2:*/		return 0x82190264;
		  /* 82190264h */ case    3:  		/* lwz R31, <#[R3 + 48]> */
		/* 82190264h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000030) );
		/* 82190264h case    3:*/		return 0x82190268;
		  /* 82190268h */ case    4:  		/* lwz R7, <#[R10]> */
		/* 82190268h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 82190268h case    4:*/		return 0x8219026C;
		  /* 8219026Ch */ case    5:  		/* lwz R3, <#[R10 + 12]> */
		/* 8219026Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x0000000C) );
		/* 8219026Ch case    5:*/		return 0x82190270;
		  /* 82190270h */ case    6:  		/* lwz R5, <#[R31 + 12]> */
		/* 82190270h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 82190270h case    6:*/		return 0x82190274;
		  /* 82190274h */ case    7:  		/* rlwinm. R10, R7, 2, 31, 31 */
		/* 82190274h case    7:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R10,regs.R7);
		/* 82190274h case    7:*/		return 0x82190278;
		  /* 82190278h */ case    8:  		/* bc 12, CR0_EQ, 172 */
		/* 82190278h case    8:*/		if ( regs.CR[0].eq ) { return 0x82190324;  }
		/* 82190278h case    8:*/		return 0x8219027C;
		  /* 8219027Ch */ case    9:  		/* rlwinm R11, R11, 0, 0, 19 */
		/* 8219027Ch case    9:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R11);
		/* 8219027Ch case    9:*/		return 0x82190280;
		  /* 82190280h */ case   10:  		/* lwz R11, <#[R11]> */
		/* 82190280h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82190280h case   10:*/		return 0x82190284;
		  /* 82190284h */ case   11:  		/* lwz R11, <#[R11 + 148]> */
		/* 82190284h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000094) );
		/* 82190284h case   11:*/		return 0x82190288;
	}
	return 0x82190288;
} // Block from 82190258h-82190288h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82190288h
// Function '?FindTwoOperandScalarUseConstantMask@Instruction@D3DXShader@@QAAPAV12@PAI0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190288);
		  /* 82190288h */ case    0:  		/* lwz R11, <#[R11 + 44]> */
		/* 82190288h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 82190288h case    0:*/		return 0x8219028C;
		  /* 8219028Ch */ case    1:  		/* rlwinm. R11, R11, 25, 31, 31 */
		/* 8219028Ch case    1:*/		cpu::op::rlwinm<1,25,31,31>(regs,&regs.R11,regs.R11);
		/* 8219028Ch case    1:*/		return 0x82190290;
		  /* 82190290h */ case    2:  		/* bc 12, CR0_EQ, 148 */
		/* 82190290h case    2:*/		if ( regs.CR[0].eq ) { return 0x82190324;  }
		/* 82190290h case    2:*/		return 0x82190294;
		  /* 82190294h */ case    3:  		/* li R11, 0 */
		/* 82190294h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82190294h case    3:*/		return 0x82190298;
		  /* 82190298h */ case    4:  		/* rlwinm. R8, R7, 7, 29, 31 */
		/* 82190298h case    4:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R8,regs.R7);
		/* 82190298h case    4:*/		return 0x8219029C;
		  /* 8219029Ch */ case    5:  		/* mr R5, R11 */
		/* 8219029Ch case    5:*/		regs.R5 = regs.R11;
		/* 8219029Ch case    5:*/		return 0x821902A0;
		  /* 821902A0h */ case    6:  		/* li R30, 1 */
		/* 821902A0h case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 821902A0h case    6:*/		return 0x821902A4;
		  /* 821902A4h */ case    7:  		/* mr R10, R11 */
		/* 821902A4h case    7:*/		regs.R10 = regs.R11;
		/* 821902A4h case    7:*/		return 0x821902A8;
		  /* 821902A8h */ case    8:  		/* bc 12, CR0_EQ, 44 */
		/* 821902A8h case    8:*/		if ( regs.CR[0].eq ) { return 0x821902D4;  }
		/* 821902A8h case    8:*/		return 0x821902AC;
		  /* 821902ACh */ case    9:  		/* mr R9, R11 */
		/* 821902ACh case    9:*/		regs.R9 = regs.R11;
		/* 821902ACh case    9:*/		return 0x821902B0;
		  /* 821902B0h */ case   10:  		/* rlwinm R6, R7, 27, 24, 31 */
		/* 821902B0h case   10:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R7);
		/* 821902B0h case   10:*/		return 0x821902B4;
		  /* 821902B4h */ case   11:  		/* addi R10, R10, 1 */
		/* 821902B4h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821902B4h case   11:*/		return 0x821902B8;
		  /* 821902B8h */ case   12:  		/* srw R6, R6, R9 */
		/* 821902B8h case   12:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R6,regs.R9);
		/* 821902B8h case   12:*/		return 0x821902BC;
		  /* 821902BCh */ case   13:  		/* rlwinm R6, R6, 0, 30, 31 */
		/* 821902BCh case   13:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R6,regs.R6);
		/* 821902BCh case   13:*/		return 0x821902C0;
		  /* 821902C0h */ case   14:  		/* addi R9, R9, 2 */
		/* 821902C0h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x2);
		/* 821902C0h case   14:*/		return 0x821902C4;
		  /* 821902C4h */ case   15:  		/* slw R6, R30, R6 */
		/* 821902C4h case   15:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R30,regs.R6);
		/* 821902C4h case   15:*/		return 0x821902C8;
		  /* 821902C8h */ case   16:  		/* or R5, R6, R5 */
		/* 821902C8h case   16:*/		cpu::op::or<0>(regs,&regs.R5,regs.R6,regs.R5);
		/* 821902C8h case   16:*/		return 0x821902CC;
		  /* 821902CCh */ case   17:  		/* cmplw CR6, R10, R8 */
		/* 821902CCh case   17:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 821902CCh case   17:*/		return 0x821902D0;
		  /* 821902D0h */ case   18:  		/* bc 12, CR6_LT, -32 */
		/* 821902D0h case   18:*/		if ( regs.CR[6].lt ) { return 0x821902B0;  }
		/* 821902D0h case   18:*/		return 0x821902D4;
	}
	return 0x821902D4;
} // Block from 82190288h-821902D4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821902D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821902D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821902D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821902D4);
		  /* 821902D4h */ case    0:  		/* lwz R7, <#[R31]> */
		/* 821902D4h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000000) );
		/* 821902D4h case    0:*/		return 0x821902D8;
		  /* 821902D8h */ case    1:  		/* mr R8, R11 */
		/* 821902D8h case    1:*/		regs.R8 = regs.R11;
		/* 821902D8h case    1:*/		return 0x821902DC;
		  /* 821902DCh */ case    2:  		/* mr R10, R11 */
		/* 821902DCh case    2:*/		regs.R10 = regs.R11;
		/* 821902DCh case    2:*/		return 0x821902E0;
		  /* 821902E0h */ case    3:  		/* rlwinm. R6, R7, 7, 29, 31 */
		/* 821902E0h case    3:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R6,regs.R7);
		/* 821902E0h case    3:*/		return 0x821902E4;
		  /* 821902E4h */ case    4:  		/* bc 12, CR0_EQ, 44 */
		/* 821902E4h case    4:*/		if ( regs.CR[0].eq ) { return 0x82190310;  }
		/* 821902E4h case    4:*/		return 0x821902E8;
		  /* 821902E8h */ case    5:  		/* mr R9, R11 */
		/* 821902E8h case    5:*/		regs.R9 = regs.R11;
		/* 821902E8h case    5:*/		return 0x821902EC;
		  /* 821902ECh */ case    6:  		/* rlwinm R3, R7, 27, 24, 31 */
		/* 821902ECh case    6:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R3,regs.R7);
		/* 821902ECh case    6:*/		return 0x821902F0;
		  /* 821902F0h */ case    7:  		/* addi R10, R10, 1 */
		/* 821902F0h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821902F0h case    7:*/		return 0x821902F4;
		  /* 821902F4h */ case    8:  		/* srw R3, R3, R9 */
		/* 821902F4h case    8:*/		cpu::op::srw<0>(regs,&regs.R3,regs.R3,regs.R9);
		/* 821902F4h case    8:*/		return 0x821902F8;
		  /* 821902F8h */ case    9:  		/* rlwinm R3, R3, 0, 30, 31 */
		/* 821902F8h case    9:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R3,regs.R3);
		/* 821902F8h case    9:*/		return 0x821902FC;
		  /* 821902FCh */ case   10:  		/* addi R9, R9, 2 */
		/* 821902FCh case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x2);
		/* 821902FCh case   10:*/		return 0x82190300;
		  /* 82190300h */ case   11:  		/* slw R3, R30, R3 */
		/* 82190300h case   11:*/		cpu::op::slw<0>(regs,&regs.R3,regs.R30,regs.R3);
		/* 82190300h case   11:*/		return 0x82190304;
		  /* 82190304h */ case   12:  		/* or R8, R3, R8 */
		/* 82190304h case   12:*/		cpu::op::or<0>(regs,&regs.R8,regs.R3,regs.R8);
		/* 82190304h case   12:*/		return 0x82190308;
		  /* 82190308h */ case   13:  		/* cmplw CR6, R10, R6 */
		/* 82190308h case   13:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 82190308h case   13:*/		return 0x8219030C;
		  /* 8219030Ch */ case   14:  		/* bc 12, CR6_LT, -32 */
		/* 8219030Ch case   14:*/		if ( regs.CR[6].lt ) { return 0x821902EC;  }
		/* 8219030Ch case   14:*/		return 0x82190310;
	}
	return 0x82190310;
} // Block from 821902D4h-82190310h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82190310h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190310( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190310) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190310);
		  /* 82190310h */ case    0:  		/* and. R10, R8, R5 */
		/* 82190310h case    0:*/		cpu::op::and<1>(regs,&regs.R10,regs.R8,regs.R5);
		/* 82190310h case    0:*/		return 0x82190314;
		  /* 82190314h */ case    1:  		/* bc 4, CR0_EQ, 408 */
		/* 82190314h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821904AC;  }
		/* 82190314h case    1:*/		return 0x82190318;
		  /* 82190318h */ case    2:  		/* li R3, 1 */
		/* 82190318h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82190318h case    2:*/		return 0x8219031C;
		  /* 8219031Ch */ case    3:  		/* stb R11, <#[R4]> */
		/* 8219031Ch case    3:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8219031Ch case    3:*/		return 0x82190320;
		  /* 82190320h */ case    4:  		/* b 400 */
		/* 82190320h case    4:*/		return 0x821904B0;
		/* 82190320h case    4:*/		return 0x82190324;
	}
	return 0x82190324;
} // Block from 82190310h-82190324h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82190324h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190324( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190324) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190324);
		  /* 82190324h */ case    0:  		/* lwz R10, <#[R3 + 8]> */
		/* 82190324h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82190324h case    0:*/		return 0x82190328;
		  /* 82190328h */ case    1:  		/* li R11, 0 */
		/* 82190328h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82190328h case    1:*/		return 0x8219032C;
		  /* 8219032Ch */ case    2:  		/* li R30, 1 */
		/* 8219032Ch case    2:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 8219032Ch case    2:*/		return 0x82190330;
		  /* 82190330h */ case    3:  		/* rlwinm R10, R10, 25, 25, 31 */
		/* 82190330h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R10);
		/* 82190330h case    3:*/		return 0x82190334;
		  /* 82190334h */ case    4:  		/* cmpwi CR6, R10, 19 */
		/* 82190334h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000013);
		/* 82190334h case    4:*/		return 0x82190338;
		  /* 82190338h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 82190338h case    5:*/		if ( regs.CR[6].eq ) { return 0x8219034C;  }
		/* 82190338h case    5:*/		return 0x8219033C;
		  /* 8219033Ch */ case    6:  		/* cmpwi CR6, R10, 29 */
		/* 8219033Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000001D);
		/* 8219033Ch case    6:*/		return 0x82190340;
		  /* 82190340h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 82190340h case    7:*/		if ( regs.CR[6].eq ) { return 0x8219034C;  }
		/* 82190340h case    7:*/		return 0x82190344;
		  /* 82190344h */ case    8:  		/* cmpwi CR6, R10, 113 */
		/* 82190344h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000071);
		/* 82190344h case    8:*/		return 0x82190348;
		  /* 82190348h */ case    9:  		/* bc 4, CR6_EQ, 148 */
		/* 82190348h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821903DC;  }
		/* 82190348h case    9:*/		return 0x8219034C;
	}
	return 0x8219034C;
} // Block from 82190324h-8219034Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219034Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219034C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219034C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219034C);
		  /* 8219034Ch */ case    0:  		/* rlwinm. R6, R7, 7, 29, 31 */
		/* 8219034Ch case    0:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R6,regs.R7);
		/* 8219034Ch case    0:*/		return 0x82190350;
		  /* 82190350h */ case    1:  		/* mr R10, R11 */
		/* 82190350h case    1:*/		regs.R10 = regs.R11;
		/* 82190350h case    1:*/		return 0x82190354;
		  /* 82190354h */ case    2:  		/* bc 12, CR0_EQ, 44 */
		/* 82190354h case    2:*/		if ( regs.CR[0].eq ) { return 0x82190380;  }
		/* 82190354h case    2:*/		return 0x82190358;
		  /* 82190358h */ case    3:  		/* mr R9, R11 */
		/* 82190358h case    3:*/		regs.R9 = regs.R11;
		/* 82190358h case    3:*/		return 0x8219035C;
		  /* 8219035Ch */ case    4:  		/* rlwinm R8, R7, 27, 24, 31 */
		/* 8219035Ch case    4:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R8,regs.R7);
		/* 8219035Ch case    4:*/		return 0x82190360;
		  /* 82190360h */ case    5:  		/* srw R8, R8, R9 */
		/* 82190360h case    5:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R8,regs.R9);
		/* 82190360h case    5:*/		return 0x82190364;
		  /* 82190364h */ case    6:  		/* rlwinm R8, R8, 0, 30, 31 */
		/* 82190364h case    6:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R8,regs.R8);
		/* 82190364h case    6:*/		return 0x82190368;
		  /* 82190368h */ case    7:  		/* cmpw CR6, R8, R10 */
		/* 82190368h case    7:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R10);
		/* 82190368h case    7:*/		return 0x8219036C;
		  /* 8219036Ch */ case    8:  		/* bc 4, CR6_EQ, 200 */
		/* 8219036Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x82190434;  }
		/* 8219036Ch case    8:*/		return 0x82190370;
		  /* 82190370h */ case    9:  		/* addi R10, R10, 1 */
		/* 82190370h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82190370h case    9:*/		return 0x82190374;
		  /* 82190374h */ case   10:  		/* addi R9, R9, 2 */
		/* 82190374h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x2);
		/* 82190374h case   10:*/		return 0x82190378;
		  /* 82190378h */ case   11:  		/* cmplw CR6, R10, R6 */
		/* 82190378h case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 82190378h case   11:*/		return 0x8219037C;
		  /* 8219037Ch */ case   12:  		/* bc 12, CR6_LT, -32 */
		/* 8219037Ch case   12:*/		if ( regs.CR[6].lt ) { return 0x8219035C;  }
		/* 8219037Ch case   12:*/		return 0x82190380;
	}
	return 0x82190380;
} // Block from 8219034Ch-82190380h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82190380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190380);
		  /* 82190380h */ case    0:  		/* mr R10, R11 */
		/* 82190380h case    0:*/		regs.R10 = regs.R11;
		/* 82190380h case    0:*/		return 0x82190384;
		  /* 82190384h */ case    1:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82190384h case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82190384h case    1:*/		return 0x82190388;
		  /* 82190388h */ case    2:  		/* bc 4, CR0_EQ, 292 */
		/* 82190388h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821904AC;  }
		/* 82190388h case    2:*/		return 0x8219038C;
		  /* 8219038Ch */ case    3:  		/* lwz R10, <#[R5 + 8]> */
		/* 8219038Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000008) );
		/* 8219038Ch case    3:*/		return 0x82190390;
		  /* 82190390h */ case    4:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 82190390h case    4:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 82190390h case    4:*/		return 0x82190394;
		  /* 82190394h */ case    5:  		/* cmplwi CR6, R10, 15872 */
		/* 82190394h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003E00);
		/* 82190394h case    5:*/		return 0x82190398;
		  /* 82190398h */ case    6:  		/* bc 4, CR6_EQ, 276 */
		/* 82190398h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821904AC;  }
		/* 82190398h case    6:*/		return 0x8219039C;
		  /* 8219039Ch */ case    7:  		/* mr R9, R11 */
		/* 8219039Ch case    7:*/		regs.R9 = regs.R11;
		/* 8219039Ch case    7:*/		return 0x821903A0;
		  /* 821903A0h */ case    8:  		/* cmplwi CR6, R6, 0 */
		/* 821903A0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 821903A0h case    8:*/		return 0x821903A4;
		  /* 821903A4h */ case    9:  		/* bc 12, CR6_EQ, 52 */
		/* 821903A4h case    9:*/		if ( regs.CR[6].eq ) { return 0x821903D8;  }
		/* 821903A4h case    9:*/		return 0x821903A8;
		  /* 821903A8h */ case   10:  		/* lwz R8, <#[R31]> */
		/* 821903A8h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 821903A8h case   10:*/		return 0x821903AC;
		  /* 821903ACh */ case   11:  		/* mr R10, R11 */
		/* 821903ACh case   11:*/		regs.R10 = regs.R11;
		/* 821903ACh case   11:*/		return 0x821903B0;
	}
	return 0x821903B0;
} // Block from 82190380h-821903B0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821903B0h
// Function '?CanPossiblyCauseConstantWaterfall@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821903B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821903B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821903B0);
		  /* 821903B0h */ case    0:  		/* rlwinm R8, R8, 27, 24, 31 */
		/* 821903B0h case    0:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R8,regs.R8);
		/* 821903B0h case    0:*/		return 0x821903B4;
		  /* 821903B4h */ case    1:  		/* rlwinm R29, R7, 27, 24, 31 */
		/* 821903B4h case    1:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R29,regs.R7);
		/* 821903B4h case    1:*/		return 0x821903B8;
		  /* 821903B8h */ case    2:  		/* xor R29, R29, R8 */
		/* 821903B8h case    2:*/		cpu::op::xor<0>(regs,&regs.R29,regs.R29,regs.R8);
		/* 821903B8h case    2:*/		return 0x821903BC;
		  /* 821903BCh */ case    3:  		/* srw R29, R29, R10 */
		/* 821903BCh case    3:*/		cpu::op::srw<0>(regs,&regs.R29,regs.R29,regs.R10);
		/* 821903BCh case    3:*/		return 0x821903C0;
		  /* 821903C0h */ case    4:  		/* rlwinm. R29, R29, 0, 30, 31 */
		/* 821903C0h case    4:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R29,regs.R29);
		/* 821903C0h case    4:*/		return 0x821903C4;
		  /* 821903C4h */ case    5:  		/* bc 12, CR0_EQ, 232 */
		/* 821903C4h case    5:*/		if ( regs.CR[0].eq ) { return 0x821904AC;  }
		/* 821903C4h case    5:*/		return 0x821903C8;
		  /* 821903C8h */ case    6:  		/* addi R9, R9, 1 */
		/* 821903C8h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 821903C8h case    6:*/		return 0x821903CC;
		  /* 821903CCh */ case    7:  		/* addi R10, R10, 2 */
		/* 821903CCh case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 821903CCh case    7:*/		return 0x821903D0;
		  /* 821903D0h */ case    8:  		/* cmplw CR6, R9, R6 */
		/* 821903D0h case    8:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 821903D0h case    8:*/		return 0x821903D4;
		  /* 821903D4h */ case    9:  		/* bc 12, CR6_LT, -32 */
		/* 821903D4h case    9:*/		if ( regs.CR[6].lt ) { return 0x821903B4;  }
		/* 821903D4h case    9:*/		return 0x821903D8;
	}
	return 0x821903D8;
} // Block from 821903B0h-821903D8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821903D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821903D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821903D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821903D8);
		  /* 821903D8h */ case    0:  		/* stb R11, <#[R4]> */
		/* 821903D8h case    0:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 821903D8h case    0:*/		return 0x821903DC;
	}
	return 0x821903DC;
} // Block from 821903D8h-821903DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821903DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821903DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821903DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821903DC);
		  /* 821903DCh */ case    0:  		/* stw R11, <#[R1 + 80]> */
		/* 821903DCh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821903DCh case    0:*/		return 0x821903E0;
		  /* 821903E0h */ case    1:  		/* stw R11, <#[R1 + 84]> */
		/* 821903E0h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 821903E0h case    1:*/		return 0x821903E4;
		  /* 821903E4h */ case    2:  		/* lwz R10, <#[R5 + 8]> */
		/* 821903E4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000008) );
		/* 821903E4h case    2:*/		return 0x821903E8;
		  /* 821903E8h */ case    3:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 821903E8h case    3:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 821903E8h case    3:*/		return 0x821903EC;
		  /* 821903ECh */ case    4:  		/* cmplwi CR6, R10, 15872 */
		/* 821903ECh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003E00);
		/* 821903ECh case    4:*/		return 0x821903F0;
		  /* 821903F0h */ case    5:  		/* bc 4, CR6_EQ, 76 */
		/* 821903F0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8219043C;  }
		/* 821903F0h case    5:*/		return 0x821903F4;
		  /* 821903F4h */ case    6:  		/* lwz R8, <#[R31]> */
		/* 821903F4h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 821903F4h case    6:*/		return 0x821903F8;
		  /* 821903F8h */ case    7:  		/* mr R9, R11 */
		/* 821903F8h case    7:*/		regs.R9 = regs.R11;
		/* 821903F8h case    7:*/		return 0x821903FC;
		  /* 821903FCh */ case    8:  		/* rlwinm. R7, R8, 7, 29, 31 */
		/* 821903FCh case    8:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R7,regs.R8);
		/* 821903FCh case    8:*/		return 0x82190400;
		  /* 82190400h */ case    9:  		/* bc 12, CR0_EQ, 44 */
		/* 82190400h case    9:*/		if ( regs.CR[0].eq ) { return 0x8219042C;  }
		/* 82190400h case    9:*/		return 0x82190404;
		  /* 82190404h */ case   10:  		/* mr R10, R11 */
		/* 82190404h case   10:*/		regs.R10 = regs.R11;
		/* 82190404h case   10:*/		return 0x82190408;
		  /* 82190408h */ case   11:  		/* rlwinm R6, R8, 27, 24, 31 */
		/* 82190408h case   11:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R8);
		/* 82190408h case   11:*/		return 0x8219040C;
		  /* 8219040Ch */ case   12:  		/* addi R11, R11, 1 */
		/* 8219040Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219040Ch case   12:*/		return 0x82190410;
		  /* 82190410h */ case   13:  		/* srw R6, R6, R10 */
		/* 82190410h case   13:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R6,regs.R10);
		/* 82190410h case   13:*/		return 0x82190414;
		  /* 82190414h */ case   14:  		/* rlwinm R6, R6, 0, 30, 31 */
		/* 82190414h case   14:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R6,regs.R6);
		/* 82190414h case   14:*/		return 0x82190418;
		  /* 82190418h */ case   15:  		/* addi R10, R10, 2 */
		/* 82190418h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82190418h case   15:*/		return 0x8219041C;
		  /* 8219041Ch */ case   16:  		/* slw R6, R30, R6 */
		/* 8219041Ch case   16:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R30,regs.R6);
		/* 8219041Ch case   16:*/		return 0x82190420;
	}
	return 0x82190420;
} // Block from 821903DCh-82190420h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82190420h
// Function '?RecomputePathLength@Instruction@D3DXShader@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190420);
		  /* 82190420h */ case    0:  		/* or R9, R6, R9 */
		/* 82190420h case    0:*/		cpu::op::or<0>(regs,&regs.R9,regs.R6,regs.R9);
		/* 82190420h case    0:*/		return 0x82190424;
		  /* 82190424h */ case    1:  		/* cmplw CR6, R11, R7 */
		/* 82190424h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 82190424h case    1:*/		return 0x82190428;
		  /* 82190428h */ case    2:  		/* bc 12, CR6_LT, -32 */
		/* 82190428h case    2:*/		if ( regs.CR[6].lt ) { return 0x82190408;  }
		/* 82190428h case    2:*/		return 0x8219042C;
	}
	return 0x8219042C;
} // Block from 82190420h-8219042Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219042Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219042C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219042C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219042C);
		  /* 8219042Ch */ case    0:  		/* stw R9, <#[R1 + 80]> */
		/* 8219042Ch case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 8219042Ch case    0:*/		return 0x82190430;
		  /* 82190430h */ case    1:  		/* b 24 */
		/* 82190430h case    1:*/		return 0x82190448;
		/* 82190430h case    1:*/		return 0x82190434;
	}
	return 0x82190434;
} // Block from 8219042Ch-82190434h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82190434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190434);
		  /* 82190434h */ case    0:  		/* mr R10, R30 */
		/* 82190434h case    0:*/		regs.R10 = regs.R30;
		/* 82190434h case    0:*/		return 0x82190438;
		  /* 82190438h */ case    1:  		/* b -180 */
		/* 82190438h case    1:*/		return 0x82190384;
		/* 82190438h case    1:*/		return 0x8219043C;
	}
	return 0x8219043C;
} // Block from 82190434h-8219043Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219043Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219043C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219043C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219043C);
		  /* 8219043Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8219043Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219043Ch case    0:*/		return 0x82190440;
		  /* 82190440h */ case    1:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 82190440h case    1:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 82190440h case    1:*/		return 0x82190444;
		  /* 82190444h */ case    2:  		/* stw R11, <#[R1 + 84]> */
		/* 82190444h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82190444h case    2:*/		return 0x82190448;
	}
	return 0x82190448;
} // Block from 8219043Ch-82190448h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82190448h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190448);
		  /* 82190448h */ case    0:  		/* addi R5, R1, 84 */
		/* 82190448h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 82190448h case    0:*/		return 0x8219044C;
		  /* 8219044Ch */ case    1:  		/* addi R4, R1, 80 */
		/* 8219044Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8219044Ch case    1:*/		return 0x82190450;
		  /* 82190450h */ case    2:  		/* bl -2912 */
		/* 82190450h case    2:*/		regs.LR = 0x82190454; return 0x8218F8F0;
		/* 82190450h case    2:*/		return 0x82190454;
		  /* 82190454h */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 82190454h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82190454h case    3:*/		return 0x82190458;
		  /* 82190458h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 82190458h case    4:*/		if ( regs.CR[0].eq ) { return 0x82190468;  }
		/* 82190458h case    4:*/		return 0x8219045C;
		  /* 8219045Ch */ case    5:  		/* addi R5, R1, 84 */
		/* 8219045Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 8219045Ch case    5:*/		return 0x82190460;
		  /* 82190460h */ case    6:  		/* addi R4, R1, 80 */
		/* 82190460h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82190460h case    6:*/		return 0x82190464;
		  /* 82190464h */ case    7:  		/* bl -2932 */
		/* 82190464h case    7:*/		regs.LR = 0x82190468; return 0x8218F8F0;
		/* 82190464h case    7:*/		return 0x82190468;
	}
	return 0x82190468;
} // Block from 82190448h-82190468h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82190468h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190468);
		  /* 82190468h */ case    0:  		/* lis R10, -28311 */
		/* 82190468h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF9169);
		/* 82190468h case    0:*/		return 0x8219046C;
		  /* 8219046Ch */ case    1:  		/* lwz R9, <#[R1 + 80]> */
		/* 8219046Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 8219046Ch case    1:*/		return 0x82190470;
		  /* 82190470h */ case    2:  		/* lis R8, 0 */
		/* 82190470h case    2:*/		cpu::op::lis<0>(regs,&regs.R8,0x0);
		/* 82190470h case    2:*/		return 0x82190474;
		  /* 82190474h */ case    3:  		/* lwz R11, <#[R1 + 84]> */
		/* 82190474h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82190474h case    3:*/		return 0x82190478;
		  /* 82190478h */ case    4:  		/* ori R10, R10, 5192 */
		/* 82190478h case    4:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1448);
		/* 82190478h case    4:*/		return 0x8219047C;
		  /* 8219047Ch */ case    5:  		/* ori R8, R8, 36262 */
		/* 8219047Ch case    5:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x8DA6);
		/* 8219047Ch case    5:*/		return 0x82190480;
		  /* 82190480h */ case    6:  		/* rldimi R10, R8, 32, 0 */
		/* 82190480h case    6:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R10,regs.R8);
		/* 82190480h case    6:*/		return 0x82190484;
		  /* 82190484h */ case    7:  		/* li R8, 4 */
		/* 82190484h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 82190484h case    7:*/		return 0x82190488;
		  /* 82190488h */ case    8:  		/* srd R10, R10, R9 */
		/* 82190488h case    8:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82190488h case    8:*/		return 0x8219048C;
		  /* 8219048Ch */ case    9:  		/* srd R10, R10, R9 */
		/* 8219048Ch case    9:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8219048Ch case    9:*/		return 0x82190490;
		  /* 82190490h */ case   10:  		/* srd R10, R10, R9 */
		/* 82190490h case   10:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82190490h case   10:*/		return 0x82190494;
		  /* 82190494h */ case   11:  		/* rlwinm R10, R10, 0, 29, 31 */
		/* 82190494h case   11:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R10);
		/* 82190494h case   11:*/		return 0x82190498;
		  /* 82190498h */ case   12:  		/* add R11, R10, R11 */
		/* 82190498h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82190498h case   12:*/		return 0x8219049C;
		  /* 8219049Ch */ case   13:  		/* subfc R11, R8, R11 */
		/* 8219049Ch case   13:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 8219049Ch case   13:*/		return 0x821904A0;
		  /* 821904A0h */ case   14:  		/* subfe R11, R11, R11 */
		/* 821904A0h case   14:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 821904A0h case   14:*/		return 0x821904A4;
		  /* 821904A4h */ case   15:  		/* rlwinm R3, R11, 0, 31, 31 */
		/* 821904A4h case   15:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R11);
		/* 821904A4h case   15:*/		return 0x821904A8;
		  /* 821904A8h */ case   16:  		/* b 8 */
		/* 821904A8h case   16:*/		return 0x821904B0;
		/* 821904A8h case   16:*/		return 0x821904AC;
	}
	return 0x821904AC;
} // Block from 82190468h-821904ACh (17 instructions)

//////////////////////////////////////////////////////
// Block at 821904ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821904AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821904AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821904AC);
		  /* 821904ACh */ case    0:  		/* li R3, 0 */
		/* 821904ACh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821904ACh case    0:*/		return 0x821904B0;
	}
	return 0x821904B0;
} // Block from 821904ACh-821904B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821904B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821904B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821904B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821904B0);
		  /* 821904B0h */ case    0:  		/* addi R1, R1, 128 */
		/* 821904B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821904B0h case    0:*/		return 0x821904B4;
		  /* 821904B4h */ case    1:  		/* b -1045000 */
		/* 821904B4h case    1:*/		return 0x820912AC;
		/* 821904B4h case    1:*/		return 0x821904B8;
	}
	return 0x821904B8;
} // Block from 821904B0h-821904B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821904B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821904B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821904B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821904B8);
		  /* 821904B8h */ case    0:  		/* mfspr R12, LR */
		/* 821904B8h case    0:*/		regs.R12 = regs.LR;
		/* 821904B8h case    0:*/		return 0x821904BC;
		  /* 821904BCh */ case    1:  		/* bl -1045096 */
		/* 821904BCh case    1:*/		regs.LR = 0x821904C0; return 0x82091254;
		/* 821904BCh case    1:*/		return 0x821904C0;
		  /* 821904C0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821904C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821904C0h case    2:*/		return 0x821904C4;
		  /* 821904C4h */ case    3:  		/* lwz R28, <#[R4]> */
		/* 821904C4h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R4 + 0x00000000) );
		/* 821904C4h case    3:*/		return 0x821904C8;
		  /* 821904C8h */ case    4:  		/* mr R27, R3 */
		/* 821904C8h case    4:*/		regs.R27 = regs.R3;
		/* 821904C8h case    4:*/		return 0x821904CC;
		  /* 821904CCh */ case    5:  		/* mr R29, R4 */
		/* 821904CCh case    5:*/		regs.R29 = regs.R4;
		/* 821904CCh case    5:*/		return 0x821904D0;
		  /* 821904D0h */ case    6:  		/* cmplwi CR6, R28, 0 */
		/* 821904D0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 821904D0h case    6:*/		return 0x821904D4;
		  /* 821904D4h */ case    7:  		/* bc 12, CR6_EQ, 200 */
		/* 821904D4h case    7:*/		if ( regs.CR[6].eq ) { return 0x8219059C;  }
		/* 821904D4h case    7:*/		return 0x821904D8;
		  /* 821904D8h */ case    8:  		/* lwz R11, <#[R28]> */
		/* 821904D8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821904D8h case    8:*/		return 0x821904DC;
		  /* 821904DCh */ case    9:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 821904DCh case    9:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 821904DCh case    9:*/		return 0x821904E0;
	}
	return 0x821904E0;
} // Block from 821904B8h-821904E0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821904E0h
// Function '?ScheduleInstruction@MachineState@D3DXShader@@QAAXPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821904E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821904E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821904E0);
		  /* 821904E0h */ case    0:  		/* bc 12, CR0_EQ, 16 */
		/* 821904E0h case    0:*/		if ( regs.CR[0].eq ) { return 0x821904F0;  }
		/* 821904E0h case    0:*/		return 0x821904E4;
		  /* 821904E4h */ case    1:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821904E4h case    1:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821904E4h case    1:*/		return 0x821904E8;
		  /* 821904E8h */ case    2:  		/* li R11, 1 */
		/* 821904E8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821904E8h case    2:*/		return 0x821904EC;
		  /* 821904ECh */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 821904ECh case    3:*/		if ( regs.CR[0].eq ) { return 0x821904F4;  }
		/* 821904ECh case    3:*/		return 0x821904F0;
	}
	return 0x821904F0;
} // Block from 821904E0h-821904F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821904F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821904F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821904F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821904F0);
		  /* 821904F0h */ case    0:  		/* li R11, 0 */
		/* 821904F0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821904F0h case    0:*/		return 0x821904F4;
	}
	return 0x821904F4;
} // Block from 821904F0h-821904F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821904F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821904F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821904F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821904F4);
		  /* 821904F4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821904F4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821904F4h case    0:*/		return 0x821904F8;
		  /* 821904F8h */ case    1:  		/* bc 12, CR0_EQ, 156 */
		/* 821904F8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82190594;  }
		/* 821904F8h case    1:*/		return 0x821904FC;
		  /* 821904FCh */ case    2:  		/* lwz R30, <#[R28 + 12]> */
		/* 821904FCh case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x0000000C) );
		/* 821904FCh case    2:*/		return 0x82190500;
		  /* 82190500h */ case    3:  		/* lwz R31, <#[R30 + 4]> */
		/* 82190500h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000004) );
		/* 82190500h case    3:*/		return 0x82190504;
		  /* 82190504h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 82190504h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82190504h case    4:*/		return 0x82190508;
		  /* 82190508h */ case    5:  		/* bc 12, CR6_EQ, 96 */
		/* 82190508h case    5:*/		if ( regs.CR[6].eq ) { return 0x82190568;  }
		/* 82190508h case    5:*/		return 0x8219050C;
		  /* 8219050Ch */ case    6:  		/* lwz R4, <#[R31 + 16]> */
		/* 8219050Ch case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 8219050Ch case    6:*/		return 0x82190510;
		  /* 82190510h */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 82190510h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82190510h case    7:*/		return 0x82190514;
		  /* 82190514h */ case    8:  		/* bc 12, CR6_EQ, 76 */
		/* 82190514h case    8:*/		if ( regs.CR[6].eq ) { return 0x82190560;  }
		/* 82190514h case    8:*/		return 0x82190518;
		  /* 82190518h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 82190518h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82190518h case    9:*/		return 0x8219051C;
		  /* 8219051Ch */ case   10:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 8219051Ch case   10:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 8219051Ch case   10:*/		return 0x82190520;
		  /* 82190520h */ case   11:  		/* bc 12, CR0_EQ, 16 */
		/* 82190520h case   11:*/		if ( regs.CR[0].eq ) { return 0x82190530;  }
		/* 82190520h case   11:*/		return 0x82190524;
		  /* 82190524h */ case   12:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82190524h case   12:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82190524h case   12:*/		return 0x82190528;
		  /* 82190528h */ case   13:  		/* li R11, 1 */
		/* 82190528h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82190528h case   13:*/		return 0x8219052C;
		  /* 8219052Ch */ case   14:  		/* bc 12, CR0_EQ, 8 */
		/* 8219052Ch case   14:*/		if ( regs.CR[0].eq ) { return 0x82190534;  }
		/* 8219052Ch case   14:*/		return 0x82190530;
	}
	return 0x82190530;
} // Block from 821904F4h-82190530h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82190530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190530);
		  /* 82190530h */ case    0:  		/* li R11, 0 */
		/* 82190530h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82190530h case    0:*/		return 0x82190534;
	}
	return 0x82190534;
} // Block from 82190530h-82190534h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82190534h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190534( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190534) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190534);
		  /* 82190534h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82190534h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82190534h case    0:*/		return 0x82190538;
		  /* 82190538h */ case    1:  		/* bc 12, CR0_EQ, 40 */
		/* 82190538h case    1:*/		if ( regs.CR[0].eq ) { return 0x82190560;  }
		/* 82190538h case    1:*/		return 0x8219053C;
		  /* 8219053Ch */ case    2:  		/* cmplw CR6, R4, R29 */
		/* 8219053Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R29);
		/* 8219053Ch case    2:*/		return 0x82190540;
		  /* 82190540h */ case    3:  		/* bc 12, CR6_EQ, 32 */
		/* 82190540h case    3:*/		if ( regs.CR[6].eq ) { return 0x82190560;  }
		/* 82190540h case    3:*/		return 0x82190544;
		  /* 82190544h */ case    4:  		/* lbz R11, <#[R4 + 16]> */
		/* 82190544h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 82190544h case    4:*/		return 0x82190548;
		  /* 82190548h */ case    5:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82190548h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82190548h case    5:*/		return 0x8219054C;
		  /* 8219054Ch */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 8219054Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x82190560;  }
		/* 8219054Ch case    6:*/		return 0x82190550;
		  /* 82190550h */ case    7:  		/* mr R3, R29 */
		/* 82190550h case    7:*/		regs.R3 = regs.R29;
		/* 82190550h case    7:*/		return 0x82190554;
		  /* 82190554h */ case    8:  		/* bl -126092 */
		/* 82190554h case    8:*/		regs.LR = 0x82190558; return 0x821718C8;
		/* 82190554h case    8:*/		return 0x82190558;
		  /* 82190558h */ case    9:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82190558h case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82190558h case    9:*/		return 0x8219055C;
		  /* 8219055Ch */ case   10:  		/* bc 4, CR0_EQ, 56 */
		/* 8219055Ch case   10:*/		if ( !regs.CR[0].eq ) { return 0x82190594;  }
		/* 8219055Ch case   10:*/		return 0x82190560;
	}
	return 0x82190560;
} // Block from 82190534h-82190560h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82190560h
// Function '?GetPredicateInstruction@Scheduler@D3DXShader@@QAAPAVInstruction@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190560);
		  /* 82190560h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 82190560h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 82190560h case    0:*/		return 0x82190564;
		  /* 82190564h */ case    1:  		/* b -96 */
		/* 82190564h case    1:*/		return 0x82190504;
		/* 82190564h case    1:*/		return 0x82190568;
	}
	return 0x82190568;
} // Block from 82190560h-82190568h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82190568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190568);
		  /* 82190568h */ case    0:  		/* li R10, 0 */
		/* 82190568h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82190568h case    0:*/		return 0x8219056C;
		  /* 8219056Ch */ case    1:  		/* addi R11, R27, 4 */
		/* 8219056Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x4);
		/* 8219056Ch case    1:*/		return 0x82190570;
		  /* 82190570h */ case    2:  		/* lwz R9, <#[R11]> */
		/* 82190570h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82190570h case    2:*/		return 0x82190574;
		  /* 82190574h */ case    3:  		/* cmplw CR6, R30, R9 */
		/* 82190574h case    3:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R9);
		/* 82190574h case    3:*/		return 0x82190578;
		  /* 82190578h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 82190578h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82190584;  }
		/* 82190578h case    4:*/		return 0x8219057C;
		  /* 8219057Ch */ case    5:  		/* li R9, 0 */
		/* 8219057Ch case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8219057Ch case    5:*/		return 0x82190580;
		  /* 82190580h */ case    6:  		/* stw R9, <#[R11]> */
		/* 82190580h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82190580h case    6:*/		return 0x82190584;
	}
	return 0x82190584;
} // Block from 82190568h-82190584h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82190584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190584);
		  /* 82190584h */ case    0:  		/* addi R10, R10, 1 */
		/* 82190584h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82190584h case    0:*/		return 0x82190588;
		  /* 82190588h */ case    1:  		/* addi R11, R11, 4 */
		/* 82190588h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82190588h case    1:*/		return 0x8219058C;
		  /* 8219058Ch */ case    2:  		/* cmplwi CR6, R10, 9 */
		/* 8219058Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000009);
		/* 8219058Ch case    2:*/		return 0x82190590;
		  /* 82190590h */ case    3:  		/* bc 12, CR6_LT, -32 */
		/* 82190590h case    3:*/		if ( regs.CR[6].lt ) { return 0x82190570;  }
		/* 82190590h case    3:*/		return 0x82190594;
	}
	return 0x82190594;
} // Block from 82190584h-82190594h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82190594h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190594( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190594) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190594);
		  /* 82190594h */ case    0:  		/* lwz R28, <#[R28 + 4]> */
		/* 82190594h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x00000004) );
		/* 82190594h case    0:*/		return 0x82190598;
		  /* 82190598h */ case    1:  		/* b -200 */
		/* 82190598h case    1:*/		return 0x821904D0;
		/* 82190598h case    1:*/		return 0x8219059C;
	}
	return 0x8219059C;
} // Block from 82190594h-8219059Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219059Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219059C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219059C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219059C);
		  /* 8219059Ch */ case    0:  		/* mr R4, R29 */
		/* 8219059Ch case    0:*/		regs.R4 = regs.R29;
		/* 8219059Ch case    0:*/		return 0x821905A0;
		  /* 821905A0h */ case    1:  		/* mr R3, R27 */
		/* 821905A0h case    1:*/		regs.R3 = regs.R27;
		/* 821905A0h case    1:*/		return 0x821905A4;
		  /* 821905A4h */ case    2:  		/* bl -136868 */
		/* 821905A4h case    2:*/		regs.LR = 0x821905A8; return 0x8216EF00;
		/* 821905A4h case    2:*/		return 0x821905A8;
		  /* 821905A8h */ case    3:  		/* lwz R31, <#[R29 + 4]> */
		/* 821905A8h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000004) );
		/* 821905A8h case    3:*/		return 0x821905AC;
		  /* 821905ACh */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 821905ACh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821905ACh case    4:*/		return 0x821905B0;
		  /* 821905B0h */ case    5:  		/* bc 12, CR6_EQ, 40 */
		/* 821905B0h case    5:*/		if ( regs.CR[6].eq ) { return 0x821905D8;  }
		/* 821905B0h case    5:*/		return 0x821905B4;
		  /* 821905B4h */ case    6:  		/* lwz R5, <#[R31 + 16]> */
		/* 821905B4h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000010) );
		/* 821905B4h case    6:*/		return 0x821905B8;
		  /* 821905B8h */ case    7:  		/* cmplwi CR6, R5, 0 */
		/* 821905B8h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821905B8h case    7:*/		return 0x821905BC;
		  /* 821905BCh */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 821905BCh case    8:*/		if ( regs.CR[6].eq ) { return 0x821905D0;  }
		/* 821905BCh case    8:*/		return 0x821905C0;
		  /* 821905C0h */ case    9:  		/* mr R6, R29 */
		/* 821905C0h case    9:*/		regs.R6 = regs.R29;
		/* 821905C0h case    9:*/		return 0x821905C4;
		  /* 821905C4h */ case   10:  		/* mr R4, R31 */
		/* 821905C4h case   10:*/		regs.R4 = regs.R31;
		/* 821905C4h case   10:*/		return 0x821905C8;
		  /* 821905C8h */ case   11:  		/* mr R3, R27 */
		/* 821905C8h case   11:*/		regs.R3 = regs.R27;
		/* 821905C8h case   11:*/		return 0x821905CC;
		  /* 821905CCh */ case   12:  		/* bl -135756 */
		/* 821905CCh case   12:*/		regs.LR = 0x821905D0; return 0x8216F380;
		/* 821905CCh case   12:*/		return 0x821905D0;
	}
	return 0x821905D0;
} // Block from 8219059Ch-821905D0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821905D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821905D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821905D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821905D0);
		  /* 821905D0h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 821905D0h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 821905D0h case    0:*/		return 0x821905D4;
		  /* 821905D4h */ case    1:  		/* b -40 */
		/* 821905D4h case    1:*/		return 0x821905AC;
		/* 821905D4h case    1:*/		return 0x821905D8;
	}
	return 0x821905D8;
} // Block from 821905D0h-821905D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821905D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821905D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821905D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821905D8);
		  /* 821905D8h */ case    0:  		/* li R5, 0 */
		/* 821905D8h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821905D8h case    0:*/		return 0x821905DC;
		  /* 821905DCh */ case    1:  		/* mr R4, R29 */
		/* 821905DCh case    1:*/		regs.R4 = regs.R29;
		/* 821905DCh case    1:*/		return 0x821905E0;
		  /* 821905E0h */ case    2:  		/* mr R3, R27 */
		/* 821905E0h case    2:*/		regs.R3 = regs.R27;
		/* 821905E0h case    2:*/		return 0x821905E4;
		  /* 821905E4h */ case    3:  		/* bl -128892 */
		/* 821905E4h case    3:*/		regs.LR = 0x821905E8; return 0x82170E68;
		/* 821905E4h case    3:*/		return 0x821905E8;
	}
	return 0x821905E8;
} // Block from 821905D8h-821905E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821905E8h
// Function '?DependentsHaveBeenScheduled@Scheduler@D3DXShader@@QAA_NPAVInstruction@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821905E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821905E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821905E8);
		  /* 821905E8h */ case    0:  		/* addi R1, R1, 128 */
		/* 821905E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821905E8h case    0:*/		return 0x821905EC;
		  /* 821905ECh */ case    1:  		/* b -1045320 */
		/* 821905ECh case    1:*/		return 0x820912A4;
		/* 821905ECh case    1:*/		return 0x821905F0;
		  /* 821905F0h */ case    2:  		/* lwz R11, <#[R4 + 20]> */
		/* 821905F0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000014) );
		/* 821905F0h case    2:*/		return 0x821905F4;
		  /* 821905F4h */ case    3:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821905F4h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821905F4h case    3:*/		return 0x821905F8;
		  /* 821905F8h */ case    4:  		/* bclr 4, CR0_EQ */
		/* 821905F8h case    4:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 821905F8h case    4:*/		return 0x821905FC;
	}
	return 0x821905FC;
} // Block from 821905E8h-821905FCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821905FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821905FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821905FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821905FC);
		  /* 821905FCh */ case    0:  		/* mr R9, R11 */
		/* 821905FCh case    0:*/		regs.R9 = regs.R11;
		/* 821905FCh case    0:*/		return 0x82190600;
		  /* 82190600h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 82190600h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82190600h case    1:*/		return 0x82190604;
		  /* 82190604h */ case    2:  		/* bclr 12, CR0_EQ */
		/* 82190604h case    2:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82190604h case    2:*/		return 0x82190608;
	}
	return 0x82190608;
} // Block from 821905FCh-82190608h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82190608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190608);
		  /* 82190608h */ case    0:  		/* lis R11, -32215 */
		/* 82190608h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82190608h case    0:*/		return 0x8219060C;
		  /* 8219060Ch */ case    1:  		/* addi R8, R11, -26096 */
		/* 8219060Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFF9A10);
		/* 8219060Ch case    1:*/		return 0x82190610;
		  /* 82190610h */ case    2:  		/* lwz R11, <#[R9 + 4]> */
		/* 82190610h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 82190610h case    2:*/		return 0x82190614;
		  /* 82190614h */ case    3:  		/* addi R10, R9, 4 */
		/* 82190614h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x4);
		/* 82190614h case    3:*/		return 0x82190618;
		  /* 82190618h */ case    4:  		/* b 20 */
		/* 82190618h case    4:*/		return 0x8219062C;
		/* 82190618h case    4:*/		return 0x8219061C;
		  /* 8219061Ch */ case    5:  		/* cmplw CR6, R11, R8 */
		/* 8219061Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8219061Ch case    5:*/		return 0x82190620;
		  /* 82190620h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 82190620h case    6:*/		if ( regs.CR[6].eq ) { return 0x82190634;  }
		/* 82190620h case    6:*/		return 0x82190624;
		  /* 82190624h */ case    7:  		/* addi R10, R11, 8 */
		/* 82190624h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x8);
		/* 82190624h case    7:*/		return 0x82190628;
		  /* 82190628h */ case    8:  		/* lwz R11, <#[R11 + 8]> */
		/* 82190628h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82190628h case    8:*/		return 0x8219062C;
	}
	return 0x8219062C;
} // Block from 82190608h-8219062Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219062Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219062C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219062C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219062C);
		  /* 8219062Ch */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8219062Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219062Ch case    0:*/		return 0x82190630;
		  /* 82190630h */ case    1:  		/* bc 4, CR6_EQ, -20 */
		/* 82190630h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219061C;  }
		/* 82190630h case    1:*/		return 0x82190634;
	}
	return 0x82190634;
} // Block from 8219062Ch-82190634h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82190634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190634);
		  /* 82190634h */ case    0:  		/* rlwinm R11, R9, 0, 0, 30 */
		/* 82190634h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R9);
		/* 82190634h case    0:*/		return 0x82190638;
		  /* 82190638h */ case    1:  		/* li R9, 0 */
		/* 82190638h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82190638h case    1:*/		return 0x8219063C;
		  /* 8219063Ch */ case    2:  		/* stw R9, <#[R10]> */
		/* 8219063Ch case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8219063Ch case    2:*/		return 0x82190640;
		  /* 82190640h */ case    3:  		/* lwz R11, <#[R11 + 40]> */
		/* 82190640h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82190640h case    3:*/		return 0x82190644;
		  /* 82190644h */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82190644h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82190644h case    4:*/		return 0x82190648;
		  /* 82190648h */ case    5:  		/* bclr 4, CR0_EQ */
		/* 82190648h case    5:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82190648h case    5:*/		return 0x8219064C;
	}
	return 0x8219064C;
} // Block from 82190634h-8219064Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219064Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219064C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219064C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219064C);
		  /* 8219064Ch */ case    0:  		/* mr R9, R11 */
		/* 8219064Ch case    0:*/		regs.R9 = regs.R11;
		/* 8219064Ch case    0:*/		return 0x82190650;
		  /* 82190650h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82190650h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82190650h case    1:*/		return 0x82190654;
		  /* 82190654h */ case    2:  		/* bc 4, CR6_EQ, -68 */
		/* 82190654h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82190610;  }
		/* 82190654h case    2:*/		return 0x82190658;
		  /* 82190658h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82190658h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82190658h case    3:*/		return 0x8219065C;
	}
	return 0x8219065C;
} // Block from 8219064Ch-8219065Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219065Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219065C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219065C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219065C);
		  /* 8219065Ch */ case    0:  		/* nop */
		/* 8219065Ch case    0:*/		cpu::op::nop();
		/* 8219065Ch case    0:*/		return 0x82190660;
	}
	return 0x82190660;
} // Block from 8219065Ch-82190660h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82190660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190660);
		  /* 82190660h */ case    0:  		/* mfspr R12, LR */
		/* 82190660h case    0:*/		regs.R12 = regs.LR;
		/* 82190660h case    0:*/		return 0x82190664;
		  /* 82190664h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82190664h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82190664h case    1:*/		return 0x82190668;
		  /* 82190668h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82190668h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82190668h case    2:*/		return 0x8219066C;
		  /* 8219066Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8219066Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219066Ch case    3:*/		return 0x82190670;
	}
	return 0x82190670;
} // Block from 82190660h-82190670h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82190670h
// Function '?CanCoIssueWith@Compiler@D3DXShader@@QAA_NPAVInstruction@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190670);
		  /* 82190670h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 82190670h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82190670h case    0:*/		return 0x82190674;
		  /* 82190674h */ case    1:  		/* lwz R10, <#[R4 + 44]> */
		/* 82190674h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000002C) );
		/* 82190674h case    1:*/		return 0x82190678;
		  /* 82190678h */ case    2:  		/* mr R11, R4 */
		/* 82190678h case    2:*/		regs.R11 = regs.R4;
		/* 82190678h case    2:*/		return 0x8219067C;
		  /* 8219067Ch */ case    3:  		/* mr R3, R4 */
		/* 8219067Ch case    3:*/		regs.R3 = regs.R4;
		/* 8219067Ch case    3:*/		return 0x82190680;
		  /* 82190680h */ case    4:  		/* li R30, 0 */
		/* 82190680h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82190680h case    4:*/		return 0x82190684;
		  /* 82190684h */ case    5:  		/* lwz R31, <#[R10 + 12]> */
		/* 82190684h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x0000000C) );
		/* 82190684h case    5:*/		return 0x82190688;
		  /* 82190688h */ case    6:  		/* b 52 */
		/* 82190688h case    6:*/		return 0x821906BC;
		/* 82190688h case    6:*/		return 0x8219068C;
		  /* 8219068Ch */ case    7:  		/* lwz R3, <#[R3 + 12]> */
		/* 8219068Ch case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000000C) );
		/* 8219068Ch case    7:*/		return 0x82190690;
		  /* 82190690h */ case    8:  		/* lwz R11, <#[R3 + 8]> */
		/* 82190690h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82190690h case    8:*/		return 0x82190694;
		  /* 82190694h */ case    9:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 82190694h case    9:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 82190694h case    9:*/		return 0x82190698;
		  /* 82190698h */ case   10:  		/* cmplwi CR6, R10, 12288 */
		/* 82190698h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003000);
		/* 82190698h case   10:*/		return 0x8219069C;
		  /* 8219069Ch */ case   11:  		/* bc 4, CR6_EQ, 32 */
		/* 8219069Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x821906BC;  }
		/* 8219069Ch case   11:*/		return 0x821906A0;
		  /* 821906A0h */ case   12:  		/* rlwinm. R11, R11, 0, 10, 12 */
		/* 821906A0h case   12:*/		cpu::op::rlwinm<1,0,10,12>(regs,&regs.R11,regs.R11);
		/* 821906A0h case   12:*/		return 0x821906A4;
		  /* 821906A4h */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 821906A4h case   13:*/		if ( regs.CR[0].eq ) { return 0x821906BC;  }
		/* 821906A4h case   13:*/		return 0x821906A8;
		  /* 821906A8h */ case   14:  		/* lwz R11, <#[R3 + 44]> */
		/* 821906A8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 821906A8h case   14:*/		return 0x821906AC;
		  /* 821906ACh */ case   15:  		/* lwz R11, <#[R11 + 12]> */
		/* 821906ACh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 821906ACh case   15:*/		return 0x821906B0;
		  /* 821906B0h */ case   16:  		/* cmplw CR6, R31, R11 */
		/* 821906B0h case   16:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 821906B0h case   16:*/		return 0x821906B4;
		  /* 821906B4h */ case   17:  		/* bc 4, CR6_EQ, 8 */
		/* 821906B4h case   17:*/		if ( !regs.CR[6].eq ) { return 0x821906BC;  }
		/* 821906B4h case   17:*/		return 0x821906B8;
		  /* 821906B8h */ case   18:  		/* li R30, 1 */
		/* 821906B8h case   18:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 821906B8h case   18:*/		return 0x821906BC;
	}
	return 0x821906BC;
} // Block from 82190670h-821906BCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 821906BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821906BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821906BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821906BC);
		  /* 821906BCh */ case    0:  		/* li R4, 3 */
		/* 821906BCh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 821906BCh case    0:*/		return 0x821906C0;
		  /* 821906C0h */ case    1:  		/* bl -99240 */
		/* 821906C0h case    1:*/		regs.LR = 0x821906C4; return 0x82178318;
		/* 821906C0h case    1:*/		return 0x821906C4;
		  /* 821906C4h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 821906C4h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 821906C4h case    2:*/		return 0x821906C8;
		  /* 821906C8h */ case    3:  		/* bc 4, CR0_EQ, -60 */
		/* 821906C8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219068C;  }
		/* 821906C8h case    3:*/		return 0x821906CC;
		  /* 821906CCh */ case    4:  		/* rlwinm R11, R30, 0, 24, 31 */
		/* 821906CCh case    4:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R30);
		/* 821906CCh case    4:*/		return 0x821906D0;
		  /* 821906D0h */ case    5:  		/* cntlzw R11, R11 */
		/* 821906D0h case    5:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 821906D0h case    5:*/		return 0x821906D4;
		  /* 821906D4h */ case    6:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 821906D4h case    6:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 821906D4h case    6:*/		return 0x821906D8;
		  /* 821906D8h */ case    7:  		/* addi R1, R1, 112 */
		/* 821906D8h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821906D8h case    7:*/		return 0x821906DC;
		  /* 821906DCh */ case    8:  		/* lwz R12, <#[R1 - 8]> */
		/* 821906DCh case    8:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821906DCh case    8:*/		return 0x821906E0;
		  /* 821906E0h */ case    9:  		/* mtspr LR, R12 */
		/* 821906E0h case    9:*/		regs.LR = regs.R12;
		/* 821906E0h case    9:*/		return 0x821906E4;
		  /* 821906E4h */ case   10:  		/* ld R30, <#[R1 - 24]> */
		/* 821906E4h case   10:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821906E4h case   10:*/		return 0x821906E8;
		  /* 821906E8h */ case   11:  		/* ld R31, <#[R1 - 16]> */
		/* 821906E8h case   11:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821906E8h case   11:*/		return 0x821906EC;
		  /* 821906ECh */ case   12:  		/* bclr 20, CR0_LT */
		/* 821906ECh case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821906ECh case   12:*/		return 0x821906F0;
	}
	return 0x821906F0;
} // Block from 821906BCh-821906F0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821906F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821906F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821906F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821906F0);
		  /* 821906F0h */ case    0:  		/* mfspr R12, LR */
		/* 821906F0h case    0:*/		regs.R12 = regs.LR;
		/* 821906F0h case    0:*/		return 0x821906F4;
		  /* 821906F4h */ case    1:  		/* bl -1045660 */
		/* 821906F4h case    1:*/		regs.LR = 0x821906F8; return 0x82091258;
		/* 821906F4h case    1:*/		return 0x821906F8;
		  /* 821906F8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821906F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821906F8h case    2:*/		return 0x821906FC;
		  /* 821906FCh */ case    3:  		/* addi R29, R3, 4 */
		/* 821906FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R3,0x4);
		/* 821906FCh case    3:*/		return 0x82190700;
		  /* 82190700h */ case    4:  		/* mr R30, R3 */
		/* 82190700h case    4:*/		regs.R30 = regs.R3;
		/* 82190700h case    4:*/		return 0x82190704;
		  /* 82190704h */ case    5:  		/* mr R28, R5 */
		/* 82190704h case    5:*/		regs.R28 = regs.R5;
		/* 82190704h case    5:*/		return 0x82190708;
		  /* 82190708h */ case    6:  		/* addi R4, R4, 4 */
		/* 82190708h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 82190708h case    6:*/		return 0x8219070C;
		  /* 8219070Ch */ case    7:  		/* li R5, 52 */
		/* 8219070Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x34);
		/* 8219070Ch case    7:*/		return 0x82190710;
		  /* 82190710h */ case    8:  		/* mr R3, R29 */
		/* 82190710h case    8:*/		regs.R3 = regs.R29;
		/* 82190710h case    8:*/		return 0x82190714;
		  /* 82190714h */ case    9:  		/* mr R31, R6 */
		/* 82190714h case    9:*/		regs.R31 = regs.R6;
		/* 82190714h case    9:*/		return 0x82190718;
		  /* 82190718h */ case   10:  		/* bl -1043816 */
		/* 82190718h case   10:*/		regs.LR = 0x8219071C; return 0x820919B0;
		/* 82190718h case   10:*/		return 0x8219071C;
		  /* 8219071Ch */ case   11:  		/* mr R11, R31 */
		/* 8219071Ch case   11:*/		regs.R11 = regs.R31;
		/* 8219071Ch case   11:*/		return 0x82190720;
		  /* 82190720h */ case   12:  		/* rlwinm R10, R11, 0, 0, 30 */
		/* 82190720h case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R11);
		/* 82190720h case   12:*/		return 0x82190724;
		  /* 82190724h */ case   13:  		/* lwz R10, <#[R10 + 36]> */
		/* 82190724h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000024) );
		/* 82190724h case   13:*/		return 0x82190728;
		  /* 82190728h */ case   14:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 82190728h case   14:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 82190728h case   14:*/		return 0x8219072C;
		  /* 8219072Ch */ case   15:  		/* bc 4, CR0_EQ, 44 */
		/* 8219072Ch case   15:*/		if ( !regs.CR[0].eq ) { return 0x82190758;  }
		/* 8219072Ch case   15:*/		return 0x82190730;
		  /* 82190730h */ case   16:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82190730h case   16:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82190730h case   16:*/		return 0x82190734;
		  /* 82190734h */ case   17:  		/* addic. R10, R10, -40 */
		/* 82190734h case   17:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R10,0xFFFFFFD8);
		/* 82190734h case   17:*/		return 0x82190738;
		  /* 82190738h */ case   18:  		/* bc 12, CR0_EQ, 32 */
		/* 82190738h case   18:*/		if ( regs.CR[0].eq ) { return 0x82190758;  }
		/* 82190738h case   18:*/		return 0x8219073C;
		  /* 8219073Ch */ case   19:  		/* lwz R9, <#[R10 + 20]> */
		/* 8219073Ch case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000014) );
		/* 8219073Ch case   19:*/		return 0x82190740;
		  /* 82190740h */ case   20:  		/* lwz R8, <#[R11 + 20]> */
		/* 82190740h case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 82190740h case   20:*/		return 0x82190744;
		  /* 82190744h */ case   21:  		/* xor R9, R9, R8 */
		/* 82190744h case   21:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82190744h case   21:*/		return 0x82190748;
		  /* 82190748h */ case   22:  		/* rlwinm. R9, R9, 0, 19, 31 */
		/* 82190748h case   22:*/		cpu::op::rlwinm<1,0,19,31>(regs,&regs.R9,regs.R9);
		/* 82190748h case   22:*/		return 0x8219074C;
		  /* 8219074Ch */ case   23:  		/* bc 4, CR0_EQ, 12 */
		/* 8219074Ch case   23:*/		if ( !regs.CR[0].eq ) { return 0x82190758;  }
		/* 8219074Ch case   23:*/		return 0x82190750;
		  /* 82190750h */ case   24:  		/* mr R11, R10 */
		/* 82190750h case   24:*/		regs.R11 = regs.R10;
		/* 82190750h case   24:*/		return 0x82190754;
		  /* 82190754h */ case   25:  		/* b -52 */
		/* 82190754h case   25:*/		return 0x82190720;
		/* 82190754h case   25:*/		return 0x82190758;
	}
	return 0x82190758;
} // Block from 821906F0h-82190758h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82190758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190758);
		  /* 82190758h */ case    0:  		/* stw R11, <#[R30]> */
		/* 82190758h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82190758h case    0:*/		return 0x8219075C;
		  /* 8219075Ch */ case    1:  		/* lwz R10, <#[R28 + 4]> */
		/* 8219075Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000004) );
		/* 8219075Ch case    1:*/		return 0x82190760;
		  /* 82190760h */ case    2:  		/* rlwinm R9, R10, 0, 31, 31 */
		/* 82190760h case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R10);
		/* 82190760h case    2:*/		return 0x82190764;
		  /* 82190764h */ case    3:  		/* addic R9, R9, -1 */
		/* 82190764h case    3:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82190764h case    3:*/		return 0x82190768;
		  /* 82190768h */ case    4:  		/* subfe R9, R9, R9 */
		/* 82190768h case    4:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 82190768h case    4:*/		return 0x8219076C;
		  /* 8219076Ch */ case    5:  		/* and R31, R9, R10 */
		/* 8219076Ch case    5:*/		cpu::op::and<0>(regs,&regs.R31,regs.R9,regs.R10);
		/* 8219076Ch case    5:*/		return 0x82190770;
		  /* 82190770h */ case    6:  		/* cmplw CR6, R31, R11 */
		/* 82190770h case    6:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82190770h case    6:*/		return 0x82190774;
		  /* 82190774h */ case    7:  		/* bc 12, CR6_EQ, 52 */
		/* 82190774h case    7:*/		if ( regs.CR[6].eq ) { return 0x821907A8;  }
		/* 82190774h case    7:*/		return 0x82190778;
		  /* 82190778h */ case    8:  		/* mr R4, R31 */
		/* 82190778h case    8:*/		regs.R4 = regs.R31;
		/* 82190778h case    8:*/		return 0x8219077C;
		  /* 8219077Ch */ case    9:  		/* mr R3, R29 */
		/* 8219077Ch case    9:*/		regs.R3 = regs.R29;
		/* 8219077Ch case    9:*/		return 0x82190780;
		  /* 82190780h */ case   10:  		/* bl -712 */
		/* 82190780h case   10:*/		regs.LR = 0x82190784; return 0x821904B8;
		/* 82190780h case   10:*/		return 0x82190784;
		  /* 82190784h */ case   11:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82190784h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82190784h case   11:*/		return 0x82190788;
		  /* 82190788h */ case   12:  		/* lwz R10, <#[R30]> */
		/* 82190788h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82190788h case   12:*/		return 0x8219078C;
		  /* 8219078Ch */ case   13:  		/* lwz R11, <#[R11 + 40]> */
		/* 8219078Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8219078Ch case   13:*/		return 0x82190790;
		  /* 82190790h */ case   14:  		/* rlwinm R9, R11, 0, 31, 31 */
		/* 82190790h case   14:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R11);
		/* 82190790h case   14:*/		return 0x82190794;
		  /* 82190794h */ case   15:  		/* addic R9, R9, -1 */
		/* 82190794h case   15:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82190794h case   15:*/		return 0x82190798;
		  /* 82190798h */ case   16:  		/* subfe R9, R9, R9 */
		/* 82190798h case   16:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 82190798h case   16:*/		return 0x8219079C;
		  /* 8219079Ch */ case   17:  		/* and R31, R9, R11 */
		/* 8219079Ch case   17:*/		cpu::op::and<0>(regs,&regs.R31,regs.R9,regs.R11);
		/* 8219079Ch case   17:*/		return 0x821907A0;
		  /* 821907A0h */ case   18:  		/* cmplw CR6, R31, R10 */
		/* 821907A0h case   18:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R10);
		/* 821907A0h case   18:*/		return 0x821907A4;
		  /* 821907A4h */ case   19:  		/* bc 4, CR6_EQ, -44 */
		/* 821907A4h case   19:*/		if ( !regs.CR[6].eq ) { return 0x82190778;  }
		/* 821907A4h case   19:*/		return 0x821907A8;
	}
	return 0x821907A8;
} // Block from 82190758h-821907A8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821907A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821907A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821907A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821907A8);
		  /* 821907A8h */ case    0:  		/* addi R1, R1, 128 */
		/* 821907A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821907A8h case    0:*/		return 0x821907AC;
		  /* 821907ACh */ case    1:  		/* b -1045764 */
		/* 821907ACh case    1:*/		return 0x820912A8;
		/* 821907ACh case    1:*/		return 0x821907B0;
		  /* 821907B0h */ case    2:  		/* lwz R9, <#[R3]> */
		/* 821907B0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 821907B0h case    2:*/		return 0x821907B4;
		  /* 821907B4h */ case    3:  		/* lwz R11, <#[R9 + 8]> */
		/* 821907B4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 821907B4h case    3:*/		return 0x821907B8;
		  /* 821907B8h */ case    4:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821907B8h case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821907B8h case    4:*/		return 0x821907BC;
		  /* 821907BCh */ case    5:  		/* cmplwi CR6, R11, 1 */
		/* 821907BCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821907BCh case    5:*/		return 0x821907C0;
		  /* 821907C0h */ case    6:  		/* bc 12, CR6_LT, 16 */
		/* 821907C0h case    6:*/		if ( regs.CR[6].lt ) { return 0x821907D0;  }
		/* 821907C0h case    6:*/		return 0x821907C4;
		  /* 821907C4h */ case    7:  		/* cmplwi CR6, R11, 31 */
		/* 821907C4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001F);
		/* 821907C4h case    7:*/		return 0x821907C8;
		  /* 821907C8h */ case    8:  		/* li R10, 1 */
		/* 821907C8h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821907C8h case    8:*/		return 0x821907CC;
		  /* 821907CCh */ case    9:  		/* bc 4, CR6_GT, 8 */
		/* 821907CCh case    9:*/		if ( !regs.CR[6].gt ) { return 0x821907D4;  }
		/* 821907CCh case    9:*/		return 0x821907D0;
	}
	return 0x821907D0;
} // Block from 821907A8h-821907D0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821907D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821907D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821907D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821907D0);
		  /* 821907D0h */ case    0:  		/* li R10, 0 */
		/* 821907D0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821907D0h case    0:*/		return 0x821907D4;
	}
	return 0x821907D4;
} // Block from 821907D0h-821907D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821907D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821907D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821907D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821907D4);
		  /* 821907D4h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 821907D4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 821907D4h case    0:*/		return 0x821907D8;
		  /* 821907D8h */ case    1:  		/* bc 12, CR0_EQ, 148 */
		/* 821907D8h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219086C;  }
		/* 821907D8h case    1:*/		return 0x821907DC;
		  /* 821907DCh */ case    2:  		/* cmplwi CR6, R11, 1 */
		/* 821907DCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821907DCh case    2:*/		return 0x821907E0;
		  /* 821907E0h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 821907E0h case    3:*/		if ( regs.CR[6].lt ) { return 0x821907F0;  }
		/* 821907E0h case    3:*/		return 0x821907E4;
		  /* 821907E4h */ case    4:  		/* cmplwi CR6, R11, 82 */
		/* 821907E4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 821907E4h case    4:*/		return 0x821907E8;
		  /* 821907E8h */ case    5:  		/* li R11, 1 */
		/* 821907E8h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821907E8h case    5:*/		return 0x821907EC;
		  /* 821907ECh */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 821907ECh case    6:*/		if ( !regs.CR[6].gt ) { return 0x821907F4;  }
		/* 821907ECh case    6:*/		return 0x821907F0;
	}
	return 0x821907F0;
} // Block from 821907D4h-821907F0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821907F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821907F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821907F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821907F0);
		  /* 821907F0h */ case    0:  		/* li R11, 0 */
		/* 821907F0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821907F0h case    0:*/		return 0x821907F4;
	}
	return 0x821907F4;
} // Block from 821907F0h-821907F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821907F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821907F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821907F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821907F4);
		  /* 821907F4h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 821907F4h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821907F4h case    0:*/		return 0x821907F8;
		  /* 821907F8h */ case    1:  		/* addic R10, R11, -1 */
		/* 821907F8h case    1:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 821907F8h case    1:*/		return 0x821907FC;
		  /* 821907FCh */ case    2:  		/* subfe R11, R10, R11 */
		/* 821907FCh case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821907FCh case    2:*/		return 0x82190800;
		  /* 82190800h */ case    3:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82190800h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82190800h case    3:*/		return 0x82190804;
		  /* 82190804h */ case    4:  		/* bc 12, CR0_EQ, 104 */
		/* 82190804h case    4:*/		if ( regs.CR[0].eq ) { return 0x8219086C;  }
		/* 82190804h case    4:*/		return 0x82190808;
		  /* 82190808h */ case    5:  		/* rlwinm R11, R9, 0, 0, 30 */
		/* 82190808h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R9);
		/* 82190808h case    5:*/		return 0x8219080C;
		  /* 8219080Ch */ case    6:  		/* lwz R11, <#[R11 + 40]> */
		/* 8219080Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8219080Ch case    6:*/		return 0x82190810;
		  /* 82190810h */ case    7:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82190810h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82190810h case    7:*/		return 0x82190814;
		  /* 82190814h */ case    8:  		/* bc 4, CR0_EQ, 76 */
		/* 82190814h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82190860;  }
		/* 82190814h case    8:*/		return 0x82190818;
		  /* 82190818h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82190818h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82190818h case    9:*/		return 0x8219081C;
		  /* 8219081Ch */ case   10:  		/* bc 12, CR6_EQ, 68 */
		/* 8219081Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x82190860;  }
		/* 8219081Ch case   10:*/		return 0x82190820;
		  /* 82190820h */ case   11:  		/* lwz R10, <#[R11 + 20]> */
		/* 82190820h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 82190820h case   11:*/		return 0x82190824;
		  /* 82190824h */ case   12:  		/* lwz R9, <#[R9 + 20]> */
		/* 82190824h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000014) );
		/* 82190824h case   12:*/		return 0x82190828;
		  /* 82190828h */ case   13:  		/* xor R10, R10, R9 */
		/* 82190828h case   13:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82190828h case   13:*/		return 0x8219082C;
		  /* 8219082Ch */ case   14:  		/* rlwinm. R10, R10, 0, 19, 31 */
		/* 8219082Ch case   14:*/		cpu::op::rlwinm<1,0,19,31>(regs,&regs.R10,regs.R10);
		/* 8219082Ch case   14:*/		return 0x82190830;
		  /* 82190830h */ case   15:  		/* bc 4, CR0_EQ, 48 */
		/* 82190830h case   15:*/		if ( !regs.CR[0].eq ) { return 0x82190860;  }
		/* 82190830h case   15:*/		return 0x82190834;
		  /* 82190834h */ case   16:  		/* lwz R11, <#[R11 + 8]> */
		/* 82190834h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82190834h case   16:*/		return 0x82190838;
		  /* 82190838h */ case   17:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82190838h case   17:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82190838h case   17:*/		return 0x8219083C;
		  /* 8219083Ch */ case   18:  		/* cmplwi CR6, R11, 32 */
		/* 8219083Ch case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 8219083Ch case   18:*/		return 0x82190840;
		  /* 82190840h */ case   19:  		/* bc 12, CR6_LT, 16 */
		/* 82190840h case   19:*/		if ( regs.CR[6].lt ) { return 0x82190850;  }
		/* 82190840h case   19:*/		return 0x82190844;
		  /* 82190844h */ case   20:  		/* cmplwi CR6, R11, 82 */
		/* 82190844h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 82190844h case   20:*/		return 0x82190848;
		  /* 82190848h */ case   21:  		/* li R11, 1 */
		/* 82190848h case   21:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82190848h case   21:*/		return 0x8219084C;
		  /* 8219084Ch */ case   22:  		/* bc 4, CR6_GT, 8 */
		/* 8219084Ch case   22:*/		if ( !regs.CR[6].gt ) { return 0x82190854;  }
		/* 8219084Ch case   22:*/		return 0x82190850;
	}
	return 0x82190850;
} // Block from 821907F4h-82190850h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82190850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190850);
		  /* 82190850h */ case    0:  		/* li R11, 0 */
		/* 82190850h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82190850h case    0:*/		return 0x82190854;
	}
	return 0x82190854;
} // Block from 82190850h-82190854h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82190854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190854);
		  /* 82190854h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82190854h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82190854h case    0:*/		return 0x82190858;
		  /* 82190858h */ case    1:  		/* li R11, 0 */
		/* 82190858h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82190858h case    1:*/		return 0x8219085C;
		  /* 8219085Ch */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 8219085Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x82190864;  }
		/* 8219085Ch case    2:*/		return 0x82190860;
	}
	return 0x82190860;
} // Block from 82190854h-82190860h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82190860h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190860);
		  /* 82190860h */ case    0:  		/* li R11, 1 */
		/* 82190860h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82190860h case    0:*/		return 0x82190864;
	}
	return 0x82190864;
} // Block from 82190860h-82190864h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82190864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190864);
		  /* 82190864h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 82190864h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 82190864h case    0:*/		return 0x82190868;
		  /* 82190868h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82190868h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82190868h case    1:*/		return 0x8219086C;
	}
	return 0x8219086C;
} // Block from 82190864h-8219086Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219086Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219086C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219086C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219086C);
		  /* 8219086Ch */ case    0:  		/* li R3, 0 */
		/* 8219086Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219086Ch case    0:*/		return 0x82190870;
		  /* 82190870h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82190870h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82190870h case    1:*/		return 0x82190874;
	}
	return 0x82190874;
} // Block from 8219086Ch-82190874h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82190874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190874);
		  /* 82190874h */ case    0:  		/* nop */
		/* 82190874h case    0:*/		cpu::op::nop();
		/* 82190874h case    0:*/		return 0x82190878;
	}
	return 0x82190878;
} // Block from 82190874h-82190878h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82190878h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190878);
		  /* 82190878h */ case    0:  		/* mfspr R12, LR */
		/* 82190878h case    0:*/		regs.R12 = regs.LR;
		/* 82190878h case    0:*/		return 0x8219087C;
		  /* 8219087Ch */ case    1:  		/* bl -1046048 */
		/* 8219087Ch case    1:*/		regs.LR = 0x82190880; return 0x8209125C;
		/* 8219087Ch case    1:*/		return 0x82190880;
		  /* 82190880h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 82190880h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82190880h case    2:*/		return 0x82190884;
		  /* 82190884h */ case    3:  		/* lwz R31, <#[R3]> */
		/* 82190884h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82190884h case    3:*/		return 0x82190888;
		  /* 82190888h */ case    4:  		/* mr R30, R3 */
		/* 82190888h case    4:*/		regs.R30 = regs.R3;
		/* 82190888h case    4:*/		return 0x8219088C;
		  /* 8219088Ch */ case    5:  		/* mr R29, R4 */
		/* 8219088Ch case    5:*/		regs.R29 = regs.R4;
		/* 8219088Ch case    5:*/		return 0x82190890;
		  /* 82190890h */ case    6:  		/* lwz R11, <#[R31 + 8]> */
		/* 82190890h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82190890h case    6:*/		return 0x82190894;
		  /* 82190894h */ case    7:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82190894h case    7:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82190894h case    7:*/		return 0x82190898;
		  /* 82190898h */ case    8:  		/* cmplwi CR6, R11, 1 */
		/* 82190898h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82190898h case    8:*/		return 0x8219089C;
		  /* 8219089Ch */ case    9:  		/* bc 12, CR6_LT, 16 */
		/* 8219089Ch case    9:*/		if ( regs.CR[6].lt ) { return 0x821908AC;  }
		/* 8219089Ch case    9:*/		return 0x821908A0;
		  /* 821908A0h */ case   10:  		/* cmplwi CR6, R11, 31 */
		/* 821908A0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001F);
		/* 821908A0h case   10:*/		return 0x821908A4;
		  /* 821908A4h */ case   11:  		/* li R10, 1 */
		/* 821908A4h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821908A4h case   11:*/		return 0x821908A8;
		  /* 821908A8h */ case   12:  		/* bc 4, CR6_GT, 8 */
		/* 821908A8h case   12:*/		if ( !regs.CR[6].gt ) { return 0x821908B0;  }
		/* 821908A8h case   12:*/		return 0x821908AC;
	}
	return 0x821908AC;
} // Block from 82190878h-821908ACh (13 instructions)

//////////////////////////////////////////////////////
// Block at 821908ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821908AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821908AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821908AC);
		  /* 821908ACh */ case    0:  		/* li R10, 0 */
		/* 821908ACh case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821908ACh case    0:*/		return 0x821908B0;
	}
	return 0x821908B0;
} // Block from 821908ACh-821908B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821908B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821908B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821908B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821908B0);
		  /* 821908B0h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 821908B0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 821908B0h case    0:*/		return 0x821908B4;
		  /* 821908B4h */ case    1:  		/* bc 12, CR0_EQ, 232 */
		/* 821908B4h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219099C;  }
		/* 821908B4h case    1:*/		return 0x821908B8;
		  /* 821908B8h */ case    2:  		/* cmplwi CR6, R11, 1 */
		/* 821908B8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821908B8h case    2:*/		return 0x821908BC;
		  /* 821908BCh */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 821908BCh case    3:*/		if ( regs.CR[6].lt ) { return 0x821908CC;  }
		/* 821908BCh case    3:*/		return 0x821908C0;
		  /* 821908C0h */ case    4:  		/* cmplwi CR6, R11, 82 */
		/* 821908C0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 821908C0h case    4:*/		return 0x821908C4;
		  /* 821908C4h */ case    5:  		/* li R11, 1 */
		/* 821908C4h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821908C4h case    5:*/		return 0x821908C8;
		  /* 821908C8h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 821908C8h case    6:*/		if ( !regs.CR[6].gt ) { return 0x821908D0;  }
		/* 821908C8h case    6:*/		return 0x821908CC;
	}
	return 0x821908CC;
} // Block from 821908B0h-821908CCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 821908CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821908CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821908CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821908CC);
		  /* 821908CCh */ case    0:  		/* li R11, 0 */
		/* 821908CCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821908CCh case    0:*/		return 0x821908D0;
	}
	return 0x821908D0;
} // Block from 821908CCh-821908D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821908D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821908D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821908D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821908D0);
		  /* 821908D0h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 821908D0h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821908D0h case    0:*/		return 0x821908D4;
		  /* 821908D4h */ case    1:  		/* addic R10, R11, -1 */
		/* 821908D4h case    1:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 821908D4h case    1:*/		return 0x821908D8;
		  /* 821908D8h */ case    2:  		/* subfe R11, R10, R11 */
		/* 821908D8h case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821908D8h case    2:*/		return 0x821908DC;
		  /* 821908DCh */ case    3:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821908DCh case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821908DCh case    3:*/		return 0x821908E0;
		  /* 821908E0h */ case    4:  		/* bc 12, CR0_EQ, 188 */
		/* 821908E0h case    4:*/		if ( regs.CR[0].eq ) { return 0x8219099C;  }
		/* 821908E0h case    4:*/		return 0x821908E4;
		  /* 821908E4h */ case    5:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821908E4h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821908E4h case    5:*/		return 0x821908E8;
		  /* 821908E8h */ case    6:  		/* lwz R11, <#[R11 + 40]> */
		/* 821908E8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821908E8h case    6:*/		return 0x821908EC;
		  /* 821908ECh */ case    7:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821908ECh case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821908ECh case    7:*/		return 0x821908F0;
		  /* 821908F0h */ case    8:  		/* bc 4, CR0_EQ, 72 */
		/* 821908F0h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82190938;  }
		/* 821908F0h case    8:*/		return 0x821908F4;
		  /* 821908F4h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 821908F4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821908F4h case    9:*/		return 0x821908F8;
		  /* 821908F8h */ case   10:  		/* bc 12, CR6_EQ, 64 */
		/* 821908F8h case   10:*/		if ( regs.CR[6].eq ) { return 0x82190938;  }
		/* 821908F8h case   10:*/		return 0x821908FC;
		  /* 821908FCh */ case   11:  		/* lwz R10, <#[R11 + 20]> */
		/* 821908FCh case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 821908FCh case   11:*/		return 0x82190900;
		  /* 82190900h */ case   12:  		/* lwz R9, <#[R31 + 20]> */
		/* 82190900h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 82190900h case   12:*/		return 0x82190904;
		  /* 82190904h */ case   13:  		/* xor R10, R10, R9 */
		/* 82190904h case   13:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82190904h case   13:*/		return 0x82190908;
		  /* 82190908h */ case   14:  		/* rlwinm. R10, R10, 0, 19, 31 */
		/* 82190908h case   14:*/		cpu::op::rlwinm<1,0,19,31>(regs,&regs.R10,regs.R10);
		/* 82190908h case   14:*/		return 0x8219090C;
		  /* 8219090Ch */ case   15:  		/* bc 4, CR0_EQ, 44 */
		/* 8219090Ch case   15:*/		if ( !regs.CR[0].eq ) { return 0x82190938;  }
		/* 8219090Ch case   15:*/		return 0x82190910;
		  /* 82190910h */ case   16:  		/* lwz R11, <#[R11 + 8]> */
		/* 82190910h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82190910h case   16:*/		return 0x82190914;
		  /* 82190914h */ case   17:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82190914h case   17:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82190914h case   17:*/		return 0x82190918;
		  /* 82190918h */ case   18:  		/* cmplwi CR6, R11, 32 */
		/* 82190918h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 82190918h case   18:*/		return 0x8219091C;
		  /* 8219091Ch */ case   19:  		/* bc 12, CR6_LT, 16 */
		/* 8219091Ch case   19:*/		if ( regs.CR[6].lt ) { return 0x8219092C;  }
		/* 8219091Ch case   19:*/		return 0x82190920;
		  /* 82190920h */ case   20:  		/* cmplwi CR6, R11, 82 */
		/* 82190920h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 82190920h case   20:*/		return 0x82190924;
		  /* 82190924h */ case   21:  		/* li R11, 1 */
		/* 82190924h case   21:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82190924h case   21:*/		return 0x82190928;
		  /* 82190928h */ case   22:  		/* bc 4, CR6_GT, 8 */
		/* 82190928h case   22:*/		if ( !regs.CR[6].gt ) { return 0x82190930;  }
		/* 82190928h case   22:*/		return 0x8219092C;
	}
	return 0x8219092C;
} // Block from 821908D0h-8219092Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 8219092Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219092C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219092C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219092C);
		  /* 8219092Ch */ case    0:  		/* li R11, 0 */
		/* 8219092Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219092Ch case    0:*/		return 0x82190930;
	}
	return 0x82190930;
} // Block from 8219092Ch-82190930h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82190930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190930);
		  /* 82190930h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82190930h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82190930h case    0:*/		return 0x82190934;
		  /* 82190934h */ case    1:  		/* bc 4, CR0_EQ, 104 */
		/* 82190934h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219099C;  }
		/* 82190934h case    1:*/		return 0x82190938;
	}
	return 0x82190938;
} // Block from 82190930h-82190938h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82190938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190938);
		  /* 82190938h */ case    0:  		/* addi R4, R30, 4 */
		/* 82190938h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x4);
		/* 82190938h case    0:*/		return 0x8219093C;
		  /* 8219093Ch */ case    1:  		/* addi R3, R1, 80 */
		/* 8219093Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8219093Ch case    1:*/		return 0x82190940;
		  /* 82190940h */ case    2:  		/* li R5, 52 */
		/* 82190940h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x34);
		/* 82190940h case    2:*/		return 0x82190944;
		  /* 82190944h */ case    3:  		/* bl -1044372 */
		/* 82190944h case    3:*/		regs.LR = 0x82190948; return 0x820919B0;
		/* 82190944h case    3:*/		return 0x82190948;
		  /* 82190948h */ case    4:  		/* mr R4, R31 */
		/* 82190948h case    4:*/		regs.R4 = regs.R31;
		/* 82190948h case    4:*/		return 0x8219094C;
		  /* 8219094Ch */ case    5:  		/* addi R3, R1, 80 */
		/* 8219094Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8219094Ch case    5:*/		return 0x82190950;
		  /* 82190950h */ case    6:  		/* bl -1176 */
		/* 82190950h case    6:*/		regs.LR = 0x82190954; return 0x821904B8;
		/* 82190950h case    6:*/		return 0x82190954;
		  /* 82190954h */ case    7:  		/* mr R4, R29 */
		/* 82190954h case    7:*/		regs.R4 = regs.R29;
		/* 82190954h case    7:*/		return 0x82190958;
		  /* 82190958h */ case    8:  		/* addi R3, R1, 80 */
		/* 82190958h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82190958h case    8:*/		return 0x8219095C;
		  /* 8219095Ch */ case    9:  		/* bl -137220 */
		/* 8219095Ch case    9:*/		regs.LR = 0x82190960; return 0x8216F158;
		/* 8219095Ch case    9:*/		return 0x82190960;
		  /* 82190960h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82190960h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82190960h case   10:*/		return 0x82190964;
		  /* 82190964h */ case   11:  		/* bc 12, CR0_EQ, 56 */
		/* 82190964h case   11:*/		if ( regs.CR[0].eq ) { return 0x8219099C;  }
		/* 82190964h case   11:*/		return 0x82190968;
		  /* 82190968h */ case   12:  		/* mr R4, R29 */
		/* 82190968h case   12:*/		regs.R4 = regs.R29;
		/* 82190968h case   12:*/		return 0x8219096C;
		  /* 8219096Ch */ case   13:  		/* addi R3, R1, 80 */
		/* 8219096Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8219096Ch case   13:*/		return 0x82190970;
		  /* 82190970h */ case   14:  		/* bl -136600 */
		/* 82190970h case   14:*/		regs.LR = 0x82190974; return 0x8216F3D8;
		/* 82190970h case   14:*/		return 0x82190974;
		  /* 82190974h */ case   15:  		/* mr R4, R31 */
		/* 82190974h case   15:*/		regs.R4 = regs.R31;
		/* 82190974h case   15:*/		return 0x82190978;
		  /* 82190978h */ case   16:  		/* addi R3, R1, 80 */
		/* 82190978h case   16:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82190978h case   16:*/		return 0x8219097C;
		  /* 8219097Ch */ case   17:  		/* bl -137252 */
		/* 8219097Ch case   17:*/		regs.LR = 0x82190980; return 0x8216F158;
		/* 8219097Ch case   17:*/		return 0x82190980;
		  /* 82190980h */ case   18:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82190980h case   18:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82190980h case   18:*/		return 0x82190984;
		  /* 82190984h */ case   19:  		/* bc 12, CR0_EQ, 24 */
		/* 82190984h case   19:*/		if ( regs.CR[0].eq ) { return 0x8219099C;  }
		/* 82190984h case   19:*/		return 0x82190988;
		  /* 82190988h */ case   20:  		/* mr R5, R29 */
		/* 82190988h case   20:*/		regs.R5 = regs.R29;
		/* 82190988h case   20:*/		return 0x8219098C;
		  /* 8219098Ch */ case   21:  		/* lwz R3, <#[R30 + 48]> */
		/* 8219098Ch case   21:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 8219098Ch case   21:*/		return 0x82190990;
		  /* 82190990h */ case   22:  		/* mr R4, R31 */
		/* 82190990h case   22:*/		regs.R4 = regs.R31;
		/* 82190990h case   22:*/		return 0x82190994;
		  /* 82190994h */ case   23:  		/* bl -3260 */
		/* 82190994h case   23:*/		regs.LR = 0x82190998; return 0x8218FCD8;
		/* 82190994h case   23:*/		return 0x82190998;
		  /* 82190998h */ case   24:  		/* b 8 */
		/* 82190998h case   24:*/		return 0x821909A0;
		/* 82190998h case   24:*/		return 0x8219099C;
	}
	return 0x8219099C;
} // Block from 82190938h-8219099Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 8219099Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219099C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219099C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219099C);
		  /* 8219099Ch */ case    0:  		/* li R3, 0 */
		/* 8219099Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219099Ch case    0:*/		return 0x821909A0;
	}
	return 0x821909A0;
} // Block from 8219099Ch-821909A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821909A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821909A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821909A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821909A0);
		  /* 821909A0h */ case    0:  		/* addi R1, R1, 176 */
		/* 821909A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 821909A0h case    0:*/		return 0x821909A4;
		  /* 821909A4h */ case    1:  		/* b -1046264 */
		/* 821909A4h case    1:*/		return 0x820912AC;
		/* 821909A4h case    1:*/		return 0x821909A8;
	}
	return 0x821909A8;
} // Block from 821909A0h-821909A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821909A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821909A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821909A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821909A8);
		  /* 821909A8h */ case    0:  		/* mfspr R12, LR */
		/* 821909A8h case    0:*/		regs.R12 = regs.LR;
		/* 821909A8h case    0:*/		return 0x821909AC;
		  /* 821909ACh */ case    1:  		/* bl -1046352 */
		/* 821909ACh case    1:*/		regs.LR = 0x821909B0; return 0x8209125C;
		/* 821909ACh case    1:*/		return 0x821909B0;
		  /* 821909B0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821909B0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821909B0h case    2:*/		return 0x821909B4;
		  /* 821909B4h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 821909B4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821909B4h case    3:*/		return 0x821909B8;
		  /* 821909B8h */ case    4:  		/* mr R29, R3 */
		/* 821909B8h case    4:*/		regs.R29 = regs.R3;
		/* 821909B8h case    4:*/		return 0x821909BC;
		  /* 821909BCh */ case    5:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821909BCh case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821909BCh case    5:*/		return 0x821909C0;
		  /* 821909C0h */ case    6:  		/* lwz R11, <#[R11 + 36]> */
		/* 821909C0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 821909C0h case    6:*/		return 0x821909C4;
		  /* 821909C4h */ case    7:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821909C4h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821909C4h case    7:*/		return 0x821909C8;
		  /* 821909C8h */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 821909C8h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821909D8;  }
		/* 821909C8h case    8:*/		return 0x821909CC;
		  /* 821909CCh */ case    9:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821909CCh case    9:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821909CCh case    9:*/		return 0x821909D0;
		  /* 821909D0h */ case   10:  		/* addic. R31, R11, -40 */
		/* 821909D0h case   10:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 821909D0h case   10:*/		return 0x821909D4;
		  /* 821909D4h */ case   11:  		/* bc 4, CR0_EQ, 12 */
		/* 821909D4h case   11:*/		if ( !regs.CR[0].eq ) { return 0x821909E0;  }
		/* 821909D4h case   11:*/		return 0x821909D8;
	}
	return 0x821909D8;
} // Block from 821909A8h-821909D8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821909D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821909D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821909D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821909D8);
		  /* 821909D8h */ case    0:  		/* li R3, 0 */
		/* 821909D8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821909D8h case    0:*/		return 0x821909DC;
		  /* 821909DCh */ case    1:  		/* b 160 */
		/* 821909DCh case    1:*/		return 0x82190A7C;
		/* 821909DCh case    1:*/		return 0x821909E0;
	}
	return 0x821909E0;
} // Block from 821909D8h-821909E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821909E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821909E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821909E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821909E0);
		  /* 821909E0h */ case    0:  		/* mr R11, R31 */
		/* 821909E0h case    0:*/		regs.R11 = regs.R31;
		/* 821909E0h case    0:*/		return 0x821909E4;
		  /* 821909E4h */ case    1:  		/* rlwinm R10, R11, 0, 0, 30 */
		/* 821909E4h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R11);
		/* 821909E4h case    1:*/		return 0x821909E8;
		  /* 821909E8h */ case    2:  		/* lwz R10, <#[R10 + 36]> */
		/* 821909E8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000024) );
		/* 821909E8h case    2:*/		return 0x821909EC;
		  /* 821909ECh */ case    3:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 821909ECh case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 821909ECh case    3:*/		return 0x821909F0;
		  /* 821909F0h */ case    4:  		/* bc 4, CR0_EQ, 44 */
		/* 821909F0h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82190A1C;  }
		/* 821909F0h case    4:*/		return 0x821909F4;
		  /* 821909F4h */ case    5:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821909F4h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821909F4h case    5:*/		return 0x821909F8;
		  /* 821909F8h */ case    6:  		/* addic. R10, R10, -40 */
		/* 821909F8h case    6:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R10,0xFFFFFFD8);
		/* 821909F8h case    6:*/		return 0x821909FC;
		  /* 821909FCh */ case    7:  		/* bc 12, CR0_EQ, 32 */
		/* 821909FCh case    7:*/		if ( regs.CR[0].eq ) { return 0x82190A1C;  }
		/* 821909FCh case    7:*/		return 0x82190A00;
		  /* 82190A00h */ case    8:  		/* lwz R9, <#[R10 + 20]> */
		/* 82190A00h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000014) );
		/* 82190A00h case    8:*/		return 0x82190A04;
		  /* 82190A04h */ case    9:  		/* lwz R8, <#[R11 + 20]> */
		/* 82190A04h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 82190A04h case    9:*/		return 0x82190A08;
		  /* 82190A08h */ case   10:  		/* xor R9, R9, R8 */
		/* 82190A08h case   10:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82190A08h case   10:*/		return 0x82190A0C;
		  /* 82190A0Ch */ case   11:  		/* rlwinm. R9, R9, 0, 19, 31 */
		/* 82190A0Ch case   11:*/		cpu::op::rlwinm<1,0,19,31>(regs,&regs.R9,regs.R9);
		/* 82190A0Ch case   11:*/		return 0x82190A10;
		  /* 82190A10h */ case   12:  		/* bc 4, CR0_EQ, 12 */
		/* 82190A10h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82190A1C;  }
		/* 82190A10h case   12:*/		return 0x82190A14;
		  /* 82190A14h */ case   13:  		/* mr R11, R10 */
		/* 82190A14h case   13:*/		regs.R11 = regs.R10;
		/* 82190A14h case   13:*/		return 0x82190A18;
		  /* 82190A18h */ case   14:  		/* b -52 */
		/* 82190A18h case   14:*/		return 0x821909E4;
		/* 82190A18h case   14:*/		return 0x82190A1C;
	}
	return 0x82190A1C;
} // Block from 821909E0h-82190A1Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 82190A1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190A1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190A1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190A1C);
		  /* 82190A1Ch */ case    0:  		/* stw R11, <#[R29]> */
		/* 82190A1Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82190A1Ch case    0:*/		return 0x82190A20;
		  /* 82190A20h */ case    1:  		/* addi R30, R29, 4 */
		/* 82190A20h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R29,0x4);
		/* 82190A20h case    1:*/		return 0x82190A24;
		  /* 82190A24h */ case    2:  		/* b 60 */
		/* 82190A24h case    2:*/		return 0x82190A60;
		/* 82190A24h case    2:*/		return 0x82190A28;
		  /* 82190A28h */ case    3:  		/* mr R4, R31 */
		/* 82190A28h case    3:*/		regs.R4 = regs.R31;
		/* 82190A28h case    3:*/		return 0x82190A2C;
		  /* 82190A2Ch */ case    4:  		/* mr R3, R30 */
		/* 82190A2Ch case    4:*/		regs.R3 = regs.R30;
		/* 82190A2Ch case    4:*/		return 0x82190A30;
		  /* 82190A30h */ case    5:  		/* bl -136792 */
		/* 82190A30h case    5:*/		regs.LR = 0x82190A34; return 0x8216F3D8;
		/* 82190A30h case    5:*/		return 0x82190A34;
		  /* 82190A34h */ case    6:  		/* lwz R11, <#[R29]> */
		/* 82190A34h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82190A34h case    6:*/		return 0x82190A38;
		  /* 82190A38h */ case    7:  		/* cmplw CR6, R31, R11 */
		/* 82190A38h case    7:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82190A38h case    7:*/		return 0x82190A3C;
		  /* 82190A3Ch */ case    8:  		/* bc 12, CR6_EQ, 60 */
		/* 82190A3Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x82190A78;  }
		/* 82190A3Ch case    8:*/		return 0x82190A40;
		  /* 82190A40h */ case    9:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82190A40h case    9:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82190A40h case    9:*/		return 0x82190A44;
		  /* 82190A44h */ case   10:  		/* lwz R11, <#[R11 + 36]> */
		/* 82190A44h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82190A44h case   10:*/		return 0x82190A48;
		  /* 82190A48h */ case   11:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82190A48h case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82190A48h case   11:*/		return 0x82190A4C;
		  /* 82190A4Ch */ case   12:  		/* bc 12, CR0_EQ, 12 */
		/* 82190A4Ch case   12:*/		if ( regs.CR[0].eq ) { return 0x82190A58;  }
		/* 82190A4Ch case   12:*/		return 0x82190A50;
		  /* 82190A50h */ case   13:  		/* li R31, 0 */
		/* 82190A50h case   13:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82190A50h case   13:*/		return 0x82190A54;
		  /* 82190A54h */ case   14:  		/* b 12 */
		/* 82190A54h case   14:*/		return 0x82190A60;
		/* 82190A54h case   14:*/		return 0x82190A58;
	}
	return 0x82190A58;
} // Block from 82190A1Ch-82190A58h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82190A58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190A58);
		  /* 82190A58h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82190A58h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82190A58h case    0:*/		return 0x82190A5C;
		  /* 82190A5Ch */ case    1:  		/* addi R31, R11, -40 */
		/* 82190A5Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 82190A5Ch case    1:*/		return 0x82190A60;
	}
	return 0x82190A60;
} // Block from 82190A58h-82190A60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82190A60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190A60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190A60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190A60);
		  /* 82190A60h */ case    0:  		/* mr R4, R31 */
		/* 82190A60h case    0:*/		regs.R4 = regs.R31;
		/* 82190A60h case    0:*/		return 0x82190A64;
		  /* 82190A64h */ case    1:  		/* mr R3, R30 */
		/* 82190A64h case    1:*/		regs.R3 = regs.R30;
		/* 82190A64h case    1:*/		return 0x82190A68;
		  /* 82190A68h */ case    2:  		/* bl -137488 */
		/* 82190A68h case    2:*/		regs.LR = 0x82190A6C; return 0x8216F158;
		/* 82190A68h case    2:*/		return 0x82190A6C;
		  /* 82190A6Ch */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82190A6Ch case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82190A6Ch case    3:*/		return 0x82190A70;
		  /* 82190A70h */ case    4:  		/* bc 4, CR0_EQ, -72 */
		/* 82190A70h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82190A28;  }
		/* 82190A70h case    4:*/		return 0x82190A74;
		  /* 82190A74h */ case    5:  		/* b -156 */
		/* 82190A74h case    5:*/		return 0x821909D8;
		/* 82190A74h case    5:*/		return 0x82190A78;
	}
	return 0x82190A78;
} // Block from 82190A60h-82190A78h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82190A78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190A78);
		  /* 82190A78h */ case    0:  		/* li R3, 1 */
		/* 82190A78h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82190A78h case    0:*/		return 0x82190A7C;
	}
	return 0x82190A7C;
} // Block from 82190A78h-82190A7Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82190A7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190A7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190A7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190A7C);
		  /* 82190A7Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 82190A7Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82190A7Ch case    0:*/		return 0x82190A80;
		  /* 82190A80h */ case    1:  		/* b -1046484 */
		/* 82190A80h case    1:*/		return 0x820912AC;
		/* 82190A80h case    1:*/		return 0x82190A84;
		  /* 82190A84h */ case    2:  		/* nop */
		/* 82190A84h case    2:*/		cpu::op::nop();
		/* 82190A84h case    2:*/		return 0x82190A88;
	}
	return 0x82190A88;
} // Block from 82190A7Ch-82190A88h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82190A88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190A88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190A88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190A88);
		  /* 82190A88h */ case    0:  		/* mfspr R12, LR */
		/* 82190A88h case    0:*/		regs.R12 = regs.LR;
		/* 82190A88h case    0:*/		return 0x82190A8C;
		  /* 82190A8Ch */ case    1:  		/* bl -1046576 */
		/* 82190A8Ch case    1:*/		regs.LR = 0x82190A90; return 0x8209125C;
		/* 82190A8Ch case    1:*/		return 0x82190A90;
		  /* 82190A90h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82190A90h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82190A90h case    2:*/		return 0x82190A94;
		  /* 82190A94h */ case    3:  		/* lwz R29, <#[R3]> */
		/* 82190A94h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82190A94h case    3:*/		return 0x82190A98;
		  /* 82190A98h */ case    4:  		/* addi R31, R3, 4 */
		/* 82190A98h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x4);
		/* 82190A98h case    4:*/		return 0x82190A9C;
		  /* 82190A9Ch */ case    5:  		/* mr R30, R4 */
		/* 82190A9Ch case    5:*/		regs.R30 = regs.R4;
		/* 82190A9Ch case    5:*/		return 0x82190AA0;
		  /* 82190AA0h */ case    6:  		/* mr R3, R31 */
		/* 82190AA0h case    6:*/		regs.R3 = regs.R31;
		/* 82190AA0h case    6:*/		return 0x82190AA4;
		  /* 82190AA4h */ case    7:  		/* mr R4, R29 */
		/* 82190AA4h case    7:*/		regs.R4 = regs.R29;
		/* 82190AA4h case    7:*/		return 0x82190AA8;
		  /* 82190AA8h */ case    8:  		/* bl -1520 */
		/* 82190AA8h case    8:*/		regs.LR = 0x82190AAC; return 0x821904B8;
		/* 82190AA8h case    8:*/		return 0x82190AAC;
		  /* 82190AACh */ case    9:  		/* mr R3, R31 */
		/* 82190AACh case    9:*/		regs.R3 = regs.R31;
		/* 82190AACh case    9:*/		return 0x82190AB0;
		  /* 82190AB0h */ case   10:  		/* mr R4, R30 */
		/* 82190AB0h case   10:*/		regs.R4 = regs.R30;
		/* 82190AB0h case   10:*/		return 0x82190AB4;
		  /* 82190AB4h */ case   11:  		/* bl -136924 */
		/* 82190AB4h case   11:*/		regs.LR = 0x82190AB8; return 0x8216F3D8;
		/* 82190AB4h case   11:*/		return 0x82190AB8;
		  /* 82190AB8h */ case   12:  		/* mr R4, R29 */
		/* 82190AB8h case   12:*/		regs.R4 = regs.R29;
		/* 82190AB8h case   12:*/		return 0x82190ABC;
		  /* 82190ABCh */ case   13:  		/* mr R3, R31 */
		/* 82190ABCh case   13:*/		regs.R3 = regs.R31;
		/* 82190ABCh case   13:*/		return 0x82190AC0;
		  /* 82190AC0h */ case   14:  		/* bl -136936 */
		/* 82190AC0h case   14:*/		regs.LR = 0x82190AC4; return 0x8216F3D8;
		/* 82190AC0h case   14:*/		return 0x82190AC4;
		  /* 82190AC4h */ case   15:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 82190AC4h case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 82190AC4h case   15:*/		return 0x82190AC8;
		  /* 82190AC8h */ case   16:  		/* rlwinm R10, R30, 0, 0, 30 */
		/* 82190AC8h case   16:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R30);
		/* 82190AC8h case   16:*/		return 0x82190ACC;
		  /* 82190ACCh */ case   17:  		/* addi R11, R11, 36 */
		/* 82190ACCh case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82190ACCh case   17:*/		return 0x82190AD0;
		  /* 82190AD0h */ case   18:  		/* addi R10, R10, 36 */
		/* 82190AD0h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 82190AD0h case   18:*/		return 0x82190AD4;
		  /* 82190AD4h */ case   19:  		/* addi R9, R11, 4 */
		/* 82190AD4h case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 82190AD4h case   19:*/		return 0x82190AD8;
		  /* 82190AD8h */ case   20:  		/* addi R8, R10, 4 */
		/* 82190AD8h case   20:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x4);
		/* 82190AD8h case   20:*/		return 0x82190ADC;
		  /* 82190ADCh */ case   21:  		/* addi R7, R10, -36 */
		/* 82190ADCh case   21:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFFFDC);
		/* 82190ADCh case   21:*/		return 0x82190AE0;
		  /* 82190AE0h */ case   22:  		/* lwz R6, <#[R11 + 4]> */
		/* 82190AE0h case   22:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82190AE0h case   22:*/		return 0x82190AE4;
		  /* 82190AE4h */ case   23:  		/* stw R6, <#[R10 + 4]> */
		/* 82190AE4h case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 82190AE4h case   23:*/		return 0x82190AE8;
		  /* 82190AE8h */ case   24:  		/* lwz R6, <#[R11 + 4]> */
		/* 82190AE8h case   24:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82190AE8h case   24:*/		return 0x82190AEC;
		  /* 82190AECh */ case   25:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 82190AECh case   25:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 82190AECh case   25:*/		return 0x82190AF0;
		  /* 82190AF0h */ case   26:  		/* stw R8, <#[R6 + 36]> */
		/* 82190AF0h case   26:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000024) );
		/* 82190AF0h case   26:*/		return 0x82190AF4;
		  /* 82190AF4h */ case   27:  		/* stw R9, <#[R10]> */
		/* 82190AF4h case   27:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82190AF4h case   27:*/		return 0x82190AF8;
		  /* 82190AF8h */ case   28:  		/* stw R7, <#[R11 + 4]> */
		/* 82190AF8h case   28:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82190AF8h case   28:*/		return 0x82190AFC;
		  /* 82190AFCh */ case   29:  		/* addi R1, R1, 112 */
		/* 82190AFCh case   29:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82190AFCh case   29:*/		return 0x82190B00;
		  /* 82190B00h */ case   30:  		/* b -1046612 */
		/* 82190B00h case   30:*/		return 0x820912AC;
		/* 82190B00h case   30:*/		return 0x82190B04;
		  /* 82190B04h */ case   31:  		/* nop */
		/* 82190B04h case   31:*/		cpu::op::nop();
		/* 82190B04h case   31:*/		return 0x82190B08;
		  /* 82190B08h */ case   32:  		/* lwz R11, <#[R3]> */
		/* 82190B08h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82190B08h case   32:*/		return 0x82190B0C;
		  /* 82190B0Ch */ case   33:  		/* lwz R10, <#[R11 + 8]> */
		/* 82190B0Ch case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82190B0Ch case   33:*/		return 0x82190B10;
		  /* 82190B10h */ case   34:  		/* rlwinm R10, R10, 25, 25, 31 */
		/* 82190B10h case   34:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R10);
		/* 82190B10h case   34:*/		return 0x82190B14;
		  /* 82190B14h */ case   35:  		/* cmplwi CR6, R10, 1 */
		/* 82190B14h case   35:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 82190B14h case   35:*/		return 0x82190B18;
		  /* 82190B18h */ case   36:  		/* bc 12, CR6_LT, 16 */
		/* 82190B18h case   36:*/		if ( regs.CR[6].lt ) { return 0x82190B28;  }
		/* 82190B18h case   36:*/		return 0x82190B1C;
		  /* 82190B1Ch */ case   37:  		/* cmplwi CR6, R10, 31 */
		/* 82190B1Ch case   37:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000001F);
		/* 82190B1Ch case   37:*/		return 0x82190B20;
		  /* 82190B20h */ case   38:  		/* li R10, 1 */
		/* 82190B20h case   38:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82190B20h case   38:*/		return 0x82190B24;
		  /* 82190B24h */ case   39:  		/* bc 4, CR6_GT, 8 */
		/* 82190B24h case   39:*/		if ( !regs.CR[6].gt ) { return 0x82190B2C;  }
		/* 82190B24h case   39:*/		return 0x82190B28;
	}
	return 0x82190B28;
} // Block from 82190A88h-82190B28h (40 instructions)

//////////////////////////////////////////////////////
// Block at 82190B28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190B28);
		  /* 82190B28h */ case    0:  		/* li R10, 0 */
		/* 82190B28h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82190B28h case    0:*/		return 0x82190B2C;
	}
	return 0x82190B2C;
} // Block from 82190B28h-82190B2Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82190B2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190B2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190B2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190B2C);
		  /* 82190B2Ch */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82190B2Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82190B2Ch case    0:*/		return 0x82190B30;
		  /* 82190B30h */ case    1:  		/* bc 12, CR0_EQ, 52 */
		/* 82190B30h case    1:*/		if ( regs.CR[0].eq ) { return 0x82190B64;  }
		/* 82190B30h case    1:*/		return 0x82190B34;
		  /* 82190B34h */ case    2:  		/* rlwinm R10, R11, 0, 0, 30 */
		/* 82190B34h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R11);
		/* 82190B34h case    2:*/		return 0x82190B38;
		  /* 82190B38h */ case    3:  		/* lwz R10, <#[R10 + 40]> */
		/* 82190B38h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000028) );
		/* 82190B38h case    3:*/		return 0x82190B3C;
		  /* 82190B3Ch */ case    4:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 82190B3Ch case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 82190B3Ch case    4:*/		return 0x82190B40;
		  /* 82190B40h */ case    5:  		/* bc 4, CR0_EQ, 36 */
		/* 82190B40h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82190B64;  }
		/* 82190B40h case    5:*/		return 0x82190B44;
		  /* 82190B44h */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 82190B44h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82190B44h case    6:*/		return 0x82190B48;
		  /* 82190B48h */ case    7:  		/* bc 12, CR6_EQ, 28 */
		/* 82190B48h case    7:*/		if ( regs.CR[6].eq ) { return 0x82190B64;  }
		/* 82190B48h case    7:*/		return 0x82190B4C;
		  /* 82190B4Ch */ case    8:  		/* lwz R9, <#[R10 + 20]> */
		/* 82190B4Ch case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000014) );
		/* 82190B4Ch case    8:*/		return 0x82190B50;
		  /* 82190B50h */ case    9:  		/* lwz R8, <#[R11 + 20]> */
		/* 82190B50h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 82190B50h case    9:*/		return 0x82190B54;
		  /* 82190B54h */ case   10:  		/* xor R9, R9, R8 */
		/* 82190B54h case   10:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82190B54h case   10:*/		return 0x82190B58;
		  /* 82190B58h */ case   11:  		/* rlwinm. R9, R9, 0, 19, 31 */
		/* 82190B58h case   11:*/		cpu::op::rlwinm<1,0,19,31>(regs,&regs.R9,regs.R9);
		/* 82190B58h case   11:*/		return 0x82190B5C;
		  /* 82190B5Ch */ case   12:  		/* bc 4, CR0_EQ, 8 */
		/* 82190B5Ch case   12:*/		if ( !regs.CR[0].eq ) { return 0x82190B64;  }
		/* 82190B5Ch case   12:*/		return 0x82190B60;
		  /* 82190B60h */ case   13:  		/* mr R11, R10 */
		/* 82190B60h case   13:*/		regs.R11 = regs.R10;
		/* 82190B60h case   13:*/		return 0x82190B64;
	}
	return 0x82190B64;
} // Block from 82190B2Ch-82190B64h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82190B64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190B64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190B64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190B64);
		  /* 82190B64h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 82190B64h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82190B64h case    0:*/		return 0x82190B68;
		  /* 82190B68h */ case    1:  		/* rlwinm R10, R10, 25, 25, 31 */
		/* 82190B68h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R10);
		/* 82190B68h case    1:*/		return 0x82190B6C;
		  /* 82190B6Ch */ case    2:  		/* cmplwi CR6, R10, 32 */
		/* 82190B6Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000020);
		/* 82190B6Ch case    2:*/		return 0x82190B70;
		  /* 82190B70h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 82190B70h case    3:*/		if ( regs.CR[6].lt ) { return 0x82190B80;  }
		/* 82190B70h case    3:*/		return 0x82190B74;
		  /* 82190B74h */ case    4:  		/* cmplwi CR6, R10, 82 */
		/* 82190B74h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000052);
		/* 82190B74h case    4:*/		return 0x82190B78;
		  /* 82190B78h */ case    5:  		/* li R10, 1 */
		/* 82190B78h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82190B78h case    5:*/		return 0x82190B7C;
		  /* 82190B7Ch */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 82190B7Ch case    6:*/		if ( !regs.CR[6].gt ) { return 0x82190B84;  }
		/* 82190B7Ch case    6:*/		return 0x82190B80;
	}
	return 0x82190B80;
} // Block from 82190B64h-82190B80h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82190B80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190B80);
		  /* 82190B80h */ case    0:  		/* li R10, 0 */
		/* 82190B80h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82190B80h case    0:*/		return 0x82190B84;
	}
	return 0x82190B84;
} // Block from 82190B80h-82190B84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82190B84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190B84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190B84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190B84);
		  /* 82190B84h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82190B84h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82190B84h case    0:*/		return 0x82190B88;
		  /* 82190B88h */ case    1:  		/* bc 12, CR0_EQ, 52 */
		/* 82190B88h case    1:*/		if ( regs.CR[0].eq ) { return 0x82190BBC;  }
		/* 82190B88h case    1:*/		return 0x82190B8C;
		  /* 82190B8Ch */ case    2:  		/* rlwinm R10, R11, 0, 0, 30 */
		/* 82190B8Ch case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R11);
		/* 82190B8Ch case    2:*/		return 0x82190B90;
		  /* 82190B90h */ case    3:  		/* lwz R10, <#[R10 + 40]> */
		/* 82190B90h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000028) );
		/* 82190B90h case    3:*/		return 0x82190B94;
		  /* 82190B94h */ case    4:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 82190B94h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 82190B94h case    4:*/		return 0x82190B98;
		  /* 82190B98h */ case    5:  		/* bc 4, CR0_EQ, 36 */
		/* 82190B98h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82190BBC;  }
		/* 82190B98h case    5:*/		return 0x82190B9C;
		  /* 82190B9Ch */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 82190B9Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82190B9Ch case    6:*/		return 0x82190BA0;
		  /* 82190BA0h */ case    7:  		/* bc 12, CR6_EQ, 28 */
		/* 82190BA0h case    7:*/		if ( regs.CR[6].eq ) { return 0x82190BBC;  }
		/* 82190BA0h case    7:*/		return 0x82190BA4;
		  /* 82190BA4h */ case    8:  		/* lwz R9, <#[R10 + 20]> */
		/* 82190BA4h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000014) );
		/* 82190BA4h case    8:*/		return 0x82190BA8;
		  /* 82190BA8h */ case    9:  		/* lwz R8, <#[R11 + 20]> */
		/* 82190BA8h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 82190BA8h case    9:*/		return 0x82190BAC;
		  /* 82190BACh */ case   10:  		/* xor R9, R9, R8 */
		/* 82190BACh case   10:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82190BACh case   10:*/		return 0x82190BB0;
		  /* 82190BB0h */ case   11:  		/* rlwinm. R9, R9, 0, 19, 31 */
		/* 82190BB0h case   11:*/		cpu::op::rlwinm<1,0,19,31>(regs,&regs.R9,regs.R9);
		/* 82190BB0h case   11:*/		return 0x82190BB4;
		  /* 82190BB4h */ case   12:  		/* bc 4, CR0_EQ, 8 */
		/* 82190BB4h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82190BBC;  }
		/* 82190BB4h case   12:*/		return 0x82190BB8;
		  /* 82190BB8h */ case   13:  		/* mr R11, R10 */
		/* 82190BB8h case   13:*/		regs.R11 = regs.R10;
		/* 82190BB8h case   13:*/		return 0x82190BBC;
	}
	return 0x82190BBC;
} // Block from 82190B84h-82190BBCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 82190BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190BBC);
		  /* 82190BBCh */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82190BBCh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82190BBCh case    0:*/		return 0x82190BC0;
		  /* 82190BC0h */ case    1:  		/* rlwinm R10, R4, 0, 0, 30 */
		/* 82190BC0h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R4);
		/* 82190BC0h case    1:*/		return 0x82190BC4;
		  /* 82190BC4h */ case    2:  		/* addi R11, R11, 36 */
		/* 82190BC4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82190BC4h case    2:*/		return 0x82190BC8;
		  /* 82190BC8h */ case    3:  		/* addi R10, R10, 36 */
		/* 82190BC8h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 82190BC8h case    3:*/		return 0x82190BCC;
		  /* 82190BCCh */ case    4:  		/* addi R9, R11, 4 */
		/* 82190BCCh case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 82190BCCh case    4:*/		return 0x82190BD0;
		  /* 82190BD0h */ case    5:  		/* addi R8, R10, 4 */
		/* 82190BD0h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x4);
		/* 82190BD0h case    5:*/		return 0x82190BD4;
		  /* 82190BD4h */ case    6:  		/* addi R7, R10, -36 */
		/* 82190BD4h case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFFFDC);
		/* 82190BD4h case    6:*/		return 0x82190BD8;
		  /* 82190BD8h */ case    7:  		/* lwz R6, <#[R11 + 4]> */
		/* 82190BD8h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82190BD8h case    7:*/		return 0x82190BDC;
		  /* 82190BDCh */ case    8:  		/* stw R6, <#[R10 + 4]> */
		/* 82190BDCh case    8:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 82190BDCh case    8:*/		return 0x82190BE0;
		  /* 82190BE0h */ case    9:  		/* lwz R6, <#[R11 + 4]> */
		/* 82190BE0h case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82190BE0h case    9:*/		return 0x82190BE4;
		  /* 82190BE4h */ case   10:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 82190BE4h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 82190BE4h case   10:*/		return 0x82190BE8;
	}
	return 0x82190BE8;
} // Block from 82190BBCh-82190BE8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82190BE8h
// Function '?CanSmashToTwoOperandScalarInstruction@Instruction@D3DXShader@@QAA_NPA_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190BE8);
		  /* 82190BE8h */ case    0:  		/* stw R8, <#[R6 + 36]> */
		/* 82190BE8h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000024) );
		/* 82190BE8h case    0:*/		return 0x82190BEC;
		  /* 82190BECh */ case    1:  		/* stw R9, <#[R10]> */
		/* 82190BECh case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82190BECh case    1:*/		return 0x82190BF0;
		  /* 82190BF0h */ case    2:  		/* stw R7, <#[R11 + 4]> */
		/* 82190BF0h case    2:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82190BF0h case    2:*/		return 0x82190BF4;
		  /* 82190BF4h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82190BF4h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82190BF4h case    3:*/		return 0x82190BF8;
	}
	return 0x82190BF8;
} // Block from 82190BE8h-82190BF8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82190BF8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190BF8);
		  /* 82190BF8h */ case    0:  		/* mfspr R12, LR */
		/* 82190BF8h case    0:*/		regs.R12 = regs.LR;
		/* 82190BF8h case    0:*/		return 0x82190BFC;
		  /* 82190BFCh */ case    1:  		/* bl -1046960 */
		/* 82190BFCh case    1:*/		regs.LR = 0x82190C00; return 0x8209124C;
		/* 82190BFCh case    1:*/		return 0x82190C00;
		  /* 82190C00h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82190C00h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82190C00h case    2:*/		return 0x82190C04;
		  /* 82190C04h */ case    3:  		/* addi R29, R4, 44 */
		/* 82190C04h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R4,0x2C);
		/* 82190C04h case    3:*/		return 0x82190C08;
		  /* 82190C08h */ case    4:  		/* mr R30, R4 */
		/* 82190C08h case    4:*/		regs.R30 = regs.R4;
		/* 82190C08h case    4:*/		return 0x82190C0C;
		  /* 82190C0Ch */ case    5:  		/* li R25, 0 */
		/* 82190C0Ch case    5:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82190C0Ch case    5:*/		return 0x82190C10;
		  /* 82190C10h */ case    6:  		/* mr R26, R29 */
		/* 82190C10h case    6:*/		regs.R26 = regs.R29;
		/* 82190C10h case    6:*/		return 0x82190C14;
		  /* 82190C14h */ case    7:  		/* lwz R11, <#[R30 + 8]> */
		/* 82190C14h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82190C14h case    7:*/		return 0x82190C18;
		  /* 82190C18h */ case    8:  		/* rlwinm R11, R11, 13, 29, 31 */
		/* 82190C18h case    8:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R11,regs.R11);
		/* 82190C18h case    8:*/		return 0x82190C1C;
		  /* 82190C1Ch */ case    9:  		/* cmplw CR6, R25, R11 */
		/* 82190C1Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 82190C1Ch case    9:*/		return 0x82190C20;
		  /* 82190C20h */ case   10:  		/* bc 4, CR6_LT, 424 */
		/* 82190C20h case   10:*/		if ( !regs.CR[6].lt ) { return 0x82190DC8;  }
		/* 82190C20h case   10:*/		return 0x82190C24;
		  /* 82190C24h */ case   11:  		/* lwz R11, <#[R26]> */
		/* 82190C24h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82190C24h case   11:*/		return 0x82190C28;
		  /* 82190C28h */ case   12:  		/* lwz R27, <#[R11 + 12]> */
		/* 82190C28h case   12:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x0000000C) );
		/* 82190C28h case   12:*/		return 0x82190C2C;
		  /* 82190C2Ch */ case   13:  		/* addi R28, R27, 4 */
		/* 82190C2Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R27,0x4);
		/* 82190C2Ch case   13:*/		return 0x82190C30;
		  /* 82190C30h */ case   14:  		/* lwz R31, <#[R28]> */
		/* 82190C30h case   14:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x00000000) );
		/* 82190C30h case   14:*/		return 0x82190C34;
		  /* 82190C34h */ case   15:  		/* cmplwi CR6, R31, 0 */
		/* 82190C34h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82190C34h case   15:*/		return 0x82190C38;
		  /* 82190C38h */ case   16:  		/* bc 12, CR6_EQ, 388 */
		/* 82190C38h case   16:*/		if ( regs.CR[6].eq ) { return 0x82190DBC;  }
		/* 82190C38h case   16:*/		return 0x82190C3C;
		  /* 82190C3Ch */ case   17:  		/* lwz R4, <#[R31 + 16]> */
		/* 82190C3Ch case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 82190C3Ch case   17:*/		return 0x82190C40;
		  /* 82190C40h */ case   18:  		/* cmplwi CR6, R4, 0 */
		/* 82190C40h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82190C40h case   18:*/		return 0x82190C44;
		  /* 82190C44h */ case   19:  		/* bc 12, CR6_EQ, 356 */
		/* 82190C44h case   19:*/		if ( regs.CR[6].eq ) { return 0x82190DA8;  }
		/* 82190C44h case   19:*/		return 0x82190C48;
		  /* 82190C48h */ case   20:  		/* lwz R11, <#[R31]> */
		/* 82190C48h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82190C48h case   20:*/		return 0x82190C4C;
		  /* 82190C4Ch */ case   21:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82190C4Ch case   21:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82190C4Ch case   21:*/		return 0x82190C50;
		  /* 82190C50h */ case   22:  		/* bc 12, CR0_EQ, 344 */
		/* 82190C50h case   22:*/		if ( regs.CR[0].eq ) { return 0x82190DA8;  }
		/* 82190C50h case   22:*/		return 0x82190C54;
		  /* 82190C54h */ case   23:  		/* cmplw CR6, R4, R30 */
		/* 82190C54h case   23:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R30);
		/* 82190C54h case   23:*/		return 0x82190C58;
		  /* 82190C58h */ case   24:  		/* bc 12, CR6_EQ, 336 */
		/* 82190C58h case   24:*/		if ( regs.CR[6].eq ) { return 0x82190DA8;  }
		/* 82190C58h case   24:*/		return 0x82190C5C;
		  /* 82190C5Ch */ case   25:  		/* lbz R11, <#[R4 + 16]> */
		/* 82190C5Ch case   25:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 82190C5Ch case   25:*/		return 0x82190C60;
		  /* 82190C60h */ case   26:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82190C60h case   26:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82190C60h case   26:*/		return 0x82190C64;
		  /* 82190C64h */ case   27:  		/* bc 12, CR0_EQ, 324 */
		/* 82190C64h case   27:*/		if ( regs.CR[0].eq ) { return 0x82190DA8;  }
		/* 82190C64h case   27:*/		return 0x82190C68;
		  /* 82190C68h */ case   28:  		/* mr R3, R30 */
		/* 82190C68h case   28:*/		regs.R3 = regs.R30;
		/* 82190C68h case   28:*/		return 0x82190C6C;
		  /* 82190C6Ch */ case   29:  		/* bl -127908 */
		/* 82190C6Ch case   29:*/		regs.LR = 0x82190C70; return 0x821718C8;
		/* 82190C6Ch case   29:*/		return 0x82190C70;
		  /* 82190C70h */ case   30:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82190C70h case   30:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82190C70h case   30:*/		return 0x82190C74;
		  /* 82190C74h */ case   31:  		/* bc 12, CR0_EQ, 308 */
		/* 82190C74h case   31:*/		if ( regs.CR[0].eq ) { return 0x82190DA8;  }
		/* 82190C74h case   31:*/		return 0x82190C78;
		  /* 82190C78h */ case   32:  		/* lwz R10, <#[R30 + 8]> */
		/* 82190C78h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82190C78h case   32:*/		return 0x82190C7C;
		  /* 82190C7Ch */ case   33:  		/* li R8, 0 */
		/* 82190C7Ch case   33:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82190C7Ch case   33:*/		return 0x82190C80;
		  /* 82190C80h */ case   34:  		/* li R11, 0 */
		/* 82190C80h case   34:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82190C80h case   34:*/		return 0x82190C84;
		  /* 82190C84h */ case   35:  		/* rlwinm R7, R10, 13, 29, 31 */
		/* 82190C84h case   35:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R7,regs.R10);
		/* 82190C84h case   35:*/		return 0x82190C88;
		  /* 82190C88h */ case   36:  		/* mr R10, R29 */
		/* 82190C88h case   36:*/		regs.R10 = regs.R29;
		/* 82190C88h case   36:*/		return 0x82190C8C;
		  /* 82190C8Ch */ case   37:  		/* cmplw CR6, R11, R7 */
		/* 82190C8Ch case   37:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 82190C8Ch case   37:*/		return 0x82190C90;
		  /* 82190C90h */ case   38:  		/* bc 4, CR6_LT, 60 */
		/* 82190C90h case   38:*/		if ( !regs.CR[6].lt ) { return 0x82190CCC;  }
		/* 82190C90h case   38:*/		return 0x82190C94;
		  /* 82190C94h */ case   39:  		/* lwz R9, <#[R10]> */
		/* 82190C94h case   39:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82190C94h case   39:*/		return 0x82190C98;
		  /* 82190C98h */ case   40:  		/* lwz R6, <#[R9 + 12]> */
		/* 82190C98h case   40:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + 0x0000000C) );
		/* 82190C98h case   40:*/		return 0x82190C9C;
		  /* 82190C9Ch */ case   41:  		/* cmplw CR6, R6, R27 */
		/* 82190C9Ch case   41:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R27);
		/* 82190C9Ch case   41:*/		return 0x82190CA0;
		  /* 82190CA0h */ case   42:  		/* bc 4, CR6_EQ, 32 */
		/* 82190CA0h case   42:*/		if ( !regs.CR[6].eq ) { return 0x82190CC0;  }
		/* 82190CA0h case   42:*/		return 0x82190CA4;
		  /* 82190CA4h */ case   43:  		/* lwz R9, <#[R9]> */
		/* 82190CA4h case   43:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 82190CA4h case   43:*/		return 0x82190CA8;
		  /* 82190CA8h */ case   44:  		/* li R6, 3 */
		/* 82190CA8h case   44:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 82190CA8h case   44:*/		return 0x82190CAC;
		  /* 82190CACh */ case   45:  		/* rlwinm R9, R9, 28, 29, 30 */
		/* 82190CACh case   45:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R9,regs.R9);
		/* 82190CACh case   45:*/		return 0x82190CB0;
		  /* 82190CB0h */ case   46:  		/* slw R6, R6, R9 */
		/* 82190CB0h case   46:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R6,regs.R9);
		/* 82190CB0h case   46:*/		return 0x82190CB4;
		  /* 82190CB4h */ case   47:  		/* andc R8, R8, R6 */
		/* 82190CB4h case   47:*/		cpu::op::andc<0>(regs,&regs.R8,regs.R8,regs.R6);
		/* 82190CB4h case   47:*/		return 0x82190CB8;
		  /* 82190CB8h */ case   48:  		/* slw R9, R11, R9 */
		/* 82190CB8h case   48:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 82190CB8h case   48:*/		return 0x82190CBC;
		  /* 82190CBCh */ case   49:  		/* or R8, R8, R9 */
		/* 82190CBCh case   49:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R9);
		/* 82190CBCh case   49:*/		return 0x82190CC0;
	}
	return 0x82190CC0;
} // Block from 82190BF8h-82190CC0h (50 instructions)

//////////////////////////////////////////////////////
// Block at 82190CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190CC0);
		  /* 82190CC0h */ case    0:  		/* addi R11, R11, 1 */
		/* 82190CC0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82190CC0h case    0:*/		return 0x82190CC4;
		  /* 82190CC4h */ case    1:  		/* addi R10, R10, 4 */
		/* 82190CC4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82190CC4h case    1:*/		return 0x82190CC8;
		  /* 82190CC8h */ case    2:  		/* b -60 */
		/* 82190CC8h case    2:*/		return 0x82190C8C;
		/* 82190CC8h case    2:*/		return 0x82190CCC;
	}
	return 0x82190CCC;
} // Block from 82190CC0h-82190CCCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82190CCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190CCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190CCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190CCC);
		  /* 82190CCCh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82190CCCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82190CCCh case    0:*/		return 0x82190CD0;
		  /* 82190CD0h */ case    1:  		/* rlwinm. R11, R11, 2, 31, 31 */
		/* 82190CD0h case    1:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R11,regs.R11);
		/* 82190CD0h case    1:*/		return 0x82190CD4;
		  /* 82190CD4h */ case    2:  		/* bc 12, CR0_EQ, 76 */
		/* 82190CD4h case    2:*/		if ( regs.CR[0].eq ) { return 0x82190D20;  }
		/* 82190CD4h case    2:*/		return 0x82190CD8;
		  /* 82190CD8h */ case    3:  		/* lwz R11, <#[R30 + 4]> */
		/* 82190CD8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82190CD8h case    3:*/		return 0x82190CDC;
		  /* 82190CDCh */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82190CDCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82190CDCh case    4:*/		return 0x82190CE0;
		  /* 82190CE0h */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 82190CE0h case    5:*/		if ( regs.CR[6].eq ) { return 0x82190D04;  }
		/* 82190CE0h case    5:*/		return 0x82190CE4;
		  /* 82190CE4h */ case    6:  		/* lwz R10, <#[R11 + 16]> */
		/* 82190CE4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82190CE4h case    6:*/		return 0x82190CE8;
		  /* 82190CE8h */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 82190CE8h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82190CE8h case    7:*/		return 0x82190CEC;
		  /* 82190CECh */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 82190CECh case    8:*/		if ( regs.CR[6].eq ) { return 0x82190CFC;  }
		/* 82190CECh case    8:*/		return 0x82190CF0;
		  /* 82190CF0h */ case    9:  		/* lwz R10, <#[R11]> */
		/* 82190CF0h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82190CF0h case    9:*/		return 0x82190CF4;
		  /* 82190CF4h */ case   10:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 82190CF4h case   10:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 82190CF4h case   10:*/		return 0x82190CF8;
		  /* 82190CF8h */ case   11:  		/* bc 4, CR0_EQ, 12 */
		/* 82190CF8h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82190D04;  }
		/* 82190CF8h case   11:*/		return 0x82190CFC;
	}
	return 0x82190CFC;
} // Block from 82190CCCh-82190CFCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 82190CFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190CFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190CFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190CFC);
		  /* 82190CFCh */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82190CFCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82190CFCh case    0:*/		return 0x82190D00;
		  /* 82190D00h */ case    1:  		/* b -36 */
		/* 82190D00h case    1:*/		return 0x82190CDC;
		/* 82190D00h case    1:*/		return 0x82190D04;
	}
	return 0x82190D04;
} // Block from 82190CFCh-82190D04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82190D04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190D04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190D04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190D04);
		  /* 82190D04h */ case    0:  		/* lwz R10, <#[R31]> */
		/* 82190D04h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82190D04h case    0:*/		return 0x82190D08;
		  /* 82190D08h */ case    1:  		/* rlwinm R10, R10, 0, 2, 0 */
		/* 82190D08h case    1:*/		cpu::op::rlwinm<0,0,2,0>(regs,&regs.R10,regs.R10);
		/* 82190D08h case    1:*/		return 0x82190D0C;
		  /* 82190D0Ch */ case    2:  		/* stw R10, <#[R31]> */
		/* 82190D0Ch case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82190D0Ch case    2:*/		return 0x82190D10;
		  /* 82190D10h */ case    3:  		/* lwz R11, <#[R11]> */
		/* 82190D10h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82190D10h case    3:*/		return 0x82190D14;
		  /* 82190D14h */ case    4:  		/* rlwimi R11, R10, 0, 19, 6 */
		/* 82190D14h case    4:*/		cpu::op::rlwimi<0,0,19,6>(regs,&regs.R11,regs.R10);
		/* 82190D14h case    4:*/		return 0x82190D18;
		  /* 82190D18h */ case    5:  		/* oris R11, R11, 16384 */
		/* 82190D18h case    5:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 82190D18h case    5:*/		return 0x82190D1C;
		  /* 82190D1Ch */ case    6:  		/* stw R11, <#[R31]> */
		/* 82190D1Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82190D1Ch case    6:*/		return 0x82190D20;
	}
	return 0x82190D20;
} // Block from 82190D04h-82190D20h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82190D20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190D20);
		  /* 82190D20h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82190D20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82190D20h case    0:*/		return 0x82190D24;
		  /* 82190D24h */ case    1:  		/* addi R11, R11, 4 */
		/* 82190D24h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82190D24h case    1:*/		return 0x82190D28;
		  /* 82190D28h */ case    2:  		/* lwz R10, <#[R11]> */
		/* 82190D28h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82190D28h case    2:*/		return 0x82190D2C;
		  /* 82190D2Ch */ case    3:  		/* b 12 */
		/* 82190D2Ch case    3:*/		return 0x82190D38;
		/* 82190D2Ch case    3:*/		return 0x82190D30;
		  /* 82190D30h */ case    4:  		/* addi R11, R10, 8 */
		/* 82190D30h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 82190D30h case    4:*/		return 0x82190D34;
		  /* 82190D34h */ case    5:  		/* lwz R10, <#[R10 + 8]> */
		/* 82190D34h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82190D34h case    5:*/		return 0x82190D38;
	}
	return 0x82190D38;
} // Block from 82190D20h-82190D38h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82190D38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190D38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190D38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190D38);
		  /* 82190D38h */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 82190D38h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 82190D38h case    0:*/		return 0x82190D3C;
		  /* 82190D3Ch */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82190D3Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82190D30;  }
		/* 82190D3Ch case    1:*/		return 0x82190D40;
		  /* 82190D40h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 82190D40h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82190D40h case    2:*/		return 0x82190D44;
		  /* 82190D44h */ case    3:  		/* stw R10, <#[R11]> */
		/* 82190D44h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82190D44h case    3:*/		return 0x82190D48;
		  /* 82190D48h */ case    4:  		/* lwz R11, <#[R30 + 4]> */
		/* 82190D48h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82190D48h case    4:*/		return 0x82190D4C;
		  /* 82190D4Ch */ case    5:  		/* stw R11, <#[R31 + 8]> */
		/* 82190D4Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82190D4Ch case    5:*/		return 0x82190D50;
		  /* 82190D50h */ case    6:  		/* stw R31, <#[R30 + 4]> */
		/* 82190D50h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000004) );
		/* 82190D50h case    6:*/		return 0x82190D54;
		  /* 82190D54h */ case    7:  		/* lwz R11, <#[R31]> */
		/* 82190D54h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82190D54h case    7:*/		return 0x82190D58;
		  /* 82190D58h */ case    8:  		/* mr R10, R11 */
		/* 82190D58h case    8:*/		regs.R10 = regs.R11;
		/* 82190D58h case    8:*/		return 0x82190D5C;
		  /* 82190D5Ch */ case    9:  		/* rlwinm R10, R10, 27, 24, 31 */
		/* 82190D5Ch case    9:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R10);
		/* 82190D5Ch case    9:*/		return 0x82190D60;
		  /* 82190D60h */ case   10:  		/* stw R30, <#[R31 + 12]> */
		/* 82190D60h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 82190D60h case   10:*/		return 0x82190D64;
		  /* 82190D64h */ case   11:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82190D64h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82190D64h case   11:*/		return 0x82190D68;
		  /* 82190D68h */ case   12:  		/* rlwinm R9, R10, 27, 29, 30 */
		/* 82190D68h case   12:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R9,regs.R10);
		/* 82190D68h case   12:*/		return 0x82190D6C;
		  /* 82190D6Ch */ case   13:  		/* rlwinm R7, R10, 29, 29, 30 */
		/* 82190D6Ch case   13:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R7,regs.R10);
		/* 82190D6Ch case   13:*/		return 0x82190D70;
		  /* 82190D70h */ case   14:  		/* srw R9, R8, R9 */
		/* 82190D70h case   14:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82190D70h case   14:*/		return 0x82190D74;
		  /* 82190D74h */ case   15:  		/* srw R7, R8, R7 */
		/* 82190D74h case   15:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R8,regs.R7);
		/* 82190D74h case   15:*/		return 0x82190D78;
		  /* 82190D78h */ case   16:  		/* rlwimi R7, R9, 2, 28, 29 */
		/* 82190D78h case   16:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R7,regs.R9);
		/* 82190D78h case   16:*/		return 0x82190D7C;
		  /* 82190D7Ch */ case   17:  		/* rlwinm R9, R10, 31, 29, 30 */
		/* 82190D7Ch case   17:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R9,regs.R10);
		/* 82190D7Ch case   17:*/		return 0x82190D80;
		  /* 82190D80h */ case   18:  		/* rlwinm R10, R10, 1, 29, 30 */
		/* 82190D80h case   18:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R10,regs.R10);
		/* 82190D80h case   18:*/		return 0x82190D84;
		  /* 82190D84h */ case   19:  		/* rlwinm R7, R7, 0, 28, 31 */
		/* 82190D84h case   19:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R7,regs.R7);
		/* 82190D84h case   19:*/		return 0x82190D88;
		  /* 82190D88h */ case   20:  		/* srw R9, R8, R9 */
		/* 82190D88h case   20:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82190D88h case   20:*/		return 0x82190D8C;
		  /* 82190D8Ch */ case   21:  		/* srw R10, R8, R10 */
		/* 82190D8Ch case   21:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 82190D8Ch case   21:*/		return 0x82190D90;
		  /* 82190D90h */ case   22:  		/* rlwimi R9, R7, 2, 0, 29 */
		/* 82190D90h case   22:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R7);
		/* 82190D90h case   22:*/		return 0x82190D94;
		  /* 82190D94h */ case   23:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 82190D94h case   23:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 82190D94h case   23:*/		return 0x82190D98;
		  /* 82190D98h */ case   24:  		/* rlwimi R10, R9, 2, 0, 29 */
		/* 82190D98h case   24:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 82190D98h case   24:*/		return 0x82190D9C;
		  /* 82190D9Ch */ case   25:  		/* rlwinm R10, R10, 5, 0, 26 */
		/* 82190D9Ch case   25:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R10);
		/* 82190D9Ch case   25:*/		return 0x82190DA0;
		  /* 82190DA0h */ case   26:  		/* or R11, R10, R11 */
		/* 82190DA0h case   26:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82190DA0h case   26:*/		return 0x82190DA4;
		  /* 82190DA4h */ case   27:  		/* stw R11, <#[R31]> */
		/* 82190DA4h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82190DA4h case   27:*/		return 0x82190DA8;
	}
	return 0x82190DA8;
} // Block from 82190D38h-82190DA8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82190DA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190DA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190DA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190DA8);
		  /* 82190DA8h */ case    0:  		/* lwz R11, <#[R28]> */
		/* 82190DA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82190DA8h case    0:*/		return 0x82190DAC;
		  /* 82190DACh */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 82190DACh case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 82190DACh case    1:*/		return 0x82190DB0;
		  /* 82190DB0h */ case    2:  		/* bc 4, CR6_EQ, -384 */
		/* 82190DB0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82190C30;  }
		/* 82190DB0h case    2:*/		return 0x82190DB4;
		  /* 82190DB4h */ case    3:  		/* addi R28, R31, 8 */
		/* 82190DB4h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x8);
		/* 82190DB4h case    3:*/		return 0x82190DB8;
		  /* 82190DB8h */ case    4:  		/* b -392 */
		/* 82190DB8h case    4:*/		return 0x82190C30;
		/* 82190DB8h case    4:*/		return 0x82190DBC;
	}
	return 0x82190DBC;
} // Block from 82190DA8h-82190DBCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82190DBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190DBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190DBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190DBC);
		  /* 82190DBCh */ case    0:  		/* addi R25, R25, 1 */
		/* 82190DBCh case    0:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 82190DBCh case    0:*/		return 0x82190DC0;
		  /* 82190DC0h */ case    1:  		/* addi R26, R26, 4 */
		/* 82190DC0h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 82190DC0h case    1:*/		return 0x82190DC4;
		  /* 82190DC4h */ case    2:  		/* b -432 */
		/* 82190DC4h case    2:*/		return 0x82190C14;
		/* 82190DC4h case    2:*/		return 0x82190DC8;
	}
	return 0x82190DC8;
} // Block from 82190DBCh-82190DC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82190DC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190DC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190DC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190DC8);
		  /* 82190DC8h */ case    0:  		/* addi R1, R1, 144 */
		/* 82190DC8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82190DC8h case    0:*/		return 0x82190DCC;
		  /* 82190DCCh */ case    1:  		/* b -1047344 */
		/* 82190DCCh case    1:*/		return 0x8209129C;
		/* 82190DCCh case    1:*/		return 0x82190DD0;
	}
	return 0x82190DD0;
} // Block from 82190DC8h-82190DD0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82190DD0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190DD0);
		  /* 82190DD0h */ case    0:  		/* mfspr R12, LR */
		/* 82190DD0h case    0:*/		regs.R12 = regs.LR;
		/* 82190DD0h case    0:*/		return 0x82190DD4;
		  /* 82190DD4h */ case    1:  		/* bl -1047444 */
		/* 82190DD4h case    1:*/		regs.LR = 0x82190DD8; return 0x82091240;
		/* 82190DD4h case    1:*/		return 0x82190DD8;
		  /* 82190DD8h */ case    2:  		/* stfd FR31, <#[R1 - 96]> */
		/* 82190DD8h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA0) );
		/* 82190DD8h case    2:*/		return 0x82190DDC;
		  /* 82190DDCh */ case    3:  		/* stwu R1, <#[R1 - 192]> */
		/* 82190DDCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82190DDCh case    3:*/		return 0x82190DE0;
		  /* 82190DE0h */ case    4:  		/* lwz R31, <#[R3 + 8]> */
		/* 82190DE0h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000008) );
		/* 82190DE0h case    4:*/		return 0x82190DE4;
		  /* 82190DE4h */ case    5:  		/* mr R26, R3 */
		/* 82190DE4h case    5:*/		regs.R26 = regs.R3;
		/* 82190DE4h case    5:*/		return 0x82190DE8;
		  /* 82190DE8h */ case    6:  		/* rlwinm R25, R31, 18, 29, 31 */
		/* 82190DE8h case    6:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R25,regs.R31);
		/* 82190DE8h case    6:*/		return 0x82190DEC;
		  /* 82190DECh */ case    7:  		/* bl -131132 */
		/* 82190DECh case    7:*/		regs.LR = 0x82190DF0; return 0x82170DB0;
		/* 82190DECh case    7:*/		return 0x82190DF0;
		  /* 82190DF0h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82190DF0h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82190DF0h case    8:*/		return 0x82190DF4;
		  /* 82190DF4h */ case    9:  		/* bc 12, CR0_EQ, 32 */
		/* 82190DF4h case    9:*/		if ( regs.CR[0].eq ) { return 0x82190E14;  }
		/* 82190DF4h case    9:*/		return 0x82190DF8;
		  /* 82190DF8h */ case   10:  		/* lwz R11, <#[R26 + 44]> */
		/* 82190DF8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000002C) );
		/* 82190DF8h case   10:*/		return 0x82190DFC;
		  /* 82190DFCh */ case   11:  		/* lwz R11, <#[R11]> */
		/* 82190DFCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82190DFCh case   11:*/		return 0x82190E00;
		  /* 82190E00h */ case   12:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 82190E00h case   12:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 82190E00h case   12:*/		return 0x82190E04;
		  /* 82190E04h */ case   13:  		/* cmplw CR6, R25, R11 */
		/* 82190E04h case   13:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 82190E04h case   13:*/		return 0x82190E08;
		  /* 82190E08h */ case   14:  		/* bc 12, CR6_EQ, 12 */
		/* 82190E08h case   14:*/		if ( regs.CR[6].eq ) { return 0x82190E14;  }
		/* 82190E08h case   14:*/		return 0x82190E0C;
		  /* 82190E0Ch */ case   15:  		/* li R3, -1 */
		/* 82190E0Ch case   15:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82190E0Ch case   15:*/		return 0x82190E10;
		  /* 82190E10h */ case   16:  		/* b 956 */
		/* 82190E10h case   16:*/		return 0x821911CC;
		/* 82190E10h case   16:*/		return 0x82190E14;
	}
	return 0x82190E14;
} // Block from 82190DD0h-82190E14h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82190E14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190E14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190E14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190E14);
		  /* 82190E14h */ case    0:  		/* rlwinm R9, R31, 25, 25, 31 */
		/* 82190E14h case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R9,regs.R31);
		/* 82190E14h case    0:*/		return 0x82190E18;
		  /* 82190E18h */ case    1:  		/* li R22, -1 */
		/* 82190E18h case    1:*/		cpu::op::li<0>(regs,&regs.R22,0xFFFFFFFF);
		/* 82190E18h case    1:*/		return 0x82190E1C;
		  /* 82190E1Ch */ case    2:  		/* li R23, 1 */
		/* 82190E1Ch case    2:*/		cpu::op::li<0>(regs,&regs.R23,0x1);
		/* 82190E1Ch case    2:*/		return 0x82190E20;
		  /* 82190E20h */ case    3:  		/* mr R24, R22 */
		/* 82190E20h case    3:*/		regs.R24 = regs.R22;
		/* 82190E20h case    3:*/		return 0x82190E24;
		  /* 82190E24h */ case    4:  		/* li R27, 0 */
		/* 82190E24h case    4:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82190E24h case    4:*/		return 0x82190E28;
		  /* 82190E28h */ case    5:  		/* cmplwi CR6, R9, 8 */
		/* 82190E28h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000008);
		/* 82190E28h case    5:*/		return 0x82190E2C;
		  /* 82190E2Ch */ case    6:  		/* bc 12, CR6_GT, 396 */
		/* 82190E2Ch case    6:*/		if ( regs.CR[6].gt ) { return 0x82190FB8;  }
		/* 82190E2Ch case    6:*/		return 0x82190E30;
		  /* 82190E30h */ case    7:  		/* cmplwi CR6, R9, 5 */
		/* 82190E30h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000005);
		/* 82190E30h case    7:*/		return 0x82190E34;
		  /* 82190E34h */ case    8:  		/* bc 4, CR6_LT, 420 */
		/* 82190E34h case    8:*/		if ( !regs.CR[6].lt ) { return 0x82190FD8;  }
		/* 82190E34h case    8:*/		return 0x82190E38;
		  /* 82190E38h */ case    9:  		/* cmplwi CR6, R9, 0 */
		/* 82190E38h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82190E38h case    9:*/		return 0x82190E3C;
		  /* 82190E3Ch */ case   10:  		/* bc 12, CR6_EQ, 908 */
		/* 82190E3Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x821911C8;  }
		/* 82190E3Ch case   10:*/		return 0x82190E40;
		  /* 82190E40h */ case   11:  		/* cmplwi CR6, R9, 2 */
		/* 82190E40h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000002);
		/* 82190E40h case   11:*/		return 0x82190E44;
		  /* 82190E44h */ case   12:  		/* bc 4, CR6_GT, 72 */
		/* 82190E44h case   12:*/		if ( !regs.CR[6].gt ) { return 0x82190E8C;  }
		/* 82190E44h case   12:*/		return 0x82190E48;
		  /* 82190E48h */ case   13:  		/* cmplwi CR6, R9, 4 */
		/* 82190E48h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000004);
		/* 82190E48h case   13:*/		return 0x82190E4C;
		  /* 82190E4Ch */ case   14:  		/* bc 12, CR6_GT, 892 */
		/* 82190E4Ch case   14:*/		if ( regs.CR[6].gt ) { return 0x821911C8;  }
		/* 82190E4Ch case   14:*/		return 0x82190E50;
	}
	return 0x82190E50;
} // Block from 82190E14h-82190E50h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82190E50h
// Function '?SimulateForwards@MachineState@D3DXShader@@QAAXPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190E50);
		  /* 82190E50h */ case    0:  		/* lwz R11, <#[R26 + 44]> */
		/* 82190E50h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000002C) );
		/* 82190E50h case    0:*/		return 0x82190E54;
		  /* 82190E54h */ case    1:  		/* mr R24, R25 */
		/* 82190E54h case    1:*/		regs.R24 = regs.R25;
		/* 82190E54h case    1:*/		return 0x82190E58;
		  /* 82190E58h */ case    2:  		/* lwz R10, <#[R26 + 48]> */
		/* 82190E58h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000030) );
		/* 82190E58h case    2:*/		return 0x82190E5C;
		  /* 82190E5Ch */ case    3:  		/* lwz R9, <#[R11 + 12]> */
		/* 82190E5Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82190E5Ch case    3:*/		return 0x82190E60;
		  /* 82190E60h */ case    4:  		/* lwz R8, <#[R10 + 12]> */
		/* 82190E60h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x0000000C) );
		/* 82190E60h case    4:*/		return 0x82190E64;
		  /* 82190E64h */ case    5:  		/* cmpw CR6, R9, R8 */
		/* 82190E64h case    5:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R8);
		/* 82190E64h case    5:*/		return 0x82190E68;
		  /* 82190E68h */ case    6:  		/* bc 4, CR6_EQ, 24 */
		/* 82190E68h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82190E80;  }
		/* 82190E68h case    6:*/		return 0x82190E6C;
		  /* 82190E6Ch */ case    7:  		/* lwz R11, <#[R11]> */
		/* 82190E6Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82190E6Ch case    7:*/		return 0x82190E70;
		  /* 82190E70h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 82190E70h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 82190E70h case    8:*/		return 0x82190E74;
		  /* 82190E74h */ case    9:  		/* xor R11, R10, R11 */
		/* 82190E74h case    9:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82190E74h case    9:*/		return 0x82190E78;
		  /* 82190E78h */ case   10:  		/* rlwinm. R11, R11, 0, 27, 31 */
		/* 82190E78h case   10:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82190E78h case   10:*/		return 0x82190E7C;
		  /* 82190E7Ch */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 82190E7Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x82190E84;  }
		/* 82190E7Ch case   11:*/		return 0x82190E80;
	}
	return 0x82190E80;
} // Block from 82190E50h-82190E80h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82190E80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190E80);
		  /* 82190E80h */ case    0:  		/* mulli R24, R25, 3 */
		/* 82190E80h case    0:*/		cpu::op::mulli<0>(regs,&regs.R24,regs.R25,0x3);
		/* 82190E80h case    0:*/		return 0x82190E84;
	}
	return 0x82190E84;
} // Block from 82190E80h-82190E84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82190E84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190E84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190E84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190E84);
		  /* 82190E84h */ case    0:  		/* subfic R11, R25, 1 */
		/* 82190E84h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R25,0x1);
		/* 82190E84h case    0:*/		return 0x82190E88;
		  /* 82190E88h */ case    1:  		/* b 596 */
		/* 82190E88h case    1:*/		return 0x821910DC;
		/* 82190E88h case    1:*/		return 0x82190E8C;
	}
	return 0x82190E8C;
} // Block from 82190E84h-82190E8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82190E8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190E8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190E8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190E8C);
		  /* 82190E8Ch */ case    0:  		/* lwz R31, <#[R26 + 48]> */
		/* 82190E8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R26 + 0x00000030) );
		/* 82190E8Ch case    0:*/		return 0x82190E90;
		  /* 82190E90h */ case    1:  		/* lwz R30, <#[R26 + 44]> */
		/* 82190E90h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x0000002C) );
		/* 82190E90h case    1:*/		return 0x82190E94;
		  /* 82190E94h */ case    2:  		/* stb R23, <#[R1 + 80]> */
		/* 82190E94h case    2:*/		cpu::mem::store8( regs, regs.R23, (uint32)(regs.R1 + 0x00000050) );
		/* 82190E94h case    2:*/		return 0x82190E98;
		  /* 82190E98h */ case    3:  		/* lwz R29, <#[R31 + 12]> */
		/* 82190E98h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 82190E98h case    3:*/		return 0x82190E9C;
		  /* 82190E9Ch */ case    4:  		/* lwz R28, <#[R30 + 12]> */
		/* 82190E9Ch case    4:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x0000000C) );
		/* 82190E9Ch case    4:*/		return 0x82190EA0;
		  /* 82190EA0h */ case    5:  		/* lwz R11, <#[R29 + 8]> */
		/* 82190EA0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82190EA0h case    5:*/		return 0x82190EA4;
		  /* 82190EA4h */ case    6:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82190EA4h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82190EA4h case    6:*/		return 0x82190EA8;
		  /* 82190EA8h */ case    7:  		/* cmplwi CR6, R11, 125 */
		/* 82190EA8h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82190EA8h case    7:*/		return 0x82190EAC;
		  /* 82190EACh */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 82190EACh case    8:*/		if ( regs.CR[6].eq ) { return 0x82190EBC;  }
		/* 82190EACh case    8:*/		return 0x82190EB0;
		  /* 82190EB0h */ case    9:  		/* cmplwi CR6, R11, 124 */
		/* 82190EB0h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82190EB0h case    9:*/		return 0x82190EB4;
		  /* 82190EB4h */ case   10:  		/* li R11, 0 */
		/* 82190EB4h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82190EB4h case   10:*/		return 0x82190EB8;
		  /* 82190EB8h */ case   11:  		/* bc 4, CR6_EQ, 8 */
		/* 82190EB8h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82190EC0;  }
		/* 82190EB8h case   11:*/		return 0x82190EBC;
	}
	return 0x82190EBC;
} // Block from 82190E8Ch-82190EBCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 82190EBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190EBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190EBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190EBC);
		  /* 82190EBCh */ case    0:  		/* mr R11, R23 */
		/* 82190EBCh case    0:*/		regs.R11 = regs.R23;
		/* 82190EBCh case    0:*/		return 0x82190EC0;
	}
	return 0x82190EC0;
} // Block from 82190EBCh-82190EC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82190EC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190EC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190EC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190EC0);
		  /* 82190EC0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82190EC0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82190EC0h case    0:*/		return 0x82190EC4;
		  /* 82190EC4h */ case    1:  		/* bc 12, CR0_EQ, 152 */
		/* 82190EC4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82190F5C;  }
		/* 82190EC4h case    1:*/		return 0x82190EC8;
		  /* 82190EC8h */ case    2:  		/* lwz R11, <#[R28 + 8]> */
		/* 82190EC8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 82190EC8h case    2:*/		return 0x82190ECC;
		  /* 82190ECCh */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82190ECCh case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82190ECCh case    3:*/		return 0x82190ED0;
		  /* 82190ED0h */ case    4:  		/* cmplwi CR6, R11, 125 */
		/* 82190ED0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82190ED0h case    4:*/		return 0x82190ED4;
		  /* 82190ED4h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 82190ED4h case    5:*/		if ( regs.CR[6].eq ) { return 0x82190EE4;  }
		/* 82190ED4h case    5:*/		return 0x82190ED8;
		  /* 82190ED8h */ case    6:  		/* cmplwi CR6, R11, 124 */
		/* 82190ED8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82190ED8h case    6:*/		return 0x82190EDC;
		  /* 82190EDCh */ case    7:  		/* li R11, 0 */
		/* 82190EDCh case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82190EDCh case    7:*/		return 0x82190EE0;
		  /* 82190EE0h */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 82190EE0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82190EE8;  }
		/* 82190EE0h case    8:*/		return 0x82190EE4;
	}
	return 0x82190EE4;
} // Block from 82190EC0h-82190EE4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82190EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190EE4);
		  /* 82190EE4h */ case    0:  		/* mr R11, R23 */
		/* 82190EE4h case    0:*/		regs.R11 = regs.R23;
		/* 82190EE4h case    0:*/		return 0x82190EE8;
	}
	return 0x82190EE8;
} // Block from 82190EE4h-82190EE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82190EE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190EE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190EE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190EE8);
		  /* 82190EE8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82190EE8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82190EE8h case    0:*/		return 0x82190EEC;
		  /* 82190EECh */ case    1:  		/* bc 4, CR0_EQ, 112 */
		/* 82190EECh case    1:*/		if ( !regs.CR[0].eq ) { return 0x82190F5C;  }
		/* 82190EECh case    1:*/		return 0x82190EF0;
		  /* 82190EF0h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 82190EF0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82190EF0h case    2:*/		return 0x82190EF4;
		  /* 82190EF4h */ case    3:  		/* lwz R10, <#[R30]> */
		/* 82190EF4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82190EF4h case    3:*/		return 0x82190EF8;
		  /* 82190EF8h */ case    4:  		/* xor R8, R10, R11 */
		/* 82190EF8h case    4:*/		cpu::op::xor<0>(regs,&regs.R8,regs.R10,regs.R11);
		/* 82190EF8h case    4:*/		return 0x82190EFC;
		  /* 82190EFCh */ case    5:  		/* rlwinm. R8, R8, 0, 27, 30 */
		/* 82190EFCh case    5:*/		cpu::op::rlwinm<1,0,27,30>(regs,&regs.R8,regs.R8);
		/* 82190EFCh case    5:*/		return 0x82190F00;
		  /* 82190F00h */ case    6:  		/* bc 12, CR0_EQ, 28 */
		/* 82190F00h case    6:*/		if ( regs.CR[0].eq ) { return 0x82190F1C;  }
		/* 82190F00h case    6:*/		return 0x82190F04;
		  /* 82190F04h */ case    7:  		/* cmplwi CR6, R9, 1 */
		/* 82190F04h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 82190F04h case    7:*/		return 0x82190F08;
		  /* 82190F08h */ case    8:  		/* bc 4, CR6_EQ, 84 */
		/* 82190F08h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82190F5C;  }
		/* 82190F08h case    8:*/		return 0x82190F0C;
		  /* 82190F0Ch */ case    9:  		/* xor R11, R10, R11 */
		/* 82190F0Ch case    9:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82190F0Ch case    9:*/		return 0x82190F10;
		  /* 82190F10h */ case   10:  		/* andi. R11, R11, 26 */
		/* 82190F10h case   10:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x1A);
		/* 82190F10h case   10:*/		return 0x82190F14;
		  /* 82190F14h */ case   11:  		/* cmplwi CR0, R11, 0 */
		/* 82190F14h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82190F14h case   11:*/		return 0x82190F18;
		  /* 82190F18h */ case   12:  		/* bc 4, CR0_EQ, 68 */
		/* 82190F18h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82190F5C;  }
		/* 82190F18h case   12:*/		return 0x82190F1C;
	}
	return 0x82190F1C;
} // Block from 82190EE8h-82190F1Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 82190F1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190F1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190F1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190F1C);
		  /* 82190F1Ch */ case    0:  		/* addi R4, R1, 80 */
		/* 82190F1Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82190F1Ch case    0:*/		return 0x82190F20;
		  /* 82190F20h */ case    1:  		/* mr R3, R26 */
		/* 82190F20h case    1:*/		regs.R3 = regs.R26;
		/* 82190F20h case    1:*/		return 0x82190F24;
		  /* 82190F24h */ case    2:  		/* bl -3284 */
		/* 82190F24h case    2:*/		regs.LR = 0x82190F28; return 0x82190250;
		/* 82190F24h case    2:*/		return 0x82190F28;
		  /* 82190F28h */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82190F28h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82190F28h case    3:*/		return 0x82190F2C;
		  /* 82190F2Ch */ case    4:  		/* bc 12, CR0_EQ, 48 */
		/* 82190F2Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x82190F5C;  }
		/* 82190F2Ch case    4:*/		return 0x82190F30;
		  /* 82190F30h */ case    5:  		/* lbz R11, <#[R1 + 80]> */
		/* 82190F30h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82190F30h case    5:*/		return 0x82190F34;
		  /* 82190F34h */ case    6:  		/* mr R24, R25 */
		/* 82190F34h case    6:*/		regs.R24 = regs.R25;
		/* 82190F34h case    6:*/		return 0x82190F38;
		  /* 82190F38h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 82190F38h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82190F38h case    7:*/		return 0x82190F3C;
		  /* 82190F3Ch */ case    8:  		/* bc 12, CR0_EQ, -184 */
		/* 82190F3Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x82190E84;  }
		/* 82190F3Ch case    8:*/		return 0x82190F40;
		  /* 82190F40h */ case    9:  		/* lwz R11, <#[R28 + 8]> */
		/* 82190F40h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 82190F40h case    9:*/		return 0x82190F44;
		  /* 82190F44h */ case   10:  		/* lis R10, 1 */
		/* 82190F44h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0x1);
		/* 82190F44h case   10:*/		return 0x82190F48;
		  /* 82190F48h */ case   11:  		/* rlwinm R11, R11, 0, 15, 17 */
		/* 82190F48h case   11:*/		cpu::op::rlwinm<0,0,15,17>(regs,&regs.R11,regs.R11);
		/* 82190F48h case   11:*/		return 0x82190F4C;
		  /* 82190F4Ch */ case   12:  		/* cmplw CR6, R11, R10 */
		/* 82190F4Ch case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82190F4Ch case   12:*/		return 0x82190F50;
		  /* 82190F50h */ case   13:  		/* bc 4, CR6_EQ, -204 */
		/* 82190F50h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82190E84;  }
		/* 82190F50h case   13:*/		return 0x82190F54;
		  /* 82190F54h */ case   14:  		/* addi R24, R25, 1 */
		/* 82190F54h case   14:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R25,0x1);
		/* 82190F54h case   14:*/		return 0x82190F58;
		  /* 82190F58h */ case   15:  		/* b -212 */
		/* 82190F58h case   15:*/		return 0x82190E84;
		/* 82190F58h case   15:*/		return 0x82190F5C;
	}
	return 0x82190F5C;
} // Block from 82190F1Ch-82190F5Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 82190F5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190F5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190F5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190F5C);
		  /* 82190F5Ch */ case    0:  		/* cmplw CR6, R28, R29 */
		/* 82190F5Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R29);
		/* 82190F5Ch case    0:*/		return 0x82190F60;
		  /* 82190F60h */ case    1:  		/* bc 4, CR6_EQ, 64 */
		/* 82190F60h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82190FA0;  }
		/* 82190F60h case    1:*/		return 0x82190F64;
		  /* 82190F64h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 82190F64h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82190F64h case    2:*/		return 0x82190F68;
		  /* 82190F68h */ case    3:  		/* lwz R10, <#[R30]> */
		/* 82190F68h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82190F68h case    3:*/		return 0x82190F6C;
		  /* 82190F6Ch */ case    4:  		/* xor R9, R10, R11 */
		/* 82190F6Ch case    4:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 82190F6Ch case    4:*/		return 0x82190F70;
		  /* 82190F70h */ case    5:  		/* rlwinm. R9, R9, 0, 27, 31 */
		/* 82190F70h case    5:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R9,regs.R9);
		/* 82190F70h case    5:*/		return 0x82190F74;
		  /* 82190F74h */ case    6:  		/* bc 12, CR0_EQ, 36 */
		/* 82190F74h case    6:*/		if ( regs.CR[0].eq ) { return 0x82190F98;  }
		/* 82190F74h case    6:*/		return 0x82190F78;
		  /* 82190F78h */ case    7:  		/* lwz R9, <#[R26 + 8]> */
		/* 82190F78h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000008) );
		/* 82190F78h case    7:*/		return 0x82190F7C;
		  /* 82190F7Ch */ case    8:  		/* rlwinm R9, R9, 0, 18, 24 */
		/* 82190F7Ch case    8:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R9);
		/* 82190F7Ch case    8:*/		return 0x82190F80;
		  /* 82190F80h */ case    9:  		/* cmplwi CR6, R9, 128 */
		/* 82190F80h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000080);
		/* 82190F80h case    9:*/		return 0x82190F84;
		  /* 82190F84h */ case   10:  		/* bc 4, CR6_EQ, 28 */
		/* 82190F84h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82190FA0;  }
		/* 82190F84h case   10:*/		return 0x82190F88;
	}
	return 0x82190F88;
} // Block from 82190F5Ch-82190F88h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82190F88h
// Function '?CleanPrologueAfterScheduling@Compiler@D3DXShader@@AAAXPAVBlock@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190F88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190F88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190F88);
		  /* 82190F88h */ case    0:  		/* xor R11, R10, R11 */
		/* 82190F88h case    0:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82190F88h case    0:*/		return 0x82190F8C;
		  /* 82190F8Ch */ case    1:  		/* andi. R11, R11, 27 */
		/* 82190F8Ch case    1:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x1B);
		/* 82190F8Ch case    1:*/		return 0x82190F90;
		  /* 82190F90h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 82190F90h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82190F90h case    2:*/		return 0x82190F94;
		  /* 82190F94h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 82190F94h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82190FA0;  }
		/* 82190F94h case    3:*/		return 0x82190F98;
	}
	return 0x82190F98;
} // Block from 82190F88h-82190F98h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82190F98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190F98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190F98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190F98);
		  /* 82190F98h */ case    0:  		/* mr R24, R25 */
		/* 82190F98h case    0:*/		regs.R24 = regs.R25;
		/* 82190F98h case    0:*/		return 0x82190F9C;
		  /* 82190F9Ch */ case    1:  		/* b -280 */
		/* 82190F9Ch case    1:*/		return 0x82190E84;
		/* 82190F9Ch case    1:*/		return 0x82190FA0;
	}
	return 0x82190FA0;
} // Block from 82190F98h-82190FA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82190FA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190FA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190FA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190FA0);
		  /* 82190FA0h */ case    0:  		/* mr R3, R26 */
		/* 82190FA0h case    0:*/		regs.R3 = regs.R26;
		/* 82190FA0h case    0:*/		return 0x82190FA4;
		  /* 82190FA4h */ case    1:  		/* bl -5516 */
		/* 82190FA4h case    1:*/		regs.LR = 0x82190FA8; return 0x8218FA18;
		/* 82190FA4h case    1:*/		return 0x82190FA8;
		  /* 82190FA8h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82190FA8h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82190FA8h case    2:*/		return 0x82190FAC;
		  /* 82190FACh */ case    3:  		/* bc 4, CR0_EQ, -296 */
		/* 82190FACh case    3:*/		if ( !regs.CR[0].eq ) { return 0x82190E84;  }
		/* 82190FACh case    3:*/		return 0x82190FB0;
		  /* 82190FB0h */ case    4:  		/* rlwinm R24, R25, 1, 0, 30 */
		/* 82190FB0h case    4:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R24,regs.R25);
		/* 82190FB0h case    4:*/		return 0x82190FB4;
		  /* 82190FB4h */ case    5:  		/* b -304 */
		/* 82190FB4h case    5:*/		return 0x82190E84;
		/* 82190FB4h case    5:*/		return 0x82190FB8;
	}
	return 0x82190FB8;
} // Block from 82190FA0h-82190FB8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82190FB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190FB8);
		  /* 82190FB8h */ case    0:  		/* cmplwi CR6, R9, 9 */
		/* 82190FB8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000009);
		/* 82190FB8h case    0:*/		return 0x82190FBC;
		  /* 82190FBCh */ case    1:  		/* bc 12, CR6_LT, 524 */
		/* 82190FBCh case    1:*/		if ( regs.CR[6].lt ) { return 0x821911C8;  }
		/* 82190FBCh case    1:*/		return 0x82190FC0;
		  /* 82190FC0h */ case    2:  		/* cmplwi CR6, R9, 11 */
		/* 82190FC0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000000B);
		/* 82190FC0h case    2:*/		return 0x82190FC4;
		  /* 82190FC4h */ case    3:  		/* bc 4, CR6_GT, 272 */
		/* 82190FC4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x821910D4;  }
		/* 82190FC4h case    3:*/		return 0x82190FC8;
		  /* 82190FC8h */ case    4:  		/* cmplwi CR6, R9, 24 */
		/* 82190FC8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000018);
		/* 82190FC8h case    4:*/		return 0x82190FCC;
		  /* 82190FCCh */ case    5:  		/* bc 4, CR6_GT, 508 */
		/* 82190FCCh case    5:*/		if ( !regs.CR[6].gt ) { return 0x821911C8;  }
		/* 82190FCCh case    5:*/		return 0x82190FD0;
		  /* 82190FD0h */ case    6:  		/* cmplwi CR6, R9, 28 */
		/* 82190FD0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000001C);
		/* 82190FD0h case    6:*/		return 0x82190FD4;
		  /* 82190FD4h */ case    7:  		/* bc 12, CR6_GT, 500 */
		/* 82190FD4h case    7:*/		if ( regs.CR[6].gt ) { return 0x821911C8;  }
		/* 82190FD4h case    7:*/		return 0x82190FD8;
	}
	return 0x82190FD8;
} // Block from 82190FB8h-82190FD8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82190FD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190FD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190FD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190FD8);
		  /* 82190FD8h */ case    0:  		/* lwz R28, <#[R26 + 48]> */
		/* 82190FD8h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R26 + 0x00000030) );
		/* 82190FD8h case    0:*/		return 0x82190FDC;
		  /* 82190FDCh */ case    1:  		/* lwz R11, <#[R28 + 12]> */
		/* 82190FDCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000000C) );
		/* 82190FDCh case    1:*/		return 0x82190FE0;
		  /* 82190FE0h */ case    2:  		/* lwz R11, <#[R11 + 8]> */
		/* 82190FE0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82190FE0h case    2:*/		return 0x82190FE4;
		  /* 82190FE4h */ case    3:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82190FE4h case    3:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82190FE4h case    3:*/		return 0x82190FE8;
		  /* 82190FE8h */ case    4:  		/* cmplwi CR6, R11, 16000 */
		/* 82190FE8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 82190FE8h case    4:*/		return 0x82190FEC;
		  /* 82190FECh */ case    5:  		/* bc 4, CR6_EQ, 248 */
		/* 82190FECh case    5:*/		if ( !regs.CR[6].eq ) { return 0x821910E4;  }
		/* 82190FECh case    5:*/		return 0x82190FF0;
		  /* 82190FF0h */ case    6:  		/* lwz R11, <#[R28]> */
		/* 82190FF0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82190FF0h case    6:*/		return 0x82190FF4;
		  /* 82190FF4h */ case    7:  		/* li R29, 0 */
		/* 82190FF4h case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82190FF4h case    7:*/		return 0x82190FF8;
	}
	return 0x82190FF8;
} // Block from 82190FD8h-82190FF8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82190FF8h
// Function '?CanScheduleVFETCHGroup@Scheduler@D3DXShader@@QAA_NPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82190FF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82190FF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82190FF8);
		  /* 82190FF8h */ case    0:  		/* rlwinm. R31, R11, 7, 29, 31 */
		/* 82190FF8h case    0:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R31,regs.R11);
		/* 82190FF8h case    0:*/		return 0x82190FFC;
		  /* 82190FFCh */ case    1:  		/* bc 12, CR0_EQ, 80 */
		/* 82190FFCh case    1:*/		if ( regs.CR[0].eq ) { return 0x8219104C;  }
		/* 82190FFCh case    1:*/		return 0x82191000;
		  /* 82191000h */ case    2:  		/* lis R11, -32256 */
		/* 82191000h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82191000h case    2:*/		return 0x82191004;
		  /* 82191004h */ case    3:  		/* li R30, 0 */
		/* 82191004h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82191004h case    3:*/		return 0x82191008;
		  /* 82191008h */ case    4:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 82191008h case    4:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 82191008h case    4:*/		return 0x8219100C;
		  /* 8219100Ch */ case    5:  		/* lwz R11, <#[R28]> */
		/* 8219100Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8219100Ch case    5:*/		return 0x82191010;
		  /* 82191010h */ case    6:  		/* lwz R10, <#[R28 + 12]> */
		/* 82191010h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000000C) );
		/* 82191010h case    6:*/		return 0x82191014;
		  /* 82191014h */ case    7:  		/* rlwinm R9, R11, 27, 24, 31 */
		/* 82191014h case    7:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R11);
		/* 82191014h case    7:*/		return 0x82191018;
		  /* 82191018h */ case    8:  		/* rlwinm R4, R11, 0, 27, 31 */
		/* 82191018h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R11);
		/* 82191018h case    8:*/		return 0x8219101C;
		  /* 8219101Ch */ case    9:  		/* srw R11, R9, R30 */
		/* 8219101Ch case    9:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R9,regs.R30);
		/* 8219101Ch case    9:*/		return 0x82191020;
		  /* 82191020h */ case   10:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82191020h case   10:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82191020h case   10:*/		return 0x82191024;
		  /* 82191024h */ case   11:  		/* addi R11, R11, 11 */
		/* 82191024h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xB);
		/* 82191024h case   11:*/		return 0x82191028;
		  /* 82191028h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82191028h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82191028h case   12:*/		return 0x8219102C;
		  /* 8219102Ch */ case   13:  		/* lfsx FR1, <#[R11 + R10]> */
		/* 8219102Ch case   13:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8219102Ch case   13:*/		return 0x82191030;
		  /* 82191030h */ case   14:  		/* bl 590816 */
		/* 82191030h case   14:*/		regs.LR = 0x82191034; return 0x82221410;
		/* 82191030h case   14:*/		return 0x82191034;
		  /* 82191034h */ case   15:  		/* fcmpu CR6, FR1, FR31 */
		/* 82191034h case   15:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR31);
		/* 82191034h case   15:*/		return 0x82191038;
		  /* 82191038h */ case   16:  		/* bc 4, CR6_EQ, 20 */
		/* 82191038h case   16:*/		if ( !regs.CR[6].eq ) { return 0x8219104C;  }
		/* 82191038h case   16:*/		return 0x8219103C;
		  /* 8219103Ch */ case   17:  		/* addi R29, R29, 1 */
		/* 8219103Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8219103Ch case   17:*/		return 0x82191040;
		  /* 82191040h */ case   18:  		/* addi R30, R30, 2 */
		/* 82191040h case   18:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x2);
		/* 82191040h case   18:*/		return 0x82191044;
		  /* 82191044h */ case   19:  		/* cmplw CR6, R29, R31 */
		/* 82191044h case   19:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R31);
		/* 82191044h case   19:*/		return 0x82191048;
		  /* 82191048h */ case   20:  		/* bc 12, CR6_LT, -60 */
		/* 82191048h case   20:*/		if ( regs.CR[6].lt ) { return 0x8219100C;  }
		/* 82191048h case   20:*/		return 0x8219104C;
	}
	return 0x8219104C;
} // Block from 82190FF8h-8219104Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8219104Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219104C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219104C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219104C);
		  /* 8219104Ch */ case    0:  		/* cmplw CR6, R29, R31 */
		/* 8219104Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R31);
		/* 8219104Ch case    0:*/		return 0x82191050;
		  /* 82191050h */ case    1:  		/* bc 12, CR6_EQ, 116 */
		/* 82191050h case    1:*/		if ( regs.CR[6].eq ) { return 0x821910C4;  }
		/* 82191050h case    1:*/		return 0x82191054;
		  /* 82191054h */ case    2:  		/* lwz R11, <#[R26 + 8]> */
		/* 82191054h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82191054h case    2:*/		return 0x82191058;
		  /* 82191058h */ case    3:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82191058h case    3:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82191058h case    3:*/		return 0x8219105C;
		  /* 8219105Ch */ case    4:  		/* cmplwi CR6, R11, 3200 */
		/* 8219105Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000C80);
		/* 8219105Ch case    4:*/		return 0x82191060;
		  /* 82191060h */ case    5:  		/* bc 4, CR6_EQ, 132 */
		/* 82191060h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821910E4;  }
		/* 82191060h case    5:*/		return 0x82191064;
		  /* 82191064h */ case    6:  		/* li R29, 0 */
		/* 82191064h case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82191064h case    6:*/		return 0x82191068;
		  /* 82191068h */ case    7:  		/* cmplwi CR6, R31, 0 */
		/* 82191068h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82191068h case    7:*/		return 0x8219106C;
		  /* 8219106Ch */ case    8:  		/* bc 12, CR6_EQ, 80 */
		/* 8219106Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x821910BC;  }
		/* 8219106Ch case    8:*/		return 0x82191070;
		  /* 82191070h */ case    9:  		/* lis R11, -32256 */
		/* 82191070h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82191070h case    9:*/		return 0x82191074;
		  /* 82191074h */ case   10:  		/* li R30, 0 */
		/* 82191074h case   10:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82191074h case   10:*/		return 0x82191078;
		  /* 82191078h */ case   11:  		/* lfd FR31, <#[R11 + 1848]> */
		/* 82191078h case   11:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000738) );
		/* 82191078h case   11:*/		return 0x8219107C;
		  /* 8219107Ch */ case   12:  		/* lwz R11, <#[R28]> */
		/* 8219107Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8219107Ch case   12:*/		return 0x82191080;
		  /* 82191080h */ case   13:  		/* lwz R10, <#[R28 + 12]> */
		/* 82191080h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000000C) );
		/* 82191080h case   13:*/		return 0x82191084;
		  /* 82191084h */ case   14:  		/* rlwinm R9, R11, 27, 24, 31 */
		/* 82191084h case   14:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R11);
		/* 82191084h case   14:*/		return 0x82191088;
	}
	return 0x82191088;
} // Block from 8219104Ch-82191088h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82191088h
// Function '?Reset@ScheduledBundleEnumerator@D3DXShader@@QAAXPAVScheduler@2@PAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@PAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191088);
		  /* 82191088h */ case    0:  		/* rlwinm R4, R11, 0, 27, 31 */
		/* 82191088h case    0:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R11);
		/* 82191088h case    0:*/		return 0x8219108C;
		  /* 8219108Ch */ case    1:  		/* srw R11, R9, R30 */
		/* 8219108Ch case    1:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R9,regs.R30);
		/* 8219108Ch case    1:*/		return 0x82191090;
		  /* 82191090h */ case    2:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82191090h case    2:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82191090h case    2:*/		return 0x82191094;
		  /* 82191094h */ case    3:  		/* addi R11, R11, 11 */
		/* 82191094h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xB);
		/* 82191094h case    3:*/		return 0x82191098;
		  /* 82191098h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82191098h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82191098h case    4:*/		return 0x8219109C;
		  /* 8219109Ch */ case    5:  		/* lfsx FR1, <#[R11 + R10]> */
		/* 8219109Ch case    5:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8219109Ch case    5:*/		return 0x821910A0;
		  /* 821910A0h */ case    6:  		/* bl 590704 */
		/* 821910A0h case    6:*/		regs.LR = 0x821910A4; return 0x82221410;
		/* 821910A0h case    6:*/		return 0x821910A4;
		  /* 821910A4h */ case    7:  		/* fcmpu CR6, FR1, FR31 */
		/* 821910A4h case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR31);
		/* 821910A4h case    7:*/		return 0x821910A8;
		  /* 821910A8h */ case    8:  		/* bc 4, CR6_EQ, 20 */
		/* 821910A8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821910BC;  }
		/* 821910A8h case    8:*/		return 0x821910AC;
		  /* 821910ACh */ case    9:  		/* addi R29, R29, 1 */
		/* 821910ACh case    9:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 821910ACh case    9:*/		return 0x821910B0;
		  /* 821910B0h */ case   10:  		/* addi R30, R30, 2 */
		/* 821910B0h case   10:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x2);
		/* 821910B0h case   10:*/		return 0x821910B4;
		  /* 821910B4h */ case   11:  		/* cmplw CR6, R29, R31 */
		/* 821910B4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R31);
		/* 821910B4h case   11:*/		return 0x821910B8;
		  /* 821910B8h */ case   12:  		/* bc 12, CR6_LT, -60 */
		/* 821910B8h case   12:*/		if ( regs.CR[6].lt ) { return 0x8219107C;  }
		/* 821910B8h case   12:*/		return 0x821910BC;
	}
	return 0x821910BC;
} // Block from 82191088h-821910BCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 821910BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821910BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821910BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821910BC);
		  /* 821910BCh */ case    0:  		/* cmplw CR6, R29, R31 */
		/* 821910BCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R31);
		/* 821910BCh case    0:*/		return 0x821910C0;
		  /* 821910C0h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 821910C0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821910E4;  }
		/* 821910C0h case    1:*/		return 0x821910C4;
	}
	return 0x821910C4;
} // Block from 821910BCh-821910C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821910C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821910C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821910C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821910C4);
		  /* 821910C4h */ case    0:  		/* mr R24, R31 */
		/* 821910C4h case    0:*/		regs.R24 = regs.R31;
		/* 821910C4h case    0:*/		return 0x821910C8;
		  /* 821910C8h */ case    1:  		/* cmpwi CR6, R31, -1 */
		/* 821910C8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R31,0xFFFFFFFF);
		/* 821910C8h case    1:*/		return 0x821910CC;
		  /* 821910CCh */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 821910CCh case    2:*/		if ( regs.CR[6].eq ) { return 0x821910E4;  }
		/* 821910CCh case    2:*/		return 0x821910D0;
		  /* 821910D0h */ case    3:  		/* b -588 */
		/* 821910D0h case    3:*/		return 0x82190E84;
		/* 821910D0h case    3:*/		return 0x821910D4;
	}
	return 0x821910D4;
} // Block from 821910C4h-821910D4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821910D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821910D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821910D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821910D4);
		  /* 821910D4h */ case    0:  		/* subfic R11, R25, 1 */
		/* 821910D4h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R25,0x1);
		/* 821910D4h case    0:*/		return 0x821910D8;
		  /* 821910D8h */ case    1:  		/* mr R24, R25 */
		/* 821910D8h case    1:*/		regs.R24 = regs.R25;
		/* 821910D8h case    1:*/		return 0x821910DC;
	}
	return 0x821910DC;
} // Block from 821910D4h-821910DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821910DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821910DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821910DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821910DC);
		  /* 821910DCh */ case    0:  		/* subfe R11, R11, R11 */
		/* 821910DCh case    0:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 821910DCh case    0:*/		return 0x821910E0;
		  /* 821910E0h */ case    1:  		/* rlwinm R27, R11, 0, 31, 31 */
		/* 821910E0h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R27,regs.R11);
		/* 821910E0h case    1:*/		return 0x821910E4;
	}
	return 0x821910E4;
} // Block from 821910DCh-821910E4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821910E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821910E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821910E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821910E4);
		  /* 821910E4h */ case    0:  		/* rlwinm. R11, R27, 0, 24, 31 */
		/* 821910E4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R27);
		/* 821910E4h case    0:*/		return 0x821910E8;
		  /* 821910E8h */ case    1:  		/* bc 12, CR0_EQ, 216 */
		/* 821910E8h case    1:*/		if ( regs.CR[0].eq ) { return 0x821911C0;  }
		/* 821910E8h case    1:*/		return 0x821910EC;
		  /* 821910ECh */ case    2:  		/* lwz R9, <#[R26 + 4]> */
		/* 821910ECh case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000004) );
		/* 821910ECh case    2:*/		return 0x821910F0;
		  /* 821910F0h */ case    3:  		/* mr R10, R9 */
		/* 821910F0h case    3:*/		regs.R10 = regs.R9;
		/* 821910F0h case    3:*/		return 0x821910F4;
		  /* 821910F4h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 821910F4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821910F4h case    4:*/		return 0x821910F8;
		  /* 821910F8h */ case    5:  		/* bc 12, CR6_EQ, 200 */
		/* 821910F8h case    5:*/		if ( regs.CR[6].eq ) { return 0x821911C0;  }
		/* 821910F8h case    5:*/		return 0x821910FC;
		  /* 821910FCh */ case    6:  		/* lwz R11, <#[R10 + 16]> */
		/* 821910FCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 821910FCh case    6:*/		return 0x82191100;
		  /* 82191100h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82191100h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82191100h case    7:*/		return 0x82191104;
		  /* 82191104h */ case    8:  		/* bc 12, CR6_EQ, 24 */
		/* 82191104h case    8:*/		if ( regs.CR[6].eq ) { return 0x8219111C;  }
		/* 82191104h case    8:*/		return 0x82191108;
		  /* 82191108h */ case    9:  		/* lwz R8, <#[R11 + 8]> */
		/* 82191108h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 82191108h case    9:*/		return 0x8219110C;
		  /* 8219110Ch */ case   10:  		/* mr R30, R11 */
		/* 8219110Ch case   10:*/		regs.R30 = regs.R11;
		/* 8219110Ch case   10:*/		return 0x82191110;
		  /* 82191110h */ case   11:  		/* rlwinm R11, R8, 0, 18, 24 */
		/* 82191110h case   11:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R8);
		/* 82191110h case   11:*/		return 0x82191114;
		  /* 82191114h */ case   12:  		/* cmplwi CR6, R11, 14080 */
		/* 82191114h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 82191114h case   12:*/		return 0x82191118;
		  /* 82191118h */ case   13:  		/* bc 12, CR6_EQ, 12 */
		/* 82191118h case   13:*/		if ( regs.CR[6].eq ) { return 0x82191124;  }
		/* 82191118h case   13:*/		return 0x8219111C;
	}
	return 0x8219111C;
} // Block from 821910E4h-8219111Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8219111Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219111C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219111C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219111C);
		  /* 8219111Ch */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 8219111Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8219111Ch case    0:*/		return 0x82191120;
		  /* 82191120h */ case    1:  		/* b -44 */
		/* 82191120h case    1:*/		return 0x821910F4;
		/* 82191120h case    1:*/		return 0x82191124;
	}
	return 0x82191124;
} // Block from 8219111Ch-82191124h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82191124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191124);
		  /* 82191124h */ case    0:  		/* mr R31, R9 */
		/* 82191124h case    0:*/		regs.R31 = regs.R9;
		/* 82191124h case    0:*/		return 0x82191128;
		  /* 82191128h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 82191128h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82191128h case    1:*/		return 0x8219112C;
		  /* 8219112Ch */ case    2:  		/* bc 12, CR6_EQ, 148 */
		/* 8219112Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x821911C0;  }
		/* 8219112Ch case    2:*/		return 0x82191130;
		  /* 82191130h */ case    3:  		/* lwz R3, <#[R31 + 16]> */
		/* 82191130h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82191130h case    3:*/		return 0x82191134;
		  /* 82191134h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 82191134h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82191134h case    4:*/		return 0x82191138;
		  /* 82191138h */ case    5:  		/* bc 12, CR6_EQ, 128 */
		/* 82191138h case    5:*/		if ( regs.CR[6].eq ) { return 0x821911B8;  }
		/* 82191138h case    5:*/		return 0x8219113C;
		  /* 8219113Ch */ case    6:  		/* cmplw CR6, R3, R30 */
		/* 8219113Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R30);
		/* 8219113Ch case    6:*/		return 0x82191140;
		  /* 82191140h */ case    7:  		/* bc 12, CR6_EQ, 120 */
		/* 82191140h case    7:*/		if ( regs.CR[6].eq ) { return 0x821911B8;  }
		/* 82191140h case    7:*/		return 0x82191144;
		  /* 82191144h */ case    8:  		/* mr R4, R30 */
		/* 82191144h case    8:*/		regs.R4 = regs.R30;
		/* 82191144h case    8:*/		return 0x82191148;
	}
	return 0x82191148;
} // Block from 82191124h-82191148h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82191148h
// Function '?HasEmptyScalarSlot@ScheduledBundleEnumerator@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191148);
		  /* 82191148h */ case    0:  		/* bl -129152 */
		/* 82191148h case    0:*/		regs.LR = 0x8219114C; return 0x821718C8;
		/* 82191148h case    0:*/		return 0x8219114C;
		  /* 8219114Ch */ case    1:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219114Ch case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219114Ch case    1:*/		return 0x82191150;
		  /* 82191150h */ case    2:  		/* bc 12, CR0_EQ, 104 */
		/* 82191150h case    2:*/		if ( regs.CR[0].eq ) { return 0x821911B8;  }
		/* 82191150h case    2:*/		return 0x82191154;
		  /* 82191154h */ case    3:  		/* lwz R8, <#[R31]> */
		/* 82191154h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 82191154h case    3:*/		return 0x82191158;
		  /* 82191158h */ case    4:  		/* li R10, 0 */
		/* 82191158h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82191158h case    4:*/		return 0x8219115C;
		  /* 8219115Ch */ case    5:  		/* li R11, 0 */
		/* 8219115Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219115Ch case    5:*/		return 0x82191160;
		  /* 82191160h */ case    6:  		/* rlwinm. R7, R8, 7, 29, 31 */
		/* 82191160h case    6:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R7,regs.R8);
		/* 82191160h case    6:*/		return 0x82191164;
		  /* 82191164h */ case    7:  		/* bc 12, CR0_EQ, 72 */
		/* 82191164h case    7:*/		if ( regs.CR[0].eq ) { return 0x821911AC;  }
		/* 82191164h case    7:*/		return 0x82191168;
		  /* 82191168h */ case    8:  		/* li R9, 0 */
		/* 82191168h case    8:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82191168h case    8:*/		return 0x8219116C;
		  /* 8219116Ch */ case    9:  		/* rlwinm R6, R8, 27, 24, 31 */
		/* 8219116Ch case    9:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R8);
		/* 8219116Ch case    9:*/		return 0x82191170;
		  /* 82191170h */ case   10:  		/* addi R11, R11, 1 */
		/* 82191170h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82191170h case   10:*/		return 0x82191174;
		  /* 82191174h */ case   11:  		/* srw R6, R6, R9 */
		/* 82191174h case   11:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R6,regs.R9);
		/* 82191174h case   11:*/		return 0x82191178;
		  /* 82191178h */ case   12:  		/* rlwinm R6, R6, 0, 30, 31 */
		/* 82191178h case   12:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R6,regs.R6);
		/* 82191178h case   12:*/		return 0x8219117C;
		  /* 8219117Ch */ case   13:  		/* addi R9, R9, 2 */
		/* 8219117Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x2);
		/* 8219117Ch case   13:*/		return 0x82191180;
		  /* 82191180h */ case   14:  		/* slw R6, R23, R6 */
		/* 82191180h case   14:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R23,regs.R6);
		/* 82191180h case   14:*/		return 0x82191184;
		  /* 82191184h */ case   15:  		/* or R10, R6, R10 */
		/* 82191184h case   15:*/		cpu::op::or<0>(regs,&regs.R10,regs.R6,regs.R10);
		/* 82191184h case   15:*/		return 0x82191188;
		  /* 82191188h */ case   16:  		/* cmplw CR6, R11, R7 */
		/* 82191188h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 82191188h case   16:*/		return 0x8219118C;
		  /* 8219118Ch */ case   17:  		/* bc 12, CR6_LT, -32 */
		/* 8219118Ch case   17:*/		if ( regs.CR[6].lt ) { return 0x8219116C;  }
		/* 8219118Ch case   17:*/		return 0x82191190;
		  /* 82191190h */ case   18:  		/* cmplwi CR6, R10, 0 */
		/* 82191190h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82191190h case   18:*/		return 0x82191194;
		  /* 82191194h */ case   19:  		/* bc 12, CR6_EQ, 24 */
		/* 82191194h case   19:*/		if ( regs.CR[6].eq ) { return 0x821911AC;  }
		/* 82191194h case   19:*/		return 0x82191198;
		  /* 82191198h */ case   20:  		/* addi R11, R10, -1 */
		/* 82191198h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 82191198h case   20:*/		return 0x8219119C;
		  /* 8219119Ch */ case   21:  		/* andc R11, R10, R11 */
		/* 8219119Ch case   21:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8219119Ch case   21:*/		return 0x821911A0;
		  /* 821911A0h */ case   22:  		/* subf. R11, R11, R10 */
		/* 821911A0h case   22:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821911A0h case   22:*/		return 0x821911A4;
		  /* 821911A4h */ case   23:  		/* mr R11, R23 */
		/* 821911A4h case   23:*/		regs.R11 = regs.R23;
		/* 821911A4h case   23:*/		return 0x821911A8;
		  /* 821911A8h */ case   24:  		/* bc 12, CR0_EQ, 8 */
		/* 821911A8h case   24:*/		if ( regs.CR[0].eq ) { return 0x821911B0;  }
		/* 821911A8h case   24:*/		return 0x821911AC;
	}
	return 0x821911AC;
} // Block from 82191148h-821911ACh (25 instructions)

//////////////////////////////////////////////////////
// Block at 821911ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821911AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821911AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821911AC);
		  /* 821911ACh */ case    0:  		/* li R11, 0 */
		/* 821911ACh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821911ACh case    0:*/		return 0x821911B0;
	}
	return 0x821911B0;
} // Block from 821911ACh-821911B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821911B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821911B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821911B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821911B0);
		  /* 821911B0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821911B0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821911B0h case    0:*/		return 0x821911B4;
		  /* 821911B4h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 821911B4h case    1:*/		if ( regs.CR[0].eq ) { return 0x821911C8;  }
		/* 821911B4h case    1:*/		return 0x821911B8;
	}
	return 0x821911B8;
} // Block from 821911B0h-821911B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821911B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821911B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821911B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821911B8);
		  /* 821911B8h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 821911B8h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 821911B8h case    0:*/		return 0x821911BC;
		  /* 821911BCh */ case    1:  		/* b -148 */
		/* 821911BCh case    1:*/		return 0x82191128;
		/* 821911BCh case    1:*/		return 0x821911C0;
	}
	return 0x821911C0;
} // Block from 821911B8h-821911C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821911C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821911C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821911C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821911C0);
		  /* 821911C0h */ case    0:  		/* mr R3, R24 */
		/* 821911C0h case    0:*/		regs.R3 = regs.R24;
		/* 821911C0h case    0:*/		return 0x821911C4;
		  /* 821911C4h */ case    1:  		/* b 8 */
		/* 821911C4h case    1:*/		return 0x821911CC;
		/* 821911C4h case    1:*/		return 0x821911C8;
	}
	return 0x821911C8;
} // Block from 821911C0h-821911C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821911C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821911C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821911C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821911C8);
		  /* 821911C8h */ case    0:  		/* mr R3, R22 */
		/* 821911C8h case    0:*/		regs.R3 = regs.R22;
		/* 821911C8h case    0:*/		return 0x821911CC;
	}
	return 0x821911CC;
} // Block from 821911C8h-821911CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821911CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821911CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821911CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821911CC);
		  /* 821911CCh */ case    0:  		/* addi R1, R1, 192 */
		/* 821911CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 821911CCh case    0:*/		return 0x821911D0;
		  /* 821911D0h */ case    1:  		/* lfd FR31, <#[R1 - 96]> */
		/* 821911D0h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA0) );
		/* 821911D0h case    1:*/		return 0x821911D4;
		  /* 821911D4h */ case    2:  		/* b -1048388 */
		/* 821911D4h case    2:*/		return 0x82091290;
		/* 821911D4h case    2:*/		return 0x821911D8;
	}
	return 0x821911D8;
} // Block from 821911CCh-821911D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821911D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821911D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821911D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821911D8);
		  /* 821911D8h */ case    0:  		/* mfspr R12, LR */
		/* 821911D8h case    0:*/		regs.R12 = regs.LR;
		/* 821911D8h case    0:*/		return 0x821911DC;
		  /* 821911DCh */ case    1:  		/* bl -1048468 */
		/* 821911DCh case    1:*/		regs.LR = 0x821911E0; return 0x82091248;
		/* 821911DCh case    1:*/		return 0x821911E0;
		  /* 821911E0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 821911E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 821911E0h case    2:*/		return 0x821911E4;
		  /* 821911E4h */ case    3:  		/* lwz R31, <#[R5]> */
		/* 821911E4h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R5 + 0x00000000) );
		/* 821911E4h case    3:*/		return 0x821911E8;
		  /* 821911E8h */ case    4:  		/* mr R27, R3 */
		/* 821911E8h case    4:*/		regs.R27 = regs.R3;
		/* 821911E8h case    4:*/		return 0x821911EC;
		  /* 821911ECh */ case    5:  		/* mr R26, R4 */
		/* 821911ECh case    5:*/		regs.R26 = regs.R4;
		/* 821911ECh case    5:*/		return 0x821911F0;
		  /* 821911F0h */ case    6:  		/* mr R28, R5 */
		/* 821911F0h case    6:*/		regs.R28 = regs.R5;
		/* 821911F0h case    6:*/		return 0x821911F4;
		  /* 821911F4h */ case    7:  		/* mr R29, R6 */
		/* 821911F4h case    7:*/		regs.R29 = regs.R6;
		/* 821911F4h case    7:*/		return 0x821911F8;
		  /* 821911F8h */ case    8:  		/* mr R25, R7 */
		/* 821911F8h case    8:*/		regs.R25 = regs.R7;
		/* 821911F8h case    8:*/		return 0x821911FC;
		  /* 821911FCh */ case    9:  		/* mr R24, R8 */
		/* 821911FCh case    9:*/		regs.R24 = regs.R8;
		/* 821911FCh case    9:*/		return 0x82191200;
		  /* 82191200h */ case   10:  		/* li R30, 0 */
		/* 82191200h case   10:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82191200h case   10:*/		return 0x82191204;
		  /* 82191204h */ case   11:  		/* cmplwi CR6, R31, 0 */
		/* 82191204h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82191204h case   11:*/		return 0x82191208;
		  /* 82191208h */ case   12:  		/* bc 12, CR6_EQ, 60 */
		/* 82191208h case   12:*/		if ( regs.CR[6].eq ) { return 0x82191244;  }
		/* 82191208h case   12:*/		return 0x8219120C;
		  /* 8219120Ch */ case   13:  		/* lwz R11, <#[R31]> */
		/* 8219120Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219120Ch case   13:*/		return 0x82191210;
	}
	return 0x82191210;
} // Block from 821911D8h-82191210h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82191210h
// Function '?HasEmptySlotForInstr@ScheduledBundleEnumerator@D3DXShader@@QAA_NPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191210);
		  /* 82191210h */ case    0:  		/* rlwinm. R10, R11, 0, 4, 6 */
		/* 82191210h case    0:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R11);
		/* 82191210h case    0:*/		return 0x82191214;
		  /* 82191214h */ case    1:  		/* bc 4, CR0_EQ, 40 */
		/* 82191214h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219123C;  }
		/* 82191214h case    1:*/		return 0x82191218;
		  /* 82191218h */ case    2:  		/* rlwinm. R10, R11, 2, 31, 31 */
		/* 82191218h case    2:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R10,regs.R11);
		/* 82191218h case    2:*/		return 0x8219121C;
		  /* 8219121Ch */ case    3:  		/* bc 12, CR0_EQ, 20 */
		/* 8219121Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x82191230;  }
		/* 8219121Ch case    3:*/		return 0x82191220;
		  /* 82191220h */ case    4:  		/* rlwinm. R11, R11, 0, 7, 18 */
		/* 82191220h case    4:*/		cpu::op::rlwinm<1,0,7,18>(regs,&regs.R11,regs.R11);
		/* 82191220h case    4:*/		return 0x82191224;
		  /* 82191224h */ case    5:  		/* bc 4, CR0_EQ, 12 */
		/* 82191224h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82191230;  }
		/* 82191224h case    5:*/		return 0x82191228;
		  /* 82191228h */ case    6:  		/* mr R30, R31 */
		/* 82191228h case    6:*/		regs.R30 = regs.R31;
		/* 82191228h case    6:*/		return 0x8219122C;
		  /* 8219122Ch */ case    7:  		/* b 16 */
		/* 8219122Ch case    7:*/		return 0x8219123C;
		/* 8219122Ch case    7:*/		return 0x82191230;
	}
	return 0x82191230;
} // Block from 82191210h-82191230h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82191230h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191230);
		  /* 82191230h */ case    0:  		/* mr R4, R31 */
		/* 82191230h case    0:*/		regs.R4 = regs.R31;
		/* 82191230h case    0:*/		return 0x82191234;
		  /* 82191234h */ case    1:  		/* mr R3, R26 */
		/* 82191234h case    1:*/		regs.R3 = regs.R26;
		/* 82191234h case    1:*/		return 0x82191238;
		  /* 82191238h */ case    2:  		/* bl -102512 */
		/* 82191238h case    2:*/		regs.LR = 0x8219123C; return 0x821781C8;
		/* 82191238h case    2:*/		return 0x8219123C;
	}
	return 0x8219123C;
} // Block from 82191230h-8219123Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219123Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219123C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219123C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219123C);
		  /* 8219123Ch */ case    0:  		/* lwz R31, <#[R31 + 4]> */
		/* 8219123Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 8219123Ch case    0:*/		return 0x82191240;
		  /* 82191240h */ case    1:  		/* b -60 */
		/* 82191240h case    1:*/		return 0x82191204;
		/* 82191240h case    1:*/		return 0x82191244;
	}
	return 0x82191244;
} // Block from 8219123Ch-82191244h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82191244h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191244( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191244) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191244);
		  /* 82191244h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 82191244h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82191244h case    0:*/		return 0x82191248;
		  /* 82191248h */ case    1:  		/* bc 12, CR6_EQ, 56 */
		/* 82191248h case    1:*/		if ( regs.CR[6].eq ) { return 0x82191280;  }
		/* 82191248h case    1:*/		return 0x8219124C;
		  /* 8219124Ch */ case    2:  		/* lwz R11, <#[R26]> */
		/* 8219124Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8219124Ch case    2:*/		return 0x82191250;
		  /* 82191250h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82191250h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82191250h case    3:*/		return 0x82191254;
		  /* 82191254h */ case    4:  		/* bc 12, CR6_EQ, 44 */
		/* 82191254h case    4:*/		if ( regs.CR[6].eq ) { return 0x82191280;  }
		/* 82191254h case    4:*/		return 0x82191258;
		  /* 82191258h */ case    5:  		/* lwz R10, <#[R11]> */
		/* 82191258h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82191258h case    5:*/		return 0x8219125C;
		  /* 8219125Ch */ case    6:  		/* rlwinm. R9, R10, 0, 4, 6 */
		/* 8219125Ch case    6:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R10);
		/* 8219125Ch case    6:*/		return 0x82191260;
		  /* 82191260h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 82191260h case    7:*/		if ( regs.CR[0].eq ) { return 0x8219126C;  }
		/* 82191260h case    7:*/		return 0x82191264;
		  /* 82191264h */ case    8:  		/* rlwinm. R10, R10, 0, 28, 28 */
		/* 82191264h case    8:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R10);
		/* 82191264h case    8:*/		return 0x82191268;
		  /* 82191268h */ case    9:  		/* bc 4, CR0_EQ, 12 */
		/* 82191268h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82191274;  }
		/* 82191268h case    9:*/		return 0x8219126C;
	}
	return 0x8219126C;
} // Block from 82191244h-8219126Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219126Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219126C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219126C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219126C);
		  /* 8219126Ch */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 8219126Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8219126Ch case    0:*/		return 0x82191270;
		  /* 82191270h */ case    1:  		/* b -32 */
		/* 82191270h case    1:*/		return 0x82191250;
		/* 82191270h case    1:*/		return 0x82191274;
	}
	return 0x82191274;
} // Block from 8219126Ch-82191274h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82191274h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191274( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191274) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191274);
		  /* 82191274h */ case    0:  		/* mr R4, R30 */
		/* 82191274h case    0:*/		regs.R4 = regs.R30;
		/* 82191274h case    0:*/		return 0x82191278;
		  /* 82191278h */ case    1:  		/* mr R3, R26 */
		/* 82191278h case    1:*/		regs.R3 = regs.R26;
		/* 82191278h case    1:*/		return 0x8219127C;
		  /* 8219127Ch */ case    2:  		/* bl -102580 */
		/* 8219127Ch case    2:*/		regs.LR = 0x82191280; return 0x821781C8;
		/* 8219127Ch case    2:*/		return 0x82191280;
	}
	return 0x82191280;
} // Block from 82191274h-82191280h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82191280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191280);
		  /* 82191280h */ case    0:  		/* cmplwi CR6, R24, 4 */
		/* 82191280h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000004);
		/* 82191280h case    0:*/		return 0x82191284;
		  /* 82191284h */ case    1:  		/* bc 4, CR6_LT, 72 */
		/* 82191284h case    1:*/		if ( !regs.CR[6].lt ) { return 0x821912CC;  }
		/* 82191284h case    1:*/		return 0x82191288;
		  /* 82191288h */ case    2:  		/* lwz R11, <#[R28 + 8]> */
		/* 82191288h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 82191288h case    2:*/		return 0x8219128C;
		  /* 8219128Ch */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8219128Ch case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8219128Ch case    3:*/		return 0x82191290;
		  /* 82191290h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 82191290h case    4:*/		if ( regs.CR[0].eq ) { return 0x821912A0;  }
		/* 82191290h case    4:*/		return 0x82191294;
		  /* 82191294h */ case    5:  		/* lwz R11, <#[R26 + 8]> */
		/* 82191294h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82191294h case    5:*/		return 0x82191298;
		  /* 82191298h */ case    6:  		/* ori R11, R11, 1 */
		/* 82191298h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82191298h case    6:*/		return 0x8219129C;
		  /* 8219129Ch */ case    7:  		/* stw R11, <#[R26 + 8]> */
		/* 8219129Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 8219129Ch case    7:*/		return 0x821912A0;
	}
	return 0x821912A0;
} // Block from 82191280h-821912A0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821912A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821912A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821912A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821912A0);
		  /* 821912A0h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 821912A0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821912A0h case    0:*/		return 0x821912A4;
		  /* 821912A4h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 821912A4h case    1:*/		if ( regs.CR[6].eq ) { return 0x821912D4;  }
		/* 821912A4h case    1:*/		return 0x821912A8;
		  /* 821912A8h */ case    2:  		/* mr R4, R26 */
		/* 821912A8h case    2:*/		regs.R4 = regs.R26;
		/* 821912A8h case    2:*/		return 0x821912AC;
		  /* 821912ACh */ case    3:  		/* mr R3, R27 */
		/* 821912ACh case    3:*/		regs.R3 = regs.R27;
		/* 821912ACh case    3:*/		return 0x821912B0;
		  /* 821912B0h */ case    4:  		/* bl -103088 */
		/* 821912B0h case    4:*/		regs.LR = 0x821912B4; return 0x82178000;
		/* 821912B0h case    4:*/		return 0x821912B4;
		  /* 821912B4h */ case    5:  		/* mr R4, R3 */
		/* 821912B4h case    5:*/		regs.R4 = regs.R3;
		/* 821912B4h case    5:*/		return 0x821912B8;
		  /* 821912B8h */ case    6:  		/* mr R3, R29 */
		/* 821912B8h case    6:*/		regs.R3 = regs.R29;
		/* 821912B8h case    6:*/		return 0x821912BC;
		  /* 821912BCh */ case    7:  		/* bl -102644 */
		/* 821912BCh case    7:*/		regs.LR = 0x821912C0; return 0x821781C8;
		/* 821912BCh case    7:*/		return 0x821912C0;
		  /* 821912C0h */ case    8:  		/* addi R11, R25, 11 */
		/* 821912C0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R25,0xB);
		/* 821912C0h case    8:*/		return 0x821912C4;
		  /* 821912C4h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821912C4h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821912C4h case    9:*/		return 0x821912C8;
		  /* 821912C8h */ case   10:  		/* stwx R3, <#[R11 + R29]> */
		/* 821912C8h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 821912C8h case   10:*/		return 0x821912CC;
	}
	return 0x821912CC;
} // Block from 821912A0h-821912CCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 821912CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821912CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821912CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821912CC);
		  /* 821912CCh */ case    0:  		/* addi R1, R1, 160 */
		/* 821912CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 821912CCh case    0:*/		return 0x821912D0;
		  /* 821912D0h */ case    1:  		/* b -1048632 */
		/* 821912D0h case    1:*/		return 0x82091298;
		/* 821912D0h case    1:*/		return 0x821912D4;
	}
	return 0x821912D4;
} // Block from 821912CCh-821912D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821912D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821912D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821912D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821912D4);
		  /* 821912D4h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 821912D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 821912D4h case    0:*/		return 0x821912D8;
		  /* 821912D8h */ case    1:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 821912D8h case    1:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 821912D8h case    1:*/		return 0x821912DC;
		  /* 821912DCh */ case    2:  		/* bc 12, CR0_EQ, -16 */
		/* 821912DCh case    2:*/		if ( regs.CR[0].eq ) { return 0x821912CC;  }
		/* 821912DCh case    2:*/		return 0x821912E0;
		  /* 821912E0h */ case    3:  		/* lwz R11, <#[R26 + 8]> */
		/* 821912E0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821912E0h case    3:*/		return 0x821912E4;
		  /* 821912E4h */ case    4:  		/* li R10, 17 */
		/* 821912E4h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x11);
		/* 821912E4h case    4:*/		return 0x821912E8;
		  /* 821912E8h */ case    5:  		/* rlwimi R11, R10, 1, 26, 30 */
		/* 821912E8h case    5:*/		cpu::op::rlwimi<0,1,26,30>(regs,&regs.R11,regs.R10);
		/* 821912E8h case    5:*/		return 0x821912EC;
		  /* 821912ECh */ case    6:  		/* stw R11, <#[R26 + 8]> */
		/* 821912ECh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821912ECh case    6:*/		return 0x821912F0;
		  /* 821912F0h */ case    7:  		/* lwz R31, <#[R28 + 4]> */
		/* 821912F0h case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x00000004) );
		/* 821912F0h case    7:*/		return 0x821912F4;
		  /* 821912F4h */ case    8:  		/* cmplwi CR6, R31, 0 */
		/* 821912F4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821912F4h case    8:*/		return 0x821912F8;
		  /* 821912F8h */ case    9:  		/* bc 12, CR6_EQ, 36 */
		/* 821912F8h case    9:*/		if ( regs.CR[6].eq ) { return 0x8219131C;  }
		/* 821912F8h case    9:*/		return 0x821912FC;
		  /* 821912FCh */ case   10:  		/* lwz R11, <#[R31 + 16]> */
		/* 821912FCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821912FCh case   10:*/		return 0x82191300;
		  /* 82191300h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 82191300h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82191300h case   11:*/		return 0x82191304;
		  /* 82191304h */ case   12:  		/* bc 12, CR6_EQ, 16 */
		/* 82191304h case   12:*/		if ( regs.CR[6].eq ) { return 0x82191314;  }
		/* 82191304h case   12:*/		return 0x82191308;
		  /* 82191308h */ case   13:  		/* lwz R11, <#[R31]> */
		/* 82191308h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82191308h case   13:*/		return 0x8219130C;
		  /* 8219130Ch */ case   14:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 8219130Ch case   14:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 8219130Ch case   14:*/		return 0x82191310;
		  /* 82191310h */ case   15:  		/* bc 4, CR0_EQ, 12 */
		/* 82191310h case   15:*/		if ( !regs.CR[0].eq ) { return 0x8219131C;  }
		/* 82191310h case   15:*/		return 0x82191314;
	}
	return 0x82191314;
} // Block from 821912D4h-82191314h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82191314h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191314( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191314) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191314);
		  /* 82191314h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 82191314h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 82191314h case    0:*/		return 0x82191318;
		  /* 82191318h */ case    1:  		/* b -36 */
		/* 82191318h case    1:*/		return 0x821912F4;
		/* 82191318h case    1:*/		return 0x8219131C;
	}
	return 0x8219131C;
} // Block from 82191314h-8219131Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219131Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219131C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219131C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219131C);
		  /* 8219131Ch */ case    0:  		/* mr R5, R26 */
		/* 8219131Ch case    0:*/		regs.R5 = regs.R26;
		/* 8219131Ch case    0:*/		return 0x82191320;
		  /* 82191320h */ case    1:  		/* mr R4, R31 */
		/* 82191320h case    1:*/		regs.R4 = regs.R31;
		/* 82191320h case    1:*/		return 0x82191324;
		  /* 82191324h */ case    2:  		/* mr R3, R27 */
		/* 82191324h case    2:*/		regs.R3 = regs.R27;
		/* 82191324h case    2:*/		return 0x82191328;
		  /* 82191328h */ case    3:  		/* bl -131640 */
		/* 82191328h case    3:*/		regs.LR = 0x8219132C; return 0x821710F0;
		/* 82191328h case    3:*/		return 0x8219132C;
		  /* 8219132Ch */ case    4:  		/* lis R11, 4 */
		/* 8219132Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0x4);
		/* 8219132Ch case    4:*/		return 0x82191330;
		  /* 82191330h */ case    5:  		/* mr R4, R3 */
		/* 82191330h case    5:*/		regs.R4 = regs.R3;
		/* 82191330h case    5:*/		return 0x82191334;
		  /* 82191334h */ case    6:  		/* ori R10, R11, 57 */
		/* 82191334h case    6:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R11,0x39);
		/* 82191334h case    6:*/		return 0x82191338;
		  /* 82191338h */ case    7:  		/* lwz R11, <#[R3]> */
		/* 82191338h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82191338h case    7:*/		return 0x8219133C;
		  /* 8219133Ch */ case    8:  		/* li R8, 0 */
		/* 8219133Ch case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8219133Ch case    8:*/		return 0x82191340;
	}
	return 0x82191340;
} // Block from 8219131Ch-82191340h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82191340h
// Function '?GoToPrevBundle@ScheduledBundleEnumerator@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191340);
		  /* 82191340h */ case    0:  		/* rlwimi R11, R10, 7, 19, 26 */
		/* 82191340h case    0:*/		cpu::op::rlwimi<0,7,19,26>(regs,&regs.R11,regs.R10);
		/* 82191340h case    0:*/		return 0x82191344;
		  /* 82191344h */ case    1:  		/* rlwimi R11, R10, 7, 4, 6 */
		/* 82191344h case    1:*/		cpu::op::rlwimi<0,7,4,6>(regs,&regs.R11,regs.R10);
		/* 82191344h case    1:*/		return 0x82191348;
		  /* 82191348h */ case    2:  		/* stw R11, <#[R3]> */
		/* 82191348h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82191348h case    2:*/		return 0x8219134C;
		  /* 8219134Ch */ case    3:  		/* lwz R9, <#[R31]> */
		/* 8219134Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8219134Ch case    3:*/		return 0x82191350;
		  /* 82191350h */ case    4:  		/* lwz R10, <#[R28 + 8]> */
		/* 82191350h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 82191350h case    4:*/		return 0x82191354;
		  /* 82191354h */ case    5:  		/* rlwinm R10, R10, 31, 28, 31 */
		/* 82191354h case    5:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R10,regs.R10);
		/* 82191354h case    5:*/		return 0x82191358;
		  /* 82191358h */ case    6:  		/* rlwinm R9, R9, 19, 28, 31 */
		/* 82191358h case    6:*/		cpu::op::rlwinm<0,19,28,31>(regs,&regs.R9,regs.R9);
		/* 82191358h case    6:*/		return 0x8219135C;
		  /* 8219135Ch */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 8219135Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8219135Ch case    7:*/		return 0x82191360;
		  /* 82191360h */ case    8:  		/* bc 12, CR6_EQ, 56 */
		/* 82191360h case    8:*/		if ( regs.CR[6].eq ) { return 0x82191398;  }
		/* 82191360h case    8:*/		return 0x82191364;
		  /* 82191364h */ case    9:  		/* addi R8, R10, -1 */
		/* 82191364h case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xFFFFFFFF);
		/* 82191364h case    9:*/		return 0x82191368;
		  /* 82191368h */ case   10:  		/* addi R7, R9, -1 */
		/* 82191368h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R9,0xFFFFFFFF);
		/* 82191368h case   10:*/		return 0x8219136C;
		  /* 8219136Ch */ case   11:  		/* andc R6, R10, R8 */
		/* 8219136Ch case   11:*/		cpu::op::andc<0>(regs,&regs.R6,regs.R10,regs.R8);
		/* 8219136Ch case   11:*/		return 0x82191370;
		  /* 82191370h */ case   12:  		/* andc R8, R9, R7 */
		/* 82191370h case   12:*/		cpu::op::andc<0>(regs,&regs.R8,regs.R9,regs.R7);
		/* 82191370h case   12:*/		return 0x82191374;
		  /* 82191374h */ case   13:  		/* cntlzw R7, R6 */
		/* 82191374h case   13:*/		cpu::op::cntlzw<0>(regs,&regs.R7,regs.R6);
		/* 82191374h case   13:*/		return 0x82191378;
		  /* 82191378h */ case   14:  		/* subfic R7, R7, 31 */
		/* 82191378h case   14:*/		cpu::op::subfic<0>(regs,&regs.R7,regs.R7,0x1F);
		/* 82191378h case   14:*/		return 0x8219137C;
		  /* 8219137Ch */ case   15:  		/* cmplw CR6, R7, R24 */
		/* 8219137Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R24);
		/* 8219137Ch case   15:*/		return 0x82191380;
		  /* 82191380h */ case   16:  		/* bc 12, CR6_EQ, 24 */
		/* 82191380h case   16:*/		if ( regs.CR[6].eq ) { return 0x82191398;  }
		/* 82191380h case   16:*/		return 0x82191384;
		  /* 82191384h */ case   17:  		/* addi R7, R10, -1 */
		/* 82191384h case   17:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFFFFF);
		/* 82191384h case   17:*/		return 0x82191388;
		  /* 82191388h */ case   18:  		/* subf R9, R8, R9 */
		/* 82191388h case   18:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82191388h case   18:*/		return 0x8219138C;
		  /* 8219138Ch */ case   19:  		/* andc R7, R10, R7 */
		/* 8219138Ch case   19:*/		cpu::op::andc<0>(regs,&regs.R7,regs.R10,regs.R7);
		/* 8219138Ch case   19:*/		return 0x82191390;
		  /* 82191390h */ case   20:  		/* subf R10, R7, R10 */
		/* 82191390h case   20:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R7,regs.R10);
		/* 82191390h case   20:*/		return 0x82191394;
		  /* 82191394h */ case   21:  		/* b -56 */
		/* 82191394h case   21:*/		return 0x8219135C;
		/* 82191394h case   21:*/		return 0x82191398;
	}
	return 0x82191398;
} // Block from 82191340h-82191398h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82191398h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191398);
		  /* 82191398h */ case    0:  		/* rlwimi R11, R8, 13, 15, 18 */
		/* 82191398h case    0:*/		cpu::op::rlwimi<0,13,15,18>(regs,&regs.R11,regs.R8);
		/* 82191398h case    0:*/		return 0x8219139C;
		  /* 8219139Ch */ case    1:  		/* stw R11, <#[R4]> */
		/* 8219139Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8219139Ch case    1:*/		return 0x821913A0;
		  /* 821913A0h */ case    2:  		/* lwz R3, <#[R31 + 16]> */
		/* 821913A0h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 821913A0h case    2:*/		return 0x821913A4;
		  /* 821913A4h */ case    3:  		/* bl -102876 */
		/* 821913A4h case    3:*/		regs.LR = 0x821913A8; return 0x821781C8;
		/* 821913A4h case    3:*/		return 0x821913A8;
		  /* 821913A8h */ case    4:  		/* lwz R31, <#[R28]> */
		/* 821913A8h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x00000000) );
		/* 821913A8h case    4:*/		return 0x821913AC;
		  /* 821913ACh */ case    5:  		/* cmplwi CR6, R31, 0 */
		/* 821913ACh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821913ACh case    5:*/		return 0x821913B0;
		  /* 821913B0h */ case    6:  		/* bc 12, CR6_EQ, 60 */
		/* 821913B0h case    6:*/		if ( regs.CR[6].eq ) { return 0x821913EC;  }
		/* 821913B0h case    6:*/		return 0x821913B4;
		  /* 821913B4h */ case    7:  		/* lwz R11, <#[R31]> */
		/* 821913B4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821913B4h case    7:*/		return 0x821913B8;
		  /* 821913B8h */ case    8:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 821913B8h case    8:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 821913B8h case    8:*/		return 0x821913BC;
		  /* 821913BCh */ case    9:  		/* bc 4, CR0_EQ, 16 */
		/* 821913BCh case    9:*/		if ( !regs.CR[0].eq ) { return 0x821913CC;  }
		/* 821913BCh case    9:*/		return 0x821913C0;
		  /* 821913C0h */ case   10:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821913C0h case   10:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821913C0h case   10:*/		return 0x821913C4;
		  /* 821913C4h */ case   11:  		/* li R11, 1 */
		/* 821913C4h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821913C4h case   11:*/		return 0x821913C8;
		  /* 821913C8h */ case   12:  		/* bc 12, CR0_EQ, 8 */
		/* 821913C8h case   12:*/		if ( regs.CR[0].eq ) { return 0x821913D0;  }
		/* 821913C8h case   12:*/		return 0x821913CC;
	}
	return 0x821913CC;
} // Block from 82191398h-821913CCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 821913CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821913CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821913CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821913CC);
		  /* 821913CCh */ case    0:  		/* li R11, 0 */
		/* 821913CCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821913CCh case    0:*/		return 0x821913D0;
	}
	return 0x821913D0;
} // Block from 821913CCh-821913D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821913D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821913D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821913D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821913D0);
		  /* 821913D0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821913D0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821913D0h case    0:*/		return 0x821913D4;
		  /* 821913D4h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 821913D4h case    1:*/		if ( regs.CR[0].eq ) { return 0x821913E4;  }
		/* 821913D4h case    1:*/		return 0x821913D8;
		  /* 821913D8h */ case    2:  		/* mr R4, R31 */
		/* 821913D8h case    2:*/		regs.R4 = regs.R31;
		/* 821913D8h case    2:*/		return 0x821913DC;
		  /* 821913DCh */ case    3:  		/* mr R3, R26 */
		/* 821913DCh case    3:*/		regs.R3 = regs.R26;
		/* 821913DCh case    3:*/		return 0x821913E0;
		  /* 821913E0h */ case    4:  		/* bl -102936 */
		/* 821913E0h case    4:*/		regs.LR = 0x821913E4; return 0x821781C8;
		/* 821913E0h case    4:*/		return 0x821913E4;
	}
	return 0x821913E4;
} // Block from 821913D0h-821913E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821913E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821913E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821913E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821913E4);
		  /* 821913E4h */ case    0:  		/* lwz R31, <#[R31 + 4]> */
		/* 821913E4h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 821913E4h case    0:*/		return 0x821913E8;
		  /* 821913E8h */ case    1:  		/* b -60 */
		/* 821913E8h case    1:*/		return 0x821913AC;
		/* 821913E8h case    1:*/		return 0x821913EC;
	}
	return 0x821913EC;
} // Block from 821913E4h-821913ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821913ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821913EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821913EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821913EC);
		  /* 821913ECh */ case    0:  		/* lwz R31, <#[R28 + 4]> */
		/* 821913ECh case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x00000004) );
		/* 821913ECh case    0:*/		return 0x821913F0;
		  /* 821913F0h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 821913F0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821913F0h case    1:*/		return 0x821913F4;
		  /* 821913F4h */ case    2:  		/* bc 12, CR6_EQ, -296 */
		/* 821913F4h case    2:*/		if ( regs.CR[6].eq ) { return 0x821912CC;  }
		/* 821913F4h case    2:*/		return 0x821913F8;
		  /* 821913F8h */ case    3:  		/* lwz R3, <#[R31 + 16]> */
		/* 821913F8h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 821913F8h case    3:*/		return 0x821913FC;
		  /* 821913FCh */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 821913FCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 821913FCh case    4:*/		return 0x82191400;
		  /* 82191400h */ case    5:  		/* bc 12, CR6_EQ, 48 */
		/* 82191400h case    5:*/		if ( regs.CR[6].eq ) { return 0x82191430;  }
		/* 82191400h case    5:*/		return 0x82191404;
		  /* 82191404h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 82191404h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82191404h case    6:*/		return 0x82191408;
		  /* 82191408h */ case    7:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 82191408h case    7:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 82191408h case    7:*/		return 0x8219140C;
		  /* 8219140Ch */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 8219140Ch case    8:*/		if ( !regs.CR[0].eq ) { return 0x8219141C;  }
		/* 8219140Ch case    8:*/		return 0x82191410;
		  /* 82191410h */ case    9:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82191410h case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82191410h case    9:*/		return 0x82191414;
		  /* 82191414h */ case   10:  		/* li R11, 1 */
		/* 82191414h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82191414h case   10:*/		return 0x82191418;
		  /* 82191418h */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 82191418h case   11:*/		if ( regs.CR[0].eq ) { return 0x82191420;  }
		/* 82191418h case   11:*/		return 0x8219141C;
	}
	return 0x8219141C;
} // Block from 821913ECh-8219141Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8219141Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219141C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219141C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219141C);
		  /* 8219141Ch */ case    0:  		/* li R11, 0 */
		/* 8219141Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219141Ch case    0:*/		return 0x82191420;
	}
	return 0x82191420;
} // Block from 8219141Ch-82191420h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82191420h
// Function '?FillEmptySlot@ScheduledBundleEnumerator@D3DXShader@@QAAXPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191420);
		  /* 82191420h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82191420h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82191420h case    0:*/		return 0x82191424;
		  /* 82191424h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82191424h case    1:*/		if ( regs.CR[0].eq ) { return 0x82191430;  }
		/* 82191424h case    1:*/		return 0x82191428;
		  /* 82191428h */ case    2:  		/* mr R4, R31 */
		/* 82191428h case    2:*/		regs.R4 = regs.R31;
		/* 82191428h case    2:*/		return 0x8219142C;
		  /* 8219142Ch */ case    3:  		/* bl -103012 */
		/* 8219142Ch case    3:*/		regs.LR = 0x82191430; return 0x821781C8;
		/* 8219142Ch case    3:*/		return 0x82191430;
	}
	return 0x82191430;
} // Block from 82191420h-82191430h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82191430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191430);
		  /* 82191430h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 82191430h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 82191430h case    0:*/		return 0x82191434;
		  /* 82191434h */ case    1:  		/* b -68 */
		/* 82191434h case    1:*/		return 0x821913F0;
		/* 82191434h case    1:*/		return 0x82191438;
	}
	return 0x82191438;
} // Block from 82191430h-82191438h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82191438h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191438);
		  /* 82191438h */ case    0:  		/* mfspr R12, LR */
		/* 82191438h case    0:*/		regs.R12 = regs.LR;
		/* 82191438h case    0:*/		return 0x8219143C;
		  /* 8219143Ch */ case    1:  		/* bl -1049076 */
		/* 8219143Ch case    1:*/		regs.LR = 0x82191440; return 0x82091248;
		/* 8219143Ch case    1:*/		return 0x82191440;
		  /* 82191440h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82191440h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82191440h case    2:*/		return 0x82191444;
		  /* 82191444h */ case    3:  		/* lwz R11, <#[R5 + 8]> */
		/* 82191444h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 82191444h case    3:*/		return 0x82191448;
		  /* 82191448h */ case    4:  		/* mr R24, R3 */
		/* 82191448h case    4:*/		regs.R24 = regs.R3;
		/* 82191448h case    4:*/		return 0x8219144C;
		  /* 8219144Ch */ case    5:  		/* mr R26, R4 */
		/* 8219144Ch case    5:*/		regs.R26 = regs.R4;
		/* 8219144Ch case    5:*/		return 0x82191450;
		  /* 82191450h */ case    6:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82191450h case    6:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82191450h case    6:*/		return 0x82191454;
		  /* 82191454h */ case    7:  		/* mr R30, R5 */
		/* 82191454h case    7:*/		regs.R30 = regs.R5;
		/* 82191454h case    7:*/		return 0x82191458;
		  /* 82191458h */ case    8:  		/* li R27, 0 */
		/* 82191458h case    8:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82191458h case    8:*/		return 0x8219145C;
		  /* 8219145Ch */ case    9:  		/* li R29, 0 */
		/* 8219145Ch case    9:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8219145Ch case    9:*/		return 0x82191460;
		  /* 82191460h */ case   10:  		/* cmplwi CR6, R11, 14080 */
		/* 82191460h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 82191460h case   10:*/		return 0x82191464;
		  /* 82191464h */ case   11:  		/* bc 4, CR6_EQ, 136 */
		/* 82191464h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821914EC;  }
		/* 82191464h case   11:*/		return 0x82191468;
		  /* 82191468h */ case   12:  		/* lwz R10, <#[R4 + 4]> */
		/* 82191468h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 82191468h case   12:*/		return 0x8219146C;
		  /* 8219146Ch */ case   13:  		/* cmplwi CR6, R10, 0 */
		/* 8219146Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8219146Ch case   13:*/		return 0x82191470;
		  /* 82191470h */ case   14:  		/* bc 12, CR6_EQ, 124 */
		/* 82191470h case   14:*/		if ( regs.CR[6].eq ) { return 0x821914EC;  }
		/* 82191470h case   14:*/		return 0x82191474;
		  /* 82191474h */ case   15:  		/* lwz R11, <#[R10 + 16]> */
		/* 82191474h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 82191474h case   15:*/		return 0x82191478;
		  /* 82191478h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 82191478h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82191478h case   16:*/		return 0x8219147C;
		  /* 8219147Ch */ case   17:  		/* bc 12, CR6_EQ, 20 */
		/* 8219147Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x82191490;  }
		/* 8219147Ch case   17:*/		return 0x82191480;
		  /* 82191480h */ case   18:  		/* lwz R9, <#[R11 + 8]> */
		/* 82191480h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82191480h case   18:*/		return 0x82191484;
		  /* 82191484h */ case   19:  		/* rlwinm R9, R9, 0, 18, 24 */
		/* 82191484h case   19:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R9);
		/* 82191484h case   19:*/		return 0x82191488;
		  /* 82191488h */ case   20:  		/* cmplwi CR6, R9, 14080 */
		/* 82191488h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00003700);
		/* 82191488h case   20:*/		return 0x8219148C;
		  /* 8219148Ch */ case   21:  		/* bc 12, CR6_EQ, 12 */
		/* 8219148Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x82191498;  }
		/* 8219148Ch case   21:*/		return 0x82191490;
	}
	return 0x82191490;
} // Block from 82191438h-82191490h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82191490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191490);
		  /* 82191490h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 82191490h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82191490h case    0:*/		return 0x82191494;
		  /* 82191494h */ case    1:  		/* b -40 */
		/* 82191494h case    1:*/		return 0x8219146C;
		/* 82191494h case    1:*/		return 0x82191498;
	}
	return 0x82191498;
} // Block from 82191490h-82191498h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82191498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191498);
		  /* 82191498h */ case    0:  		/* lwz R9, <#[R11 + 8]> */
		/* 82191498h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82191498h case    0:*/		return 0x8219149C;
		  /* 8219149Ch */ case    1:  		/* mr R27, R11 */
		/* 8219149Ch case    1:*/		regs.R27 = regs.R11;
		/* 8219149Ch case    1:*/		return 0x821914A0;
	}
	return 0x821914A0;
} // Block from 82191498h-821914A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821914A0h
// Function '?AddNonMicrocodeToSlot@ScheduledBundleEnumerator@D3DXShader@@QAAXPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821914A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821914A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821914A0);
		  /* 821914A0h */ case    0:  		/* li R10, 0 */
		/* 821914A0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821914A0h case    0:*/		return 0x821914A4;
		  /* 821914A4h */ case    1:  		/* rlwinm R8, R9, 13, 29, 31 */
		/* 821914A4h case    1:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R8,regs.R9);
		/* 821914A4h case    1:*/		return 0x821914A8;
		  /* 821914A8h */ case    2:  		/* addi R9, R11, 44 */
		/* 821914A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x2C);
		/* 821914A8h case    2:*/		return 0x821914AC;
		  /* 821914ACh */ case    3:  		/* cmplw CR6, R10, R8 */
		/* 821914ACh case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 821914ACh case    3:*/		return 0x821914B0;
		  /* 821914B0h */ case    4:  		/* bc 4, CR6_LT, 60 */
		/* 821914B0h case    4:*/		if ( !regs.CR[6].lt ) { return 0x821914EC;  }
		/* 821914B0h case    4:*/		return 0x821914B4;
		  /* 821914B4h */ case    5:  		/* lwz R11, <#[R9]> */
		/* 821914B4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 821914B4h case    5:*/		return 0x821914B8;
		  /* 821914B8h */ case    6:  		/* lwz R7, <#[R11 + 12]> */
		/* 821914B8h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 821914B8h case    6:*/		return 0x821914BC;
		  /* 821914BCh */ case    7:  		/* cmplw CR6, R7, R26 */
		/* 821914BCh case    7:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R26);
		/* 821914BCh case    7:*/		return 0x821914C0;
		  /* 821914C0h */ case    8:  		/* bc 4, CR6_EQ, 32 */
		/* 821914C0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821914E0;  }
		/* 821914C0h case    8:*/		return 0x821914C4;
		  /* 821914C4h */ case    9:  		/* lwz R11, <#[R11]> */
		/* 821914C4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821914C4h case    9:*/		return 0x821914C8;
		  /* 821914C8h */ case   10:  		/* li R7, 3 */
		/* 821914C8h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 821914C8h case   10:*/		return 0x821914CC;
		  /* 821914CCh */ case   11:  		/* rlwinm R11, R11, 28, 29, 30 */
		/* 821914CCh case   11:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R11,regs.R11);
		/* 821914CCh case   11:*/		return 0x821914D0;
		  /* 821914D0h */ case   12:  		/* slw R7, R7, R11 */
		/* 821914D0h case   12:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R7,regs.R11);
		/* 821914D0h case   12:*/		return 0x821914D4;
		  /* 821914D4h */ case   13:  		/* andc R7, R29, R7 */
		/* 821914D4h case   13:*/		cpu::op::andc<0>(regs,&regs.R7,regs.R29,regs.R7);
		/* 821914D4h case   13:*/		return 0x821914D8;
		  /* 821914D8h */ case   14:  		/* slw R11, R10, R11 */
		/* 821914D8h case   14:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821914D8h case   14:*/		return 0x821914DC;
		  /* 821914DCh */ case   15:  		/* or R29, R7, R11 */
		/* 821914DCh case   15:*/		cpu::op::or<0>(regs,&regs.R29,regs.R7,regs.R11);
		/* 821914DCh case   15:*/		return 0x821914E0;
	}
	return 0x821914E0;
} // Block from 821914A0h-821914E0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821914E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821914E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821914E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821914E0);
		  /* 821914E0h */ case    0:  		/* addi R10, R10, 1 */
		/* 821914E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821914E0h case    0:*/		return 0x821914E4;
		  /* 821914E4h */ case    1:  		/* addi R9, R9, 4 */
		/* 821914E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 821914E4h case    1:*/		return 0x821914E8;
		  /* 821914E8h */ case    2:  		/* b -60 */
		/* 821914E8h case    2:*/		return 0x821914AC;
		/* 821914E8h case    2:*/		return 0x821914EC;
	}
	return 0x821914EC;
} // Block from 821914E0h-821914ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821914ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821914EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821914EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821914EC);
		  /* 821914ECh */ case    0:  		/* addi R28, R26, 4 */
		/* 821914ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R26,0x4);
		/* 821914ECh case    0:*/		return 0x821914F0;
		  /* 821914F0h */ case    1:  		/* li R25, 1 */
		/* 821914F0h case    1:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 821914F0h case    1:*/		return 0x821914F4;
		  /* 821914F4h */ case    2:  		/* lwz R31, <#[R28]> */
		/* 821914F4h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x00000000) );
		/* 821914F4h case    2:*/		return 0x821914F8;
		  /* 821914F8h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 821914F8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821914F8h case    3:*/		return 0x821914FC;
		  /* 821914FCh */ case    4:  		/* bc 12, CR6_EQ, 532 */
		/* 821914FCh case    4:*/		if ( regs.CR[6].eq ) { return 0x82191710;  }
		/* 821914FCh case    4:*/		return 0x82191500;
		  /* 82191500h */ case    5:  		/* lwz R3, <#[R31 + 16]> */
		/* 82191500h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82191500h case    5:*/		return 0x82191504;
		  /* 82191504h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 82191504h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82191504h case    6:*/		return 0x82191508;
		  /* 82191508h */ case    7:  		/* bc 12, CR6_EQ, 500 */
		/* 82191508h case    7:*/		if ( regs.CR[6].eq ) { return 0x821916FC;  }
		/* 82191508h case    7:*/		return 0x8219150C;
		  /* 8219150Ch */ case    8:  		/* lwz R6, <#[R31]> */
		/* 8219150Ch case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000000) );
		/* 8219150Ch case    8:*/		return 0x82191510;
		  /* 82191510h */ case    9:  		/* rlwinm. R11, R6, 7, 29, 31 */
		/* 82191510h case    9:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R11,regs.R6);
		/* 82191510h case    9:*/		return 0x82191514;
		  /* 82191514h */ case   10:  		/* bc 12, CR0_EQ, 392 */
		/* 82191514h case   10:*/		if ( regs.CR[0].eq ) { return 0x8219169C;  }
		/* 82191514h case   10:*/		return 0x82191518;
		  /* 82191518h */ case   11:  		/* lwz R10, <#[R30 + 8]> */
		/* 82191518h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82191518h case   11:*/		return 0x8219151C;
		  /* 8219151Ch */ case   12:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 8219151Ch case   12:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 8219151Ch case   12:*/		return 0x82191520;
		  /* 82191520h */ case   13:  		/* cmplwi CR6, R10, 14080 */
		/* 82191520h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003700);
		/* 82191520h case   13:*/		return 0x82191524;
		  /* 82191524h */ case   14:  		/* bc 4, CR6_EQ, 376 */
		/* 82191524h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8219169C;  }
		/* 82191524h case   14:*/		return 0x82191528;
		  /* 82191528h */ case   15:  		/* lwz R10, <#[R3 + 8]> */
		/* 82191528h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82191528h case   15:*/		return 0x8219152C;
		  /* 8219152Ch */ case   16:  		/* rlwinm R10, R10, 25, 25, 31 */
		/* 8219152Ch case   16:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R10);
		/* 8219152Ch case   16:*/		return 0x82191530;
		  /* 82191530h */ case   17:  		/* cmplwi CR6, R10, 112 */
		/* 82191530h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000070);
		/* 82191530h case   17:*/		return 0x82191534;
		  /* 82191534h */ case   18:  		/* bc 12, CR6_EQ, 268 */
		/* 82191534h case   18:*/		if ( regs.CR[6].eq ) { return 0x82191640;  }
		/* 82191534h case   18:*/		return 0x82191538;
		  /* 82191538h */ case   19:  		/* cmplwi CR6, R10, 110 */
		/* 82191538h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000006E);
		/* 82191538h case   19:*/		return 0x8219153C;
		  /* 8219153Ch */ case   20:  		/* bc 12, CR6_EQ, 260 */
		/* 8219153Ch case   20:*/		if ( regs.CR[6].eq ) { return 0x82191640;  }
		/* 8219153Ch case   20:*/		return 0x82191540;
		  /* 82191540h */ case   21:  		/* li R9, 0 */
		/* 82191540h case   21:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82191540h case   21:*/		return 0x82191544;
		  /* 82191544h */ case   22:  		/* li R10, 0 */
		/* 82191544h case   22:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82191544h case   22:*/		return 0x82191548;
		  /* 82191548h */ case   23:  		/* cmplwi CR6, R11, 0 */
		/* 82191548h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82191548h case   23:*/		return 0x8219154C;
		  /* 8219154Ch */ case   24:  		/* bc 12, CR6_EQ, 80 */
		/* 8219154Ch case   24:*/		if ( regs.CR[6].eq ) { return 0x8219159C;  }
		/* 8219154Ch case   24:*/		return 0x82191550;
		  /* 82191550h */ case   25:  		/* rlwinm R7, R6, 0, 0, 31 */
		/* 82191550h case   25:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R7,regs.R6);
		/* 82191550h case   25:*/		return 0x82191554;
		  /* 82191554h */ case   26:  		/* rlwinm R8, R6, 27, 24, 31 */
		/* 82191554h case   26:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R8,regs.R6);
		/* 82191554h case   26:*/		return 0x82191558;
		  /* 82191558h */ case   27:  		/* li R11, 0 */
		/* 82191558h case   27:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82191558h case   27:*/		return 0x8219155C;
		  /* 8219155Ch */ case   28:  		/* rlwinm R7, R7, 7, 29, 31 */
		/* 8219155Ch case   28:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R7,regs.R7);
		/* 8219155Ch case   28:*/		return 0x82191560;
		  /* 82191560h */ case   29:  		/* srw R5, R8, R11 */
		/* 82191560h case   29:*/		cpu::op::srw<0>(regs,&regs.R5,regs.R8,regs.R11);
		/* 82191560h case   29:*/		return 0x82191564;
		  /* 82191564h */ case   30:  		/* rlwinm R5, R5, 0, 30, 31 */
		/* 82191564h case   30:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R5,regs.R5);
		/* 82191564h case   30:*/		return 0x82191568;
		  /* 82191568h */ case   31:  		/* addi R10, R10, 1 */
		/* 82191568h case   31:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82191568h case   31:*/		return 0x8219156C;
		  /* 8219156Ch */ case   32:  		/* slw R5, R25, R5 */
		/* 8219156Ch case   32:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R25,regs.R5);
		/* 8219156Ch case   32:*/		return 0x82191570;
		  /* 82191570h */ case   33:  		/* or R9, R5, R9 */
		/* 82191570h case   33:*/		cpu::op::or<0>(regs,&regs.R9,regs.R5,regs.R9);
		/* 82191570h case   33:*/		return 0x82191574;
		  /* 82191574h */ case   34:  		/* addi R11, R11, 2 */
		/* 82191574h case   34:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82191574h case   34:*/		return 0x82191578;
		  /* 82191578h */ case   35:  		/* cmplw CR6, R10, R7 */
		/* 82191578h case   35:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 82191578h case   35:*/		return 0x8219157C;
		  /* 8219157Ch */ case   36:  		/* bc 12, CR6_LT, -28 */
		/* 8219157Ch case   36:*/		if ( regs.CR[6].lt ) { return 0x82191560;  }
		/* 8219157Ch case   36:*/		return 0x82191580;
		  /* 82191580h */ case   37:  		/* cmplwi CR6, R9, 0 */
		/* 82191580h case   37:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82191580h case   37:*/		return 0x82191584;
		  /* 82191584h */ case   38:  		/* bc 12, CR6_EQ, 24 */
		/* 82191584h case   38:*/		if ( regs.CR[6].eq ) { return 0x8219159C;  }
		/* 82191584h case   38:*/		return 0x82191588;
		  /* 82191588h */ case   39:  		/* addi R11, R9, -1 */
		/* 82191588h case   39:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 82191588h case   39:*/		return 0x8219158C;
		  /* 8219158Ch */ case   40:  		/* andc R11, R9, R11 */
		/* 8219158Ch case   40:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8219158Ch case   40:*/		return 0x82191590;
	}
	return 0x82191590;
} // Block from 821914ECh-82191590h (41 instructions)

//////////////////////////////////////////////////////
// Block at 82191590h
// Function '?CheckMergeInterference@Compiler@D3DXShader@@AAAXPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191590( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191590) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191590);
		  /* 82191590h */ case    0:  		/* subf. R11, R11, R9 */
		/* 82191590h case    0:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82191590h case    0:*/		return 0x82191594;
		  /* 82191594h */ case    1:  		/* mr R11, R25 */
		/* 82191594h case    1:*/		regs.R11 = regs.R25;
		/* 82191594h case    1:*/		return 0x82191598;
		  /* 82191598h */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 82191598h case    2:*/		if ( regs.CR[0].eq ) { return 0x821915A0;  }
		/* 82191598h case    2:*/		return 0x8219159C;
	}
	return 0x8219159C;
} // Block from 82191590h-8219159Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219159Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219159C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219159C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219159C);
		  /* 8219159Ch */ case    0:  		/* li R11, 0 */
		/* 8219159Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219159Ch case    0:*/		return 0x821915A0;
	}
	return 0x821915A0;
} // Block from 8219159Ch-821915A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821915A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821915A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821915A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821915A0);
		  /* 821915A0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821915A0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821915A0h case    0:*/		return 0x821915A4;
		  /* 821915A4h */ case    1:  		/* bc 4, CR0_EQ, 156 */
		/* 821915A4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82191640;  }
		/* 821915A4h case    1:*/		return 0x821915A8;
		  /* 821915A8h */ case    2:  		/* rlwinm. R11, R6, 0, 31, 31 */
		/* 821915A8h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R6);
		/* 821915A8h case    2:*/		return 0x821915AC;
		  /* 821915ACh */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 821915ACh case    3:*/		if ( regs.CR[0].eq ) { return 0x821915B8;  }
		/* 821915ACh case    3:*/		return 0x821915B0;
		  /* 821915B0h */ case    4:  		/* rlwinm R11, R6, 0, 0, 30 */
		/* 821915B0h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R6);
		/* 821915B0h case    4:*/		return 0x821915B4;
		  /* 821915B4h */ case    5:  		/* stw R11, <#[R31]> */
		/* 821915B4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821915B4h case    5:*/		return 0x821915B8;
	}
	return 0x821915B8;
} // Block from 821915A0h-821915B8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821915B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821915B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821915B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821915B8);
		  /* 821915B8h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 821915B8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 821915B8h case    0:*/		return 0x821915BC;
		  /* 821915BCh */ case    1:  		/* bc 12, CR6_EQ, 224 */
		/* 821915BCh case    1:*/		if ( regs.CR[6].eq ) { return 0x8219169C;  }
		/* 821915BCh case    1:*/		return 0x821915C0;
		  /* 821915C0h */ case    2:  		/* lwz R10, <#[R31]> */
		/* 821915C0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821915C0h case    2:*/		return 0x821915C4;
		  /* 821915C4h */ case    3:  		/* lwz R11, <#[R31 + 12]> */
		/* 821915C4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821915C4h case    3:*/		return 0x821915C8;
		  /* 821915C8h */ case    4:  		/* rlwinm R9, R10, 22, 29, 30 */
		/* 821915C8h case    4:*/		cpu::op::rlwinm<0,22,29,30>(regs,&regs.R9,regs.R10);
		/* 821915C8h case    4:*/		return 0x821915CC;
		  /* 821915CCh */ case    5:  		/* rlwinm R8, R10, 24, 29, 30 */
		/* 821915CCh case    5:*/		cpu::op::rlwinm<0,24,29,30>(regs,&regs.R8,regs.R10);
		/* 821915CCh case    5:*/		return 0x821915D0;
		  /* 821915D0h */ case    6:  		/* srw R9, R29, R9 */
		/* 821915D0h case    6:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R29,regs.R9);
		/* 821915D0h case    6:*/		return 0x821915D4;
		  /* 821915D4h */ case    7:  		/* srw R8, R29, R8 */
		/* 821915D4h case    7:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R29,regs.R8);
		/* 821915D4h case    7:*/		return 0x821915D8;
		  /* 821915D8h */ case    8:  		/* rlwimi R8, R9, 2, 28, 29 */
		/* 821915D8h case    8:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R8,regs.R9);
		/* 821915D8h case    8:*/		return 0x821915DC;
		  /* 821915DCh */ case    9:  		/* rlwinm R9, R10, 26, 29, 30 */
		/* 821915DCh case    9:*/		cpu::op::rlwinm<0,26,29,30>(regs,&regs.R9,regs.R10);
		/* 821915DCh case    9:*/		return 0x821915E0;
		  /* 821915E0h */ case   10:  		/* rlwinm R8, R8, 0, 28, 31 */
		/* 821915E0h case   10:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R8,regs.R8);
		/* 821915E0h case   10:*/		return 0x821915E4;
		  /* 821915E4h */ case   11:  		/* srw R9, R29, R9 */
		/* 821915E4h case   11:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R29,regs.R9);
		/* 821915E4h case   11:*/		return 0x821915E8;
		  /* 821915E8h */ case   12:  		/* rlwinm R7, R10, 28, 29, 30 */
		/* 821915E8h case   12:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R7,regs.R10);
		/* 821915E8h case   12:*/		return 0x821915EC;
		  /* 821915ECh */ case   13:  		/* rlwimi R9, R8, 2, 0, 29 */
		/* 821915ECh case   13:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 821915ECh case   13:*/		return 0x821915F0;
		  /* 821915F0h */ case   14:  		/* srw R8, R29, R7 */
		/* 821915F0h case   14:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R29,regs.R7);
		/* 821915F0h case   14:*/		return 0x821915F4;
		  /* 821915F4h */ case   15:  		/* rlwimi R8, R9, 2, 0, 29 */
		/* 821915F4h case   15:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R8,regs.R9);
		/* 821915F4h case   15:*/		return 0x821915F8;
		  /* 821915F8h */ case   16:  		/* rlwinm R10, R10, 0, 27, 18 */
		/* 821915F8h case   16:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R10,regs.R10);
		/* 821915F8h case   16:*/		return 0x821915FC;
		  /* 821915FCh */ case   17:  		/* rlwinm R9, R8, 5, 0, 26 */
		/* 821915FCh case   17:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R9,regs.R8);
		/* 821915FCh case   17:*/		return 0x82191600;
		  /* 82191600h */ case   18:  		/* addi R11, R11, 4 */
		/* 82191600h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82191600h case   18:*/		return 0x82191604;
		  /* 82191604h */ case   19:  		/* or R10, R9, R10 */
		/* 82191604h case   19:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82191604h case   19:*/		return 0x82191608;
		  /* 82191608h */ case   20:  		/* stw R10, <#[R31]> */
		/* 82191608h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82191608h case   20:*/		return 0x8219160C;
		  /* 8219160Ch */ case   21:  		/* lwz R10, <#[R11]> */
		/* 8219160Ch case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8219160Ch case   21:*/		return 0x82191610;
		  /* 82191610h */ case   22:  		/* b 12 */
		/* 82191610h case   22:*/		return 0x8219161C;
		/* 82191610h case   22:*/		return 0x82191614;
		  /* 82191614h */ case   23:  		/* addi R11, R10, 8 */
		/* 82191614h case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 82191614h case   23:*/		return 0x82191618;
		  /* 82191618h */ case   24:  		/* lwz R10, <#[R10 + 8]> */
		/* 82191618h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82191618h case   24:*/		return 0x8219161C;
	}
	return 0x8219161C;
} // Block from 821915B8h-8219161Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 8219161Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219161C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219161C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219161C);
		  /* 8219161Ch */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 8219161Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 8219161Ch case    0:*/		return 0x82191620;
		  /* 82191620h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82191620h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82191614;  }
		/* 82191620h case    1:*/		return 0x82191624;
		  /* 82191624h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 82191624h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82191624h case    2:*/		return 0x82191628;
		  /* 82191628h */ case    3:  		/* stw R10, <#[R11]> */
		/* 82191628h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82191628h case    3:*/		return 0x8219162C;
		  /* 8219162Ch */ case    4:  		/* lwz R11, <#[R27 + 4]> */
		/* 8219162Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 8219162Ch case    4:*/		return 0x82191630;
		  /* 82191630h */ case    5:  		/* stw R11, <#[R31 + 8]> */
		/* 82191630h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82191630h case    5:*/		return 0x82191634;
		  /* 82191634h */ case    6:  		/* stw R31, <#[R27 + 4]> */
		/* 82191634h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R27 + 0x00000004) );
		/* 82191634h case    6:*/		return 0x82191638;
		  /* 82191638h */ case    7:  		/* stw R27, <#[R31 + 12]> */
		/* 82191638h case    7:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x0000000C) );
		/* 82191638h case    7:*/		return 0x8219163C;
		  /* 8219163Ch */ case    8:  		/* b 192 */
		/* 8219163Ch case    8:*/		return 0x821916FC;
		/* 8219163Ch case    8:*/		return 0x82191640;
	}
	return 0x82191640;
} // Block from 8219161Ch-82191640h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82191640h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191640);
		  /* 82191640h */ case    0:  		/* rlwinm R11, R6, 27, 30, 31 */
		/* 82191640h case    0:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R11,regs.R6);
		/* 82191640h case    0:*/		return 0x82191644;
		  /* 82191644h */ case    1:  		/* addi R10, R11, 11 */
		/* 82191644h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xB);
		/* 82191644h case    1:*/		return 0x82191648;
		  /* 82191648h */ case    2:  		/* lwz R11, <#[R31 + 12]> */
		/* 82191648h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82191648h case    2:*/		return 0x8219164C;
		  /* 8219164Ch */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8219164Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8219164Ch case    3:*/		return 0x82191650;
		  /* 82191650h */ case    4:  		/* addi R11, R11, 4 */
		/* 82191650h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82191650h case    4:*/		return 0x82191654;
		  /* 82191654h */ case    5:  		/* lwzx R9, <#[R10 + R30]> */
		/* 82191654h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 82191654h case    5:*/		return 0x82191658;
		  /* 82191658h */ case    6:  		/* lwz R10, <#[R11]> */
		/* 82191658h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82191658h case    6:*/		return 0x8219165C;
		  /* 8219165Ch */ case    7:  		/* lwz R9, <#[R9 + 12]> */
		/* 8219165Ch case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000000C) );
		/* 8219165Ch case    7:*/		return 0x82191660;
		  /* 82191660h */ case    8:  		/* b 12 */
		/* 82191660h case    8:*/		return 0x8219166C;
		/* 82191660h case    8:*/		return 0x82191664;
		  /* 82191664h */ case    9:  		/* addi R11, R10, 8 */
		/* 82191664h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 82191664h case    9:*/		return 0x82191668;
		  /* 82191668h */ case   10:  		/* lwz R10, <#[R10 + 8]> */
		/* 82191668h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82191668h case   10:*/		return 0x8219166C;
	}
	return 0x8219166C;
} // Block from 82191640h-8219166Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219166Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219166C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219166C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219166C);
		  /* 8219166Ch */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 8219166Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 8219166Ch case    0:*/		return 0x82191670;
		  /* 82191670h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82191670h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82191664;  }
		/* 82191670h case    1:*/		return 0x82191674;
		  /* 82191674h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 82191674h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82191674h case    2:*/		return 0x82191678;
		  /* 82191678h */ case    3:  		/* stw R10, <#[R11]> */
		/* 82191678h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82191678h case    3:*/		return 0x8219167C;
		  /* 8219167Ch */ case    4:  		/* lwz R11, <#[R9 + 4]> */
		/* 8219167Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 8219167Ch case    4:*/		return 0x82191680;
		  /* 82191680h */ case    5:  		/* stw R11, <#[R31 + 8]> */
		/* 82191680h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82191680h case    5:*/		return 0x82191684;
		  /* 82191684h */ case    6:  		/* stw R31, <#[R9 + 4]> */
		/* 82191684h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R9 + 0x00000004) );
		/* 82191684h case    6:*/		return 0x82191688;
		  /* 82191688h */ case    7:  		/* lwz R11, <#[R31]> */
		/* 82191688h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82191688h case    7:*/		return 0x8219168C;
		  /* 8219168Ch */ case    8:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 8219168Ch case    8:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 8219168Ch case    8:*/		return 0x82191690;
		  /* 82191690h */ case    9:  		/* stw R9, <#[R31 + 12]> */
		/* 82191690h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 82191690h case    9:*/		return 0x82191694;
		  /* 82191694h */ case   10:  		/* stw R11, <#[R31]> */
		/* 82191694h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82191694h case   10:*/		return 0x82191698;
		  /* 82191698h */ case   11:  		/* b 100 */
		/* 82191698h case   11:*/		return 0x821916FC;
		/* 82191698h case   11:*/		return 0x8219169C;
	}
	return 0x8219169C;
} // Block from 8219166Ch-8219169Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8219169Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219169C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219169C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219169C);
		  /* 8219169Ch */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 8219169Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219169Ch case    0:*/		return 0x821916A0;
		  /* 821916A0h */ case    1:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 821916A0h case    1:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 821916A0h case    1:*/		return 0x821916A4;
		  /* 821916A4h */ case    2:  		/* bc 12, CR0_EQ, 32 */
		/* 821916A4h case    2:*/		if ( regs.CR[0].eq ) { return 0x821916C4;  }
		/* 821916A4h case    2:*/		return 0x821916A8;
		  /* 821916A8h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 821916A8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821916A8h case    3:*/		return 0x821916AC;
		  /* 821916ACh */ case    4:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821916ACh case    4:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821916ACh case    4:*/		return 0x821916B0;
		  /* 821916B0h */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 821916B0h case    5:*/		if ( regs.CR[0].eq ) { return 0x821916C4;  }
		/* 821916B0h case    5:*/		return 0x821916B4;
		  /* 821916B4h */ case    6:  		/* mr R5, R24 */
		/* 821916B4h case    6:*/		regs.R5 = regs.R24;
		/* 821916B4h case    6:*/		return 0x821916B8;
		  /* 821916B8h */ case    7:  		/* mr R4, R31 */
		/* 821916B8h case    7:*/		regs.R4 = regs.R31;
		/* 821916B8h case    7:*/		return 0x821916BC;
		  /* 821916BCh */ case    8:  		/* bl -101804 */
		/* 821916BCh case    8:*/		regs.LR = 0x821916C0; return 0x82178910;
		/* 821916BCh case    8:*/		return 0x821916C0;
		  /* 821916C0h */ case    9:  		/* b 60 */
		/* 821916C0h case    9:*/		return 0x821916FC;
		/* 821916C0h case    9:*/		return 0x821916C4;
	}
	return 0x821916C4;
} // Block from 8219169Ch-821916C4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821916C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821916C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821916C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821916C4);
		  /* 821916C4h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 821916C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821916C4h case    0:*/		return 0x821916C8;
		  /* 821916C8h */ case    1:  		/* addi R11, R11, 4 */
		/* 821916C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821916C8h case    1:*/		return 0x821916CC;
		  /* 821916CCh */ case    2:  		/* lwz R10, <#[R11]> */
		/* 821916CCh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821916CCh case    2:*/		return 0x821916D0;
		  /* 821916D0h */ case    3:  		/* b 12 */
		/* 821916D0h case    3:*/		return 0x821916DC;
		/* 821916D0h case    3:*/		return 0x821916D4;
		  /* 821916D4h */ case    4:  		/* addi R11, R10, 8 */
		/* 821916D4h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 821916D4h case    4:*/		return 0x821916D8;
		  /* 821916D8h */ case    5:  		/* lwz R10, <#[R10 + 8]> */
		/* 821916D8h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821916D8h case    5:*/		return 0x821916DC;
	}
	return 0x821916DC;
} // Block from 821916C4h-821916DCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821916DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821916DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821916DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821916DC);
		  /* 821916DCh */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 821916DCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 821916DCh case    0:*/		return 0x821916E0;
		  /* 821916E0h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821916E0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821916D4;  }
		/* 821916E0h case    1:*/		return 0x821916E4;
		  /* 821916E4h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 821916E4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821916E4h case    2:*/		return 0x821916E8;
		  /* 821916E8h */ case    3:  		/* stw R10, <#[R11]> */
		/* 821916E8h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821916E8h case    3:*/		return 0x821916EC;
		  /* 821916ECh */ case    4:  		/* lwz R11, <#[R30 + 4]> */
		/* 821916ECh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821916ECh case    4:*/		return 0x821916F0;
		  /* 821916F0h */ case    5:  		/* stw R11, <#[R31 + 8]> */
		/* 821916F0h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821916F0h case    5:*/		return 0x821916F4;
		  /* 821916F4h */ case    6:  		/* stw R31, <#[R30 + 4]> */
		/* 821916F4h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000004) );
		/* 821916F4h case    6:*/		return 0x821916F8;
		  /* 821916F8h */ case    7:  		/* stw R30, <#[R31 + 12]> */
		/* 821916F8h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 821916F8h case    7:*/		return 0x821916FC;
	}
	return 0x821916FC;
} // Block from 821916DCh-821916FCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 821916FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821916FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821916FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821916FC);
		  /* 821916FCh */ case    0:  		/* lwz R11, <#[R28]> */
		/* 821916FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821916FCh case    0:*/		return 0x82191700;
		  /* 82191700h */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 82191700h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 82191700h case    1:*/		return 0x82191704;
		  /* 82191704h */ case    2:  		/* bc 4, CR6_EQ, -528 */
		/* 82191704h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821914F4;  }
		/* 82191704h case    2:*/		return 0x82191708;
		  /* 82191708h */ case    3:  		/* addi R28, R31, 8 */
		/* 82191708h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x8);
		/* 82191708h case    3:*/		return 0x8219170C;
		  /* 8219170Ch */ case    4:  		/* b -536 */
		/* 8219170Ch case    4:*/		return 0x821914F4;
		/* 8219170Ch case    4:*/		return 0x82191710;
	}
	return 0x82191710;
} // Block from 821916FCh-82191710h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82191710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191710);
		  /* 82191710h */ case    0:  		/* lwz R11, <#[R24 + 40]> */
		/* 82191710h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000028) );
		/* 82191710h case    0:*/		return 0x82191714;
		  /* 82191714h */ case    1:  		/* rlwinm. R11, R11, 0, 12, 12 */
		/* 82191714h case    1:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R11,regs.R11);
		/* 82191714h case    1:*/		return 0x82191718;
		  /* 82191718h */ case    2:  		/* bc 4, CR0_EQ, 12 */
		/* 82191718h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82191724;  }
		/* 82191718h case    2:*/		return 0x8219171C;
		  /* 8219171Ch */ case    3:  		/* mr R3, R30 */
		/* 8219171Ch case    3:*/		regs.R3 = regs.R30;
		/* 8219171Ch case    3:*/		return 0x82191720;
		  /* 82191720h */ case    4:  		/* bl -7320 */
		/* 82191720h case    4:*/		regs.LR = 0x82191724; return 0x8218FA88;
		/* 82191720h case    4:*/		return 0x82191724;
	}
	return 0x82191724;
} // Block from 82191710h-82191724h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82191724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191724);
		  /* 82191724h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 82191724h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82191724h case    0:*/		return 0x82191728;
		  /* 82191728h */ case    1:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 82191728h case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 82191728h case    1:*/		return 0x8219172C;
		  /* 8219172Ch */ case    2:  		/* cmplwi CR6, R10, 14080 */
		/* 8219172Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003700);
		/* 8219172Ch case    2:*/		return 0x82191730;
		  /* 82191730h */ case    3:  		/* bc 4, CR6_EQ, 20 */
		/* 82191730h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82191744;  }
		/* 82191730h case    3:*/		return 0x82191734;
		  /* 82191734h */ case    4:  		/* mr R4, R30 */
		/* 82191734h case    4:*/		regs.R4 = regs.R30;
		/* 82191734h case    4:*/		return 0x82191738;
		  /* 82191738h */ case    5:  		/* mr R3, R24 */
		/* 82191738h case    5:*/		regs.R3 = regs.R24;
		/* 82191738h case    5:*/		return 0x8219173C;
		  /* 8219173Ch */ case    6:  		/* bl 150700 */
		/* 8219173Ch case    6:*/		regs.LR = 0x82191740; return 0x821B63E8;
		/* 8219173Ch case    6:*/		return 0x82191740;
		  /* 82191740h */ case    7:  		/* b 20 */
		/* 82191740h case    7:*/		return 0x82191754;
		/* 82191740h case    7:*/		return 0x82191744;
	}
	return 0x82191744;
} // Block from 82191724h-82191744h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82191744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191744);
		  /* 82191744h */ case    0:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 82191744h case    0:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82191744h case    0:*/		return 0x82191748;
		  /* 82191748h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 82191748h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82191754;  }
		/* 82191748h case    1:*/		return 0x8219174C;
		  /* 8219174Ch */ case    2:  		/* mr R3, R30 */
		/* 8219174Ch case    2:*/		regs.R3 = regs.R30;
		/* 8219174Ch case    2:*/		return 0x82191750;
		  /* 82191750h */ case    3:  		/* bl -103384 */
		/* 82191750h case    3:*/		regs.LR = 0x82191754; return 0x82178378;
		/* 82191750h case    3:*/		return 0x82191754;
	}
	return 0x82191754;
} // Block from 82191744h-82191754h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82191754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191754);
		  /* 82191754h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 82191754h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82191754h case    0:*/		return 0x82191758;
		  /* 82191758h */ case    1:  		/* oris R11, R11, 256 */
		/* 82191758h case    1:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82191758h case    1:*/		return 0x8219175C;
		  /* 8219175Ch */ case    2:  		/* stw R11, <#[R30 + 8]> */
		/* 8219175Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219175Ch case    2:*/		return 0x82191760;
		  /* 82191760h */ case    3:  		/* lwz R10, <#[R26 + 8]> */
		/* 82191760h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000008) );
		/* 82191760h case    3:*/		return 0x82191764;
		  /* 82191764h */ case    4:  		/* rlwinm. R10, R10, 9, 31, 31 */
		/* 82191764h case    4:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R10,regs.R10);
		/* 82191764h case    4:*/		return 0x82191768;
	}
	return 0x82191768;
} // Block from 82191754h-82191768h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82191768h
// Function '?ComputeNumInstrsIfSmashedToScalars_PermitSideEffects@Instruction@D3DXShader@@QAAIXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191768);
		  /* 82191768h */ case    0:  		/* bc 12, CR0_EQ, 124 */
		/* 82191768h case    0:*/		if ( regs.CR[0].eq ) { return 0x821917E4;  }
		/* 82191768h case    0:*/		return 0x8219176C;
		  /* 8219176Ch */ case    1:  		/* lwz R10, <#[R24 + 44]> */
		/* 8219176Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000002C) );
		/* 8219176Ch case    1:*/		return 0x82191770;
		  /* 82191770h */ case    2:  		/* mr R3, R24 */
		/* 82191770h case    2:*/		regs.R3 = regs.R24;
		/* 82191770h case    2:*/		return 0x82191774;
		  /* 82191774h */ case    3:  		/* rlwinm. R10, R10, 25, 31, 31 */
		/* 82191774h case    3:*/		cpu::op::rlwinm<1,25,31,31>(regs,&regs.R10,regs.R10);
		/* 82191774h case    3:*/		return 0x82191778;
		  /* 82191778h */ case    4:  		/* bc 12, CR0_EQ, 100 */
		/* 82191778h case    4:*/		if ( regs.CR[0].eq ) { return 0x821917DC;  }
		/* 82191778h case    4:*/		return 0x8219177C;
		  /* 8219177Ch */ case    5:  		/* lwz R10, <#[R30 + 16]> */
		/* 8219177Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 8219177Ch case    5:*/		return 0x82191780;
		  /* 82191780h */ case    6:  		/* oris R11, R11, 128 */
		/* 82191780h case    6:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x80);
		/* 82191780h case    6:*/		return 0x82191784;
		  /* 82191784h */ case    7:  		/* mr R4, R26 */
		/* 82191784h case    7:*/		regs.R4 = regs.R26;
		/* 82191784h case    7:*/		return 0x82191788;
		  /* 82191788h */ case    8:  		/* rlwimi R10, R25, 16, 13, 15 */
		/* 82191788h case    8:*/		cpu::op::rlwimi<0,16,13,15>(regs,&regs.R10,regs.R25);
		/* 82191788h case    8:*/		return 0x8219178C;
		  /* 8219178Ch */ case    9:  		/* stw R11, <#[R30 + 8]> */
		/* 8219178Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219178Ch case    9:*/		return 0x82191790;
		  /* 82191790h */ case   10:  		/* stw R10, <#[R30 + 16]> */
		/* 82191790h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 82191790h case   10:*/		return 0x82191794;
		  /* 82191794h */ case   11:  		/* bl -55652 */
		/* 82191794h case   11:*/		regs.LR = 0x82191798; return 0x82183E30;
		/* 82191794h case   11:*/		return 0x82191798;
		  /* 82191798h */ case   12:  		/* sth R3, <#[R30 + 18]> */
		/* 82191798h case   12:*/		cpu::mem::store16( regs, regs.R3, (uint32)(regs.R30 + 0x00000012) );
		/* 82191798h case   12:*/		return 0x8219179C;
		  /* 8219179Ch */ case   13:  		/* lwz R11, <#[R24 + 668]> */
		/* 8219179Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000029C) );
		/* 8219179Ch case   13:*/		return 0x821917A0;
		  /* 821917A0h */ case   14:  		/* li R9, 0 */
		/* 821917A0h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821917A0h case   14:*/		return 0x821917A4;
		  /* 821917A4h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821917A4h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821917A4h case   15:*/		return 0x821917A8;
		  /* 821917A8h */ case   16:  		/* bc 4, CR6_GT, 60 */
		/* 821917A8h case   16:*/		if ( !regs.CR[6].gt ) { return 0x821917E4;  }
		/* 821917A8h case   16:*/		return 0x821917AC;
		  /* 821917ACh */ case   17:  		/* li R11, 0 */
		/* 821917ACh case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821917ACh case   17:*/		return 0x821917B0;
		  /* 821917B0h */ case   18:  		/* lwz R10, <#[R24 + 708]> */
		/* 821917B0h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x000002C4) );
		/* 821917B0h case   18:*/		return 0x821917B4;
		  /* 821917B4h */ case   19:  		/* lwzx R8, <#[R10 + R11]> */
		/* 821917B4h case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821917B4h case   19:*/		return 0x821917B8;
		  /* 821917B8h */ case   20:  		/* cmplw CR6, R8, R26 */
		/* 821917B8h case   20:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R26);
		/* 821917B8h case   20:*/		return 0x821917BC;
		  /* 821917BCh */ case   21:  		/* bc 4, CR6_EQ, 8 */
		/* 821917BCh case   21:*/		if ( !regs.CR[6].eq ) { return 0x821917C4;  }
		/* 821917BCh case   21:*/		return 0x821917C0;
		  /* 821917C0h */ case   22:  		/* stwx R30, <#[R10 + R11]> */
		/* 821917C0h case   22:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821917C0h case   22:*/		return 0x821917C4;
	}
	return 0x821917C4;
} // Block from 82191768h-821917C4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821917C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821917C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821917C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821917C4);
		  /* 821917C4h */ case    0:  		/* lwz R10, <#[R24 + 668]> */
		/* 821917C4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000029C) );
		/* 821917C4h case    0:*/		return 0x821917C8;
		  /* 821917C8h */ case    1:  		/* addi R9, R9, 1 */
		/* 821917C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 821917C8h case    1:*/		return 0x821917CC;
		  /* 821917CCh */ case    2:  		/* addi R11, R11, 4 */
		/* 821917CCh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821917CCh case    2:*/		return 0x821917D0;
		  /* 821917D0h */ case    3:  		/* cmplw CR6, R9, R10 */
		/* 821917D0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 821917D0h case    3:*/		return 0x821917D4;
		  /* 821917D4h */ case    4:  		/* bc 12, CR6_LT, -36 */
		/* 821917D4h case    4:*/		if ( regs.CR[6].lt ) { return 0x821917B0;  }
		/* 821917D4h case    4:*/		return 0x821917D8;
		  /* 821917D8h */ case    5:  		/* b 12 */
		/* 821917D8h case    5:*/		return 0x821917E4;
		/* 821917D8h case    5:*/		return 0x821917DC;
	}
	return 0x821917DC;
} // Block from 821917C4h-821917DCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821917DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821917DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821917DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821917DC);
		  /* 821917DCh */ case    0:  		/* mr R4, R30 */
		/* 821917DCh case    0:*/		regs.R4 = regs.R30;
		/* 821917DCh case    0:*/		return 0x821917E0;
		  /* 821917E0h */ case    1:  		/* bl 152168 */
		/* 821917E0h case    1:*/		regs.LR = 0x821917E4; return 0x821B6A48;
		/* 821917E0h case    1:*/		return 0x821917E4;
	}
	return 0x821917E4;
} // Block from 821917DCh-821917E4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821917E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821917E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821917E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821917E4);
		  /* 821917E4h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 821917E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821917E4h case    0:*/		return 0x821917E8;
		  /* 821917E8h */ case    1:  		/* rlwinm. R11, R11, 7, 31, 31 */
		/* 821917E8h case    1:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R11);
		/* 821917E8h case    1:*/		return 0x821917EC;
		  /* 821917ECh */ case    2:  		/* bc 12, CR0_EQ, 136 */
		/* 821917ECh case    2:*/		if ( regs.CR[0].eq ) { return 0x82191874;  }
		/* 821917ECh case    2:*/		return 0x821917F0;
		  /* 821917F0h */ case    3:  		/* lwz R31, <#[R26]> */
		/* 821917F0h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R26 + 0x00000000) );
		/* 821917F0h case    3:*/		return 0x821917F4;
		  /* 821917F4h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 821917F4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821917F4h case    4:*/		return 0x821917F8;
		  /* 821917F8h */ case    5:  		/* bc 12, CR6_EQ, 60 */
		/* 821917F8h case    5:*/		if ( regs.CR[6].eq ) { return 0x82191834;  }
		/* 821917F8h case    5:*/		return 0x821917FC;
		  /* 821917FCh */ case    6:  		/* lwz R11, <#[R31]> */
		/* 821917FCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821917FCh case    6:*/		return 0x82191800;
		  /* 82191800h */ case    7:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 82191800h case    7:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 82191800h case    7:*/		return 0x82191804;
		  /* 82191804h */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 82191804h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82191814;  }
		/* 82191804h case    8:*/		return 0x82191808;
		  /* 82191808h */ case    9:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82191808h case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82191808h case    9:*/		return 0x8219180C;
		  /* 8219180Ch */ case   10:  		/* mr R11, R25 */
		/* 8219180Ch case   10:*/		regs.R11 = regs.R25;
		/* 8219180Ch case   10:*/		return 0x82191810;
		  /* 82191810h */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 82191810h case   11:*/		if ( regs.CR[0].eq ) { return 0x82191818;  }
		/* 82191810h case   11:*/		return 0x82191814;
	}
	return 0x82191814;
} // Block from 821917E4h-82191814h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82191814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191814);
		  /* 82191814h */ case    0:  		/* li R11, 0 */
		/* 82191814h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82191814h case    0:*/		return 0x82191818;
	}
	return 0x82191818;
} // Block from 82191814h-82191818h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82191818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191818);
		  /* 82191818h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82191818h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82191818h case    0:*/		return 0x8219181C;
		  /* 8219181Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8219181Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8219182C;  }
		/* 8219181Ch case    1:*/		return 0x82191820;
		  /* 82191820h */ case    2:  		/* mr R4, R31 */
		/* 82191820h case    2:*/		regs.R4 = regs.R31;
		/* 82191820h case    2:*/		return 0x82191824;
		  /* 82191824h */ case    3:  		/* mr R3, R30 */
		/* 82191824h case    3:*/		regs.R3 = regs.R30;
		/* 82191824h case    3:*/		return 0x82191828;
		  /* 82191828h */ case    4:  		/* bl -104032 */
		/* 82191828h case    4:*/		regs.LR = 0x8219182C; return 0x821781C8;
		/* 82191828h case    4:*/		return 0x8219182C;
	}
	return 0x8219182C;
} // Block from 82191818h-8219182Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219182Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219182C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219182C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219182C);
		  /* 8219182Ch */ case    0:  		/* lwz R31, <#[R31 + 4]> */
		/* 8219182Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 8219182Ch case    0:*/		return 0x82191830;
		  /* 82191830h */ case    1:  		/* b -60 */
		/* 82191830h case    1:*/		return 0x821917F4;
		/* 82191830h case    1:*/		return 0x82191834;
	}
	return 0x82191834;
} // Block from 8219182Ch-82191834h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82191834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191834);
		  /* 82191834h */ case    0:  		/* lwz R10, <#[R26 + 8]> */
		/* 82191834h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000008) );
		/* 82191834h case    0:*/		return 0x82191838;
		  /* 82191838h */ case    1:  		/* li R11, 4 */
		/* 82191838h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 82191838h case    1:*/		return 0x8219183C;
		  /* 8219183Ch */ case    2:  		/* rlwinm R10, R10, 0, 7, 5 */
		/* 8219183Ch case    2:*/		cpu::op::rlwinm<0,0,7,5>(regs,&regs.R10,regs.R10);
		/* 8219183Ch case    2:*/		return 0x82191840;
		  /* 82191840h */ case    3:  		/* stw R10, <#[R26 + 8]> */
		/* 82191840h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R26 + 0x00000008) );
		/* 82191840h case    3:*/		return 0x82191844;
		  /* 82191844h */ case    4:  		/* mtspr CTR, R11 */
		/* 82191844h case    4:*/		regs.CTR = regs.R11;
		/* 82191844h case    4:*/		return 0x82191848;
		  /* 82191848h */ case    5:  		/* lwz R10, <#[R30 + 8]> */
		/* 82191848h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82191848h case    5:*/		return 0x8219184C;
		  /* 8219184Ch */ case    6:  		/* oris R10, R10, 512 */
		/* 8219184Ch case    6:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x200);
		/* 8219184Ch case    6:*/		return 0x82191850;
		  /* 82191850h */ case    7:  		/* stw R10, <#[R30 + 8]> */
		/* 82191850h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82191850h case    7:*/		return 0x82191854;
		  /* 82191854h */ case    8:  		/* lwz R11, <#[R26 + 28]> */
		/* 82191854h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000001C) );
		/* 82191854h case    8:*/		return 0x82191858;
		  /* 82191858h */ case    9:  		/* addi R11, R11, 92 */
		/* 82191858h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x5C);
		/* 82191858h case    9:*/		return 0x8219185C;
		  /* 8219185Ch */ case   10:  		/* lwz R10, <#[R11]> */
		/* 8219185Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8219185Ch case   10:*/		return 0x82191860;
		  /* 82191860h */ case   11:  		/* cmplw CR6, R10, R26 */
		/* 82191860h case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R26);
		/* 82191860h case   11:*/		return 0x82191864;
		  /* 82191864h */ case   12:  		/* bc 4, CR6_EQ, 8 */
		/* 82191864h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8219186C;  }
		/* 82191864h case   12:*/		return 0x82191868;
		  /* 82191868h */ case   13:  		/* stw R30, <#[R11]> */
		/* 82191868h case   13:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82191868h case   13:*/		return 0x8219186C;
	}
	return 0x8219186C;
} // Block from 82191834h-8219186Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8219186Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219186C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219186C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219186C);
		  /* 8219186Ch */ case    0:  		/* addi R11, R11, 4 */
		/* 8219186Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8219186Ch case    0:*/		return 0x82191870;
		  /* 82191870h */ case    1:  		/* bc 16, CR0_LT, -20 */
		/* 82191870h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8219185C;  }
		/* 82191870h case    1:*/		return 0x82191874;
	}
	return 0x82191874;
} // Block from 8219186Ch-82191874h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82191874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191874);
		  /* 82191874h */ case    0:  		/* mr R3, R30 */
		/* 82191874h case    0:*/		regs.R3 = regs.R30;
		/* 82191874h case    0:*/		return 0x82191878;
		  /* 82191878h */ case    1:  		/* bl -184056 */
		/* 82191878h case    1:*/		regs.LR = 0x8219187C; return 0x82164980;
		/* 82191878h case    1:*/		return 0x8219187C;
		  /* 8219187Ch */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219187Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219187Ch case    2:*/		return 0x82191880;
		  /* 82191880h */ case    3:  		/* bc 12, CR0_EQ, 88 */
		/* 82191880h case    3:*/		if ( regs.CR[0].eq ) { return 0x821918D8;  }
		/* 82191880h case    3:*/		return 0x82191884;
		  /* 82191884h */ case    4:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82191884h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82191884h case    4:*/		return 0x82191888;
		  /* 82191888h */ case    5:  		/* lwz R11, <#[R11 + 36]> */
		/* 82191888h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82191888h case    5:*/		return 0x8219188C;
		  /* 8219188Ch */ case    6:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219188Ch case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219188Ch case    6:*/		return 0x82191890;
		  /* 82191890h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 82191890h case    7:*/		if ( regs.CR[0].eq ) { return 0x8219189C;  }
		/* 82191890h case    7:*/		return 0x82191894;
		  /* 82191894h */ case    8:  		/* li R31, 0 */
		/* 82191894h case    8:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82191894h case    8:*/		return 0x82191898;
		  /* 82191898h */ case    9:  		/* b 12 */
		/* 82191898h case    9:*/		return 0x821918A4;
		/* 82191898h case    9:*/		return 0x8219189C;
	}
	return 0x8219189C;
} // Block from 82191874h-8219189Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219189Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219189C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219189C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219189C);
		  /* 8219189Ch */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8219189Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8219189Ch case    0:*/		return 0x821918A0;
		  /* 821918A0h */ case    1:  		/* addi R31, R11, -40 */
		/* 821918A0h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 821918A0h case    1:*/		return 0x821918A4;
	}
	return 0x821918A4;
} // Block from 8219189Ch-821918A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821918A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821918A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821918A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821918A4);
		  /* 821918A4h */ case    0:  		/* mr R3, R30 */
		/* 821918A4h case    0:*/		regs.R3 = regs.R30;
		/* 821918A4h case    0:*/		return 0x821918A8;
		  /* 821918A8h */ case    1:  		/* bl -184104 */
		/* 821918A8h case    1:*/		regs.LR = 0x821918AC; return 0x82164980;
		/* 821918A8h case    1:*/		return 0x821918AC;
		  /* 821918ACh */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821918ACh case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821918ACh case    2:*/		return 0x821918B0;
		  /* 821918B0h */ case    3:  		/* bc 12, CR0_EQ, 24 */
		/* 821918B0h case    3:*/		if ( regs.CR[0].eq ) { return 0x821918C8;  }
		/* 821918B0h case    3:*/		return 0x821918B4;
		  /* 821918B4h */ case    4:  		/* li R6, 1 */
		/* 821918B4h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821918B4h case    4:*/		return 0x821918B8;
		  /* 821918B8h */ case    5:  		/* li R5, 0 */
		/* 821918B8h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821918B8h case    5:*/		return 0x821918BC;
		  /* 821918BCh */ case    6:  		/* mr R4, R30 */
		/* 821918BCh case    6:*/		regs.R4 = regs.R30;
		/* 821918BCh case    6:*/		return 0x821918C0;
		  /* 821918C0h */ case    7:  		/* mr R3, R24 */
		/* 821918C0h case    7:*/		regs.R3 = regs.R24;
		/* 821918C0h case    7:*/		return 0x821918C4;
		  /* 821918C4h */ case    8:  		/* bl 629508 */
		/* 821918C4h case    8:*/		regs.LR = 0x821918C8; return 0x8222B3C8;
		/* 821918C4h case    8:*/		return 0x821918C8;
	}
	return 0x821918C8;
} // Block from 821918A4h-821918C8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821918C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821918C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821918C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821918C8);
		  /* 821918C8h */ case    0:  		/* mr R30, R31 */
		/* 821918C8h case    0:*/		regs.R30 = regs.R31;
		/* 821918C8h case    0:*/		return 0x821918CC;
		  /* 821918CCh */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 821918CCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821918CCh case    1:*/		return 0x821918D0;
		  /* 821918D0h */ case    2:  		/* bc 4, CR6_EQ, -76 */
		/* 821918D0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82191884;  }
		/* 821918D0h case    2:*/		return 0x821918D4;
		  /* 821918D4h */ case    3:  		/* b 32 */
		/* 821918D4h case    3:*/		return 0x821918F4;
		/* 821918D4h case    3:*/		return 0x821918D8;
	}
	return 0x821918D8;
} // Block from 821918C8h-821918D8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821918D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821918D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821918D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821918D8);
		  /* 821918D8h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 821918D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821918D8h case    0:*/		return 0x821918DC;
		  /* 821918DCh */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821918DCh case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821918DCh case    1:*/		return 0x821918E0;
		  /* 821918E0h */ case    2:  		/* cmplwi CR6, R11, 14080 */
		/* 821918E0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 821918E0h case    2:*/		return 0x821918E4;
		  /* 821918E4h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 821918E4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821918F4;  }
		/* 821918E4h case    3:*/		return 0x821918E8;
		  /* 821918E8h */ case    4:  		/* mr R4, R30 */
		/* 821918E8h case    4:*/		regs.R4 = regs.R30;
		/* 821918E8h case    4:*/		return 0x821918EC;
		  /* 821918ECh */ case    5:  		/* mr R3, R24 */
		/* 821918ECh case    5:*/		regs.R3 = regs.R24;
		/* 821918ECh case    5:*/		return 0x821918F0;
		  /* 821918F0h */ case    6:  		/* bl -3320 */
		/* 821918F0h case    6:*/		regs.LR = 0x821918F4; return 0x82190BF8;
		/* 821918F0h case    6:*/		return 0x821918F4;
	}
	return 0x821918F4;
} // Block from 821918D8h-821918F4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821918F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821918F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821918F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821918F4);
		  /* 821918F4h */ case    0:  		/* addi R1, R1, 160 */
		/* 821918F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 821918F4h case    0:*/		return 0x821918F8;
		  /* 821918F8h */ case    1:  		/* b -1050208 */
		/* 821918F8h case    1:*/		return 0x82091298;
		/* 821918F8h case    1:*/		return 0x821918FC;
		  /* 821918FCh */ case    2:  		/* nop */
		/* 821918FCh case    2:*/		cpu::op::nop();
		/* 821918FCh case    2:*/		return 0x82191900;
	}
	return 0x82191900;
} // Block from 821918F4h-82191900h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82191900h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191900);
		  /* 82191900h */ case    0:  		/* mfspr R12, LR */
		/* 82191900h case    0:*/		regs.R12 = regs.LR;
		/* 82191900h case    0:*/		return 0x82191904;
		  /* 82191904h */ case    1:  		/* bl -1050288 */
		/* 82191904h case    1:*/		regs.LR = 0x82191908; return 0x82091254;
		/* 82191904h case    1:*/		return 0x82191908;
		  /* 82191908h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82191908h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82191908h case    2:*/		return 0x8219190C;
		  /* 8219190Ch */ case    3:  		/* mr R27, R3 */
		/* 8219190Ch case    3:*/		regs.R27 = regs.R3;
		/* 8219190Ch case    3:*/		return 0x82191910;
		  /* 82191910h */ case    4:  		/* mr R28, R4 */
		/* 82191910h case    4:*/		regs.R28 = regs.R4;
		/* 82191910h case    4:*/		return 0x82191914;
		  /* 82191914h */ case    5:  		/* b 128 */
		/* 82191914h case    5:*/		return 0x82191994;
		/* 82191914h case    5:*/		return 0x82191918;
		  /* 82191918h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82191918h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82191918h case    6:*/		return 0x8219191C;
		  /* 8219191Ch */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 8219191Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x82191928;  }
		/* 8219191Ch case    7:*/		return 0x82191920;
		  /* 82191920h */ case    8:  		/* li R29, 0 */
		/* 82191920h case    8:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82191920h case    8:*/		return 0x82191924;
		  /* 82191924h */ case    9:  		/* b 16 */
		/* 82191924h case    9:*/		return 0x82191934;
		/* 82191924h case    9:*/		return 0x82191928;
	}
	return 0x82191928;
} // Block from 82191900h-82191928h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82191928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191928);
		  /* 82191928h */ case    0:  		/* lwz R11, <#[R28]> */
		/* 82191928h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82191928h case    0:*/		return 0x8219192C;
		  /* 8219192Ch */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8219192Ch case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8219192Ch case    1:*/		return 0x82191930;
		  /* 82191930h */ case    2:  		/* addi R29, R11, -40 */
		/* 82191930h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFFFFD8);
		/* 82191930h case    2:*/		return 0x82191934;
	}
	return 0x82191934;
} // Block from 82191928h-82191934h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82191934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191934);
		  /* 82191934h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 82191934h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82191934h case    0:*/		return 0x82191938;
		  /* 82191938h */ case    1:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 82191938h case    1:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82191938h case    1:*/		return 0x8219193C;
		  /* 8219193Ch */ case    2:  		/* bc 12, CR0_EQ, 76 */
		/* 8219193Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x82191988;  }
		/* 8219193Ch case    2:*/		return 0x82191940;
		  /* 82191940h */ case    3:  		/* addi R30, R29, 4 */
		/* 82191940h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R29,0x4);
		/* 82191940h case    3:*/		return 0x82191944;
		  /* 82191944h */ case    4:  		/* lwz R31, <#[R30]> */
		/* 82191944h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 82191944h case    4:*/		return 0x82191948;
		  /* 82191948h */ case    5:  		/* cmplwi CR6, R31, 0 */
		/* 82191948h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82191948h case    5:*/		return 0x8219194C;
		  /* 8219194Ch */ case    6:  		/* bc 12, CR6_EQ, 60 */
		/* 8219194Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x82191988;  }
		/* 8219194Ch case    6:*/		return 0x82191950;
		  /* 82191950h */ case    7:  		/* lwz R3, <#[R31 + 16]> */
		/* 82191950h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82191950h case    7:*/		return 0x82191954;
		  /* 82191954h */ case    8:  		/* cmplwi CR6, R3, 0 */
		/* 82191954h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82191954h case    8:*/		return 0x82191958;
		  /* 82191958h */ case    9:  		/* bc 12, CR6_EQ, 28 */
		/* 82191958h case    9:*/		if ( regs.CR[6].eq ) { return 0x82191974;  }
		/* 82191958h case    9:*/		return 0x8219195C;
		  /* 8219195Ch */ case   10:  		/* lwz R11, <#[R31]> */
		/* 8219195Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219195Ch case   10:*/		return 0x82191960;
		  /* 82191960h */ case   11:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82191960h case   11:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82191960h case   11:*/		return 0x82191964;
		  /* 82191964h */ case   12:  		/* bc 12, CR0_EQ, 16 */
		/* 82191964h case   12:*/		if ( regs.CR[0].eq ) { return 0x82191974;  }
		/* 82191964h case   12:*/		return 0x82191968;
		  /* 82191968h */ case   13:  		/* mr R5, R27 */
		/* 82191968h case   13:*/		regs.R5 = regs.R27;
		/* 82191968h case   13:*/		return 0x8219196C;
		  /* 8219196Ch */ case   14:  		/* mr R4, R31 */
		/* 8219196Ch case   14:*/		regs.R4 = regs.R31;
		/* 8219196Ch case   14:*/		return 0x82191970;
		  /* 82191970h */ case   15:  		/* bl -102496 */
		/* 82191970h case   15:*/		regs.LR = 0x82191974; return 0x82178910;
		/* 82191970h case   15:*/		return 0x82191974;
	}
	return 0x82191974;
} // Block from 82191934h-82191974h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82191974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191974);
		  /* 82191974h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82191974h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82191974h case    0:*/		return 0x82191978;
		  /* 82191978h */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 82191978h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 82191978h case    1:*/		return 0x8219197C;
		  /* 8219197Ch */ case    2:  		/* bc 4, CR6_EQ, -56 */
		/* 8219197Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82191944;  }
		/* 8219197Ch case    2:*/		return 0x82191980;
		  /* 82191980h */ case    3:  		/* addi R30, R31, 8 */
		/* 82191980h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x8);
		/* 82191980h case    3:*/		return 0x82191984;
		  /* 82191984h */ case    4:  		/* b -64 */
		/* 82191984h case    4:*/		return 0x82191944;
		/* 82191984h case    4:*/		return 0x82191988;
	}
	return 0x82191988;
} // Block from 82191974h-82191988h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82191988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191988);
		  /* 82191988h */ case    0:  		/* mr R4, R29 */
		/* 82191988h case    0:*/		regs.R4 = regs.R29;
		/* 82191988h case    0:*/		return 0x8219198C;
		  /* 8219198Ch */ case    1:  		/* mr R3, R27 */
		/* 8219198Ch case    1:*/		regs.R3 = regs.R27;
		/* 8219198Ch case    1:*/		return 0x82191990;
		  /* 82191990h */ case    2:  		/* bl 629952 */
		/* 82191990h case    2:*/		regs.LR = 0x82191994; return 0x8222B650;
		/* 82191990h case    2:*/		return 0x82191994;
	}
	return 0x82191994;
} // Block from 82191988h-82191994h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82191994h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191994( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191994) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191994);
		  /* 82191994h */ case    0:  		/* lwz R11, <#[R28 + 4]> */
		/* 82191994h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82191994h case    0:*/		return 0x82191998;
		  /* 82191998h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82191998h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82191998h case    1:*/		return 0x8219199C;
		  /* 8219199Ch */ case    2:  		/* bc 12, CR0_EQ, -132 */
		/* 8219199Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x82191918;  }
		/* 8219199Ch case    2:*/		return 0x821919A0;
		  /* 821919A0h */ case    3:  		/* addi R1, R1, 128 */
		/* 821919A0h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821919A0h case    3:*/		return 0x821919A4;
		  /* 821919A4h */ case    4:  		/* b -1050368 */
		/* 821919A4h case    4:*/		return 0x820912A4;
		/* 821919A4h case    4:*/		return 0x821919A8;
		  /* 821919A8h */ case    5:  		/* lwz R11, <#[R4 + 4]> */
		/* 821919A8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821919A8h case    5:*/		return 0x821919AC;
		  /* 821919ACh */ case    6:  		/* addi R9, R4, 4 */
		/* 821919ACh case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R4,0x4);
		/* 821919ACh case    6:*/		return 0x821919B0;
		  /* 821919B0h */ case    7:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821919B0h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821919B0h case    7:*/		return 0x821919B4;
		  /* 821919B4h */ case    8:  		/* bclr 4, CR0_EQ */
		/* 821919B4h case    8:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 821919B4h case    8:*/		return 0x821919B8;
	}
	return 0x821919B8;
} // Block from 82191994h-821919B8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821919B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821919B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821919B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821919B8);
		  /* 821919B8h */ case    0:  		/* lwz R10, <#[R4]> */
		/* 821919B8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 821919B8h case    0:*/		return 0x821919BC;
		  /* 821919BCh */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821919BCh case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821919BCh case    1:*/		return 0x821919C0;
		  /* 821919C0h */ case    2:  		/* addi R8, R3, 4 */
		/* 821919C0h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R3,0x4);
		/* 821919C0h case    2:*/		return 0x821919C4;
		  /* 821919C4h */ case    3:  		/* lwz R7, <#[R3 + 4]> */
		/* 821919C4h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000004) );
		/* 821919C4h case    3:*/		return 0x821919C8;
		  /* 821919C8h */ case    4:  		/* addi R11, R11, 36 */
		/* 821919C8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821919C8h case    4:*/		return 0x821919CC;
		  /* 821919CCh */ case    5:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821919CCh case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821919CCh case    5:*/		return 0x821919D0;
		  /* 821919D0h */ case    6:  		/* ori R8, R8, 1 */
		/* 821919D0h case    6:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821919D0h case    6:*/		return 0x821919D4;
		  /* 821919D4h */ case    7:  		/* addi R10, R10, -4 */
		/* 821919D4h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 821919D4h case    7:*/		return 0x821919D8;
		  /* 821919D8h */ case    8:  		/* addi R5, R11, -36 */
		/* 821919D8h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFDC);
		/* 821919D8h case    8:*/		return 0x821919DC;
		  /* 821919DCh */ case    9:  		/* stw R8, <#[R11]> */
		/* 821919DCh case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 821919DCh case    9:*/		return 0x821919E0;
		  /* 821919E0h */ case   10:  		/* rlwinm R6, R7, 0, 0, 30 */
		/* 821919E0h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R7);
		/* 821919E0h case   10:*/		return 0x821919E4;
		  /* 821919E4h */ case   11:  		/* addi R8, R4, -36 */
		/* 821919E4h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R4,0xFFFFFFDC);
		/* 821919E4h case   11:*/		return 0x821919E8;
		  /* 821919E8h */ case   12:  		/* stw R5, <#[R3 + 4]> */
		/* 821919E8h case   12:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000004) );
		/* 821919E8h case   12:*/		return 0x821919EC;
		  /* 821919ECh */ case   13:  		/* addi R11, R10, 4 */
		/* 821919ECh case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x4);
		/* 821919ECh case   13:*/		return 0x821919F0;
		  /* 821919F0h */ case   14:  		/* stw R7, <#[R10 + 4]> */
		/* 821919F0h case   14:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 821919F0h case   14:*/		return 0x821919F4;
		  /* 821919F4h */ case   15:  		/* ori R8, R8, 1 */
		/* 821919F4h case   15:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821919F4h case   15:*/		return 0x821919F8;
		  /* 821919F8h */ case   16:  		/* ori R10, R9, 1 */
		/* 821919F8h case   16:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R9,0x1);
		/* 821919F8h case   16:*/		return 0x821919FC;
		  /* 821919FCh */ case   17:  		/* stw R11, <#[R6 + 36]> */
		/* 821919FCh case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000024) );
		/* 821919FCh case   17:*/		return 0x82191A00;
		  /* 82191A00h */ case   18:  		/* stw R8, <#[R9]> */
		/* 82191A00h case   18:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 82191A00h case   18:*/		return 0x82191A04;
		  /* 82191A04h */ case   19:  		/* stw R10, <#[R4]> */
		/* 82191A04h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 82191A04h case   19:*/		return 0x82191A08;
		  /* 82191A08h */ case   20:  		/* bclr 20, CR0_LT */
		/* 82191A08h case   20:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82191A08h case   20:*/		return 0x82191A0C;
	}
	return 0x82191A0C;
} // Block from 821919B8h-82191A0Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 82191A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191A0C);
		  /* 82191A0Ch */ case    0:  		/* nop */
		/* 82191A0Ch case    0:*/		cpu::op::nop();
		/* 82191A0Ch case    0:*/		return 0x82191A10;
	}
	return 0x82191A10;
} // Block from 82191A0Ch-82191A10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82191A10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191A10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191A10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191A10);
		  /* 82191A10h */ case    0:  		/* mfspr R12, LR */
		/* 82191A10h case    0:*/		regs.R12 = regs.LR;
		/* 82191A10h case    0:*/		return 0x82191A14;
		  /* 82191A14h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82191A14h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82191A14h case    1:*/		return 0x82191A18;
		  /* 82191A18h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82191A18h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82191A18h case    2:*/		return 0x82191A1C;
		  /* 82191A1Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82191A1Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82191A1Ch case    3:*/		return 0x82191A20;
		  /* 82191A20h */ case    4:  		/* mr R31, R3 */
		/* 82191A20h case    4:*/		regs.R31 = regs.R3;
		/* 82191A20h case    4:*/		return 0x82191A24;
		  /* 82191A24h */ case    5:  		/* bl -131708 */
		/* 82191A24h case    5:*/		regs.LR = 0x82191A28; return 0x821717A8;
		/* 82191A24h case    5:*/		return 0x82191A28;
		  /* 82191A28h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82191A28h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82191A28h case    6:*/		return 0x82191A2C;
		  /* 82191A2Ch */ case    7:  		/* bc 4, CR0_EQ, 56 */
		/* 82191A2Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x82191A64;  }
		/* 82191A2Ch case    7:*/		return 0x82191A30;
		  /* 82191A30h */ case    8:  		/* lwz R11, <#[R31 + 8]> */
		/* 82191A30h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82191A30h case    8:*/		return 0x82191A34;
		  /* 82191A34h */ case    9:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 82191A34h case    9:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 82191A34h case    9:*/		return 0x82191A38;
		  /* 82191A38h */ case   10:  		/* cmplwi CR6, R10, 83 */
		/* 82191A38h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000053);
		/* 82191A38h case   10:*/		return 0x82191A3C;
		  /* 82191A3Ch */ case   11:  		/* bc 12, CR6_LT, 16 */
		/* 82191A3Ch case   11:*/		if ( regs.CR[6].lt ) { return 0x82191A4C;  }
		/* 82191A3Ch case   11:*/		return 0x82191A40;
		  /* 82191A40h */ case   12:  		/* cmplwi CR6, R10, 95 */
		/* 82191A40h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005F);
		/* 82191A40h case   12:*/		return 0x82191A44;
		  /* 82191A44h */ case   13:  		/* li R11, 1 */
		/* 82191A44h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82191A44h case   13:*/		return 0x82191A48;
		  /* 82191A48h */ case   14:  		/* bc 4, CR6_GT, 8 */
		/* 82191A48h case   14:*/		if ( !regs.CR[6].gt ) { return 0x82191A50;  }
		/* 82191A48h case   14:*/		return 0x82191A4C;
	}
	return 0x82191A4C;
} // Block from 82191A10h-82191A4Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 82191A4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191A4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191A4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191A4C);
		  /* 82191A4Ch */ case    0:  		/* li R11, 0 */
		/* 82191A4Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82191A4Ch case    0:*/		return 0x82191A50;
	}
	return 0x82191A50;
} // Block from 82191A4Ch-82191A50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82191A50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191A50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191A50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191A50);
		  /* 82191A50h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82191A50h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82191A50h case    0:*/		return 0x82191A54;
		  /* 82191A54h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 82191A54h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82191A64;  }
		/* 82191A54h case    1:*/		return 0x82191A58;
		  /* 82191A58h */ case    2:  		/* cmplwi CR6, R10, 117 */
		/* 82191A58h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000075);
		/* 82191A58h case    2:*/		return 0x82191A5C;
		  /* 82191A5Ch */ case    3:  		/* li R11, 0 */
		/* 82191A5Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82191A5Ch case    3:*/		return 0x82191A60;
		  /* 82191A60h */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 82191A60h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82191A68;  }
		/* 82191A60h case    4:*/		return 0x82191A64;
	}
	return 0x82191A64;
} // Block from 82191A50h-82191A64h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82191A64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191A64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191A64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191A64);
		  /* 82191A64h */ case    0:  		/* li R11, 1 */
		/* 82191A64h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82191A64h case    0:*/		return 0x82191A68;
	}
	return 0x82191A68;
} // Block from 82191A64h-82191A68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82191A68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191A68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191A68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191A68);
		  /* 82191A68h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 82191A68h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 82191A68h case    0:*/		return 0x82191A6C;
		  /* 82191A6Ch */ case    1:  		/* addi R1, R1, 96 */
		/* 82191A6Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82191A6Ch case    1:*/		return 0x82191A70;
		  /* 82191A70h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82191A70h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82191A70h case    2:*/		return 0x82191A74;
		  /* 82191A74h */ case    3:  		/* mtspr LR, R12 */
		/* 82191A74h case    3:*/		regs.LR = regs.R12;
		/* 82191A74h case    3:*/		return 0x82191A78;
		  /* 82191A78h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82191A78h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82191A78h case    4:*/		return 0x82191A7C;
		  /* 82191A7Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 82191A7Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82191A7Ch case    5:*/		return 0x82191A80;
	}
	return 0x82191A80;
} // Block from 82191A68h-82191A80h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82191A80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191A80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191A80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191A80);
		  /* 82191A80h */ case    0:  		/* mfspr R12, LR */
		/* 82191A80h case    0:*/		regs.R12 = regs.LR;
		/* 82191A80h case    0:*/		return 0x82191A84;
		  /* 82191A84h */ case    1:  		/* bl -1050672 */
		/* 82191A84h case    1:*/		regs.LR = 0x82191A88; return 0x82091254;
		/* 82191A84h case    1:*/		return 0x82191A88;
		  /* 82191A88h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82191A88h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82191A88h case    2:*/		return 0x82191A8C;
		  /* 82191A8Ch */ case    3:  		/* mr R30, R5 */
		/* 82191A8Ch case    3:*/		regs.R30 = regs.R5;
		/* 82191A8Ch case    3:*/		return 0x82191A90;
		  /* 82191A90h */ case    4:  		/* mr R31, R6 */
		/* 82191A90h case    4:*/		regs.R31 = regs.R6;
		/* 82191A90h case    4:*/		return 0x82191A94;
		  /* 82191A94h */ case    5:  		/* mr R27, R7 */
		/* 82191A94h case    5:*/		regs.R27 = regs.R7;
		/* 82191A94h case    5:*/		return 0x82191A98;
		  /* 82191A98h */ case    6:  		/* li R8, 4 */
		/* 82191A98h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 82191A98h case    6:*/		return 0x82191A9C;
		  /* 82191A9Ch */ case    7:  		/* li R7, 2 */
		/* 82191A9Ch case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 82191A9Ch case    7:*/		return 0x82191AA0;
		  /* 82191AA0h */ case    8:  		/* li R6, 30 */
		/* 82191AA0h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x1E);
		/* 82191AA0h case    8:*/		return 0x82191AA4;
		  /* 82191AA4h */ case    9:  		/* li R5, 0 */
		/* 82191AA4h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82191AA4h case    9:*/		return 0x82191AA8;
		  /* 82191AA8h */ case   10:  		/* mr R28, R3 */
		/* 82191AA8h case   10:*/		regs.R28 = regs.R3;
		/* 82191AA8h case   10:*/		return 0x82191AAC;
		  /* 82191AACh */ case   11:  		/* bl 601836 */
		/* 82191AACh case   11:*/		regs.LR = 0x82191AB0; return 0x82224998;
		/* 82191AACh case   11:*/		return 0x82191AB0;
		  /* 82191AB0h */ case   12:  		/* lwz R11, <#[R31 + 16]> */
		/* 82191AB0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82191AB0h case   12:*/		return 0x82191AB4;
		  /* 82191AB4h */ case   13:  		/* mr R29, R3 */
		/* 82191AB4h case   13:*/		regs.R29 = regs.R3;
		/* 82191AB4h case   13:*/		return 0x82191AB8;
		  /* 82191AB8h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 82191AB8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82191AB8h case   14:*/		return 0x82191ABC;
		  /* 82191ABCh */ case   15:  		/* mr R4, R31 */
		/* 82191ABCh case   15:*/		regs.R4 = regs.R31;
		/* 82191ABCh case   15:*/		return 0x82191AC0;
		  /* 82191AC0h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 82191AC0h case   16:*/		if ( regs.CR[6].eq ) { return 0x82191AD4;  }
		/* 82191AC0h case   16:*/		return 0x82191AC4;
		  /* 82191AC4h */ case   17:  		/* mr R3, R28 */
		/* 82191AC4h case   17:*/		regs.R3 = regs.R28;
		/* 82191AC4h case   17:*/		return 0x82191AC8;
		  /* 82191AC8h */ case   18:  		/* lwz R5, <#[R31 + 12]> */
		/* 82191AC8h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 82191AC8h case   18:*/		return 0x82191ACC;
		  /* 82191ACCh */ case   19:  		/* bl -133596 */
		/* 82191ACCh case   19:*/		regs.LR = 0x82191AD0; return 0x821710F0;
		/* 82191ACCh case   19:*/		return 0x82191AD0;
		  /* 82191AD0h */ case   20:  		/* mr R4, R3 */
		/* 82191AD0h case   20:*/		regs.R4 = regs.R3;
		/* 82191AD0h case   20:*/		return 0x82191AD4;
	}
	return 0x82191AD4;
} // Block from 82191A80h-82191AD4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82191AD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191AD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191AD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191AD4);
		  /* 82191AD4h */ case    0:  		/* mr R3, R29 */
		/* 82191AD4h case    0:*/		regs.R3 = regs.R29;
		/* 82191AD4h case    0:*/		return 0x82191AD8;
		  /* 82191AD8h */ case    1:  		/* bl -104720 */
		/* 82191AD8h case    1:*/		regs.LR = 0x82191ADC; return 0x821781C8;
		/* 82191AD8h case    1:*/		return 0x82191ADC;
		  /* 82191ADCh */ case    2:  		/* stw R3, <#[R29 + 44]> */
		/* 82191ADCh case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 82191ADCh case    2:*/		return 0x82191AE0;
		  /* 82191AE0h */ case    3:  		/* lwz R11, <#[R27 + 16]> */
		/* 82191AE0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 82191AE0h case    3:*/		return 0x82191AE4;
		  /* 82191AE4h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82191AE4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82191AE4h case    4:*/		return 0x82191AE8;
		  /* 82191AE8h */ case    5:  		/* mr R4, R27 */
		/* 82191AE8h case    5:*/		regs.R4 = regs.R27;
		/* 82191AE8h case    5:*/		return 0x82191AEC;
		  /* 82191AECh */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 82191AECh case    6:*/		if ( regs.CR[6].eq ) { return 0x82191B00;  }
		/* 82191AECh case    6:*/		return 0x82191AF0;
		  /* 82191AF0h */ case    7:  		/* mr R3, R28 */
		/* 82191AF0h case    7:*/		regs.R3 = regs.R28;
		/* 82191AF0h case    7:*/		return 0x82191AF4;
		  /* 82191AF4h */ case    8:  		/* lwz R5, <#[R27 + 12]> */
		/* 82191AF4h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + 0x0000000C) );
		/* 82191AF4h case    8:*/		return 0x82191AF8;
		  /* 82191AF8h */ case    9:  		/* bl -133640 */
		/* 82191AF8h case    9:*/		regs.LR = 0x82191AFC; return 0x821710F0;
		/* 82191AF8h case    9:*/		return 0x82191AFC;
		  /* 82191AFCh */ case   10:  		/* mr R4, R3 */
		/* 82191AFCh case   10:*/		regs.R4 = regs.R3;
		/* 82191AFCh case   10:*/		return 0x82191B00;
	}
	return 0x82191B00;
} // Block from 82191AD4h-82191B00h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82191B00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191B00);
		  /* 82191B00h */ case    0:  		/* mr R3, R29 */
		/* 82191B00h case    0:*/		regs.R3 = regs.R29;
		/* 82191B00h case    0:*/		return 0x82191B04;
		  /* 82191B04h */ case    1:  		/* bl -104764 */
		/* 82191B04h case    1:*/		regs.LR = 0x82191B08; return 0x821781C8;
		/* 82191B04h case    1:*/		return 0x82191B08;
		  /* 82191B08h */ case    2:  		/* stw R3, <#[R29 + 48]> */
		/* 82191B08h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000030) );
		/* 82191B08h case    2:*/		return 0x82191B0C;
		  /* 82191B0Ch */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 82191B0Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82191B0Ch case    3:*/		return 0x82191B10;
		  /* 82191B10h */ case    4:  		/* bc 12, CR6_EQ, 56 */
		/* 82191B10h case    4:*/		if ( regs.CR[6].eq ) { return 0x82191B48;  }
		/* 82191B10h case    4:*/		return 0x82191B14;
		  /* 82191B14h */ case    5:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 82191B14h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 82191B14h case    5:*/		return 0x82191B18;
		  /* 82191B18h */ case    6:  		/* lwz R9, <#[R30]> */
		/* 82191B18h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 82191B18h case    6:*/		return 0x82191B1C;
		  /* 82191B1Ch */ case    7:  		/* addi R10, R30, -36 */
		/* 82191B1Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0xFFFFFFDC);
		/* 82191B1Ch case    7:*/		return 0x82191B20;
		  /* 82191B20h */ case    8:  		/* addi R11, R11, 36 */
		/* 82191B20h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82191B20h case    8:*/		return 0x82191B24;
		  /* 82191B24h */ case    9:  		/* ori R8, R10, 1 */
		/* 82191B24h case    9:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 82191B24h case    9:*/		return 0x82191B28;
		  /* 82191B28h */ case   10:  		/* addi R7, R11, -36 */
		/* 82191B28h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 82191B28h case   10:*/		return 0x82191B2C;
		  /* 82191B2Ch */ case   11:  		/* addi R10, R11, 4 */
		/* 82191B2Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82191B2Ch case   11:*/		return 0x82191B30;
		  /* 82191B30h */ case   12:  		/* stw R9, <#[R11]> */
		/* 82191B30h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82191B30h case   12:*/		return 0x82191B34;
		  /* 82191B34h */ case   13:  		/* lwz R9, <#[R30]> */
		/* 82191B34h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 82191B34h case   13:*/		return 0x82191B38;
		  /* 82191B38h */ case   14:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82191B38h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82191B38h case   14:*/		return 0x82191B3C;
		  /* 82191B3Ch */ case   15:  		/* stw R7, <#[R9]> */
		/* 82191B3Ch case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 82191B3Ch case   15:*/		return 0x82191B40;
		  /* 82191B40h */ case   16:  		/* stw R8, <#[R11 + 4]> */
		/* 82191B40h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82191B40h case   16:*/		return 0x82191B44;
		  /* 82191B44h */ case   17:  		/* stw R10, <#[R30]> */
		/* 82191B44h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82191B44h case   17:*/		return 0x82191B48;
	}
	return 0x82191B48;
} // Block from 82191B00h-82191B48h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82191B48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191B48);
		  /* 82191B48h */ case    0:  		/* mr R3, R29 */
		/* 82191B48h case    0:*/		regs.R3 = regs.R29;
		/* 82191B48h case    0:*/		return 0x82191B4C;
		  /* 82191B4Ch */ case    1:  		/* addi R1, R1, 128 */
		/* 82191B4Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82191B4Ch case    1:*/		return 0x82191B50;
		  /* 82191B50h */ case    2:  		/* b -1050796 */
		/* 82191B50h case    2:*/		return 0x820912A4;
		/* 82191B50h case    2:*/		return 0x82191B54;
		  /* 82191B54h */ case    3:  		/* nop */
		/* 82191B54h case    3:*/		cpu::op::nop();
		/* 82191B54h case    3:*/		return 0x82191B58;
	}
	return 0x82191B58;
} // Block from 82191B48h-82191B58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82191B58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191B58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191B58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191B58);
		  /* 82191B58h */ case    0:  		/* mfspr R12, LR */
		/* 82191B58h case    0:*/		regs.R12 = regs.LR;
		/* 82191B58h case    0:*/		return 0x82191B5C;
		  /* 82191B5Ch */ case    1:  		/* bl -1050884 */
		/* 82191B5Ch case    1:*/		regs.LR = 0x82191B60; return 0x82091258;
		/* 82191B5Ch case    1:*/		return 0x82191B60;
		  /* 82191B60h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82191B60h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82191B60h case    2:*/		return 0x82191B64;
		  /* 82191B64h */ case    3:  		/* mr R31, R5 */
		/* 82191B64h case    3:*/		regs.R31 = regs.R5;
		/* 82191B64h case    3:*/		return 0x82191B68;
		  /* 82191B68h */ case    4:  		/* mr R30, R6 */
		/* 82191B68h case    4:*/		regs.R30 = regs.R6;
		/* 82191B68h case    4:*/		return 0x82191B6C;
		  /* 82191B6Ch */ case    5:  		/* li R8, 1 */
		/* 82191B6Ch case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82191B6Ch case    5:*/		return 0x82191B70;
	}
	return 0x82191B70;
} // Block from 82191B58h-82191B70h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82191B70h
// Function '?PrepareSmashedInstruction@Compiler@D3DXShader@@AAAXPAVInstruction@2@00II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191B70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191B70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191B70);
		  /* 82191B70h */ case    0:  		/* li R7, 1 */
		/* 82191B70h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82191B70h case    0:*/		return 0x82191B74;
		  /* 82191B74h */ case    1:  		/* li R6, 37 */
		/* 82191B74h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x25);
		/* 82191B74h case    1:*/		return 0x82191B78;
		  /* 82191B78h */ case    2:  		/* li R5, 0 */
		/* 82191B78h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82191B78h case    2:*/		return 0x82191B7C;
		  /* 82191B7Ch */ case    3:  		/* mr R29, R3 */
		/* 82191B7Ch case    3:*/		regs.R29 = regs.R3;
		/* 82191B7Ch case    3:*/		return 0x82191B80;
		  /* 82191B80h */ case    4:  		/* bl 601624 */
		/* 82191B80h case    4:*/		regs.LR = 0x82191B84; return 0x82224998;
		/* 82191B80h case    4:*/		return 0x82191B84;
		  /* 82191B84h */ case    5:  		/* lwz R11, <#[R30 + 16]> */
		/* 82191B84h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82191B84h case    5:*/		return 0x82191B88;
		  /* 82191B88h */ case    6:  		/* mr R28, R3 */
		/* 82191B88h case    6:*/		regs.R28 = regs.R3;
		/* 82191B88h case    6:*/		return 0x82191B8C;
		  /* 82191B8Ch */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82191B8Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82191B8Ch case    7:*/		return 0x82191B90;
		  /* 82191B90h */ case    8:  		/* mr R4, R30 */
		/* 82191B90h case    8:*/		regs.R4 = regs.R30;
		/* 82191B90h case    8:*/		return 0x82191B94;
		  /* 82191B94h */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 82191B94h case    9:*/		if ( regs.CR[6].eq ) { return 0x82191BA8;  }
		/* 82191B94h case    9:*/		return 0x82191B98;
		  /* 82191B98h */ case   10:  		/* mr R3, R29 */
		/* 82191B98h case   10:*/		regs.R3 = regs.R29;
		/* 82191B98h case   10:*/		return 0x82191B9C;
		  /* 82191B9Ch */ case   11:  		/* lwz R5, <#[R30 + 12]> */
		/* 82191B9Ch case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 82191B9Ch case   11:*/		return 0x82191BA0;
		  /* 82191BA0h */ case   12:  		/* bl -133808 */
		/* 82191BA0h case   12:*/		regs.LR = 0x82191BA4; return 0x821710F0;
		/* 82191BA0h case   12:*/		return 0x82191BA4;
		  /* 82191BA4h */ case   13:  		/* mr R4, R3 */
		/* 82191BA4h case   13:*/		regs.R4 = regs.R3;
		/* 82191BA4h case   13:*/		return 0x82191BA8;
	}
	return 0x82191BA8;
} // Block from 82191B70h-82191BA8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82191BA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191BA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191BA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191BA8);
		  /* 82191BA8h */ case    0:  		/* mr R3, R28 */
		/* 82191BA8h case    0:*/		regs.R3 = regs.R28;
		/* 82191BA8h case    0:*/		return 0x82191BAC;
		  /* 82191BACh */ case    1:  		/* bl -104932 */
		/* 82191BACh case    1:*/		regs.LR = 0x82191BB0; return 0x821781C8;
		/* 82191BACh case    1:*/		return 0x82191BB0;
		  /* 82191BB0h */ case    2:  		/* stw R3, <#[R28 + 44]> */
		/* 82191BB0h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x0000002C) );
		/* 82191BB0h case    2:*/		return 0x82191BB4;
		  /* 82191BB4h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 82191BB4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82191BB4h case    3:*/		return 0x82191BB8;
		  /* 82191BB8h */ case    4:  		/* bc 12, CR6_EQ, 56 */
		/* 82191BB8h case    4:*/		if ( regs.CR[6].eq ) { return 0x82191BF0;  }
		/* 82191BB8h case    4:*/		return 0x82191BBC;
		  /* 82191BBCh */ case    5:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 82191BBCh case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 82191BBCh case    5:*/		return 0x82191BC0;
		  /* 82191BC0h */ case    6:  		/* lwz R9, <#[R31]> */
		/* 82191BC0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82191BC0h case    6:*/		return 0x82191BC4;
		  /* 82191BC4h */ case    7:  		/* addi R10, R31, -36 */
		/* 82191BC4h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFDC);
		/* 82191BC4h case    7:*/		return 0x82191BC8;
		  /* 82191BC8h */ case    8:  		/* addi R11, R11, 36 */
		/* 82191BC8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82191BC8h case    8:*/		return 0x82191BCC;
		  /* 82191BCCh */ case    9:  		/* ori R8, R10, 1 */
		/* 82191BCCh case    9:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 82191BCCh case    9:*/		return 0x82191BD0;
		  /* 82191BD0h */ case   10:  		/* addi R7, R11, -36 */
		/* 82191BD0h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 82191BD0h case   10:*/		return 0x82191BD4;
		  /* 82191BD4h */ case   11:  		/* addi R10, R11, 4 */
		/* 82191BD4h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82191BD4h case   11:*/		return 0x82191BD8;
		  /* 82191BD8h */ case   12:  		/* stw R9, <#[R11]> */
		/* 82191BD8h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82191BD8h case   12:*/		return 0x82191BDC;
		  /* 82191BDCh */ case   13:  		/* lwz R9, <#[R31]> */
		/* 82191BDCh case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82191BDCh case   13:*/		return 0x82191BE0;
		  /* 82191BE0h */ case   14:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82191BE0h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82191BE0h case   14:*/		return 0x82191BE4;
		  /* 82191BE4h */ case   15:  		/* stw R7, <#[R9]> */
		/* 82191BE4h case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 82191BE4h case   15:*/		return 0x82191BE8;
		  /* 82191BE8h */ case   16:  		/* stw R8, <#[R11 + 4]> */
		/* 82191BE8h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82191BE8h case   16:*/		return 0x82191BEC;
		  /* 82191BECh */ case   17:  		/* stw R10, <#[R31]> */
		/* 82191BECh case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82191BECh case   17:*/		return 0x82191BF0;
	}
	return 0x82191BF0;
} // Block from 82191BA8h-82191BF0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82191BF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191BF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191BF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191BF0);
		  /* 82191BF0h */ case    0:  		/* mr R3, R28 */
		/* 82191BF0h case    0:*/		regs.R3 = regs.R28;
		/* 82191BF0h case    0:*/		return 0x82191BF4;
		  /* 82191BF4h */ case    1:  		/* addi R1, R1, 128 */
		/* 82191BF4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82191BF4h case    1:*/		return 0x82191BF8;
		  /* 82191BF8h */ case    2:  		/* b -1050960 */
		/* 82191BF8h case    2:*/		return 0x820912A8;
		/* 82191BF8h case    2:*/		return 0x82191BFC;
		  /* 82191BFCh */ case    3:  		/* nop */
		/* 82191BFCh case    3:*/		cpu::op::nop();
		/* 82191BFCh case    3:*/		return 0x82191C00;
	}
	return 0x82191C00;
} // Block from 82191BF0h-82191C00h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82191C00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191C00);
		  /* 82191C00h */ case    0:  		/* mfspr R12, LR */
		/* 82191C00h case    0:*/		regs.R12 = regs.LR;
		/* 82191C00h case    0:*/		return 0x82191C04;
		  /* 82191C04h */ case    1:  		/* bl -1051052 */
		/* 82191C04h case    1:*/		regs.LR = 0x82191C08; return 0x82091258;
		/* 82191C04h case    1:*/		return 0x82191C08;
		  /* 82191C08h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82191C08h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82191C08h case    2:*/		return 0x82191C0C;
		  /* 82191C0Ch */ case    3:  		/* mr R31, R5 */
		/* 82191C0Ch case    3:*/		regs.R31 = regs.R5;
		/* 82191C0Ch case    3:*/		return 0x82191C10;
		  /* 82191C10h */ case    4:  		/* mr R30, R6 */
		/* 82191C10h case    4:*/		regs.R30 = regs.R6;
		/* 82191C10h case    4:*/		return 0x82191C14;
		  /* 82191C14h */ case    5:  		/* li R8, 1 */
		/* 82191C14h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82191C14h case    5:*/		return 0x82191C18;
		  /* 82191C18h */ case    6:  		/* li R7, 1 */
		/* 82191C18h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82191C18h case    6:*/		return 0x82191C1C;
		  /* 82191C1Ch */ case    7:  		/* li R6, 55 */
		/* 82191C1Ch case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x37);
		/* 82191C1Ch case    7:*/		return 0x82191C20;
		  /* 82191C20h */ case    8:  		/* li R5, 0 */
		/* 82191C20h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82191C20h case    8:*/		return 0x82191C24;
		  /* 82191C24h */ case    9:  		/* mr R29, R3 */
		/* 82191C24h case    9:*/		regs.R29 = regs.R3;
		/* 82191C24h case    9:*/		return 0x82191C28;
		  /* 82191C28h */ case   10:  		/* bl 601456 */
		/* 82191C28h case   10:*/		regs.LR = 0x82191C2C; return 0x82224998;
		/* 82191C28h case   10:*/		return 0x82191C2C;
		  /* 82191C2Ch */ case   11:  		/* lwz R11, <#[R30 + 16]> */
		/* 82191C2Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82191C2Ch case   11:*/		return 0x82191C30;
		  /* 82191C30h */ case   12:  		/* mr R28, R3 */
		/* 82191C30h case   12:*/		regs.R28 = regs.R3;
		/* 82191C30h case   12:*/		return 0x82191C34;
		  /* 82191C34h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 82191C34h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82191C34h case   13:*/		return 0x82191C38;
		  /* 82191C38h */ case   14:  		/* mr R4, R30 */
		/* 82191C38h case   14:*/		regs.R4 = regs.R30;
		/* 82191C38h case   14:*/		return 0x82191C3C;
		  /* 82191C3Ch */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 82191C3Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x82191C50;  }
		/* 82191C3Ch case   15:*/		return 0x82191C40;
		  /* 82191C40h */ case   16:  		/* mr R3, R29 */
		/* 82191C40h case   16:*/		regs.R3 = regs.R29;
		/* 82191C40h case   16:*/		return 0x82191C44;
		  /* 82191C44h */ case   17:  		/* lwz R5, <#[R30 + 12]> */
		/* 82191C44h case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 82191C44h case   17:*/		return 0x82191C48;
		  /* 82191C48h */ case   18:  		/* bl -133976 */
		/* 82191C48h case   18:*/		regs.LR = 0x82191C4C; return 0x821710F0;
		/* 82191C48h case   18:*/		return 0x82191C4C;
		  /* 82191C4Ch */ case   19:  		/* mr R4, R3 */
		/* 82191C4Ch case   19:*/		regs.R4 = regs.R3;
		/* 82191C4Ch case   19:*/		return 0x82191C50;
	}
	return 0x82191C50;
} // Block from 82191C00h-82191C50h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82191C50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191C50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191C50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191C50);
		  /* 82191C50h */ case    0:  		/* mr R3, R28 */
		/* 82191C50h case    0:*/		regs.R3 = regs.R28;
		/* 82191C50h case    0:*/		return 0x82191C54;
		  /* 82191C54h */ case    1:  		/* bl -105100 */
		/* 82191C54h case    1:*/		regs.LR = 0x82191C58; return 0x821781C8;
		/* 82191C54h case    1:*/		return 0x82191C58;
		  /* 82191C58h */ case    2:  		/* stw R3, <#[R28 + 44]> */
		/* 82191C58h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x0000002C) );
		/* 82191C58h case    2:*/		return 0x82191C5C;
		  /* 82191C5Ch */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 82191C5Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82191C5Ch case    3:*/		return 0x82191C60;
		  /* 82191C60h */ case    4:  		/* bc 12, CR6_EQ, 56 */
		/* 82191C60h case    4:*/		if ( regs.CR[6].eq ) { return 0x82191C98;  }
		/* 82191C60h case    4:*/		return 0x82191C64;
		  /* 82191C64h */ case    5:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 82191C64h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 82191C64h case    5:*/		return 0x82191C68;
		  /* 82191C68h */ case    6:  		/* lwz R9, <#[R31]> */
		/* 82191C68h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82191C68h case    6:*/		return 0x82191C6C;
		  /* 82191C6Ch */ case    7:  		/* addi R10, R31, -36 */
		/* 82191C6Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFDC);
		/* 82191C6Ch case    7:*/		return 0x82191C70;
		  /* 82191C70h */ case    8:  		/* addi R11, R11, 36 */
		/* 82191C70h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82191C70h case    8:*/		return 0x82191C74;
		  /* 82191C74h */ case    9:  		/* ori R8, R10, 1 */
		/* 82191C74h case    9:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 82191C74h case    9:*/		return 0x82191C78;
		  /* 82191C78h */ case   10:  		/* addi R7, R11, -36 */
		/* 82191C78h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 82191C78h case   10:*/		return 0x82191C7C;
		  /* 82191C7Ch */ case   11:  		/* addi R10, R11, 4 */
		/* 82191C7Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82191C7Ch case   11:*/		return 0x82191C80;
		  /* 82191C80h */ case   12:  		/* stw R9, <#[R11]> */
		/* 82191C80h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82191C80h case   12:*/		return 0x82191C84;
		  /* 82191C84h */ case   13:  		/* lwz R9, <#[R31]> */
		/* 82191C84h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82191C84h case   13:*/		return 0x82191C88;
		  /* 82191C88h */ case   14:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82191C88h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82191C88h case   14:*/		return 0x82191C8C;
		  /* 82191C8Ch */ case   15:  		/* stw R7, <#[R9]> */
		/* 82191C8Ch case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 82191C8Ch case   15:*/		return 0x82191C90;
		  /* 82191C90h */ case   16:  		/* stw R8, <#[R11 + 4]> */
		/* 82191C90h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82191C90h case   16:*/		return 0x82191C94;
		  /* 82191C94h */ case   17:  		/* stw R10, <#[R31]> */
		/* 82191C94h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82191C94h case   17:*/		return 0x82191C98;
	}
	return 0x82191C98;
} // Block from 82191C50h-82191C98h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82191C98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191C98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191C98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191C98);
		  /* 82191C98h */ case    0:  		/* mr R3, R28 */
		/* 82191C98h case    0:*/		regs.R3 = regs.R28;
		/* 82191C98h case    0:*/		return 0x82191C9C;
		  /* 82191C9Ch */ case    1:  		/* addi R1, R1, 128 */
		/* 82191C9Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82191C9Ch case    1:*/		return 0x82191CA0;
		  /* 82191CA0h */ case    2:  		/* b -1051128 */
		/* 82191CA0h case    2:*/		return 0x820912A8;
		/* 82191CA0h case    2:*/		return 0x82191CA4;
		  /* 82191CA4h */ case    3:  		/* nop */
		/* 82191CA4h case    3:*/		cpu::op::nop();
		/* 82191CA4h case    3:*/		return 0x82191CA8;
	}
	return 0x82191CA8;
} // Block from 82191C98h-82191CA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82191CA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191CA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191CA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191CA8);
		  /* 82191CA8h */ case    0:  		/* mfspr R12, LR */
		/* 82191CA8h case    0:*/		regs.R12 = regs.LR;
		/* 82191CA8h case    0:*/		return 0x82191CAC;
		  /* 82191CACh */ case    1:  		/* bl -1051220 */
		/* 82191CACh case    1:*/		regs.LR = 0x82191CB0; return 0x82091258;
		/* 82191CACh case    1:*/		return 0x82191CB0;
		  /* 82191CB0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82191CB0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82191CB0h case    2:*/		return 0x82191CB4;
		  /* 82191CB4h */ case    3:  		/* mr R31, R5 */
		/* 82191CB4h case    3:*/		regs.R31 = regs.R5;
		/* 82191CB4h case    3:*/		return 0x82191CB8;
		  /* 82191CB8h */ case    4:  		/* mr R30, R6 */
		/* 82191CB8h case    4:*/		regs.R30 = regs.R6;
		/* 82191CB8h case    4:*/		return 0x82191CBC;
		  /* 82191CBCh */ case    5:  		/* li R8, 1 */
		/* 82191CBCh case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82191CBCh case    5:*/		return 0x82191CC0;
		  /* 82191CC0h */ case    6:  		/* li R7, 1 */
		/* 82191CC0h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82191CC0h case    6:*/		return 0x82191CC4;
		  /* 82191CC4h */ case    7:  		/* li R6, 56 */
		/* 82191CC4h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x38);
		/* 82191CC4h case    7:*/		return 0x82191CC8;
		  /* 82191CC8h */ case    8:  		/* li R5, 0 */
		/* 82191CC8h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82191CC8h case    8:*/		return 0x82191CCC;
		  /* 82191CCCh */ case    9:  		/* mr R29, R3 */
		/* 82191CCCh case    9:*/		regs.R29 = regs.R3;
		/* 82191CCCh case    9:*/		return 0x82191CD0;
		  /* 82191CD0h */ case   10:  		/* bl 601288 */
		/* 82191CD0h case   10:*/		regs.LR = 0x82191CD4; return 0x82224998;
		/* 82191CD0h case   10:*/		return 0x82191CD4;
		  /* 82191CD4h */ case   11:  		/* lwz R11, <#[R30 + 16]> */
		/* 82191CD4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82191CD4h case   11:*/		return 0x82191CD8;
		  /* 82191CD8h */ case   12:  		/* mr R28, R3 */
		/* 82191CD8h case   12:*/		regs.R28 = regs.R3;
		/* 82191CD8h case   12:*/		return 0x82191CDC;
		  /* 82191CDCh */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 82191CDCh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82191CDCh case   13:*/		return 0x82191CE0;
		  /* 82191CE0h */ case   14:  		/* mr R4, R30 */
		/* 82191CE0h case   14:*/		regs.R4 = regs.R30;
		/* 82191CE0h case   14:*/		return 0x82191CE4;
		  /* 82191CE4h */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 82191CE4h case   15:*/		if ( regs.CR[6].eq ) { return 0x82191CF8;  }
		/* 82191CE4h case   15:*/		return 0x82191CE8;
		  /* 82191CE8h */ case   16:  		/* mr R3, R29 */
		/* 82191CE8h case   16:*/		regs.R3 = regs.R29;
		/* 82191CE8h case   16:*/		return 0x82191CEC;
		  /* 82191CECh */ case   17:  		/* lwz R5, <#[R30 + 12]> */
		/* 82191CECh case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 82191CECh case   17:*/		return 0x82191CF0;
		  /* 82191CF0h */ case   18:  		/* bl -134144 */
		/* 82191CF0h case   18:*/		regs.LR = 0x82191CF4; return 0x821710F0;
		/* 82191CF0h case   18:*/		return 0x82191CF4;
		  /* 82191CF4h */ case   19:  		/* mr R4, R3 */
		/* 82191CF4h case   19:*/		regs.R4 = regs.R3;
		/* 82191CF4h case   19:*/		return 0x82191CF8;
	}
	return 0x82191CF8;
} // Block from 82191CA8h-82191CF8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82191CF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191CF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191CF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191CF8);
		  /* 82191CF8h */ case    0:  		/* mr R3, R28 */
		/* 82191CF8h case    0:*/		regs.R3 = regs.R28;
		/* 82191CF8h case    0:*/		return 0x82191CFC;
		  /* 82191CFCh */ case    1:  		/* bl -105268 */
		/* 82191CFCh case    1:*/		regs.LR = 0x82191D00; return 0x821781C8;
		/* 82191CFCh case    1:*/		return 0x82191D00;
		  /* 82191D00h */ case    2:  		/* stw R3, <#[R28 + 44]> */
		/* 82191D00h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x0000002C) );
		/* 82191D00h case    2:*/		return 0x82191D04;
		  /* 82191D04h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 82191D04h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82191D04h case    3:*/		return 0x82191D08;
		  /* 82191D08h */ case    4:  		/* bc 12, CR6_EQ, 56 */
		/* 82191D08h case    4:*/		if ( regs.CR[6].eq ) { return 0x82191D40;  }
		/* 82191D08h case    4:*/		return 0x82191D0C;
		  /* 82191D0Ch */ case    5:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 82191D0Ch case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 82191D0Ch case    5:*/		return 0x82191D10;
		  /* 82191D10h */ case    6:  		/* lwz R9, <#[R31]> */
		/* 82191D10h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82191D10h case    6:*/		return 0x82191D14;
		  /* 82191D14h */ case    7:  		/* addi R10, R31, -36 */
		/* 82191D14h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFDC);
		/* 82191D14h case    7:*/		return 0x82191D18;
		  /* 82191D18h */ case    8:  		/* addi R11, R11, 36 */
		/* 82191D18h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82191D18h case    8:*/		return 0x82191D1C;
		  /* 82191D1Ch */ case    9:  		/* ori R8, R10, 1 */
		/* 82191D1Ch case    9:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 82191D1Ch case    9:*/		return 0x82191D20;
		  /* 82191D20h */ case   10:  		/* addi R7, R11, -36 */
		/* 82191D20h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 82191D20h case   10:*/		return 0x82191D24;
		  /* 82191D24h */ case   11:  		/* addi R10, R11, 4 */
		/* 82191D24h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82191D24h case   11:*/		return 0x82191D28;
		  /* 82191D28h */ case   12:  		/* stw R9, <#[R11]> */
		/* 82191D28h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82191D28h case   12:*/		return 0x82191D2C;
		  /* 82191D2Ch */ case   13:  		/* lwz R9, <#[R31]> */
		/* 82191D2Ch case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82191D2Ch case   13:*/		return 0x82191D30;
		  /* 82191D30h */ case   14:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82191D30h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82191D30h case   14:*/		return 0x82191D34;
		  /* 82191D34h */ case   15:  		/* stw R7, <#[R9]> */
		/* 82191D34h case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 82191D34h case   15:*/		return 0x82191D38;
		  /* 82191D38h */ case   16:  		/* stw R8, <#[R11 + 4]> */
		/* 82191D38h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82191D38h case   16:*/		return 0x82191D3C;
		  /* 82191D3Ch */ case   17:  		/* stw R10, <#[R31]> */
		/* 82191D3Ch case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82191D3Ch case   17:*/		return 0x82191D40;
	}
	return 0x82191D40;
} // Block from 82191CF8h-82191D40h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82191D40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191D40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191D40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191D40);
		  /* 82191D40h */ case    0:  		/* mr R3, R28 */
		/* 82191D40h case    0:*/		regs.R3 = regs.R28;
		/* 82191D40h case    0:*/		return 0x82191D44;
		  /* 82191D44h */ case    1:  		/* addi R1, R1, 128 */
		/* 82191D44h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82191D44h case    1:*/		return 0x82191D48;
		  /* 82191D48h */ case    2:  		/* b -1051296 */
		/* 82191D48h case    2:*/		return 0x820912A8;
		/* 82191D48h case    2:*/		return 0x82191D4C;
		  /* 82191D4Ch */ case    3:  		/* nop */
		/* 82191D4Ch case    3:*/		cpu::op::nop();
		/* 82191D4Ch case    3:*/		return 0x82191D50;
	}
	return 0x82191D50;
} // Block from 82191D40h-82191D50h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82191D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191D50);
		  /* 82191D50h */ case    0:  		/* mfspr R12, LR */
		/* 82191D50h case    0:*/		regs.R12 = regs.LR;
		/* 82191D50h case    0:*/		return 0x82191D54;
		  /* 82191D54h */ case    1:  		/* bl -1051392 */
		/* 82191D54h case    1:*/		regs.LR = 0x82191D58; return 0x82091254;
		/* 82191D54h case    1:*/		return 0x82191D58;
		  /* 82191D58h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82191D58h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82191D58h case    2:*/		return 0x82191D5C;
		  /* 82191D5Ch */ case    3:  		/* mr R30, R5 */
		/* 82191D5Ch case    3:*/		regs.R30 = regs.R5;
		/* 82191D5Ch case    3:*/		return 0x82191D60;
		  /* 82191D60h */ case    4:  		/* mr R31, R6 */
		/* 82191D60h case    4:*/		regs.R31 = regs.R6;
		/* 82191D60h case    4:*/		return 0x82191D64;
		  /* 82191D64h */ case    5:  		/* mr R27, R7 */
		/* 82191D64h case    5:*/		regs.R27 = regs.R7;
		/* 82191D64h case    5:*/		return 0x82191D68;
		  /* 82191D68h */ case    6:  		/* li R8, 1 */
		/* 82191D68h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82191D68h case    6:*/		return 0x82191D6C;
		  /* 82191D6Ch */ case    7:  		/* li R7, 2 */
		/* 82191D6Ch case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 82191D6Ch case    7:*/		return 0x82191D70;
		  /* 82191D70h */ case    8:  		/* li R6, 74 */
		/* 82191D70h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x4A);
		/* 82191D70h case    8:*/		return 0x82191D74;
		  /* 82191D74h */ case    9:  		/* li R5, 0 */
		/* 82191D74h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82191D74h case    9:*/		return 0x82191D78;
		  /* 82191D78h */ case   10:  		/* mr R28, R3 */
		/* 82191D78h case   10:*/		regs.R28 = regs.R3;
		/* 82191D78h case   10:*/		return 0x82191D7C;
		  /* 82191D7Ch */ case   11:  		/* bl 601116 */
		/* 82191D7Ch case   11:*/		regs.LR = 0x82191D80; return 0x82224998;
		/* 82191D7Ch case   11:*/		return 0x82191D80;
		  /* 82191D80h */ case   12:  		/* lwz R11, <#[R31 + 16]> */
		/* 82191D80h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82191D80h case   12:*/		return 0x82191D84;
		  /* 82191D84h */ case   13:  		/* mr R29, R3 */
		/* 82191D84h case   13:*/		regs.R29 = regs.R3;
		/* 82191D84h case   13:*/		return 0x82191D88;
		  /* 82191D88h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 82191D88h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82191D88h case   14:*/		return 0x82191D8C;
		  /* 82191D8Ch */ case   15:  		/* mr R4, R31 */
		/* 82191D8Ch case   15:*/		regs.R4 = regs.R31;
		/* 82191D8Ch case   15:*/		return 0x82191D90;
		  /* 82191D90h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 82191D90h case   16:*/		if ( regs.CR[6].eq ) { return 0x82191DA4;  }
		/* 82191D90h case   16:*/		return 0x82191D94;
		  /* 82191D94h */ case   17:  		/* mr R3, R28 */
		/* 82191D94h case   17:*/		regs.R3 = regs.R28;
		/* 82191D94h case   17:*/		return 0x82191D98;
		  /* 82191D98h */ case   18:  		/* lwz R5, <#[R31 + 12]> */
		/* 82191D98h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 82191D98h case   18:*/		return 0x82191D9C;
		  /* 82191D9Ch */ case   19:  		/* bl -134316 */
		/* 82191D9Ch case   19:*/		regs.LR = 0x82191DA0; return 0x821710F0;
		/* 82191D9Ch case   19:*/		return 0x82191DA0;
		  /* 82191DA0h */ case   20:  		/* mr R4, R3 */
		/* 82191DA0h case   20:*/		regs.R4 = regs.R3;
		/* 82191DA0h case   20:*/		return 0x82191DA4;
	}
	return 0x82191DA4;
} // Block from 82191D50h-82191DA4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82191DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191DA4);
		  /* 82191DA4h */ case    0:  		/* mr R3, R29 */
		/* 82191DA4h case    0:*/		regs.R3 = regs.R29;
		/* 82191DA4h case    0:*/		return 0x82191DA8;
		  /* 82191DA8h */ case    1:  		/* bl -105440 */
		/* 82191DA8h case    1:*/		regs.LR = 0x82191DAC; return 0x821781C8;
		/* 82191DA8h case    1:*/		return 0x82191DAC;
		  /* 82191DACh */ case    2:  		/* stw R3, <#[R29 + 44]> */
		/* 82191DACh case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 82191DACh case    2:*/		return 0x82191DB0;
		  /* 82191DB0h */ case    3:  		/* lwz R11, <#[R27 + 16]> */
		/* 82191DB0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 82191DB0h case    3:*/		return 0x82191DB4;
		  /* 82191DB4h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82191DB4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82191DB4h case    4:*/		return 0x82191DB8;
		  /* 82191DB8h */ case    5:  		/* mr R4, R27 */
		/* 82191DB8h case    5:*/		regs.R4 = regs.R27;
		/* 82191DB8h case    5:*/		return 0x82191DBC;
		  /* 82191DBCh */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 82191DBCh case    6:*/		if ( regs.CR[6].eq ) { return 0x82191DD0;  }
		/* 82191DBCh case    6:*/		return 0x82191DC0;
		  /* 82191DC0h */ case    7:  		/* mr R3, R28 */
		/* 82191DC0h case    7:*/		regs.R3 = regs.R28;
		/* 82191DC0h case    7:*/		return 0x82191DC4;
		  /* 82191DC4h */ case    8:  		/* lwz R5, <#[R27 + 12]> */
		/* 82191DC4h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + 0x0000000C) );
		/* 82191DC4h case    8:*/		return 0x82191DC8;
		  /* 82191DC8h */ case    9:  		/* bl -134360 */
		/* 82191DC8h case    9:*/		regs.LR = 0x82191DCC; return 0x821710F0;
		/* 82191DC8h case    9:*/		return 0x82191DCC;
		  /* 82191DCCh */ case   10:  		/* mr R4, R3 */
		/* 82191DCCh case   10:*/		regs.R4 = regs.R3;
		/* 82191DCCh case   10:*/		return 0x82191DD0;
	}
	return 0x82191DD0;
} // Block from 82191DA4h-82191DD0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82191DD0h
// Function '?ReplaceSmashedInstruction@Compiler@D3DXShader@@AAAXPAVInstruction@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191DD0);
		  /* 82191DD0h */ case    0:  		/* mr R3, R29 */
		/* 82191DD0h case    0:*/		regs.R3 = regs.R29;
		/* 82191DD0h case    0:*/		return 0x82191DD4;
		  /* 82191DD4h */ case    1:  		/* bl -105484 */
		/* 82191DD4h case    1:*/		regs.LR = 0x82191DD8; return 0x821781C8;
		/* 82191DD4h case    1:*/		return 0x82191DD8;
		  /* 82191DD8h */ case    2:  		/* stw R3, <#[R29 + 48]> */
		/* 82191DD8h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000030) );
		/* 82191DD8h case    2:*/		return 0x82191DDC;
		  /* 82191DDCh */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 82191DDCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82191DDCh case    3:*/		return 0x82191DE0;
		  /* 82191DE0h */ case    4:  		/* bc 12, CR6_EQ, 56 */
		/* 82191DE0h case    4:*/		if ( regs.CR[6].eq ) { return 0x82191E18;  }
		/* 82191DE0h case    4:*/		return 0x82191DE4;
		  /* 82191DE4h */ case    5:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 82191DE4h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 82191DE4h case    5:*/		return 0x82191DE8;
		  /* 82191DE8h */ case    6:  		/* lwz R9, <#[R30]> */
		/* 82191DE8h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 82191DE8h case    6:*/		return 0x82191DEC;
		  /* 82191DECh */ case    7:  		/* addi R10, R30, -36 */
		/* 82191DECh case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0xFFFFFFDC);
		/* 82191DECh case    7:*/		return 0x82191DF0;
		  /* 82191DF0h */ case    8:  		/* addi R11, R11, 36 */
		/* 82191DF0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82191DF0h case    8:*/		return 0x82191DF4;
		  /* 82191DF4h */ case    9:  		/* ori R8, R10, 1 */
		/* 82191DF4h case    9:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 82191DF4h case    9:*/		return 0x82191DF8;
		  /* 82191DF8h */ case   10:  		/* addi R7, R11, -36 */
		/* 82191DF8h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 82191DF8h case   10:*/		return 0x82191DFC;
		  /* 82191DFCh */ case   11:  		/* addi R10, R11, 4 */
		/* 82191DFCh case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82191DFCh case   11:*/		return 0x82191E00;
		  /* 82191E00h */ case   12:  		/* stw R9, <#[R11]> */
		/* 82191E00h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82191E00h case   12:*/		return 0x82191E04;
		  /* 82191E04h */ case   13:  		/* lwz R9, <#[R30]> */
		/* 82191E04h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 82191E04h case   13:*/		return 0x82191E08;
		  /* 82191E08h */ case   14:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82191E08h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82191E08h case   14:*/		return 0x82191E0C;
		  /* 82191E0Ch */ case   15:  		/* stw R7, <#[R9]> */
		/* 82191E0Ch case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 82191E0Ch case   15:*/		return 0x82191E10;
		  /* 82191E10h */ case   16:  		/* stw R8, <#[R11 + 4]> */
		/* 82191E10h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82191E10h case   16:*/		return 0x82191E14;
		  /* 82191E14h */ case   17:  		/* stw R10, <#[R30]> */
		/* 82191E14h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82191E14h case   17:*/		return 0x82191E18;
	}
	return 0x82191E18;
} // Block from 82191DD0h-82191E18h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82191E18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191E18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191E18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191E18);
		  /* 82191E18h */ case    0:  		/* mr R3, R29 */
		/* 82191E18h case    0:*/		regs.R3 = regs.R29;
		/* 82191E18h case    0:*/		return 0x82191E1C;
		  /* 82191E1Ch */ case    1:  		/* addi R1, R1, 128 */
		/* 82191E1Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82191E1Ch case    1:*/		return 0x82191E20;
		  /* 82191E20h */ case    2:  		/* b -1051516 */
		/* 82191E20h case    2:*/		return 0x820912A4;
		/* 82191E20h case    2:*/		return 0x82191E24;
		  /* 82191E24h */ case    3:  		/* nop */
		/* 82191E24h case    3:*/		cpu::op::nop();
		/* 82191E24h case    3:*/		return 0x82191E28;
	}
	return 0x82191E28;
} // Block from 82191E18h-82191E28h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82191E28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191E28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191E28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191E28);
		  /* 82191E28h */ case    0:  		/* mfspr R12, LR */
		/* 82191E28h case    0:*/		regs.R12 = regs.LR;
		/* 82191E28h case    0:*/		return 0x82191E2C;
		  /* 82191E2Ch */ case    1:  		/* bl -1051608 */
		/* 82191E2Ch case    1:*/		regs.LR = 0x82191E30; return 0x82091254;
		/* 82191E2Ch case    1:*/		return 0x82191E30;
		  /* 82191E30h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82191E30h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82191E30h case    2:*/		return 0x82191E34;
		  /* 82191E34h */ case    3:  		/* mr R30, R5 */
		/* 82191E34h case    3:*/		regs.R30 = regs.R5;
		/* 82191E34h case    3:*/		return 0x82191E38;
		  /* 82191E38h */ case    4:  		/* mr R31, R6 */
		/* 82191E38h case    4:*/		regs.R31 = regs.R6;
		/* 82191E38h case    4:*/		return 0x82191E3C;
		  /* 82191E3Ch */ case    5:  		/* mr R27, R7 */
		/* 82191E3Ch case    5:*/		regs.R27 = regs.R7;
		/* 82191E3Ch case    5:*/		return 0x82191E40;
		  /* 82191E40h */ case    6:  		/* li R8, 1 */
		/* 82191E40h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82191E40h case    6:*/		return 0x82191E44;
		  /* 82191E44h */ case    7:  		/* li R7, 2 */
		/* 82191E44h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 82191E44h case    7:*/		return 0x82191E48;
		  /* 82191E48h */ case    8:  		/* li R6, 76 */
		/* 82191E48h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x4C);
		/* 82191E48h case    8:*/		return 0x82191E4C;
		  /* 82191E4Ch */ case    9:  		/* li R5, 0 */
		/* 82191E4Ch case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82191E4Ch case    9:*/		return 0x82191E50;
		  /* 82191E50h */ case   10:  		/* mr R28, R3 */
		/* 82191E50h case   10:*/		regs.R28 = regs.R3;
		/* 82191E50h case   10:*/		return 0x82191E54;
		  /* 82191E54h */ case   11:  		/* bl 600900 */
		/* 82191E54h case   11:*/		regs.LR = 0x82191E58; return 0x82224998;
		/* 82191E54h case   11:*/		return 0x82191E58;
		  /* 82191E58h */ case   12:  		/* lwz R11, <#[R31 + 16]> */
		/* 82191E58h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82191E58h case   12:*/		return 0x82191E5C;
		  /* 82191E5Ch */ case   13:  		/* mr R29, R3 */
		/* 82191E5Ch case   13:*/		regs.R29 = regs.R3;
		/* 82191E5Ch case   13:*/		return 0x82191E60;
		  /* 82191E60h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 82191E60h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82191E60h case   14:*/		return 0x82191E64;
		  /* 82191E64h */ case   15:  		/* mr R4, R31 */
		/* 82191E64h case   15:*/		regs.R4 = regs.R31;
		/* 82191E64h case   15:*/		return 0x82191E68;
		  /* 82191E68h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 82191E68h case   16:*/		if ( regs.CR[6].eq ) { return 0x82191E7C;  }
		/* 82191E68h case   16:*/		return 0x82191E6C;
		  /* 82191E6Ch */ case   17:  		/* mr R3, R28 */
		/* 82191E6Ch case   17:*/		regs.R3 = regs.R28;
		/* 82191E6Ch case   17:*/		return 0x82191E70;
		  /* 82191E70h */ case   18:  		/* lwz R5, <#[R31 + 12]> */
		/* 82191E70h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 82191E70h case   18:*/		return 0x82191E74;
		  /* 82191E74h */ case   19:  		/* bl -134532 */
		/* 82191E74h case   19:*/		regs.LR = 0x82191E78; return 0x821710F0;
		/* 82191E74h case   19:*/		return 0x82191E78;
		  /* 82191E78h */ case   20:  		/* mr R4, R3 */
		/* 82191E78h case   20:*/		regs.R4 = regs.R3;
		/* 82191E78h case   20:*/		return 0x82191E7C;
	}
	return 0x82191E7C;
} // Block from 82191E28h-82191E7Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 82191E7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191E7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191E7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191E7C);
		  /* 82191E7Ch */ case    0:  		/* mr R3, R29 */
		/* 82191E7Ch case    0:*/		regs.R3 = regs.R29;
		/* 82191E7Ch case    0:*/		return 0x82191E80;
		  /* 82191E80h */ case    1:  		/* bl -105656 */
		/* 82191E80h case    1:*/		regs.LR = 0x82191E84; return 0x821781C8;
		/* 82191E80h case    1:*/		return 0x82191E84;
		  /* 82191E84h */ case    2:  		/* stw R3, <#[R29 + 44]> */
		/* 82191E84h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 82191E84h case    2:*/		return 0x82191E88;
		  /* 82191E88h */ case    3:  		/* lwz R11, <#[R27 + 16]> */
		/* 82191E88h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 82191E88h case    3:*/		return 0x82191E8C;
		  /* 82191E8Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82191E8Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82191E8Ch case    4:*/		return 0x82191E90;
		  /* 82191E90h */ case    5:  		/* mr R4, R27 */
		/* 82191E90h case    5:*/		regs.R4 = regs.R27;
		/* 82191E90h case    5:*/		return 0x82191E94;
		  /* 82191E94h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 82191E94h case    6:*/		if ( regs.CR[6].eq ) { return 0x82191EA8;  }
		/* 82191E94h case    6:*/		return 0x82191E98;
		  /* 82191E98h */ case    7:  		/* mr R3, R28 */
		/* 82191E98h case    7:*/		regs.R3 = regs.R28;
		/* 82191E98h case    7:*/		return 0x82191E9C;
		  /* 82191E9Ch */ case    8:  		/* lwz R5, <#[R27 + 12]> */
		/* 82191E9Ch case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + 0x0000000C) );
		/* 82191E9Ch case    8:*/		return 0x82191EA0;
		  /* 82191EA0h */ case    9:  		/* bl -134576 */
		/* 82191EA0h case    9:*/		regs.LR = 0x82191EA4; return 0x821710F0;
		/* 82191EA0h case    9:*/		return 0x82191EA4;
		  /* 82191EA4h */ case   10:  		/* mr R4, R3 */
		/* 82191EA4h case   10:*/		regs.R4 = regs.R3;
		/* 82191EA4h case   10:*/		return 0x82191EA8;
	}
	return 0x82191EA8;
} // Block from 82191E7Ch-82191EA8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82191EA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191EA8);
		  /* 82191EA8h */ case    0:  		/* mr R3, R29 */
		/* 82191EA8h case    0:*/		regs.R3 = regs.R29;
		/* 82191EA8h case    0:*/		return 0x82191EAC;
		  /* 82191EACh */ case    1:  		/* bl -105700 */
		/* 82191EACh case    1:*/		regs.LR = 0x82191EB0; return 0x821781C8;
		/* 82191EACh case    1:*/		return 0x82191EB0;
		  /* 82191EB0h */ case    2:  		/* stw R3, <#[R29 + 48]> */
		/* 82191EB0h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000030) );
		/* 82191EB0h case    2:*/		return 0x82191EB4;
		  /* 82191EB4h */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 82191EB4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82191EB4h case    3:*/		return 0x82191EB8;
		  /* 82191EB8h */ case    4:  		/* bc 12, CR6_EQ, 56 */
		/* 82191EB8h case    4:*/		if ( regs.CR[6].eq ) { return 0x82191EF0;  }
		/* 82191EB8h case    4:*/		return 0x82191EBC;
		  /* 82191EBCh */ case    5:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 82191EBCh case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 82191EBCh case    5:*/		return 0x82191EC0;
		  /* 82191EC0h */ case    6:  		/* lwz R9, <#[R30]> */
		/* 82191EC0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 82191EC0h case    6:*/		return 0x82191EC4;
		  /* 82191EC4h */ case    7:  		/* addi R10, R30, -36 */
		/* 82191EC4h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0xFFFFFFDC);
		/* 82191EC4h case    7:*/		return 0x82191EC8;
		  /* 82191EC8h */ case    8:  		/* addi R11, R11, 36 */
		/* 82191EC8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82191EC8h case    8:*/		return 0x82191ECC;
		  /* 82191ECCh */ case    9:  		/* ori R8, R10, 1 */
		/* 82191ECCh case    9:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 82191ECCh case    9:*/		return 0x82191ED0;
		  /* 82191ED0h */ case   10:  		/* addi R7, R11, -36 */
		/* 82191ED0h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 82191ED0h case   10:*/		return 0x82191ED4;
		  /* 82191ED4h */ case   11:  		/* addi R10, R11, 4 */
		/* 82191ED4h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82191ED4h case   11:*/		return 0x82191ED8;
		  /* 82191ED8h */ case   12:  		/* stw R9, <#[R11]> */
		/* 82191ED8h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82191ED8h case   12:*/		return 0x82191EDC;
		  /* 82191EDCh */ case   13:  		/* lwz R9, <#[R30]> */
		/* 82191EDCh case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 82191EDCh case   13:*/		return 0x82191EE0;
		  /* 82191EE0h */ case   14:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82191EE0h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82191EE0h case   14:*/		return 0x82191EE4;
		  /* 82191EE4h */ case   15:  		/* stw R7, <#[R9]> */
		/* 82191EE4h case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 82191EE4h case   15:*/		return 0x82191EE8;
		  /* 82191EE8h */ case   16:  		/* stw R8, <#[R11 + 4]> */
		/* 82191EE8h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82191EE8h case   16:*/		return 0x82191EEC;
		  /* 82191EECh */ case   17:  		/* stw R10, <#[R30]> */
		/* 82191EECh case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82191EECh case   17:*/		return 0x82191EF0;
	}
	return 0x82191EF0;
} // Block from 82191EA8h-82191EF0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82191EF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191EF0);
		  /* 82191EF0h */ case    0:  		/* mr R3, R29 */
		/* 82191EF0h case    0:*/		regs.R3 = regs.R29;
		/* 82191EF0h case    0:*/		return 0x82191EF4;
		  /* 82191EF4h */ case    1:  		/* addi R1, R1, 128 */
		/* 82191EF4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82191EF4h case    1:*/		return 0x82191EF8;
		  /* 82191EF8h */ case    2:  		/* b -1051732 */
		/* 82191EF8h case    2:*/		return 0x820912A4;
		/* 82191EF8h case    2:*/		return 0x82191EFC;
		  /* 82191EFCh */ case    3:  		/* nop */
		/* 82191EFCh case    3:*/		cpu::op::nop();
		/* 82191EFCh case    3:*/		return 0x82191F00;
	}
	return 0x82191F00;
} // Block from 82191EF0h-82191F00h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82191F00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191F00);
		  /* 82191F00h */ case    0:  		/* mfspr R12, LR */
		/* 82191F00h case    0:*/		regs.R12 = regs.LR;
		/* 82191F00h case    0:*/		return 0x82191F04;
		  /* 82191F04h */ case    1:  		/* bl -1051824 */
		/* 82191F04h case    1:*/		regs.LR = 0x82191F08; return 0x82091254;
		/* 82191F04h case    1:*/		return 0x82191F08;
		  /* 82191F08h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82191F08h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82191F08h case    2:*/		return 0x82191F0C;
		  /* 82191F0Ch */ case    3:  		/* mr R30, R5 */
		/* 82191F0Ch case    3:*/		regs.R30 = regs.R5;
		/* 82191F0Ch case    3:*/		return 0x82191F10;
		  /* 82191F10h */ case    4:  		/* mr R31, R6 */
		/* 82191F10h case    4:*/		regs.R31 = regs.R6;
		/* 82191F10h case    4:*/		return 0x82191F14;
		  /* 82191F14h */ case    5:  		/* mr R27, R7 */
		/* 82191F14h case    5:*/		regs.R27 = regs.R7;
		/* 82191F14h case    5:*/		return 0x82191F18;
		  /* 82191F18h */ case    6:  		/* li R8, 1 */
		/* 82191F18h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82191F18h case    6:*/		return 0x82191F1C;
		  /* 82191F1Ch */ case    7:  		/* li R7, 2 */
		/* 82191F1Ch case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 82191F1Ch case    7:*/		return 0x82191F20;
		  /* 82191F20h */ case    8:  		/* li R6, 78 */
		/* 82191F20h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x4E);
		/* 82191F20h case    8:*/		return 0x82191F24;
		  /* 82191F24h */ case    9:  		/* li R5, 0 */
		/* 82191F24h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82191F24h case    9:*/		return 0x82191F28;
		  /* 82191F28h */ case   10:  		/* mr R28, R3 */
		/* 82191F28h case   10:*/		regs.R28 = regs.R3;
		/* 82191F28h case   10:*/		return 0x82191F2C;
		  /* 82191F2Ch */ case   11:  		/* bl 600684 */
		/* 82191F2Ch case   11:*/		regs.LR = 0x82191F30; return 0x82224998;
		/* 82191F2Ch case   11:*/		return 0x82191F30;
		  /* 82191F30h */ case   12:  		/* lwz R11, <#[R31 + 16]> */
		/* 82191F30h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82191F30h case   12:*/		return 0x82191F34;
		  /* 82191F34h */ case   13:  		/* mr R29, R3 */
		/* 82191F34h case   13:*/		regs.R29 = regs.R3;
		/* 82191F34h case   13:*/		return 0x82191F38;
		  /* 82191F38h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 82191F38h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82191F38h case   14:*/		return 0x82191F3C;
		  /* 82191F3Ch */ case   15:  		/* mr R4, R31 */
		/* 82191F3Ch case   15:*/		regs.R4 = regs.R31;
		/* 82191F3Ch case   15:*/		return 0x82191F40;
		  /* 82191F40h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 82191F40h case   16:*/		if ( regs.CR[6].eq ) { return 0x82191F54;  }
		/* 82191F40h case   16:*/		return 0x82191F44;
		  /* 82191F44h */ case   17:  		/* mr R3, R28 */
		/* 82191F44h case   17:*/		regs.R3 = regs.R28;
		/* 82191F44h case   17:*/		return 0x82191F48;
		  /* 82191F48h */ case   18:  		/* lwz R5, <#[R31 + 12]> */
		/* 82191F48h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 82191F48h case   18:*/		return 0x82191F4C;
		  /* 82191F4Ch */ case   19:  		/* bl -134748 */
		/* 82191F4Ch case   19:*/		regs.LR = 0x82191F50; return 0x821710F0;
		/* 82191F4Ch case   19:*/		return 0x82191F50;
		  /* 82191F50h */ case   20:  		/* mr R4, R3 */
		/* 82191F50h case   20:*/		regs.R4 = regs.R3;
		/* 82191F50h case   20:*/		return 0x82191F54;
	}
	return 0x82191F54;
} // Block from 82191F00h-82191F54h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82191F54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191F54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191F54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191F54);
		  /* 82191F54h */ case    0:  		/* mr R3, R29 */
		/* 82191F54h case    0:*/		regs.R3 = regs.R29;
		/* 82191F54h case    0:*/		return 0x82191F58;
		  /* 82191F58h */ case    1:  		/* bl -105872 */
		/* 82191F58h case    1:*/		regs.LR = 0x82191F5C; return 0x821781C8;
		/* 82191F58h case    1:*/		return 0x82191F5C;
		  /* 82191F5Ch */ case    2:  		/* stw R3, <#[R29 + 44]> */
		/* 82191F5Ch case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 82191F5Ch case    2:*/		return 0x82191F60;
		  /* 82191F60h */ case    3:  		/* lwz R11, <#[R27 + 16]> */
		/* 82191F60h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 82191F60h case    3:*/		return 0x82191F64;
		  /* 82191F64h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82191F64h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82191F64h case    4:*/		return 0x82191F68;
		  /* 82191F68h */ case    5:  		/* mr R4, R27 */
		/* 82191F68h case    5:*/		regs.R4 = regs.R27;
		/* 82191F68h case    5:*/		return 0x82191F6C;
		  /* 82191F6Ch */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 82191F6Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x82191F80;  }
		/* 82191F6Ch case    6:*/		return 0x82191F70;
		  /* 82191F70h */ case    7:  		/* mr R3, R28 */
		/* 82191F70h case    7:*/		regs.R3 = regs.R28;
		/* 82191F70h case    7:*/		return 0x82191F74;
		  /* 82191F74h */ case    8:  		/* lwz R5, <#[R27 + 12]> */
		/* 82191F74h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + 0x0000000C) );
		/* 82191F74h case    8:*/		return 0x82191F78;
		  /* 82191F78h */ case    9:  		/* bl -134792 */
		/* 82191F78h case    9:*/		regs.LR = 0x82191F7C; return 0x821710F0;
		/* 82191F78h case    9:*/		return 0x82191F7C;
		  /* 82191F7Ch */ case   10:  		/* mr R4, R3 */
		/* 82191F7Ch case   10:*/		regs.R4 = regs.R3;
		/* 82191F7Ch case   10:*/		return 0x82191F80;
	}
	return 0x82191F80;
} // Block from 82191F54h-82191F80h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82191F80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191F80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191F80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191F80);
		  /* 82191F80h */ case    0:  		/* mr R3, R29 */
		/* 82191F80h case    0:*/		regs.R3 = regs.R29;
		/* 82191F80h case    0:*/		return 0x82191F84;
		  /* 82191F84h */ case    1:  		/* bl -105916 */
		/* 82191F84h case    1:*/		regs.LR = 0x82191F88; return 0x821781C8;
		/* 82191F84h case    1:*/		return 0x82191F88;
		  /* 82191F88h */ case    2:  		/* stw R3, <#[R29 + 48]> */
		/* 82191F88h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000030) );
		/* 82191F88h case    2:*/		return 0x82191F8C;
		  /* 82191F8Ch */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 82191F8Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82191F8Ch case    3:*/		return 0x82191F90;
		  /* 82191F90h */ case    4:  		/* bc 12, CR6_EQ, 56 */
		/* 82191F90h case    4:*/		if ( regs.CR[6].eq ) { return 0x82191FC8;  }
		/* 82191F90h case    4:*/		return 0x82191F94;
		  /* 82191F94h */ case    5:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 82191F94h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 82191F94h case    5:*/		return 0x82191F98;
		  /* 82191F98h */ case    6:  		/* lwz R9, <#[R30]> */
		/* 82191F98h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 82191F98h case    6:*/		return 0x82191F9C;
		  /* 82191F9Ch */ case    7:  		/* addi R10, R30, -36 */
		/* 82191F9Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0xFFFFFFDC);
		/* 82191F9Ch case    7:*/		return 0x82191FA0;
		  /* 82191FA0h */ case    8:  		/* addi R11, R11, 36 */
		/* 82191FA0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82191FA0h case    8:*/		return 0x82191FA4;
		  /* 82191FA4h */ case    9:  		/* ori R8, R10, 1 */
		/* 82191FA4h case    9:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 82191FA4h case    9:*/		return 0x82191FA8;
		  /* 82191FA8h */ case   10:  		/* addi R7, R11, -36 */
		/* 82191FA8h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 82191FA8h case   10:*/		return 0x82191FAC;
		  /* 82191FACh */ case   11:  		/* addi R10, R11, 4 */
		/* 82191FACh case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82191FACh case   11:*/		return 0x82191FB0;
		  /* 82191FB0h */ case   12:  		/* stw R9, <#[R11]> */
		/* 82191FB0h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82191FB0h case   12:*/		return 0x82191FB4;
		  /* 82191FB4h */ case   13:  		/* lwz R9, <#[R30]> */
		/* 82191FB4h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 82191FB4h case   13:*/		return 0x82191FB8;
		  /* 82191FB8h */ case   14:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82191FB8h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82191FB8h case   14:*/		return 0x82191FBC;
		  /* 82191FBCh */ case   15:  		/* stw R7, <#[R9]> */
		/* 82191FBCh case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 82191FBCh case   15:*/		return 0x82191FC0;
		  /* 82191FC0h */ case   16:  		/* stw R8, <#[R11 + 4]> */
		/* 82191FC0h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82191FC0h case   16:*/		return 0x82191FC4;
		  /* 82191FC4h */ case   17:  		/* stw R10, <#[R30]> */
		/* 82191FC4h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82191FC4h case   17:*/		return 0x82191FC8;
	}
	return 0x82191FC8;
} // Block from 82191F80h-82191FC8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82191FC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191FC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191FC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191FC8);
		  /* 82191FC8h */ case    0:  		/* mr R3, R29 */
		/* 82191FC8h case    0:*/		regs.R3 = regs.R29;
		/* 82191FC8h case    0:*/		return 0x82191FCC;
		  /* 82191FCCh */ case    1:  		/* addi R1, R1, 128 */
		/* 82191FCCh case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82191FCCh case    1:*/		return 0x82191FD0;
		  /* 82191FD0h */ case    2:  		/* b -1051948 */
		/* 82191FD0h case    2:*/		return 0x820912A4;
		/* 82191FD0h case    2:*/		return 0x82191FD4;
		  /* 82191FD4h */ case    3:  		/* nop */
		/* 82191FD4h case    3:*/		cpu::op::nop();
		/* 82191FD4h case    3:*/		return 0x82191FD8;
	}
	return 0x82191FD8;
} // Block from 82191FC8h-82191FD8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82191FD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82191FD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82191FD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82191FD8);
		  /* 82191FD8h */ case    0:  		/* mfspr R12, LR */
		/* 82191FD8h case    0:*/		regs.R12 = regs.LR;
		/* 82191FD8h case    0:*/		return 0x82191FDC;
		  /* 82191FDCh */ case    1:  		/* bl -1052036 */
		/* 82191FDCh case    1:*/		regs.LR = 0x82191FE0; return 0x82091258;
		/* 82191FDCh case    1:*/		return 0x82191FE0;
		  /* 82191FE0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82191FE0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82191FE0h case    2:*/		return 0x82191FE4;
		  /* 82191FE4h */ case    3:  		/* mr R31, R5 */
		/* 82191FE4h case    3:*/		regs.R31 = regs.R5;
		/* 82191FE4h case    3:*/		return 0x82191FE8;
		  /* 82191FE8h */ case    4:  		/* mr R30, R6 */
		/* 82191FE8h case    4:*/		regs.R30 = regs.R6;
		/* 82191FE8h case    4:*/		return 0x82191FEC;
		  /* 82191FECh */ case    5:  		/* li R8, 4 */
		/* 82191FECh case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 82191FECh case    5:*/		return 0x82191FF0;
		  /* 82191FF0h */ case    6:  		/* li R7, 1 */
		/* 82191FF0h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82191FF0h case    6:*/		return 0x82191FF4;
		  /* 82191FF4h */ case    7:  		/* li R6, 98 */
		/* 82191FF4h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x62);
		/* 82191FF4h case    7:*/		return 0x82191FF8;
		  /* 82191FF8h */ case    8:  		/* li R5, 0 */
		/* 82191FF8h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82191FF8h case    8:*/		return 0x82191FFC;
		  /* 82191FFCh */ case    9:  		/* mr R29, R3 */
		/* 82191FFCh case    9:*/		regs.R29 = regs.R3;
		/* 82191FFCh case    9:*/		return 0x82192000;
		  /* 82192000h */ case   10:  		/* bl 600472 */
		/* 82192000h case   10:*/		regs.LR = 0x82192004; return 0x82224998;
		/* 82192000h case   10:*/		return 0x82192004;
		  /* 82192004h */ case   11:  		/* lwz R11, <#[R30 + 16]> */
		/* 82192004h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82192004h case   11:*/		return 0x82192008;
		  /* 82192008h */ case   12:  		/* mr R28, R3 */
		/* 82192008h case   12:*/		regs.R28 = regs.R3;
		/* 82192008h case   12:*/		return 0x8219200C;
		  /* 8219200Ch */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 8219200Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219200Ch case   13:*/		return 0x82192010;
		  /* 82192010h */ case   14:  		/* mr R4, R30 */
		/* 82192010h case   14:*/		regs.R4 = regs.R30;
		/* 82192010h case   14:*/		return 0x82192014;
		  /* 82192014h */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 82192014h case   15:*/		if ( regs.CR[6].eq ) { return 0x82192028;  }
		/* 82192014h case   15:*/		return 0x82192018;
		  /* 82192018h */ case   16:  		/* mr R3, R29 */
		/* 82192018h case   16:*/		regs.R3 = regs.R29;
		/* 82192018h case   16:*/		return 0x8219201C;
		  /* 8219201Ch */ case   17:  		/* lwz R5, <#[R30 + 12]> */
		/* 8219201Ch case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 8219201Ch case   17:*/		return 0x82192020;
		  /* 82192020h */ case   18:  		/* bl -134960 */
		/* 82192020h case   18:*/		regs.LR = 0x82192024; return 0x821710F0;
		/* 82192020h case   18:*/		return 0x82192024;
		  /* 82192024h */ case   19:  		/* mr R4, R3 */
		/* 82192024h case   19:*/		regs.R4 = regs.R3;
		/* 82192024h case   19:*/		return 0x82192028;
	}
	return 0x82192028;
} // Block from 82191FD8h-82192028h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82192028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192028);
		  /* 82192028h */ case    0:  		/* mr R3, R28 */
		/* 82192028h case    0:*/		regs.R3 = regs.R28;
		/* 82192028h case    0:*/		return 0x8219202C;
		  /* 8219202Ch */ case    1:  		/* bl -106084 */
		/* 8219202Ch case    1:*/		regs.LR = 0x82192030; return 0x821781C8;
		/* 8219202Ch case    1:*/		return 0x82192030;
		  /* 82192030h */ case    2:  		/* stw R3, <#[R28 + 44]> */
		/* 82192030h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x0000002C) );
		/* 82192030h case    2:*/		return 0x82192034;
		  /* 82192034h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 82192034h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82192034h case    3:*/		return 0x82192038;
		  /* 82192038h */ case    4:  		/* bc 12, CR6_EQ, 56 */
		/* 82192038h case    4:*/		if ( regs.CR[6].eq ) { return 0x82192070;  }
		/* 82192038h case    4:*/		return 0x8219203C;
		  /* 8219203Ch */ case    5:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 8219203Ch case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 8219203Ch case    5:*/		return 0x82192040;
		  /* 82192040h */ case    6:  		/* lwz R9, <#[R31]> */
		/* 82192040h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82192040h case    6:*/		return 0x82192044;
		  /* 82192044h */ case    7:  		/* addi R10, R31, -36 */
		/* 82192044h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFDC);
		/* 82192044h case    7:*/		return 0x82192048;
		  /* 82192048h */ case    8:  		/* addi R11, R11, 36 */
		/* 82192048h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82192048h case    8:*/		return 0x8219204C;
		  /* 8219204Ch */ case    9:  		/* ori R8, R10, 1 */
		/* 8219204Ch case    9:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 8219204Ch case    9:*/		return 0x82192050;
		  /* 82192050h */ case   10:  		/* addi R7, R11, -36 */
		/* 82192050h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 82192050h case   10:*/		return 0x82192054;
		  /* 82192054h */ case   11:  		/* addi R10, R11, 4 */
		/* 82192054h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82192054h case   11:*/		return 0x82192058;
		  /* 82192058h */ case   12:  		/* stw R9, <#[R11]> */
		/* 82192058h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82192058h case   12:*/		return 0x8219205C;
		  /* 8219205Ch */ case   13:  		/* lwz R9, <#[R31]> */
		/* 8219205Ch case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8219205Ch case   13:*/		return 0x82192060;
		  /* 82192060h */ case   14:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82192060h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82192060h case   14:*/		return 0x82192064;
		  /* 82192064h */ case   15:  		/* stw R7, <#[R9]> */
		/* 82192064h case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 82192064h case   15:*/		return 0x82192068;
		  /* 82192068h */ case   16:  		/* stw R8, <#[R11 + 4]> */
		/* 82192068h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82192068h case   16:*/		return 0x8219206C;
		  /* 8219206Ch */ case   17:  		/* stw R10, <#[R31]> */
		/* 8219206Ch case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8219206Ch case   17:*/		return 0x82192070;
	}
	return 0x82192070;
} // Block from 82192028h-82192070h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82192070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192070);
		  /* 82192070h */ case    0:  		/* mr R3, R28 */
		/* 82192070h case    0:*/		regs.R3 = regs.R28;
		/* 82192070h case    0:*/		return 0x82192074;
		  /* 82192074h */ case    1:  		/* addi R1, R1, 128 */
		/* 82192074h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82192074h case    1:*/		return 0x82192078;
		  /* 82192078h */ case    2:  		/* b -1052112 */
		/* 82192078h case    2:*/		return 0x820912A8;
		/* 82192078h case    2:*/		return 0x8219207C;
		  /* 8219207Ch */ case    3:  		/* nop */
		/* 8219207Ch case    3:*/		cpu::op::nop();
		/* 8219207Ch case    3:*/		return 0x82192080;
	}
	return 0x82192080;
} // Block from 82192070h-82192080h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82192080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192080);
		  /* 82192080h */ case    0:  		/* mfspr R12, LR */
		/* 82192080h case    0:*/		regs.R12 = regs.LR;
		/* 82192080h case    0:*/		return 0x82192084;
		  /* 82192084h */ case    1:  		/* bl -1052204 */
		/* 82192084h case    1:*/		regs.LR = 0x82192088; return 0x82091258;
		/* 82192084h case    1:*/		return 0x82192088;
		  /* 82192088h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82192088h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82192088h case    2:*/		return 0x8219208C;
		  /* 8219208Ch */ case    3:  		/* mr R31, R5 */
		/* 8219208Ch case    3:*/		regs.R31 = regs.R5;
		/* 8219208Ch case    3:*/		return 0x82192090;
		  /* 82192090h */ case    4:  		/* mr R30, R6 */
		/* 82192090h case    4:*/		regs.R30 = regs.R6;
		/* 82192090h case    4:*/		return 0x82192094;
		  /* 82192094h */ case    5:  		/* li R8, 4 */
		/* 82192094h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 82192094h case    5:*/		return 0x82192098;
		  /* 82192098h */ case    6:  		/* li R7, 1 */
		/* 82192098h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82192098h case    6:*/		return 0x8219209C;
		  /* 8219209Ch */ case    7:  		/* li R6, 101 */
		/* 8219209Ch case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x65);
		/* 8219209Ch case    7:*/		return 0x821920A0;
		  /* 821920A0h */ case    8:  		/* li R5, 0 */
		/* 821920A0h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821920A0h case    8:*/		return 0x821920A4;
		  /* 821920A4h */ case    9:  		/* mr R29, R3 */
		/* 821920A4h case    9:*/		regs.R29 = regs.R3;
		/* 821920A4h case    9:*/		return 0x821920A8;
		  /* 821920A8h */ case   10:  		/* bl 600304 */
		/* 821920A8h case   10:*/		regs.LR = 0x821920AC; return 0x82224998;
		/* 821920A8h case   10:*/		return 0x821920AC;
		  /* 821920ACh */ case   11:  		/* lwz R11, <#[R30 + 16]> */
		/* 821920ACh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 821920ACh case   11:*/		return 0x821920B0;
		  /* 821920B0h */ case   12:  		/* mr R28, R3 */
		/* 821920B0h case   12:*/		regs.R28 = regs.R3;
		/* 821920B0h case   12:*/		return 0x821920B4;
		  /* 821920B4h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 821920B4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821920B4h case   13:*/		return 0x821920B8;
		  /* 821920B8h */ case   14:  		/* mr R4, R30 */
		/* 821920B8h case   14:*/		regs.R4 = regs.R30;
		/* 821920B8h case   14:*/		return 0x821920BC;
		  /* 821920BCh */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 821920BCh case   15:*/		if ( regs.CR[6].eq ) { return 0x821920D0;  }
		/* 821920BCh case   15:*/		return 0x821920C0;
		  /* 821920C0h */ case   16:  		/* mr R3, R29 */
		/* 821920C0h case   16:*/		regs.R3 = regs.R29;
		/* 821920C0h case   16:*/		return 0x821920C4;
		  /* 821920C4h */ case   17:  		/* lwz R5, <#[R30 + 12]> */
		/* 821920C4h case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 821920C4h case   17:*/		return 0x821920C8;
		  /* 821920C8h */ case   18:  		/* bl -135128 */
		/* 821920C8h case   18:*/		regs.LR = 0x821920CC; return 0x821710F0;
		/* 821920C8h case   18:*/		return 0x821920CC;
		  /* 821920CCh */ case   19:  		/* mr R4, R3 */
		/* 821920CCh case   19:*/		regs.R4 = regs.R3;
		/* 821920CCh case   19:*/		return 0x821920D0;
	}
	return 0x821920D0;
} // Block from 82192080h-821920D0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821920D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821920D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821920D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821920D0);
		  /* 821920D0h */ case    0:  		/* mr R3, R28 */
		/* 821920D0h case    0:*/		regs.R3 = regs.R28;
		/* 821920D0h case    0:*/		return 0x821920D4;
		  /* 821920D4h */ case    1:  		/* bl -106252 */
		/* 821920D4h case    1:*/		regs.LR = 0x821920D8; return 0x821781C8;
		/* 821920D4h case    1:*/		return 0x821920D8;
		  /* 821920D8h */ case    2:  		/* stw R3, <#[R28 + 44]> */
		/* 821920D8h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x0000002C) );
		/* 821920D8h case    2:*/		return 0x821920DC;
		  /* 821920DCh */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 821920DCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821920DCh case    3:*/		return 0x821920E0;
		  /* 821920E0h */ case    4:  		/* bc 12, CR6_EQ, 56 */
		/* 821920E0h case    4:*/		if ( regs.CR[6].eq ) { return 0x82192118;  }
		/* 821920E0h case    4:*/		return 0x821920E4;
		  /* 821920E4h */ case    5:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 821920E4h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 821920E4h case    5:*/		return 0x821920E8;
		  /* 821920E8h */ case    6:  		/* lwz R9, <#[R31]> */
		/* 821920E8h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821920E8h case    6:*/		return 0x821920EC;
		  /* 821920ECh */ case    7:  		/* addi R10, R31, -36 */
		/* 821920ECh case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFDC);
		/* 821920ECh case    7:*/		return 0x821920F0;
		  /* 821920F0h */ case    8:  		/* addi R11, R11, 36 */
		/* 821920F0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821920F0h case    8:*/		return 0x821920F4;
		  /* 821920F4h */ case    9:  		/* ori R8, R10, 1 */
		/* 821920F4h case    9:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 821920F4h case    9:*/		return 0x821920F8;
		  /* 821920F8h */ case   10:  		/* addi R7, R11, -36 */
		/* 821920F8h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 821920F8h case   10:*/		return 0x821920FC;
		  /* 821920FCh */ case   11:  		/* addi R10, R11, 4 */
		/* 821920FCh case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821920FCh case   11:*/		return 0x82192100;
		  /* 82192100h */ case   12:  		/* stw R9, <#[R11]> */
		/* 82192100h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82192100h case   12:*/		return 0x82192104;
		  /* 82192104h */ case   13:  		/* lwz R9, <#[R31]> */
		/* 82192104h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82192104h case   13:*/		return 0x82192108;
		  /* 82192108h */ case   14:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82192108h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82192108h case   14:*/		return 0x8219210C;
		  /* 8219210Ch */ case   15:  		/* stw R7, <#[R9]> */
		/* 8219210Ch case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 8219210Ch case   15:*/		return 0x82192110;
		  /* 82192110h */ case   16:  		/* stw R8, <#[R11 + 4]> */
		/* 82192110h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82192110h case   16:*/		return 0x82192114;
		  /* 82192114h */ case   17:  		/* stw R10, <#[R31]> */
		/* 82192114h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82192114h case   17:*/		return 0x82192118;
	}
	return 0x82192118;
} // Block from 821920D0h-82192118h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82192118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192118);
		  /* 82192118h */ case    0:  		/* mr R3, R28 */
		/* 82192118h case    0:*/		regs.R3 = regs.R28;
		/* 82192118h case    0:*/		return 0x8219211C;
		  /* 8219211Ch */ case    1:  		/* addi R1, R1, 128 */
		/* 8219211Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8219211Ch case    1:*/		return 0x82192120;
		  /* 82192120h */ case    2:  		/* b -1052280 */
		/* 82192120h case    2:*/		return 0x820912A8;
		/* 82192120h case    2:*/		return 0x82192124;
		  /* 82192124h */ case    3:  		/* nop */
		/* 82192124h case    3:*/		cpu::op::nop();
		/* 82192124h case    3:*/		return 0x82192128;
	}
	return 0x82192128;
} // Block from 82192118h-82192128h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82192128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192128);
		  /* 82192128h */ case    0:  		/* mfspr R12, LR */
		/* 82192128h case    0:*/		regs.R12 = regs.LR;
		/* 82192128h case    0:*/		return 0x8219212C;
		  /* 8219212Ch */ case    1:  		/* bl -1052372 */
		/* 8219212Ch case    1:*/		regs.LR = 0x82192130; return 0x82091258;
		/* 8219212Ch case    1:*/		return 0x82192130;
		  /* 82192130h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82192130h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82192130h case    2:*/		return 0x82192134;
		  /* 82192134h */ case    3:  		/* mr R31, R5 */
		/* 82192134h case    3:*/		regs.R31 = regs.R5;
		/* 82192134h case    3:*/		return 0x82192138;
		  /* 82192138h */ case    4:  		/* mr R30, R6 */
		/* 82192138h case    4:*/		regs.R30 = regs.R6;
		/* 82192138h case    4:*/		return 0x8219213C;
		  /* 8219213Ch */ case    5:  		/* li R8, 4 */
		/* 8219213Ch case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 8219213Ch case    5:*/		return 0x82192140;
		  /* 82192140h */ case    6:  		/* li R7, 1 */
		/* 82192140h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82192140h case    6:*/		return 0x82192144;
		  /* 82192144h */ case    7:  		/* li R6, 102 */
		/* 82192144h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x66);
		/* 82192144h case    7:*/		return 0x82192148;
		  /* 82192148h */ case    8:  		/* li R5, 0 */
		/* 82192148h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82192148h case    8:*/		return 0x8219214C;
		  /* 8219214Ch */ case    9:  		/* mr R29, R3 */
		/* 8219214Ch case    9:*/		regs.R29 = regs.R3;
		/* 8219214Ch case    9:*/		return 0x82192150;
		  /* 82192150h */ case   10:  		/* bl 600136 */
		/* 82192150h case   10:*/		regs.LR = 0x82192154; return 0x82224998;
		/* 82192150h case   10:*/		return 0x82192154;
		  /* 82192154h */ case   11:  		/* lwz R11, <#[R30 + 16]> */
		/* 82192154h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82192154h case   11:*/		return 0x82192158;
		  /* 82192158h */ case   12:  		/* mr R28, R3 */
		/* 82192158h case   12:*/		regs.R28 = regs.R3;
		/* 82192158h case   12:*/		return 0x8219215C;
		  /* 8219215Ch */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 8219215Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219215Ch case   13:*/		return 0x82192160;
		  /* 82192160h */ case   14:  		/* mr R4, R30 */
		/* 82192160h case   14:*/		regs.R4 = regs.R30;
		/* 82192160h case   14:*/		return 0x82192164;
		  /* 82192164h */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 82192164h case   15:*/		if ( regs.CR[6].eq ) { return 0x82192178;  }
		/* 82192164h case   15:*/		return 0x82192168;
		  /* 82192168h */ case   16:  		/* mr R3, R29 */
		/* 82192168h case   16:*/		regs.R3 = regs.R29;
		/* 82192168h case   16:*/		return 0x8219216C;
		  /* 8219216Ch */ case   17:  		/* lwz R5, <#[R30 + 12]> */
		/* 8219216Ch case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 8219216Ch case   17:*/		return 0x82192170;
		  /* 82192170h */ case   18:  		/* bl -135296 */
		/* 82192170h case   18:*/		regs.LR = 0x82192174; return 0x821710F0;
		/* 82192170h case   18:*/		return 0x82192174;
		  /* 82192174h */ case   19:  		/* mr R4, R3 */
		/* 82192174h case   19:*/		regs.R4 = regs.R3;
		/* 82192174h case   19:*/		return 0x82192178;
	}
	return 0x82192178;
} // Block from 82192128h-82192178h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82192178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192178);
		  /* 82192178h */ case    0:  		/* mr R3, R28 */
		/* 82192178h case    0:*/		regs.R3 = regs.R28;
		/* 82192178h case    0:*/		return 0x8219217C;
		  /* 8219217Ch */ case    1:  		/* bl -106420 */
		/* 8219217Ch case    1:*/		regs.LR = 0x82192180; return 0x821781C8;
		/* 8219217Ch case    1:*/		return 0x82192180;
		  /* 82192180h */ case    2:  		/* stw R3, <#[R28 + 44]> */
		/* 82192180h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x0000002C) );
		/* 82192180h case    2:*/		return 0x82192184;
		  /* 82192184h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 82192184h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82192184h case    3:*/		return 0x82192188;
		  /* 82192188h */ case    4:  		/* bc 12, CR6_EQ, 56 */
		/* 82192188h case    4:*/		if ( regs.CR[6].eq ) { return 0x821921C0;  }
		/* 82192188h case    4:*/		return 0x8219218C;
		  /* 8219218Ch */ case    5:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 8219218Ch case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 8219218Ch case    5:*/		return 0x82192190;
		  /* 82192190h */ case    6:  		/* lwz R9, <#[R31]> */
		/* 82192190h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82192190h case    6:*/		return 0x82192194;
		  /* 82192194h */ case    7:  		/* addi R10, R31, -36 */
		/* 82192194h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFDC);
		/* 82192194h case    7:*/		return 0x82192198;
		  /* 82192198h */ case    8:  		/* addi R11, R11, 36 */
		/* 82192198h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82192198h case    8:*/		return 0x8219219C;
		  /* 8219219Ch */ case    9:  		/* ori R8, R10, 1 */
		/* 8219219Ch case    9:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 8219219Ch case    9:*/		return 0x821921A0;
		  /* 821921A0h */ case   10:  		/* addi R7, R11, -36 */
		/* 821921A0h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 821921A0h case   10:*/		return 0x821921A4;
		  /* 821921A4h */ case   11:  		/* addi R10, R11, 4 */
		/* 821921A4h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821921A4h case   11:*/		return 0x821921A8;
		  /* 821921A8h */ case   12:  		/* stw R9, <#[R11]> */
		/* 821921A8h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821921A8h case   12:*/		return 0x821921AC;
		  /* 821921ACh */ case   13:  		/* lwz R9, <#[R31]> */
		/* 821921ACh case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821921ACh case   13:*/		return 0x821921B0;
		  /* 821921B0h */ case   14:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 821921B0h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 821921B0h case   14:*/		return 0x821921B4;
		  /* 821921B4h */ case   15:  		/* stw R7, <#[R9]> */
		/* 821921B4h case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 821921B4h case   15:*/		return 0x821921B8;
		  /* 821921B8h */ case   16:  		/* stw R8, <#[R11 + 4]> */
		/* 821921B8h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821921B8h case   16:*/		return 0x821921BC;
		  /* 821921BCh */ case   17:  		/* stw R10, <#[R31]> */
		/* 821921BCh case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821921BCh case   17:*/		return 0x821921C0;
	}
	return 0x821921C0;
} // Block from 82192178h-821921C0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821921C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821921C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821921C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821921C0);
		  /* 821921C0h */ case    0:  		/* mr R3, R28 */
		/* 821921C0h case    0:*/		regs.R3 = regs.R28;
		/* 821921C0h case    0:*/		return 0x821921C4;
		  /* 821921C4h */ case    1:  		/* addi R1, R1, 128 */
		/* 821921C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821921C4h case    1:*/		return 0x821921C8;
		  /* 821921C8h */ case    2:  		/* b -1052448 */
		/* 821921C8h case    2:*/		return 0x820912A8;
		/* 821921C8h case    2:*/		return 0x821921CC;
		  /* 821921CCh */ case    3:  		/* nop */
		/* 821921CCh case    3:*/		cpu::op::nop();
		/* 821921CCh case    3:*/		return 0x821921D0;
	}
	return 0x821921D0;
} // Block from 821921C0h-821921D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821921D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821921D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821921D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821921D0);
		  /* 821921D0h */ case    0:  		/* mfspr R12, LR */
		/* 821921D0h case    0:*/		regs.R12 = regs.LR;
		/* 821921D0h case    0:*/		return 0x821921D4;
		  /* 821921D4h */ case    1:  		/* bl -1052568 */
		/* 821921D4h case    1:*/		regs.LR = 0x821921D8; return 0x8209123C;
		/* 821921D4h case    1:*/		return 0x821921D8;
		  /* 821921D8h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 821921D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 821921D8h case    2:*/		return 0x821921DC;
		  /* 821921DCh */ case    3:  		/* lwz R11, <#[R4 + 20]> */
		/* 821921DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000014) );
		/* 821921DCh case    3:*/		return 0x821921E0;
		  /* 821921E0h */ case    4:  		/* mr R31, R3 */
		/* 821921E0h case    4:*/		regs.R31 = regs.R3;
		/* 821921E0h case    4:*/		return 0x821921E4;
		  /* 821921E4h */ case    5:  		/* mr R29, R4 */
		/* 821921E4h case    5:*/		regs.R29 = regs.R4;
		/* 821921E4h case    5:*/		return 0x821921E8;
		  /* 821921E8h */ case    6:  		/* rlwinm. R10, R11, 6, 31, 31 */
		/* 821921E8h case    6:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R10,regs.R11);
		/* 821921E8h case    6:*/		return 0x821921EC;
		  /* 821921ECh */ case    7:  		/* bc 4, CR0_EQ, 976 */
		/* 821921ECh case    7:*/		if ( !regs.CR[0].eq ) { return 0x821925BC;  }
		/* 821921ECh case    7:*/		return 0x821921F0;
		  /* 821921F0h */ case    8:  		/* lwz R8, <#[R4 + 8]> */
		/* 821921F0h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000008) );
		/* 821921F0h case    8:*/		return 0x821921F4;
		  /* 821921F4h */ case    9:  		/* oris R11, R11, 1024 */
		/* 821921F4h case    9:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x400);
		/* 821921F4h case    9:*/		return 0x821921F8;
		  /* 821921F8h */ case   10:  		/* mr R21, R3 */
		/* 821921F8h case   10:*/		regs.R21 = regs.R3;
		/* 821921F8h case   10:*/		return 0x821921FC;
		  /* 821921FCh */ case   11:  		/* rlwinm R10, R8, 25, 25, 31 */
		/* 821921FCh case   11:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R8);
		/* 821921FCh case   11:*/		return 0x82192200;
		  /* 82192200h */ case   12:  		/* stw R11, <#[R4 + 20]> */
		/* 82192200h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000014) );
		/* 82192200h case   12:*/		return 0x82192204;
		  /* 82192204h */ case   13:  		/* cmplwi CR6, R10, 1 */
		/* 82192204h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 82192204h case   13:*/		return 0x82192208;
		  /* 82192208h */ case   14:  		/* bc 12, CR6_LT, 16 */
		/* 82192208h case   14:*/		if ( regs.CR[6].lt ) { return 0x82192218;  }
		/* 82192208h case   14:*/		return 0x8219220C;
		  /* 8219220Ch */ case   15:  		/* cmplwi CR6, R10, 102 */
		/* 8219220Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000066);
		/* 8219220Ch case   15:*/		return 0x82192210;
		  /* 82192210h */ case   16:  		/* li R9, 1 */
		/* 82192210h case   16:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82192210h case   16:*/		return 0x82192214;
		  /* 82192214h */ case   17:  		/* bc 4, CR6_GT, 8 */
		/* 82192214h case   17:*/		if ( !regs.CR[6].gt ) { return 0x8219221C;  }
		/* 82192214h case   17:*/		return 0x82192218;
	}
	return 0x82192218;
} // Block from 821921D0h-82192218h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82192218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192218);
		  /* 82192218h */ case    0:  		/* li R9, 0 */
		/* 82192218h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82192218h case    0:*/		return 0x8219221C;
	}
	return 0x8219221C;
} // Block from 82192218h-8219221Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219221Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219221C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219221C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219221C);
		  /* 8219221Ch */ case    0:  		/* rlwinm. R9, R9, 0, 24, 31 */
		/* 8219221Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R9);
		/* 8219221Ch case    0:*/		return 0x82192220;
		  /* 82192220h */ case    1:  		/* bc 12, CR0_EQ, 912 */
		/* 82192220h case    1:*/		if ( regs.CR[0].eq ) { return 0x821925B0;  }
		/* 82192220h case    1:*/		return 0x82192224;
		  /* 82192224h */ case    2:  		/* rlwinm R22, R11, 19, 19, 31 */
		/* 82192224h case    2:*/		cpu::op::rlwinm<0,19,19,31>(regs,&regs.R22,regs.R11);
		/* 82192224h case    2:*/		return 0x82192228;
		  /* 82192228h */ case    3:  		/* cmplwi CR6, R10, 1 */
		/* 82192228h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 82192228h case    3:*/		return 0x8219222C;
		  /* 8219222Ch */ case    4:  		/* bc 12, CR6_LT, 16 */
		/* 8219222Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x8219223C;  }
		/* 8219222Ch case    4:*/		return 0x82192230;
		  /* 82192230h */ case    5:  		/* cmplwi CR6, R10, 31 */
		/* 82192230h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000001F);
		/* 82192230h case    5:*/		return 0x82192234;
		  /* 82192234h */ case    6:  		/* li R11, 1 */
		/* 82192234h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192234h case    6:*/		return 0x82192238;
		  /* 82192238h */ case    7:  		/* bc 4, CR6_GT, 8 */
		/* 82192238h case    7:*/		if ( !regs.CR[6].gt ) { return 0x82192240;  }
		/* 82192238h case    7:*/		return 0x8219223C;
	}
	return 0x8219223C;
} // Block from 8219221Ch-8219223Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219223Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219223C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219223C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219223C);
		  /* 8219223Ch */ case    0:  		/* li R11, 0 */
		/* 8219223Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219223Ch case    0:*/		return 0x82192240;
	}
	return 0x82192240;
} // Block from 8219223Ch-82192240h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192240);
		  /* 82192240h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192240h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192240h case    0:*/		return 0x82192244;
		  /* 82192244h */ case    1:  		/* mr R23, R11 */
		/* 82192244h case    1:*/		regs.R23 = regs.R11;
		/* 82192244h case    1:*/		return 0x82192248;
		  /* 82192248h */ case    2:  		/* bc 12, CR0_EQ, 60 */
		/* 82192248h case    2:*/		if ( regs.CR[0].eq ) { return 0x82192284;  }
		/* 82192248h case    2:*/		return 0x8219224C;
		  /* 8219224Ch */ case    3:  		/* cmplwi CR0, R10, 0 */
		/* 8219224Ch case    3:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 8219224Ch case    3:*/		return 0x82192250;
		  /* 82192250h */ case    4:  		/* bc 12, CR0_EQ, 36 */
		/* 82192250h case    4:*/		if ( regs.CR[0].eq ) { return 0x82192274;  }
		/* 82192250h case    4:*/		return 0x82192254;
		  /* 82192254h */ case    5:  		/* cmplwi CR6, R10, 11 */
		/* 82192254h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000000B);
		/* 82192254h case    5:*/		return 0x82192258;
		  /* 82192258h */ case    6:  		/* bc 4, CR6_GT, 20 */
		/* 82192258h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8219226C;  }
		/* 82192258h case    6:*/		return 0x8219225C;
		  /* 8219225Ch */ case    7:  		/* cmplwi CR6, R10, 24 */
		/* 8219225Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000018);
		/* 8219225Ch case    7:*/		return 0x82192260;
		  /* 82192260h */ case    8:  		/* bc 4, CR6_GT, 20 */
		/* 82192260h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82192274;  }
		/* 82192260h case    8:*/		return 0x82192264;
		  /* 82192264h */ case    9:  		/* cmplwi CR6, R10, 28 */
		/* 82192264h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000001C);
		/* 82192264h case    9:*/		return 0x82192268;
		  /* 82192268h */ case   10:  		/* bc 12, CR6_GT, 12 */
		/* 82192268h case   10:*/		if ( regs.CR[6].gt ) { return 0x82192274;  }
		/* 82192268h case   10:*/		return 0x8219226C;
	}
	return 0x8219226C;
} // Block from 82192240h-8219226Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219226Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219226C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219226C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219226C);
		  /* 8219226Ch */ case    0:  		/* li R11, 1 */
		/* 8219226Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219226Ch case    0:*/		return 0x82192270;
		  /* 82192270h */ case    1:  		/* b 8 */
		/* 82192270h case    1:*/		return 0x82192278;
		/* 82192270h case    1:*/		return 0x82192274;
	}
	return 0x82192274;
} // Block from 8219226Ch-82192274h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82192274h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192274( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192274) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192274);
		  /* 82192274h */ case    0:  		/* li R11, 0 */
		/* 82192274h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192274h case    0:*/		return 0x82192278;
	}
	return 0x82192278;
} // Block from 82192274h-82192278h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192278);
		  /* 82192278h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192278h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192278h case    0:*/		return 0x8219227C;
		  /* 8219227Ch */ case    1:  		/* li R11, 1 */
		/* 8219227Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219227Ch case    1:*/		return 0x82192280;
		  /* 82192280h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 82192280h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82192288;  }
		/* 82192280h case    2:*/		return 0x82192284;
	}
	return 0x82192284;
} // Block from 82192278h-82192284h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82192284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192284);
		  /* 82192284h */ case    0:  		/* li R11, 0 */
		/* 82192284h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192284h case    0:*/		return 0x82192288;
	}
	return 0x82192288;
} // Block from 82192284h-82192288h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192288);
		  /* 82192288h */ case    0:  		/* lwz R10, <#[R29 + 16]> */
		/* 82192288h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000010) );
		/* 82192288h case    0:*/		return 0x8219228C;
		  /* 8219228Ch */ case    1:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219228Ch case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219228Ch case    1:*/		return 0x82192290;
		  /* 82192290h */ case    2:  		/* rlwinm R10, R10, 11, 29, 31 */
		/* 82192290h case    2:*/		cpu::op::rlwinm<0,11,29,31>(regs,&regs.R10,regs.R10);
		/* 82192290h case    2:*/		return 0x82192294;
		  /* 82192294h */ case    3:  		/* li R24, -1 */
		/* 82192294h case    3:*/		cpu::op::li<0>(regs,&regs.R24,0xFFFFFFFF);
		/* 82192294h case    3:*/		return 0x82192298;
	}
	return 0x82192298;
} // Block from 82192288h-82192298h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82192298h
// Function '?RemoveSmashedInstructions@Compiler@D3DXShader@@AAAXPAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192298);
		  /* 82192298h */ case    0:  		/* li R27, 0 */
		/* 82192298h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82192298h case    0:*/		return 0x8219229C;
		  /* 8219229Ch */ case    1:  		/* mr R25, R11 */
		/* 8219229Ch case    1:*/		regs.R25 = regs.R11;
		/* 8219229Ch case    1:*/		return 0x821922A0;
		  /* 821922A0h */ case    2:  		/* addi R26, R10, -1 */
		/* 821922A0h case    2:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R10,0xFFFFFFFF);
		/* 821922A0h case    2:*/		return 0x821922A4;
		  /* 821922A4h */ case    3:  		/* bc 12, CR0_EQ, 32 */
		/* 821922A4h case    3:*/		if ( regs.CR[0].eq ) { return 0x821922C4;  }
		/* 821922A4h case    3:*/		return 0x821922A8;
		  /* 821922A8h */ case    4:  		/* rlwinm. R11, R8, 7, 31, 31 */
		/* 821922A8h case    4:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R8);
		/* 821922A8h case    4:*/		return 0x821922AC;
		  /* 821922ACh */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 821922ACh case    5:*/		if ( regs.CR[0].eq ) { return 0x821922B8;  }
		/* 821922ACh case    5:*/		return 0x821922B0;
		  /* 821922B0h */ case    6:  		/* mr R27, R24 */
		/* 821922B0h case    6:*/		regs.R27 = regs.R24;
		/* 821922B0h case    6:*/		return 0x821922B4;
		  /* 821922B4h */ case    7:  		/* b 16 */
		/* 821922B4h case    7:*/		return 0x821922C4;
		/* 821922B4h case    7:*/		return 0x821922B8;
	}
	return 0x821922B8;
} // Block from 82192298h-821922B8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821922B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821922B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821922B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821922B8);
		  /* 821922B8h */ case    0:  		/* mr R3, R29 */
		/* 821922B8h case    0:*/		regs.R3 = regs.R29;
		/* 821922B8h case    0:*/		return 0x821922BC;
		  /* 821922BCh */ case    1:  		/* bl -5356 */
		/* 821922BCh case    1:*/		regs.LR = 0x821922C0; return 0x82190DD0;
		/* 821922BCh case    1:*/		return 0x821922C0;
		  /* 821922C0h */ case    2:  		/* mr R27, R3 */
		/* 821922C0h case    2:*/		regs.R27 = regs.R3;
		/* 821922C0h case    2:*/		return 0x821922C4;
	}
	return 0x821922C4;
} // Block from 821922B8h-821922C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821922C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821922C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821922C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821922C4);
		  /* 821922C4h */ case    0:  		/* lwz R10, <#[R29 + 4]> */
		/* 821922C4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 821922C4h case    0:*/		return 0x821922C8;
		  /* 821922C8h */ case    1:  		/* li R28, 0 */
		/* 821922C8h case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 821922C8h case    1:*/		return 0x821922CC;
		  /* 821922CCh */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 821922CCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821922CCh case    2:*/		return 0x821922D0;
		  /* 821922D0h */ case    3:  		/* bc 12, CR6_EQ, 84 */
		/* 821922D0h case    3:*/		if ( regs.CR[6].eq ) { return 0x82192324;  }
		/* 821922D0h case    3:*/		return 0x821922D4;
		  /* 821922D4h */ case    4:  		/* lwz R11, <#[R10 + 16]> */
		/* 821922D4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 821922D4h case    4:*/		return 0x821922D8;
		  /* 821922D8h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821922D8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821922D8h case    5:*/		return 0x821922DC;
		  /* 821922DCh */ case    6:  		/* bc 12, CR6_EQ, 64 */
		/* 821922DCh case    6:*/		if ( regs.CR[6].eq ) { return 0x8219231C;  }
		/* 821922DCh case    6:*/		return 0x821922E0;
		  /* 821922E0h */ case    7:  		/* lwz R9, <#[R10]> */
		/* 821922E0h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821922E0h case    7:*/		return 0x821922E4;
		  /* 821922E4h */ case    8:  		/* rlwinm. R9, R9, 0, 4, 6 */
		/* 821922E4h case    8:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R9);
		/* 821922E4h case    8:*/		return 0x821922E8;
		  /* 821922E8h */ case    9:  		/* bc 12, CR0_EQ, 52 */
		/* 821922E8h case    9:*/		if ( regs.CR[0].eq ) { return 0x8219231C;  }
		/* 821922E8h case    9:*/		return 0x821922EC;
		  /* 821922ECh */ case   10:  		/* lwz R9, <#[R11 + 28]> */
		/* 821922ECh case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000001C) );
		/* 821922ECh case   10:*/		return 0x821922F0;
		  /* 821922F0h */ case   11:  		/* lwz R8, <#[R29 + 28]> */
		/* 821922F0h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x0000001C) );
		/* 821922F0h case   11:*/		return 0x821922F4;
		  /* 821922F4h */ case   12:  		/* cmpw CR6, R9, R8 */
		/* 821922F4h case   12:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R8);
		/* 821922F4h case   12:*/		return 0x821922F8;
		  /* 821922F8h */ case   13:  		/* bc 4, CR6_EQ, 36 */
		/* 821922F8h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8219231C;  }
		/* 821922F8h case   13:*/		return 0x821922FC;
		  /* 821922FCh */ case   14:  		/* lbz R9, <#[R11 + 16]> */
		/* 821922FCh case   14:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 821922FCh case   14:*/		return 0x82192300;
		  /* 82192300h */ case   15:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 82192300h case   15:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 82192300h case   15:*/		return 0x82192304;
		  /* 82192304h */ case   16:  		/* bc 12, CR0_EQ, 24 */
		/* 82192304h case   16:*/		if ( regs.CR[0].eq ) { return 0x8219231C;  }
		/* 82192304h case   16:*/		return 0x82192308;
		  /* 82192308h */ case   17:  		/* lwz R11, <#[R11 + 20]> */
		/* 82192308h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82192308h case   17:*/		return 0x8219230C;
		  /* 8219230Ch */ case   18:  		/* rlwinm R11, R11, 0, 19, 31 */
		/* 8219230Ch case   18:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R11);
		/* 8219230Ch case   18:*/		return 0x82192310;
		  /* 82192310h */ case   19:  		/* cmplw CR6, R11, R28 */
		/* 82192310h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 82192310h case   19:*/		return 0x82192314;
		  /* 82192314h */ case   20:  		/* bc 4, CR6_GT, 8 */
		/* 82192314h case   20:*/		if ( !regs.CR[6].gt ) { return 0x8219231C;  }
		/* 82192314h case   20:*/		return 0x82192318;
		  /* 82192318h */ case   21:  		/* mr R28, R11 */
		/* 82192318h case   21:*/		regs.R28 = regs.R11;
		/* 82192318h case   21:*/		return 0x8219231C;
	}
	return 0x8219231C;
} // Block from 821922C4h-8219231Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 8219231Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219231C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219231C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219231C);
		  /* 8219231Ch */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 8219231Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8219231Ch case    0:*/		return 0x82192320;
		  /* 82192320h */ case    1:  		/* b -84 */
		/* 82192320h case    1:*/		return 0x821922CC;
		/* 82192320h case    1:*/		return 0x82192324;
	}
	return 0x82192324;
} // Block from 8219231Ch-82192324h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82192324h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192324( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192324) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192324);
		  /* 82192324h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 82192324h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82192324h case    0:*/		return 0x82192328;
		  /* 82192328h */ case    1:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 82192328h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 82192328h case    1:*/		return 0x8219232C;
		  /* 8219232Ch */ case    2:  		/* cmplwi CR6, R10, 91 */
		/* 8219232Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005B);
		/* 8219232Ch case    2:*/		return 0x82192330;
		  /* 82192330h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 82192330h case    3:*/		if ( regs.CR[6].lt ) { return 0x82192340;  }
		/* 82192330h case    3:*/		return 0x82192334;
		  /* 82192334h */ case    4:  		/* cmplwi CR6, R10, 94 */
		/* 82192334h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005E);
		/* 82192334h case    4:*/		return 0x82192338;
		  /* 82192338h */ case    5:  		/* li R11, 1 */
		/* 82192338h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192338h case    5:*/		return 0x8219233C;
		  /* 8219233Ch */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 8219233Ch case    6:*/		if ( !regs.CR[6].gt ) { return 0x82192344;  }
		/* 8219233Ch case    6:*/		return 0x82192340;
	}
	return 0x82192340;
} // Block from 82192324h-82192340h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82192340h
// Function '?InsertAtHead@?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@D3DXShader@@QAAXPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192340);
		  /* 82192340h */ case    0:  		/* li R11, 0 */
		/* 82192340h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192340h case    0:*/		return 0x82192344;
	}
	return 0x82192344;
} // Block from 82192340h-82192344h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192344h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192344( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192344) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192344);
		  /* 82192344h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192344h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192344h case    0:*/		return 0x82192348;
		  /* 82192348h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 82192348h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82192358;  }
		/* 82192348h case    1:*/		return 0x8219234C;
		  /* 8219234Ch */ case    2:  		/* cmplwi CR6, R10, 123 */
		/* 8219234Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007B);
		/* 8219234Ch case    2:*/		return 0x82192350;
		  /* 82192350h */ case    3:  		/* li R11, 0 */
		/* 82192350h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192350h case    3:*/		return 0x82192354;
		  /* 82192354h */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 82192354h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8219235C;  }
		/* 82192354h case    4:*/		return 0x82192358;
	}
	return 0x82192358;
} // Block from 82192344h-82192358h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82192358h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192358);
		  /* 82192358h */ case    0:  		/* li R11, 1 */
		/* 82192358h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192358h case    0:*/		return 0x8219235C;
	}
	return 0x8219235C;
} // Block from 82192358h-8219235Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219235Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219235C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219235C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219235C);
		  /* 8219235Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219235Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219235Ch case    0:*/		return 0x82192360;
		  /* 82192360h */ case    1:  		/* bc 4, CR0_EQ, 40 */
		/* 82192360h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82192388;  }
		/* 82192360h case    1:*/		return 0x82192364;
		  /* 82192364h */ case    2:  		/* cmplwi CR6, R10, 96 */
		/* 82192364h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000060);
		/* 82192364h case    2:*/		return 0x82192368;
		  /* 82192368h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 82192368h case    3:*/		if ( regs.CR[6].lt ) { return 0x82192378;  }
		/* 82192368h case    3:*/		return 0x8219236C;
		  /* 8219236Ch */ case    4:  		/* cmplwi CR6, R10, 102 */
		/* 8219236Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000066);
		/* 8219236Ch case    4:*/		return 0x82192370;
		  /* 82192370h */ case    5:  		/* li R11, 1 */
		/* 82192370h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192370h case    5:*/		return 0x82192374;
		  /* 82192374h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 82192374h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8219237C;  }
		/* 82192374h case    6:*/		return 0x82192378;
	}
	return 0x82192378;
} // Block from 8219235Ch-82192378h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82192378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192378);
		  /* 82192378h */ case    0:  		/* li R11, 0 */
		/* 82192378h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192378h case    0:*/		return 0x8219237C;
	}
	return 0x8219237C;
} // Block from 82192378h-8219237Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219237Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219237C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219237C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219237C);
		  /* 8219237Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219237Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219237Ch case    0:*/		return 0x82192380;
		  /* 82192380h */ case    1:  		/* li R11, 0 */
		/* 82192380h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192380h case    1:*/		return 0x82192384;
		  /* 82192384h */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 82192384h case    2:*/		if ( regs.CR[0].eq ) { return 0x8219238C;  }
		/* 82192384h case    2:*/		return 0x82192388;
	}
	return 0x82192388;
} // Block from 8219237Ch-82192388h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82192388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192388);
		  /* 82192388h */ case    0:  		/* li R11, 1 */
		/* 82192388h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192388h case    0:*/		return 0x8219238C;
	}
	return 0x8219238C;
} // Block from 82192388h-8219238Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219238Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219238C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219238C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219238C);
		  /* 8219238Ch */ case    0:  		/* lwz R31, <#[R31]> */
		/* 8219238Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000000) );
		/* 8219238Ch case    0:*/		return 0x82192390;
		  /* 82192390h */ case    1:  		/* rlwinm R30, R11, 0, 24, 31 */
		/* 82192390h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R30,regs.R11);
		/* 82192390h case    1:*/		return 0x82192394;
		  /* 82192394h */ case    2:  		/* b 532 */
		/* 82192394h case    2:*/		return 0x821925A8;
		/* 82192394h case    2:*/		return 0x82192398;
		  /* 82192398h */ case    3:  		/* lwz R7, <#[R31 + 8]> */
		/* 82192398h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000008) );
		/* 82192398h case    3:*/		return 0x8219239C;
		  /* 8219239Ch */ case    4:  		/* rlwinm R8, R7, 25, 25, 31 */
		/* 8219239Ch case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R8,regs.R7);
		/* 8219239Ch case    4:*/		return 0x821923A0;
		  /* 821923A0h */ case    5:  		/* cmplwi CR6, R8, 1 */
		/* 821923A0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000001);
		/* 821923A0h case    5:*/		return 0x821923A4;
		  /* 821923A4h */ case    6:  		/* bc 12, CR6_LT, 16 */
		/* 821923A4h case    6:*/		if ( regs.CR[6].lt ) { return 0x821923B4;  }
		/* 821923A4h case    6:*/		return 0x821923A8;
	}
	return 0x821923A8;
} // Block from 8219238Ch-821923A8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821923A8h
// Function '?CanHaveOrderingDependencies@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821923A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821923A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821923A8);
		  /* 821923A8h */ case    0:  		/* cmplwi CR6, R8, 102 */
		/* 821923A8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000066);
		/* 821923A8h case    0:*/		return 0x821923AC;
		  /* 821923ACh */ case    1:  		/* li R11, 1 */
		/* 821923ACh case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821923ACh case    1:*/		return 0x821923B0;
		  /* 821923B0h */ case    2:  		/* bc 4, CR6_GT, 8 */
		/* 821923B0h case    2:*/		if ( !regs.CR[6].gt ) { return 0x821923B8;  }
		/* 821923B0h case    2:*/		return 0x821923B4;
	}
	return 0x821923B4;
} // Block from 821923A8h-821923B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821923B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821923B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821923B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821923B4);
		  /* 821923B4h */ case    0:  		/* li R11, 0 */
		/* 821923B4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821923B4h case    0:*/		return 0x821923B8;
	}
	return 0x821923B8;
} // Block from 821923B4h-821923B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821923B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821923B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821923B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821923B8);
		  /* 821923B8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821923B8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821923B8h case    0:*/		return 0x821923BC;
		  /* 821923BCh */ case    1:  		/* bc 12, CR0_EQ, 484 */
		/* 821923BCh case    1:*/		if ( regs.CR[0].eq ) { return 0x821925A0;  }
		/* 821923BCh case    1:*/		return 0x821923C0;
		  /* 821923C0h */ case    2:  		/* rlwinm. R11, R30, 0, 24, 31 */
		/* 821923C0h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R30);
		/* 821923C0h case    2:*/		return 0x821923C4;
		  /* 821923C4h */ case    3:  		/* bc 12, CR0_EQ, 92 */
		/* 821923C4h case    3:*/		if ( regs.CR[0].eq ) { return 0x82192420;  }
		/* 821923C4h case    3:*/		return 0x821923C8;
		  /* 821923C8h */ case    4:  		/* cmplwi CR6, R8, 91 */
		/* 821923C8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000005B);
		/* 821923C8h case    4:*/		return 0x821923CC;
		  /* 821923CCh */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 821923CCh case    5:*/		if ( regs.CR[6].lt ) { return 0x821923DC;  }
		/* 821923CCh case    5:*/		return 0x821923D0;
		  /* 821923D0h */ case    6:  		/* cmplwi CR6, R8, 94 */
		/* 821923D0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000005E);
		/* 821923D0h case    6:*/		return 0x821923D4;
		  /* 821923D4h */ case    7:  		/* li R11, 1 */
		/* 821923D4h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821923D4h case    7:*/		return 0x821923D8;
		  /* 821923D8h */ case    8:  		/* bc 4, CR6_GT, 8 */
		/* 821923D8h case    8:*/		if ( !regs.CR[6].gt ) { return 0x821923E0;  }
		/* 821923D8h case    8:*/		return 0x821923DC;
	}
	return 0x821923DC;
} // Block from 821923B8h-821923DCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 821923DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821923DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821923DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821923DC);
		  /* 821923DCh */ case    0:  		/* li R11, 0 */
		/* 821923DCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821923DCh case    0:*/		return 0x821923E0;
	}
	return 0x821923E0;
} // Block from 821923DCh-821923E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821923E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821923E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821923E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821923E0);
		  /* 821923E0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821923E0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821923E0h case    0:*/		return 0x821923E4;
		  /* 821923E4h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 821923E4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821923F4;  }
		/* 821923E4h case    1:*/		return 0x821923E8;
		  /* 821923E8h */ case    2:  		/* cmplwi CR6, R8, 123 */
		/* 821923E8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000007B);
		/* 821923E8h case    2:*/		return 0x821923EC;
		  /* 821923ECh */ case    3:  		/* li R11, 0 */
		/* 821923ECh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821923ECh case    3:*/		return 0x821923F0;
		  /* 821923F0h */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 821923F0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821923F8;  }
		/* 821923F0h case    4:*/		return 0x821923F4;
	}
	return 0x821923F4;
} // Block from 821923E0h-821923F4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821923F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821923F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821923F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821923F4);
		  /* 821923F4h */ case    0:  		/* li R11, 1 */
		/* 821923F4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821923F4h case    0:*/		return 0x821923F8;
	}
	return 0x821923F8;
} // Block from 821923F4h-821923F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821923F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821923F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821923F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821923F8);
		  /* 821923F8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821923F8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821923F8h case    0:*/		return 0x821923FC;
		  /* 821923FCh */ case    1:  		/* bc 4, CR0_EQ, 36 */
		/* 821923FCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x82192420;  }
		/* 821923FCh case    1:*/		return 0x82192400;
		  /* 82192400h */ case    2:  		/* cmplwi CR6, R8, 96 */
		/* 82192400h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000060);
		/* 82192400h case    2:*/		return 0x82192404;
		  /* 82192404h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 82192404h case    3:*/		if ( regs.CR[6].lt ) { return 0x82192414;  }
		/* 82192404h case    3:*/		return 0x82192408;
		  /* 82192408h */ case    4:  		/* cmplwi CR6, R8, 102 */
		/* 82192408h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000066);
		/* 82192408h case    4:*/		return 0x8219240C;
		  /* 8219240Ch */ case    5:  		/* li R11, 1 */
		/* 8219240Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219240Ch case    5:*/		return 0x82192410;
		  /* 82192410h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 82192410h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82192418;  }
		/* 82192410h case    6:*/		return 0x82192414;
	}
	return 0x82192414;
} // Block from 821923F8h-82192414h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82192414h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192414);
		  /* 82192414h */ case    0:  		/* li R11, 0 */
		/* 82192414h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192414h case    0:*/		return 0x82192418;
	}
	return 0x82192418;
} // Block from 82192414h-82192418h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192418h
// Function '?MakeInstr_V_MAXA@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@PAVDependency@2@2@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192418);
		  /* 82192418h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192418h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192418h case    0:*/		return 0x8219241C;
		  /* 8219241Ch */ case    1:  		/* bc 12, CR0_EQ, 388 */
		/* 8219241Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821925A0;  }
		/* 8219241Ch case    1:*/		return 0x82192420;
	}
	return 0x82192420;
} // Block from 82192418h-82192420h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82192420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192420);
		  /* 82192420h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 82192420h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82192420h case    0:*/		return 0x82192424;
		  /* 82192424h */ case    1:  		/* rlwinm R11, R11, 19, 19, 31 */
		/* 82192424h case    1:*/		cpu::op::rlwinm<0,19,19,31>(regs,&regs.R11,regs.R11);
		/* 82192424h case    1:*/		return 0x82192428;
		  /* 82192428h */ case    2:  		/* cmplw CR6, R22, R11 */
		/* 82192428h case    2:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 82192428h case    2:*/		return 0x8219242C;
		  /* 8219242Ch */ case    3:  		/* bc 12, CR6_GT, 388 */
		/* 8219242Ch case    3:*/		if ( regs.CR[6].gt ) { return 0x821925B0;  }
		/* 8219242Ch case    3:*/		return 0x82192430;
		  /* 82192430h */ case    4:  		/* bc 12, CR6_LT, 368 */
		/* 82192430h case    4:*/		if ( regs.CR[6].lt ) { return 0x821925A0;  }
		/* 82192430h case    4:*/		return 0x82192434;
		  /* 82192434h */ case    5:  		/* cmplwi CR6, R23, 0 */
		/* 82192434h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 82192434h case    5:*/		return 0x82192438;
		  /* 82192438h */ case    6:  		/* bc 12, CR6_EQ, 172 */
		/* 82192438h case    6:*/		if ( regs.CR[6].eq ) { return 0x821924E4;  }
		/* 82192438h case    6:*/		return 0x8219243C;
		  /* 8219243Ch */ case    7:  		/* cmplwi CR6, R8, 1 */
		/* 8219243Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000001);
		/* 8219243Ch case    7:*/		return 0x82192440;
		  /* 82192440h */ case    8:  		/* bc 12, CR6_LT, 16 */
		/* 82192440h case    8:*/		if ( regs.CR[6].lt ) { return 0x82192450;  }
		/* 82192440h case    8:*/		return 0x82192444;
		  /* 82192444h */ case    9:  		/* cmplwi CR6, R8, 31 */
		/* 82192444h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000001F);
		/* 82192444h case    9:*/		return 0x82192448;
		  /* 82192448h */ case   10:  		/* li R11, 1 */
		/* 82192448h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192448h case   10:*/		return 0x8219244C;
		  /* 8219244Ch */ case   11:  		/* bc 4, CR6_GT, 8 */
		/* 8219244Ch case   11:*/		if ( !regs.CR[6].gt ) { return 0x82192454;  }
		/* 8219244Ch case   11:*/		return 0x82192450;
	}
	return 0x82192450;
} // Block from 82192420h-82192450h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82192450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192450);
		  /* 82192450h */ case    0:  		/* li R11, 0 */
		/* 82192450h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192450h case    0:*/		return 0x82192454;
	}
	return 0x82192454;
} // Block from 82192450h-82192454h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192454);
		  /* 82192454h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192454h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192454h case    0:*/		return 0x82192458;
		  /* 82192458h */ case    1:  		/* bc 12, CR0_EQ, 100 */
		/* 82192458h case    1:*/		if ( regs.CR[0].eq ) { return 0x821924BC;  }
		/* 82192458h case    1:*/		return 0x8219245C;
		  /* 8219245Ch */ case    2:  		/* cmplwi CR0, R8, 0 */
		/* 8219245Ch case    2:*/		cpu::op::cmplwi<0>(regs,regs.R8,0x00000000);
		/* 8219245Ch case    2:*/		return 0x82192460;
		  /* 82192460h */ case    3:  		/* bc 12, CR0_EQ, 36 */
		/* 82192460h case    3:*/		if ( regs.CR[0].eq ) { return 0x82192484;  }
		/* 82192460h case    3:*/		return 0x82192464;
		  /* 82192464h */ case    4:  		/* cmplwi CR6, R8, 11 */
		/* 82192464h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000000B);
		/* 82192464h case    4:*/		return 0x82192468;
		  /* 82192468h */ case    5:  		/* bc 4, CR6_GT, 20 */
		/* 82192468h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8219247C;  }
		/* 82192468h case    5:*/		return 0x8219246C;
		  /* 8219246Ch */ case    6:  		/* cmplwi CR6, R8, 24 */
		/* 8219246Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000018);
		/* 8219246Ch case    6:*/		return 0x82192470;
		  /* 82192470h */ case    7:  		/* bc 4, CR6_GT, 20 */
		/* 82192470h case    7:*/		if ( !regs.CR[6].gt ) { return 0x82192484;  }
		/* 82192470h case    7:*/		return 0x82192474;
		  /* 82192474h */ case    8:  		/* cmplwi CR6, R8, 28 */
		/* 82192474h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000001C);
		/* 82192474h case    8:*/		return 0x82192478;
		  /* 82192478h */ case    9:  		/* bc 12, CR6_GT, 12 */
		/* 82192478h case    9:*/		if ( regs.CR[6].gt ) { return 0x82192484;  }
		/* 82192478h case    9:*/		return 0x8219247C;
	}
	return 0x8219247C;
} // Block from 82192454h-8219247Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219247Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219247C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219247C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219247C);
		  /* 8219247Ch */ case    0:  		/* li R11, 1 */
		/* 8219247Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219247Ch case    0:*/		return 0x82192480;
		  /* 82192480h */ case    1:  		/* b 8 */
		/* 82192480h case    1:*/		return 0x82192488;
		/* 82192480h case    1:*/		return 0x82192484;
	}
	return 0x82192484;
} // Block from 8219247Ch-82192484h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82192484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192484);
		  /* 82192484h */ case    0:  		/* li R11, 0 */
		/* 82192484h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192484h case    0:*/		return 0x82192488;
	}
	return 0x82192488;
} // Block from 82192484h-82192488h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192488);
		  /* 82192488h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192488h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192488h case    0:*/		return 0x8219248C;
		  /* 8219248Ch */ case    1:  		/* bc 12, CR0_EQ, 48 */
		/* 8219248Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821924BC;  }
		/* 8219248Ch case    1:*/		return 0x82192490;
		  /* 82192490h */ case    2:  		/* cmplwi CR6, R25, 0 */
		/* 82192490h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82192490h case    2:*/		return 0x82192494;
		  /* 82192494h */ case    3:  		/* bc 12, CR6_EQ, 284 */
		/* 82192494h case    3:*/		if ( regs.CR[6].eq ) { return 0x821925B0;  }
		/* 82192494h case    3:*/		return 0x82192498;
		  /* 82192498h */ case    4:  		/* rlwinm. R11, R7, 7, 31, 31 */
		/* 82192498h case    4:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R7);
		/* 82192498h case    4:*/		return 0x8219249C;
		  /* 8219249Ch */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 8219249Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x821924A8;  }
		/* 8219249Ch case    5:*/		return 0x821924A0;
		  /* 821924A0h */ case    6:  		/* mr R3, R24 */
		/* 821924A0h case    6:*/		regs.R3 = regs.R24;
		/* 821924A0h case    6:*/		return 0x821924A4;
		  /* 821924A4h */ case    7:  		/* b 12 */
		/* 821924A4h case    7:*/		return 0x821924B0;
		/* 821924A4h case    7:*/		return 0x821924A8;
	}
	return 0x821924A8;
} // Block from 82192488h-821924A8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821924A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821924A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821924A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821924A8);
		  /* 821924A8h */ case    0:  		/* mr R3, R31 */
		/* 821924A8h case    0:*/		regs.R3 = regs.R31;
		/* 821924A8h case    0:*/		return 0x821924AC;
		  /* 821924ACh */ case    1:  		/* bl -5852 */
		/* 821924ACh case    1:*/		regs.LR = 0x821924B0; return 0x82190DD0;
		/* 821924ACh case    1:*/		return 0x821924B0;
	}
	return 0x821924B0;
} // Block from 821924A8h-821924B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821924B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821924B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821924B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821924B0);
		  /* 821924B0h */ case    0:  		/* cmplw CR6, R27, R3 */
		/* 821924B0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R3);
		/* 821924B0h case    0:*/		return 0x821924B4;
		  /* 821924B4h */ case    1:  		/* bc 12, CR6_GT, 252 */
		/* 821924B4h case    1:*/		if ( regs.CR[6].gt ) { return 0x821925B0;  }
		/* 821924B4h case    1:*/		return 0x821924B8;
		  /* 821924B8h */ case    2:  		/* bc 12, CR6_LT, 232 */
		/* 821924B8h case    2:*/		if ( regs.CR[6].lt ) { return 0x821925A0;  }
		/* 821924B8h case    2:*/		return 0x821924BC;
	}
	return 0x821924BC;
} // Block from 821924B0h-821924BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821924BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821924BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821924BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821924BC);
		  /* 821924BCh */ case    0:  		/* lwz R7, <#[R31 + 8]> */
		/* 821924BCh case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000008) );
		/* 821924BCh case    0:*/		return 0x821924C0;
		  /* 821924C0h */ case    1:  		/* rlwinm R8, R7, 25, 25, 31 */
		/* 821924C0h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R8,regs.R7);
		/* 821924C0h case    1:*/		return 0x821924C4;
		  /* 821924C4h */ case    2:  		/* cmplwi CR6, R8, 32 */
		/* 821924C4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000020);
		/* 821924C4h case    2:*/		return 0x821924C8;
		  /* 821924C8h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 821924C8h case    3:*/		if ( regs.CR[6].lt ) { return 0x821924D8;  }
		/* 821924C8h case    3:*/		return 0x821924CC;
		  /* 821924CCh */ case    4:  		/* cmplwi CR6, R8, 82 */
		/* 821924CCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000052);
		/* 821924CCh case    4:*/		return 0x821924D0;
		  /* 821924D0h */ case    5:  		/* li R11, 1 */
		/* 821924D0h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821924D0h case    5:*/		return 0x821924D4;
		  /* 821924D4h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 821924D4h case    6:*/		if ( !regs.CR[6].gt ) { return 0x821924DC;  }
		/* 821924D4h case    6:*/		return 0x821924D8;
	}
	return 0x821924D8;
} // Block from 821924BCh-821924D8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821924D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821924D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821924D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821924D8);
		  /* 821924D8h */ case    0:  		/* li R11, 0 */
		/* 821924D8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821924D8h case    0:*/		return 0x821924DC;
	}
	return 0x821924DC;
} // Block from 821924D8h-821924DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821924DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821924DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821924DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821924DC);
		  /* 821924DCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821924DCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821924DCh case    0:*/		return 0x821924E0;
		  /* 821924E0h */ case    1:  		/* bc 4, CR0_EQ, 208 */
		/* 821924E0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821925B0;  }
		/* 821924E0h case    1:*/		return 0x821924E4;
	}
	return 0x821924E4;
} // Block from 821924DCh-821924E4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821924E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821924E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821924E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821924E4);
		  /* 821924E4h */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 821924E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821924E4h case    0:*/		return 0x821924E8;
		  /* 821924E8h */ case    1:  		/* rlwinm R11, R11, 11, 29, 31 */
		/* 821924E8h case    1:*/		cpu::op::rlwinm<0,11,29,31>(regs,&regs.R11,regs.R11);
		/* 821924E8h case    1:*/		return 0x821924EC;
		  /* 821924ECh */ case    2:  		/* addi R11, R11, -1 */
		/* 821924ECh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821924ECh case    2:*/		return 0x821924F0;
	}
	return 0x821924F0;
} // Block from 821924E4h-821924F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821924F0h
// Function '?MakeInstr_S_MAX@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821924F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821924F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821924F0);
		  /* 821924F0h */ case    0:  		/* cmpw CR6, R26, R11 */
		/* 821924F0h case    0:*/		cpu::op::cmpw<6>(regs,regs.R26,regs.R11);
		/* 821924F0h case    0:*/		return 0x821924F4;
		  /* 821924F4h */ case    1:  		/* bc 12, CR6_LT, 188 */
		/* 821924F4h case    1:*/		if ( regs.CR[6].lt ) { return 0x821925B0;  }
		/* 821924F4h case    1:*/		return 0x821924F8;
		  /* 821924F8h */ case    2:  		/* lwz R9, <#[R31 + 4]> */
		/* 821924F8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 821924F8h case    2:*/		return 0x821924FC;
		  /* 821924FCh */ case    3:  		/* li R10, 0 */
		/* 821924FCh case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821924FCh case    3:*/		return 0x82192500;
		  /* 82192500h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 82192500h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82192500h case    4:*/		return 0x82192504;
		  /* 82192504h */ case    5:  		/* bc 12, CR6_EQ, 84 */
		/* 82192504h case    5:*/		if ( regs.CR[6].eq ) { return 0x82192558;  }
		/* 82192504h case    5:*/		return 0x82192508;
		  /* 82192508h */ case    6:  		/* lwz R11, <#[R9 + 16]> */
		/* 82192508h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000010) );
		/* 82192508h case    6:*/		return 0x8219250C;
		  /* 8219250Ch */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8219250Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219250Ch case    7:*/		return 0x82192510;
		  /* 82192510h */ case    8:  		/* bc 12, CR6_EQ, 64 */
		/* 82192510h case    8:*/		if ( regs.CR[6].eq ) { return 0x82192550;  }
		/* 82192510h case    8:*/		return 0x82192514;
		  /* 82192514h */ case    9:  		/* lwz R6, <#[R9]> */
		/* 82192514h case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + 0x00000000) );
		/* 82192514h case    9:*/		return 0x82192518;
		  /* 82192518h */ case   10:  		/* rlwinm. R6, R6, 0, 4, 6 */
		/* 82192518h case   10:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R6,regs.R6);
		/* 82192518h case   10:*/		return 0x8219251C;
		  /* 8219251Ch */ case   11:  		/* bc 12, CR0_EQ, 52 */
		/* 8219251Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x82192550;  }
		/* 8219251Ch case   11:*/		return 0x82192520;
		  /* 82192520h */ case   12:  		/* lwz R6, <#[R11 + 28]> */
		/* 82192520h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x0000001C) );
		/* 82192520h case   12:*/		return 0x82192524;
		  /* 82192524h */ case   13:  		/* lwz R5, <#[R31 + 28]> */
		/* 82192524h case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000001C) );
		/* 82192524h case   13:*/		return 0x82192528;
		  /* 82192528h */ case   14:  		/* cmpw CR6, R6, R5 */
		/* 82192528h case   14:*/		cpu::op::cmpw<6>(regs,regs.R6,regs.R5);
		/* 82192528h case   14:*/		return 0x8219252C;
		  /* 8219252Ch */ case   15:  		/* bc 4, CR6_EQ, 36 */
		/* 8219252Ch case   15:*/		if ( !regs.CR[6].eq ) { return 0x82192550;  }
		/* 8219252Ch case   15:*/		return 0x82192530;
		  /* 82192530h */ case   16:  		/* lbz R6, <#[R11 + 16]> */
		/* 82192530h case   16:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000010) );
		/* 82192530h case   16:*/		return 0x82192534;
		  /* 82192534h */ case   17:  		/* rlwinm. R6, R6, 0, 31, 31 */
		/* 82192534h case   17:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R6,regs.R6);
		/* 82192534h case   17:*/		return 0x82192538;
		  /* 82192538h */ case   18:  		/* bc 12, CR0_EQ, 24 */
		/* 82192538h case   18:*/		if ( regs.CR[0].eq ) { return 0x82192550;  }
		/* 82192538h case   18:*/		return 0x8219253C;
		  /* 8219253Ch */ case   19:  		/* lwz R11, <#[R11 + 20]> */
		/* 8219253Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8219253Ch case   19:*/		return 0x82192540;
		  /* 82192540h */ case   20:  		/* rlwinm R11, R11, 0, 19, 31 */
		/* 82192540h case   20:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R11);
		/* 82192540h case   20:*/		return 0x82192544;
		  /* 82192544h */ case   21:  		/* cmplw CR6, R11, R10 */
		/* 82192544h case   21:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82192544h case   21:*/		return 0x82192548;
		  /* 82192548h */ case   22:  		/* bc 4, CR6_GT, 8 */
		/* 82192548h case   22:*/		if ( !regs.CR[6].gt ) { return 0x82192550;  }
		/* 82192548h case   22:*/		return 0x8219254C;
		  /* 8219254Ch */ case   23:  		/* mr R10, R11 */
		/* 8219254Ch case   23:*/		regs.R10 = regs.R11;
		/* 8219254Ch case   23:*/		return 0x82192550;
	}
	return 0x82192550;
} // Block from 821924F0h-82192550h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82192550h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192550);
		  /* 82192550h */ case    0:  		/* lwz R9, <#[R9 + 8]> */
		/* 82192550h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 82192550h case    0:*/		return 0x82192554;
		  /* 82192554h */ case    1:  		/* b -84 */
		/* 82192554h case    1:*/		return 0x82192500;
		/* 82192554h case    1:*/		return 0x82192558;
	}
	return 0x82192558;
} // Block from 82192550h-82192558h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82192558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192558);
		  /* 82192558h */ case    0:  		/* cmplw CR6, R28, R10 */
		/* 82192558h case    0:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R10);
		/* 82192558h case    0:*/		return 0x8219255C;
		  /* 8219255Ch */ case    1:  		/* bc 12, CR6_GT, 84 */
		/* 8219255Ch case    1:*/		if ( regs.CR[6].gt ) { return 0x821925B0;  }
		/* 8219255Ch case    1:*/		return 0x82192560;
		  /* 82192560h */ case    2:  		/* lwz R11, <#[R29 + 8]> */
		/* 82192560h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82192560h case    2:*/		return 0x82192564;
		  /* 82192564h */ case    3:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 82192564h case    3:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 82192564h case    3:*/		return 0x82192568;
		  /* 82192568h */ case    4:  		/* cmplwi CR6, R10, 12288 */
		/* 82192568h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003000);
		/* 82192568h case    4:*/		return 0x8219256C;
		  /* 8219256Ch */ case    5:  		/* bc 4, CR6_EQ, 52 */
		/* 8219256Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x821925A0;  }
		/* 8219256Ch case    5:*/		return 0x82192570;
		  /* 82192570h */ case    6:  		/* rlwinm. R11, R11, 0, 10, 12 */
		/* 82192570h case    6:*/		cpu::op::rlwinm<1,0,10,12>(regs,&regs.R11,regs.R11);
		/* 82192570h case    6:*/		return 0x82192574;
		  /* 82192574h */ case    7:  		/* bc 12, CR0_EQ, 44 */
		/* 82192574h case    7:*/		if ( regs.CR[0].eq ) { return 0x821925A0;  }
		/* 82192574h case    7:*/		return 0x82192578;
		  /* 82192578h */ case    8:  		/* cmplwi CR6, R8, 96 */
		/* 82192578h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000060);
		/* 82192578h case    8:*/		return 0x8219257C;
		  /* 8219257Ch */ case    9:  		/* bc 4, CR6_EQ, 36 */
		/* 8219257Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x821925A0;  }
		/* 8219257Ch case    9:*/		return 0x82192580;
		  /* 82192580h */ case   10:  		/* rlwinm. R11, R7, 0, 10, 12 */
		/* 82192580h case   10:*/		cpu::op::rlwinm<1,0,10,12>(regs,&regs.R11,regs.R7);
		/* 82192580h case   10:*/		return 0x82192584;
		  /* 82192584h */ case   11:  		/* bc 12, CR0_EQ, 28 */
		/* 82192584h case   11:*/		if ( regs.CR[0].eq ) { return 0x821925A0;  }
		/* 82192584h case   11:*/		return 0x82192588;
		  /* 82192588h */ case   12:  		/* lwz R11, <#[R31 + 44]> */
		/* 82192588h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 82192588h case   12:*/		return 0x8219258C;
		  /* 8219258Ch */ case   13:  		/* lwz R10, <#[R29 + 44]> */
		/* 8219258Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000002C) );
		/* 8219258Ch case   13:*/		return 0x82192590;
		  /* 82192590h */ case   14:  		/* lwz R11, <#[R11 + 12]> */
		/* 82192590h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 82192590h case   14:*/		return 0x82192594;
		  /* 82192594h */ case   15:  		/* lwz R10, <#[R10 + 12]> */
		/* 82192594h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 82192594h case   15:*/		return 0x82192598;
	}
	return 0x82192598;
} // Block from 82192558h-82192598h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82192598h
// Function '?MakeInstr_S_MAXA@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192598);
		  /* 82192598h */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 82192598h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82192598h case    0:*/		return 0x8219259C;
		  /* 8219259Ch */ case    1:  		/* bc 12, CR6_LT, 20 */
		/* 8219259Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x821925B0;  }
		/* 8219259Ch case    1:*/		return 0x821925A0;
	}
	return 0x821925A0;
} // Block from 82192598h-821925A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821925A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821925A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821925A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821925A0);
		  /* 821925A0h */ case    0:  		/* addi R21, R31, 32 */
		/* 821925A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R31,0x20);
		/* 821925A0h case    0:*/		return 0x821925A4;
		  /* 821925A4h */ case    1:  		/* lwz R31, <#[R31 + 32]> */
		/* 821925A4h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000020) );
		/* 821925A4h case    1:*/		return 0x821925A8;
	}
	return 0x821925A8;
} // Block from 821925A0h-821925A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821925A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821925A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821925A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821925A8);
		  /* 821925A8h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 821925A8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821925A8h case    0:*/		return 0x821925AC;
		  /* 821925ACh */ case    1:  		/* bc 4, CR6_EQ, -532 */
		/* 821925ACh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82192398;  }
		/* 821925ACh case    1:*/		return 0x821925B0;
	}
	return 0x821925B0;
} // Block from 821925A8h-821925B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821925B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821925B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821925B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821925B0);
		  /* 821925B0h */ case    0:  		/* lwz R11, <#[R21]> */
		/* 821925B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 821925B0h case    0:*/		return 0x821925B4;
		  /* 821925B4h */ case    1:  		/* stw R11, <#[R29 + 32]> */
		/* 821925B4h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000020) );
		/* 821925B4h case    1:*/		return 0x821925B8;
		  /* 821925B8h */ case    2:  		/* stw R29, <#[R21]> */
		/* 821925B8h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R21 + 0x00000000) );
		/* 821925B8h case    2:*/		return 0x821925BC;
	}
	return 0x821925BC;
} // Block from 821925B0h-821925BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821925BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821925BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821925BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821925BC);
		  /* 821925BCh */ case    0:  		/* addi R1, R1, 176 */
		/* 821925BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 821925BCh case    0:*/		return 0x821925C0;
		  /* 821925C0h */ case    1:  		/* b -1053492 */
		/* 821925C0h case    1:*/		return 0x8209128C;
		/* 821925C0h case    1:*/		return 0x821925C4;
		  /* 821925C4h */ case    2:  		/* nop */
		/* 821925C4h case    2:*/		cpu::op::nop();
		/* 821925C4h case    2:*/		return 0x821925C8;
	}
	return 0x821925C8;
} // Block from 821925BCh-821925C8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821925C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821925C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821925C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821925C8);
		  /* 821925C8h */ case    0:  		/* mfspr R12, LR */
		/* 821925C8h case    0:*/		regs.R12 = regs.LR;
		/* 821925C8h case    0:*/		return 0x821925CC;
		  /* 821925CCh */ case    1:  		/* bl -1053596 */
		/* 821925CCh case    1:*/		regs.LR = 0x821925D0; return 0x82091230;
		/* 821925CCh case    1:*/		return 0x821925D0;
		  /* 821925D0h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 821925D0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 821925D0h case    2:*/		return 0x821925D4;
		  /* 821925D4h */ case    3:  		/* lis R11, -32215 */
		/* 821925D4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 821925D4h case    3:*/		return 0x821925D8;
		  /* 821925D8h */ case    4:  		/* mr R22, R3 */
		/* 821925D8h case    4:*/		regs.R22 = regs.R3;
		/* 821925D8h case    4:*/		return 0x821925DC;
		  /* 821925DCh */ case    5:  		/* mr R23, R4 */
		/* 821925DCh case    5:*/		regs.R23 = regs.R4;
		/* 821925DCh case    5:*/		return 0x821925E0;
		  /* 821925E0h */ case    6:  		/* mr R18, R5 */
		/* 821925E0h case    6:*/		regs.R18 = regs.R5;
		/* 821925E0h case    6:*/		return 0x821925E4;
		  /* 821925E4h */ case    7:  		/* addi R19, R4, 24 */
		/* 821925E4h case    7:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R4,0x18);
		/* 821925E4h case    7:*/		return 0x821925E8;
		  /* 821925E8h */ case    8:  		/* addi R24, R11, -26096 */
		/* 821925E8h case    8:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0xFFFF9A10);
		/* 821925E8h case    8:*/		return 0x821925EC;
		  /* 821925ECh */ case    9:  		/* lwz R11, <#[R19 + 4]> */
		/* 821925ECh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 821925ECh case    9:*/		return 0x821925F0;
		  /* 821925F0h */ case   10:  		/* li R21, 0 */
		/* 821925F0h case   10:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 821925F0h case   10:*/		return 0x821925F4;
		  /* 821925F4h */ case   11:  		/* li R25, 0 */
		/* 821925F4h case   11:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 821925F4h case   11:*/		return 0x821925F8;
		  /* 821925F8h */ case   12:  		/* li R26, 0 */
		/* 821925F8h case   12:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 821925F8h case   12:*/		return 0x821925FC;
		  /* 821925FCh */ case   13:  		/* li R20, 0 */
		/* 821925FCh case   13:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 821925FCh case   13:*/		return 0x82192600;
		  /* 82192600h */ case   14:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82192600h case   14:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82192600h case   14:*/		return 0x82192604;
		  /* 82192604h */ case   15:  		/* addic R10, R10, -1 */
		/* 82192604h case   15:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82192604h case   15:*/		return 0x82192608;
		  /* 82192608h */ case   16:  		/* subfe R10, R10, R10 */
		/* 82192608h case   16:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82192608h case   16:*/		return 0x8219260C;
		  /* 8219260Ch */ case   17:  		/* and R27, R10, R11 */
		/* 8219260Ch case   17:*/		cpu::op::and<0>(regs,&regs.R27,regs.R10,regs.R11);
		/* 8219260Ch case   17:*/		return 0x82192610;
		  /* 82192610h */ case   18:  		/* cmplwi CR6, R27, 0 */
		/* 82192610h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82192610h case   18:*/		return 0x82192614;
		  /* 82192614h */ case   19:  		/* bc 12, CR6_EQ, 1560 */
		/* 82192614h case   19:*/		if ( regs.CR[6].eq ) { return 0x82192C2C;  }
		/* 82192614h case   19:*/		return 0x82192618;
		  /* 82192618h */ case   20:  		/* lwz R31, <#[R27 + 8]> */
		/* 82192618h case   20:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R27 + 0x00000008) );
		/* 82192618h case   20:*/		return 0x8219261C;
		  /* 8219261Ch */ case   21:  		/* rlwinm. R11, R31, 0, 25, 25 */
		/* 8219261Ch case   21:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R31);
		/* 8219261Ch case   21:*/		return 0x82192620;
		  /* 82192620h */ case   22:  		/* bc 4, CR0_EQ, 12 */
		/* 82192620h case   22:*/		if ( !regs.CR[0].eq ) { return 0x8219262C;  }
		/* 82192620h case   22:*/		return 0x82192624;
		  /* 82192624h */ case   23:  		/* li R11, 0 */
		/* 82192624h case   23:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192624h case   23:*/		return 0x82192628;
		  /* 82192628h */ case   24:  		/* b 44 */
		/* 82192628h case   24:*/		return 0x82192654;
		/* 82192628h case   24:*/		return 0x8219262C;
	}
	return 0x8219262C;
} // Block from 821925C8h-8219262Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 8219262Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219262C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219262C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219262C);
		  /* 8219262Ch */ case    0:  		/* rlwinm R11, R31, 25, 25, 31 */
		/* 8219262Ch case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R31);
		/* 8219262Ch case    0:*/		return 0x82192630;
		  /* 82192630h */ case    1:  		/* cmplwi CR6, R11, 30 */
		/* 82192630h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001E);
		/* 82192630h case    1:*/		return 0x82192634;
		  /* 82192634h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 82192634h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219264C;  }
		/* 82192634h case    2:*/		return 0x82192638;
		  /* 82192638h */ case    3:  		/* cmplwi CR6, R11, 55 */
		/* 82192638h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000037);
		/* 82192638h case    3:*/		return 0x8219263C;
		  /* 8219263Ch */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 8219263Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x8219264C;  }
		/* 8219263Ch case    4:*/		return 0x82192640;
	}
	return 0x82192640;
} // Block from 8219262Ch-82192640h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82192640h
// Function '?MakeInstr_S_MAXA_FLOOR@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192640);
		  /* 82192640h */ case    0:  		/* cmplwi CR6, R11, 56 */
		/* 82192640h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000038);
		/* 82192640h case    0:*/		return 0x82192644;
		  /* 82192644h */ case    1:  		/* li R11, 0 */
		/* 82192644h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192644h case    1:*/		return 0x82192648;
		  /* 82192648h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 82192648h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82192650;  }
		/* 82192648h case    2:*/		return 0x8219264C;
	}
	return 0x8219264C;
} // Block from 82192640h-8219264Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219264Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219264C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219264C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219264C);
		  /* 8219264Ch */ case    0:  		/* li R11, 1 */
		/* 8219264Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219264Ch case    0:*/		return 0x82192650;
	}
	return 0x82192650;
} // Block from 8219264Ch-82192650h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192650);
		  /* 82192650h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 82192650h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192650h case    0:*/		return 0x82192654;
	}
	return 0x82192654;
} // Block from 82192650h-82192654h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192654h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192654( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192654) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192654);
		  /* 82192654h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192654h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192654h case    0:*/		return 0x82192658;
		  /* 82192658h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82192658h case    1:*/		if ( regs.CR[0].eq ) { return 0x82192664;  }
		/* 82192658h case    1:*/		return 0x8219265C;
		  /* 8219265Ch */ case    2:  		/* mr R25, R27 */
		/* 8219265Ch case    2:*/		regs.R25 = regs.R27;
		/* 8219265Ch case    2:*/		return 0x82192660;
		  /* 82192660h */ case    3:  		/* b 92 */
		/* 82192660h case    3:*/		return 0x821926BC;
		/* 82192660h case    3:*/		return 0x82192664;
	}
	return 0x82192664;
} // Block from 82192654h-82192664h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82192664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192664);
		  /* 82192664h */ case    0:  		/* rlwinm R10, R31, 25, 25, 31 */
		/* 82192664h case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R31);
		/* 82192664h case    0:*/		return 0x82192668;
		  /* 82192668h */ case    1:  		/* cmplwi CR6, R10, 91 */
		/* 82192668h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005B);
		/* 82192668h case    1:*/		return 0x8219266C;
		  /* 8219266Ch */ case    2:  		/* bc 12, CR6_LT, 16 */
		/* 8219266Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x8219267C;  }
		/* 8219266Ch case    2:*/		return 0x82192670;
		  /* 82192670h */ case    3:  		/* cmplwi CR6, R10, 94 */
		/* 82192670h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005E);
		/* 82192670h case    3:*/		return 0x82192674;
		  /* 82192674h */ case    4:  		/* li R11, 1 */
		/* 82192674h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192674h case    4:*/		return 0x82192678;
		  /* 82192678h */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 82192678h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82192680;  }
		/* 82192678h case    5:*/		return 0x8219267C;
	}
	return 0x8219267C;
} // Block from 82192664h-8219267Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219267Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219267C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219267C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219267C);
		  /* 8219267Ch */ case    0:  		/* li R11, 0 */
		/* 8219267Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219267Ch case    0:*/		return 0x82192680;
	}
	return 0x82192680;
} // Block from 8219267Ch-82192680h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192680);
		  /* 82192680h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192680h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192680h case    0:*/		return 0x82192684;
		  /* 82192684h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 82192684h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82192694;  }
		/* 82192684h case    1:*/		return 0x82192688;
		  /* 82192688h */ case    2:  		/* cmplwi CR6, R10, 123 */
		/* 82192688h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007B);
		/* 82192688h case    2:*/		return 0x8219268C;
		  /* 8219268Ch */ case    3:  		/* li R11, 0 */
		/* 8219268Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219268Ch case    3:*/		return 0x82192690;
		  /* 82192690h */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 82192690h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82192698;  }
		/* 82192690h case    4:*/		return 0x82192694;
	}
	return 0x82192694;
} // Block from 82192680h-82192694h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82192694h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192694( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192694) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192694);
		  /* 82192694h */ case    0:  		/* li R11, 1 */
		/* 82192694h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192694h case    0:*/		return 0x82192698;
	}
	return 0x82192698;
} // Block from 82192694h-82192698h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192698);
		  /* 82192698h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192698h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192698h case    0:*/		return 0x8219269C;
		  /* 8219269Ch */ case    1:  		/* bc 4, CR0_EQ, 28 */
		/* 8219269Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x821926B8;  }
		/* 8219269Ch case    1:*/		return 0x821926A0;
		  /* 821926A0h */ case    2:  		/* mr R3, R27 */
		/* 821926A0h case    2:*/		regs.R3 = regs.R27;
		/* 821926A0h case    2:*/		return 0x821926A4;
		  /* 821926A4h */ case    3:  		/* bl -145836 */
		/* 821926A4h case    3:*/		regs.LR = 0x821926A8; return 0x8216ECF8;
		/* 821926A4h case    3:*/		return 0x821926A8;
		  /* 821926A8h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 821926A8h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821926A8h case    4:*/		return 0x821926AC;
		  /* 821926ACh */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 821926ACh case    5:*/		if ( regs.CR[0].eq ) { return 0x821926BC;  }
		/* 821926ACh case    5:*/		return 0x821926B0;
		  /* 821926B0h */ case    6:  		/* cmpwi CR6, R3, 1 */
		/* 821926B0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 821926B0h case    6:*/		return 0x821926B4;
		  /* 821926B4h */ case    7:  		/* bc 12, CR6_EQ, 8 */
		/* 821926B4h case    7:*/		if ( regs.CR[6].eq ) { return 0x821926BC;  }
		/* 821926B4h case    7:*/		return 0x821926B8;
	}
	return 0x821926B8;
} // Block from 82192698h-821926B8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821926B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821926B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821926B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821926B8);
		  /* 821926B8h */ case    0:  		/* mr R26, R27 */
		/* 821926B8h case    0:*/		regs.R26 = regs.R27;
		/* 821926B8h case    0:*/		return 0x821926BC;
	}
	return 0x821926BC;
} // Block from 821926B8h-821926BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821926BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821926BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821926BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821926BC);
		  /* 821926BCh */ case    0:  		/* rlwinm R11, R31, 25, 25, 31 */
		/* 821926BCh case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R31);
		/* 821926BCh case    0:*/		return 0x821926C0;
		  /* 821926C0h */ case    1:  		/* cmplwi CR6, R11, 25 */
		/* 821926C0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000019);
		/* 821926C0h case    1:*/		return 0x821926C4;
		  /* 821926C4h */ case    2:  		/* bc 12, CR6_LT, 12 */
		/* 821926C4h case    2:*/		if ( regs.CR[6].lt ) { return 0x821926D0;  }
		/* 821926C4h case    2:*/		return 0x821926C8;
		  /* 821926C8h */ case    3:  		/* cmplwi CR6, R11, 28 */
		/* 821926C8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001C);
		/* 821926C8h case    3:*/		return 0x821926CC;
		  /* 821926CCh */ case    4:  		/* bc 4, CR6_GT, 20 */
		/* 821926CCh case    4:*/		if ( !regs.CR[6].gt ) { return 0x821926E0;  }
		/* 821926CCh case    4:*/		return 0x821926D0;
	}
	return 0x821926D0;
} // Block from 821926BCh-821926D0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821926D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821926D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821926D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821926D0);
		  /* 821926D0h */ case    0:  		/* cmplwi CR6, R11, 67 */
		/* 821926D0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000043);
		/* 821926D0h case    0:*/		return 0x821926D4;
		  /* 821926D4h */ case    1:  		/* bc 12, CR6_LT, 20 */
		/* 821926D4h case    1:*/		if ( regs.CR[6].lt ) { return 0x821926E8;  }
		/* 821926D4h case    1:*/		return 0x821926D8;
		  /* 821926D8h */ case    2:  		/* cmplwi CR6, R11, 71 */
		/* 821926D8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000047);
		/* 821926D8h case    2:*/		return 0x821926DC;
		  /* 821926DCh */ case    3:  		/* bc 12, CR6_GT, 12 */
		/* 821926DCh case    3:*/		if ( regs.CR[6].gt ) { return 0x821926E8;  }
		/* 821926DCh case    3:*/		return 0x821926E0;
	}
	return 0x821926E0;
} // Block from 821926D0h-821926E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821926E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821926E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821926E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821926E0);
		  /* 821926E0h */ case    0:  		/* li R11, 1 */
		/* 821926E0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821926E0h case    0:*/		return 0x821926E4;
		  /* 821926E4h */ case    1:  		/* b 8 */
		/* 821926E4h case    1:*/		return 0x821926EC;
		/* 821926E4h case    1:*/		return 0x821926E8;
	}
	return 0x821926E8;
} // Block from 821926E0h-821926E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821926E8h
// Function '?MakeInstr_S_MUL_CONST_0@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@PAVDependency@2@2@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821926E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821926E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821926E8);
		  /* 821926E8h */ case    0:  		/* li R11, 0 */
		/* 821926E8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821926E8h case    0:*/		return 0x821926EC;
	}
	return 0x821926EC;
} // Block from 821926E8h-821926ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821926ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821926EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821926EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821926EC);
		  /* 821926ECh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821926ECh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821926ECh case    0:*/		return 0x821926F0;
		  /* 821926F0h */ case    1:  		/* bc 12, CR0_EQ, 144 */
		/* 821926F0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82192780;  }
		/* 821926F0h case    1:*/		return 0x821926F4;
		  /* 821926F4h */ case    2:  		/* lwz R31, <#[R19 + 4]> */
		/* 821926F4h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R19 + 0x00000004) );
		/* 821926F4h case    2:*/		return 0x821926F8;
		  /* 821926F8h */ case    3:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 821926F8h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 821926F8h case    3:*/		return 0x821926FC;
		  /* 821926FCh */ case    4:  		/* bc 4, CR0_EQ, 132 */
		/* 821926FCh case    4:*/		if ( !regs.CR[0].eq ) { return 0x82192780;  }
		/* 821926FCh case    4:*/		return 0x82192700;
		  /* 82192700h */ case    5:  		/* cmplwi CR0, R31, 0 */
		/* 82192700h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 82192700h case    5:*/		return 0x82192704;
		  /* 82192704h */ case    6:  		/* bc 12, CR0_EQ, 124 */
		/* 82192704h case    6:*/		if ( regs.CR[0].eq ) { return 0x82192780;  }
		/* 82192704h case    6:*/		return 0x82192708;
		  /* 82192708h */ case    7:  		/* lwz R11, <#[R31 + 8]> */
		/* 82192708h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82192708h case    7:*/		return 0x8219270C;
		  /* 8219270Ch */ case    8:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219270Ch case    8:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219270Ch case    8:*/		return 0x82192710;
		  /* 82192710h */ case    9:  		/* cmplwi CR6, R11, 12416 */
		/* 82192710h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003080);
		/* 82192710h case    9:*/		return 0x82192714;
		  /* 82192714h */ case   10:  		/* bc 4, CR6_EQ, 84 */
		/* 82192714h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82192768;  }
		/* 82192714h case   10:*/		return 0x82192718;
		  /* 82192718h */ case   11:  		/* lwz R11, <#[R31]> */
		/* 82192718h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82192718h case   11:*/		return 0x8219271C;
		  /* 8219271Ch */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 8219271Ch case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219271Ch case   12:*/		return 0x82192720;
		  /* 82192720h */ case   13:  		/* bc 12, CR6_EQ, 32 */
		/* 82192720h case   13:*/		if ( regs.CR[6].eq ) { return 0x82192740;  }
		/* 82192720h case   13:*/		return 0x82192724;
		  /* 82192724h */ case   14:  		/* lwz R10, <#[R11 + 12]> */
		/* 82192724h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82192724h case   14:*/		return 0x82192728;
		  /* 82192728h */ case   15:  		/* cmplw CR6, R10, R27 */
		/* 82192728h case   15:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R27);
		/* 82192728h case   15:*/		return 0x8219272C;
		  /* 8219272Ch */ case   16:  		/* bc 12, CR6_EQ, 12 */
		/* 8219272Ch case   16:*/		if ( regs.CR[6].eq ) { return 0x82192738;  }
		/* 8219272Ch case   16:*/		return 0x82192730;
		  /* 82192730h */ case   17:  		/* lwz R11, <#[R11 + 4]> */
		/* 82192730h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82192730h case   17:*/		return 0x82192734;
		  /* 82192734h */ case   18:  		/* b -24 */
		/* 82192734h case   18:*/		return 0x8219271C;
		/* 82192734h case   18:*/		return 0x82192738;
	}
	return 0x82192738;
} // Block from 821926ECh-82192738h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82192738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192738);
		  /* 82192738h */ case    0:  		/* li R11, 1 */
		/* 82192738h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192738h case    0:*/		return 0x8219273C;
		  /* 8219273Ch */ case    1:  		/* b 8 */
		/* 8219273Ch case    1:*/		return 0x82192744;
		/* 8219273Ch case    1:*/		return 0x82192740;
	}
	return 0x82192740;
} // Block from 82192738h-82192740h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82192740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192740);
		  /* 82192740h */ case    0:  		/* li R11, 0 */
		/* 82192740h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192740h case    0:*/		return 0x82192744;
	}
	return 0x82192744;
} // Block from 82192740h-82192744h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192744);
		  /* 82192744h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192744h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192744h case    0:*/		return 0x82192748;
		  /* 82192748h */ case    1:  		/* bc 4, CR0_EQ, 32 */
		/* 82192748h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82192768;  }
		/* 82192748h case    1:*/		return 0x8219274C;
		  /* 8219274Ch */ case    2:  		/* li R6, 0 */
		/* 8219274Ch case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8219274Ch case    2:*/		return 0x82192750;
		  /* 82192750h */ case    3:  		/* mr R5, R31 */
		/* 82192750h case    3:*/		regs.R5 = regs.R31;
		/* 82192750h case    3:*/		return 0x82192754;
		  /* 82192754h */ case    4:  		/* mr R4, R27 */
		/* 82192754h case    4:*/		regs.R4 = regs.R27;
		/* 82192754h case    4:*/		return 0x82192758;
		  /* 82192758h */ case    5:  		/* mr R3, R22 */
		/* 82192758h case    5:*/		regs.R3 = regs.R22;
		/* 82192758h case    5:*/		return 0x8219275C;
		  /* 8219275Ch */ case    6:  		/* bl 630028 */
		/* 8219275Ch case    6:*/		regs.LR = 0x82192760; return 0x8222C468;
		/* 8219275Ch case    6:*/		return 0x82192760;
		  /* 82192760h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82192760h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82192760h case    7:*/		return 0x82192764;
		  /* 82192764h */ case    8:  		/* bc 4, CR0_EQ, 1140 */
		/* 82192764h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82192BD8;  }
		/* 82192764h case    8:*/		return 0x82192768;
	}
	return 0x82192768;
} // Block from 82192744h-82192768h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82192768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192768);
		  /* 82192768h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82192768h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82192768h case    0:*/		return 0x8219276C;
		  /* 8219276Ch */ case    1:  		/* lwz R31, <#[R11 + 40]> */
		/* 8219276Ch case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000028) );
		/* 8219276Ch case    1:*/		return 0x82192770;
		  /* 82192770h */ case    2:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 82192770h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 82192770h case    2:*/		return 0x82192774;
		  /* 82192774h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 82192774h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82192780;  }
		/* 82192774h case    3:*/		return 0x82192778;
		  /* 82192778h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 82192778h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82192778h case    4:*/		return 0x8219277C;
		  /* 8219277Ch */ case    5:  		/* bc 4, CR6_EQ, -116 */
		/* 8219277Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x82192708;  }
		/* 8219277Ch case    5:*/		return 0x82192780;
	}
	return 0x82192780;
} // Block from 82192768h-82192780h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82192780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192780);
		  /* 82192780h */ case    0:  		/* lwz R8, <#[R27 + 8]> */
		/* 82192780h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000008) );
		/* 82192780h case    0:*/		return 0x82192784;
		  /* 82192784h */ case    1:  		/* rlwinm R9, R8, 25, 25, 31 */
		/* 82192784h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R9,regs.R8);
		/* 82192784h case    1:*/		return 0x82192788;
		  /* 82192788h */ case    2:  		/* cmplwi CR6, R9, 96 */
		/* 82192788h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000060);
		/* 82192788h case    2:*/		return 0x8219278C;
		  /* 8219278Ch */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 8219278Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x821927A4;  }
		/* 8219278Ch case    3:*/		return 0x82192790;
		  /* 82192790h */ case    4:  		/* rlwinm R11, R8, 0, 10, 12 */
		/* 82192790h case    4:*/		cpu::op::rlwinm<0,0,10,12>(regs,&regs.R11,regs.R8);
		/* 82192790h case    4:*/		return 0x82192794;
		  /* 82192794h */ case    5:  		/* lis R10, 8 */
		/* 82192794h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x8);
		/* 82192794h case    5:*/		return 0x82192798;
		  /* 82192798h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 82192798h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82192798h case    6:*/		return 0x8219279C;
		  /* 8219279Ch */ case    7:  		/* li R11, 1 */
		/* 8219279Ch case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219279Ch case    7:*/		return 0x821927A0;
		  /* 821927A0h */ case    8:  		/* bc 12, CR6_GT, 8 */
		/* 821927A0h case    8:*/		if ( regs.CR[6].gt ) { return 0x821927A8;  }
		/* 821927A0h case    8:*/		return 0x821927A4;
	}
	return 0x821927A4;
} // Block from 82192780h-821927A4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821927A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821927A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821927A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821927A4);
		  /* 821927A4h */ case    0:  		/* li R11, 0 */
		/* 821927A4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821927A4h case    0:*/		return 0x821927A8;
	}
	return 0x821927A8;
} // Block from 821927A4h-821927A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821927A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821927A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821927A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821927A8);
		  /* 821927A8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821927A8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821927A8h case    0:*/		return 0x821927AC;
		  /* 821927ACh */ case    1:  		/* bc 4, CR0_EQ, 36 */
		/* 821927ACh case    1:*/		if ( !regs.CR[0].eq ) { return 0x821927D0;  }
		/* 821927ACh case    1:*/		return 0x821927B0;
		  /* 821927B0h */ case    2:  		/* cmplwi CR6, R9, 96 */
		/* 821927B0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000060);
		/* 821927B0h case    2:*/		return 0x821927B4;
		  /* 821927B4h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 821927B4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821927C4;  }
		/* 821927B4h case    3:*/		return 0x821927B8;
		  /* 821927B8h */ case    4:  		/* rlwinm. R11, R8, 0, 10, 12 */
		/* 821927B8h case    4:*/		cpu::op::rlwinm<1,0,10,12>(regs,&regs.R11,regs.R8);
		/* 821927B8h case    4:*/		return 0x821927BC;
		  /* 821927BCh */ case    5:  		/* li R11, 1 */
		/* 821927BCh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821927BCh case    5:*/		return 0x821927C0;
	}
	return 0x821927C0;
} // Block from 821927A8h-821927C0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821927C0h
// Function '?MakeInstr_S_ADD_CONST_0@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@PAVDependency@2@2@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821927C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821927C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821927C0);
		  /* 821927C0h */ case    0:  		/* bc 12, CR0_EQ, 8 */
		/* 821927C0h case    0:*/		if ( regs.CR[0].eq ) { return 0x821927C8;  }
		/* 821927C0h case    0:*/		return 0x821927C4;
	}
	return 0x821927C4;
} // Block from 821927C0h-821927C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821927C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821927C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821927C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821927C4);
		  /* 821927C4h */ case    0:  		/* li R11, 0 */
		/* 821927C4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821927C4h case    0:*/		return 0x821927C8;
	}
	return 0x821927C8;
} // Block from 821927C4h-821927C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821927C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821927C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821927C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821927C8);
		  /* 821927C8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821927C8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821927C8h case    0:*/		return 0x821927CC;
		  /* 821927CCh */ case    1:  		/* bc 12, CR0_EQ, 320 */
		/* 821927CCh case    1:*/		if ( regs.CR[0].eq ) { return 0x8219290C;  }
		/* 821927CCh case    1:*/		return 0x821927D0;
	}
	return 0x821927D0;
} // Block from 821927C8h-821927D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821927D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821927D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821927D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821927D0);
		  /* 821927D0h */ case    0:  		/* mr R10, R27 */
		/* 821927D0h case    0:*/		regs.R10 = regs.R27;
		/* 821927D0h case    0:*/		return 0x821927D4;
		  /* 821927D4h */ case    1:  		/* cmplwi CR6, R9, 96 */
		/* 821927D4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000060);
		/* 821927D4h case    1:*/		return 0x821927D8;
		  /* 821927D8h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 821927D8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821927E8;  }
		/* 821927D8h case    2:*/		return 0x821927DC;
		  /* 821927DCh */ case    3:  		/* rlwinm. R11, R8, 0, 10, 12 */
		/* 821927DCh case    3:*/		cpu::op::rlwinm<1,0,10,12>(regs,&regs.R11,regs.R8);
		/* 821927DCh case    3:*/		return 0x821927E0;
		  /* 821927E0h */ case    4:  		/* li R11, 1 */
		/* 821927E0h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821927E0h case    4:*/		return 0x821927E4;
		  /* 821927E4h */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 821927E4h case    5:*/		if ( regs.CR[0].eq ) { return 0x821927EC;  }
		/* 821927E4h case    5:*/		return 0x821927E8;
	}
	return 0x821927E8;
} // Block from 821927D0h-821927E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821927E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821927E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821927E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821927E8);
		  /* 821927E8h */ case    0:  		/* li R11, 0 */
		/* 821927E8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821927E8h case    0:*/		return 0x821927EC;
	}
	return 0x821927EC;
} // Block from 821927E8h-821927ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821927ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821927EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821927EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821927EC);
		  /* 821927ECh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821927ECh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821927ECh case    0:*/		return 0x821927F0;
		  /* 821927F0h */ case    1:  		/* bc 12, CR0_EQ, 64 */
		/* 821927F0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82192830;  }
		/* 821927F0h case    1:*/		return 0x821927F4;
		  /* 821927F4h */ case    2:  		/* lwz R10, <#[R27]> */
		/* 821927F4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 821927F4h case    2:*/		return 0x821927F8;
		  /* 821927F8h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 821927F8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821927F8h case    3:*/		return 0x821927FC;
		  /* 821927FCh */ case    4:  		/* bc 12, CR6_EQ, 1060 */
		/* 821927FCh case    4:*/		if ( regs.CR[6].eq ) { return 0x82192C20;  }
		/* 821927FCh case    4:*/		return 0x82192800;
		  /* 82192800h */ case    5:  		/* lwz R11, <#[R10]> */
		/* 82192800h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82192800h case    5:*/		return 0x82192804;
		  /* 82192804h */ case    6:  		/* rlwinm. R9, R11, 0, 1, 1 */
		/* 82192804h case    6:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R9,regs.R11);
		/* 82192804h case    6:*/		return 0x82192808;
		  /* 82192808h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 82192808h case    7:*/		if ( regs.CR[0].eq ) { return 0x82192818;  }
		/* 82192808h case    7:*/		return 0x8219280C;
		  /* 8219280Ch */ case    8:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 8219280Ch case    8:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 8219280Ch case    8:*/		return 0x82192810;
		  /* 82192810h */ case    9:  		/* li R11, 1 */
		/* 82192810h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192810h case    9:*/		return 0x82192814;
		  /* 82192814h */ case   10:  		/* bc 12, CR0_EQ, 8 */
		/* 82192814h case   10:*/		if ( regs.CR[0].eq ) { return 0x8219281C;  }
		/* 82192814h case   10:*/		return 0x82192818;
	}
	return 0x82192818;
} // Block from 821927ECh-82192818h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82192818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192818);
		  /* 82192818h */ case    0:  		/* li R11, 0 */
		/* 82192818h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192818h case    0:*/		return 0x8219281C;
	}
	return 0x8219281C;
} // Block from 82192818h-8219281Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219281Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219281C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219281C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219281C);
		  /* 8219281Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219281Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219281Ch case    0:*/		return 0x82192820;
		  /* 82192820h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 82192820h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219282C;  }
		/* 82192820h case    1:*/		return 0x82192824;
		  /* 82192824h */ case    2:  		/* lwz R10, <#[R10 + 4]> */
		/* 82192824h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82192824h case    2:*/		return 0x82192828;
		  /* 82192828h */ case    3:  		/* b -48 */
		/* 82192828h case    3:*/		return 0x821927F8;
		/* 82192828h case    3:*/		return 0x8219282C;
	}
	return 0x8219282C;
} // Block from 8219281Ch-8219282Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219282Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219282C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219282C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219282C);
		  /* 8219282Ch */ case    0:  		/* lwz R10, <#[R10 + 12]> */
		/* 8219282Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 8219282Ch case    0:*/		return 0x82192830;
	}
	return 0x82192830;
} // Block from 8219282Ch-82192830h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192830h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192830);
		  /* 82192830h */ case    0:  		/* lwz R28, <#[R10 + 4]> */
		/* 82192830h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + 0x00000004) );
		/* 82192830h case    0:*/		return 0x82192834;
		  /* 82192834h */ case    1:  		/* cmplwi CR6, R28, 0 */
		/* 82192834h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82192834h case    1:*/		return 0x82192838;
		  /* 82192838h */ case    2:  		/* bc 12, CR6_EQ, 212 */
		/* 82192838h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219290C;  }
		/* 82192838h case    2:*/		return 0x8219283C;
		  /* 8219283Ch */ case    3:  		/* lwz R29, <#[R28 + 16]> */
		/* 8219283Ch case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R28 + 0x00000010) );
		/* 8219283Ch case    3:*/		return 0x82192840;
		  /* 82192840h */ case    4:  		/* cmplwi CR6, R29, 0 */
		/* 82192840h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82192840h case    4:*/		return 0x82192844;
		  /* 82192844h */ case    5:  		/* bc 12, CR6_EQ, 192 */
		/* 82192844h case    5:*/		if ( regs.CR[6].eq ) { return 0x82192904;  }
		/* 82192844h case    5:*/		return 0x82192848;
		  /* 82192848h */ case    6:  		/* lwz R11, <#[R28]> */
		/* 82192848h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82192848h case    6:*/		return 0x8219284C;
		  /* 8219284Ch */ case    7:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 8219284Ch case    7:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 8219284Ch case    7:*/		return 0x82192850;
		  /* 82192850h */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 82192850h case    8:*/		if ( regs.CR[0].eq ) { return 0x82192860;  }
		/* 82192850h case    8:*/		return 0x82192854;
		  /* 82192854h */ case    9:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82192854h case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82192854h case    9:*/		return 0x82192858;
		  /* 82192858h */ case   10:  		/* li R11, 1 */
		/* 82192858h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192858h case   10:*/		return 0x8219285C;
		  /* 8219285Ch */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 8219285Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x82192864;  }
		/* 8219285Ch case   11:*/		return 0x82192860;
	}
	return 0x82192860;
} // Block from 82192830h-82192860h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82192860h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192860);
		  /* 82192860h */ case    0:  		/* li R11, 0 */
		/* 82192860h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192860h case    0:*/		return 0x82192864;
	}
	return 0x82192864;
} // Block from 82192860h-82192864h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192864);
		  /* 82192864h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192864h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192864h case    0:*/		return 0x82192868;
		  /* 82192868h */ case    1:  		/* bc 12, CR0_EQ, 156 */
		/* 82192868h case    1:*/		if ( regs.CR[0].eq ) { return 0x82192904;  }
		/* 82192868h case    1:*/		return 0x8219286C;
		  /* 8219286Ch */ case    2:  		/* lwz R30, <#[R27 + 4]> */
		/* 8219286Ch case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x00000004) );
		/* 8219286Ch case    2:*/		return 0x82192870;
		  /* 82192870h */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 82192870h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82192870h case    3:*/		return 0x82192874;
		  /* 82192874h */ case    4:  		/* bc 12, CR6_EQ, 144 */
		/* 82192874h case    4:*/		if ( regs.CR[6].eq ) { return 0x82192904;  }
		/* 82192874h case    4:*/		return 0x82192878;
		  /* 82192878h */ case    5:  		/* lwz R31, <#[R30 + 16]> */
		/* 82192878h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000010) );
		/* 82192878h case    5:*/		return 0x8219287C;
		  /* 8219287Ch */ case    6:  		/* cmplwi CR6, R31, 0 */
		/* 8219287Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219287Ch case    6:*/		return 0x82192880;
		  /* 82192880h */ case    7:  		/* bc 12, CR6_EQ, 124 */
		/* 82192880h case    7:*/		if ( regs.CR[6].eq ) { return 0x821928FC;  }
		/* 82192880h case    7:*/		return 0x82192884;
		  /* 82192884h */ case    8:  		/* lwz R11, <#[R30]> */
		/* 82192884h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82192884h case    8:*/		return 0x82192888;
		  /* 82192888h */ case    9:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 82192888h case    9:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 82192888h case    9:*/		return 0x8219288C;
		  /* 8219288Ch */ case   10:  		/* bc 12, CR0_EQ, 16 */
		/* 8219288Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x8219289C;  }
		/* 8219288Ch case   10:*/		return 0x82192890;
		  /* 82192890h */ case   11:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82192890h case   11:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82192890h case   11:*/		return 0x82192894;
		  /* 82192894h */ case   12:  		/* li R11, 1 */
		/* 82192894h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192894h case   12:*/		return 0x82192898;
	}
	return 0x82192898;
} // Block from 82192864h-82192898h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82192898h
// Function '?MakeInstr_S_SUB_CONST_0@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@PAVDependency@2@2@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192898);
		  /* 82192898h */ case    0:  		/* bc 12, CR0_EQ, 8 */
		/* 82192898h case    0:*/		if ( regs.CR[0].eq ) { return 0x821928A0;  }
		/* 82192898h case    0:*/		return 0x8219289C;
	}
	return 0x8219289C;
} // Block from 82192898h-8219289Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219289Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219289C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219289C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219289C);
		  /* 8219289Ch */ case    0:  		/* li R11, 0 */
		/* 8219289Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219289Ch case    0:*/		return 0x821928A0;
	}
	return 0x821928A0;
} // Block from 8219289Ch-821928A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821928A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821928A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821928A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821928A0);
		  /* 821928A0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821928A0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821928A0h case    0:*/		return 0x821928A4;
		  /* 821928A4h */ case    1:  		/* bc 4, CR0_EQ, 88 */
		/* 821928A4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821928FC;  }
		/* 821928A4h case    1:*/		return 0x821928A8;
		  /* 821928A8h */ case    2:  		/* mr R3, R31 */
		/* 821928A8h case    2:*/		regs.R3 = regs.R31;
		/* 821928A8h case    2:*/		return 0x821928AC;
		  /* 821928ACh */ case    3:  		/* bl -3740 */
		/* 821928ACh case    3:*/		regs.LR = 0x821928B0; return 0x82191A10;
		/* 821928ACh case    3:*/		return 0x821928B0;
		  /* 821928B0h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821928B0h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821928B0h case    4:*/		return 0x821928B4;
		  /* 821928B4h */ case    5:  		/* bc 12, CR0_EQ, 72 */
		/* 821928B4h case    5:*/		if ( regs.CR[0].eq ) { return 0x821928FC;  }
		/* 821928B4h case    5:*/		return 0x821928B8;
		  /* 821928B8h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 821928B8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821928B8h case    6:*/		return 0x821928BC;
		  /* 821928BCh */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 821928BCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821928BCh case    7:*/		return 0x821928C0;
		  /* 821928C0h */ case    8:  		/* bc 12, CR6_EQ, 32 */
		/* 821928C0h case    8:*/		if ( regs.CR[6].eq ) { return 0x821928E0;  }
		/* 821928C0h case    8:*/		return 0x821928C4;
		  /* 821928C4h */ case    9:  		/* lwz R10, <#[R11 + 12]> */
		/* 821928C4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821928C4h case    9:*/		return 0x821928C8;
		  /* 821928C8h */ case   10:  		/* cmplw CR6, R10, R29 */
		/* 821928C8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 821928C8h case   10:*/		return 0x821928CC;
		  /* 821928CCh */ case   11:  		/* bc 12, CR6_EQ, 12 */
		/* 821928CCh case   11:*/		if ( regs.CR[6].eq ) { return 0x821928D8;  }
		/* 821928CCh case   11:*/		return 0x821928D0;
		  /* 821928D0h */ case   12:  		/* lwz R11, <#[R11 + 4]> */
		/* 821928D0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821928D0h case   12:*/		return 0x821928D4;
		  /* 821928D4h */ case   13:  		/* b -24 */
		/* 821928D4h case   13:*/		return 0x821928BC;
		/* 821928D4h case   13:*/		return 0x821928D8;
	}
	return 0x821928D8;
} // Block from 821928A0h-821928D8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821928D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821928D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821928D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821928D8);
		  /* 821928D8h */ case    0:  		/* li R11, 1 */
		/* 821928D8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821928D8h case    0:*/		return 0x821928DC;
		  /* 821928DCh */ case    1:  		/* b 8 */
		/* 821928DCh case    1:*/		return 0x821928E4;
		/* 821928DCh case    1:*/		return 0x821928E0;
	}
	return 0x821928E0;
} // Block from 821928D8h-821928E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821928E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821928E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821928E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821928E0);
		  /* 821928E0h */ case    0:  		/* li R11, 0 */
		/* 821928E0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821928E0h case    0:*/		return 0x821928E4;
	}
	return 0x821928E4;
} // Block from 821928E0h-821928E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821928E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821928E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821928E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821928E4);
		  /* 821928E4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821928E4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821928E4h case    0:*/		return 0x821928E8;
		  /* 821928E8h */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 821928E8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821928FC;  }
		/* 821928E8h case    1:*/		return 0x821928EC;
		  /* 821928ECh */ case    2:  		/* mr R5, R22 */
		/* 821928ECh case    2:*/		regs.R5 = regs.R22;
		/* 821928ECh case    2:*/		return 0x821928F0;
		  /* 821928F0h */ case    3:  		/* mr R4, R29 */
		/* 821928F0h case    3:*/		regs.R4 = regs.R29;
		/* 821928F0h case    3:*/		return 0x821928F4;
		  /* 821928F4h */ case    4:  		/* mr R3, R31 */
		/* 821928F4h case    4:*/		regs.R3 = regs.R31;
		/* 821928F4h case    4:*/		return 0x821928F8;
		  /* 821928F8h */ case    5:  		/* bl -108136 */
		/* 821928F8h case    5:*/		regs.LR = 0x821928FC; return 0x82178290;
		/* 821928F8h case    5:*/		return 0x821928FC;
	}
	return 0x821928FC;
} // Block from 821928E4h-821928FCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821928FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821928FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821928FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821928FC);
		  /* 821928FCh */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 821928FCh case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 821928FCh case    0:*/		return 0x82192900;
		  /* 82192900h */ case    1:  		/* b -144 */
		/* 82192900h case    1:*/		return 0x82192870;
		/* 82192900h case    1:*/		return 0x82192904;
	}
	return 0x82192904;
} // Block from 821928FCh-82192904h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82192904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192904);
		  /* 82192904h */ case    0:  		/* lwz R28, <#[R28 + 8]> */
		/* 82192904h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x00000008) );
		/* 82192904h case    0:*/		return 0x82192908;
		  /* 82192908h */ case    1:  		/* b -212 */
		/* 82192908h case    1:*/		return 0x82192834;
		/* 82192908h case    1:*/		return 0x8219290C;
	}
	return 0x8219290C;
} // Block from 82192904h-8219290Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219290Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219290C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219290C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219290C);
		  /* 8219290Ch */ case    0:  		/* lwz R11, <#[R27 + 8]> */
		/* 8219290Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8219290Ch case    0:*/		return 0x82192910;
		  /* 82192910h */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82192910h case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82192910h case    1:*/		return 0x82192914;
		  /* 82192914h */ case    2:  		/* cmplwi CR6, R11, 12032 */
		/* 82192914h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002F00);
		/* 82192914h case    2:*/		return 0x82192918;
		  /* 82192918h */ case    3:  		/* bc 4, CR6_EQ, 196 */
		/* 82192918h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821929DC;  }
		/* 82192918h case    3:*/		return 0x8219291C;
		  /* 8219291Ch */ case    4:  		/* mr R31, R27 */
		/* 8219291Ch case    4:*/		regs.R31 = regs.R27;
		/* 8219291Ch case    4:*/		return 0x82192920;
		  /* 82192920h */ case    5:  		/* lwz R9, <#[R31 + 4]> */
		/* 82192920h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 82192920h case    5:*/		return 0x82192924;
		  /* 82192924h */ case    6:  		/* cmplwi CR6, R9, 0 */
		/* 82192924h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82192924h case    6:*/		return 0x82192928;
		  /* 82192928h */ case    7:  		/* bc 12, CR6_EQ, 180 */
		/* 82192928h case    7:*/		if ( regs.CR[6].eq ) { return 0x821929DC;  }
		/* 82192928h case    7:*/		return 0x8219292C;
		  /* 8219292Ch */ case    8:  		/* lwz R11, <#[R9 + 16]> */
		/* 8219292Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000010) );
		/* 8219292Ch case    8:*/		return 0x82192930;
		  /* 82192930h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82192930h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82192930h case    9:*/		return 0x82192934;
		  /* 82192934h */ case   10:  		/* bc 12, CR6_EQ, 80 */
		/* 82192934h case   10:*/		if ( regs.CR[6].eq ) { return 0x82192984;  }
		/* 82192934h case   10:*/		return 0x82192938;
		  /* 82192938h */ case   11:  		/* lwz R10, <#[R9]> */
		/* 82192938h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 82192938h case   11:*/		return 0x8219293C;
		  /* 8219293Ch */ case   12:  		/* rlwinm. R11, R10, 0, 1, 1 */
		/* 8219293Ch case   12:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R10);
		/* 8219293Ch case   12:*/		return 0x82192940;
		  /* 82192940h */ case   13:  		/* bc 4, CR0_EQ, 16 */
		/* 82192940h case   13:*/		if ( !regs.CR[0].eq ) { return 0x82192950;  }
		/* 82192940h case   13:*/		return 0x82192944;
		  /* 82192944h */ case   14:  		/* rlwinm. R11, R10, 0, 4, 6 */
		/* 82192944h case   14:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R10);
		/* 82192944h case   14:*/		return 0x82192948;
		  /* 82192948h */ case   15:  		/* li R11, 1 */
		/* 82192948h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192948h case   15:*/		return 0x8219294C;
		  /* 8219294Ch */ case   16:  		/* bc 12, CR0_EQ, 8 */
		/* 8219294Ch case   16:*/		if ( regs.CR[0].eq ) { return 0x82192954;  }
		/* 8219294Ch case   16:*/		return 0x82192950;
	}
	return 0x82192950;
} // Block from 8219290Ch-82192950h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82192950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192950);
		  /* 82192950h */ case    0:  		/* li R11, 0 */
		/* 82192950h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192950h case    0:*/		return 0x82192954;
	}
	return 0x82192954;
} // Block from 82192950h-82192954h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192954);
		  /* 82192954h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192954h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192954h case    0:*/		return 0x82192958;
		  /* 82192958h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82192958h case    1:*/		if ( regs.CR[0].eq ) { return 0x82192968;  }
		/* 82192958h case    1:*/		return 0x8219295C;
		  /* 8219295Ch */ case    2:  		/* rlwinm. R11, R10, 0, 7, 18 */
		/* 8219295Ch case    2:*/		cpu::op::rlwinm<1,0,7,18>(regs,&regs.R11,regs.R10);
		/* 8219295Ch case    2:*/		return 0x82192960;
		  /* 82192960h */ case    3:  		/* li R11, 1 */
		/* 82192960h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192960h case    3:*/		return 0x82192964;
		  /* 82192964h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 82192964h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8219296C;  }
		/* 82192964h case    4:*/		return 0x82192968;
	}
	return 0x82192968;
} // Block from 82192954h-82192968h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82192968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192968);
		  /* 82192968h */ case    0:  		/* li R11, 0 */
		/* 82192968h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192968h case    0:*/		return 0x8219296C;
	}
	return 0x8219296C;
} // Block from 82192968h-8219296Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219296Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219296C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219296C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219296C);
		  /* 8219296Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219296Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219296Ch case    0:*/		return 0x82192970;
	}
	return 0x82192970;
} // Block from 8219296Ch-82192970h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192970h
// Function '?MakeInstr_T_SET_TEX_LOD@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192970);
		  /* 82192970h */ case    0:  		/* bc 12, CR0_EQ, 20 */
		/* 82192970h case    0:*/		if ( regs.CR[0].eq ) { return 0x82192984;  }
		/* 82192970h case    0:*/		return 0x82192974;
		  /* 82192974h */ case    1:  		/* rlwinm R11, R10, 19, 20, 31 */
		/* 82192974h case    1:*/		cpu::op::rlwinm<0,19,20,31>(regs,&regs.R11,regs.R10);
		/* 82192974h case    1:*/		return 0x82192978;
		  /* 82192978h */ case    2:  		/* addi R11, R11, -1 */
		/* 82192978h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82192978h case    2:*/		return 0x8219297C;
		  /* 8219297Ch */ case    3:  		/* cmpwi CR6, R11, 2 */
		/* 8219297Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 8219297Ch case    3:*/		return 0x82192980;
		  /* 82192980h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 82192980h case    4:*/		if ( regs.CR[6].eq ) { return 0x8219298C;  }
		/* 82192980h case    4:*/		return 0x82192984;
	}
	return 0x82192984;
} // Block from 82192970h-82192984h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82192984h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192984( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192984) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192984);
		  /* 82192984h */ case    0:  		/* lwz R9, <#[R9 + 8]> */
		/* 82192984h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 82192984h case    0:*/		return 0x82192988;
		  /* 82192988h */ case    1:  		/* b -100 */
		/* 82192988h case    1:*/		return 0x82192924;
		/* 82192988h case    1:*/		return 0x8219298C;
	}
	return 0x8219298C;
} // Block from 82192984h-8219298Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219298Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219298C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219298C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219298C);
		  /* 8219298Ch */ case    0:  		/* lwz R31, <#[R9 + 16]> */
		/* 8219298Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R9 + 0x00000010) );
		/* 8219298Ch case    0:*/		return 0x82192990;
		  /* 82192990h */ case    1:  		/* lwz R11, <#[R31 + 8]> */
		/* 82192990h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82192990h case    1:*/		return 0x82192994;
		  /* 82192994h */ case    2:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82192994h case    2:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82192994h case    2:*/		return 0x82192998;
		  /* 82192998h */ case    3:  		/* cmplwi CR6, R11, 12032 */
		/* 82192998h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002F00);
		/* 82192998h case    3:*/		return 0x8219299C;
		  /* 8219299Ch */ case    4:  		/* bc 12, CR6_EQ, 64 */
		/* 8219299Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x821929DC;  }
		/* 8219299Ch case    4:*/		return 0x821929A0;
		  /* 821929A0h */ case    5:  		/* li R5, 8 */
		/* 821929A0h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x8);
		/* 821929A0h case    5:*/		return 0x821929A4;
		  /* 821929A4h */ case    6:  		/* mr R4, R27 */
		/* 821929A4h case    6:*/		regs.R4 = regs.R27;
		/* 821929A4h case    6:*/		return 0x821929A8;
		  /* 821929A8h */ case    7:  		/* mr R3, R22 */
		/* 821929A8h case    7:*/		regs.R3 = regs.R22;
		/* 821929A8h case    7:*/		return 0x821929AC;
		  /* 821929ACh */ case    8:  		/* bl -139868 */
		/* 821929ACh case    8:*/		regs.LR = 0x821929B0; return 0x82170750;
		/* 821929ACh case    8:*/		return 0x821929B0;
		  /* 821929B0h */ case    9:  		/* mr R4, R3 */
		/* 821929B0h case    9:*/		regs.R4 = regs.R3;
		/* 821929B0h case    9:*/		return 0x821929B4;
		  /* 821929B4h */ case   10:  		/* mr R3, R31 */
		/* 821929B4h case   10:*/		regs.R3 = regs.R31;
		/* 821929B4h case   10:*/		return 0x821929B8;
		  /* 821929B8h */ case   11:  		/* bl -108528 */
		/* 821929B8h case   11:*/		regs.LR = 0x821929BC; return 0x821781C8;
		/* 821929B8h case   11:*/		return 0x821929BC;
		  /* 821929BCh */ case   12:  		/* li R5, 5 */
		/* 821929BCh case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x5);
		/* 821929BCh case   12:*/		return 0x821929C0;
		  /* 821929C0h */ case   13:  		/* mr R4, R27 */
		/* 821929C0h case   13:*/		regs.R4 = regs.R27;
		/* 821929C0h case   13:*/		return 0x821929C4;
		  /* 821929C4h */ case   14:  		/* mr R3, R22 */
		/* 821929C4h case   14:*/		regs.R3 = regs.R22;
		/* 821929C4h case   14:*/		return 0x821929C8;
		  /* 821929C8h */ case   15:  		/* bl -139896 */
		/* 821929C8h case   15:*/		regs.LR = 0x821929CC; return 0x82170750;
		/* 821929C8h case   15:*/		return 0x821929CC;
		  /* 821929CCh */ case   16:  		/* mr R4, R3 */
		/* 821929CCh case   16:*/		regs.R4 = regs.R3;
		/* 821929CCh case   16:*/		return 0x821929D0;
		  /* 821929D0h */ case   17:  		/* mr R3, R31 */
		/* 821929D0h case   17:*/		regs.R3 = regs.R31;
		/* 821929D0h case   17:*/		return 0x821929D4;
		  /* 821929D4h */ case   18:  		/* bl -108556 */
		/* 821929D4h case   18:*/		regs.LR = 0x821929D8; return 0x821781C8;
		/* 821929D4h case   18:*/		return 0x821929D8;
		  /* 821929D8h */ case   19:  		/* b -184 */
		/* 821929D8h case   19:*/		return 0x82192920;
		/* 821929D8h case   19:*/		return 0x821929DC;
	}
	return 0x821929DC;
} // Block from 8219298Ch-821929DCh (20 instructions)

//////////////////////////////////////////////////////
// Block at 821929DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821929DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821929DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821929DC);
		  /* 821929DCh */ case    0:  		/* lwz R11, <#[R27 + 8]> */
		/* 821929DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 821929DCh case    0:*/		return 0x821929E0;
		  /* 821929E0h */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821929E0h case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821929E0h case    1:*/		return 0x821929E4;
		  /* 821929E4h */ case    2:  		/* cmplwi CR6, R11, 12160 */
		/* 821929E4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002F80);
		/* 821929E4h case    2:*/		return 0x821929E8;
		  /* 821929E8h */ case    3:  		/* bc 4, CR6_EQ, 80 */
		/* 821929E8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82192A38;  }
		/* 821929E8h case    3:*/		return 0x821929EC;
		  /* 821929ECh */ case    4:  		/* lwz R31, <#[R19 + 4]> */
		/* 821929ECh case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R19 + 0x00000004) );
		/* 821929ECh case    4:*/		return 0x821929F0;
		  /* 821929F0h */ case    5:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 821929F0h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 821929F0h case    5:*/		return 0x821929F4;
		  /* 821929F4h */ case    6:  		/* bc 4, CR0_EQ, 68 */
		/* 821929F4h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82192A38;  }
		/* 821929F4h case    6:*/		return 0x821929F8;
		  /* 821929F8h */ case    7:  		/* cmplwi CR0, R31, 0 */
		/* 821929F8h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 821929F8h case    7:*/		return 0x821929FC;
		  /* 821929FCh */ case    8:  		/* bc 12, CR0_EQ, 60 */
		/* 821929FCh case    8:*/		if ( regs.CR[0].eq ) { return 0x82192A38;  }
		/* 821929FCh case    8:*/		return 0x82192A00;
		  /* 82192A00h */ case    9:  		/* lwz R11, <#[R31 + 8]> */
		/* 82192A00h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82192A00h case    9:*/		return 0x82192A04;
		  /* 82192A04h */ case   10:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82192A04h case   10:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82192A04h case   10:*/		return 0x82192A08;
		  /* 82192A08h */ case   11:  		/* cmplwi CR6, R11, 12288 */
		/* 82192A08h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003000);
		/* 82192A08h case   11:*/		return 0x82192A0C;
		  /* 82192A0Ch */ case   12:  		/* bc 4, CR6_EQ, 20 */
		/* 82192A0Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x82192A20;  }
		/* 82192A0Ch case   12:*/		return 0x82192A10;
		  /* 82192A10h */ case   13:  		/* mr R5, R22 */
		/* 82192A10h case   13:*/		regs.R5 = regs.R22;
		/* 82192A10h case   13:*/		return 0x82192A14;
		  /* 82192A14h */ case   14:  		/* mr R4, R31 */
		/* 82192A14h case   14:*/		regs.R4 = regs.R31;
		/* 82192A14h case   14:*/		return 0x82192A18;
	}
	return 0x82192A18;
} // Block from 821929DCh-82192A18h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82192A18h
// Function '?MakeInstr_T_SET_GRADIENTS_H@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192A18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192A18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192A18);
		  /* 82192A18h */ case    0:  		/* mr R3, R27 */
		/* 82192A18h case    0:*/		regs.R3 = regs.R27;
		/* 82192A18h case    0:*/		return 0x82192A1C;
		  /* 82192A1Ch */ case    1:  		/* bl -108428 */
		/* 82192A1Ch case    1:*/		regs.LR = 0x82192A20; return 0x82178290;
		/* 82192A1Ch case    1:*/		return 0x82192A20;
	}
	return 0x82192A20;
} // Block from 82192A18h-82192A20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82192A20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192A20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192A20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192A20);
		  /* 82192A20h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82192A20h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82192A20h case    0:*/		return 0x82192A24;
		  /* 82192A24h */ case    1:  		/* lwz R31, <#[R11 + 40]> */
		/* 82192A24h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000028) );
		/* 82192A24h case    1:*/		return 0x82192A28;
		  /* 82192A28h */ case    2:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 82192A28h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 82192A28h case    2:*/		return 0x82192A2C;
		  /* 82192A2Ch */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 82192A2Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x82192A38;  }
		/* 82192A2Ch case    3:*/		return 0x82192A30;
		  /* 82192A30h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 82192A30h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82192A30h case    4:*/		return 0x82192A34;
		  /* 82192A34h */ case    5:  		/* bc 4, CR6_EQ, -52 */
		/* 82192A34h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82192A00;  }
		/* 82192A34h case    5:*/		return 0x82192A38;
	}
	return 0x82192A38;
} // Block from 82192A20h-82192A38h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82192A38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192A38);
		  /* 82192A38h */ case    0:  		/* lwz R6, <#[R27 + 4]> */
		/* 82192A38h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R27 + 0x00000004) );
		/* 82192A38h case    0:*/		return 0x82192A3C;
		  /* 82192A3Ch */ case    1:  		/* addi R10, R27, 4 */
		/* 82192A3Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0x4);
		/* 82192A3Ch case    1:*/		return 0x82192A40;
		  /* 82192A40h */ case    2:  		/* li R5, 0 */
		/* 82192A40h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82192A40h case    2:*/		return 0x82192A44;
		  /* 82192A44h */ case    3:  		/* cmplwi CR6, R6, 0 */
		/* 82192A44h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82192A44h case    3:*/		return 0x82192A48;
		  /* 82192A48h */ case    4:  		/* bc 12, CR6_EQ, 204 */
		/* 82192A48h case    4:*/		if ( regs.CR[6].eq ) { return 0x82192B14;  }
		/* 82192A48h case    4:*/		return 0x82192A4C;
		  /* 82192A4Ch */ case    5:  		/* lwz R9, <#[R6 + 16]> */
		/* 82192A4Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000010) );
		/* 82192A4Ch case    5:*/		return 0x82192A50;
		  /* 82192A50h */ case    6:  		/* cmplwi CR6, R9, 0 */
		/* 82192A50h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82192A50h case    6:*/		return 0x82192A54;
		  /* 82192A54h */ case    7:  		/* bc 12, CR6_EQ, 184 */
		/* 82192A54h case    7:*/		if ( regs.CR[6].eq ) { return 0x82192B0C;  }
		/* 82192A54h case    7:*/		return 0x82192A58;
		  /* 82192A58h */ case    8:  		/* lwz R8, <#[R6]> */
		/* 82192A58h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + 0x00000000) );
		/* 82192A58h case    8:*/		return 0x82192A5C;
		  /* 82192A5Ch */ case    9:  		/* rlwinm. R7, R8, 2, 31, 31 */
		/* 82192A5Ch case    9:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R7,regs.R8);
		/* 82192A5Ch case    9:*/		return 0x82192A60;
		  /* 82192A60h */ case   10:  		/* bc 4, CR0_EQ, 16 */
		/* 82192A60h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82192A70;  }
		/* 82192A60h case   10:*/		return 0x82192A64;
		  /* 82192A64h */ case   11:  		/* rlwinm. R11, R8, 0, 4, 6 */
		/* 82192A64h case   11:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R8);
		/* 82192A64h case   11:*/		return 0x82192A68;
		  /* 82192A68h */ case   12:  		/* li R11, 0 */
		/* 82192A68h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192A68h case   12:*/		return 0x82192A6C;
		  /* 82192A6Ch */ case   13:  		/* bc 12, CR0_EQ, 8 */
		/* 82192A6Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x82192A74;  }
		/* 82192A6Ch case   13:*/		return 0x82192A70;
	}
	return 0x82192A70;
} // Block from 82192A38h-82192A70h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82192A70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192A70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192A70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192A70);
		  /* 82192A70h */ case    0:  		/* li R11, 1 */
		/* 82192A70h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192A70h case    0:*/		return 0x82192A74;
	}
	return 0x82192A74;
} // Block from 82192A70h-82192A74h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192A74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192A74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192A74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192A74);
		  /* 82192A74h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192A74h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192A74h case    0:*/		return 0x82192A78;
		  /* 82192A78h */ case    1:  		/* bc 12, CR0_EQ, 148 */
		/* 82192A78h case    1:*/		if ( regs.CR[0].eq ) { return 0x82192B0C;  }
		/* 82192A78h case    1:*/		return 0x82192A7C;
		  /* 82192A7Ch */ case    2:  		/* lwz R11, <#[R9 + 8]> */
		/* 82192A7Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 82192A7Ch case    2:*/		return 0x82192A80;
		  /* 82192A80h */ case    3:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82192A80h case    3:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82192A80h case    3:*/		return 0x82192A84;
		  /* 82192A84h */ case    4:  		/* cmplwi CR6, R11, 14336 */
		/* 82192A84h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 82192A84h case    4:*/		return 0x82192A88;
		  /* 82192A88h */ case    5:  		/* bc 4, CR6_EQ, 28 */
		/* 82192A88h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82192AA4;  }
		/* 82192A88h case    5:*/		return 0x82192A8C;
		  /* 82192A8Ch */ case    6:  		/* rlwinm. R11, R5, 0, 24, 31 */
		/* 82192A8Ch case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R5);
		/* 82192A8Ch case    6:*/		return 0x82192A90;
		  /* 82192A90h */ case    7:  		/* bc 4, CR0_EQ, 124 */
		/* 82192A90h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82192B0C;  }
		/* 82192A90h case    7:*/		return 0x82192A94;
		  /* 82192A94h */ case    8:  		/* stw R21, <#[R27 + 32]> */
		/* 82192A94h case    8:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R27 + 0x00000020) );
		/* 82192A94h case    8:*/		return 0x82192A98;
		  /* 82192A98h */ case    9:  		/* mr R21, R27 */
		/* 82192A98h case    9:*/		regs.R21 = regs.R27;
		/* 82192A98h case    9:*/		return 0x82192A9C;
		  /* 82192A9Ch */ case   10:  		/* li R5, 1 */
		/* 82192A9Ch case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82192A9Ch case   10:*/		return 0x82192AA0;
		  /* 82192AA0h */ case   11:  		/* b 108 */
		/* 82192AA0h case   11:*/		return 0x82192B0C;
		/* 82192AA0h case   11:*/		return 0x82192AA4;
	}
	return 0x82192AA4;
} // Block from 82192A74h-82192AA4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82192AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192AA4);
		  /* 82192AA4h */ case    0:  		/* lwz R11, <#[R27 + 8]> */
		/* 82192AA4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 82192AA4h case    0:*/		return 0x82192AA8;
		  /* 82192AA8h */ case    1:  		/* li R9, 1 */
		/* 82192AA8h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82192AA8h case    1:*/		return 0x82192AAC;
		  /* 82192AACh */ case    2:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82192AACh case    2:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82192AACh case    2:*/		return 0x82192AB0;
		  /* 82192AB0h */ case    3:  		/* cmplwi CR6, R11, 96 */
		/* 82192AB0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000060);
		/* 82192AB0h case    3:*/		return 0x82192AB4;
		  /* 82192AB4h */ case    4:  		/* bc 12, CR6_LT, 16 */
		/* 82192AB4h case    4:*/		if ( regs.CR[6].lt ) { return 0x82192AC4;  }
		/* 82192AB4h case    4:*/		return 0x82192AB8;
		  /* 82192AB8h */ case    5:  		/* cmplwi CR6, R11, 102 */
		/* 82192AB8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000066);
		/* 82192AB8h case    5:*/		return 0x82192ABC;
		  /* 82192ABCh */ case    6:  		/* li R11, 1 */
		/* 82192ABCh case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192ABCh case    6:*/		return 0x82192AC0;
	}
	return 0x82192AC0;
} // Block from 82192AA4h-82192AC0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82192AC0h
// Function '?MakeInstr_T_SET_GRADIENTS_V@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192AC0);
		  /* 82192AC0h */ case    0:  		/* bc 4, CR6_GT, 8 */
		/* 82192AC0h case    0:*/		if ( !regs.CR[6].gt ) { return 0x82192AC8;  }
		/* 82192AC0h case    0:*/		return 0x82192AC4;
	}
	return 0x82192AC4;
} // Block from 82192AC0h-82192AC4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192AC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192AC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192AC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192AC4);
		  /* 82192AC4h */ case    0:  		/* li R11, 0 */
		/* 82192AC4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192AC4h case    0:*/		return 0x82192AC8;
	}
	return 0x82192AC8;
} // Block from 82192AC4h-82192AC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192AC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192AC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192AC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192AC8);
		  /* 82192AC8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192AC8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192AC8h case    0:*/		return 0x82192ACC;
		  /* 82192ACCh */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82192ACCh case    1:*/		if ( regs.CR[0].eq ) { return 0x82192AD8;  }
		/* 82192ACCh case    1:*/		return 0x82192AD0;
		  /* 82192AD0h */ case    2:  		/* li R9, 3 */
		/* 82192AD0h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x3);
		/* 82192AD0h case    2:*/		return 0x82192AD4;
		  /* 82192AD4h */ case    3:  		/* b 48 */
		/* 82192AD4h case    3:*/		return 0x82192B04;
		/* 82192AD4h case    3:*/		return 0x82192AD8;
	}
	return 0x82192AD8;
} // Block from 82192AC8h-82192AD8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82192AD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192AD8);
		  /* 82192AD8h */ case    0:  		/* cmplwi CR6, R7, 0 */
		/* 82192AD8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82192AD8h case    0:*/		return 0x82192ADC;
		  /* 82192ADCh */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 82192ADCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82192AEC;  }
		/* 82192ADCh case    1:*/		return 0x82192AE0;
		  /* 82192AE0h */ case    2:  		/* rlwinm. R11, R8, 0, 4, 6 */
		/* 82192AE0h case    2:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R8);
		/* 82192AE0h case    2:*/		return 0x82192AE4;
		  /* 82192AE4h */ case    3:  		/* li R11, 1 */
		/* 82192AE4h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192AE4h case    3:*/		return 0x82192AE8;
		  /* 82192AE8h */ case    4:  		/* bc 12, CR0_EQ, 8 */
		/* 82192AE8h case    4:*/		if ( regs.CR[0].eq ) { return 0x82192AF0;  }
		/* 82192AE8h case    4:*/		return 0x82192AEC;
	}
	return 0x82192AEC;
} // Block from 82192AD8h-82192AECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82192AECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192AEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192AEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192AEC);
		  /* 82192AECh */ case    0:  		/* li R11, 0 */
		/* 82192AECh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192AECh case    0:*/		return 0x82192AF0;
	}
	return 0x82192AF0;
} // Block from 82192AECh-82192AF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192AF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192AF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192AF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192AF0);
		  /* 82192AF0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192AF0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192AF0h case    0:*/		return 0x82192AF4;
		  /* 82192AF4h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82192AF4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82192B04;  }
		/* 82192AF4h case    1:*/		return 0x82192AF8;
		  /* 82192AF8h */ case    2:  		/* rlwinm. R11, R8, 0, 7, 18 */
		/* 82192AF8h case    2:*/		cpu::op::rlwinm<1,0,7,18>(regs,&regs.R11,regs.R8);
		/* 82192AF8h case    2:*/		return 0x82192AFC;
		  /* 82192AFCh */ case    3:  		/* bc 4, CR0_EQ, 8 */
		/* 82192AFCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x82192B04;  }
		/* 82192AFCh case    3:*/		return 0x82192B00;
		  /* 82192B00h */ case    4:  		/* li R9, 2 */
		/* 82192B00h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 82192B00h case    4:*/		return 0x82192B04;
	}
	return 0x82192B04;
} // Block from 82192AF0h-82192B04h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82192B04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192B04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192B04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192B04);
		  /* 82192B04h */ case    0:  		/* rlwimi R8, R9, 28, 2, 3 */
		/* 82192B04h case    0:*/		cpu::op::rlwimi<0,28,2,3>(regs,&regs.R8,regs.R9);
		/* 82192B04h case    0:*/		return 0x82192B08;
		  /* 82192B08h */ case    1:  		/* stw R8, <#[R6]> */
		/* 82192B08h case    1:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000000) );
		/* 82192B08h case    1:*/		return 0x82192B0C;
	}
	return 0x82192B0C;
} // Block from 82192B04h-82192B0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82192B0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192B0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192B0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192B0C);
		  /* 82192B0Ch */ case    0:  		/* lwz R6, <#[R6 + 8]> */
		/* 82192B0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000008) );
		/* 82192B0Ch case    0:*/		return 0x82192B10;
		  /* 82192B10h */ case    1:  		/* b -204 */
		/* 82192B10h case    1:*/		return 0x82192A44;
		/* 82192B10h case    1:*/		return 0x82192B14;
	}
	return 0x82192B14;
} // Block from 82192B0Ch-82192B14h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82192B14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192B14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192B14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192B14);
		  /* 82192B14h */ case    0:  		/* rlwinm. R11, R5, 0, 24, 31 */
		/* 82192B14h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R5);
		/* 82192B14h case    0:*/		return 0x82192B18;
		  /* 82192B18h */ case    1:  		/* bc 4, CR0_EQ, 140 */
		/* 82192B18h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82192BA4;  }
		/* 82192B18h case    1:*/		return 0x82192B1C;
		  /* 82192B1Ch */ case    2:  		/* lwz R11, <#[R27 + 8]> */
		/* 82192B1Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 82192B1Ch case    2:*/		return 0x82192B20;
		  /* 82192B20h */ case    3:  		/* rlwinm. R11, R11, 7, 31, 31 */
		/* 82192B20h case    3:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R11);
		/* 82192B20h case    3:*/		return 0x82192B24;
		  /* 82192B24h */ case    4:  		/* bc 12, CR0_EQ, 128 */
		/* 82192B24h case    4:*/		if ( regs.CR[0].eq ) { return 0x82192BA4;  }
		/* 82192B24h case    4:*/		return 0x82192B28;
		  /* 82192B28h */ case    5:  		/* lwz R11, <#[R10]> */
		/* 82192B28h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82192B28h case    5:*/		return 0x82192B2C;
		  /* 82192B2Ch */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 82192B2Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82192B2Ch case    6:*/		return 0x82192B30;
		  /* 82192B30h */ case    7:  		/* bc 4, CR6_EQ, 116 */
		/* 82192B30h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82192BA4;  }
		/* 82192B30h case    7:*/		return 0x82192B34;
		  /* 82192B34h */ case    8:  		/* lwz R9, <#[R27]> */
		/* 82192B34h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000000) );
		/* 82192B34h case    8:*/		return 0x82192B38;
		  /* 82192B38h */ case    9:  		/* cmplwi CR6, R9, 0 */
		/* 82192B38h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82192B38h case    9:*/		return 0x82192B3C;
		  /* 82192B3Ch */ case   10:  		/* bc 12, CR6_EQ, 68 */
		/* 82192B3Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x82192B80;  }
		/* 82192B3Ch case   10:*/		return 0x82192B40;
		  /* 82192B40h */ case   11:  		/* lwz R11, <#[R9 + 12]> */
		/* 82192B40h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 82192B40h case   11:*/		return 0x82192B44;
		  /* 82192B44h */ case   12:  		/* lwz R11, <#[R11 + 4]> */
		/* 82192B44h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82192B44h case   12:*/		return 0x82192B48;
		  /* 82192B48h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 82192B48h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82192B48h case   13:*/		return 0x82192B4C;
		  /* 82192B4Ch */ case   14:  		/* bc 12, CR6_EQ, 40 */
		/* 82192B4Ch case   14:*/		if ( regs.CR[6].eq ) { return 0x82192B74;  }
		/* 82192B4Ch case   14:*/		return 0x82192B50;
		  /* 82192B50h */ case   15:  		/* lwz R8, <#[R11 + 16]> */
		/* 82192B50h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 82192B50h case   15:*/		return 0x82192B54;
		  /* 82192B54h */ case   16:  		/* cmplwi CR6, R8, 0 */
		/* 82192B54h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82192B54h case   16:*/		return 0x82192B58;
		  /* 82192B58h */ case   17:  		/* bc 12, CR6_EQ, 12 */
		/* 82192B58h case   17:*/		if ( regs.CR[6].eq ) { return 0x82192B64;  }
		/* 82192B58h case   17:*/		return 0x82192B5C;
		  /* 82192B5Ch */ case   18:  		/* cmplw CR6, R11, R24 */
		/* 82192B5Ch case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 82192B5Ch case   18:*/		return 0x82192B60;
		  /* 82192B60h */ case   19:  		/* bc 12, CR6_EQ, 12 */
		/* 82192B60h case   19:*/		if ( regs.CR[6].eq ) { return 0x82192B6C;  }
		/* 82192B60h case   19:*/		return 0x82192B64;
	}
	return 0x82192B64;
} // Block from 82192B14h-82192B64h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82192B64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192B64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192B64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192B64);
		  /* 82192B64h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82192B64h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82192B64h case    0:*/		return 0x82192B68;
	}
	return 0x82192B68;
} // Block from 82192B64h-82192B68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192B68h
// Function '?QueueInstruction@Scheduler@D3DXShader@@QAAXPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192B68);
		  /* 82192B68h */ case    0:  		/* b -32 */
		/* 82192B68h case    0:*/		return 0x82192B48;
		/* 82192B68h case    0:*/		return 0x82192B6C;
	}
	return 0x82192B6C;
} // Block from 82192B68h-82192B6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192B6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192B6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192B6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192B6C);
		  /* 82192B6Ch */ case    0:  		/* lwz R9, <#[R9 + 4]> */
		/* 82192B6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 82192B6Ch case    0:*/		return 0x82192B70;
		  /* 82192B70h */ case    1:  		/* b -56 */
		/* 82192B70h case    1:*/		return 0x82192B38;
		/* 82192B70h case    1:*/		return 0x82192B74;
	}
	return 0x82192B74;
} // Block from 82192B6Ch-82192B74h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82192B74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192B74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192B74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192B74);
		  /* 82192B74h */ case    0:  		/* stw R21, <#[R27 + 32]> */
		/* 82192B74h case    0:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R27 + 0x00000020) );
		/* 82192B74h case    0:*/		return 0x82192B78;
		  /* 82192B78h */ case    1:  		/* mr R21, R27 */
		/* 82192B78h case    1:*/		regs.R21 = regs.R27;
		/* 82192B78h case    1:*/		return 0x82192B7C;
		  /* 82192B7Ch */ case    2:  		/* b 40 */
		/* 82192B7Ch case    2:*/		return 0x82192BA4;
		/* 82192B7Ch case    2:*/		return 0x82192B80;
	}
	return 0x82192B80;
} // Block from 82192B74h-82192B80h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82192B80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192B80);
		  /* 82192B80h */ case    0:  		/* stw R20, <#[R27 + 32]> */
		/* 82192B80h case    0:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R27 + 0x00000020) );
		/* 82192B80h case    0:*/		return 0x82192B84;
		  /* 82192B84h */ case    1:  		/* mr R20, R27 */
		/* 82192B84h case    1:*/		regs.R20 = regs.R27;
		/* 82192B84h case    1:*/		return 0x82192B88;
		  /* 82192B88h */ case    2:  		/* lwz R11, <#[R10]> */
		/* 82192B88h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82192B88h case    2:*/		return 0x82192B8C;
		  /* 82192B8Ch */ case    3:  		/* b 12 */
		/* 82192B8Ch case    3:*/		return 0x82192B98;
		/* 82192B8Ch case    3:*/		return 0x82192B90;
		  /* 82192B90h */ case    4:  		/* addi R10, R11, 8 */
		/* 82192B90h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x8);
		/* 82192B90h case    4:*/		return 0x82192B94;
		  /* 82192B94h */ case    5:  		/* lwz R11, <#[R11 + 8]> */
		/* 82192B94h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82192B94h case    5:*/		return 0x82192B98;
	}
	return 0x82192B98;
} // Block from 82192B80h-82192B98h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82192B98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192B98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192B98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192B98);
		  /* 82192B98h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 82192B98h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82192B98h case    0:*/		return 0x82192B9C;
		  /* 82192B9Ch */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82192B9Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82192B90;  }
		/* 82192B9Ch case    1:*/		return 0x82192BA0;
		  /* 82192BA0h */ case    2:  		/* stw R24, <#[R10]> */
		/* 82192BA0h case    2:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R10 + 0x00000000) );
		/* 82192BA0h case    2:*/		return 0x82192BA4;
	}
	return 0x82192BA4;
} // Block from 82192B98h-82192BA4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82192BA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192BA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192BA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192BA4);
		  /* 82192BA4h */ case    0:  		/* mr R4, R27 */
		/* 82192BA4h case    0:*/		regs.R4 = regs.R27;
		/* 82192BA4h case    0:*/		return 0x82192BA8;
		  /* 82192BA8h */ case    1:  		/* mr R3, R22 */
		/* 82192BA8h case    1:*/		regs.R3 = regs.R22;
		/* 82192BA8h case    1:*/		return 0x82192BAC;
		  /* 82192BACh */ case    2:  		/* bl 587908 */
		/* 82192BACh case    2:*/		regs.LR = 0x82192BB0; return 0x82222430;
		/* 82192BACh case    2:*/		return 0x82192BB0;
		  /* 82192BB0h */ case    3:  		/* mr R11, R3 */
		/* 82192BB0h case    3:*/		regs.R11 = regs.R3;
		/* 82192BB0h case    3:*/		return 0x82192BB4;
		  /* 82192BB4h */ case    4:  		/* lwz R10, <#[R27 + 16]> */
		/* 82192BB4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000010) );
		/* 82192BB4h case    4:*/		return 0x82192BB8;
		  /* 82192BB8h */ case    5:  		/* mr R3, R27 */
		/* 82192BB8h case    5:*/		regs.R3 = regs.R27;
		/* 82192BB8h case    5:*/		return 0x82192BBC;
		  /* 82192BBCh */ case    6:  		/* addi R11, R11, 1 */
		/* 82192BBCh case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82192BBCh case    6:*/		return 0x82192BC0;
		  /* 82192BC0h */ case    7:  		/* rlwimi R10, R11, 21, 8, 10 */
		/* 82192BC0h case    7:*/		cpu::op::rlwimi<0,21,8,10>(regs,&regs.R10,regs.R11);
		/* 82192BC0h case    7:*/		return 0x82192BC4;
		  /* 82192BC4h */ case    8:  		/* stw R10, <#[R27 + 16]> */
		/* 82192BC4h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R27 + 0x00000010) );
		/* 82192BC4h case    8:*/		return 0x82192BC8;
		  /* 82192BC8h */ case    9:  		/* bl -12608 */
		/* 82192BC8h case    9:*/		regs.LR = 0x82192BCC; return 0x8218FA88;
		/* 82192BC8h case    9:*/		return 0x82192BCC;
		  /* 82192BCCh */ case   10:  		/* rlwinm R11, R27, 0, 0, 30 */
		/* 82192BCCh case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R27);
		/* 82192BCCh case   10:*/		return 0x82192BD0;
		  /* 82192BD0h */ case   11:  		/* lwz R11, <#[R11 + 40]> */
		/* 82192BD0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82192BD0h case   11:*/		return 0x82192BD4;
		  /* 82192BD4h */ case   12:  		/* b -1492 */
		/* 82192BD4h case   12:*/		return 0x82192600;
		/* 82192BD4h case   12:*/		return 0x82192BD8;
	}
	return 0x82192BD8;
} // Block from 82192BA4h-82192BD8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82192BD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192BD8);
		  /* 82192BD8h */ case    0:  		/* li R6, 0 */
		/* 82192BD8h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82192BD8h case    0:*/		return 0x82192BDC;
		  /* 82192BDCh */ case    1:  		/* mr R5, R31 */
		/* 82192BDCh case    1:*/		regs.R5 = regs.R31;
		/* 82192BDCh case    1:*/		return 0x82192BE0;
		  /* 82192BE0h */ case    2:  		/* mr R4, R27 */
		/* 82192BE0h case    2:*/		regs.R4 = regs.R27;
		/* 82192BE0h case    2:*/		return 0x82192BE4;
		  /* 82192BE4h */ case    3:  		/* mr R3, R22 */
		/* 82192BE4h case    3:*/		regs.R3 = regs.R22;
		/* 82192BE4h case    3:*/		return 0x82192BE8;
		  /* 82192BE8h */ case    4:  		/* bl 634968 */
		/* 82192BE8h case    4:*/		regs.LR = 0x82192BEC; return 0x8222DC40;
		/* 82192BE8h case    4:*/		return 0x82192BEC;
		  /* 82192BECh */ case    5:  		/* mr R5, R22 */
		/* 82192BECh case    5:*/		regs.R5 = regs.R22;
		/* 82192BECh case    5:*/		return 0x82192BF0;
		  /* 82192BF0h */ case    6:  		/* mr R4, R27 */
		/* 82192BF0h case    6:*/		regs.R4 = regs.R27;
		/* 82192BF0h case    6:*/		return 0x82192BF4;
		  /* 82192BF4h */ case    7:  		/* mr R3, R31 */
		/* 82192BF4h case    7:*/		regs.R3 = regs.R31;
		/* 82192BF4h case    7:*/		return 0x82192BF8;
		  /* 82192BF8h */ case    8:  		/* bl -108904 */
		/* 82192BF8h case    8:*/		regs.LR = 0x82192BFC; return 0x82178290;
		/* 82192BF8h case    8:*/		return 0x82192BFC;
		  /* 82192BFCh */ case    9:  		/* b 8 */
		/* 82192BFCh case    9:*/		return 0x82192C04;
		/* 82192BFCh case    9:*/		return 0x82192C00;
		  /* 82192C00h */ case   10:  		/* lwz R21, <#[R21 + 32]> */
		/* 82192C00h case   10:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R21 + 0x00000020) );
		/* 82192C00h case   10:*/		return 0x82192C04;
	}
	return 0x82192C04;
} // Block from 82192BD8h-82192C04h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82192C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192C04);
		  /* 82192C04h */ case    0:  		/* cmplwi CR6, R21, 0 */
		/* 82192C04h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 82192C04h case    0:*/		return 0x82192C08;
		  /* 82192C08h */ case    1:  		/* bc 4, CR6_EQ, -8 */
		/* 82192C08h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82192C00;  }
		/* 82192C08h case    1:*/		return 0x82192C0C;
		  /* 82192C0Ch */ case    2:  		/* b 8 */
		/* 82192C0Ch case    2:*/		return 0x82192C14;
		/* 82192C0Ch case    2:*/		return 0x82192C10;
		  /* 82192C10h */ case    3:  		/* lwz R20, <#[R20 + 32]> */
		/* 82192C10h case    3:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R20 + 0x00000020) );
		/* 82192C10h case    3:*/		return 0x82192C14;
	}
	return 0x82192C14;
} // Block from 82192C04h-82192C14h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82192C14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192C14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192C14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192C14);
		  /* 82192C14h */ case    0:  		/* cmplwi CR6, R20, 0 */
		/* 82192C14h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 82192C14h case    0:*/		return 0x82192C18;
		  /* 82192C18h */ case    1:  		/* bc 4, CR6_EQ, -8 */
		/* 82192C18h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82192C10;  }
		/* 82192C18h case    1:*/		return 0x82192C1C;
		  /* 82192C1Ch */ case    2:  		/* b -1584 */
		/* 82192C1Ch case    2:*/		return 0x821925EC;
		/* 82192C1Ch case    2:*/		return 0x82192C20;
	}
	return 0x82192C20;
} // Block from 82192C14h-82192C20h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82192C20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192C20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192C20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192C20);
		  /* 82192C20h */ case    0:  		/* li R4, 4800 */
		/* 82192C20h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82192C20h case    0:*/		return 0x82192C24;
		  /* 82192C24h */ case    1:  		/* mr R3, R22 */
		/* 82192C24h case    1:*/		regs.R3 = regs.R22;
		/* 82192C24h case    1:*/		return 0x82192C28;
		  /* 82192C28h */ case    2:  		/* bl -265664 */
		/* 82192C28h case    2:*/		regs.LR = 0x82192C2C; return 0x82151E68;
		/* 82192C28h case    2:*/		return 0x82192C2C;
	}
	return 0x82192C2C;
} // Block from 82192C20h-82192C2Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82192C2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192C2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192C2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192C2C);
		  /* 82192C2Ch */ case    0:  		/* lwz R31, <#[R23 + 36]> */
		/* 82192C2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R23 + 0x00000024) );
		/* 82192C2Ch case    0:*/		return 0x82192C30;
		  /* 82192C30h */ case    1:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 82192C30h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 82192C30h case    1:*/		return 0x82192C34;
		  /* 82192C34h */ case    2:  		/* bc 4, CR0_EQ, 44 */
		/* 82192C34h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82192C60;  }
		/* 82192C34h case    2:*/		return 0x82192C38;
		  /* 82192C38h */ case    3:  		/* cmplwi CR0, R31, 0 */
		/* 82192C38h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 82192C38h case    3:*/		return 0x82192C3C;
		  /* 82192C3Ch */ case    4:  		/* bc 12, CR0_EQ, 36 */
		/* 82192C3Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x82192C60;  }
		/* 82192C3Ch case    4:*/		return 0x82192C40;
		  /* 82192C40h */ case    5:  		/* mr R3, R31 */
		/* 82192C40h case    5:*/		regs.R3 = regs.R31;
		/* 82192C40h case    5:*/		return 0x82192C44;
		  /* 82192C44h */ case    6:  		/* bl -12732 */
		/* 82192C44h case    6:*/		regs.LR = 0x82192C48; return 0x8218FA88;
		/* 82192C44h case    6:*/		return 0x82192C48;
		  /* 82192C48h */ case    7:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82192C48h case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82192C48h case    7:*/		return 0x82192C4C;
		  /* 82192C4Ch */ case    8:  		/* lwz R31, <#[R11 + 40]> */
		/* 82192C4Ch case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000028) );
		/* 82192C4Ch case    8:*/		return 0x82192C50;
		  /* 82192C50h */ case    9:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 82192C50h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 82192C50h case    9:*/		return 0x82192C54;
		  /* 82192C54h */ case   10:  		/* bc 4, CR0_EQ, 12 */
		/* 82192C54h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82192C60;  }
		/* 82192C54h case   10:*/		return 0x82192C58;
		  /* 82192C58h */ case   11:  		/* cmplwi CR6, R31, 0 */
		/* 82192C58h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82192C58h case   11:*/		return 0x82192C5C;
		  /* 82192C5Ch */ case   12:  		/* bc 4, CR6_EQ, -28 */
		/* 82192C5Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x82192C40;  }
		/* 82192C5Ch case   12:*/		return 0x82192C60;
	}
	return 0x82192C60;
} // Block from 82192C2Ch-82192C60h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82192C60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192C60);
		  /* 82192C60h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 82192C60h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82192C60h case    0:*/		return 0x82192C64;
		  /* 82192C64h */ case    1:  		/* bc 12, CR6_EQ, 588 */
		/* 82192C64h case    1:*/		if ( regs.CR[6].eq ) { return 0x82192EB0;  }
		/* 82192C64h case    1:*/		return 0x82192C68;
		  /* 82192C68h */ case    2:  		/* cmplwi CR6, R26, 0 */
		/* 82192C68h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82192C68h case    2:*/		return 0x82192C6C;
		  /* 82192C6Ch */ case    3:  		/* bc 12, CR6_EQ, 580 */
		/* 82192C6Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82192EB0;  }
		/* 82192C6Ch case    3:*/		return 0x82192C70;
		  /* 82192C70h */ case    4:  		/* lwz R11, <#[R19 + 4]> */
		/* 82192C70h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 82192C70h case    4:*/		return 0x82192C74;
		  /* 82192C74h */ case    5:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82192C74h case    5:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82192C74h case    5:*/		return 0x82192C78;
		  /* 82192C78h */ case    6:  		/* addic R10, R10, -1 */
		/* 82192C78h case    6:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82192C78h case    6:*/		return 0x82192C7C;
		  /* 82192C7Ch */ case    7:  		/* subfe R10, R10, R10 */
		/* 82192C7Ch case    7:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82192C7Ch case    7:*/		return 0x82192C80;
		  /* 82192C80h */ case    8:  		/* and R26, R10, R11 */
		/* 82192C80h case    8:*/		cpu::op::and<0>(regs,&regs.R26,regs.R10,regs.R11);
		/* 82192C80h case    8:*/		return 0x82192C84;
		  /* 82192C84h */ case    9:  		/* cmplwi CR6, R26, 0 */
		/* 82192C84h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82192C84h case    9:*/		return 0x82192C88;
		  /* 82192C88h */ case   10:  		/* bc 12, CR6_EQ, 552 */
		/* 82192C88h case   10:*/		if ( regs.CR[6].eq ) { return 0x82192EB0;  }
		/* 82192C88h case   10:*/		return 0x82192C8C;
		  /* 82192C8Ch */ case   11:  		/* lwz R11, <#[R26 + 8]> */
		/* 82192C8Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82192C8Ch case   11:*/		return 0x82192C90;
		  /* 82192C90h */ case   12:  		/* rlwinm. R10, R11, 0, 25, 25 */
		/* 82192C90h case   12:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R11);
		/* 82192C90h case   12:*/		return 0x82192C94;
		  /* 82192C94h */ case   13:  		/* bc 4, CR0_EQ, 12 */
		/* 82192C94h case   13:*/		if ( !regs.CR[0].eq ) { return 0x82192CA0;  }
		/* 82192C94h case   13:*/		return 0x82192C98;
		  /* 82192C98h */ case   14:  		/* li R11, 0 */
		/* 82192C98h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192C98h case   14:*/		return 0x82192C9C;
		  /* 82192C9Ch */ case   15:  		/* b 44 */
		/* 82192C9Ch case   15:*/		return 0x82192CC8;
		/* 82192C9Ch case   15:*/		return 0x82192CA0;
	}
	return 0x82192CA0;
} // Block from 82192C60h-82192CA0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82192CA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192CA0);
		  /* 82192CA0h */ case    0:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82192CA0h case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82192CA0h case    0:*/		return 0x82192CA4;
		  /* 82192CA4h */ case    1:  		/* cmplwi CR6, R11, 30 */
		/* 82192CA4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001E);
		/* 82192CA4h case    1:*/		return 0x82192CA8;
		  /* 82192CA8h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 82192CA8h case    2:*/		if ( regs.CR[6].eq ) { return 0x82192CC0;  }
		/* 82192CA8h case    2:*/		return 0x82192CAC;
		  /* 82192CACh */ case    3:  		/* cmplwi CR6, R11, 55 */
		/* 82192CACh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000037);
		/* 82192CACh case    3:*/		return 0x82192CB0;
		  /* 82192CB0h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 82192CB0h case    4:*/		if ( regs.CR[6].eq ) { return 0x82192CC0;  }
		/* 82192CB0h case    4:*/		return 0x82192CB4;
		  /* 82192CB4h */ case    5:  		/* cmplwi CR6, R11, 56 */
		/* 82192CB4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000038);
		/* 82192CB4h case    5:*/		return 0x82192CB8;
		  /* 82192CB8h */ case    6:  		/* li R11, 0 */
		/* 82192CB8h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192CB8h case    6:*/		return 0x82192CBC;
		  /* 82192CBCh */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 82192CBCh case    7:*/		if ( !regs.CR[6].eq ) { return 0x82192CC4;  }
		/* 82192CBCh case    7:*/		return 0x82192CC0;
	}
	return 0x82192CC0;
} // Block from 82192CA0h-82192CC0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82192CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192CC0);
		  /* 82192CC0h */ case    0:  		/* li R11, 1 */
		/* 82192CC0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192CC0h case    0:*/		return 0x82192CC4;
	}
	return 0x82192CC4;
} // Block from 82192CC0h-82192CC4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192CC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192CC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192CC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192CC4);
		  /* 82192CC4h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 82192CC4h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192CC4h case    0:*/		return 0x82192CC8;
	}
	return 0x82192CC8;
} // Block from 82192CC4h-82192CC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192CC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192CC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192CC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192CC8);
		  /* 82192CC8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192CC8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192CC8h case    0:*/		return 0x82192CCC;
		  /* 82192CCCh */ case    1:  		/* bc 12, CR0_EQ, 432 */
		/* 82192CCCh case    1:*/		if ( regs.CR[0].eq ) { return 0x82192E7C;  }
		/* 82192CCCh case    1:*/		return 0x82192CD0;
		  /* 82192CD0h */ case    2:  		/* lwz R11, <#[R19 + 4]> */
		/* 82192CD0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 82192CD0h case    2:*/		return 0x82192CD4;
		  /* 82192CD4h */ case    3:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82192CD4h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82192CD4h case    3:*/		return 0x82192CD8;
		  /* 82192CD8h */ case    4:  		/* bc 4, CR0_EQ, 420 */
		/* 82192CD8h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82192E7C;  }
		/* 82192CD8h case    4:*/		return 0x82192CDC;
		  /* 82192CDCh */ case    5:  		/* mr R29, R11 */
		/* 82192CDCh case    5:*/		regs.R29 = regs.R11;
		/* 82192CDCh case    5:*/		return 0x82192CE0;
		  /* 82192CE0h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 82192CE0h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82192CE0h case    6:*/		return 0x82192CE4;
		  /* 82192CE4h */ case    7:  		/* bc 12, CR0_EQ, 408 */
		/* 82192CE4h case    7:*/		if ( regs.CR[0].eq ) { return 0x82192E7C;  }
		/* 82192CE4h case    7:*/		return 0x82192CE8;
		  /* 82192CE8h */ case    8:  		/* mr R3, R29 */
		/* 82192CE8h case    8:*/		regs.R3 = regs.R29;
		/* 82192CE8h case    8:*/		return 0x82192CEC;
		  /* 82192CECh */ case    9:  		/* bl -147444 */
		/* 82192CECh case    9:*/		regs.LR = 0x82192CF0; return 0x8216ECF8;
		/* 82192CECh case    9:*/		return 0x82192CF0;
		  /* 82192CF0h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 82192CF0h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82192CF0h case   10:*/		return 0x82192CF4;
		  /* 82192CF4h */ case   11:  		/* bc 12, CR0_EQ, 12 */
		/* 82192CF4h case   11:*/		if ( regs.CR[0].eq ) { return 0x82192D00;  }
		/* 82192CF4h case   11:*/		return 0x82192CF8;
		  /* 82192CF8h */ case   12:  		/* cmpwi CR6, R3, 1 */
		/* 82192CF8h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82192CF8h case   12:*/		return 0x82192CFC;
		  /* 82192CFCh */ case   13:  		/* bc 4, CR6_EQ, 68 */
		/* 82192CFCh case   13:*/		if ( !regs.CR[6].eq ) { return 0x82192D40;  }
		/* 82192CFCh case   13:*/		return 0x82192D00;
	}
	return 0x82192D00;
} // Block from 82192CC8h-82192D00h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82192D00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192D00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192D00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192D00);
		  /* 82192D00h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 82192D00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82192D00h case    0:*/		return 0x82192D04;
		  /* 82192D04h */ case    1:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 82192D04h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 82192D04h case    1:*/		return 0x82192D08;
		  /* 82192D08h */ case    2:  		/* cmplwi CR6, R10, 91 */
		/* 82192D08h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005B);
		/* 82192D08h case    2:*/		return 0x82192D0C;
		  /* 82192D0Ch */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 82192D0Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82192D1C;  }
		/* 82192D0Ch case    3:*/		return 0x82192D10;
		  /* 82192D10h */ case    4:  		/* cmplwi CR6, R10, 94 */
		/* 82192D10h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005E);
		/* 82192D10h case    4:*/		return 0x82192D14;
		  /* 82192D14h */ case    5:  		/* li R11, 1 */
		/* 82192D14h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192D14h case    5:*/		return 0x82192D18;
		  /* 82192D18h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 82192D18h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82192D20;  }
		/* 82192D18h case    6:*/		return 0x82192D1C;
	}
	return 0x82192D1C;
} // Block from 82192D00h-82192D1Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82192D1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192D1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192D1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192D1C);
		  /* 82192D1Ch */ case    0:  		/* li R11, 0 */
		/* 82192D1Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192D1Ch case    0:*/		return 0x82192D20;
	}
	return 0x82192D20;
} // Block from 82192D1Ch-82192D20h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192D20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192D20);
		  /* 82192D20h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192D20h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192D20h case    0:*/		return 0x82192D24;
		  /* 82192D24h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 82192D24h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82192D34;  }
		/* 82192D24h case    1:*/		return 0x82192D28;
		  /* 82192D28h */ case    2:  		/* cmplwi CR6, R10, 123 */
		/* 82192D28h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007B);
		/* 82192D28h case    2:*/		return 0x82192D2C;
		  /* 82192D2Ch */ case    3:  		/* li R11, 0 */
		/* 82192D2Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192D2Ch case    3:*/		return 0x82192D30;
		  /* 82192D30h */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 82192D30h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82192D38;  }
		/* 82192D30h case    4:*/		return 0x82192D34;
	}
	return 0x82192D34;
} // Block from 82192D20h-82192D34h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82192D34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192D34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192D34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192D34);
		  /* 82192D34h */ case    0:  		/* li R11, 1 */
		/* 82192D34h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192D34h case    0:*/		return 0x82192D38;
	}
	return 0x82192D38;
} // Block from 82192D34h-82192D38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192D38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192D38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192D38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192D38);
		  /* 82192D38h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192D38h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192D38h case    0:*/		return 0x82192D3C;
		  /* 82192D3Ch */ case    1:  		/* bc 12, CR0_EQ, 292 */
		/* 82192D3Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82192E60;  }
		/* 82192D3Ch case    1:*/		return 0x82192D40;
	}
	return 0x82192D40;
} // Block from 82192D38h-82192D40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82192D40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192D40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192D40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192D40);
		  /* 82192D40h */ case    0:  		/* lwz R27, <#[R26 + 4]> */
		/* 82192D40h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R26 + 0x00000004) );
		/* 82192D40h case    0:*/		return 0x82192D44;
		  /* 82192D44h */ case    1:  		/* cmplwi CR6, R27, 0 */
		/* 82192D44h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82192D44h case    1:*/		return 0x82192D48;
		  /* 82192D48h */ case    2:  		/* bc 12, CR6_EQ, 280 */
		/* 82192D48h case    2:*/		if ( regs.CR[6].eq ) { return 0x82192E60;  }
		/* 82192D48h case    2:*/		return 0x82192D4C;
		  /* 82192D4Ch */ case    3:  		/* lwz R28, <#[R27 + 16]> */
		/* 82192D4Ch case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R27 + 0x00000010) );
		/* 82192D4Ch case    3:*/		return 0x82192D50;
		  /* 82192D50h */ case    4:  		/* cmplwi CR6, R28, 0 */
		/* 82192D50h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82192D50h case    4:*/		return 0x82192D54;
		  /* 82192D54h */ case    5:  		/* bc 12, CR6_EQ, 260 */
		/* 82192D54h case    5:*/		if ( regs.CR[6].eq ) { return 0x82192E58;  }
		/* 82192D54h case    5:*/		return 0x82192D58;
		  /* 82192D58h */ case    6:  		/* lwz R11, <#[R27]> */
		/* 82192D58h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82192D58h case    6:*/		return 0x82192D5C;
		  /* 82192D5Ch */ case    7:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 82192D5Ch case    7:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 82192D5Ch case    7:*/		return 0x82192D60;
		  /* 82192D60h */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 82192D60h case    8:*/		if ( regs.CR[0].eq ) { return 0x82192D70;  }
		/* 82192D60h case    8:*/		return 0x82192D64;
		  /* 82192D64h */ case    9:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82192D64h case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82192D64h case    9:*/		return 0x82192D68;
		  /* 82192D68h */ case   10:  		/* li R11, 1 */
		/* 82192D68h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192D68h case   10:*/		return 0x82192D6C;
		  /* 82192D6Ch */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 82192D6Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x82192D74;  }
		/* 82192D6Ch case   11:*/		return 0x82192D70;
	}
	return 0x82192D70;
} // Block from 82192D40h-82192D70h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82192D70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192D70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192D70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192D70);
		  /* 82192D70h */ case    0:  		/* li R11, 0 */
		/* 82192D70h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192D70h case    0:*/		return 0x82192D74;
	}
	return 0x82192D74;
} // Block from 82192D70h-82192D74h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192D74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192D74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192D74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192D74);
		  /* 82192D74h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192D74h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192D74h case    0:*/		return 0x82192D78;
		  /* 82192D78h */ case    1:  		/* bc 12, CR0_EQ, 224 */
		/* 82192D78h case    1:*/		if ( regs.CR[0].eq ) { return 0x82192E58;  }
		/* 82192D78h case    1:*/		return 0x82192D7C;
		  /* 82192D7Ch */ case    2:  		/* mr R7, R22 */
		/* 82192D7Ch case    2:*/		regs.R7 = regs.R22;
		/* 82192D7Ch case    2:*/		return 0x82192D80;
		  /* 82192D80h */ case    3:  		/* li R6, 1 */
		/* 82192D80h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82192D80h case    3:*/		return 0x82192D84;
		  /* 82192D84h */ case    4:  		/* li R5, 0 */
		/* 82192D84h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82192D84h case    4:*/		return 0x82192D88;
		  /* 82192D88h */ case    5:  		/* mr R4, R28 */
		/* 82192D88h case    5:*/		regs.R4 = regs.R28;
		/* 82192D88h case    5:*/		return 0x82192D8C;
		  /* 82192D8Ch */ case    6:  		/* mr R3, R29 */
		/* 82192D8Ch case    6:*/		regs.R3 = regs.R29;
		/* 82192D8Ch case    6:*/		return 0x82192D90;
		  /* 82192D90h */ case    7:  		/* bl 625832 */
		/* 82192D90h case    7:*/		regs.LR = 0x82192D94; return 0x8222BA38;
		/* 82192D90h case    7:*/		return 0x82192D94;
		  /* 82192D94h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82192D94h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82192D94h case    8:*/		return 0x82192D98;
		  /* 82192D98h */ case    9:  		/* bc 12, CR0_EQ, 192 */
		/* 82192D98h case    9:*/		if ( regs.CR[0].eq ) { return 0x82192E58;  }
		/* 82192D98h case    9:*/		return 0x82192D9C;
		  /* 82192D9Ch */ case   10:  		/* lwz R30, <#[R26 + 4]> */
		/* 82192D9Ch case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x00000004) );
		/* 82192D9Ch case   10:*/		return 0x82192DA0;
		  /* 82192DA0h */ case   11:  		/* cmplwi CR6, R30, 0 */
		/* 82192DA0h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82192DA0h case   11:*/		return 0x82192DA4;
		  /* 82192DA4h */ case   12:  		/* bc 12, CR6_EQ, 180 */
		/* 82192DA4h case   12:*/		if ( regs.CR[6].eq ) { return 0x82192E58;  }
		/* 82192DA4h case   12:*/		return 0x82192DA8;
		  /* 82192DA8h */ case   13:  		/* lwz R31, <#[R30 + 16]> */
		/* 82192DA8h case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000010) );
		/* 82192DA8h case   13:*/		return 0x82192DAC;
		  /* 82192DACh */ case   14:  		/* cmplwi CR6, R31, 0 */
		/* 82192DACh case   14:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82192DACh case   14:*/		return 0x82192DB0;
		  /* 82192DB0h */ case   15:  		/* bc 12, CR6_EQ, 160 */
		/* 82192DB0h case   15:*/		if ( regs.CR[6].eq ) { return 0x82192E50;  }
		/* 82192DB0h case   15:*/		return 0x82192DB4;
		  /* 82192DB4h */ case   16:  		/* lwz R11, <#[R30]> */
		/* 82192DB4h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82192DB4h case   16:*/		return 0x82192DB8;
		  /* 82192DB8h */ case   17:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 82192DB8h case   17:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 82192DB8h case   17:*/		return 0x82192DBC;
		  /* 82192DBCh */ case   18:  		/* bc 12, CR0_EQ, 16 */
		/* 82192DBCh case   18:*/		if ( regs.CR[0].eq ) { return 0x82192DCC;  }
		/* 82192DBCh case   18:*/		return 0x82192DC0;
		  /* 82192DC0h */ case   19:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82192DC0h case   19:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82192DC0h case   19:*/		return 0x82192DC4;
		  /* 82192DC4h */ case   20:  		/* li R11, 1 */
		/* 82192DC4h case   20:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192DC4h case   20:*/		return 0x82192DC8;
		  /* 82192DC8h */ case   21:  		/* bc 12, CR0_EQ, 8 */
		/* 82192DC8h case   21:*/		if ( regs.CR[0].eq ) { return 0x82192DD0;  }
		/* 82192DC8h case   21:*/		return 0x82192DCC;
	}
	return 0x82192DCC;
} // Block from 82192D74h-82192DCCh (22 instructions)

//////////////////////////////////////////////////////
// Block at 82192DCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192DCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192DCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192DCC);
		  /* 82192DCCh */ case    0:  		/* li R11, 0 */
		/* 82192DCCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192DCCh case    0:*/		return 0x82192DD0;
	}
	return 0x82192DD0;
} // Block from 82192DCCh-82192DD0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192DD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192DD0);
		  /* 82192DD0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192DD0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192DD0h case    0:*/		return 0x82192DD4;
		  /* 82192DD4h */ case    1:  		/* bc 12, CR0_EQ, 124 */
		/* 82192DD4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82192E50;  }
		/* 82192DD4h case    1:*/		return 0x82192DD8;
		  /* 82192DD8h */ case    2:  		/* mr R7, R22 */
		/* 82192DD8h case    2:*/		regs.R7 = regs.R22;
		/* 82192DD8h case    2:*/		return 0x82192DDC;
		  /* 82192DDCh */ case    3:  		/* li R6, 1 */
		/* 82192DDCh case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82192DDCh case    3:*/		return 0x82192DE0;
		  /* 82192DE0h */ case    4:  		/* li R5, 0 */
		/* 82192DE0h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82192DE0h case    4:*/		return 0x82192DE4;
		  /* 82192DE4h */ case    5:  		/* mr R4, R31 */
		/* 82192DE4h case    5:*/		regs.R4 = regs.R31;
		/* 82192DE4h case    5:*/		return 0x82192DE8;
		  /* 82192DE8h */ case    6:  		/* mr R3, R29 */
		/* 82192DE8h case    6:*/		regs.R3 = regs.R29;
		/* 82192DE8h case    6:*/		return 0x82192DEC;
		  /* 82192DECh */ case    7:  		/* bl 625740 */
		/* 82192DECh case    7:*/		regs.LR = 0x82192DF0; return 0x8222BA38;
		/* 82192DECh case    7:*/		return 0x82192DF0;
		  /* 82192DF0h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82192DF0h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82192DF0h case    8:*/		return 0x82192DF4;
		  /* 82192DF4h */ case    9:  		/* bc 4, CR0_EQ, 92 */
		/* 82192DF4h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82192E50;  }
		/* 82192DF4h case    9:*/		return 0x82192DF8;
		  /* 82192DF8h */ case   10:  		/* mr R7, R22 */
		/* 82192DF8h case   10:*/		regs.R7 = regs.R22;
		/* 82192DF8h case   10:*/		return 0x82192DFC;
		  /* 82192DFCh */ case   11:  		/* li R6, 1 */
		/* 82192DFCh case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82192DFCh case   11:*/		return 0x82192E00;
		  /* 82192E00h */ case   12:  		/* li R5, 0 */
		/* 82192E00h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82192E00h case   12:*/		return 0x82192E04;
		  /* 82192E04h */ case   13:  		/* mr R4, R29 */
		/* 82192E04h case   13:*/		regs.R4 = regs.R29;
		/* 82192E04h case   13:*/		return 0x82192E08;
		  /* 82192E08h */ case   14:  		/* mr R3, R31 */
		/* 82192E08h case   14:*/		regs.R3 = regs.R31;
		/* 82192E08h case   14:*/		return 0x82192E0C;
		  /* 82192E0Ch */ case   15:  		/* bl 625708 */
		/* 82192E0Ch case   15:*/		regs.LR = 0x82192E10; return 0x8222BA38;
		/* 82192E0Ch case   15:*/		return 0x82192E10;
		  /* 82192E10h */ case   16:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82192E10h case   16:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82192E10h case   16:*/		return 0x82192E14;
		  /* 82192E14h */ case   17:  		/* bc 4, CR0_EQ, 60 */
		/* 82192E14h case   17:*/		if ( !regs.CR[0].eq ) { return 0x82192E50;  }
		/* 82192E14h case   17:*/		return 0x82192E18;
		  /* 82192E18h */ case   18:  		/* lwz R11, <#[R28 + 20]> */
		/* 82192E18h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 82192E18h case   18:*/		return 0x82192E1C;
		  /* 82192E1Ch */ case   19:  		/* lwz R10, <#[R31 + 20]> */
		/* 82192E1Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 82192E1Ch case   19:*/		return 0x82192E20;
		  /* 82192E20h */ case   20:  		/* rlwinm R11, R11, 19, 19, 31 */
		/* 82192E20h case   20:*/		cpu::op::rlwinm<0,19,19,31>(regs,&regs.R11,regs.R11);
		/* 82192E20h case   20:*/		return 0x82192E24;
		  /* 82192E24h */ case   21:  		/* rlwinm R10, R10, 19, 19, 31 */
		/* 82192E24h case   21:*/		cpu::op::rlwinm<0,19,19,31>(regs,&regs.R10,regs.R10);
		/* 82192E24h case   21:*/		return 0x82192E28;
		  /* 82192E28h */ case   22:  		/* addi R11, R11, 1 */
		/* 82192E28h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82192E28h case   22:*/		return 0x82192E2C;
		  /* 82192E2Ch */ case   23:  		/* cmplw CR6, R10, R11 */
		/* 82192E2Ch case   23:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82192E2Ch case   23:*/		return 0x82192E30;
		  /* 82192E30h */ case   24:  		/* bc 12, CR6_GT, 32 */
		/* 82192E30h case   24:*/		if ( regs.CR[6].gt ) { return 0x82192E50;  }
		/* 82192E30h case   24:*/		return 0x82192E34;
		  /* 82192E34h */ case   25:  		/* li R6, 0 */
		/* 82192E34h case   25:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82192E34h case   25:*/		return 0x82192E38;
		  /* 82192E38h */ case   26:  		/* mr R5, R29 */
		/* 82192E38h case   26:*/		regs.R5 = regs.R29;
		/* 82192E38h case   26:*/		return 0x82192E3C;
		  /* 82192E3Ch */ case   27:  		/* mr R4, R31 */
		/* 82192E3Ch case   27:*/		regs.R4 = regs.R31;
		/* 82192E3Ch case   27:*/		return 0x82192E40;
		  /* 82192E40h */ case   28:  		/* mr R3, R22 */
		/* 82192E40h case   28:*/		regs.R3 = regs.R22;
		/* 82192E40h case   28:*/		return 0x82192E44;
		  /* 82192E44h */ case   29:  		/* bl 628260 */
		/* 82192E44h case   29:*/		regs.LR = 0x82192E48; return 0x8222C468;
		/* 82192E44h case   29:*/		return 0x82192E48;
		  /* 82192E48h */ case   30:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82192E48h case   30:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82192E48h case   30:*/		return 0x82192E4C;
		  /* 82192E4Ch */ case   31:  		/* bc 4, CR0_EQ, 60 */
		/* 82192E4Ch case   31:*/		if ( !regs.CR[0].eq ) { return 0x82192E88;  }
		/* 82192E4Ch case   31:*/		return 0x82192E50;
	}
	return 0x82192E50;
} // Block from 82192DD0h-82192E50h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82192E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192E50);
		  /* 82192E50h */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 82192E50h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 82192E50h case    0:*/		return 0x82192E54;
		  /* 82192E54h */ case    1:  		/* b -180 */
		/* 82192E54h case    1:*/		return 0x82192DA0;
		/* 82192E54h case    1:*/		return 0x82192E58;
	}
	return 0x82192E58;
} // Block from 82192E50h-82192E58h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82192E58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192E58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192E58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192E58);
		  /* 82192E58h */ case    0:  		/* lwz R27, <#[R27 + 8]> */
		/* 82192E58h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R27 + 0x00000008) );
		/* 82192E58h case    0:*/		return 0x82192E5C;
		  /* 82192E5Ch */ case    1:  		/* b -280 */
		/* 82192E5Ch case    1:*/		return 0x82192D44;
		/* 82192E5Ch case    1:*/		return 0x82192E60;
	}
	return 0x82192E60;
} // Block from 82192E58h-82192E60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82192E60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192E60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192E60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192E60);
		  /* 82192E60h */ case    0:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 82192E60h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 82192E60h case    0:*/		return 0x82192E64;
		  /* 82192E64h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 82192E64h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82192E64h case    1:*/		return 0x82192E68;
		  /* 82192E68h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82192E68h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82192E68h case    2:*/		return 0x82192E6C;
		  /* 82192E6Ch */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82192E6Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x82192E7C;  }
		/* 82192E6Ch case    3:*/		return 0x82192E70;
		  /* 82192E70h */ case    4:  		/* mr R29, R11 */
		/* 82192E70h case    4:*/		regs.R29 = regs.R11;
		/* 82192E70h case    4:*/		return 0x82192E74;
		  /* 82192E74h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82192E74h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82192E74h case    5:*/		return 0x82192E78;
		  /* 82192E78h */ case    6:  		/* bc 4, CR6_EQ, -400 */
		/* 82192E78h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82192CE8;  }
		/* 82192E78h case    6:*/		return 0x82192E7C;
	}
	return 0x82192E7C;
} // Block from 82192E60h-82192E7Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82192E7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192E7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192E7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192E7C);
		  /* 82192E7Ch */ case    0:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 82192E7Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 82192E7Ch case    0:*/		return 0x82192E80;
		  /* 82192E80h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 82192E80h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82192E80h case    1:*/		return 0x82192E84;
		  /* 82192E84h */ case    2:  		/* b -528 */
		/* 82192E84h case    2:*/		return 0x82192C74;
		/* 82192E84h case    2:*/		return 0x82192E88;
	}
	return 0x82192E88;
} // Block from 82192E7Ch-82192E88h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82192E88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192E88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192E88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192E88);
		  /* 82192E88h */ case    0:  		/* li R6, 0 */
		/* 82192E88h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82192E88h case    0:*/		return 0x82192E8C;
		  /* 82192E8Ch */ case    1:  		/* mr R5, R29 */
		/* 82192E8Ch case    1:*/		regs.R5 = regs.R29;
		/* 82192E8Ch case    1:*/		return 0x82192E90;
		  /* 82192E90h */ case    2:  		/* mr R4, R31 */
		/* 82192E90h case    2:*/		regs.R4 = regs.R31;
		/* 82192E90h case    2:*/		return 0x82192E94;
		  /* 82192E94h */ case    3:  		/* mr R3, R22 */
		/* 82192E94h case    3:*/		regs.R3 = regs.R22;
		/* 82192E94h case    3:*/		return 0x82192E98;
		  /* 82192E98h */ case    4:  		/* bl 634280 */
		/* 82192E98h case    4:*/		regs.LR = 0x82192E9C; return 0x8222DC40;
		/* 82192E98h case    4:*/		return 0x82192E9C;
		  /* 82192E9Ch */ case    5:  		/* mr R5, R22 */
		/* 82192E9Ch case    5:*/		regs.R5 = regs.R22;
		/* 82192E9Ch case    5:*/		return 0x82192EA0;
		  /* 82192EA0h */ case    6:  		/* mr R4, R31 */
		/* 82192EA0h case    6:*/		regs.R4 = regs.R31;
		/* 82192EA0h case    6:*/		return 0x82192EA4;
		  /* 82192EA4h */ case    7:  		/* mr R3, R29 */
		/* 82192EA4h case    7:*/		regs.R3 = regs.R29;
		/* 82192EA4h case    7:*/		return 0x82192EA8;
		  /* 82192EA8h */ case    8:  		/* bl -109592 */
		/* 82192EA8h case    8:*/		regs.LR = 0x82192EAC; return 0x82178290;
		/* 82192EA8h case    8:*/		return 0x82192EAC;
		  /* 82192EACh */ case    9:  		/* b -572 */
		/* 82192EACh case    9:*/		return 0x82192C70;
		/* 82192EACh case    9:*/		return 0x82192EB0;
	}
	return 0x82192EB0;
} // Block from 82192E88h-82192EB0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82192EB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192EB0);
		  /* 82192EB0h */ case    0:  		/* stw R20, <#[R18]> */
		/* 82192EB0h case    0:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R18 + 0x00000000) );
		/* 82192EB0h case    0:*/		return 0x82192EB4;
		  /* 82192EB4h */ case    1:  		/* mr R3, R21 */
		/* 82192EB4h case    1:*/		regs.R3 = regs.R21;
		/* 82192EB4h case    1:*/		return 0x82192EB8;
		  /* 82192EB8h */ case    2:  		/* addi R1, R1, 208 */
		/* 82192EB8h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 82192EB8h case    2:*/		return 0x82192EBC;
		  /* 82192EBCh */ case    3:  		/* b -1055804 */
		/* 82192EBCh case    3:*/		return 0x82091280;
		/* 82192EBCh case    3:*/		return 0x82192EC0;
	}
	return 0x82192EC0;
} // Block from 82192EB0h-82192EC0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82192EC0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192EC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192EC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192EC0);
		  /* 82192EC0h */ case    0:  		/* lwz R11, <#[R4 + 16]> */
		/* 82192EC0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 82192EC0h case    0:*/		return 0x82192EC4;
		  /* 82192EC4h */ case    1:  		/* lwz R9, <#[R4 + 20]> */
		/* 82192EC4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000014) );
		/* 82192EC4h case    1:*/		return 0x82192EC8;
		  /* 82192EC8h */ case    2:  		/* lwz R10, <#[R4 + 8]> */
		/* 82192EC8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 82192EC8h case    2:*/		return 0x82192ECC;
		  /* 82192ECCh */ case    3:  		/* oris R8, R11, 256 */
		/* 82192ECCh case    3:*/		cpu::op::oris<0>(regs,&regs.R8,regs.R11,0x100);
		/* 82192ECCh case    3:*/		return 0x82192ED0;
		  /* 82192ED0h */ case    4:  		/* rlwimi R5, R9, 0, 0, 18 */
		/* 82192ED0h case    4:*/		cpu::op::rlwimi<0,0,0,18>(regs,&regs.R5,regs.R9);
		/* 82192ED0h case    4:*/		return 0x82192ED4;
		  /* 82192ED4h */ case    5:  		/* rlwinm R11, R10, 25, 25, 31 */
		/* 82192ED4h case    5:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R10);
		/* 82192ED4h case    5:*/		return 0x82192ED8;
		  /* 82192ED8h */ case    6:  		/* stw R8, <#[R4 + 16]> */
		/* 82192ED8h case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R4 + 0x00000010) );
		/* 82192ED8h case    6:*/		return 0x82192EDC;
		  /* 82192EDCh */ case    7:  		/* stw R5, <#[R4 + 20]> */
		/* 82192EDCh case    7:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R4 + 0x00000014) );
		/* 82192EDCh case    7:*/		return 0x82192EE0;
		  /* 82192EE0h */ case    8:  		/* cmplwi CR6, R11, 110 */
		/* 82192EE0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000006E);
		/* 82192EE0h case    8:*/		return 0x82192EE4;
		  /* 82192EE4h */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 82192EE4h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82192EEC;  }
		/* 82192EE4h case    9:*/		return 0x82192EE8;
		  /* 82192EE8h */ case   10:  		/* b -8944 */
		/* 82192EE8h case   10:*/		return 0x82190BF8;
		/* 82192EE8h case   10:*/		return 0x82192EEC;
	}
	return 0x82192EEC;
} // Block from 82192EC0h-82192EECh (11 instructions)

//////////////////////////////////////////////////////
// Block at 82192EECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192EEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192EEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192EEC);
		  /* 82192EECh */ case    0:  		/* cmplwi CR6, R11, 32 */
		/* 82192EECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 82192EECh case    0:*/		return 0x82192EF0;
		  /* 82192EF0h */ case    1:  		/* bc 12, CR6_LT, 16 */
		/* 82192EF0h case    1:*/		if ( regs.CR[6].lt ) { return 0x82192F00;  }
		/* 82192EF0h case    1:*/		return 0x82192EF4;
		  /* 82192EF4h */ case    2:  		/* cmplwi CR6, R11, 82 */
		/* 82192EF4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 82192EF4h case    2:*/		return 0x82192EF8;
		  /* 82192EF8h */ case    3:  		/* li R11, 1 */
		/* 82192EF8h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192EF8h case    3:*/		return 0x82192EFC;
		  /* 82192EFCh */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 82192EFCh case    4:*/		if ( !regs.CR[6].gt ) { return 0x82192F04;  }
		/* 82192EFCh case    4:*/		return 0x82192F00;
	}
	return 0x82192F00;
} // Block from 82192EECh-82192F00h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82192F00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192F00);
		  /* 82192F00h */ case    0:  		/* li R11, 0 */
		/* 82192F00h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192F00h case    0:*/		return 0x82192F04;
	}
	return 0x82192F04;
} // Block from 82192F00h-82192F04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192F04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192F04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192F04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192F04);
		  /* 82192F04h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192F04h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192F04h case    0:*/		return 0x82192F08;
		  /* 82192F08h */ case    1:  		/* bclr 12, CR0_EQ */
		/* 82192F08h case    1:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82192F08h case    1:*/		return 0x82192F0C;
	}
	return 0x82192F0C;
} // Block from 82192F04h-82192F0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82192F0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192F0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192F0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192F0C);
		  /* 82192F0Ch */ case    0:  		/* rlwinm R11, R10, 0, 10, 12 */
		/* 82192F0Ch case    0:*/		cpu::op::rlwinm<0,0,10,12>(regs,&regs.R11,regs.R10);
		/* 82192F0Ch case    0:*/		return 0x82192F10;
		  /* 82192F10h */ case    1:  		/* lis R10, 8 */
		/* 82192F10h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x8);
		/* 82192F10h case    1:*/		return 0x82192F14;
		  /* 82192F14h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 82192F14h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82192F14h case    2:*/		return 0x82192F18;
		  /* 82192F18h */ case    3:  		/* bclr 4, CR6_GT */
		/* 82192F18h case    3:*/		if ( !regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 82192F18h case    3:*/		return 0x82192F1C;
	}
	return 0x82192F1C;
} // Block from 82192F0Ch-82192F1Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82192F1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192F1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192F1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192F1C);
		  /* 82192F1Ch */ case    0:  		/* lwz R11, <#[R4 + 48]> */
		/* 82192F1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000030) );
		/* 82192F1Ch case    0:*/		return 0x82192F20;
		  /* 82192F20h */ case    1:  		/* lwz R4, <#[R11 + 12]> */
		/* 82192F20h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000000C) );
		/* 82192F20h case    1:*/		return 0x82192F24;
		  /* 82192F24h */ case    2:  		/* lwz R11, <#[R4 + 8]> */
		/* 82192F24h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 82192F24h case    2:*/		return 0x82192F28;
		  /* 82192F28h */ case    3:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 82192F28h case    3:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 82192F28h case    3:*/		return 0x82192F2C;
		  /* 82192F2Ch */ case    4:  		/* bclr 4, CR0_EQ */
		/* 82192F2Ch case    4:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82192F2Ch case    4:*/		return 0x82192F30;
	}
	return 0x82192F30;
} // Block from 82192F1Ch-82192F30h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82192F30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192F30);
		  /* 82192F30h */ case    0:  		/* b 146200 */
		/* 82192F30h case    0:*/		return 0x821B6A48;
		/* 82192F30h case    0:*/		return 0x82192F34;
		  /* 82192F34h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82192F34h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82192F34h case    1:*/		return 0x82192F38;
	}
	return 0x82192F38;
} // Block from 82192F30h-82192F38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82192F38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192F38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192F38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192F38);
		  /* 82192F38h */ case    0:  		/* mfspr R12, LR */
		/* 82192F38h case    0:*/		regs.R12 = regs.LR;
		/* 82192F38h case    0:*/		return 0x82192F3C;
		  /* 82192F3Ch */ case    1:  		/* bl -1056008 */
		/* 82192F3Ch case    1:*/		regs.LR = 0x82192F40; return 0x82091234;
		/* 82192F3Ch case    1:*/		return 0x82192F40;
		  /* 82192F40h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82192F40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82192F40h case    2:*/		return 0x82192F44;
		  /* 82192F44h */ case    3:  		/* lwz R21, <#[R4 + 44]> */
		/* 82192F44h case    3:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R4 + 0x0000002C) );
		/* 82192F44h case    3:*/		return 0x82192F48;
		  /* 82192F48h */ case    4:  		/* mr R26, R3 */
		/* 82192F48h case    4:*/		regs.R26 = regs.R3;
		/* 82192F48h case    4:*/		return 0x82192F4C;
		  /* 82192F4Ch */ case    5:  		/* lwz R11, <#[R3 + 44]> */
		/* 82192F4Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 82192F4Ch case    5:*/		return 0x82192F50;
		  /* 82192F50h */ case    6:  		/* mr R29, R4 */
		/* 82192F50h case    6:*/		regs.R29 = regs.R4;
		/* 82192F50h case    6:*/		return 0x82192F54;
		  /* 82192F54h */ case    7:  		/* lwz R10, <#[R4 + 8]> */
		/* 82192F54h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 82192F54h case    7:*/		return 0x82192F58;
		  /* 82192F58h */ case    8:  		/* mr R20, R5 */
		/* 82192F58h case    8:*/		regs.R20 = regs.R5;
		/* 82192F58h case    8:*/		return 0x82192F5C;
		  /* 82192F5Ch */ case    9:  		/* mr R22, R6 */
		/* 82192F5Ch case    9:*/		regs.R22 = regs.R6;
		/* 82192F5Ch case    9:*/		return 0x82192F60;
	}
	return 0x82192F60;
} // Block from 82192F38h-82192F60h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82192F60h
// Function '?PrepBlockForScheduling@Compiler@D3DXShader@@AAAPAVInstruction@2@PAVBlock@2@PAPAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192F60);
		  /* 82192F60h */ case    0:  		/* rlwinm. R11, R11, 25, 31, 31 */
		/* 82192F60h case    0:*/		cpu::op::rlwinm<1,25,31,31>(regs,&regs.R11,regs.R11);
		/* 82192F60h case    0:*/		return 0x82192F64;
		  /* 82192F64h */ case    1:  		/* lwz R19, <#[R21 + 12]> */
		/* 82192F64h case    1:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R21 + 0x0000000C) );
		/* 82192F64h case    1:*/		return 0x82192F68;
		  /* 82192F68h */ case    2:  		/* bc 12, CR0_EQ, 24 */
		/* 82192F68h case    2:*/		if ( regs.CR[0].eq ) { return 0x82192F80;  }
		/* 82192F68h case    2:*/		return 0x82192F6C;
		  /* 82192F6Ch */ case    3:  		/* li R11, 1 */
		/* 82192F6Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192F6Ch case    3:*/		return 0x82192F70;
		  /* 82192F70h */ case    4:  		/* rlwinm R9, R10, 18, 29, 31 */
		/* 82192F70h case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R9,regs.R10);
		/* 82192F70h case    4:*/		return 0x82192F74;
		  /* 82192F74h */ case    5:  		/* slw R11, R11, R9 */
		/* 82192F74h case    5:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82192F74h case    5:*/		return 0x82192F78;
		  /* 82192F78h */ case    6:  		/* addi R31, R11, -1 */
		/* 82192F78h case    6:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFFFFF);
		/* 82192F78h case    6:*/		return 0x82192F7C;
		  /* 82192F7Ch */ case    7:  		/* b 8 */
		/* 82192F7Ch case    7:*/		return 0x82192F84;
		/* 82192F7Ch case    7:*/		return 0x82192F80;
	}
	return 0x82192F80;
} // Block from 82192F60h-82192F80h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82192F80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192F80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192F80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192F80);
		  /* 82192F80h */ case    0:  		/* rlwinm R31, R10, 31, 28, 31 */
		/* 82192F80h case    0:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R31,regs.R10);
		/* 82192F80h case    0:*/		return 0x82192F84;
	}
	return 0x82192F84;
} // Block from 82192F80h-82192F84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192F84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192F84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192F84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192F84);
		  /* 82192F84h */ case    0:  		/* lwz R23, <#[R29 + 28]> */
		/* 82192F84h case    0:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R29 + 0x0000001C) );
		/* 82192F84h case    0:*/		return 0x82192F88;
		  /* 82192F88h */ case    1:  		/* li R24, 0 */
		/* 82192F88h case    1:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 82192F88h case    1:*/		return 0x82192F8C;
		  /* 82192F8Ch */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 82192F8Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82192F8Ch case    2:*/		return 0x82192F90;
		  /* 82192F90h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 82192F90h case    3:*/		if ( regs.CR[6].eq ) { return 0x82192FA8;  }
		/* 82192F90h case    3:*/		return 0x82192F94;
		  /* 82192F94h */ case    4:  		/* addi R11, R31, -1 */
		/* 82192F94h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFF);
		/* 82192F94h case    4:*/		return 0x82192F98;
		  /* 82192F98h */ case    5:  		/* andc R11, R31, R11 */
		/* 82192F98h case    5:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 82192F98h case    5:*/		return 0x82192F9C;
		  /* 82192F9Ch */ case    6:  		/* subf. R11, R11, R31 */
		/* 82192F9Ch case    6:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82192F9Ch case    6:*/		return 0x82192FA0;
		  /* 82192FA0h */ case    7:  		/* li R11, 1 */
		/* 82192FA0h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82192FA0h case    7:*/		return 0x82192FA4;
		  /* 82192FA4h */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 82192FA4h case    8:*/		if ( regs.CR[0].eq ) { return 0x82192FAC;  }
		/* 82192FA4h case    8:*/		return 0x82192FA8;
	}
	return 0x82192FA8;
} // Block from 82192F84h-82192FA8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82192FA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192FA8);
		  /* 82192FA8h */ case    0:  		/* li R11, 0 */
		/* 82192FA8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82192FA8h case    0:*/		return 0x82192FAC;
	}
	return 0x82192FAC;
} // Block from 82192FA8h-82192FACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82192FACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192FAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192FAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192FAC);
		  /* 82192FACh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82192FACh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82192FACh case    0:*/		return 0x82192FB0;
		  /* 82192FB0h */ case    1:  		/* bc 4, CR0_EQ, 72 */
		/* 82192FB0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82192FF8;  }
		/* 82192FB0h case    1:*/		return 0x82192FB4;
		  /* 82192FB4h */ case    2:  		/* rlwinm. R11, R10, 27, 31, 31 */
		/* 82192FB4h case    2:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R10);
		/* 82192FB4h case    2:*/		return 0x82192FB8;
		  /* 82192FB8h */ case    3:  		/* bc 4, CR0_EQ, 64 */
		/* 82192FB8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82192FF8;  }
		/* 82192FB8h case    3:*/		return 0x82192FBC;
		  /* 82192FBCh */ case    4:  		/* lis R11, -28311 */
		/* 82192FBCh case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF9169);
		/* 82192FBCh case    4:*/		return 0x82192FC0;
		  /* 82192FC0h */ case    5:  		/* lis R10, 0 */
		/* 82192FC0h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 82192FC0h case    5:*/		return 0x82192FC4;
		  /* 82192FC4h */ case    6:  		/* ori R11, R11, 5192 */
		/* 82192FC4h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1448);
		/* 82192FC4h case    6:*/		return 0x82192FC8;
		  /* 82192FC8h */ case    7:  		/* ori R10, R10, 36262 */
		/* 82192FC8h case    7:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8DA6);
		/* 82192FC8h case    7:*/		return 0x82192FCC;
		  /* 82192FCCh */ case    8:  		/* rldicl R9, R31, 0, 32 */
		/* 82192FCCh case    8:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R31);
		/* 82192FCCh case    8:*/		return 0x82192FD0;
		  /* 82192FD0h */ case    9:  		/* rldimi R11, R10, 32, 0 */
		/* 82192FD0h case    9:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R11,regs.R10);
		/* 82192FD0h case    9:*/		return 0x82192FD4;
		  /* 82192FD4h */ case   10:  		/* li R5, 0 */
		/* 82192FD4h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82192FD4h case   10:*/		return 0x82192FD8;
		  /* 82192FD8h */ case   11:  		/* srd R11, R11, R9 */
		/* 82192FD8h case   11:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82192FD8h case   11:*/		return 0x82192FDC;
		  /* 82192FDCh */ case   12:  		/* srd R11, R11, R9 */
		/* 82192FDCh case   12:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82192FDCh case   12:*/		return 0x82192FE0;
		  /* 82192FE0h */ case   13:  		/* srd R11, R11, R9 */
		/* 82192FE0h case   13:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82192FE0h case   13:*/		return 0x82192FE4;
		  /* 82192FE4h */ case   14:  		/* mr R4, R23 */
		/* 82192FE4h case   14:*/		regs.R4 = regs.R23;
		/* 82192FE4h case   14:*/		return 0x82192FE8;
		  /* 82192FE8h */ case   15:  		/* rlwinm R6, R11, 0, 29, 31 */
		/* 82192FE8h case   15:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R6,regs.R11);
		/* 82192FE8h case   15:*/		return 0x82192FEC;
		  /* 82192FECh */ case   16:  		/* mr R3, R26 */
		/* 82192FECh case   16:*/		regs.R3 = regs.R26;
		/* 82192FECh case   16:*/		return 0x82192FF0;
		  /* 82192FF0h */ case   17:  		/* bl 596752 */
		/* 82192FF0h case   17:*/		regs.LR = 0x82192FF4; return 0x82224B00;
		/* 82192FF0h case   17:*/		return 0x82192FF4;
		  /* 82192FF4h */ case   18:  		/* mr R24, R3 */
		/* 82192FF4h case   18:*/		regs.R24 = regs.R3;
		/* 82192FF4h case   18:*/		return 0x82192FF8;
	}
	return 0x82192FF8;
} // Block from 82192FACh-82192FF8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82192FF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82192FF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82192FF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82192FF8);
		  /* 82192FF8h */ case    0:  		/* li R25, 0 */
		/* 82192FF8h case    0:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82192FF8h case    0:*/		return 0x82192FFC;
		  /* 82192FFCh */ case    1:  		/* b 252 */
		/* 82192FFCh case    1:*/		return 0x821930F8;
		/* 82192FFCh case    1:*/		return 0x82193000;
		  /* 82193000h */ case    2:  		/* addi R11, R31, -1 */
		/* 82193000h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFF);
		/* 82193000h case    2:*/		return 0x82193004;
		  /* 82193004h */ case    3:  		/* li R8, 1 */
		/* 82193004h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82193004h case    3:*/		return 0x82193008;
		  /* 82193008h */ case    4:  		/* andc R11, R31, R11 */
		/* 82193008h case    4:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 82193008h case    4:*/		return 0x8219300C;
		  /* 8219300Ch */ case    5:  		/* li R7, 1 */
		/* 8219300Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8219300Ch case    5:*/		return 0x82193010;
		  /* 82193010h */ case    6:  		/* cntlzw R10, R11 */
		/* 82193010h case    6:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R11);
		/* 82193010h case    6:*/		return 0x82193014;
		  /* 82193014h */ case    7:  		/* mr R6, R20 */
		/* 82193014h case    7:*/		regs.R6 = regs.R20;
		/* 82193014h case    7:*/		return 0x82193018;
		  /* 82193018h */ case    8:  		/* mr R5, R22 */
		/* 82193018h case    8:*/		regs.R5 = regs.R22;
		/* 82193018h case    8:*/		return 0x8219301C;
		  /* 8219301Ch */ case    9:  		/* mr R4, R23 */
		/* 8219301Ch case    9:*/		regs.R4 = regs.R23;
		/* 8219301Ch case    9:*/		return 0x82193020;
		  /* 82193020h */ case   10:  		/* mr R3, R26 */
		/* 82193020h case   10:*/		regs.R3 = regs.R26;
		/* 82193020h case   10:*/		return 0x82193024;
		  /* 82193024h */ case   11:  		/* subf R31, R11, R31 */
		/* 82193024h case   11:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R11,regs.R31);
		/* 82193024h case   11:*/		return 0x82193028;
		  /* 82193028h */ case   12:  		/* subfic R28, R10, 31 */
		/* 82193028h case   12:*/		cpu::op::subfic<0>(regs,&regs.R28,regs.R10,0x1F);
		/* 82193028h case   12:*/		return 0x8219302C;
		  /* 8219302Ch */ case   13:  		/* bl 596332 */
		/* 8219302Ch case   13:*/		regs.LR = 0x82193030; return 0x82224998;
		/* 8219302Ch case   13:*/		return 0x82193030;
		  /* 82193030h */ case   14:  		/* lwz R27, <#[R29]> */
		/* 82193030h case   14:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R29 + 0x00000000) );
		/* 82193030h case   14:*/		return 0x82193034;
		  /* 82193034h */ case   15:  		/* mr R30, R3 */
		/* 82193034h case   15:*/		regs.R30 = regs.R3;
		/* 82193034h case   15:*/		return 0x82193038;
		  /* 82193038h */ case   16:  		/* cmplwi CR6, R27, 0 */
		/* 82193038h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82193038h case   16:*/		return 0x8219303C;
		  /* 8219303Ch */ case   17:  		/* bc 12, CR6_EQ, 52 */
		/* 8219303Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x82193070;  }
		/* 8219303Ch case   17:*/		return 0x82193040;
		  /* 82193040h */ case   18:  		/* lwz R11, <#[R27]> */
		/* 82193040h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82193040h case   18:*/		return 0x82193044;
		  /* 82193044h */ case   19:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82193044h case   19:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82193044h case   19:*/		return 0x82193048;
		  /* 82193048h */ case   20:  		/* bc 4, CR0_EQ, 32 */
		/* 82193048h case   20:*/		if ( !regs.CR[0].eq ) { return 0x82193068;  }
		/* 82193048h case   20:*/		return 0x8219304C;
		  /* 8219304Ch */ case   21:  		/* mr R4, R27 */
		/* 8219304Ch case   21:*/		regs.R4 = regs.R27;
		/* 8219304Ch case   21:*/		return 0x82193050;
		  /* 82193050h */ case   22:  		/* lwz R5, <#[R27 + 12]> */
		/* 82193050h case   22:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + 0x0000000C) );
		/* 82193050h case   22:*/		return 0x82193054;
		  /* 82193054h */ case   23:  		/* mr R3, R26 */
		/* 82193054h case   23:*/		regs.R3 = regs.R26;
		/* 82193054h case   23:*/		return 0x82193058;
		  /* 82193058h */ case   24:  		/* bl -139112 */
		/* 82193058h case   24:*/		regs.LR = 0x8219305C; return 0x821710F0;
		/* 82193058h case   24:*/		return 0x8219305C;
		  /* 8219305Ch */ case   25:  		/* mr R4, R3 */
		/* 8219305Ch case   25:*/		regs.R4 = regs.R3;
		/* 8219305Ch case   25:*/		return 0x82193060;
		  /* 82193060h */ case   26:  		/* mr R3, R30 */
		/* 82193060h case   26:*/		regs.R3 = regs.R30;
		/* 82193060h case   26:*/		return 0x82193064;
		  /* 82193064h */ case   27:  		/* bl -110236 */
		/* 82193064h case   27:*/		regs.LR = 0x82193068; return 0x821781C8;
		/* 82193064h case   27:*/		return 0x82193068;
	}
	return 0x82193068;
} // Block from 82192FF8h-82193068h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82193068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193068);
		  /* 82193068h */ case    0:  		/* lwz R27, <#[R27 + 4]> */
		/* 82193068h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R27 + 0x00000004) );
		/* 82193068h case    0:*/		return 0x8219306C;
		  /* 8219306Ch */ case    1:  		/* b -52 */
		/* 8219306Ch case    1:*/		return 0x82193038;
		/* 8219306Ch case    1:*/		return 0x82193070;
	}
	return 0x82193070;
} // Block from 82193068h-82193070h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82193070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193070);
		  /* 82193070h */ case    0:  		/* lwz R11, <#[R21]> */
		/* 82193070h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 82193070h case    0:*/		return 0x82193074;
		  /* 82193074h */ case    1:  		/* rlwinm R10, R28, 1, 0, 30 */
		/* 82193074h case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R28);
		/* 82193074h case    1:*/		return 0x82193078;
		  /* 82193078h */ case    2:  		/* mr R4, R19 */
		/* 82193078h case    2:*/		regs.R4 = regs.R19;
		/* 82193078h case    2:*/		return 0x8219307C;
		  /* 8219307Ch */ case    3:  		/* rlwinm R9, R11, 27, 24, 31 */
		/* 8219307Ch case    3:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R11);
		/* 8219307Ch case    3:*/		return 0x82193080;
		  /* 82193080h */ case    4:  		/* rlwinm R6, R11, 0, 27, 31 */
		/* 82193080h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R6,regs.R11);
		/* 82193080h case    4:*/		return 0x82193084;
		  /* 82193084h */ case    5:  		/* srw R11, R9, R10 */
		/* 82193084h case    5:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R9,regs.R10);
		/* 82193084h case    5:*/		return 0x82193088;
		  /* 82193088h */ case    6:  		/* rlwinm R5, R11, 0, 30, 31 */
		/* 82193088h case    6:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R5,regs.R11);
		/* 82193088h case    6:*/		return 0x8219308C;
		  /* 8219308Ch */ case    7:  		/* mr R3, R26 */
		/* 8219308Ch case    7:*/		regs.R3 = regs.R26;
		/* 8219308Ch case    7:*/		return 0x82193090;
		  /* 82193090h */ case    8:  		/* bl -110376 */
		/* 82193090h case    8:*/		regs.LR = 0x82193094; return 0x82178168;
		/* 82193090h case    8:*/		return 0x82193094;
		  /* 82193094h */ case    9:  		/* mr R4, R3 */
		/* 82193094h case    9:*/		regs.R4 = regs.R3;
		/* 82193094h case    9:*/		return 0x82193098;
		  /* 82193098h */ case   10:  		/* mr R3, R30 */
		/* 82193098h case   10:*/		regs.R3 = regs.R30;
		/* 82193098h case   10:*/		return 0x8219309C;
		  /* 8219309Ch */ case   11:  		/* bl -110292 */
		/* 8219309Ch case   11:*/		regs.LR = 0x821930A0; return 0x821781C8;
		/* 8219309Ch case   11:*/		return 0x821930A0;
		  /* 821930A0h */ case   12:  		/* stw R3, <#[R30 + 44]> */
		/* 821930A0h case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000002C) );
		/* 821930A0h case   12:*/		return 0x821930A4;
		  /* 821930A4h */ case   13:  		/* lwz R11, <#[R29 + 8]> */
		/* 821930A4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821930A4h case   13:*/		return 0x821930A8;
		  /* 821930A8h */ case   14:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821930A8h case   14:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821930A8h case   14:*/		return 0x821930AC;
		  /* 821930ACh */ case   15:  		/* bc 12, CR0_EQ, 16 */
		/* 821930ACh case   15:*/		if ( regs.CR[0].eq ) { return 0x821930BC;  }
		/* 821930ACh case   15:*/		return 0x821930B0;
		  /* 821930B0h */ case   16:  		/* lwz R11, <#[R30 + 8]> */
		/* 821930B0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821930B0h case   16:*/		return 0x821930B4;
		  /* 821930B4h */ case   17:  		/* ori R11, R11, 1 */
		/* 821930B4h case   17:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821930B4h case   17:*/		return 0x821930B8;
		  /* 821930B8h */ case   18:  		/* stw R11, <#[R30 + 8]> */
		/* 821930B8h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821930B8h case   18:*/		return 0x821930BC;
	}
	return 0x821930BC;
} // Block from 82193070h-821930BCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 821930BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821930BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821930BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821930BC);
		  /* 821930BCh */ case    0:  		/* mr R4, R28 */
		/* 821930BCh case    0:*/		regs.R4 = regs.R28;
		/* 821930BCh case    0:*/		return 0x821930C0;
		  /* 821930C0h */ case    1:  		/* mr R3, R29 */
		/* 821930C0h case    1:*/		regs.R3 = regs.R29;
		/* 821930C0h case    1:*/		return 0x821930C4;
		  /* 821930C4h */ case    2:  		/* bl 171940 */
		/* 821930C4h case    2:*/		regs.LR = 0x821930C8; return 0x821BD068;
		/* 821930C4h case    2:*/		return 0x821930C8;
		  /* 821930C8h */ case    3:  		/* mr R5, R3 */
		/* 821930C8h case    3:*/		regs.R5 = regs.R3;
		/* 821930C8h case    3:*/		return 0x821930CC;
		  /* 821930CCh */ case    4:  		/* li R4, 0 */
		/* 821930CCh case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821930CCh case    4:*/		return 0x821930D0;
		  /* 821930D0h */ case    5:  		/* mr R3, R30 */
		/* 821930D0h case    5:*/		regs.R3 = regs.R30;
		/* 821930D0h case    5:*/		return 0x821930D4;
		  /* 821930D4h */ case    6:  		/* bl 172084 */
		/* 821930D4h case    6:*/		regs.LR = 0x821930D8; return 0x821BD108;
		/* 821930D4h case    6:*/		return 0x821930D8;
		  /* 821930D8h */ case    7:  		/* mr R8, R28 */
		/* 821930D8h case    7:*/		regs.R8 = regs.R28;
		/* 821930D8h case    7:*/		return 0x821930DC;
		  /* 821930DCh */ case    8:  		/* mr R7, R25 */
		/* 821930DCh case    8:*/		regs.R7 = regs.R25;
		/* 821930DCh case    8:*/		return 0x821930E0;
		  /* 821930E0h */ case    9:  		/* mr R6, R24 */
		/* 821930E0h case    9:*/		regs.R6 = regs.R24;
		/* 821930E0h case    9:*/		return 0x821930E4;
		  /* 821930E4h */ case   10:  		/* mr R5, R29 */
		/* 821930E4h case   10:*/		regs.R5 = regs.R29;
		/* 821930E4h case   10:*/		return 0x821930E8;
		  /* 821930E8h */ case   11:  		/* mr R4, R30 */
		/* 821930E8h case   11:*/		regs.R4 = regs.R30;
		/* 821930E8h case   11:*/		return 0x821930EC;
		  /* 821930ECh */ case   12:  		/* mr R3, R26 */
		/* 821930ECh case   12:*/		regs.R3 = regs.R26;
		/* 821930ECh case   12:*/		return 0x821930F0;
		  /* 821930F0h */ case   13:  		/* bl -7960 */
		/* 821930F0h case   13:*/		regs.LR = 0x821930F4; return 0x821911D8;
		/* 821930F0h case   13:*/		return 0x821930F4;
		  /* 821930F4h */ case   14:  		/* addi R25, R25, 1 */
		/* 821930F4h case   14:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 821930F4h case   14:*/		return 0x821930F8;
	}
	return 0x821930F8;
} // Block from 821930BCh-821930F8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821930F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821930F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821930F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821930F8);
		  /* 821930F8h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 821930F8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821930F8h case    0:*/		return 0x821930FC;
		  /* 821930FCh */ case    1:  		/* bc 4, CR6_EQ, -252 */
		/* 821930FCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82193000;  }
		/* 821930FCh case    1:*/		return 0x82193100;
		  /* 82193100h */ case    2:  		/* cmplwi CR6, R24, 0 */
		/* 82193100h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 82193100h case    2:*/		return 0x82193104;
		  /* 82193104h */ case    3:  		/* bc 12, CR6_EQ, 56 */
		/* 82193104h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219313C;  }
		/* 82193104h case    3:*/		return 0x82193108;
		  /* 82193108h */ case    4:  		/* rlwinm R11, R24, 0, 0, 30 */
		/* 82193108h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R24);
		/* 82193108h case    4:*/		return 0x8219310C;
		  /* 8219310Ch */ case    5:  		/* lwz R9, <#[R22]> */
		/* 8219310Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R22 + 0x00000000) );
		/* 8219310Ch case    5:*/		return 0x82193110;
		  /* 82193110h */ case    6:  		/* addi R10, R22, -36 */
		/* 82193110h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R22,0xFFFFFFDC);
		/* 82193110h case    6:*/		return 0x82193114;
		  /* 82193114h */ case    7:  		/* addi R11, R11, 36 */
		/* 82193114h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82193114h case    7:*/		return 0x82193118;
		  /* 82193118h */ case    8:  		/* ori R8, R10, 1 */
		/* 82193118h case    8:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 82193118h case    8:*/		return 0x8219311C;
		  /* 8219311Ch */ case    9:  		/* addi R7, R11, -36 */
		/* 8219311Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 8219311Ch case    9:*/		return 0x82193120;
		  /* 82193120h */ case   10:  		/* addi R10, R11, 4 */
		/* 82193120h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82193120h case   10:*/		return 0x82193124;
		  /* 82193124h */ case   11:  		/* stw R9, <#[R11]> */
		/* 82193124h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82193124h case   11:*/		return 0x82193128;
		  /* 82193128h */ case   12:  		/* lwz R9, <#[R22]> */
		/* 82193128h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R22 + 0x00000000) );
		/* 82193128h case   12:*/		return 0x8219312C;
		  /* 8219312Ch */ case   13:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 8219312Ch case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 8219312Ch case   13:*/		return 0x82193130;
		  /* 82193130h */ case   14:  		/* stw R7, <#[R9]> */
		/* 82193130h case   14:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 82193130h case   14:*/		return 0x82193134;
		  /* 82193134h */ case   15:  		/* stw R8, <#[R11 + 4]> */
		/* 82193134h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82193134h case   15:*/		return 0x82193138;
		  /* 82193138h */ case   16:  		/* stw R10, <#[R22]> */
		/* 82193138h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R22 + 0x00000000) );
		/* 82193138h case   16:*/		return 0x8219313C;
	}
	return 0x8219313C;
} // Block from 821930F8h-8219313Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8219313Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219313C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219313C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219313C);
		  /* 8219313Ch */ case    0:  		/* addi R1, R1, 192 */
		/* 8219313Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 8219313Ch case    0:*/		return 0x82193140;
		  /* 82193140h */ case    1:  		/* b -1056444 */
		/* 82193140h case    1:*/		return 0x82091284;
		/* 82193140h case    1:*/		return 0x82193144;
		  /* 82193144h */ case    2:  		/* nop */
		/* 82193144h case    2:*/		cpu::op::nop();
		/* 82193144h case    2:*/		return 0x82193148;
	}
	return 0x82193148;
} // Block from 8219313Ch-82193148h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82193148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193148);
		  /* 82193148h */ case    0:  		/* mfspr R12, LR */
		/* 82193148h case    0:*/		regs.R12 = regs.LR;
		/* 82193148h case    0:*/		return 0x8219314C;
		  /* 8219314Ch */ case    1:  		/* bl -1056556 */
		/* 8219314Ch case    1:*/		regs.LR = 0x82193150; return 0x82091220;
		/* 8219314Ch case    1:*/		return 0x82193150;
		  /* 82193150h */ case    2:  		/* stwu R1, <#[R1 - 240]> */
		/* 82193150h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 82193150h case    2:*/		return 0x82193154;
		  /* 82193154h */ case    3:  		/* lwz R24, <#[R4 + 44]> */
		/* 82193154h case    3:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R4 + 0x0000002C) );
		/* 82193154h case    3:*/		return 0x82193158;
		  /* 82193158h */ case    4:  		/* mr R27, R3 */
		/* 82193158h case    4:*/		regs.R27 = regs.R3;
		/* 82193158h case    4:*/		return 0x8219315C;
		  /* 8219315Ch */ case    5:  		/* lwz R11, <#[R3 + 44]> */
		/* 8219315Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 8219315Ch case    5:*/		return 0x82193160;
		  /* 82193160h */ case    6:  		/* mr R30, R4 */
		/* 82193160h case    6:*/		regs.R30 = regs.R4;
		/* 82193160h case    6:*/		return 0x82193164;
		  /* 82193164h */ case    7:  		/* lwz R20, <#[R4 + 48]> */
		/* 82193164h case    7:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R4 + 0x00000030) );
		/* 82193164h case    7:*/		return 0x82193168;
		  /* 82193168h */ case    8:  		/* mr R21, R5 */
		/* 82193168h case    8:*/		regs.R21 = regs.R5;
		/* 82193168h case    8:*/		return 0x8219316C;
		  /* 8219316Ch */ case    9:  		/* rlwinm. R11, R11, 25, 31, 31 */
		/* 8219316Ch case    9:*/		cpu::op::rlwinm<1,25,31,31>(regs,&regs.R11,regs.R11);
		/* 8219316Ch case    9:*/		return 0x82193170;
		  /* 82193170h */ case   10:  		/* lwz R23, <#[R4 + 28]> */
		/* 82193170h case   10:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R4 + 0x0000001C) );
		/* 82193170h case   10:*/		return 0x82193174;
		  /* 82193174h */ case   11:  		/* lwz R19, <#[R24 + 12]> */
		/* 82193174h case   11:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R24 + 0x0000000C) );
		/* 82193174h case   11:*/		return 0x82193178;
		  /* 82193178h */ case   12:  		/* mr R25, R6 */
		/* 82193178h case   12:*/		regs.R25 = regs.R6;
		/* 82193178h case   12:*/		return 0x8219317C;
		  /* 8219317Ch */ case   13:  		/* lwz R11, <#[R4 + 8]> */
		/* 8219317Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8219317Ch case   13:*/		return 0x82193180;
		  /* 82193180h */ case   14:  		/* li R22, 1 */
		/* 82193180h case   14:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 82193180h case   14:*/		return 0x82193184;
		  /* 82193184h */ case   15:  		/* bc 12, CR0_EQ, 20 */
		/* 82193184h case   15:*/		if ( regs.CR[0].eq ) { return 0x82193198;  }
		/* 82193184h case   15:*/		return 0x82193188;
		  /* 82193188h */ case   16:  		/* rlwinm R10, R11, 18, 29, 31 */
		/* 82193188h case   16:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R10,regs.R11);
		/* 82193188h case   16:*/		return 0x8219318C;
		  /* 8219318Ch */ case   17:  		/* slw R10, R22, R10 */
		/* 8219318Ch case   17:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R22,regs.R10);
		/* 8219318Ch case   17:*/		return 0x82193190;
		  /* 82193190h */ case   18:  		/* addi R31, R10, -1 */
		/* 82193190h case   18:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R10,0xFFFFFFFF);
		/* 82193190h case   18:*/		return 0x82193194;
		  /* 82193194h */ case   19:  		/* b 8 */
		/* 82193194h case   19:*/		return 0x8219319C;
		/* 82193194h case   19:*/		return 0x82193198;
	}
	return 0x82193198;
} // Block from 82193148h-82193198h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82193198h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193198);
		  /* 82193198h */ case    0:  		/* rlwinm R31, R11, 31, 28, 31 */
		/* 82193198h case    0:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R31,regs.R11);
		/* 82193198h case    0:*/		return 0x8219319C;
	}
	return 0x8219319C;
} // Block from 82193198h-8219319Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219319Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219319C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219319C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219319C);
		  /* 8219319Ch */ case    0:  		/* li R26, 0 */
		/* 8219319Ch case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8219319Ch case    0:*/		return 0x821931A0;
		  /* 821931A0h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 821931A0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821931A0h case    1:*/		return 0x821931A4;
		  /* 821931A4h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 821931A4h case    2:*/		if ( regs.CR[6].eq ) { return 0x821931BC;  }
		/* 821931A4h case    2:*/		return 0x821931A8;
		  /* 821931A8h */ case    3:  		/* addi R10, R31, -1 */
		/* 821931A8h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFFF);
		/* 821931A8h case    3:*/		return 0x821931AC;
		  /* 821931ACh */ case    4:  		/* andc R10, R31, R10 */
		/* 821931ACh case    4:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R31,regs.R10);
		/* 821931ACh case    4:*/		return 0x821931B0;
		  /* 821931B0h */ case    5:  		/* subf. R10, R10, R31 */
		/* 821931B0h case    5:*/		cpu::op::subf<1>(regs,&regs.R10,regs.R10,regs.R31);
		/* 821931B0h case    5:*/		return 0x821931B4;
		  /* 821931B4h */ case    6:  		/* mr R10, R22 */
		/* 821931B4h case    6:*/		regs.R10 = regs.R22;
		/* 821931B4h case    6:*/		return 0x821931B8;
		  /* 821931B8h */ case    7:  		/* bc 12, CR0_EQ, 8 */
		/* 821931B8h case    7:*/		if ( regs.CR[0].eq ) { return 0x821931C0;  }
		/* 821931B8h case    7:*/		return 0x821931BC;
	}
	return 0x821931BC;
} // Block from 8219319Ch-821931BCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 821931BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821931BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821931BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821931BC);
		  /* 821931BCh */ case    0:  		/* li R10, 0 */
		/* 821931BCh case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821931BCh case    0:*/		return 0x821931C0;
	}
	return 0x821931C0;
} // Block from 821931BCh-821931C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821931C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821931C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821931C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821931C0);
		  /* 821931C0h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 821931C0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 821931C0h case    0:*/		return 0x821931C4;
		  /* 821931C4h */ case    1:  		/* bc 4, CR0_EQ, 36 */
		/* 821931C4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821931E8;  }
		/* 821931C4h case    1:*/		return 0x821931C8;
		  /* 821931C8h */ case    2:  		/* rlwinm. R10, R11, 27, 31, 31 */
		/* 821931C8h case    2:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R10,regs.R11);
		/* 821931C8h case    2:*/		return 0x821931CC;
		  /* 821931CCh */ case    3:  		/* bc 4, CR0_EQ, 28 */
		/* 821931CCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x821931E8;  }
		/* 821931CCh case    3:*/		return 0x821931D0;
		  /* 821931D0h */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821931D0h case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821931D0h case    4:*/		return 0x821931D4;
		  /* 821931D4h */ case    5:  		/* li R5, 0 */
		/* 821931D4h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821931D4h case    5:*/		return 0x821931D8;
		  /* 821931D8h */ case    6:  		/* mr R4, R23 */
		/* 821931D8h case    6:*/		regs.R4 = regs.R23;
		/* 821931D8h case    6:*/		return 0x821931DC;
		  /* 821931DCh */ case    7:  		/* mr R3, R27 */
		/* 821931DCh case    7:*/		regs.R3 = regs.R27;
		/* 821931DCh case    7:*/		return 0x821931E0;
		  /* 821931E0h */ case    8:  		/* bl 596256 */
		/* 821931E0h case    8:*/		regs.LR = 0x821931E4; return 0x82224B00;
		/* 821931E0h case    8:*/		return 0x821931E4;
		  /* 821931E4h */ case    9:  		/* mr R26, R3 */
		/* 821931E4h case    9:*/		regs.R26 = regs.R3;
		/* 821931E4h case    9:*/		return 0x821931E8;
	}
	return 0x821931E8;
} // Block from 821931C0h-821931E8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821931E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821931E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821931E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821931E8);
		  /* 821931E8h */ case    0:  		/* li R28, 0 */
		/* 821931E8h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 821931E8h case    0:*/		return 0x821931EC;
		  /* 821931ECh */ case    1:  		/* b 240 */
		/* 821931ECh case    1:*/		return 0x821932DC;
		/* 821931ECh case    1:*/		return 0x821931F0;
		  /* 821931F0h */ case    2:  		/* addi R11, R31, -1 */
		/* 821931F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFF);
		/* 821931F0h case    2:*/		return 0x821931F4;
		  /* 821931F4h */ case    3:  		/* li R8, 1 */
		/* 821931F4h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821931F4h case    3:*/		return 0x821931F8;
		  /* 821931F8h */ case    4:  		/* andc R11, R31, R11 */
		/* 821931F8h case    4:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 821931F8h case    4:*/		return 0x821931FC;
		  /* 821931FCh */ case    5:  		/* li R7, 1 */
		/* 821931FCh case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821931FCh case    5:*/		return 0x82193200;
		  /* 82193200h */ case    6:  		/* cntlzw R10, R11 */
		/* 82193200h case    6:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R11);
		/* 82193200h case    6:*/		return 0x82193204;
		  /* 82193204h */ case    7:  		/* mr R6, R21 */
		/* 82193204h case    7:*/		regs.R6 = regs.R21;
		/* 82193204h case    7:*/		return 0x82193208;
		  /* 82193208h */ case    8:  		/* mr R5, R25 */
		/* 82193208h case    8:*/		regs.R5 = regs.R25;
		/* 82193208h case    8:*/		return 0x8219320C;
		  /* 8219320Ch */ case    9:  		/* mr R4, R23 */
		/* 8219320Ch case    9:*/		regs.R4 = regs.R23;
		/* 8219320Ch case    9:*/		return 0x82193210;
		  /* 82193210h */ case   10:  		/* mr R3, R27 */
		/* 82193210h case   10:*/		regs.R3 = regs.R27;
		/* 82193210h case   10:*/		return 0x82193214;
		  /* 82193214h */ case   11:  		/* subf R31, R11, R31 */
		/* 82193214h case   11:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R11,regs.R31);
		/* 82193214h case   11:*/		return 0x82193218;
		  /* 82193218h */ case   12:  		/* subfic R29, R10, 31 */
		/* 82193218h case   12:*/		cpu::op::subfic<0>(regs,&regs.R29,regs.R10,0x1F);
		/* 82193218h case   12:*/		return 0x8219321C;
		  /* 8219321Ch */ case   13:  		/* bl 595836 */
		/* 8219321Ch case   13:*/		regs.LR = 0x82193220; return 0x82224998;
		/* 8219321Ch case   13:*/		return 0x82193220;
		  /* 82193220h */ case   14:  		/* lwz R11, <#[R24]> */
		/* 82193220h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 82193220h case   14:*/		return 0x82193224;
		  /* 82193224h */ case   15:  		/* rlwinm R10, R29, 1, 0, 30 */
		/* 82193224h case   15:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R29);
		/* 82193224h case   15:*/		return 0x82193228;
		  /* 82193228h */ case   16:  		/* lwz R9, <#[R20]> */
		/* 82193228h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R20 + 0x00000000) );
		/* 82193228h case   16:*/		return 0x8219322C;
		  /* 8219322Ch */ case   17:  		/* mr R18, R3 */
		/* 8219322Ch case   17:*/		regs.R18 = regs.R3;
		/* 8219322Ch case   17:*/		return 0x82193230;
		  /* 82193230h */ case   18:  		/* rlwinm R8, R11, 27, 24, 31 */
		/* 82193230h case   18:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R8,regs.R11);
		/* 82193230h case   18:*/		return 0x82193234;
		  /* 82193234h */ case   19:  		/* rlwinm R9, R9, 27, 24, 31 */
		/* 82193234h case   19:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R9);
		/* 82193234h case   19:*/		return 0x82193238;
		  /* 82193238h */ case   20:  		/* srw R8, R8, R10 */
		/* 82193238h case   20:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R8,regs.R10);
		/* 82193238h case   20:*/		return 0x8219323C;
		  /* 8219323Ch */ case   21:  		/* srw R10, R9, R10 */
		/* 8219323Ch case   21:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8219323Ch case   21:*/		return 0x82193240;
		  /* 82193240h */ case   22:  		/* mr R4, R19 */
		/* 82193240h case   22:*/		regs.R4 = regs.R19;
		/* 82193240h case   22:*/		return 0x82193244;
		  /* 82193244h */ case   23:  		/* mr R3, R27 */
		/* 82193244h case   23:*/		regs.R3 = regs.R27;
		/* 82193244h case   23:*/		return 0x82193248;
		  /* 82193248h */ case   24:  		/* rlwinm R17, R11, 0, 27, 31 */
		/* 82193248h case   24:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R17,regs.R11);
		/* 82193248h case   24:*/		return 0x8219324C;
		  /* 8219324Ch */ case   25:  		/* rlwinm R16, R10, 0, 30, 31 */
		/* 8219324Ch case   25:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R16,regs.R10);
		/* 8219324Ch case   25:*/		return 0x82193250;
		  /* 82193250h */ case   26:  		/* rlwinm R15, R8, 0, 30, 31 */
		/* 82193250h case   26:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R15,regs.R8);
		/* 82193250h case   26:*/		return 0x82193254;
		  /* 82193254h */ case   27:  		/* bl -111188 */
		/* 82193254h case   27:*/		regs.LR = 0x82193258; return 0x82178000;
		/* 82193254h case   27:*/		return 0x82193258;
		  /* 82193258h */ case   28:  		/* lwz R11, <#[R3]> */
		/* 82193258h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82193258h case   28:*/		return 0x8219325C;
		  /* 8219325Ch */ case   29:  		/* mr R4, R17 */
		/* 8219325Ch case   29:*/		regs.R4 = regs.R17;
		/* 8219325Ch case   29:*/		return 0x82193260;
		  /* 82193260h */ case   30:  		/* mr R14, R3 */
		/* 82193260h case   30:*/		regs.R14 = regs.R3;
		/* 82193260h case   30:*/		return 0x82193264;
		  /* 82193264h */ case   31:  		/* rlwimi R11, R22, 26, 4, 6 */
		/* 82193264h case   31:*/		cpu::op::rlwimi<0,26,4,6>(regs,&regs.R11,regs.R22);
		/* 82193264h case   31:*/		return 0x82193268;
		  /* 82193268h */ case   32:  		/* stw R11, <#[R3]> */
		/* 82193268h case   32:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82193268h case   32:*/		return 0x8219326C;
		  /* 8219326Ch */ case   33:  		/* bl -112556 */
		/* 8219326Ch case   33:*/		regs.LR = 0x82193270; return 0x82177AC0;
		/* 8219326Ch case   33:*/		return 0x82193270;
		  /* 82193270h */ case   34:  		/* li R11, 224 */
		/* 82193270h case   34:*/		cpu::op::li<0>(regs,&regs.R11,0xE0);
		/* 82193270h case   34:*/		return 0x82193274;
		  /* 82193274h */ case   35:  		/* lwz R10, <#[R14]> */
		/* 82193274h case   35:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000000) );
		/* 82193274h case   35:*/		return 0x82193278;
		  /* 82193278h */ case   36:  		/* mr R3, R18 */
		/* 82193278h case   36:*/		regs.R3 = regs.R18;
		/* 82193278h case   36:*/		return 0x8219327C;
		  /* 8219327Ch */ case   37:  		/* rlwimi R11, R16, 2, 27, 29 */
		/* 8219327Ch case   37:*/		cpu::op::rlwimi<0,2,27,29>(regs,&regs.R11,regs.R16);
		/* 8219327Ch case   37:*/		return 0x82193280;
		  /* 82193280h */ case   38:  		/* rlwinm R10, R10, 0, 27, 21 */
		/* 82193280h case   38:*/		cpu::op::rlwinm<0,0,27,21>(regs,&regs.R10,regs.R10);
		/* 82193280h case   38:*/		return 0x82193284;
		  /* 82193284h */ case   39:  		/* or R11, R11, R15 */
		/* 82193284h case   39:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R15);
		/* 82193284h case   39:*/		return 0x82193288;
		  /* 82193288h */ case   40:  		/* mr R4, R14 */
		/* 82193288h case   40:*/		regs.R4 = regs.R14;
		/* 82193288h case   40:*/		return 0x8219328C;
		  /* 8219328Ch */ case   41:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 8219328Ch case   41:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 8219328Ch case   41:*/		return 0x82193290;
		  /* 82193290h */ case   42:  		/* or R11, R11, R10 */
		/* 82193290h case   42:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82193290h case   42:*/		return 0x82193294;
		  /* 82193294h */ case   43:  		/* stw R11, <#[R14]> */
		/* 82193294h case   43:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R14 + 0x00000000) );
		/* 82193294h case   43:*/		return 0x82193298;
		  /* 82193298h */ case   44:  		/* bl -110800 */
		/* 82193298h case   44:*/		regs.LR = 0x8219329C; return 0x821781C8;
		/* 82193298h case   44:*/		return 0x8219329C;
		  /* 8219329Ch */ case   45:  		/* stw R3, <#[R18 + 44]> */
		/* 8219329Ch case   45:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R18 + 0x0000002C) );
		/* 8219329Ch case   45:*/		return 0x821932A0;
		  /* 821932A0h */ case   46:  		/* mr R4, R29 */
		/* 821932A0h case   46:*/		regs.R4 = regs.R29;
		/* 821932A0h case   46:*/		return 0x821932A4;
		  /* 821932A4h */ case   47:  		/* mr R3, R30 */
		/* 821932A4h case   47:*/		regs.R3 = regs.R30;
		/* 821932A4h case   47:*/		return 0x821932A8;
		  /* 821932A8h */ case   48:  		/* bl 171456 */
		/* 821932A8h case   48:*/		regs.LR = 0x821932AC; return 0x821BD068;
		/* 821932A8h case   48:*/		return 0x821932AC;
		  /* 821932ACh */ case   49:  		/* mr R5, R3 */
		/* 821932ACh case   49:*/		regs.R5 = regs.R3;
		/* 821932ACh case   49:*/		return 0x821932B0;
		  /* 821932B0h */ case   50:  		/* mr R3, R18 */
		/* 821932B0h case   50:*/		regs.R3 = regs.R18;
		/* 821932B0h case   50:*/		return 0x821932B4;
		  /* 821932B4h */ case   51:  		/* li R4, 0 */
		/* 821932B4h case   51:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821932B4h case   51:*/		return 0x821932B8;
		  /* 821932B8h */ case   52:  		/* bl 171600 */
		/* 821932B8h case   52:*/		regs.LR = 0x821932BC; return 0x821BD108;
		/* 821932B8h case   52:*/		return 0x821932BC;
		  /* 821932BCh */ case   53:  		/* mr R8, R29 */
		/* 821932BCh case   53:*/		regs.R8 = regs.R29;
		/* 821932BCh case   53:*/		return 0x821932C0;
		  /* 821932C0h */ case   54:  		/* mr R7, R28 */
		/* 821932C0h case   54:*/		regs.R7 = regs.R28;
		/* 821932C0h case   54:*/		return 0x821932C4;
		  /* 821932C4h */ case   55:  		/* mr R6, R26 */
		/* 821932C4h case   55:*/		regs.R6 = regs.R26;
		/* 821932C4h case   55:*/		return 0x821932C8;
		  /* 821932C8h */ case   56:  		/* mr R5, R30 */
		/* 821932C8h case   56:*/		regs.R5 = regs.R30;
		/* 821932C8h case   56:*/		return 0x821932CC;
		  /* 821932CCh */ case   57:  		/* mr R4, R18 */
		/* 821932CCh case   57:*/		regs.R4 = regs.R18;
		/* 821932CCh case   57:*/		return 0x821932D0;
		  /* 821932D0h */ case   58:  		/* mr R3, R27 */
		/* 821932D0h case   58:*/		regs.R3 = regs.R27;
		/* 821932D0h case   58:*/		return 0x821932D4;
		  /* 821932D4h */ case   59:  		/* bl -8444 */
		/* 821932D4h case   59:*/		regs.LR = 0x821932D8; return 0x821911D8;
		/* 821932D4h case   59:*/		return 0x821932D8;
		  /* 821932D8h */ case   60:  		/* addi R28, R28, 1 */
		/* 821932D8h case   60:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 821932D8h case   60:*/		return 0x821932DC;
	}
	return 0x821932DC;
} // Block from 821931E8h-821932DCh (61 instructions)

//////////////////////////////////////////////////////
// Block at 821932DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821932DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821932DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821932DC);
		  /* 821932DCh */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 821932DCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821932DCh case    0:*/		return 0x821932E0;
		  /* 821932E0h */ case    1:  		/* bc 4, CR6_EQ, -240 */
		/* 821932E0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821931F0;  }
		/* 821932E0h case    1:*/		return 0x821932E4;
		  /* 821932E4h */ case    2:  		/* cmplwi CR6, R26, 0 */
		/* 821932E4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 821932E4h case    2:*/		return 0x821932E8;
		  /* 821932E8h */ case    3:  		/* bc 12, CR6_EQ, 56 */
		/* 821932E8h case    3:*/		if ( regs.CR[6].eq ) { return 0x82193320;  }
		/* 821932E8h case    3:*/		return 0x821932EC;
		  /* 821932ECh */ case    4:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 821932ECh case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 821932ECh case    4:*/		return 0x821932F0;
		  /* 821932F0h */ case    5:  		/* lwz R9, <#[R25]> */
		/* 821932F0h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000000) );
		/* 821932F0h case    5:*/		return 0x821932F4;
		  /* 821932F4h */ case    6:  		/* addi R10, R25, -36 */
		/* 821932F4h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R25,0xFFFFFFDC);
		/* 821932F4h case    6:*/		return 0x821932F8;
		  /* 821932F8h */ case    7:  		/* addi R11, R11, 36 */
		/* 821932F8h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821932F8h case    7:*/		return 0x821932FC;
		  /* 821932FCh */ case    8:  		/* ori R8, R10, 1 */
		/* 821932FCh case    8:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 821932FCh case    8:*/		return 0x82193300;
		  /* 82193300h */ case    9:  		/* addi R7, R11, -36 */
		/* 82193300h case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 82193300h case    9:*/		return 0x82193304;
		  /* 82193304h */ case   10:  		/* addi R10, R11, 4 */
		/* 82193304h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82193304h case   10:*/		return 0x82193308;
		  /* 82193308h */ case   11:  		/* stw R9, <#[R11]> */
		/* 82193308h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82193308h case   11:*/		return 0x8219330C;
		  /* 8219330Ch */ case   12:  		/* lwz R9, <#[R25]> */
		/* 8219330Ch case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000000) );
		/* 8219330Ch case   12:*/		return 0x82193310;
		  /* 82193310h */ case   13:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82193310h case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82193310h case   13:*/		return 0x82193314;
		  /* 82193314h */ case   14:  		/* stw R7, <#[R9]> */
		/* 82193314h case   14:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 82193314h case   14:*/		return 0x82193318;
		  /* 82193318h */ case   15:  		/* stw R8, <#[R11 + 4]> */
		/* 82193318h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82193318h case   15:*/		return 0x8219331C;
		  /* 8219331Ch */ case   16:  		/* stw R10, <#[R25]> */
		/* 8219331Ch case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R25 + 0x00000000) );
		/* 8219331Ch case   16:*/		return 0x82193320;
	}
	return 0x82193320;
} // Block from 821932DCh-82193320h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82193320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193320);
		  /* 82193320h */ case    0:  		/* addi R1, R1, 240 */
		/* 82193320h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 82193320h case    0:*/		return 0x82193324;
		  /* 82193324h */ case    1:  		/* b -1056948 */
		/* 82193324h case    1:*/		return 0x82091270;
		/* 82193324h case    1:*/		return 0x82193328;
	}
	return 0x82193328;
} // Block from 82193320h-82193328h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82193328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193328);
		  /* 82193328h */ case    0:  		/* mfspr R12, LR */
		/* 82193328h case    0:*/		regs.R12 = regs.LR;
		/* 82193328h case    0:*/		return 0x8219332C;
		  /* 8219332Ch */ case    1:  		/* bl -1057036 */
		/* 8219332Ch case    1:*/		regs.LR = 0x82193330; return 0x82091220;
		/* 8219332Ch case    1:*/		return 0x82193330;
		  /* 82193330h */ case    2:  		/* stwu R1, <#[R1 - 256]> */
		/* 82193330h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 82193330h case    2:*/		return 0x82193334;
		  /* 82193334h */ case    3:  		/* lwz R18, <#[R4 + 44]> */
		/* 82193334h case    3:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R4 + 0x0000002C) );
		/* 82193334h case    3:*/		return 0x82193338;
		  /* 82193338h */ case    4:  		/* mr R31, R3 */
		/* 82193338h case    4:*/		regs.R31 = regs.R3;
		/* 82193338h case    4:*/		return 0x8219333C;
		  /* 8219333Ch */ case    5:  		/* lwz R21, <#[R4 + 48]> */
		/* 8219333Ch case    5:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R4 + 0x00000030) );
		/* 8219333Ch case    5:*/		return 0x82193340;
		  /* 82193340h */ case    6:  		/* mr R29, R4 */
		/* 82193340h case    6:*/		regs.R29 = regs.R4;
		/* 82193340h case    6:*/		return 0x82193344;
		  /* 82193344h */ case    7:  		/* lwz R11, <#[R3 + 44]> */
		/* 82193344h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 82193344h case    7:*/		return 0x82193348;
		  /* 82193348h */ case    8:  		/* mr R15, R5 */
		/* 82193348h case    8:*/		regs.R15 = regs.R5;
		/* 82193348h case    8:*/		return 0x8219334C;
		  /* 8219334Ch */ case    9:  		/* lwz R24, <#[R4 + 28]> */
		/* 8219334Ch case    9:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R4 + 0x0000001C) );
		/* 8219334Ch case    9:*/		return 0x82193350;
		  /* 82193350h */ case   10:  		/* mr R28, R6 */
		/* 82193350h case   10:*/		regs.R28 = regs.R6;
		/* 82193350h case   10:*/		return 0x82193354;
		  /* 82193354h */ case   11:  		/* mr R30, R7 */
		/* 82193354h case   11:*/		regs.R30 = regs.R7;
		/* 82193354h case   11:*/		return 0x82193358;
		  /* 82193358h */ case   12:  		/* lwz R10, <#[R18 + 12]> */
		/* 82193358h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R18 + 0x0000000C) );
		/* 82193358h case   12:*/		return 0x8219335C;
		  /* 8219335Ch */ case   13:  		/* li R22, 1 */
		/* 8219335Ch case   13:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 8219335Ch case   13:*/		return 0x82193360;
		  /* 82193360h */ case   14:  		/* lwz R16, <#[R21 + 12]> */
		/* 82193360h case   14:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R21 + 0x0000000C) );
		/* 82193360h case   14:*/		return 0x82193364;
		  /* 82193364h */ case   15:  		/* rlwinm. R11, R11, 25, 31, 31 */
		/* 82193364h case   15:*/		cpu::op::rlwinm<1,25,31,31>(regs,&regs.R11,regs.R11);
		/* 82193364h case   15:*/		return 0x82193368;
		  /* 82193368h */ case   16:  		/* stw R10, <#[R1 + 84]> */
		/* 82193368h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82193368h case   16:*/		return 0x8219336C;
		  /* 8219336Ch */ case   17:  		/* lwz R10, <#[R4 + 8]> */
		/* 8219336Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 8219336Ch case   17:*/		return 0x82193370;
		  /* 82193370h */ case   18:  		/* bc 12, CR0_EQ, 20 */
		/* 82193370h case   18:*/		if ( regs.CR[0].eq ) { return 0x82193384;  }
		/* 82193370h case   18:*/		return 0x82193374;
		  /* 82193374h */ case   19:  		/* rlwinm R11, R10, 18, 29, 31 */
		/* 82193374h case   19:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R10);
		/* 82193374h case   19:*/		return 0x82193378;
		  /* 82193378h */ case   20:  		/* slw R11, R22, R11 */
		/* 82193378h case   20:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R22,regs.R11);
		/* 82193378h case   20:*/		return 0x8219337C;
		  /* 8219337Ch */ case   21:  		/* addi R27, R11, -1 */
		/* 8219337Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFFFFFF);
		/* 8219337Ch case   21:*/		return 0x82193380;
		  /* 82193380h */ case   22:  		/* b 8 */
		/* 82193380h case   22:*/		return 0x82193388;
		/* 82193380h case   22:*/		return 0x82193384;
	}
	return 0x82193384;
} // Block from 82193328h-82193384h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82193384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193384);
		  /* 82193384h */ case    0:  		/* rlwinm R27, R10, 31, 28, 31 */
		/* 82193384h case    0:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R27,regs.R10);
		/* 82193384h case    0:*/		return 0x82193388;
	}
	return 0x82193388;
} // Block from 82193384h-82193388h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82193388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193388);
		  /* 82193388h */ case    0:  		/* li R25, 0 */
		/* 82193388h case    0:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82193388h case    0:*/		return 0x8219338C;
		  /* 8219338Ch */ case    1:  		/* cmplwi CR6, R27, 0 */
		/* 8219338Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8219338Ch case    1:*/		return 0x82193390;
		  /* 82193390h */ case    2:  		/* stw R25, <#[R1 + 80]> */
		/* 82193390h case    2:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000050) );
		/* 82193390h case    2:*/		return 0x82193394;
		  /* 82193394h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 82193394h case    3:*/		if ( regs.CR[6].eq ) { return 0x821933AC;  }
		/* 82193394h case    3:*/		return 0x82193398;
		  /* 82193398h */ case    4:  		/* addi R11, R27, -1 */
		/* 82193398h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0xFFFFFFFF);
		/* 82193398h case    4:*/		return 0x8219339C;
		  /* 8219339Ch */ case    5:  		/* andc R11, R27, R11 */
		/* 8219339Ch case    5:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R27,regs.R11);
		/* 8219339Ch case    5:*/		return 0x821933A0;
		  /* 821933A0h */ case    6:  		/* subf. R11, R11, R27 */
		/* 821933A0h case    6:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R11,regs.R27);
		/* 821933A0h case    6:*/		return 0x821933A4;
		  /* 821933A4h */ case    7:  		/* mr R11, R22 */
		/* 821933A4h case    7:*/		regs.R11 = regs.R22;
		/* 821933A4h case    7:*/		return 0x821933A8;
		  /* 821933A8h */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 821933A8h case    8:*/		if ( regs.CR[0].eq ) { return 0x821933B0;  }
		/* 821933A8h case    8:*/		return 0x821933AC;
	}
	return 0x821933AC;
} // Block from 82193388h-821933ACh (9 instructions)

//////////////////////////////////////////////////////
// Block at 821933ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821933AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821933AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821933AC);
		  /* 821933ACh */ case    0:  		/* li R11, 0 */
		/* 821933ACh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821933ACh case    0:*/		return 0x821933B0;
	}
	return 0x821933B0;
} // Block from 821933ACh-821933B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821933B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821933B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821933B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821933B0);
		  /* 821933B0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821933B0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821933B0h case    0:*/		return 0x821933B4;
		  /* 821933B4h */ case    1:  		/* bc 4, CR0_EQ, 76 */
		/* 821933B4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82193400;  }
		/* 821933B4h case    1:*/		return 0x821933B8;
		  /* 821933B8h */ case    2:  		/* rlwinm. R11, R10, 27, 31, 31 */
		/* 821933B8h case    2:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R10);
		/* 821933B8h case    2:*/		return 0x821933BC;
		  /* 821933BCh */ case    3:  		/* bc 4, CR0_EQ, 68 */
		/* 821933BCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x82193400;  }
		/* 821933BCh case    3:*/		return 0x821933C0;
		  /* 821933C0h */ case    4:  		/* lis R11, -28311 */
		/* 821933C0h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF9169);
		/* 821933C0h case    4:*/		return 0x821933C4;
		  /* 821933C4h */ case    5:  		/* lis R10, 0 */
		/* 821933C4h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 821933C4h case    5:*/		return 0x821933C8;
		  /* 821933C8h */ case    6:  		/* ori R11, R11, 5192 */
		/* 821933C8h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1448);
		/* 821933C8h case    6:*/		return 0x821933CC;
		  /* 821933CCh */ case    7:  		/* ori R10, R10, 36262 */
		/* 821933CCh case    7:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8DA6);
		/* 821933CCh case    7:*/		return 0x821933D0;
		  /* 821933D0h */ case    8:  		/* rldicl R9, R27, 0, 32 */
		/* 821933D0h case    8:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R27);
		/* 821933D0h case    8:*/		return 0x821933D4;
		  /* 821933D4h */ case    9:  		/* rldimi R11, R10, 32, 0 */
		/* 821933D4h case    9:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R11,regs.R10);
		/* 821933D4h case    9:*/		return 0x821933D8;
		  /* 821933D8h */ case   10:  		/* li R5, 0 */
		/* 821933D8h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821933D8h case   10:*/		return 0x821933DC;
		  /* 821933DCh */ case   11:  		/* srd R11, R11, R9 */
		/* 821933DCh case   11:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821933DCh case   11:*/		return 0x821933E0;
		  /* 821933E0h */ case   12:  		/* srd R11, R11, R9 */
		/* 821933E0h case   12:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821933E0h case   12:*/		return 0x821933E4;
		  /* 821933E4h */ case   13:  		/* srd R11, R11, R9 */
		/* 821933E4h case   13:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821933E4h case   13:*/		return 0x821933E8;
		  /* 821933E8h */ case   14:  		/* mr R4, R24 */
		/* 821933E8h case   14:*/		regs.R4 = regs.R24;
		/* 821933E8h case   14:*/		return 0x821933EC;
		  /* 821933ECh */ case   15:  		/* rlwinm R6, R11, 0, 29, 31 */
		/* 821933ECh case   15:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R6,regs.R11);
		/* 821933ECh case   15:*/		return 0x821933F0;
		  /* 821933F0h */ case   16:  		/* mr R3, R31 */
		/* 821933F0h case   16:*/		regs.R3 = regs.R31;
		/* 821933F0h case   16:*/		return 0x821933F4;
		  /* 821933F4h */ case   17:  		/* bl 595724 */
		/* 821933F4h case   17:*/		regs.LR = 0x821933F8; return 0x82224B00;
		/* 821933F4h case   17:*/		return 0x821933F8;
		  /* 821933F8h */ case   18:  		/* mr R25, R3 */
		/* 821933F8h case   18:*/		regs.R25 = regs.R3;
		/* 821933F8h case   18:*/		return 0x821933FC;
		  /* 821933FCh */ case   19:  		/* stw R3, <#[R1 + 80]> */
		/* 821933FCh case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 821933FCh case   19:*/		return 0x82193400;
	}
	return 0x82193400;
} // Block from 821933B0h-82193400h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82193400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193400);
		  /* 82193400h */ case    0:  		/* li R19, 0 */
		/* 82193400h case    0:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 82193400h case    0:*/		return 0x82193404;
		  /* 82193404h */ case    1:  		/* cmplwi CR6, R27, 0 */
		/* 82193404h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82193404h case    1:*/		return 0x82193408;
		  /* 82193408h */ case    2:  		/* bc 12, CR6_EQ, 724 */
		/* 82193408h case    2:*/		if ( regs.CR[6].eq ) { return 0x821936DC;  }
		/* 82193408h case    2:*/		return 0x8219340C;
		  /* 8219340Ch */ case    3:  		/* addi R11, R28, -36 */
		/* 8219340Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0xFFFFFFDC);
		/* 8219340Ch case    3:*/		return 0x82193410;
		  /* 82193410h */ case    4:  		/* rlwinm R20, R30, 0, 24, 31 */
		/* 82193410h case    4:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R20,regs.R30);
		/* 82193410h case    4:*/		return 0x82193414;
		  /* 82193414h */ case    5:  		/* ori R17, R11, 1 */
		/* 82193414h case    5:*/		cpu::op::ori<0>(regs,&regs.R17,regs.R11,0x1);
		/* 82193414h case    5:*/		return 0x82193418;
		  /* 82193418h */ case    6:  		/* addi R11, R27, -1 */
		/* 82193418h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0xFFFFFFFF);
		/* 82193418h case    6:*/		return 0x8219341C;
		  /* 8219341Ch */ case    7:  		/* li R8, 1 */
		/* 8219341Ch case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8219341Ch case    7:*/		return 0x82193420;
		  /* 82193420h */ case    8:  		/* andc R11, R27, R11 */
		/* 82193420h case    8:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R27,regs.R11);
		/* 82193420h case    8:*/		return 0x82193424;
		  /* 82193424h */ case    9:  		/* li R7, 1 */
		/* 82193424h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82193424h case    9:*/		return 0x82193428;
		  /* 82193428h */ case   10:  		/* cntlzw R10, R11 */
		/* 82193428h case   10:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R11);
		/* 82193428h case   10:*/		return 0x8219342C;
		  /* 8219342Ch */ case   11:  		/* mr R6, R15 */
		/* 8219342Ch case   11:*/		regs.R6 = regs.R15;
		/* 8219342Ch case   11:*/		return 0x82193430;
		  /* 82193430h */ case   12:  		/* li R5, 0 */
		/* 82193430h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82193430h case   12:*/		return 0x82193434;
		  /* 82193434h */ case   13:  		/* mr R4, R24 */
		/* 82193434h case   13:*/		regs.R4 = regs.R24;
		/* 82193434h case   13:*/		return 0x82193438;
		  /* 82193438h */ case   14:  		/* mr R3, R31 */
		/* 82193438h case   14:*/		regs.R3 = regs.R31;
		/* 82193438h case   14:*/		return 0x8219343C;
		  /* 8219343Ch */ case   15:  		/* subf R27, R11, R27 */
		/* 8219343Ch case   15:*/		cpu::op::subf<0>(regs,&regs.R27,regs.R11,regs.R27);
		/* 8219343Ch case   15:*/		return 0x82193440;
		  /* 82193440h */ case   16:  		/* subfic R23, R10, 31 */
		/* 82193440h case   16:*/		cpu::op::subfic<0>(regs,&regs.R23,regs.R10,0x1F);
		/* 82193440h case   16:*/		return 0x82193444;
		  /* 82193444h */ case   17:  		/* bl 595284 */
		/* 82193444h case   17:*/		regs.LR = 0x82193448; return 0x82224998;
		/* 82193444h case   17:*/		return 0x82193448;
		  /* 82193448h */ case   18:  		/* lwz R11, <#[R18]> */
		/* 82193448h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 82193448h case   18:*/		return 0x8219344C;
		  /* 8219344Ch */ case   19:  		/* rlwinm R25, R23, 1, 0, 30 */
		/* 8219344Ch case   19:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R25,regs.R23);
		/* 8219344Ch case   19:*/		return 0x82193450;
		  /* 82193450h */ case   20:  		/* mr R26, R3 */
		/* 82193450h case   20:*/		regs.R26 = regs.R3;
		/* 82193450h case   20:*/		return 0x82193454;
		  /* 82193454h */ case   21:  		/* lwz R4, <#[R1 + 84]> */
		/* 82193454h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 82193454h case   21:*/		return 0x82193458;
		  /* 82193458h */ case   22:  		/* rlwinm R10, R11, 27, 24, 31 */
		/* 82193458h case   22:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R11);
		/* 82193458h case   22:*/		return 0x8219345C;
		  /* 8219345Ch */ case   23:  		/* mr R3, R31 */
		/* 8219345Ch case   23:*/		regs.R3 = regs.R31;
		/* 8219345Ch case   23:*/		return 0x82193460;
		  /* 82193460h */ case   24:  		/* srw R10, R10, R25 */
		/* 82193460h case   24:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R25);
		/* 82193460h case   24:*/		return 0x82193464;
		  /* 82193464h */ case   25:  		/* rlwinm R30, R10, 0, 30, 31 */
		/* 82193464h case   25:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R30,regs.R10);
		/* 82193464h case   25:*/		return 0x82193468;
		  /* 82193468h */ case   26:  		/* rlwinm R14, R11, 0, 27, 31 */
		/* 82193468h case   26:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R14,regs.R11);
		/* 82193468h case   26:*/		return 0x8219346C;
		  /* 8219346Ch */ case   27:  		/* bl -111724 */
		/* 8219346Ch case   27:*/		regs.LR = 0x82193470; return 0x82178000;
		/* 8219346Ch case   27:*/		return 0x82193470;
		  /* 82193470h */ case   28:  		/* lwz R10, <#[R3]> */
		/* 82193470h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82193470h case   28:*/		return 0x82193474;
		  /* 82193474h */ case   29:  		/* mr R4, R14 */
		/* 82193474h case   29:*/		regs.R4 = regs.R14;
		/* 82193474h case   29:*/		return 0x82193478;
		  /* 82193478h */ case   30:  		/* mr R11, R3 */
		/* 82193478h case   30:*/		regs.R11 = regs.R3;
		/* 82193478h case   30:*/		return 0x8219347C;
		  /* 8219347Ch */ case   31:  		/* stw R3, <#[R1 + 88]> */
		/* 8219347Ch case   31:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000058) );
		/* 8219347Ch case   31:*/		return 0x82193480;
		  /* 82193480h */ case   32:  		/* rlwimi R10, R22, 26, 4, 6 */
		/* 82193480h case   32:*/		cpu::op::rlwimi<0,26,4,6>(regs,&regs.R10,regs.R22);
		/* 82193480h case   32:*/		return 0x82193484;
		  /* 82193484h */ case   33:  		/* stw R10, <#[R3]> */
		/* 82193484h case   33:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82193484h case   33:*/		return 0x82193488;
		  /* 82193488h */ case   34:  		/* bl -113096 */
		/* 82193488h case   34:*/		regs.LR = 0x8219348C; return 0x82177AC0;
		/* 82193488h case   34:*/		return 0x8219348C;
		  /* 8219348Ch */ case   35:  		/* li R11, 224 */
		/* 8219348Ch case   35:*/		cpu::op::li<0>(regs,&regs.R11,0xE0);
		/* 8219348Ch case   35:*/		return 0x82193490;
		  /* 82193490h */ case   36:  		/* mr R5, R28 */
		/* 82193490h case   36:*/		regs.R5 = regs.R28;
		/* 82193490h case   36:*/		return 0x82193494;
		  /* 82193494h */ case   37:  		/* rlwimi R11, R30, 2, 27, 29 */
		/* 82193494h case   37:*/		cpu::op::rlwimi<0,2,27,29>(regs,&regs.R11,regs.R30);
		/* 82193494h case   37:*/		return 0x82193498;
		  /* 82193498h */ case   38:  		/* mr R4, R24 */
		/* 82193498h case   38:*/		regs.R4 = regs.R24;
		/* 82193498h case   38:*/		return 0x8219349C;
		  /* 8219349Ch */ case   39:  		/* or R11, R11, R30 */
		/* 8219349Ch case   39:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8219349Ch case   39:*/		return 0x821934A0;
		  /* 821934A0h */ case   40:  		/* lwz R30, <#[R1 + 88]> */
		/* 821934A0h case   40:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000058) );
		/* 821934A0h case   40:*/		return 0x821934A4;
		  /* 821934A4h */ case   41:  		/* mr R3, R31 */
		/* 821934A4h case   41:*/		regs.R3 = regs.R31;
		/* 821934A4h case   41:*/		return 0x821934A8;
		  /* 821934A8h */ case   42:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 821934A8h case   42:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 821934A8h case   42:*/		return 0x821934AC;
		  /* 821934ACh */ case   43:  		/* mr R6, R30 */
		/* 821934ACh case   43:*/		regs.R6 = regs.R30;
		/* 821934ACh case   43:*/		return 0x821934B0;
		  /* 821934B0h */ case   44:  		/* lwz R10, <#[R30]> */
		/* 821934B0h case   44:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 821934B0h case   44:*/		return 0x821934B4;
		  /* 821934B4h */ case   45:  		/* rlwinm R10, R10, 0, 27, 21 */
		/* 821934B4h case   45:*/		cpu::op::rlwinm<0,0,27,21>(regs,&regs.R10,regs.R10);
		/* 821934B4h case   45:*/		return 0x821934B8;
		  /* 821934B8h */ case   46:  		/* or R11, R11, R10 */
		/* 821934B8h case   46:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821934B8h case   46:*/		return 0x821934BC;
		  /* 821934BCh */ case   47:  		/* stw R11, <#[R30]> */
		/* 821934BCh case   47:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821934BCh case   47:*/		return 0x821934C0;
		  /* 821934C0h */ case   48:  		/* bl -6504 */
		/* 821934C0h case   48:*/		regs.LR = 0x821934C4; return 0x82191B58;
		/* 821934C0h case   48:*/		return 0x821934C4;
		  /* 821934C4h */ case   49:  		/* mr R30, R3 */
		/* 821934C4h case   49:*/		regs.R30 = regs.R3;
		/* 821934C4h case   49:*/		return 0x821934C8;
		  /* 821934C8h */ case   50:  		/* mr R4, R3 */
		/* 821934C8h case   50:*/		regs.R4 = regs.R3;
		/* 821934C8h case   50:*/		return 0x821934CC;
		  /* 821934CCh */ case   51:  		/* li R8, 4 */
		/* 821934CCh case   51:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821934CCh case   51:*/		return 0x821934D0;
		  /* 821934D0h */ case   52:  		/* li R7, 0 */
		/* 821934D0h case   52:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821934D0h case   52:*/		return 0x821934D4;
		  /* 821934D4h */ case   53:  		/* li R6, 0 */
		/* 821934D4h case   53:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821934D4h case   53:*/		return 0x821934D8;
		  /* 821934D8h */ case   54:  		/* mr R5, R29 */
		/* 821934D8h case   54:*/		regs.R5 = regs.R29;
		/* 821934D8h case   54:*/		return 0x821934DC;
		  /* 821934DCh */ case   55:  		/* mr R3, R31 */
		/* 821934DCh case   55:*/		regs.R3 = regs.R31;
		/* 821934DCh case   55:*/		return 0x821934E0;
		  /* 821934E0h */ case   56:  		/* bl -8968 */
		/* 821934E0h case   56:*/		regs.LR = 0x821934E4; return 0x821911D8;
		/* 821934E0h case   56:*/		return 0x821934E4;
		  /* 821934E4h */ case   57:  		/* lwz R11, <#[R21]> */
		/* 821934E4h case   57:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 821934E4h case   57:*/		return 0x821934E8;
		  /* 821934E8h */ case   58:  		/* cmplwi CR6, R20, 0 */
		/* 821934E8h case   58:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 821934E8h case   58:*/		return 0x821934EC;
		  /* 821934ECh */ case   59:  		/* rlwinm R10, R11, 27, 24, 31 */
		/* 821934ECh case   59:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R11);
		/* 821934ECh case   59:*/		return 0x821934F0;
		  /* 821934F0h */ case   60:  		/* mr R3, R31 */
		/* 821934F0h case   60:*/		regs.R3 = regs.R31;
		/* 821934F0h case   60:*/		return 0x821934F4;
		  /* 821934F4h */ case   61:  		/* srw R10, R10, R25 */
		/* 821934F4h case   61:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R25);
		/* 821934F4h case   61:*/		return 0x821934F8;
		  /* 821934F8h */ case   62:  		/* rlwinm R25, R10, 0, 30, 31 */
		/* 821934F8h case   62:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R25,regs.R10);
		/* 821934F8h case   62:*/		return 0x821934FC;
		  /* 821934FCh */ case   63:  		/* bc 12, CR6_EQ, 60 */
		/* 821934FCh case   63:*/		if ( regs.CR[6].eq ) { return 0x82193538;  }
		/* 821934FCh case   63:*/		return 0x82193500;
		  /* 82193500h */ case   64:  		/* li R5, 6 */
		/* 82193500h case   64:*/		cpu::op::li<0>(regs,&regs.R5,0x6);
		/* 82193500h case   64:*/		return 0x82193504;
		  /* 82193504h */ case   65:  		/* mr R4, R30 */
		/* 82193504h case   65:*/		regs.R4 = regs.R30;
		/* 82193504h case   65:*/		return 0x82193508;
		  /* 82193508h */ case   66:  		/* bl -142776 */
		/* 82193508h case   66:*/		regs.LR = 0x8219350C; return 0x82170750;
		/* 82193508h case   66:*/		return 0x8219350C;
		  /* 8219350Ch */ case   67:  		/* mr R4, R3 */
		/* 8219350Ch case   67:*/		regs.R4 = regs.R3;
		/* 8219350Ch case   67:*/		return 0x82193510;
		  /* 82193510h */ case   68:  		/* mr R3, R26 */
		/* 82193510h case   68:*/		regs.R3 = regs.R26;
		/* 82193510h case   68:*/		return 0x82193514;
		  /* 82193514h */ case   69:  		/* bl -111436 */
		/* 82193514h case   69:*/		regs.LR = 0x82193518; return 0x821781C8;
		/* 82193514h case   69:*/		return 0x82193518;
		  /* 82193518h */ case   70:  		/* lwz R11, <#[R21]> */
		/* 82193518h case   70:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 82193518h case   70:*/		return 0x8219351C;
		  /* 8219351Ch */ case   71:  		/* mr R5, R25 */
		/* 8219351Ch case   71:*/		regs.R5 = regs.R25;
		/* 8219351Ch case   71:*/		return 0x82193520;
		  /* 82193520h */ case   72:  		/* mr R4, R16 */
		/* 82193520h case   72:*/		regs.R4 = regs.R16;
		/* 82193520h case   72:*/		return 0x82193524;
		  /* 82193524h */ case   73:  		/* mr R3, R31 */
		/* 82193524h case   73:*/		regs.R3 = regs.R31;
		/* 82193524h case   73:*/		return 0x82193528;
		  /* 82193528h */ case   74:  		/* rlwinm R6, R11, 0, 27, 31 */
		/* 82193528h case   74:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R6,regs.R11);
		/* 82193528h case   74:*/		return 0x8219352C;
		  /* 8219352Ch */ case   75:  		/* bl -111556 */
		/* 8219352Ch case   75:*/		regs.LR = 0x82193530; return 0x82178168;
		/* 8219352Ch case   75:*/		return 0x82193530;
		  /* 82193530h */ case   76:  		/* mr R4, R3 */
		/* 82193530h case   76:*/		regs.R4 = regs.R3;
		/* 82193530h case   76:*/		return 0x82193534;
		  /* 82193534h */ case   77:  		/* b 272 */
		/* 82193534h case   77:*/		return 0x82193644;
		/* 82193534h case   77:*/		return 0x82193538;
	}
	return 0x82193538;
} // Block from 82193400h-82193538h (78 instructions)

//////////////////////////////////////////////////////
// Block at 82193538h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193538);
		  /* 82193538h */ case    0:  		/* mr R4, R16 */
		/* 82193538h case    0:*/		regs.R4 = regs.R16;
		/* 82193538h case    0:*/		return 0x8219353C;
		  /* 8219353Ch */ case    1:  		/* rlwinm R14, R11, 0, 27, 31 */
		/* 8219353Ch case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R14,regs.R11);
		/* 8219353Ch case    1:*/		return 0x82193540;
		  /* 82193540h */ case    2:  		/* bl -111936 */
		/* 82193540h case    2:*/		regs.LR = 0x82193544; return 0x82178000;
		/* 82193540h case    2:*/		return 0x82193544;
		  /* 82193544h */ case    3:  		/* lwz R10, <#[R3]> */
		/* 82193544h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82193544h case    3:*/		return 0x82193548;
		  /* 82193548h */ case    4:  		/* mr R4, R14 */
		/* 82193548h case    4:*/		regs.R4 = regs.R14;
		/* 82193548h case    4:*/		return 0x8219354C;
		  /* 8219354Ch */ case    5:  		/* stw R3, <#[R1 + 88]> */
		/* 8219354Ch case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000058) );
		/* 8219354Ch case    5:*/		return 0x82193550;
		  /* 82193550h */ case    6:  		/* rlwimi R10, R22, 26, 4, 6 */
		/* 82193550h case    6:*/		cpu::op::rlwimi<0,26,4,6>(regs,&regs.R10,regs.R22);
		/* 82193550h case    6:*/		return 0x82193554;
		  /* 82193554h */ case    7:  		/* mr R11, R3 */
		/* 82193554h case    7:*/		regs.R11 = regs.R3;
		/* 82193554h case    7:*/		return 0x82193558;
		  /* 82193558h */ case    8:  		/* stw R10, <#[R3]> */
		/* 82193558h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82193558h case    8:*/		return 0x8219355C;
		  /* 8219355Ch */ case    9:  		/* bl -113308 */
		/* 8219355Ch case    9:*/		regs.LR = 0x82193560; return 0x82177AC0;
		/* 8219355Ch case    9:*/		return 0x82193560;
		  /* 82193560h */ case   10:  		/* li R11, 224 */
		/* 82193560h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0xE0);
		/* 82193560h case   10:*/		return 0x82193564;
		  /* 82193564h */ case   11:  		/* lwz R14, <#[R1 + 88]> */
		/* 82193564h case   11:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R1 + 0x00000058) );
		/* 82193564h case   11:*/		return 0x82193568;
		  /* 82193568h */ case   12:  		/* rlwinm R10, R25, 0, 27, 31 */
		/* 82193568h case   12:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R25);
		/* 82193568h case   12:*/		return 0x8219356C;
		  /* 8219356Ch */ case   13:  		/* rlwimi R11, R25, 2, 27, 29 */
		/* 8219356Ch case   13:*/		cpu::op::rlwimi<0,2,27,29>(regs,&regs.R11,regs.R25);
		/* 8219356Ch case   13:*/		return 0x82193570;
		  /* 82193570h */ case   14:  		/* mr R5, R28 */
		/* 82193570h case   14:*/		regs.R5 = regs.R28;
		/* 82193570h case   14:*/		return 0x82193574;
		  /* 82193574h */ case   15:  		/* or R11, R11, R10 */
		/* 82193574h case   15:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82193574h case   15:*/		return 0x82193578;
		  /* 82193578h */ case   16:  		/* mr R4, R24 */
		/* 82193578h case   16:*/		regs.R4 = regs.R24;
		/* 82193578h case   16:*/		return 0x8219357C;
		  /* 8219357Ch */ case   17:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 8219357Ch case   17:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 8219357Ch case   17:*/		return 0x82193580;
		  /* 82193580h */ case   18:  		/* mr R3, R31 */
		/* 82193580h case   18:*/		regs.R3 = regs.R31;
		/* 82193580h case   18:*/		return 0x82193584;
		  /* 82193584h */ case   19:  		/* mr R6, R14 */
		/* 82193584h case   19:*/		regs.R6 = regs.R14;
		/* 82193584h case   19:*/		return 0x82193588;
		  /* 82193588h */ case   20:  		/* lwz R10, <#[R14]> */
		/* 82193588h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000000) );
		/* 82193588h case   20:*/		return 0x8219358C;
		  /* 8219358Ch */ case   21:  		/* rlwinm R10, R10, 0, 27, 21 */
		/* 8219358Ch case   21:*/		cpu::op::rlwinm<0,0,27,21>(regs,&regs.R10,regs.R10);
		/* 8219358Ch case   21:*/		return 0x82193590;
		  /* 82193590h */ case   22:  		/* or R11, R11, R10 */
		/* 82193590h case   22:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82193590h case   22:*/		return 0x82193594;
		  /* 82193594h */ case   23:  		/* stw R11, <#[R14]> */
		/* 82193594h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R14 + 0x00000000) );
		/* 82193594h case   23:*/		return 0x82193598;
		  /* 82193598h */ case   24:  		/* bl -6720 */
		/* 82193598h case   24:*/		regs.LR = 0x8219359C; return 0x82191B58;
		/* 82193598h case   24:*/		return 0x8219359C;
		  /* 8219359Ch */ case   25:  		/* mr R25, R3 */
		/* 8219359Ch case   25:*/		regs.R25 = regs.R3;
		/* 8219359Ch case   25:*/		return 0x821935A0;
		  /* 821935A0h */ case   26:  		/* mr R4, R3 */
		/* 821935A0h case   26:*/		regs.R4 = regs.R3;
		/* 821935A0h case   26:*/		return 0x821935A4;
		  /* 821935A4h */ case   27:  		/* li R8, 4 */
		/* 821935A4h case   27:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821935A4h case   27:*/		return 0x821935A8;
		  /* 821935A8h */ case   28:  		/* li R7, 0 */
		/* 821935A8h case   28:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821935A8h case   28:*/		return 0x821935AC;
		  /* 821935ACh */ case   29:  		/* li R6, 0 */
		/* 821935ACh case   29:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821935ACh case   29:*/		return 0x821935B0;
		  /* 821935B0h */ case   30:  		/* mr R5, R29 */
		/* 821935B0h case   30:*/		regs.R5 = regs.R29;
		/* 821935B0h case   30:*/		return 0x821935B4;
		  /* 821935B4h */ case   31:  		/* mr R3, R31 */
		/* 821935B4h case   31:*/		regs.R3 = regs.R31;
		/* 821935B4h case   31:*/		return 0x821935B8;
		  /* 821935B8h */ case   32:  		/* bl -9184 */
		/* 821935B8h case   32:*/		regs.LR = 0x821935BC; return 0x821911D8;
		/* 821935B8h case   32:*/		return 0x821935BC;
		  /* 821935BCh */ case   33:  		/* li R6, 2 */
		/* 821935BCh case   33:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 821935BCh case   33:*/		return 0x821935C0;
		  /* 821935C0h */ case   34:  		/* mr R5, R28 */
		/* 821935C0h case   34:*/		regs.R5 = regs.R28;
		/* 821935C0h case   34:*/		return 0x821935C4;
		  /* 821935C4h */ case   35:  		/* mr R4, R24 */
		/* 821935C4h case   35:*/		regs.R4 = regs.R24;
		/* 821935C4h case   35:*/		return 0x821935C8;
		  /* 821935C8h */ case   36:  		/* mr R3, R31 */
		/* 821935C8h case   36:*/		regs.R3 = regs.R31;
		/* 821935C8h case   36:*/		return 0x821935CC;
		  /* 821935CCh */ case   37:  		/* bl 595252 */
		/* 821935CCh case   37:*/		regs.LR = 0x821935D0; return 0x82224B00;
		/* 821935CCh case   37:*/		return 0x821935D0;
		  /* 821935D0h */ case   38:  		/* mr R14, R3 */
		/* 821935D0h case   38:*/		regs.R14 = regs.R3;
		/* 821935D0h case   38:*/		return 0x821935D4;
		  /* 821935D4h */ case   39:  		/* mr R4, R30 */
		/* 821935D4h case   39:*/		regs.R4 = regs.R30;
		/* 821935D4h case   39:*/		return 0x821935D8;
		  /* 821935D8h */ case   40:  		/* mr R3, R31 */
		/* 821935D8h case   40:*/		regs.R3 = regs.R31;
		/* 821935D8h case   40:*/		return 0x821935DC;
		  /* 821935DCh */ case   41:  		/* bl -112092 */
		/* 821935DCh case   41:*/		regs.LR = 0x821935E0; return 0x82178000;
		/* 821935DCh case   41:*/		return 0x821935E0;
		  /* 821935E0h */ case   42:  		/* mr R4, R3 */
		/* 821935E0h case   42:*/		regs.R4 = regs.R3;
		/* 821935E0h case   42:*/		return 0x821935E4;
		  /* 821935E4h */ case   43:  		/* mr R3, R14 */
		/* 821935E4h case   43:*/		regs.R3 = regs.R14;
		/* 821935E4h case   43:*/		return 0x821935E8;
		  /* 821935E8h */ case   44:  		/* bl -111648 */
		/* 821935E8h case   44:*/		regs.LR = 0x821935EC; return 0x821781C8;
		/* 821935E8h case   44:*/		return 0x821935EC;
		  /* 821935ECh */ case   45:  		/* stw R3, <#[R14 + 44]> */
		/* 821935ECh case   45:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R14 + 0x0000002C) );
		/* 821935ECh case   45:*/		return 0x821935F0;
		  /* 821935F0h */ case   46:  		/* mr R4, R25 */
		/* 821935F0h case   46:*/		regs.R4 = regs.R25;
		/* 821935F0h case   46:*/		return 0x821935F4;
		  /* 821935F4h */ case   47:  		/* mr R3, R31 */
		/* 821935F4h case   47:*/		regs.R3 = regs.R31;
		/* 821935F4h case   47:*/		return 0x821935F8;
		  /* 821935F8h */ case   48:  		/* bl -112120 */
		/* 821935F8h case   48:*/		regs.LR = 0x821935FC; return 0x82178000;
		/* 821935F8h case   48:*/		return 0x821935FC;
		  /* 821935FCh */ case   49:  		/* mr R4, R3 */
		/* 821935FCh case   49:*/		regs.R4 = regs.R3;
		/* 821935FCh case   49:*/		return 0x82193600;
		  /* 82193600h */ case   50:  		/* mr R3, R14 */
		/* 82193600h case   50:*/		regs.R3 = regs.R14;
		/* 82193600h case   50:*/		return 0x82193604;
		  /* 82193604h */ case   51:  		/* bl -111676 */
		/* 82193604h case   51:*/		regs.LR = 0x82193608; return 0x821781C8;
		/* 82193604h case   51:*/		return 0x82193608;
		  /* 82193608h */ case   52:  		/* stw R3, <#[R14 + 48]> */
		/* 82193608h case   52:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R14 + 0x00000030) );
		/* 82193608h case   52:*/		return 0x8219360C;
		  /* 8219360Ch */ case   53:  		/* mr R4, R14 */
		/* 8219360Ch case   53:*/		regs.R4 = regs.R14;
		/* 8219360Ch case   53:*/		return 0x82193610;
		  /* 82193610h */ case   54:  		/* mr R3, R31 */
		/* 82193610h case   54:*/		regs.R3 = regs.R31;
		/* 82193610h case   54:*/		return 0x82193614;
		  /* 82193614h */ case   55:  		/* bl -112148 */
		/* 82193614h case   55:*/		regs.LR = 0x82193618; return 0x82178000;
		/* 82193614h case   55:*/		return 0x82193618;
		  /* 82193618h */ case   56:  		/* lwz R11, <#[R3]> */
		/* 82193618h case   56:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82193618h case   56:*/		return 0x8219361C;
		  /* 8219361Ch */ case   57:  		/* li R4, 0 */
		/* 8219361Ch case   57:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8219361Ch case   57:*/		return 0x82193620;
		  /* 82193620h */ case   58:  		/* rlwimi R11, R22, 26, 4, 6 */
		/* 82193620h case   58:*/		cpu::op::rlwimi<0,26,4,6>(regs,&regs.R11,regs.R22);
		/* 82193620h case   58:*/		return 0x82193624;
		  /* 82193624h */ case   59:  		/* mr R30, R3 */
		/* 82193624h case   59:*/		regs.R30 = regs.R3;
		/* 82193624h case   59:*/		return 0x82193628;
		  /* 82193628h */ case   60:  		/* stw R11, <#[R3]> */
		/* 82193628h case   60:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82193628h case   60:*/		return 0x8219362C;
		  /* 8219362Ch */ case   61:  		/* bl -113516 */
		/* 8219362Ch case   61:*/		regs.LR = 0x82193630; return 0x82177AC0;
		/* 8219362Ch case   61:*/		return 0x82193630;
		  /* 82193630h */ case   62:  		/* lwz R10, <#[R30]> */
		/* 82193630h case   62:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82193630h case   62:*/		return 0x82193634;
		  /* 82193634h */ case   63:  		/* li R11, 57 */
		/* 82193634h case   63:*/		cpu::op::li<0>(regs,&regs.R11,0x39);
		/* 82193634h case   63:*/		return 0x82193638;
		  /* 82193638h */ case   64:  		/* mr R4, R30 */
		/* 82193638h case   64:*/		regs.R4 = regs.R30;
		/* 82193638h case   64:*/		return 0x8219363C;
		  /* 8219363Ch */ case   65:  		/* rlwimi R10, R11, 7, 19, 26 */
		/* 8219363Ch case   65:*/		cpu::op::rlwimi<0,7,19,26>(regs,&regs.R10,regs.R11);
		/* 8219363Ch case   65:*/		return 0x82193640;
		  /* 82193640h */ case   66:  		/* stw R10, <#[R30]> */
		/* 82193640h case   66:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82193640h case   66:*/		return 0x82193644;
	}
	return 0x82193644;
} // Block from 82193538h-82193644h (67 instructions)

//////////////////////////////////////////////////////
// Block at 82193644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193644);
		  /* 82193644h */ case    0:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 82193644h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 82193644h case    0:*/		return 0x82193648;
		  /* 82193648h */ case    1:  		/* lwz R9, <#[R28]> */
		/* 82193648h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000000) );
		/* 82193648h case    1:*/		return 0x8219364C;
		  /* 8219364Ch */ case    2:  		/* mr R3, R26 */
		/* 8219364Ch case    2:*/		regs.R3 = regs.R26;
		/* 8219364Ch case    2:*/		return 0x82193650;
		  /* 82193650h */ case    3:  		/* addi R11, R11, 36 */
		/* 82193650h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82193650h case    3:*/		return 0x82193654;
		  /* 82193654h */ case    4:  		/* addi R8, R11, -36 */
		/* 82193654h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 82193654h case    4:*/		return 0x82193658;
		  /* 82193658h */ case    5:  		/* addi R10, R11, 4 */
		/* 82193658h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82193658h case    5:*/		return 0x8219365C;
		  /* 8219365Ch */ case    6:  		/* stw R9, <#[R11]> */
		/* 8219365Ch case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8219365Ch case    6:*/		return 0x82193660;
		  /* 82193660h */ case    7:  		/* lwz R9, <#[R28]> */
		/* 82193660h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000000) );
		/* 82193660h case    7:*/		return 0x82193664;
		  /* 82193664h */ case    8:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82193664h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82193664h case    8:*/		return 0x82193668;
		  /* 82193668h */ case    9:  		/* stw R8, <#[R9]> */
		/* 82193668h case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 82193668h case    9:*/		return 0x8219366C;
		  /* 8219366Ch */ case   10:  		/* stw R17, <#[R11 + 4]> */
		/* 8219366Ch case   10:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R11 + 0x00000004) );
		/* 8219366Ch case   10:*/		return 0x82193670;
		  /* 82193670h */ case   11:  		/* stw R10, <#[R28]> */
		/* 82193670h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 82193670h case   11:*/		return 0x82193674;
		  /* 82193674h */ case   12:  		/* bl -111788 */
		/* 82193674h case   12:*/		regs.LR = 0x82193678; return 0x821781C8;
		/* 82193674h case   12:*/		return 0x82193678;
		  /* 82193678h */ case   13:  		/* stw R3, <#[R26 + 44]> */
		/* 82193678h case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R26 + 0x0000002C) );
		/* 82193678h case   13:*/		return 0x8219367C;
		  /* 8219367Ch */ case   14:  		/* lwz R11, <#[R29 + 8]> */
		/* 8219367Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8219367Ch case   14:*/		return 0x82193680;
		  /* 82193680h */ case   15:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82193680h case   15:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82193680h case   15:*/		return 0x82193684;
		  /* 82193684h */ case   16:  		/* bc 12, CR0_EQ, 16 */
		/* 82193684h case   16:*/		if ( regs.CR[0].eq ) { return 0x82193694;  }
		/* 82193684h case   16:*/		return 0x82193688;
		  /* 82193688h */ case   17:  		/* lwz R11, <#[R26 + 8]> */
		/* 82193688h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82193688h case   17:*/		return 0x8219368C;
		  /* 8219368Ch */ case   18:  		/* ori R11, R11, 1 */
		/* 8219368Ch case   18:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219368Ch case   18:*/		return 0x82193690;
		  /* 82193690h */ case   19:  		/* stw R11, <#[R26 + 8]> */
		/* 82193690h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82193690h case   19:*/		return 0x82193694;
	}
	return 0x82193694;
} // Block from 82193644h-82193694h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82193694h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193694( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193694) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193694);
		  /* 82193694h */ case    0:  		/* mr R4, R23 */
		/* 82193694h case    0:*/		regs.R4 = regs.R23;
		/* 82193694h case    0:*/		return 0x82193698;
		  /* 82193698h */ case    1:  		/* mr R3, R29 */
		/* 82193698h case    1:*/		regs.R3 = regs.R29;
		/* 82193698h case    1:*/		return 0x8219369C;
		  /* 8219369Ch */ case    2:  		/* bl 170444 */
		/* 8219369Ch case    2:*/		regs.LR = 0x821936A0; return 0x821BD068;
		/* 8219369Ch case    2:*/		return 0x821936A0;
		  /* 821936A0h */ case    3:  		/* mr R5, R3 */
		/* 821936A0h case    3:*/		regs.R5 = regs.R3;
		/* 821936A0h case    3:*/		return 0x821936A4;
		  /* 821936A4h */ case    4:  		/* li R4, 0 */
		/* 821936A4h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821936A4h case    4:*/		return 0x821936A8;
		  /* 821936A8h */ case    5:  		/* mr R3, R26 */
		/* 821936A8h case    5:*/		regs.R3 = regs.R26;
		/* 821936A8h case    5:*/		return 0x821936AC;
		  /* 821936ACh */ case    6:  		/* bl 170588 */
		/* 821936ACh case    6:*/		regs.LR = 0x821936B0; return 0x821BD108;
		/* 821936ACh case    6:*/		return 0x821936B0;
		  /* 821936B0h */ case    7:  		/* lwz R25, <#[R1 + 80]> */
		/* 821936B0h case    7:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000050) );
		/* 821936B0h case    7:*/		return 0x821936B4;
		  /* 821936B4h */ case    8:  		/* mr R8, R23 */
		/* 821936B4h case    8:*/		regs.R8 = regs.R23;
		/* 821936B4h case    8:*/		return 0x821936B8;
		  /* 821936B8h */ case    9:  		/* mr R7, R19 */
		/* 821936B8h case    9:*/		regs.R7 = regs.R19;
		/* 821936B8h case    9:*/		return 0x821936BC;
		  /* 821936BCh */ case   10:  		/* mr R6, R25 */
		/* 821936BCh case   10:*/		regs.R6 = regs.R25;
		/* 821936BCh case   10:*/		return 0x821936C0;
		  /* 821936C0h */ case   11:  		/* mr R5, R29 */
		/* 821936C0h case   11:*/		regs.R5 = regs.R29;
		/* 821936C0h case   11:*/		return 0x821936C4;
		  /* 821936C4h */ case   12:  		/* mr R4, R26 */
		/* 821936C4h case   12:*/		regs.R4 = regs.R26;
		/* 821936C4h case   12:*/		return 0x821936C8;
		  /* 821936C8h */ case   13:  		/* mr R3, R31 */
		/* 821936C8h case   13:*/		regs.R3 = regs.R31;
		/* 821936C8h case   13:*/		return 0x821936CC;
		  /* 821936CCh */ case   14:  		/* bl -9460 */
		/* 821936CCh case   14:*/		regs.LR = 0x821936D0; return 0x821911D8;
		/* 821936CCh case   14:*/		return 0x821936D0;
		  /* 821936D0h */ case   15:  		/* addi R19, R19, 1 */
		/* 821936D0h case   15:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x1);
		/* 821936D0h case   15:*/		return 0x821936D4;
		  /* 821936D4h */ case   16:  		/* cmplwi CR6, R27, 0 */
		/* 821936D4h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 821936D4h case   16:*/		return 0x821936D8;
		  /* 821936D8h */ case   17:  		/* bc 4, CR6_EQ, -704 */
		/* 821936D8h case   17:*/		if ( !regs.CR[6].eq ) { return 0x82193418;  }
		/* 821936D8h case   17:*/		return 0x821936DC;
	}
	return 0x821936DC;
} // Block from 82193694h-821936DCh (18 instructions)

//////////////////////////////////////////////////////
// Block at 821936DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821936DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821936DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821936DC);
		  /* 821936DCh */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 821936DCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 821936DCh case    0:*/		return 0x821936E0;
		  /* 821936E0h */ case    1:  		/* bc 12, CR6_EQ, 56 */
		/* 821936E0h case    1:*/		if ( regs.CR[6].eq ) { return 0x82193718;  }
		/* 821936E0h case    1:*/		return 0x821936E4;
		  /* 821936E4h */ case    2:  		/* rlwinm R11, R25, 0, 0, 30 */
		/* 821936E4h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R25);
		/* 821936E4h case    2:*/		return 0x821936E8;
		  /* 821936E8h */ case    3:  		/* lwz R9, <#[R28]> */
		/* 821936E8h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000000) );
		/* 821936E8h case    3:*/		return 0x821936EC;
		  /* 821936ECh */ case    4:  		/* addi R10, R28, -36 */
		/* 821936ECh case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0xFFFFFFDC);
		/* 821936ECh case    4:*/		return 0x821936F0;
		  /* 821936F0h */ case    5:  		/* addi R11, R11, 36 */
		/* 821936F0h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821936F0h case    5:*/		return 0x821936F4;
		  /* 821936F4h */ case    6:  		/* ori R8, R10, 1 */
		/* 821936F4h case    6:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 821936F4h case    6:*/		return 0x821936F8;
		  /* 821936F8h */ case    7:  		/* addi R7, R11, -36 */
		/* 821936F8h case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 821936F8h case    7:*/		return 0x821936FC;
		  /* 821936FCh */ case    8:  		/* addi R10, R11, 4 */
		/* 821936FCh case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821936FCh case    8:*/		return 0x82193700;
		  /* 82193700h */ case    9:  		/* stw R9, <#[R11]> */
		/* 82193700h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82193700h case    9:*/		return 0x82193704;
		  /* 82193704h */ case   10:  		/* lwz R9, <#[R28]> */
		/* 82193704h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000000) );
		/* 82193704h case   10:*/		return 0x82193708;
		  /* 82193708h */ case   11:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82193708h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82193708h case   11:*/		return 0x8219370C;
		  /* 8219370Ch */ case   12:  		/* stw R7, <#[R9]> */
		/* 8219370Ch case   12:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 8219370Ch case   12:*/		return 0x82193710;
		  /* 82193710h */ case   13:  		/* stw R8, <#[R11 + 4]> */
		/* 82193710h case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82193710h case   13:*/		return 0x82193714;
		  /* 82193714h */ case   14:  		/* stw R10, <#[R28]> */
		/* 82193714h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 82193714h case   14:*/		return 0x82193718;
	}
	return 0x82193718;
} // Block from 821936DCh-82193718h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82193718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193718);
		  /* 82193718h */ case    0:  		/* addi R1, R1, 256 */
		/* 82193718h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 82193718h case    0:*/		return 0x8219371C;
		  /* 8219371Ch */ case    1:  		/* b -1057964 */
		/* 8219371Ch case    1:*/		return 0x82091270;
		/* 8219371Ch case    1:*/		return 0x82193720;
	}
	return 0x82193720;
} // Block from 82193718h-82193720h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82193720h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193720);
		  /* 82193720h */ case    0:  		/* mfspr R12, LR */
		/* 82193720h case    0:*/		regs.R12 = regs.LR;
		/* 82193720h case    0:*/		return 0x82193724;
		  /* 82193724h */ case    1:  		/* bl -1058032 */
		/* 82193724h case    1:*/		regs.LR = 0x82193728; return 0x82091234;
		/* 82193724h case    1:*/		return 0x82193728;
		  /* 82193728h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82193728h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82193728h case    2:*/		return 0x8219372C;
		  /* 8219372Ch */ case    3:  		/* mr R21, R3 */
		/* 8219372Ch case    3:*/		regs.R21 = regs.R3;
		/* 8219372Ch case    3:*/		return 0x82193730;
		  /* 82193730h */ case    4:  		/* mr R19, R4 */
		/* 82193730h case    4:*/		regs.R19 = regs.R4;
		/* 82193730h case    4:*/		return 0x82193734;
		  /* 82193734h */ case    5:  		/* mr R20, R5 */
		/* 82193734h case    5:*/		regs.R20 = regs.R5;
		/* 82193734h case    5:*/		return 0x82193738;
		  /* 82193738h */ case    6:  		/* lwz R31, <#[R21]> */
		/* 82193738h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R21 + 0x00000000) );
		/* 82193738h case    6:*/		return 0x8219373C;
		  /* 8219373Ch */ case    7:  		/* mr R28, R21 */
		/* 8219373Ch case    7:*/		regs.R28 = regs.R21;
		/* 8219373Ch case    7:*/		return 0x82193740;
		  /* 82193740h */ case    8:  		/* li R27, 0 */
		/* 82193740h case    8:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82193740h case    8:*/		return 0x82193744;
		  /* 82193744h */ case    9:  		/* li R23, 0 */
		/* 82193744h case    9:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82193744h case    9:*/		return 0x82193748;
		  /* 82193748h */ case   10:  		/* li R26, 0 */
		/* 82193748h case   10:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82193748h case   10:*/		return 0x8219374C;
		  /* 8219374Ch */ case   11:  		/* li R24, 0 */
		/* 8219374Ch case   11:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 8219374Ch case   11:*/		return 0x82193750;
		  /* 82193750h */ case   12:  		/* li R25, 0 */
		/* 82193750h case   12:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82193750h case   12:*/		return 0x82193754;
		  /* 82193754h */ case   13:  		/* li R22, 0 */
		/* 82193754h case   13:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 82193754h case   13:*/		return 0x82193758;
		  /* 82193758h */ case   14:  		/* b 480 */
		/* 82193758h case   14:*/		return 0x82193938;
		/* 82193758h case   14:*/		return 0x8219375C;
		  /* 8219375Ch */ case   15:  		/* mr R4, R31 */
		/* 8219375Ch case   15:*/		regs.R4 = regs.R31;
		/* 8219375Ch case   15:*/		return 0x82193760;
		  /* 82193760h */ case   16:  		/* mr R3, R20 */
		/* 82193760h case   16:*/		regs.R3 = regs.R20;
		/* 82193760h case   16:*/		return 0x82193764;
		  /* 82193764h */ case   17:  		/* bl -149004 */
		/* 82193764h case   17:*/		regs.LR = 0x82193768; return 0x8216F158;
		/* 82193764h case   17:*/		return 0x82193768;
		  /* 82193768h */ case   18:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82193768h case   18:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82193768h case   18:*/		return 0x8219376C;
		  /* 8219376Ch */ case   19:  		/* bc 12, CR0_EQ, 452 */
		/* 8219376Ch case   19:*/		if ( regs.CR[0].eq ) { return 0x82193930;  }
		/* 8219376Ch case   19:*/		return 0x82193770;
		  /* 82193770h */ case   20:  		/* lwz R11, <#[R31 + 8]> */
		/* 82193770h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82193770h case   20:*/		return 0x82193774;
		  /* 82193774h */ case   21:  		/* cmplwi CR6, R19, 0 */
		/* 82193774h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 82193774h case   21:*/		return 0x82193778;
		  /* 82193778h */ case   22:  		/* bc 12, CR6_EQ, 260 */
		/* 82193778h case   22:*/		if ( regs.CR[6].eq ) { return 0x8219387C;  }
		/* 82193778h case   22:*/		return 0x8219377C;
		  /* 8219377Ch */ case   23:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 8219377Ch case   23:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 8219377Ch case   23:*/		return 0x82193780;
		  /* 82193780h */ case   24:  		/* cmplwi CR6, R10, 1 */
		/* 82193780h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 82193780h case   24:*/		return 0x82193784;
		  /* 82193784h */ case   25:  		/* bc 12, CR6_LT, 16 */
		/* 82193784h case   25:*/		if ( regs.CR[6].lt ) { return 0x82193794;  }
		/* 82193784h case   25:*/		return 0x82193788;
		  /* 82193788h */ case   26:  		/* cmplwi CR6, R10, 82 */
		/* 82193788h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000052);
		/* 82193788h case   26:*/		return 0x8219378C;
		  /* 8219378Ch */ case   27:  		/* li R11, 1 */
		/* 8219378Ch case   27:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219378Ch case   27:*/		return 0x82193790;
		  /* 82193790h */ case   28:  		/* bc 4, CR6_GT, 8 */
		/* 82193790h case   28:*/		if ( !regs.CR[6].gt ) { return 0x82193798;  }
		/* 82193790h case   28:*/		return 0x82193794;
	}
	return 0x82193794;
} // Block from 82193720h-82193794h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82193794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193794);
		  /* 82193794h */ case    0:  		/* li R11, 0 */
		/* 82193794h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82193794h case    0:*/		return 0x82193798;
	}
	return 0x82193798;
} // Block from 82193794h-82193798h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82193798h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193798);
		  /* 82193798h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 82193798h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82193798h case    0:*/		return 0x8219379C;
		  /* 8219379Ch */ case    1:  		/* addic R9, R11, -1 */
		/* 8219379Ch case    1:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 8219379Ch case    1:*/		return 0x821937A0;
		  /* 821937A0h */ case    2:  		/* subfe R11, R9, R11 */
		/* 821937A0h case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821937A0h case    2:*/		return 0x821937A4;
		  /* 821937A4h */ case    3:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821937A4h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821937A4h case    3:*/		return 0x821937A8;
		  /* 821937A8h */ case    4:  		/* bc 12, CR0_EQ, 392 */
		/* 821937A8h case    4:*/		if ( regs.CR[0].eq ) { return 0x82193930;  }
		/* 821937A8h case    4:*/		return 0x821937AC;
		  /* 821937ACh */ case    5:  		/* cmplwi CR6, R10, 1 */
		/* 821937ACh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 821937ACh case    5:*/		return 0x821937B0;
		  /* 821937B0h */ case    6:  		/* bc 12, CR6_LT, 16 */
		/* 821937B0h case    6:*/		if ( regs.CR[6].lt ) { return 0x821937C0;  }
		/* 821937B0h case    6:*/		return 0x821937B4;
		  /* 821937B4h */ case    7:  		/* cmplwi CR6, R10, 31 */
		/* 821937B4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000001F);
		/* 821937B4h case    7:*/		return 0x821937B8;
		  /* 821937B8h */ case    8:  		/* li R10, 1 */
		/* 821937B8h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821937B8h case    8:*/		return 0x821937BC;
		  /* 821937BCh */ case    9:  		/* bc 4, CR6_GT, 8 */
		/* 821937BCh case    9:*/		if ( !regs.CR[6].gt ) { return 0x821937C4;  }
		/* 821937BCh case    9:*/		return 0x821937C0;
	}
	return 0x821937C0;
} // Block from 82193798h-821937C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821937C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821937C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821937C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821937C0);
		  /* 821937C0h */ case    0:  		/* li R10, 0 */
		/* 821937C0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821937C0h case    0:*/		return 0x821937C4;
	}
	return 0x821937C4;
} // Block from 821937C0h-821937C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821937C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821937C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821937C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821937C4);
		  /* 821937C4h */ case    0:  		/* lwz R11, <#[R19 + 8]> */
		/* 821937C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000008) );
		/* 821937C4h case    0:*/		return 0x821937C8;
		  /* 821937C8h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821937C8h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821937C8h case    1:*/		return 0x821937CC;
		  /* 821937CCh */ case    2:  		/* cmplwi CR6, R11, 1 */
		/* 821937CCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821937CCh case    2:*/		return 0x821937D0;
		  /* 821937D0h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 821937D0h case    3:*/		if ( regs.CR[6].lt ) { return 0x821937E0;  }
		/* 821937D0h case    3:*/		return 0x821937D4;
		  /* 821937D4h */ case    4:  		/* cmplwi CR6, R11, 31 */
		/* 821937D4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001F);
		/* 821937D4h case    4:*/		return 0x821937D8;
		  /* 821937D8h */ case    5:  		/* li R11, 1 */
		/* 821937D8h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821937D8h case    5:*/		return 0x821937DC;
		  /* 821937DCh */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 821937DCh case    6:*/		if ( !regs.CR[6].gt ) { return 0x821937E4;  }
		/* 821937DCh case    6:*/		return 0x821937E0;
	}
	return 0x821937E0;
} // Block from 821937C4h-821937E0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821937E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821937E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821937E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821937E0);
		  /* 821937E0h */ case    0:  		/* li R11, 0 */
		/* 821937E0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821937E0h case    0:*/		return 0x821937E4;
	}
	return 0x821937E4;
} // Block from 821937E0h-821937E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821937E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821937E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821937E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821937E4);
		  /* 821937E4h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 821937E4h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821937E4h case    0:*/		return 0x821937E8;
		  /* 821937E8h */ case    1:  		/* rlwinm R10, R10, 0, 24, 31 */
		/* 821937E8h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R10);
		/* 821937E8h case    1:*/		return 0x821937EC;
		  /* 821937ECh */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 821937ECh case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821937ECh case    2:*/		return 0x821937F0;
		  /* 821937F0h */ case    3:  		/* bc 12, CR6_EQ, 320 */
		/* 821937F0h case    3:*/		if ( regs.CR[6].eq ) { return 0x82193930;  }
		/* 821937F0h case    3:*/		return 0x821937F4;
		  /* 821937F4h */ case    4:  		/* mr R5, R19 */
		/* 821937F4h case    4:*/		regs.R5 = regs.R19;
		/* 821937F4h case    4:*/		return 0x821937F8;
		  /* 821937F8h */ case    5:  		/* lwz R3, <#[R21 + 56]> */
		/* 821937F8h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R21 + 0x00000038) );
		/* 821937F8h case    5:*/		return 0x821937FC;
		  /* 821937FCh */ case    6:  		/* mr R4, R31 */
		/* 821937FCh case    6:*/		regs.R4 = regs.R31;
		/* 821937FCh case    6:*/		return 0x82193800;
		  /* 82193800h */ case    7:  		/* bl -15144 */
		/* 82193800h case    7:*/		regs.LR = 0x82193804; return 0x8218FCD8;
		/* 82193800h case    7:*/		return 0x82193804;
		  /* 82193804h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82193804h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82193804h case    8:*/		return 0x82193808;
		  /* 82193808h */ case    9:  		/* bc 12, CR0_EQ, 296 */
		/* 82193808h case    9:*/		if ( regs.CR[0].eq ) { return 0x82193930;  }
		/* 82193808h case    9:*/		return 0x8219380C;
		  /* 8219380Ch */ case   10:  		/* addi R11, R21, 4 */
		/* 8219380Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R21,0x4);
		/* 8219380Ch case   10:*/		return 0x82193810;
		  /* 82193810h */ case   11:  		/* cmplw CR6, R20, R11 */
		/* 82193810h case   11:*/		cpu::op::cmplw<6>(regs,regs.R20,regs.R11);
		/* 82193810h case   11:*/		return 0x82193814;
		  /* 82193814h */ case   12:  		/* bc 12, CR6_EQ, 84 */
		/* 82193814h case   12:*/		if ( regs.CR[6].eq ) { return 0x82193868;  }
		/* 82193814h case   12:*/		return 0x82193818;
		  /* 82193818h */ case   13:  		/* lwz R10, <#[R31 + 8]> */
		/* 82193818h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82193818h case   13:*/		return 0x8219381C;
		  /* 8219381Ch */ case   14:  		/* rlwinm. R11, R10, 25, 25, 31 */
		/* 8219381Ch case   14:*/		cpu::op::rlwinm<1,25,25,31>(regs,&regs.R11,regs.R10);
		/* 8219381Ch case   14:*/		return 0x82193820;
		  /* 82193820h */ case   15:  		/* bc 12, CR0_EQ, 36 */
		/* 82193820h case   15:*/		if ( regs.CR[0].eq ) { return 0x82193844;  }
		/* 82193820h case   15:*/		return 0x82193824;
		  /* 82193824h */ case   16:  		/* cmplwi CR6, R11, 11 */
		/* 82193824h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000B);
		/* 82193824h case   16:*/		return 0x82193828;
		  /* 82193828h */ case   17:  		/* bc 4, CR6_GT, 20 */
		/* 82193828h case   17:*/		if ( !regs.CR[6].gt ) { return 0x8219383C;  }
		/* 82193828h case   17:*/		return 0x8219382C;
		  /* 8219382Ch */ case   18:  		/* cmplwi CR6, R11, 24 */
		/* 8219382Ch case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000018);
		/* 8219382Ch case   18:*/		return 0x82193830;
		  /* 82193830h */ case   19:  		/* bc 4, CR6_GT, 20 */
		/* 82193830h case   19:*/		if ( !regs.CR[6].gt ) { return 0x82193844;  }
		/* 82193830h case   19:*/		return 0x82193834;
		  /* 82193834h */ case   20:  		/* cmplwi CR6, R11, 28 */
		/* 82193834h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001C);
		/* 82193834h case   20:*/		return 0x82193838;
		  /* 82193838h */ case   21:  		/* bc 12, CR6_GT, 12 */
		/* 82193838h case   21:*/		if ( regs.CR[6].gt ) { return 0x82193844;  }
		/* 82193838h case   21:*/		return 0x8219383C;
	}
	return 0x8219383C;
} // Block from 821937E4h-8219383Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 8219383Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219383C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219383C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219383C);
		  /* 8219383Ch */ case    0:  		/* li R11, 1 */
		/* 8219383Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219383Ch case    0:*/		return 0x82193840;
		  /* 82193840h */ case    1:  		/* b 8 */
		/* 82193840h case    1:*/		return 0x82193848;
		/* 82193840h case    1:*/		return 0x82193844;
	}
	return 0x82193844;
} // Block from 8219383Ch-82193844h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82193844h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193844( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193844) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193844);
		  /* 82193844h */ case    0:  		/* li R11, 0 */
		/* 82193844h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82193844h case    0:*/		return 0x82193848;
	}
	return 0x82193848;
} // Block from 82193844h-82193848h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82193848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193848);
		  /* 82193848h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82193848h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82193848h case    0:*/		return 0x8219384C;
		  /* 8219384Ch */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 8219384Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82193868;  }
		/* 8219384Ch case    1:*/		return 0x82193850;
		  /* 82193850h */ case    2:  		/* rlwinm. R11, R10, 7, 31, 31 */
		/* 82193850h case    2:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R10);
		/* 82193850h case    2:*/		return 0x82193854;
		  /* 82193854h */ case    3:  		/* bc 4, CR0_EQ, 20 */
		/* 82193854h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82193868;  }
		/* 82193854h case    3:*/		return 0x82193858;
	}
	return 0x82193858;
} // Block from 82193848h-82193858h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82193858h
// Function '?Schedule@Compiler@D3DXShader@@AAAXPAVInstruction@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193858);
		  /* 82193858h */ case    0:  		/* mr R3, R31 */
		/* 82193858h case    0:*/		regs.R3 = regs.R31;
		/* 82193858h case    0:*/		return 0x8219385C;
		  /* 8219385Ch */ case    1:  		/* bl -10892 */
		/* 8219385Ch case    1:*/		regs.LR = 0x82193860; return 0x82190DD0;
		/* 8219385Ch case    1:*/		return 0x82193860;
		  /* 82193860h */ case    2:  		/* cmplwi CR6, R3, 2 */
		/* 82193860h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000002);
		/* 82193860h case    2:*/		return 0x82193864;
		  /* 82193864h */ case    3:  		/* bc 4, CR6_GT, 204 */
		/* 82193864h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82193930;  }
		/* 82193864h case    3:*/		return 0x82193868;
	}
	return 0x82193868;
} // Block from 82193858h-82193868h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82193868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193868);
		  /* 82193868h */ case    0:  		/* lwz R11, <#[R31 + 32]> */
		/* 82193868h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 82193868h case    0:*/		return 0x8219386C;
		  /* 8219386Ch */ case    1:  		/* stw R11, <#[R28]> */
		/* 8219386Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8219386Ch case    1:*/		return 0x82193870;
		  /* 82193870h */ case    2:  		/* mr R3, R31 */
		/* 82193870h case    2:*/		regs.R3 = regs.R31;
		/* 82193870h case    2:*/		return 0x82193874;
		  /* 82193874h */ case    3:  		/* addi R1, R1, 192 */
		/* 82193874h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 82193874h case    3:*/		return 0x82193878;
		  /* 82193878h */ case    4:  		/* b -1058292 */
		/* 82193878h case    4:*/		return 0x82091284;
		/* 82193878h case    4:*/		return 0x8219387C;
	}
	return 0x8219387C;
} // Block from 82193868h-8219387Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219387Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219387C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219387C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219387C);
		  /* 8219387Ch */ case    0:  		/* rlwinm R29, R11, 25, 25, 31 */
		/* 8219387Ch case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R29,regs.R11);
		/* 8219387Ch case    0:*/		return 0x82193880;
		  /* 82193880h */ case    1:  		/* cmplwi CR6, R29, 96 */
		/* 82193880h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000060);
		/* 82193880h case    1:*/		return 0x82193884;
		  /* 82193884h */ case    2:  		/* bc 4, CR6_EQ, 32 */
		/* 82193884h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821938A4;  }
		/* 82193884h case    2:*/		return 0x82193888;
		  /* 82193888h */ case    3:  		/* rlwinm. R11, R11, 0, 10, 12 */
		/* 82193888h case    3:*/		cpu::op::rlwinm<1,0,10,12>(regs,&regs.R11,regs.R11);
		/* 82193888h case    3:*/		return 0x8219388C;
		  /* 8219388Ch */ case    4:  		/* bc 12, CR0_EQ, 24 */
		/* 8219388Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x821938A4;  }
		/* 8219388Ch case    4:*/		return 0x82193890;
		  /* 82193890h */ case    5:  		/* mr R4, R31 */
		/* 82193890h case    5:*/		regs.R4 = regs.R31;
		/* 82193890h case    5:*/		return 0x82193894;
		  /* 82193894h */ case    6:  		/* mr R3, R21 */
		/* 82193894h case    6:*/		regs.R3 = regs.R21;
		/* 82193894h case    6:*/		return 0x82193898;
		  /* 82193898h */ case    7:  		/* bl -12856 */
		/* 82193898h case    7:*/		regs.LR = 0x8219389C; return 0x82190660;
		/* 82193898h case    7:*/		return 0x8219389C;
		  /* 8219389Ch */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219389Ch case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219389Ch case    8:*/		return 0x821938A0;
		  /* 821938A0h */ case    9:  		/* bc 12, CR0_EQ, 56 */
		/* 821938A0h case    9:*/		if ( regs.CR[0].eq ) { return 0x821938D8;  }
		/* 821938A0h case    9:*/		return 0x821938A4;
	}
	return 0x821938A4;
} // Block from 8219387Ch-821938A4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821938A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821938A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821938A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821938A4);
		  /* 821938A4h */ case    0:  		/* lwz R30, <#[R20 + 40]> */
		/* 821938A4h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R20 + 0x00000028) );
		/* 821938A4h case    0:*/		return 0x821938A8;
		  /* 821938A8h */ case    1:  		/* cmpwi CR6, R30, 0 */
		/* 821938A8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 821938A8h case    1:*/		return 0x821938AC;
		  /* 821938ACh */ case    2:  		/* bc 12, CR6_EQ, -68 */
		/* 821938ACh case    2:*/		if ( regs.CR[6].eq ) { return 0x82193868;  }
		/* 821938ACh case    2:*/		return 0x821938B0;
		  /* 821938B0h */ case    3:  		/* mr R3, R31 */
		/* 821938B0h case    3:*/		regs.R3 = regs.R31;
		/* 821938B0h case    3:*/		return 0x821938B4;
		  /* 821938B4h */ case    4:  		/* bl -150460 */
		/* 821938B4h case    4:*/		regs.LR = 0x821938B8; return 0x8216ECF8;
		/* 821938B4h case    4:*/		return 0x821938B8;
		  /* 821938B8h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 821938B8h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821938B8h case    5:*/		return 0x821938BC;
		  /* 821938BCh */ case    6:  		/* bc 12, CR0_EQ, -84 */
		/* 821938BCh case    6:*/		if ( regs.CR[0].eq ) { return 0x82193868;  }
		/* 821938BCh case    6:*/		return 0x821938C0;
		  /* 821938C0h */ case    7:  		/* cmpw CR6, R3, R30 */
		/* 821938C0h case    7:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R30);
		/* 821938C0h case    7:*/		return 0x821938C4;
		  /* 821938C4h */ case    8:  		/* bc 12, CR6_EQ, -92 */
		/* 821938C4h case    8:*/		if ( regs.CR[6].eq ) { return 0x82193868;  }
		/* 821938C4h case    8:*/		return 0x821938C8;
		  /* 821938C8h */ case    9:  		/* cmplwi CR6, R25, 0 */
		/* 821938C8h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 821938C8h case    9:*/		return 0x821938CC;
		  /* 821938CCh */ case   10:  		/* bc 4, CR6_EQ, 12 */
		/* 821938CCh case   10:*/		if ( !regs.CR[6].eq ) { return 0x821938D8;  }
		/* 821938CCh case   10:*/		return 0x821938D0;
	}
	return 0x821938D0;
} // Block from 821938A4h-821938D0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821938D0h
// Function '?SmashSingleSourceUnary@Compiler@D3DXShader@@AAAXPAVInstruction@2@W4Opcode@2@PAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821938D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821938D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821938D0);
		  /* 821938D0h */ case    0:  		/* mr R25, R31 */
		/* 821938D0h case    0:*/		regs.R25 = regs.R31;
		/* 821938D0h case    0:*/		return 0x821938D4;
		  /* 821938D4h */ case    1:  		/* mr R22, R28 */
		/* 821938D4h case    1:*/		regs.R22 = regs.R28;
		/* 821938D4h case    1:*/		return 0x821938D8;
	}
	return 0x821938D8;
} // Block from 821938D0h-821938D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821938D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821938D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821938D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821938D8);
		  /* 821938D8h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 821938D8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 821938D8h case    0:*/		return 0x821938DC;
		  /* 821938DCh */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 821938DCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x821938E8;  }
		/* 821938DCh case    1:*/		return 0x821938E0;
		  /* 821938E0h */ case    2:  		/* mr R27, R31 */
		/* 821938E0h case    2:*/		regs.R27 = regs.R31;
		/* 821938E0h case    2:*/		return 0x821938E4;
		  /* 821938E4h */ case    3:  		/* mr R23, R28 */
		/* 821938E4h case    3:*/		regs.R23 = regs.R28;
		/* 821938E4h case    3:*/		return 0x821938E8;
	}
	return 0x821938E8;
} // Block from 821938D8h-821938E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821938E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821938E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821938E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821938E8);
		  /* 821938E8h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 821938E8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 821938E8h case    0:*/		return 0x821938EC;
		  /* 821938ECh */ case    1:  		/* bc 4, CR6_EQ, 68 */
		/* 821938ECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82193930;  }
		/* 821938ECh case    1:*/		return 0x821938F0;
		  /* 821938F0h */ case    2:  		/* cmplwi CR6, R29, 91 */
		/* 821938F0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000005B);
		/* 821938F0h case    2:*/		return 0x821938F4;
		  /* 821938F4h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 821938F4h case    3:*/		if ( regs.CR[6].lt ) { return 0x82193904;  }
		/* 821938F4h case    3:*/		return 0x821938F8;
		  /* 821938F8h */ case    4:  		/* cmplwi CR6, R29, 94 */
		/* 821938F8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000005E);
		/* 821938F8h case    4:*/		return 0x821938FC;
		  /* 821938FCh */ case    5:  		/* li R11, 1 */
		/* 821938FCh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821938FCh case    5:*/		return 0x82193900;
		  /* 82193900h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 82193900h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82193908;  }
		/* 82193900h case    6:*/		return 0x82193904;
	}
	return 0x82193904;
} // Block from 821938E8h-82193904h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82193904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193904);
		  /* 82193904h */ case    0:  		/* li R11, 0 */
		/* 82193904h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82193904h case    0:*/		return 0x82193908;
	}
	return 0x82193908;
} // Block from 82193904h-82193908h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82193908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193908);
		  /* 82193908h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82193908h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82193908h case    0:*/		return 0x8219390C;
		  /* 8219390Ch */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 8219390Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219391C;  }
		/* 8219390Ch case    1:*/		return 0x82193910;
		  /* 82193910h */ case    2:  		/* cmplwi CR6, R29, 123 */
		/* 82193910h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000007B);
		/* 82193910h case    2:*/		return 0x82193914;
		  /* 82193914h */ case    3:  		/* li R11, 0 */
		/* 82193914h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82193914h case    3:*/		return 0x82193918;
		  /* 82193918h */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 82193918h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82193920;  }
		/* 82193918h case    4:*/		return 0x8219391C;
	}
	return 0x8219391C;
} // Block from 82193908h-8219391Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219391Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219391C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219391C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219391C);
		  /* 8219391Ch */ case    0:  		/* li R11, 1 */
		/* 8219391Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219391Ch case    0:*/		return 0x82193920;
	}
	return 0x82193920;
} // Block from 8219391Ch-82193920h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82193920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193920);
		  /* 82193920h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82193920h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82193920h case    0:*/		return 0x82193924;
		  /* 82193924h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82193924h case    1:*/		if ( regs.CR[0].eq ) { return 0x82193930;  }
		/* 82193924h case    1:*/		return 0x82193928;
		  /* 82193928h */ case    2:  		/* mr R26, R31 */
		/* 82193928h case    2:*/		regs.R26 = regs.R31;
		/* 82193928h case    2:*/		return 0x8219392C;
		  /* 8219392Ch */ case    3:  		/* mr R24, R28 */
		/* 8219392Ch case    3:*/		regs.R24 = regs.R28;
		/* 8219392Ch case    3:*/		return 0x82193930;
	}
	return 0x82193930;
} // Block from 82193920h-82193930h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82193930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193930);
		  /* 82193930h */ case    0:  		/* addi R28, R31, 32 */
		/* 82193930h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x20);
		/* 82193930h case    0:*/		return 0x82193934;
		  /* 82193934h */ case    1:  		/* lwz R31, <#[R31 + 32]> */
		/* 82193934h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000020) );
		/* 82193934h case    1:*/		return 0x82193938;
	}
	return 0x82193938;
} // Block from 82193930h-82193938h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82193938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193938);
		  /* 82193938h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82193938h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82193938h case    0:*/		return 0x8219393C;
		  /* 8219393Ch */ case    1:  		/* bc 4, CR6_EQ, -480 */
		/* 8219393Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219375C;  }
		/* 8219393Ch case    1:*/		return 0x82193940;
		  /* 82193940h */ case    2:  		/* cmplwi CR6, R19, 0 */
		/* 82193940h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 82193940h case    2:*/		return 0x82193944;
		  /* 82193944h */ case    3:  		/* bc 4, CR6_EQ, 524 */
		/* 82193944h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82193B50;  }
		/* 82193944h case    3:*/		return 0x82193948;
		  /* 82193948h */ case    4:  		/* cmplwi CR6, R27, 0 */
		/* 82193948h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82193948h case    4:*/		return 0x8219394C;
		  /* 8219394Ch */ case    5:  		/* bc 4, CR6_EQ, 524 */
		/* 8219394Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x82193B58;  }
		/* 8219394Ch case    5:*/		return 0x82193950;
		  /* 82193950h */ case    6:  		/* li R28, 0 */
		/* 82193950h case    6:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82193950h case    6:*/		return 0x82193954;
		  /* 82193954h */ case    7:  		/* cmpwi CR6, R28, 9 */
		/* 82193954h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000009);
		/* 82193954h case    7:*/		return 0x82193958;
		  /* 82193958h */ case    8:  		/* bc 4, CR6_LT, 608 */
		/* 82193958h case    8:*/		if ( !regs.CR[6].lt ) { return 0x82193BB8;  }
		/* 82193958h case    8:*/		return 0x8219395C;
		  /* 8219395Ch */ case    9:  		/* addi R11, R28, 1 */
		/* 8219395Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0x1);
		/* 8219395Ch case    9:*/		return 0x82193960;
		  /* 82193960h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82193960h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82193960h case   10:*/		return 0x82193964;
		  /* 82193964h */ case   11:  		/* lwzx R30, <#[R11 + R20]> */
		/* 82193964h case   11:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R20 + 0x00000000) );
		/* 82193964h case   11:*/		return 0x82193968;
		  /* 82193968h */ case   12:  		/* cmplwi CR6, R30, 0 */
		/* 82193968h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82193968h case   12:*/		return 0x8219396C;
		  /* 8219396Ch */ case   13:  		/* bc 12, CR6_EQ, 364 */
		/* 8219396Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x82193AD8;  }
		/* 8219396Ch case   13:*/		return 0x82193970;
		  /* 82193970h */ case   14:  		/* lwz R3, <#[R21 + 56]> */
		/* 82193970h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R21 + 0x00000038) );
		/* 82193970h case   14:*/		return 0x82193974;
		  /* 82193974h */ case   15:  		/* cmplwi CR6, R28, 1 */
		/* 82193974h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000001);
		/* 82193974h case   15:*/		return 0x82193978;
		  /* 82193978h */ case   16:  		/* bc 12, CR6_LT, 80 */
		/* 82193978h case   16:*/		if ( regs.CR[6].lt ) { return 0x821939C8;  }
		/* 82193978h case   16:*/		return 0x8219397C;
		  /* 8219397Ch */ case   17:  		/* bc 12, CR6_EQ, 56 */
		/* 8219397Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x821939B4;  }
		/* 8219397Ch case   17:*/		return 0x82193980;
		  /* 82193980h */ case   18:  		/* cmplwi CR6, R28, 3 */
		/* 82193980h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000003);
		/* 82193980h case   18:*/		return 0x82193984;
		  /* 82193984h */ case   19:  		/* bc 12, CR6_LT, 28 */
		/* 82193984h case   19:*/		if ( regs.CR[6].lt ) { return 0x821939A0;  }
		/* 82193984h case   19:*/		return 0x82193988;
		  /* 82193988h */ case   20:  		/* bc 4, CR6_EQ, 544 */
		/* 82193988h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82193BA8;  }
		/* 82193988h case   20:*/		return 0x8219398C;
		  /* 8219398Ch */ case   21:  		/* li R5, 0 */
		/* 8219398Ch case   21:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219398Ch case   21:*/		return 0x82193990;
		  /* 82193990h */ case   22:  		/* lwz R6, <#[R30 + 44]> */
		/* 82193990h case   22:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x0000002C) );
		/* 82193990h case   22:*/		return 0x82193994;
		  /* 82193994h */ case   23:  		/* lwz R4, <#[R30 + 28]> */
		/* 82193994h case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000001C) );
		/* 82193994h case   23:*/		return 0x82193998;
		  /* 82193998h */ case   24:  		/* bl -6256 */
		/* 82193998h case   24:*/		regs.LR = 0x8219399C; return 0x82192128;
		/* 82193998h case   24:*/		return 0x8219399C;
		  /* 8219399Ch */ case   25:  		/* b 136 */
		/* 8219399Ch case   25:*/		return 0x82193A24;
		/* 8219399Ch case   25:*/		return 0x821939A0;
	}
	return 0x821939A0;
} // Block from 82193938h-821939A0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821939A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821939A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821939A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821939A0);
		  /* 821939A0h */ case    0:  		/* li R5, 0 */
		/* 821939A0h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821939A0h case    0:*/		return 0x821939A4;
		  /* 821939A4h */ case    1:  		/* lwz R6, <#[R30 + 44]> */
		/* 821939A4h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x0000002C) );
		/* 821939A4h case    1:*/		return 0x821939A8;
		  /* 821939A8h */ case    2:  		/* lwz R4, <#[R30 + 28]> */
		/* 821939A8h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000001C) );
		/* 821939A8h case    2:*/		return 0x821939AC;
		  /* 821939ACh */ case    3:  		/* bl -6444 */
		/* 821939ACh case    3:*/		regs.LR = 0x821939B0; return 0x82192080;
		/* 821939ACh case    3:*/		return 0x821939B0;
		  /* 821939B0h */ case    4:  		/* b 116 */
		/* 821939B0h case    4:*/		return 0x82193A24;
		/* 821939B0h case    4:*/		return 0x821939B4;
	}
	return 0x821939B4;
} // Block from 821939A0h-821939B4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821939B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821939B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821939B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821939B4);
		  /* 821939B4h */ case    0:  		/* li R5, 0 */
		/* 821939B4h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821939B4h case    0:*/		return 0x821939B8;
		  /* 821939B8h */ case    1:  		/* lwz R6, <#[R30 + 44]> */
		/* 821939B8h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x0000002C) );
		/* 821939B8h case    1:*/		return 0x821939BC;
		  /* 821939BCh */ case    2:  		/* lwz R4, <#[R30 + 28]> */
		/* 821939BCh case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000001C) );
		/* 821939BCh case    2:*/		return 0x821939C0;
		  /* 821939C0h */ case    3:  		/* bl -6632 */
		/* 821939C0h case    3:*/		regs.LR = 0x821939C4; return 0x82191FD8;
		/* 821939C0h case    3:*/		return 0x821939C4;
		  /* 821939C4h */ case    4:  		/* b 96 */
		/* 821939C4h case    4:*/		return 0x82193A24;
		/* 821939C4h case    4:*/		return 0x821939C8;
	}
	return 0x821939C8;
} // Block from 821939B4h-821939C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821939C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821939C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821939C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821939C8);
		  /* 821939C8h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 821939C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821939C8h case    0:*/		return 0x821939CC;
		  /* 821939CCh */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821939CCh case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821939CCh case    1:*/		return 0x821939D0;
		  /* 821939D0h */ case    2:  		/* cmplwi CR6, R11, 30 */
		/* 821939D0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001E);
		/* 821939D0h case    2:*/		return 0x821939D4;
		  /* 821939D4h */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 821939D4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821939F0;  }
		/* 821939D4h case    3:*/		return 0x821939D8;
		  /* 821939D8h */ case    4:  		/* li R5, 0 */
		/* 821939D8h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821939D8h case    4:*/		return 0x821939DC;
		  /* 821939DCh */ case    5:  		/* lwz R7, <#[R30 + 48]> */
		/* 821939DCh case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000030) );
		/* 821939DCh case    5:*/		return 0x821939E0;
		  /* 821939E0h */ case    6:  		/* lwz R6, <#[R30 + 44]> */
		/* 821939E0h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x0000002C) );
		/* 821939E0h case    6:*/		return 0x821939E4;
		  /* 821939E4h */ case    7:  		/* lwz R4, <#[R30 + 28]> */
		/* 821939E4h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000001C) );
		/* 821939E4h case    7:*/		return 0x821939E8;
		  /* 821939E8h */ case    8:  		/* bl -8040 */
		/* 821939E8h case    8:*/		regs.LR = 0x821939EC; return 0x82191A80;
		/* 821939E8h case    8:*/		return 0x821939EC;
		  /* 821939ECh */ case    9:  		/* b 56 */
		/* 821939ECh case    9:*/		return 0x82193A24;
		/* 821939ECh case    9:*/		return 0x821939F0;
	}
	return 0x821939F0;
} // Block from 821939C8h-821939F0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821939F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821939F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821939F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821939F0);
		  /* 821939F0h */ case    0:  		/* cmplwi CR6, R11, 55 */
		/* 821939F0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000037);
		/* 821939F0h case    0:*/		return 0x821939F4;
		  /* 821939F4h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 821939F4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82193A0C;  }
		/* 821939F4h case    1:*/		return 0x821939F8;
		  /* 821939F8h */ case    2:  		/* li R5, 0 */
		/* 821939F8h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821939F8h case    2:*/		return 0x821939FC;
		  /* 821939FCh */ case    3:  		/* lwz R6, <#[R30 + 44]> */
		/* 821939FCh case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x0000002C) );
		/* 821939FCh case    3:*/		return 0x82193A00;
		  /* 82193A00h */ case    4:  		/* lwz R4, <#[R30 + 28]> */
		/* 82193A00h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000001C) );
		/* 82193A00h case    4:*/		return 0x82193A04;
		  /* 82193A04h */ case    5:  		/* bl -7684 */
		/* 82193A04h case    5:*/		regs.LR = 0x82193A08; return 0x82191C00;
		/* 82193A04h case    5:*/		return 0x82193A08;
		  /* 82193A08h */ case    6:  		/* b 28 */
		/* 82193A08h case    6:*/		return 0x82193A24;
		/* 82193A08h case    6:*/		return 0x82193A0C;
	}
	return 0x82193A0C;
} // Block from 821939F0h-82193A0Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82193A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193A0C);
		  /* 82193A0Ch */ case    0:  		/* cmplwi CR6, R11, 56 */
		/* 82193A0Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000038);
		/* 82193A0Ch case    0:*/		return 0x82193A10;
		  /* 82193A10h */ case    1:  		/* bc 4, CR6_EQ, 416 */
		/* 82193A10h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82193BB0;  }
		/* 82193A10h case    1:*/		return 0x82193A14;
		  /* 82193A14h */ case    2:  		/* li R5, 0 */
		/* 82193A14h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82193A14h case    2:*/		return 0x82193A18;
		  /* 82193A18h */ case    3:  		/* lwz R6, <#[R30 + 44]> */
		/* 82193A18h case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x0000002C) );
		/* 82193A18h case    3:*/		return 0x82193A1C;
		  /* 82193A1Ch */ case    4:  		/* lwz R4, <#[R30 + 28]> */
		/* 82193A1Ch case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000001C) );
		/* 82193A1Ch case    4:*/		return 0x82193A20;
		  /* 82193A20h */ case    5:  		/* bl -7544 */
		/* 82193A20h case    5:*/		regs.LR = 0x82193A24; return 0x82191CA8;
		/* 82193A20h case    5:*/		return 0x82193A24;
	}
	return 0x82193A24;
} // Block from 82193A0Ch-82193A24h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82193A24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193A24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193A24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193A24);
		  /* 82193A24h */ case    0:  		/* lwz R29, <#[R30]> */
		/* 82193A24h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000000) );
		/* 82193A24h case    0:*/		return 0x82193A28;
		  /* 82193A28h */ case    1:  		/* mr R31, R3 */
		/* 82193A28h case    1:*/		regs.R31 = regs.R3;
		/* 82193A28h case    1:*/		return 0x82193A2C;
		  /* 82193A2Ch */ case    2:  		/* cmplwi CR6, R29, 0 */
		/* 82193A2Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82193A2Ch case    2:*/		return 0x82193A30;
		  /* 82193A30h */ case    3:  		/* bc 12, CR6_EQ, 36 */
		/* 82193A30h case    3:*/		if ( regs.CR[6].eq ) { return 0x82193A54;  }
		/* 82193A30h case    3:*/		return 0x82193A34;
		  /* 82193A34h */ case    4:  		/* lwz R11, <#[R29]> */
		/* 82193A34h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82193A34h case    4:*/		return 0x82193A38;
		  /* 82193A38h */ case    5:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82193A38h case    5:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82193A38h case    5:*/		return 0x82193A3C;
		  /* 82193A3Ch */ case    6:  		/* bc 4, CR0_EQ, 16 */
		/* 82193A3Ch case    6:*/		if ( !regs.CR[0].eq ) { return 0x82193A4C;  }
		/* 82193A3Ch case    6:*/		return 0x82193A40;
		  /* 82193A40h */ case    7:  		/* mr R4, R29 */
		/* 82193A40h case    7:*/		regs.R4 = regs.R29;
		/* 82193A40h case    7:*/		return 0x82193A44;
		  /* 82193A44h */ case    8:  		/* mr R3, R31 */
		/* 82193A44h case    8:*/		regs.R3 = regs.R31;
		/* 82193A44h case    8:*/		return 0x82193A48;
		  /* 82193A48h */ case    9:  		/* bl -112768 */
		/* 82193A48h case    9:*/		regs.LR = 0x82193A4C; return 0x821781C8;
		/* 82193A48h case    9:*/		return 0x82193A4C;
	}
	return 0x82193A4C;
} // Block from 82193A24h-82193A4Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82193A4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193A4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193A4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193A4C);
		  /* 82193A4Ch */ case    0:  		/* lwz R29, <#[R29 + 4]> */
		/* 82193A4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000004) );
		/* 82193A4Ch case    0:*/		return 0x82193A50;
		  /* 82193A50h */ case    1:  		/* b -36 */
		/* 82193A50h case    1:*/		return 0x82193A2C;
		/* 82193A50h case    1:*/		return 0x82193A54;
	}
	return 0x82193A54;
} // Block from 82193A4Ch-82193A54h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82193A54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193A54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193A54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193A54);
		  /* 82193A54h */ case    0:  		/* li R9, 0 */
		/* 82193A54h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82193A54h case    0:*/		return 0x82193A58;
		  /* 82193A58h */ case    1:  		/* addi R8, R30, 4 */
		/* 82193A58h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R30,0x4);
		/* 82193A58h case    1:*/		return 0x82193A5C;
		  /* 82193A5Ch */ case    2:  		/* lwz R11, <#[R8]> */
		/* 82193A5Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82193A5Ch case    2:*/		return 0x82193A60;
		  /* 82193A60h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82193A60h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82193A60h case    3:*/		return 0x82193A64;
		  /* 82193A64h */ case    4:  		/* bc 12, CR6_EQ, 108 */
		/* 82193A64h case    4:*/		if ( regs.CR[6].eq ) { return 0x82193AD0;  }
		/* 82193A64h case    4:*/		return 0x82193A68;
		  /* 82193A68h */ case    5:  		/* lwz R10, <#[R11 + 16]> */
		/* 82193A68h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82193A68h case    5:*/		return 0x82193A6C;
		  /* 82193A6Ch */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 82193A6Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82193A6Ch case    6:*/		return 0x82193A70;
		  /* 82193A70h */ case    7:  		/* bc 12, CR6_EQ, 76 */
		/* 82193A70h case    7:*/		if ( regs.CR[6].eq ) { return 0x82193ABC;  }
		/* 82193A70h case    7:*/		return 0x82193A74;
		  /* 82193A74h */ case    8:  		/* lbz R10, <#[R10 + 16]> */
		/* 82193A74h case    8:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 82193A74h case    8:*/		return 0x82193A78;
		  /* 82193A78h */ case    9:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82193A78h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82193A78h case    9:*/		return 0x82193A7C;
		  /* 82193A7Ch */ case   10:  		/* bc 4, CR0_EQ, 64 */
		/* 82193A7Ch case   10:*/		if ( !regs.CR[0].eq ) { return 0x82193ABC;  }
		/* 82193A7Ch case   10:*/		return 0x82193A80;
		  /* 82193A80h */ case   11:  		/* lwz R10, <#[R11 + 12]> */
		/* 82193A80h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82193A80h case   11:*/		return 0x82193A84;
		  /* 82193A84h */ case   12:  		/* addi R10, R10, 4 */
		/* 82193A84h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82193A84h case   12:*/		return 0x82193A88;
		  /* 82193A88h */ case   13:  		/* lwz R9, <#[R10]> */
		/* 82193A88h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82193A88h case   13:*/		return 0x82193A8C;
		  /* 82193A8Ch */ case   14:  		/* b 12 */
		/* 82193A8Ch case   14:*/		return 0x82193A98;
		/* 82193A8Ch case   14:*/		return 0x82193A90;
		  /* 82193A90h */ case   15:  		/* addi R10, R9, 8 */
		/* 82193A90h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 82193A90h case   15:*/		return 0x82193A94;
		  /* 82193A94h */ case   16:  		/* lwz R9, <#[R9 + 8]> */
		/* 82193A94h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 82193A94h case   16:*/		return 0x82193A98;
	}
	return 0x82193A98;
} // Block from 82193A54h-82193A98h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82193A98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193A98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193A98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193A98);
		  /* 82193A98h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 82193A98h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82193A98h case    0:*/		return 0x82193A9C;
		  /* 82193A9Ch */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82193A9Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82193A90;  }
		/* 82193A9Ch case    1:*/		return 0x82193AA0;
		  /* 82193AA0h */ case    2:  		/* lwz R7, <#[R11 + 8]> */
		/* 82193AA0h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 82193AA0h case    2:*/		return 0x82193AA4;
		  /* 82193AA4h */ case    3:  		/* li R9, 1 */
		/* 82193AA4h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82193AA4h case    3:*/		return 0x82193AA8;
		  /* 82193AA8h */ case    4:  		/* stw R7, <#[R10]> */
		/* 82193AA8h case    4:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 82193AA8h case    4:*/		return 0x82193AAC;
		  /* 82193AACh */ case    5:  		/* lwz R10, <#[R31 + 4]> */
		/* 82193AACh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82193AACh case    5:*/		return 0x82193AB0;
		  /* 82193AB0h */ case    6:  		/* stw R10, <#[R11 + 8]> */
		/* 82193AB0h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82193AB0h case    6:*/		return 0x82193AB4;
		  /* 82193AB4h */ case    7:  		/* stw R11, <#[R31 + 4]> */
		/* 82193AB4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82193AB4h case    7:*/		return 0x82193AB8;
		  /* 82193AB8h */ case    8:  		/* stw R31, <#[R11 + 12]> */
		/* 82193AB8h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x0000000C) );
		/* 82193AB8h case    8:*/		return 0x82193ABC;
	}
	return 0x82193ABC;
} // Block from 82193A98h-82193ABCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 82193ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193ABC);
		  /* 82193ABCh */ case    0:  		/* lwz R10, <#[R8]> */
		/* 82193ABCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 82193ABCh case    0:*/		return 0x82193AC0;
		  /* 82193AC0h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 82193AC0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82193AC0h case    1:*/		return 0x82193AC4;
		  /* 82193AC4h */ case    2:  		/* bc 4, CR6_EQ, -104 */
		/* 82193AC4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82193A5C;  }
		/* 82193AC4h case    2:*/		return 0x82193AC8;
		  /* 82193AC8h */ case    3:  		/* addi R8, R11, 8 */
		/* 82193AC8h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 82193AC8h case    3:*/		return 0x82193ACC;
		  /* 82193ACCh */ case    4:  		/* b -112 */
		/* 82193ACCh case    4:*/		return 0x82193A5C;
		/* 82193ACCh case    4:*/		return 0x82193AD0;
	}
	return 0x82193AD0;
} // Block from 82193ABCh-82193AD0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82193AD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193AD0);
		  /* 82193AD0h */ case    0:  		/* rlwinm. R11, R9, 0, 24, 31 */
		/* 82193AD0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R9);
		/* 82193AD0h case    0:*/		return 0x82193AD4;
		  /* 82193AD4h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 82193AD4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82193AE0;  }
		/* 82193AD4h case    1:*/		return 0x82193AD8;
	}
	return 0x82193AD8;
} // Block from 82193AD0h-82193AD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82193AD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193AD8);
		  /* 82193AD8h */ case    0:  		/* addi R28, R28, 1 */
		/* 82193AD8h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82193AD8h case    0:*/		return 0x82193ADC;
		  /* 82193ADCh */ case    1:  		/* b -392 */
		/* 82193ADCh case    1:*/		return 0x82193954;
		/* 82193ADCh case    1:*/		return 0x82193AE0;
	}
	return 0x82193AE0;
} // Block from 82193AD8h-82193AE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82193AE0h
// Function '?SmashSingleSourceBinary@Compiler@D3DXShader@@AAAXPAVInstruction@2@W4Opcode@2@PAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193AE0);
		  /* 82193AE0h */ case    0:  		/* mr R3, R31 */
		/* 82193AE0h case    0:*/		regs.R3 = regs.R31;
		/* 82193AE0h case    0:*/		return 0x82193AE4;
		  /* 82193AE4h */ case    1:  		/* bl -192868 */
		/* 82193AE4h case    1:*/		regs.LR = 0x82193AE8; return 0x82164980;
		/* 82193AE4h case    1:*/		return 0x82193AE8;
		  /* 82193AE8h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82193AE8h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82193AE8h case    2:*/		return 0x82193AEC;
		  /* 82193AECh */ case    3:  		/* bc 12, CR0_EQ, 28 */
		/* 82193AECh case    3:*/		if ( regs.CR[0].eq ) { return 0x82193B08;  }
		/* 82193AECh case    3:*/		return 0x82193AF0;
		  /* 82193AF0h */ case    4:  		/* li R6, 0 */
		/* 82193AF0h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82193AF0h case    4:*/		return 0x82193AF4;
		  /* 82193AF4h */ case    5:  		/* lwz R3, <#[R21 + 56]> */
		/* 82193AF4h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R21 + 0x00000038) );
		/* 82193AF4h case    5:*/		return 0x82193AF8;
		  /* 82193AF8h */ case    6:  		/* li R5, 0 */
		/* 82193AF8h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82193AF8h case    6:*/		return 0x82193AFC;
		  /* 82193AFCh */ case    7:  		/* mr R4, R31 */
		/* 82193AFCh case    7:*/		regs.R4 = regs.R31;
		/* 82193AFCh case    7:*/		return 0x82193B00;
		  /* 82193B00h */ case    8:  		/* bl 620744 */
		/* 82193B00h case    8:*/		regs.LR = 0x82193B04; return 0x8222B3C8;
		/* 82193B00h case    8:*/		return 0x82193B04;
		  /* 82193B04h */ case    9:  		/* b 60 */
		/* 82193B04h case    9:*/		return 0x82193B40;
		/* 82193B04h case    9:*/		return 0x82193B08;
	}
	return 0x82193B08;
} // Block from 82193AE0h-82193B08h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82193B08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193B08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193B08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193B08);
		  /* 82193B08h */ case    0:  		/* lwz R11, <#[R30 + 20]> */
		/* 82193B08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 82193B08h case    0:*/		return 0x82193B0C;
		  /* 82193B0Ch */ case    1:  		/* mr R3, R31 */
		/* 82193B0Ch case    1:*/		regs.R3 = regs.R31;
		/* 82193B0Ch case    1:*/		return 0x82193B10;
		  /* 82193B10h */ case    2:  		/* lwz R10, <#[R31 + 20]> */
		/* 82193B10h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 82193B10h case    2:*/		return 0x82193B14;
		  /* 82193B14h */ case    3:  		/* lwz R9, <#[R31 + 16]> */
		/* 82193B14h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 82193B14h case    3:*/		return 0x82193B18;
		  /* 82193B18h */ case    4:  		/* rlwimi R11, R10, 0, 19, 5 */
		/* 82193B18h case    4:*/		cpu::op::rlwimi<0,0,19,5>(regs,&regs.R11,regs.R10);
		/* 82193B18h case    4:*/		return 0x82193B1C;
		  /* 82193B1Ch */ case    5:  		/* stw R11, <#[R31 + 20]> */
		/* 82193B1Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82193B1Ch case    5:*/		return 0x82193B20;
		  /* 82193B20h */ case    6:  		/* lwz R11, <#[R30 + 16]> */
		/* 82193B20h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82193B20h case    6:*/		return 0x82193B24;
		  /* 82193B24h */ case    7:  		/* rlwinm R11, R11, 11, 29, 31 */
		/* 82193B24h case    7:*/		cpu::op::rlwinm<0,11,29,31>(regs,&regs.R11,regs.R11);
		/* 82193B24h case    7:*/		return 0x82193B28;
		  /* 82193B28h */ case    8:  		/* rlwimi R9, R11, 21, 8, 10 */
		/* 82193B28h case    8:*/		cpu::op::rlwimi<0,21,8,10>(regs,&regs.R9,regs.R11);
		/* 82193B28h case    8:*/		return 0x82193B2C;
		  /* 82193B2Ch */ case    9:  		/* stw R9, <#[R31 + 16]> */
		/* 82193B2Ch case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 82193B2Ch case    9:*/		return 0x82193B30;
		  /* 82193B30h */ case   10:  		/* bl -112568 */
		/* 82193B30h case   10:*/		regs.LR = 0x82193B34; return 0x82178378;
		/* 82193B30h case   10:*/		return 0x82193B34;
		  /* 82193B34h */ case   11:  		/* lwz R11, <#[R31 + 8]> */
		/* 82193B34h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82193B34h case   11:*/		return 0x82193B38;
		  /* 82193B38h */ case   12:  		/* oris R11, R11, 256 */
		/* 82193B38h case   12:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82193B38h case   12:*/		return 0x82193B3C;
		  /* 82193B3Ch */ case   13:  		/* stw R11, <#[R31 + 8]> */
		/* 82193B3Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82193B3Ch case   13:*/		return 0x82193B40;
	}
	return 0x82193B40;
} // Block from 82193B08h-82193B40h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82193B40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193B40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193B40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193B40);
		  /* 82193B40h */ case    0:  		/* mr R4, R30 */
		/* 82193B40h case    0:*/		regs.R4 = regs.R30;
		/* 82193B40h case    0:*/		return 0x82193B44;
		  /* 82193B44h */ case    1:  		/* mr R3, R21 */
		/* 82193B44h case    1:*/		regs.R3 = regs.R21;
		/* 82193B44h case    1:*/		return 0x82193B48;
		  /* 82193B48h */ case    2:  		/* bl -6520 */
		/* 82193B48h case    2:*/		regs.LR = 0x82193B4C; return 0x821921D0;
		/* 82193B48h case    2:*/		return 0x82193B4C;
		  /* 82193B4Ch */ case    3:  		/* b -1044 */
		/* 82193B4Ch case    3:*/		return 0x82193738;
		/* 82193B4Ch case    3:*/		return 0x82193B50;
	}
	return 0x82193B50;
} // Block from 82193B40h-82193B50h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82193B50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193B50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193B50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193B50);
		  /* 82193B50h */ case    0:  		/* li R3, 0 */
		/* 82193B50h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82193B50h case    0:*/		return 0x82193B54;
		  /* 82193B54h */ case    1:  		/* b -736 */
		/* 82193B54h case    1:*/		return 0x82193874;
		/* 82193B54h case    1:*/		return 0x82193B58;
	}
	return 0x82193B58;
} // Block from 82193B50h-82193B58h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82193B58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193B58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193B58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193B58);
		  /* 82193B58h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 82193B58h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82193B58h case    0:*/		return 0x82193B5C;
		  /* 82193B5Ch */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 82193B5Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82193B80;  }
		/* 82193B5Ch case    1:*/		return 0x82193B60;
		  /* 82193B60h */ case    2:  		/* mr R3, R27 */
		/* 82193B60h case    2:*/		regs.R3 = regs.R27;
		/* 82193B60h case    2:*/		return 0x82193B64;
		  /* 82193B64h */ case    3:  		/* bl -151148 */
		/* 82193B64h case    3:*/		regs.LR = 0x82193B68; return 0x8216ECF8;
		/* 82193B64h case    3:*/		return 0x82193B68;
		  /* 82193B68h */ case    4:  		/* cmpwi CR6, R3, 1 */
		/* 82193B68h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82193B68h case    4:*/		return 0x82193B6C;
		  /* 82193B6Ch */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 82193B6Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82193B80;  }
		/* 82193B6Ch case    5:*/		return 0x82193B70;
		  /* 82193B70h */ case    6:  		/* lwz R11, <#[R26 + 32]> */
		/* 82193B70h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000020) );
		/* 82193B70h case    6:*/		return 0x82193B74;
		  /* 82193B74h */ case    7:  		/* mr R31, R26 */
		/* 82193B74h case    7:*/		regs.R31 = regs.R26;
		/* 82193B74h case    7:*/		return 0x82193B78;
		  /* 82193B78h */ case    8:  		/* stw R11, <#[R24]> */
		/* 82193B78h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 82193B78h case    8:*/		return 0x82193B7C;
		  /* 82193B7Ch */ case    9:  		/* b -780 */
		/* 82193B7Ch case    9:*/		return 0x82193870;
		/* 82193B7Ch case    9:*/		return 0x82193B80;
	}
	return 0x82193B80;
} // Block from 82193B58h-82193B80h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82193B80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193B80);
		  /* 82193B80h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 82193B80h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82193B80h case    0:*/		return 0x82193B84;
		  /* 82193B84h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 82193B84h case    1:*/		if ( regs.CR[6].eq ) { return 0x82193B98;  }
		/* 82193B84h case    1:*/		return 0x82193B88;
		  /* 82193B88h */ case    2:  		/* lwz R11, <#[R25 + 32]> */
		/* 82193B88h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000020) );
		/* 82193B88h case    2:*/		return 0x82193B8C;
		  /* 82193B8Ch */ case    3:  		/* mr R31, R25 */
		/* 82193B8Ch case    3:*/		regs.R31 = regs.R25;
		/* 82193B8Ch case    3:*/		return 0x82193B90;
		  /* 82193B90h */ case    4:  		/* stw R11, <#[R22]> */
		/* 82193B90h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 82193B90h case    4:*/		return 0x82193B94;
		  /* 82193B94h */ case    5:  		/* b -804 */
		/* 82193B94h case    5:*/		return 0x82193870;
		/* 82193B94h case    5:*/		return 0x82193B98;
	}
	return 0x82193B98;
} // Block from 82193B80h-82193B98h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82193B98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193B98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193B98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193B98);
		  /* 82193B98h */ case    0:  		/* lwz R11, <#[R27 + 32]> */
		/* 82193B98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000020) );
		/* 82193B98h case    0:*/		return 0x82193B9C;
		  /* 82193B9Ch */ case    1:  		/* mr R31, R27 */
		/* 82193B9Ch case    1:*/		regs.R31 = regs.R27;
		/* 82193B9Ch case    1:*/		return 0x82193BA0;
		  /* 82193BA0h */ case    2:  		/* stw R11, <#[R23]> */
		/* 82193BA0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 82193BA0h case    2:*/		return 0x82193BA4;
		  /* 82193BA4h */ case    3:  		/* b -820 */
		/* 82193BA4h case    3:*/		return 0x82193870;
		/* 82193BA4h case    3:*/		return 0x82193BA8;
	}
	return 0x82193BA8;
} // Block from 82193B98h-82193BA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82193BA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193BA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193BA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193BA8);
		  /* 82193BA8h */ case    0:  		/* li R4, 4800 */
		/* 82193BA8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82193BA8h case    0:*/		return 0x82193BAC;
		  /* 82193BACh */ case    1:  		/* bl -269636 */
		/* 82193BACh case    1:*/		regs.LR = 0x82193BB0; return 0x82151E68;
		/* 82193BACh case    1:*/		return 0x82193BB0;
	}
	return 0x82193BB0;
} // Block from 82193BA8h-82193BB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82193BB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193BB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193BB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193BB0);
		  /* 82193BB0h */ case    0:  		/* li R4, 4800 */
		/* 82193BB0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82193BB0h case    0:*/		return 0x82193BB4;
		  /* 82193BB4h */ case    1:  		/* bl -269644 */
		/* 82193BB4h case    1:*/		regs.LR = 0x82193BB8; return 0x82151E68;
		/* 82193BB4h case    1:*/		return 0x82193BB8;
	}
	return 0x82193BB8;
} // Block from 82193BB0h-82193BB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82193BB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193BB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193BB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193BB8);
		  /* 82193BB8h */ case    0:  		/* li R4, 4800 */
		/* 82193BB8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82193BB8h case    0:*/		return 0x82193BBC;
		  /* 82193BBCh */ case    1:  		/* lwz R3, <#[R21 + 56]> */
		/* 82193BBCh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R21 + 0x00000038) );
		/* 82193BBCh case    1:*/		return 0x82193BC0;
		  /* 82193BC0h */ case    2:  		/* bl -269656 */
		/* 82193BC0h case    2:*/		regs.LR = 0x82193BC4; return 0x82151E68;
		/* 82193BC0h case    2:*/		return 0x82193BC4;
		  /* 82193BC4h */ case    3:  		/* nop */
		/* 82193BC4h case    3:*/		cpu::op::nop();
		/* 82193BC4h case    3:*/		return 0x82193BC8;
	}
	return 0x82193BC8;
} // Block from 82193BB8h-82193BC8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82193BC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193BC8);
		  /* 82193BC8h */ case    0:  		/* mfspr R12, LR */
		/* 82193BC8h case    0:*/		regs.R12 = regs.LR;
		/* 82193BC8h case    0:*/		return 0x82193BCC;
		  /* 82193BCCh */ case    1:  		/* bl -1059192 */
		/* 82193BCCh case    1:*/		regs.LR = 0x82193BD0; return 0x82091254;
		/* 82193BCCh case    1:*/		return 0x82193BD0;
		  /* 82193BD0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82193BD0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82193BD0h case    2:*/		return 0x82193BD4;
		  /* 82193BD4h */ case    3:  		/* lwz R30, <#[R4]> */
		/* 82193BD4h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + 0x00000000) );
		/* 82193BD4h case    3:*/		return 0x82193BD8;
		  /* 82193BD8h */ case    4:  		/* mr R29, R3 */
		/* 82193BD8h case    4:*/		regs.R29 = regs.R3;
		/* 82193BD8h case    4:*/		return 0x82193BDC;
		  /* 82193BDCh */ case    5:  		/* mr R28, R4 */
		/* 82193BDCh case    5:*/		regs.R28 = regs.R4;
		/* 82193BDCh case    5:*/		return 0x82193BE0;
		  /* 82193BE0h */ case    6:  		/* mr R27, R5 */
		/* 82193BE0h case    6:*/		regs.R27 = regs.R5;
		/* 82193BE0h case    6:*/		return 0x82193BE4;
		  /* 82193BE4h */ case    7:  		/* cmplwi CR6, R30, 0 */
		/* 82193BE4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82193BE4h case    7:*/		return 0x82193BE8;
		  /* 82193BE8h */ case    8:  		/* bc 12, CR6_EQ, 160 */
		/* 82193BE8h case    8:*/		if ( regs.CR[6].eq ) { return 0x82193C88;  }
		/* 82193BE8h case    8:*/		return 0x82193BEC;
		  /* 82193BECh */ case    9:  		/* lwz R31, <#[R30 + 12]> */
		/* 82193BECh case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x0000000C) );
		/* 82193BECh case    9:*/		return 0x82193BF0;
		  /* 82193BF0h */ case   10:  		/* lbz R11, <#[R31 + 16]> */
		/* 82193BF0h case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82193BF0h case   10:*/		return 0x82193BF4;
		  /* 82193BF4h */ case   11:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82193BF4h case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82193BF4h case   11:*/		return 0x82193BF8;
		  /* 82193BF8h */ case   12:  		/* bc 4, CR0_EQ, 128 */
		/* 82193BF8h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82193C78;  }
		/* 82193BF8h case   12:*/		return 0x82193BFC;
		  /* 82193BFCh */ case   13:  		/* mr R6, R31 */
		/* 82193BFCh case   13:*/		regs.R6 = regs.R31;
		/* 82193BFCh case   13:*/		return 0x82193C00;
		  /* 82193C00h */ case   14:  		/* mr R5, R28 */
		/* 82193C00h case   14:*/		regs.R5 = regs.R28;
		/* 82193C00h case   14:*/		return 0x82193C04;
		  /* 82193C04h */ case   15:  		/* mr R4, R30 */
		/* 82193C04h case   15:*/		regs.R4 = regs.R30;
		/* 82193C04h case   15:*/		return 0x82193C08;
		  /* 82193C08h */ case   16:  		/* addi R3, R29, 4 */
		/* 82193C08h case   16:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R29,0x4);
		/* 82193C08h case   16:*/		return 0x82193C0C;
		  /* 82193C0Ch */ case   17:  		/* bl -149644 */
		/* 82193C0Ch case   17:*/		regs.LR = 0x82193C10; return 0x8216F380;
		/* 82193C0Ch case   17:*/		return 0x82193C10;
		  /* 82193C10h */ case   18:  		/* rlwinm. R11, R27, 0, 24, 31 */
		/* 82193C10h case   18:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R27);
		/* 82193C10h case   18:*/		return 0x82193C14;
		  /* 82193C14h */ case   19:  		/* bc 12, CR0_EQ, 64 */
		/* 82193C14h case   19:*/		if ( regs.CR[0].eq ) { return 0x82193C54;  }
		/* 82193C14h case   19:*/		return 0x82193C18;
		  /* 82193C18h */ case   20:  		/* lwz R11, <#[R31 + 28]> */
		/* 82193C18h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 82193C18h case   20:*/		return 0x82193C1C;
		  /* 82193C1Ch */ case   21:  		/* addi R10, R11, 32 */
		/* 82193C1Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x20);
		/* 82193C1Ch case   21:*/		return 0x82193C20;
		  /* 82193C20h */ case   22:  		/* lwz R11, <#[R11 + 36]> */
		/* 82193C20h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82193C20h case   22:*/		return 0x82193C24;
		  /* 82193C24h */ case   23:  		/* b 20 */
		/* 82193C24h case   23:*/		return 0x82193C38;
		/* 82193C24h case   23:*/		return 0x82193C28;
		  /* 82193C28h */ case   24:  		/* addi R9, R11, -36 */
		/* 82193C28h case   24:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFDC);
		/* 82193C28h case   24:*/		return 0x82193C2C;
		  /* 82193C2Ch */ case   25:  		/* cmplw CR6, R31, R9 */
		/* 82193C2Ch case   25:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R9);
		/* 82193C2Ch case   25:*/		return 0x82193C30;
		  /* 82193C30h */ case   26:  		/* bc 12, CR6_EQ, 80 */
		/* 82193C30h case   26:*/		if ( regs.CR[6].eq ) { return 0x82193C80;  }
		/* 82193C30h case   26:*/		return 0x82193C34;
		  /* 82193C34h */ case   27:  		/* lwz R11, <#[R11 + 4]> */
		/* 82193C34h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82193C34h case   27:*/		return 0x82193C38;
	}
	return 0x82193C38;
} // Block from 82193BC8h-82193C38h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82193C38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193C38);
		  /* 82193C38h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82193C38h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82193C38h case    0:*/		return 0x82193C3C;
		  /* 82193C3Ch */ case    1:  		/* addi R11, R11, 36 */
		/* 82193C3Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82193C3Ch case    1:*/		return 0x82193C40;
		  /* 82193C40h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 82193C40h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82193C40h case    2:*/		return 0x82193C44;
		  /* 82193C44h */ case    3:  		/* bc 4, CR6_EQ, -28 */
		/* 82193C44h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82193C28;  }
		/* 82193C44h case    3:*/		return 0x82193C48;
		  /* 82193C48h */ case    4:  		/* li R11, 0 */
		/* 82193C48h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82193C48h case    4:*/		return 0x82193C4C;
		  /* 82193C4Ch */ case    5:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82193C4Ch case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82193C4Ch case    5:*/		return 0x82193C50;
		  /* 82193C50h */ case    6:  		/* bc 4, CR0_EQ, 40 */
		/* 82193C50h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82193C78;  }
		/* 82193C50h case    6:*/		return 0x82193C54;
	}
	return 0x82193C54;
} // Block from 82193C38h-82193C54h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82193C54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193C54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193C54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193C54);
		  /* 82193C54h */ case    0:  		/* li R5, 0 */
		/* 82193C54h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82193C54h case    0:*/		return 0x82193C58;
		  /* 82193C58h */ case    1:  		/* mr R4, R31 */
		/* 82193C58h case    1:*/		regs.R4 = regs.R31;
		/* 82193C58h case    1:*/		return 0x82193C5C;
		  /* 82193C5Ch */ case    2:  		/* mr R3, R29 */
		/* 82193C5Ch case    2:*/		regs.R3 = regs.R29;
		/* 82193C5Ch case    2:*/		return 0x82193C60;
		  /* 82193C60h */ case    3:  		/* bl -16400 */
		/* 82193C60h case    3:*/		regs.LR = 0x82193C64; return 0x8218FC50;
		/* 82193C60h case    3:*/		return 0x82193C64;
		  /* 82193C64h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82193C64h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82193C64h case    4:*/		return 0x82193C68;
		  /* 82193C68h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 82193C68h case    5:*/		if ( regs.CR[0].eq ) { return 0x82193C78;  }
		/* 82193C68h case    5:*/		return 0x82193C6C;
		  /* 82193C6Ch */ case    6:  		/* mr R4, R31 */
		/* 82193C6Ch case    6:*/		regs.R4 = regs.R31;
		/* 82193C6Ch case    6:*/		return 0x82193C70;
		  /* 82193C70h */ case    7:  		/* mr R3, R29 */
		/* 82193C70h case    7:*/		regs.R3 = regs.R29;
		/* 82193C70h case    7:*/		return 0x82193C74;
		  /* 82193C74h */ case    8:  		/* bl -6820 */
		/* 82193C74h case    8:*/		regs.LR = 0x82193C78; return 0x821921D0;
		/* 82193C74h case    8:*/		return 0x82193C78;
	}
	return 0x82193C78;
} // Block from 82193C54h-82193C78h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82193C78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193C78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193C78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193C78);
		  /* 82193C78h */ case    0:  		/* lwz R30, <#[R30 + 4]> */
		/* 82193C78h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 82193C78h case    0:*/		return 0x82193C7C;
		  /* 82193C7Ch */ case    1:  		/* b -152 */
		/* 82193C7Ch case    1:*/		return 0x82193BE4;
		/* 82193C7Ch case    1:*/		return 0x82193C80;
	}
	return 0x82193C80;
} // Block from 82193C78h-82193C80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82193C80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193C80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193C80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193C80);
		  /* 82193C80h */ case    0:  		/* li R11, 1 */
		/* 82193C80h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82193C80h case    0:*/		return 0x82193C84;
		  /* 82193C84h */ case    1:  		/* b -56 */
		/* 82193C84h case    1:*/		return 0x82193C4C;
		/* 82193C84h case    1:*/		return 0x82193C88;
	}
	return 0x82193C88;
} // Block from 82193C80h-82193C88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82193C88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193C88);
		  /* 82193C88h */ case    0:  		/* addi R1, R1, 128 */
		/* 82193C88h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82193C88h case    0:*/		return 0x82193C8C;
		  /* 82193C8Ch */ case    1:  		/* b -1059304 */
		/* 82193C8Ch case    1:*/		return 0x820912A4;
		/* 82193C8Ch case    1:*/		return 0x82193C90;
	}
	return 0x82193C90;
} // Block from 82193C88h-82193C90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82193C90h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193C90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193C90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193C90);
		  /* 82193C90h */ case    0:  		/* mfspr R12, LR */
		/* 82193C90h case    0:*/		regs.R12 = regs.LR;
		/* 82193C90h case    0:*/		return 0x82193C94;
		  /* 82193C94h */ case    1:  		/* bl -1059440 */
		/* 82193C94h case    1:*/		regs.LR = 0x82193C98; return 0x82091224;
		/* 82193C94h case    1:*/		return 0x82193C98;
		  /* 82193C98h */ case    2:  		/* stfd FR31, <#[R1 - 152]> */
		/* 82193C98h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF68) );
		/* 82193C98h case    2:*/		return 0x82193C9C;
		  /* 82193C9Ch */ case    3:  		/* stwu R1, <#[R1 - 240]> */
		/* 82193C9Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 82193C9Ch case    3:*/		return 0x82193CA0;
		  /* 82193CA0h */ case    4:  		/* lwz R11, <#[R4 + 8]> */
		/* 82193CA0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 82193CA0h case    4:*/		return 0x82193CA4;
		  /* 82193CA4h */ case    5:  		/* mr R25, R3 */
		/* 82193CA4h case    5:*/		regs.R25 = regs.R3;
		/* 82193CA4h case    5:*/		return 0x82193CA8;
		  /* 82193CA8h */ case    6:  		/* mr R24, R4 */
		/* 82193CA8h case    6:*/		regs.R24 = regs.R4;
		/* 82193CA8h case    6:*/		return 0x82193CAC;
		  /* 82193CACh */ case    7:  		/* rlwinm R9, R11, 25, 25, 31 */
		/* 82193CACh case    7:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R9,regs.R11);
		/* 82193CACh case    7:*/		return 0x82193CB0;
		  /* 82193CB0h */ case    8:  		/* mr R17, R5 */
		/* 82193CB0h case    8:*/		regs.R17 = regs.R5;
		/* 82193CB0h case    8:*/		return 0x82193CB4;
		  /* 82193CB4h */ case    9:  		/* addi R11, R9, -1 */
		/* 82193CB4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 82193CB4h case    9:*/		return 0x82193CB8;
		  /* 82193CB8h */ case   10:  		/* cmplwi CR6, R11, 27 */
		/* 82193CB8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001B);
		/* 82193CB8h case   10:*/		return 0x82193CBC;
		  /* 82193CBCh */ case   11:  		/* bc 12, CR6_GT, 1516 */
		/* 82193CBCh case   11:*/		if ( regs.CR[6].gt ) { return 0x821942A8;  }
		/* 82193CBCh case   11:*/		return 0x82193CC0;
	}
	return 0x82193CC0;
} // Block from 82193C90h-82193CC0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82193CC0h
// Function '?SmashMultipleSourceBinary@Compiler@D3DXShader@@AAAXPAVInstruction@2@W4Opcode@2@PAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193CC0);
		  /* 82193CC0h */ case    0:  		/* lis R12, -32252 */
		/* 82193CC0h case    0:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8204);
		/* 82193CC0h case    0:*/		return 0x82193CC4;
		  /* 82193CC4h */ case    1:  		/* rlwinm R0, R11, 1, 0, 30 */
		/* 82193CC4h case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R0,regs.R11);
		/* 82193CC4h case    1:*/		return 0x82193CC8;
		  /* 82193CC8h */ case    2:  		/* addi R12, R12, -16792 */
		/* 82193CC8h case    2:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFBE68);
		/* 82193CC8h case    2:*/		return 0x82193CCC;
		  /* 82193CCCh */ case    3:  		/* lhzx R0, <#[R12 + R0]> */
		/* 82193CCCh case    3:*/		cpu::mem::load16z( regs, &regs.R0, (uint32)(regs.R12 + regs.R0 + 0x00000000) );
		/* 82193CCCh case    3:*/		return 0x82193CD0;
		  /* 82193CD0h */ case    4:  		/* lis R12, -32231 */
		/* 82193CD0h case    4:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8219);
		/* 82193CD0h case    4:*/		return 0x82193CD4;
		  /* 82193CD4h */ case    5:  		/* addi R12, R12, 15592 */
		/* 82193CD4h case    5:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x3CE8);
		/* 82193CD4h case    5:*/		return 0x82193CD8;
		  /* 82193CD8h */ case    6:  		/* ori R0, R0, 0 */
		/* 82193CD8h case    6:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82193CD8h case    6:*/		return 0x82193CDC;
		  /* 82193CDCh */ case    7:  		/* add R12, R12, R0 */
		/* 82193CDCh case    7:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 82193CDCh case    7:*/		return 0x82193CE0;
		  /* 82193CE0h */ case    8:  		/* mtspr CTR, R12 */
		/* 82193CE0h case    8:*/		regs.CTR = regs.R12;
		/* 82193CE0h case    8:*/		return 0x82193CE4;
		  /* 82193CE4h */ case    9:  		/* bcctr 20, CR0_LT */
		/* 82193CE4h case    9:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82193CE4h case    9:*/		return 0x82193CE8;
		  /* 82193CE8h */ case   10:  		/* lwz R20, <#[R24 + 48]> */
		/* 82193CE8h case   10:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R24 + 0x00000030) );
		/* 82193CE8h case   10:*/		return 0x82193CEC;
		  /* 82193CECh */ case   11:  		/* li R18, 1 */
		/* 82193CECh case   11:*/		cpu::op::li<0>(regs,&regs.R18,0x1);
		/* 82193CECh case   11:*/		return 0x82193CF0;
		  /* 82193CF0h */ case   12:  		/* lwz R26, <#[R24 + 44]> */
		/* 82193CF0h case   12:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R24 + 0x0000002C) );
		/* 82193CF0h case   12:*/		return 0x82193CF4;
		  /* 82193CF4h */ case   13:  		/* lwz R22, <#[R24 + 28]> */
		/* 82193CF4h case   13:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R24 + 0x0000001C) );
		/* 82193CF4h case   13:*/		return 0x82193CF8;
		  /* 82193CF8h */ case   14:  		/* stb R18, <#[R1 + 80]> */
		/* 82193CF8h case   14:*/		cpu::mem::store8( regs, regs.R18, (uint32)(regs.R1 + 0x00000050) );
		/* 82193CF8h case   14:*/		return 0x82193CFC;
		  /* 82193CFCh */ case   15:  		/* lwz R16, <#[R20 + 12]> */
		/* 82193CFCh case   15:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R20 + 0x0000000C) );
		/* 82193CFCh case   15:*/		return 0x82193D00;
		  /* 82193D00h */ case   16:  		/* lwz R19, <#[R26 + 12]> */
		/* 82193D00h case   16:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R26 + 0x0000000C) );
		/* 82193D00h case   16:*/		return 0x82193D04;
		  /* 82193D04h */ case   17:  		/* lwz R11, <#[R16 + 8]> */
		/* 82193D04h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 82193D04h case   17:*/		return 0x82193D08;
		  /* 82193D08h */ case   18:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82193D08h case   18:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82193D08h case   18:*/		return 0x82193D0C;
		  /* 82193D0Ch */ case   19:  		/* cmplwi CR6, R11, 125 */
		/* 82193D0Ch case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82193D0Ch case   19:*/		return 0x82193D10;
		  /* 82193D10h */ case   20:  		/* bc 12, CR6_EQ, 16 */
		/* 82193D10h case   20:*/		if ( regs.CR[6].eq ) { return 0x82193D20;  }
		/* 82193D10h case   20:*/		return 0x82193D14;
		  /* 82193D14h */ case   21:  		/* cmplwi CR6, R11, 124 */
		/* 82193D14h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82193D14h case   21:*/		return 0x82193D18;
		  /* 82193D18h */ case   22:  		/* li R11, 0 */
		/* 82193D18h case   22:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82193D18h case   22:*/		return 0x82193D1C;
		  /* 82193D1Ch */ case   23:  		/* bc 4, CR6_EQ, 8 */
		/* 82193D1Ch case   23:*/		if ( !regs.CR[6].eq ) { return 0x82193D24;  }
		/* 82193D1Ch case   23:*/		return 0x82193D20;
	}
	return 0x82193D20;
} // Block from 82193CC0h-82193D20h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82193D20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193D20);
		  /* 82193D20h */ case    0:  		/* mr R11, R18 */
		/* 82193D20h case    0:*/		regs.R11 = regs.R18;
		/* 82193D20h case    0:*/		return 0x82193D24;
	}
	return 0x82193D24;
} // Block from 82193D20h-82193D24h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82193D24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193D24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193D24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193D24);
		  /* 82193D24h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82193D24h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82193D24h case    0:*/		return 0x82193D28;
		  /* 82193D28h */ case    1:  		/* bc 12, CR0_EQ, 804 */
		/* 82193D28h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219404C;  }
		/* 82193D28h case    1:*/		return 0x82193D2C;
		  /* 82193D2Ch */ case    2:  		/* lwz R11, <#[R19 + 8]> */
		/* 82193D2Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000008) );
		/* 82193D2Ch case    2:*/		return 0x82193D30;
		  /* 82193D30h */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82193D30h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82193D30h case    3:*/		return 0x82193D34;
		  /* 82193D34h */ case    4:  		/* cmplwi CR6, R11, 125 */
		/* 82193D34h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82193D34h case    4:*/		return 0x82193D38;
		  /* 82193D38h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 82193D38h case    5:*/		if ( regs.CR[6].eq ) { return 0x82193D48;  }
		/* 82193D38h case    5:*/		return 0x82193D3C;
		  /* 82193D3Ch */ case    6:  		/* cmplwi CR6, R11, 124 */
		/* 82193D3Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82193D3Ch case    6:*/		return 0x82193D40;
		  /* 82193D40h */ case    7:  		/* li R11, 0 */
		/* 82193D40h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82193D40h case    7:*/		return 0x82193D44;
		  /* 82193D44h */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 82193D44h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82193D4C;  }
		/* 82193D44h case    8:*/		return 0x82193D48;
	}
	return 0x82193D48;
} // Block from 82193D24h-82193D48h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82193D48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193D48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193D48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193D48);
		  /* 82193D48h */ case    0:  		/* mr R11, R18 */
		/* 82193D48h case    0:*/		regs.R11 = regs.R18;
		/* 82193D48h case    0:*/		return 0x82193D4C;
	}
	return 0x82193D4C;
} // Block from 82193D48h-82193D4Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82193D4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193D4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193D4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193D4C);
		  /* 82193D4Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82193D4Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82193D4Ch case    0:*/		return 0x82193D50;
		  /* 82193D50h */ case    1:  		/* bc 4, CR0_EQ, 764 */
		/* 82193D50h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219404C;  }
		/* 82193D50h case    1:*/		return 0x82193D54;
		  /* 82193D54h */ case    2:  		/* lwz R11, <#[R20]> */
		/* 82193D54h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 82193D54h case    2:*/		return 0x82193D58;
		  /* 82193D58h */ case    3:  		/* lwz R10, <#[R26]> */
		/* 82193D58h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 82193D58h case    3:*/		return 0x82193D5C;
		  /* 82193D5Ch */ case    4:  		/* xor R8, R10, R11 */
		/* 82193D5Ch case    4:*/		cpu::op::xor<0>(regs,&regs.R8,regs.R10,regs.R11);
		/* 82193D5Ch case    4:*/		return 0x82193D60;
		  /* 82193D60h */ case    5:  		/* rlwinm. R8, R8, 0, 27, 30 */
		/* 82193D60h case    5:*/		cpu::op::rlwinm<1,0,27,30>(regs,&regs.R8,regs.R8);
		/* 82193D60h case    5:*/		return 0x82193D64;
		  /* 82193D64h */ case    6:  		/* bc 12, CR0_EQ, 28 */
		/* 82193D64h case    6:*/		if ( regs.CR[0].eq ) { return 0x82193D80;  }
		/* 82193D64h case    6:*/		return 0x82193D68;
		  /* 82193D68h */ case    7:  		/* cmplwi CR6, R9, 1 */
		/* 82193D68h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 82193D68h case    7:*/		return 0x82193D6C;
		  /* 82193D6Ch */ case    8:  		/* bc 4, CR6_EQ, 736 */
		/* 82193D6Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x8219404C;  }
		/* 82193D6Ch case    8:*/		return 0x82193D70;
		  /* 82193D70h */ case    9:  		/* xor R11, R10, R11 */
		/* 82193D70h case    9:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82193D70h case    9:*/		return 0x82193D74;
		  /* 82193D74h */ case   10:  		/* andi. R11, R11, 26 */
		/* 82193D74h case   10:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x1A);
		/* 82193D74h case   10:*/		return 0x82193D78;
		  /* 82193D78h */ case   11:  		/* cmplwi CR0, R11, 0 */
		/* 82193D78h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82193D78h case   11:*/		return 0x82193D7C;
		  /* 82193D7Ch */ case   12:  		/* bc 4, CR0_EQ, 720 */
		/* 82193D7Ch case   12:*/		if ( !regs.CR[0].eq ) { return 0x8219404C;  }
		/* 82193D7Ch case   12:*/		return 0x82193D80;
	}
	return 0x82193D80;
} // Block from 82193D4Ch-82193D80h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82193D80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193D80);
		  /* 82193D80h */ case    0:  		/* addi R4, R1, 80 */
		/* 82193D80h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82193D80h case    0:*/		return 0x82193D84;
		  /* 82193D84h */ case    1:  		/* mr R3, R24 */
		/* 82193D84h case    1:*/		regs.R3 = regs.R24;
		/* 82193D84h case    1:*/		return 0x82193D88;
		  /* 82193D88h */ case    2:  		/* bl -15160 */
		/* 82193D88h case    2:*/		regs.LR = 0x82193D8C; return 0x82190250;
		/* 82193D88h case    2:*/		return 0x82193D8C;
		  /* 82193D8Ch */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82193D8Ch case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82193D8Ch case    3:*/		return 0x82193D90;
		  /* 82193D90h */ case    4:  		/* bc 12, CR0_EQ, 700 */
		/* 82193D90h case    4:*/		if ( regs.CR[0].eq ) { return 0x8219404C;  }
		/* 82193D90h case    4:*/		return 0x82193D94;
		  /* 82193D94h */ case    5:  		/* lwz R11, <#[R25 + 44]> */
		/* 82193D94h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000002C) );
		/* 82193D94h case    5:*/		return 0x82193D98;
		  /* 82193D98h */ case    6:  		/* lwz R10, <#[R24 + 8]> */
		/* 82193D98h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000008) );
		/* 82193D98h case    6:*/		return 0x82193D9C;
		  /* 82193D9Ch */ case    7:  		/* rlwinm. R11, R11, 25, 31, 31 */
		/* 82193D9Ch case    7:*/		cpu::op::rlwinm<1,25,31,31>(regs,&regs.R11,regs.R11);
		/* 82193D9Ch case    7:*/		return 0x82193DA0;
		  /* 82193DA0h */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 82193DA0h case    8:*/		if ( regs.CR[0].eq ) { return 0x82193DB4;  }
		/* 82193DA0h case    8:*/		return 0x82193DA4;
		  /* 82193DA4h */ case    9:  		/* rlwinm R11, R10, 18, 29, 31 */
		/* 82193DA4h case    9:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R10);
		/* 82193DA4h case    9:*/		return 0x82193DA8;
		  /* 82193DA8h */ case   10:  		/* slw R11, R18, R11 */
		/* 82193DA8h case   10:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R18,regs.R11);
		/* 82193DA8h case   10:*/		return 0x82193DAC;
		  /* 82193DACh */ case   11:  		/* addi R30, R11, -1 */
		/* 82193DACh case   11:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFFF);
		/* 82193DACh case   11:*/		return 0x82193DB0;
		  /* 82193DB0h */ case   12:  		/* b 8 */
		/* 82193DB0h case   12:*/		return 0x82193DB8;
		/* 82193DB0h case   12:*/		return 0x82193DB4;
	}
	return 0x82193DB4;
} // Block from 82193D80h-82193DB4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82193DB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193DB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193DB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193DB4);
		  /* 82193DB4h */ case    0:  		/* rlwinm R30, R10, 31, 28, 31 */
		/* 82193DB4h case    0:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R30,regs.R10);
		/* 82193DB4h case    0:*/		return 0x82193DB8;
	}
	return 0x82193DB8;
} // Block from 82193DB4h-82193DB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82193DB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193DB8);
		  /* 82193DB8h */ case    0:  		/* li R21, 0 */
		/* 82193DB8h case    0:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 82193DB8h case    0:*/		return 0x82193DBC;
		  /* 82193DBCh */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 82193DBCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82193DBCh case    1:*/		return 0x82193DC0;
		  /* 82193DC0h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 82193DC0h case    2:*/		if ( regs.CR[6].eq ) { return 0x82193DD8;  }
		/* 82193DC0h case    2:*/		return 0x82193DC4;
		  /* 82193DC4h */ case    3:  		/* addi R11, R30, -1 */
		/* 82193DC4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFFF);
		/* 82193DC4h case    3:*/		return 0x82193DC8;
		  /* 82193DC8h */ case    4:  		/* andc R11, R30, R11 */
		/* 82193DC8h case    4:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 82193DC8h case    4:*/		return 0x82193DCC;
		  /* 82193DCCh */ case    5:  		/* subf. R11, R11, R30 */
		/* 82193DCCh case    5:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82193DCCh case    5:*/		return 0x82193DD0;
		  /* 82193DD0h */ case    6:  		/* mr R11, R18 */
		/* 82193DD0h case    6:*/		regs.R11 = regs.R18;
		/* 82193DD0h case    6:*/		return 0x82193DD4;
		  /* 82193DD4h */ case    7:  		/* bc 12, CR0_EQ, 8 */
		/* 82193DD4h case    7:*/		if ( regs.CR[0].eq ) { return 0x82193DDC;  }
		/* 82193DD4h case    7:*/		return 0x82193DD8;
	}
	return 0x82193DD8;
} // Block from 82193DB8h-82193DD8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82193DD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193DD8);
		  /* 82193DD8h */ case    0:  		/* li R11, 0 */
		/* 82193DD8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82193DD8h case    0:*/		return 0x82193DDC;
	}
	return 0x82193DDC;
} // Block from 82193DD8h-82193DDCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82193DDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193DDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193DDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193DDC);
		  /* 82193DDCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82193DDCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82193DDCh case    0:*/		return 0x82193DE0;
		  /* 82193DE0h */ case    1:  		/* bc 4, CR0_EQ, 72 */
		/* 82193DE0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82193E28;  }
		/* 82193DE0h case    1:*/		return 0x82193DE4;
		  /* 82193DE4h */ case    2:  		/* rlwinm. R11, R10, 27, 31, 31 */
		/* 82193DE4h case    2:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R10);
		/* 82193DE4h case    2:*/		return 0x82193DE8;
		  /* 82193DE8h */ case    3:  		/* bc 4, CR0_EQ, 64 */
		/* 82193DE8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82193E28;  }
		/* 82193DE8h case    3:*/		return 0x82193DEC;
		  /* 82193DECh */ case    4:  		/* lis R11, -28311 */
		/* 82193DECh case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF9169);
		/* 82193DECh case    4:*/		return 0x82193DF0;
		  /* 82193DF0h */ case    5:  		/* lis R10, 0 */
		/* 82193DF0h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 82193DF0h case    5:*/		return 0x82193DF4;
		  /* 82193DF4h */ case    6:  		/* ori R11, R11, 5192 */
		/* 82193DF4h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1448);
		/* 82193DF4h case    6:*/		return 0x82193DF8;
		  /* 82193DF8h */ case    7:  		/* ori R10, R10, 36262 */
		/* 82193DF8h case    7:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8DA6);
		/* 82193DF8h case    7:*/		return 0x82193DFC;
		  /* 82193DFCh */ case    8:  		/* rldicl R9, R30, 0, 32 */
		/* 82193DFCh case    8:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R30);
		/* 82193DFCh case    8:*/		return 0x82193E00;
		  /* 82193E00h */ case    9:  		/* rldimi R11, R10, 32, 0 */
		/* 82193E00h case    9:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R11,regs.R10);
		/* 82193E00h case    9:*/		return 0x82193E04;
		  /* 82193E04h */ case   10:  		/* li R5, 0 */
		/* 82193E04h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82193E04h case   10:*/		return 0x82193E08;
		  /* 82193E08h */ case   11:  		/* srd R11, R11, R9 */
		/* 82193E08h case   11:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82193E08h case   11:*/		return 0x82193E0C;
		  /* 82193E0Ch */ case   12:  		/* srd R11, R11, R9 */
		/* 82193E0Ch case   12:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82193E0Ch case   12:*/		return 0x82193E10;
		  /* 82193E10h */ case   13:  		/* srd R11, R11, R9 */
		/* 82193E10h case   13:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82193E10h case   13:*/		return 0x82193E14;
		  /* 82193E14h */ case   14:  		/* mr R4, R22 */
		/* 82193E14h case   14:*/		regs.R4 = regs.R22;
		/* 82193E14h case   14:*/		return 0x82193E18;
		  /* 82193E18h */ case   15:  		/* rlwinm R6, R11, 0, 29, 31 */
		/* 82193E18h case   15:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R6,regs.R11);
		/* 82193E18h case   15:*/		return 0x82193E1C;
		  /* 82193E1Ch */ case   16:  		/* mr R3, R25 */
		/* 82193E1Ch case   16:*/		regs.R3 = regs.R25;
		/* 82193E1Ch case   16:*/		return 0x82193E20;
		  /* 82193E20h */ case   17:  		/* bl 593120 */
		/* 82193E20h case   17:*/		regs.LR = 0x82193E24; return 0x82224B00;
		/* 82193E20h case   17:*/		return 0x82193E24;
		  /* 82193E24h */ case   18:  		/* mr R21, R3 */
		/* 82193E24h case   18:*/		regs.R21 = regs.R3;
		/* 82193E24h case   18:*/		return 0x82193E28;
	}
	return 0x82193E28;
} // Block from 82193DDCh-82193E28h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82193E28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193E28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193E28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193E28);
		  /* 82193E28h */ case    0:  		/* li R23, 0 */
		/* 82193E28h case    0:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82193E28h case    0:*/		return 0x82193E2C;
		  /* 82193E2Ch */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 82193E2Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82193E2Ch case    1:*/		return 0x82193E30;
		  /* 82193E30h */ case    2:  		/* bc 12, CR6_EQ, 476 */
		/* 82193E30h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219400C;  }
		/* 82193E30h case    2:*/		return 0x82193E34;
		  /* 82193E34h */ case    3:  		/* lbz R27, <#[R1 + 80]> */
		/* 82193E34h case    3:*/		cpu::mem::load8z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000050) );
		/* 82193E34h case    3:*/		return 0x82193E38;
		  /* 82193E38h */ case    4:  		/* addi R11, R30, -1 */
		/* 82193E38h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFFF);
		/* 82193E38h case    4:*/		return 0x82193E3C;
		  /* 82193E3Ch */ case    5:  		/* lwz R10, <#[R20]> */
		/* 82193E3Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x00000000) );
		/* 82193E3Ch case    5:*/		return 0x82193E40;
		  /* 82193E40h */ case    6:  		/* mr R4, R16 */
		/* 82193E40h case    6:*/		regs.R4 = regs.R16;
		/* 82193E40h case    6:*/		return 0x82193E44;
		  /* 82193E44h */ case    7:  		/* andc R11, R30, R11 */
		/* 82193E44h case    7:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 82193E44h case    7:*/		return 0x82193E48;
		  /* 82193E48h */ case    8:  		/* rlwinm R9, R10, 27, 24, 31 */
		/* 82193E48h case    8:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R10);
		/* 82193E48h case    8:*/		return 0x82193E4C;
		  /* 82193E4Ch */ case    9:  		/* cntlzw R8, R11 */
		/* 82193E4Ch case    9:*/		cpu::op::cntlzw<0>(regs,&regs.R8,regs.R11);
		/* 82193E4Ch case    9:*/		return 0x82193E50;
		  /* 82193E50h */ case   10:  		/* subf R30, R11, R30 */
		/* 82193E50h case   10:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R11,regs.R30);
		/* 82193E50h case   10:*/		return 0x82193E54;
		  /* 82193E54h */ case   11:  		/* subfic R28, R8, 31 */
		/* 82193E54h case   11:*/		cpu::op::subfic<0>(regs,&regs.R28,regs.R8,0x1F);
		/* 82193E54h case   11:*/		return 0x82193E58;
		  /* 82193E58h */ case   12:  		/* rlwinm R6, R10, 0, 27, 31 */
		/* 82193E58h case   12:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R6,regs.R10);
		/* 82193E58h case   12:*/		return 0x82193E5C;
		  /* 82193E5Ch */ case   13:  		/* rlwinm R31, R28, 1, 0, 30 */
		/* 82193E5Ch case   13:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R31,regs.R28);
		/* 82193E5Ch case   13:*/		return 0x82193E60;
		  /* 82193E60h */ case   14:  		/* mr R3, R25 */
		/* 82193E60h case   14:*/		regs.R3 = regs.R25;
		/* 82193E60h case   14:*/		return 0x82193E64;
		  /* 82193E64h */ case   15:  		/* srw R11, R9, R31 */
		/* 82193E64h case   15:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R9,regs.R31);
		/* 82193E64h case   15:*/		return 0x82193E68;
		  /* 82193E68h */ case   16:  		/* rlwinm R5, R11, 0, 30, 31 */
		/* 82193E68h case   16:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R5,regs.R11);
		/* 82193E68h case   16:*/		return 0x82193E6C;
		  /* 82193E6Ch */ case   17:  		/* bl -113924 */
		/* 82193E6Ch case   17:*/		regs.LR = 0x82193E70; return 0x82178168;
		/* 82193E6Ch case   17:*/		return 0x82193E70;
		  /* 82193E70h */ case   18:  		/* lwz R11, <#[R26]> */
		/* 82193E70h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82193E70h case   18:*/		return 0x82193E74;
		  /* 82193E74h */ case   19:  		/* rlwinm. R10, R27, 0, 24, 31 */
		/* 82193E74h case   19:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R27);
		/* 82193E74h case   19:*/		return 0x82193E78;
		  /* 82193E78h */ case   20:  		/* rlwinm R9, R11, 27, 24, 31 */
		/* 82193E78h case   20:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R11);
		/* 82193E78h case   20:*/		return 0x82193E7C;
		  /* 82193E7Ch */ case   21:  		/* mr R29, R3 */
		/* 82193E7Ch case   21:*/		regs.R29 = regs.R3;
		/* 82193E7Ch case   21:*/		return 0x82193E80;
		  /* 82193E80h */ case   22:  		/* srw R9, R9, R31 */
		/* 82193E80h case   22:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R9,regs.R31);
		/* 82193E80h case   22:*/		return 0x82193E84;
		  /* 82193E84h */ case   23:  		/* rlwinm R31, R9, 0, 30, 31 */
		/* 82193E84h case   23:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R31,regs.R9);
		/* 82193E84h case   23:*/		return 0x82193E88;
		  /* 82193E88h */ case   24:  		/* bc 12, CR0_EQ, 156 */
		/* 82193E88h case   24:*/		if ( regs.CR[0].eq ) { return 0x82193F24;  }
		/* 82193E88h case   24:*/		return 0x82193E8C;
		  /* 82193E8Ch */ case   25:  		/* lwz R10, <#[R19 + 8]> */
		/* 82193E8Ch case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R19 + 0x00000008) );
		/* 82193E8Ch case   25:*/		return 0x82193E90;
		  /* 82193E90h */ case   26:  		/* lis R9, 1 */
		/* 82193E90h case   26:*/		cpu::op::lis<0>(regs,&regs.R9,0x1);
		/* 82193E90h case   26:*/		return 0x82193E94;
		  /* 82193E94h */ case   27:  		/* rlwinm R10, R10, 0, 15, 17 */
		/* 82193E94h case   27:*/		cpu::op::rlwinm<0,0,15,17>(regs,&regs.R10,regs.R10);
		/* 82193E94h case   27:*/		return 0x82193E98;
		  /* 82193E98h */ case   28:  		/* cmplw CR6, R10, R9 */
		/* 82193E98h case   28:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82193E98h case   28:*/		return 0x82193E9C;
		  /* 82193E9Ch */ case   29:  		/* bc 4, CR6_EQ, 136 */
		/* 82193E9Ch case   29:*/		if ( !regs.CR[6].eq ) { return 0x82193F24;  }
		/* 82193E9Ch case   29:*/		return 0x82193EA0;
		  /* 82193EA0h */ case   30:  		/* mr R4, R19 */
		/* 82193EA0h case   30:*/		regs.R4 = regs.R19;
		/* 82193EA0h case   30:*/		return 0x82193EA4;
		  /* 82193EA4h */ case   31:  		/* mr R3, R25 */
		/* 82193EA4h case   31:*/		regs.R3 = regs.R25;
		/* 82193EA4h case   31:*/		return 0x82193EA8;
		  /* 82193EA8h */ case   32:  		/* rlwinm R27, R11, 0, 31, 31 */
		/* 82193EA8h case   32:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R27,regs.R11);
		/* 82193EA8h case   32:*/		return 0x82193EAC;
		  /* 82193EACh */ case   33:  		/* bl -114348 */
		/* 82193EACh case   33:*/		regs.LR = 0x82193EB0; return 0x82178000;
		/* 82193EACh case   33:*/		return 0x82193EB0;
		  /* 82193EB0h */ case   34:  		/* lwz R11, <#[R3]> */
		/* 82193EB0h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82193EB0h case   34:*/		return 0x82193EB4;
		  /* 82193EB4h */ case   35:  		/* mr R4, R27 */
		/* 82193EB4h case   35:*/		regs.R4 = regs.R27;
		/* 82193EB4h case   35:*/		return 0x82193EB8;
		  /* 82193EB8h */ case   36:  		/* rlwimi R11, R18, 26, 4, 6 */
		/* 82193EB8h case   36:*/		cpu::op::rlwimi<0,26,4,6>(regs,&regs.R11,regs.R18);
		/* 82193EB8h case   36:*/		return 0x82193EBC;
		  /* 82193EBCh */ case   37:  		/* mr R15, R3 */
		/* 82193EBCh case   37:*/		regs.R15 = regs.R3;
		/* 82193EBCh case   37:*/		return 0x82193EC0;
		  /* 82193EC0h */ case   38:  		/* stw R11, <#[R3]> */
		/* 82193EC0h case   38:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82193EC0h case   38:*/		return 0x82193EC4;
		  /* 82193EC4h */ case   39:  		/* bl -115716 */
		/* 82193EC4h case   39:*/		regs.LR = 0x82193EC8; return 0x82177AC0;
		/* 82193EC4h case   39:*/		return 0x82193EC8;
		  /* 82193EC8h */ case   40:  		/* li R11, 224 */
		/* 82193EC8h case   40:*/		cpu::op::li<0>(regs,&regs.R11,0xE0);
		/* 82193EC8h case   40:*/		return 0x82193ECC;
		  /* 82193ECCh */ case   41:  		/* rlwinm R10, R31, 0, 27, 31 */
		/* 82193ECCh case   41:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R31);
		/* 82193ECCh case   41:*/		return 0x82193ED0;
		  /* 82193ED0h */ case   42:  		/* rlwimi R11, R31, 2, 27, 29 */
		/* 82193ED0h case   42:*/		cpu::op::rlwimi<0,2,27,29>(regs,&regs.R11,regs.R31);
		/* 82193ED0h case   42:*/		return 0x82193ED4;
		  /* 82193ED4h */ case   43:  		/* mr R5, R17 */
		/* 82193ED4h case   43:*/		regs.R5 = regs.R17;
		/* 82193ED4h case   43:*/		return 0x82193ED8;
		  /* 82193ED8h */ case   44:  		/* or R11, R11, R10 */
		/* 82193ED8h case   44:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82193ED8h case   44:*/		return 0x82193EDC;
		  /* 82193EDCh */ case   45:  		/* mr R4, R22 */
		/* 82193EDCh case   45:*/		regs.R4 = regs.R22;
		/* 82193EDCh case   45:*/		return 0x82193EE0;
		  /* 82193EE0h */ case   46:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 82193EE0h case   46:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 82193EE0h case   46:*/		return 0x82193EE4;
		  /* 82193EE4h */ case   47:  		/* mr R3, R25 */
		/* 82193EE4h case   47:*/		regs.R3 = regs.R25;
		/* 82193EE4h case   47:*/		return 0x82193EE8;
		  /* 82193EE8h */ case   48:  		/* mr R6, R15 */
		/* 82193EE8h case   48:*/		regs.R6 = regs.R15;
		/* 82193EE8h case   48:*/		return 0x82193EEC;
		  /* 82193EECh */ case   49:  		/* lwz R10, <#[R15]> */
		/* 82193EECh case   49:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R15 + 0x00000000) );
		/* 82193EECh case   49:*/		return 0x82193EF0;
		  /* 82193EF0h */ case   50:  		/* rlwinm R10, R10, 0, 27, 21 */
		/* 82193EF0h case   50:*/		cpu::op::rlwinm<0,0,27,21>(regs,&regs.R10,regs.R10);
		/* 82193EF0h case   50:*/		return 0x82193EF4;
		  /* 82193EF4h */ case   51:  		/* or R11, R11, R10 */
		/* 82193EF4h case   51:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82193EF4h case   51:*/		return 0x82193EF8;
		  /* 82193EF8h */ case   52:  		/* stw R11, <#[R15]> */
		/* 82193EF8h case   52:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 82193EF8h case   52:*/		return 0x82193EFC;
		  /* 82193EFCh */ case   53:  		/* bl -9124 */
		/* 82193EFCh case   53:*/		regs.LR = 0x82193F00; return 0x82191B58;
		/* 82193EFCh case   53:*/		return 0x82193F00;
		  /* 82193F00h */ case   54:  		/* lwz R11, <#[R26]> */
		/* 82193F00h case   54:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82193F00h case   54:*/		return 0x82193F04;
		  /* 82193F04h */ case   55:  		/* mr R4, R3 */
		/* 82193F04h case   55:*/		regs.R4 = regs.R3;
		/* 82193F04h case   55:*/		return 0x82193F08;
		  /* 82193F08h */ case   56:  		/* rlwinm R6, R11, 0, 27, 30 */
		/* 82193F08h case   56:*/		cpu::op::rlwinm<0,0,27,30>(regs,&regs.R6,regs.R11);
		/* 82193F08h case   56:*/		return 0x82193F0C;
		  /* 82193F0Ch */ case   57:  		/* li R5, 0 */
		/* 82193F0Ch case   57:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82193F0Ch case   57:*/		return 0x82193F10;
		  /* 82193F10h */ case   58:  		/* mr R3, R25 */
		/* 82193F10h case   58:*/		regs.R3 = regs.R25;
		/* 82193F10h case   58:*/		return 0x82193F14;
		  /* 82193F14h */ case   59:  		/* bl -114092 */
		/* 82193F14h case   59:*/		regs.LR = 0x82193F18; return 0x82178168;
		/* 82193F14h case   59:*/		return 0x82193F18;
		  /* 82193F18h */ case   60:  		/* mr R31, R3 */
		/* 82193F18h case   60:*/		regs.R31 = regs.R3;
		/* 82193F18h case   60:*/		return 0x82193F1C;
		  /* 82193F1Ch */ case   61:  		/* li R27, 0 */
		/* 82193F1Ch case   61:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82193F1Ch case   61:*/		return 0x82193F20;
		  /* 82193F20h */ case   62:  		/* b 40 */
		/* 82193F20h case   62:*/		return 0x82193F48;
		/* 82193F20h case   62:*/		return 0x82193F24;
	}
	return 0x82193F24;
} // Block from 82193E28h-82193F24h (63 instructions)

//////////////////////////////////////////////////////
// Block at 82193F24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193F24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193F24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193F24);
		  /* 82193F24h */ case    0:  		/* mr R5, R31 */
		/* 82193F24h case    0:*/		regs.R5 = regs.R31;
		/* 82193F24h case    0:*/		return 0x82193F28;
		  /* 82193F28h */ case    1:  		/* mr R4, R19 */
		/* 82193F28h case    1:*/		regs.R4 = regs.R19;
		/* 82193F28h case    1:*/		return 0x82193F2C;
		  /* 82193F2Ch */ case    2:  		/* mr R3, R25 */
		/* 82193F2Ch case    2:*/		regs.R3 = regs.R25;
		/* 82193F2Ch case    2:*/		return 0x82193F30;
		  /* 82193F30h */ case    3:  		/* bl -114208 */
		/* 82193F30h case    3:*/		regs.LR = 0x82193F34; return 0x82178110;
		/* 82193F30h case    3:*/		return 0x82193F34;
		  /* 82193F34h */ case    4:  		/* lwz R11, <#[R26]> */
		/* 82193F34h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82193F34h case    4:*/		return 0x82193F38;
		  /* 82193F38h */ case    5:  		/* lwz R10, <#[R3]> */
		/* 82193F38h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82193F38h case    5:*/		return 0x82193F3C;
		  /* 82193F3Ch */ case    6:  		/* mr R31, R3 */
		/* 82193F3Ch case    6:*/		regs.R31 = regs.R3;
		/* 82193F3Ch case    6:*/		return 0x82193F40;
		  /* 82193F40h */ case    7:  		/* rlwimi R11, R10, 0, 0, 26 */
		/* 82193F40h case    7:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R11,regs.R10);
		/* 82193F40h case    7:*/		return 0x82193F44;
		  /* 82193F44h */ case    8:  		/* stw R11, <#[R3]> */
		/* 82193F44h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82193F44h case    8:*/		return 0x82193F48;
	}
	return 0x82193F48;
} // Block from 82193F24h-82193F48h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82193F48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193F48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193F48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193F48);
		  /* 82193F48h */ case    0:  		/* lwz R11, <#[R24 + 8]> */
		/* 82193F48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 82193F48h case    0:*/		return 0x82193F4C;
		  /* 82193F4Ch */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82193F4Ch case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82193F4Ch case    1:*/		return 0x82193F50;
		  /* 82193F50h */ case    2:  		/* cmplwi CR6, R11, 128 */
		/* 82193F50h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 82193F50h case    2:*/		return 0x82193F54;
		  /* 82193F54h */ case    3:  		/* bc 4, CR6_EQ, 120 */
		/* 82193F54h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82193FCC;  }
		/* 82193F54h case    3:*/		return 0x82193F58;
		  /* 82193F58h */ case    4:  		/* lwz R11, <#[R20]> */
		/* 82193F58h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 82193F58h case    4:*/		return 0x82193F5C;
		  /* 82193F5Ch */ case    5:  		/* lwz R10, <#[R26]> */
		/* 82193F5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 82193F5Ch case    5:*/		return 0x82193F60;
		  /* 82193F60h */ case    6:  		/* xor R10, R11, R10 */
		/* 82193F60h case    6:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82193F60h case    6:*/		return 0x82193F64;
		  /* 82193F64h */ case    7:  		/* rlwinm. R10, R10, 0, 27, 30 */
		/* 82193F64h case    7:*/		cpu::op::rlwinm<1,0,27,30>(regs,&regs.R10,regs.R10);
		/* 82193F64h case    7:*/		return 0x82193F68;
		  /* 82193F68h */ case    8:  		/* bc 12, CR0_EQ, 72 */
		/* 82193F68h case    8:*/		if ( regs.CR[0].eq ) { return 0x82193FB0;  }
		/* 82193F68h case    8:*/		return 0x82193F6C;
		  /* 82193F6Ch */ case    9:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 82193F6Ch case    9:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 82193F6Ch case    9:*/		return 0x82193F70;
		  /* 82193F70h */ case   10:  		/* bc 12, CR0_EQ, 20 */
		/* 82193F70h case   10:*/		if ( regs.CR[0].eq ) { return 0x82193F84;  }
		/* 82193F70h case   10:*/		return 0x82193F74;
		  /* 82193F74h */ case   11:  		/* li R4, 4 */
		/* 82193F74h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 82193F74h case   11:*/		return 0x82193F78;
		  /* 82193F78h */ case   12:  		/* mr R3, R31 */
		/* 82193F78h case   12:*/		regs.R3 = regs.R31;
		/* 82193F78h case   12:*/		return 0x82193F7C;
		  /* 82193F7Ch */ case   13:  		/* bl -115900 */
		/* 82193F7Ch case   13:*/		regs.LR = 0x82193F80; return 0x82177AC0;
		/* 82193F7Ch case   13:*/		return 0x82193F80;
		  /* 82193F80h */ case   14:  		/* b 20 */
		/* 82193F80h case   14:*/		return 0x82193F94;
		/* 82193F80h case   14:*/		return 0x82193F84;
	}
	return 0x82193F84;
} // Block from 82193F48h-82193F84h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82193F84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193F84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193F84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193F84);
		  /* 82193F84h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82193F84h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82193F84h case    0:*/		return 0x82193F88;
		  /* 82193F88h */ case    1:  		/* addi R10, R11, -4 */
		/* 82193F88h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFFC);
		/* 82193F88h case    1:*/		return 0x82193F8C;
		  /* 82193F8Ch */ case    2:  		/* rlwimi R10, R11, 0, 0, 26 */
		/* 82193F8Ch case    2:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R10,regs.R11);
		/* 82193F8Ch case    2:*/		return 0x82193F90;
		  /* 82193F90h */ case    3:  		/* stw R10, <#[R31]> */
		/* 82193F90h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82193F90h case    3:*/		return 0x82193F94;
	}
	return 0x82193F94;
} // Block from 82193F84h-82193F94h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82193F94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193F94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193F94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193F94);
		  /* 82193F94h */ case    0:  		/* mr R7, R31 */
		/* 82193F94h case    0:*/		regs.R7 = regs.R31;
		/* 82193F94h case    0:*/		return 0x82193F98;
		  /* 82193F98h */ case    1:  		/* mr R6, R29 */
		/* 82193F98h case    1:*/		regs.R6 = regs.R29;
		/* 82193F98h case    1:*/		return 0x82193F9C;
		  /* 82193F9Ch */ case    2:  		/* mr R5, R17 */
		/* 82193F9Ch case    2:*/		regs.R5 = regs.R17;
		/* 82193F9Ch case    2:*/		return 0x82193FA0;
		  /* 82193FA0h */ case    3:  		/* mr R4, R22 */
		/* 82193FA0h case    3:*/		regs.R4 = regs.R22;
		/* 82193FA0h case    3:*/		return 0x82193FA4;
		  /* 82193FA4h */ case    4:  		/* mr R3, R25 */
		/* 82193FA4h case    4:*/		regs.R3 = regs.R25;
		/* 82193FA4h case    4:*/		return 0x82193FA8;
		  /* 82193FA8h */ case    5:  		/* bl -8360 */
		/* 82193FA8h case    5:*/		regs.LR = 0x82193FAC; return 0x82191F00;
		/* 82193FA8h case    5:*/		return 0x82193FAC;
		  /* 82193FACh */ case    6:  		/* b 56 */
		/* 82193FACh case    6:*/		return 0x82193FE4;
		/* 82193FACh case    6:*/		return 0x82193FB0;
	}
	return 0x82193FB0;
} // Block from 82193F94h-82193FB0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82193FB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193FB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193FB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193FB0);
		  /* 82193FB0h */ case    0:  		/* mr R7, R31 */
		/* 82193FB0h case    0:*/		regs.R7 = regs.R31;
		/* 82193FB0h case    0:*/		return 0x82193FB4;
		  /* 82193FB4h */ case    1:  		/* mr R6, R29 */
		/* 82193FB4h case    1:*/		regs.R6 = regs.R29;
		/* 82193FB4h case    1:*/		return 0x82193FB8;
		  /* 82193FB8h */ case    2:  		/* mr R5, R17 */
		/* 82193FB8h case    2:*/		regs.R5 = regs.R17;
		/* 82193FB8h case    2:*/		return 0x82193FBC;
		  /* 82193FBCh */ case    3:  		/* mr R4, R22 */
		/* 82193FBCh case    3:*/		regs.R4 = regs.R22;
		/* 82193FBCh case    3:*/		return 0x82193FC0;
		  /* 82193FC0h */ case    4:  		/* mr R3, R25 */
		/* 82193FC0h case    4:*/		regs.R3 = regs.R25;
		/* 82193FC0h case    4:*/		return 0x82193FC4;
		  /* 82193FC4h */ case    5:  		/* bl -8604 */
		/* 82193FC4h case    5:*/		regs.LR = 0x82193FC8; return 0x82191E28;
		/* 82193FC4h case    5:*/		return 0x82193FC8;
		  /* 82193FC8h */ case    6:  		/* b 28 */
		/* 82193FC8h case    6:*/		return 0x82193FE4;
		/* 82193FC8h case    6:*/		return 0x82193FCC;
	}
	return 0x82193FCC;
} // Block from 82193FB0h-82193FCCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 82193FCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193FCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193FCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193FCC);
		  /* 82193FCCh */ case    0:  		/* mr R7, R31 */
		/* 82193FCCh case    0:*/		regs.R7 = regs.R31;
		/* 82193FCCh case    0:*/		return 0x82193FD0;
		  /* 82193FD0h */ case    1:  		/* mr R6, R29 */
		/* 82193FD0h case    1:*/		regs.R6 = regs.R29;
		/* 82193FD0h case    1:*/		return 0x82193FD4;
		  /* 82193FD4h */ case    2:  		/* mr R5, R17 */
		/* 82193FD4h case    2:*/		regs.R5 = regs.R17;
		/* 82193FD4h case    2:*/		return 0x82193FD8;
		  /* 82193FD8h */ case    3:  		/* mr R4, R22 */
		/* 82193FD8h case    3:*/		regs.R4 = regs.R22;
		/* 82193FD8h case    3:*/		return 0x82193FDC;
		  /* 82193FDCh */ case    4:  		/* mr R3, R25 */
		/* 82193FDCh case    4:*/		regs.R3 = regs.R25;
		/* 82193FDCh case    4:*/		return 0x82193FE0;
		  /* 82193FE0h */ case    5:  		/* bl -8848 */
		/* 82193FE0h case    5:*/		regs.LR = 0x82193FE4; return 0x82191D50;
		/* 82193FE0h case    5:*/		return 0x82193FE4;
	}
	return 0x82193FE4;
} // Block from 82193FCCh-82193FE4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82193FE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82193FE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82193FE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82193FE4);
		  /* 82193FE4h */ case    0:  		/* mr R4, R3 */
		/* 82193FE4h case    0:*/		regs.R4 = regs.R3;
		/* 82193FE4h case    0:*/		return 0x82193FE8;
		  /* 82193FE8h */ case    1:  		/* mr R8, R28 */
		/* 82193FE8h case    1:*/		regs.R8 = regs.R28;
		/* 82193FE8h case    1:*/		return 0x82193FEC;
		  /* 82193FECh */ case    2:  		/* mr R7, R23 */
		/* 82193FECh case    2:*/		regs.R7 = regs.R23;
		/* 82193FECh case    2:*/		return 0x82193FF0;
		  /* 82193FF0h */ case    3:  		/* mr R6, R21 */
		/* 82193FF0h case    3:*/		regs.R6 = regs.R21;
		/* 82193FF0h case    3:*/		return 0x82193FF4;
		  /* 82193FF4h */ case    4:  		/* mr R5, R24 */
		/* 82193FF4h case    4:*/		regs.R5 = regs.R24;
		/* 82193FF4h case    4:*/		return 0x82193FF8;
		  /* 82193FF8h */ case    5:  		/* mr R3, R25 */
		/* 82193FF8h case    5:*/		regs.R3 = regs.R25;
		/* 82193FF8h case    5:*/		return 0x82193FFC;
		  /* 82193FFCh */ case    6:  		/* bl -11812 */
		/* 82193FFCh case    6:*/		regs.LR = 0x82194000; return 0x821911D8;
		/* 82193FFCh case    6:*/		return 0x82194000;
		  /* 82194000h */ case    7:  		/* addi R23, R23, 1 */
		/* 82194000h case    7:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 82194000h case    7:*/		return 0x82194004;
		  /* 82194004h */ case    8:  		/* cmplwi CR6, R30, 0 */
		/* 82194004h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82194004h case    8:*/		return 0x82194008;
		  /* 82194008h */ case    9:  		/* bc 4, CR6_EQ, -464 */
		/* 82194008h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82193E38;  }
		/* 82194008h case    9:*/		return 0x8219400C;
	}
	return 0x8219400C;
} // Block from 82193FE4h-8219400Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219400Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219400C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219400C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219400C);
		  /* 8219400Ch */ case    0:  		/* cmplwi CR6, R21, 0 */
		/* 8219400Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 8219400Ch case    0:*/		return 0x82194010;
		  /* 82194010h */ case    1:  		/* bc 12, CR6_EQ, 528 */
		/* 82194010h case    1:*/		if ( regs.CR[6].eq ) { return 0x82194220;  }
		/* 82194010h case    1:*/		return 0x82194014;
		  /* 82194014h */ case    2:  		/* rlwinm R11, R21, 0, 0, 30 */
		/* 82194014h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R21);
		/* 82194014h case    2:*/		return 0x82194018;
		  /* 82194018h */ case    3:  		/* lwz R9, <#[R17]> */
		/* 82194018h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000000) );
		/* 82194018h case    3:*/		return 0x8219401C;
		  /* 8219401Ch */ case    4:  		/* addi R10, R17, -36 */
		/* 8219401Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R17,0xFFFFFFDC);
		/* 8219401Ch case    4:*/		return 0x82194020;
		  /* 82194020h */ case    5:  		/* addi R11, R11, 36 */
		/* 82194020h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82194020h case    5:*/		return 0x82194024;
		  /* 82194024h */ case    6:  		/* ori R8, R10, 1 */
		/* 82194024h case    6:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 82194024h case    6:*/		return 0x82194028;
		  /* 82194028h */ case    7:  		/* addi R7, R11, -36 */
		/* 82194028h case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 82194028h case    7:*/		return 0x8219402C;
		  /* 8219402Ch */ case    8:  		/* addi R10, R11, 4 */
		/* 8219402Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8219402Ch case    8:*/		return 0x82194030;
		  /* 82194030h */ case    9:  		/* stw R9, <#[R11]> */
		/* 82194030h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82194030h case    9:*/		return 0x82194034;
		  /* 82194034h */ case   10:  		/* lwz R9, <#[R17]> */
		/* 82194034h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000000) );
		/* 82194034h case   10:*/		return 0x82194038;
		  /* 82194038h */ case   11:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82194038h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82194038h case   11:*/		return 0x8219403C;
		  /* 8219403Ch */ case   12:  		/* stw R7, <#[R9]> */
		/* 8219403Ch case   12:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 8219403Ch case   12:*/		return 0x82194040;
		  /* 82194040h */ case   13:  		/* stw R8, <#[R11 + 4]> */
		/* 82194040h case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82194040h case   13:*/		return 0x82194044;
		  /* 82194044h */ case   14:  		/* stw R10, <#[R17]> */
		/* 82194044h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R17 + 0x00000000) );
		/* 82194044h case   14:*/		return 0x82194048;
		  /* 82194048h */ case   15:  		/* b 472 */
		/* 82194048h case   15:*/		return 0x82194220;
		/* 82194048h case   15:*/		return 0x8219404C;
	}
	return 0x8219404C;
} // Block from 8219400Ch-8219404Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8219404Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219404C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219404C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219404C);
		  /* 8219404Ch */ case    0:  		/* cmplw CR6, R19, R16 */
		/* 8219404Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R19,regs.R16);
		/* 8219404Ch case    0:*/		return 0x82194050;
		  /* 82194050h */ case    1:  		/* bc 4, CR6_EQ, 132 */
		/* 82194050h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821940D4;  }
		/* 82194050h case    1:*/		return 0x82194054;
		  /* 82194054h */ case    2:  		/* lwz R10, <#[R20]> */
		/* 82194054h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x00000000) );
		/* 82194054h case    2:*/		return 0x82194058;
		  /* 82194058h */ case    3:  		/* lwz R11, <#[R26]> */
		/* 82194058h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82194058h case    3:*/		return 0x8219405C;
		  /* 8219405Ch */ case    4:  		/* xor R9, R11, R10 */
		/* 8219405Ch case    4:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R11,regs.R10);
		/* 8219405Ch case    4:*/		return 0x82194060;
		  /* 82194060h */ case    5:  		/* rlwinm. R9, R9, 0, 27, 31 */
		/* 82194060h case    5:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R9,regs.R9);
		/* 82194060h case    5:*/		return 0x82194064;
		  /* 82194064h */ case    6:  		/* bc 4, CR0_EQ, 32 */
		/* 82194064h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82194084;  }
		/* 82194064h case    6:*/		return 0x82194068;
		  /* 82194068h */ case    7:  		/* lwz R11, <#[R24 + 8]> */
		/* 82194068h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 82194068h case    7:*/		return 0x8219406C;
		  /* 8219406Ch */ case    8:  		/* li R5, 32 */
		/* 8219406Ch case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 8219406Ch case    8:*/		return 0x82194070;
		  /* 82194070h */ case    9:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82194070h case    9:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82194070h case    9:*/		return 0x82194074;
		  /* 82194074h */ case   10:  		/* cmplwi CR6, R11, 128 */
		/* 82194074h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 82194074h case   10:*/		return 0x82194078;
		  /* 82194078h */ case   11:  		/* bc 12, CR6_EQ, 72 */
		/* 82194078h case   11:*/		if ( regs.CR[6].eq ) { return 0x821940C0;  }
		/* 82194078h case   11:*/		return 0x8219407C;
		  /* 8219407Ch */ case   12:  		/* li R5, 34 */
		/* 8219407Ch case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x22);
		/* 8219407Ch case   12:*/		return 0x82194080;
		  /* 82194080h */ case   13:  		/* b 64 */
		/* 82194080h case   13:*/		return 0x821940C0;
		/* 82194080h case   13:*/		return 0x82194084;
	}
	return 0x82194084;
} // Block from 8219404Ch-82194084h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82194084h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194084( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194084) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194084);
		  /* 82194084h */ case    0:  		/* lwz R9, <#[R24 + 8]> */
		/* 82194084h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000008) );
		/* 82194084h case    0:*/		return 0x82194088;
		  /* 82194088h */ case    1:  		/* rlwinm R9, R9, 0, 18, 24 */
		/* 82194088h case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R9);
		/* 82194088h case    1:*/		return 0x8219408C;
		  /* 8219408Ch */ case    2:  		/* cmplwi CR6, R9, 128 */
		/* 8219408Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000080);
		/* 8219408Ch case    2:*/		return 0x82194090;
		  /* 82194090h */ case    3:  		/* bc 4, CR6_EQ, 68 */
		/* 82194090h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821940D4;  }
		/* 82194090h case    3:*/		return 0x82194094;
		  /* 82194094h */ case    4:  		/* xor R10, R11, R10 */
		/* 82194094h case    4:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82194094h case    4:*/		return 0x82194098;
		  /* 82194098h */ case    5:  		/* andi. R10, R10, 27 */
		/* 82194098h case    5:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R10,0x1B);
		/* 82194098h case    5:*/		return 0x8219409C;
		  /* 8219409Ch */ case    6:  		/* cmplwi CR0, R10, 0 */
		/* 8219409Ch case    6:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 8219409Ch case    6:*/		return 0x821940A0;
		  /* 821940A0h */ case    7:  		/* bc 4, CR0_EQ, 52 */
		/* 821940A0h case    7:*/		if ( !regs.CR[0].eq ) { return 0x821940D4;  }
		/* 821940A0h case    7:*/		return 0x821940A4;
		  /* 821940A4h */ case    8:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 821940A4h case    8:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 821940A4h case    8:*/		return 0x821940A8;
		  /* 821940A8h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 821940A8h case    9:*/		if ( regs.CR[0].eq ) { return 0x821940BC;  }
		/* 821940A8h case    9:*/		return 0x821940AC;
		  /* 821940ACh */ case   10:  		/* lwz R11, <#[R24 + 44]> */
		/* 821940ACh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000002C) );
		/* 821940ACh case   10:*/		return 0x821940B0;
		  /* 821940B0h */ case   11:  		/* lwz R10, <#[R24 + 48]> */
		/* 821940B0h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000030) );
		/* 821940B0h case   11:*/		return 0x821940B4;
		  /* 821940B4h */ case   12:  		/* stw R11, <#[R24 + 48]> */
		/* 821940B4h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x00000030) );
		/* 821940B4h case   12:*/		return 0x821940B8;
	}
	return 0x821940B8;
} // Block from 82194084h-821940B8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821940B8h
// Function '?GetNextInstructionWorker@Scheduler@D3DXShader@@QAAPAVInstruction@2@PAV32@PAVMachineState@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821940B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821940B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821940B8);
		  /* 821940B8h */ case    0:  		/* stw R10, <#[R24 + 44]> */
		/* 821940B8h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R24 + 0x0000002C) );
		/* 821940B8h case    0:*/		return 0x821940BC;
	}
	return 0x821940BC;
} // Block from 821940B8h-821940BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821940BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821940BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821940BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821940BC);
		  /* 821940BCh */ case    0:  		/* li R5, 57 */
		/* 821940BCh case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x39);
		/* 821940BCh case    0:*/		return 0x821940C0;
	}
	return 0x821940C0;
} // Block from 821940BCh-821940C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821940C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821940C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821940C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821940C0);
		  /* 821940C0h */ case    0:  		/* mr R6, R17 */
		/* 821940C0h case    0:*/		regs.R6 = regs.R17;
		/* 821940C0h case    0:*/		return 0x821940C4;
		  /* 821940C4h */ case    1:  		/* mr R4, R24 */
		/* 821940C4h case    1:*/		regs.R4 = regs.R24;
		/* 821940C4h case    1:*/		return 0x821940C8;
		  /* 821940C8h */ case    2:  		/* mr R3, R25 */
		/* 821940C8h case    2:*/		regs.R3 = regs.R25;
		/* 821940C8h case    2:*/		return 0x821940CC;
		  /* 821940CCh */ case    3:  		/* bl -3972 */
		/* 821940CCh case    3:*/		regs.LR = 0x821940D0; return 0x82193148;
		/* 821940CCh case    3:*/		return 0x821940D0;
		  /* 821940D0h */ case    4:  		/* b 336 */
		/* 821940D0h case    4:*/		return 0x82194220;
		/* 821940D0h case    4:*/		return 0x821940D4;
	}
	return 0x821940D4;
} // Block from 821940C0h-821940D4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821940D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821940D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821940D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821940D4);
		  /* 821940D4h */ case    0:  		/* lwz R11, <#[R24 + 8]> */
		/* 821940D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 821940D4h case    0:*/		return 0x821940D8;
		  /* 821940D8h */ case    1:  		/* li R5, 33 */
		/* 821940D8h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x21);
		/* 821940D8h case    1:*/		return 0x821940DC;
		  /* 821940DCh */ case    2:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821940DCh case    2:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821940DCh case    2:*/		return 0x821940E0;
		  /* 821940E0h */ case    3:  		/* cmplwi CR6, R11, 128 */
		/* 821940E0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 821940E0h case    3:*/		return 0x821940E4;
		  /* 821940E4h */ case    4:  		/* bc 12, CR6_EQ, 8 */
		/* 821940E4h case    4:*/		if ( regs.CR[6].eq ) { return 0x821940EC;  }
		/* 821940E4h case    4:*/		return 0x821940E8;
		  /* 821940E8h */ case    5:  		/* li R5, 35 */
		/* 821940E8h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x23);
		/* 821940E8h case    5:*/		return 0x821940EC;
	}
	return 0x821940EC;
} // Block from 821940D4h-821940ECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821940ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821940EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821940EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821940EC);
		  /* 821940ECh */ case    0:  		/* li R7, 1 */
		/* 821940ECh case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821940ECh case    0:*/		return 0x821940F0;
		  /* 821940F0h */ case    1:  		/* mr R6, R17 */
		/* 821940F0h case    1:*/		regs.R6 = regs.R17;
		/* 821940F0h case    1:*/		return 0x821940F4;
		  /* 821940F4h */ case    2:  		/* mr R4, R24 */
		/* 821940F4h case    2:*/		regs.R4 = regs.R24;
		/* 821940F4h case    2:*/		return 0x821940F8;
		  /* 821940F8h */ case    3:  		/* mr R3, R25 */
		/* 821940F8h case    3:*/		regs.R3 = regs.R25;
		/* 821940F8h case    3:*/		return 0x821940FC;
		  /* 821940FCh */ case    4:  		/* bl -3540 */
		/* 821940FCh case    4:*/		regs.LR = 0x82194100; return 0x82193328;
		/* 821940FCh case    4:*/		return 0x82194100;
		  /* 82194100h */ case    5:  		/* b 288 */
		/* 82194100h case    5:*/		return 0x82194220;
		/* 82194100h case    5:*/		return 0x82194104;
		  /* 82194104h */ case    6:  		/* addi R9, R9, -3 */
		/* 82194104h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFD);
		/* 82194104h case    6:*/		return 0x82194108;
		  /* 82194108h */ case    7:  		/* lwz R11, <#[R24 + 44]> */
		/* 82194108h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000002C) );
		/* 82194108h case    7:*/		return 0x8219410C;
		  /* 8219410Ch */ case    8:  		/* lwz R10, <#[R24 + 48]> */
		/* 8219410Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000030) );
		/* 8219410Ch case    8:*/		return 0x82194110;
		  /* 82194110h */ case    9:  		/* cntlzw R9, R9 */
		/* 82194110h case    9:*/		cpu::op::cntlzw<0>(regs,&regs.R9,regs.R9);
		/* 82194110h case    9:*/		return 0x82194114;
		  /* 82194114h */ case   10:  		/* rlwinm R9, R9, 27, 31, 31 */
		/* 82194114h case   10:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R9,regs.R9);
		/* 82194114h case   10:*/		return 0x82194118;
		  /* 82194118h */ case   11:  		/* lwz R8, <#[R11 + 12]> */
		/* 82194118h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 82194118h case   11:*/		return 0x8219411C;
		  /* 8219411Ch */ case   12:  		/* lwz R7, <#[R10 + 12]> */
		/* 8219411Ch case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x0000000C) );
		/* 8219411Ch case   12:*/		return 0x82194120;
		  /* 82194120h */ case   13:  		/* xori R9, R9, 1 */
		/* 82194120h case   13:*/		cpu::op::xori<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82194120h case   13:*/		return 0x82194124;
		  /* 82194124h */ case   14:  		/* addi R5, R9, 37 */
		/* 82194124h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R9,0x25);
		/* 82194124h case   14:*/		return 0x82194128;
		  /* 82194128h */ case   15:  		/* cmplw CR6, R8, R7 */
		/* 82194128h case   15:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 82194128h case   15:*/		return 0x8219412C;
		  /* 8219412Ch */ case   16:  		/* bc 4, CR6_EQ, 24 */
		/* 8219412Ch case   16:*/		if ( !regs.CR[6].eq ) { return 0x82194144;  }
		/* 8219412Ch case   16:*/		return 0x82194130;
		  /* 82194130h */ case   17:  		/* lwz R11, <#[R11]> */
		/* 82194130h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82194130h case   17:*/		return 0x82194134;
		  /* 82194134h */ case   18:  		/* lwz R10, <#[R10]> */
		/* 82194134h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 82194134h case   18:*/		return 0x82194138;
		  /* 82194138h */ case   19:  		/* xor R11, R11, R10 */
		/* 82194138h case   19:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82194138h case   19:*/		return 0x8219413C;
		  /* 8219413Ch */ case   20:  		/* rlwinm. R11, R11, 0, 27, 31 */
		/* 8219413Ch case   20:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8219413Ch case   20:*/		return 0x82194140;
		  /* 82194140h */ case   21:  		/* bc 12, CR0_EQ, -128 */
		/* 82194140h case   21:*/		if ( regs.CR[0].eq ) { return 0x821940C0;  }
		/* 82194140h case   21:*/		return 0x82194144;
	}
	return 0x82194144;
} // Block from 821940ECh-82194144h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82194144h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194144( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194144) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194144);
		  /* 82194144h */ case    0:  		/* li R7, 0 */
		/* 82194144h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82194144h case    0:*/		return 0x82194148;
		  /* 82194148h */ case    1:  		/* b -88 */
		/* 82194148h case    1:*/		return 0x821940F0;
		/* 82194148h case    1:*/		return 0x8219414C;
		  /* 8219414Ch */ case    2:  		/* li R5, 39 */
		/* 8219414Ch case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x27);
		/* 8219414Ch case    2:*/		return 0x82194150;
		  /* 82194150h */ case    3:  		/* b 192 */
		/* 82194150h case    3:*/		return 0x82194210;
		/* 82194150h case    3:*/		return 0x82194154;
		  /* 82194154h */ case    4:  		/* li R5, 40 */
		/* 82194154h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x28);
		/* 82194154h case    4:*/		return 0x82194158;
		  /* 82194158h */ case    5:  		/* b 184 */
		/* 82194158h case    5:*/		return 0x82194210;
		/* 82194158h case    5:*/		return 0x8219415C;
		  /* 8219415Ch */ case    6:  		/* li R5, 41 */
		/* 8219415Ch case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x29);
		/* 8219415Ch case    6:*/		return 0x82194160;
		  /* 82194160h */ case    7:  		/* b 176 */
		/* 82194160h case    7:*/		return 0x82194210;
		/* 82194160h case    7:*/		return 0x82194164;
		  /* 82194164h */ case    8:  		/* li R5, 42 */
		/* 82194164h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x2A);
		/* 82194164h case    8:*/		return 0x82194168;
		  /* 82194168h */ case    9:  		/* b 168 */
		/* 82194168h case    9:*/		return 0x82194210;
		/* 82194168h case    9:*/		return 0x8219416C;
		  /* 8219416Ch */ case   10:  		/* lwz R29, <#[R24 + 48]> */
		/* 8219416Ch case   10:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R24 + 0x00000030) );
		/* 8219416Ch case   10:*/		return 0x82194170;
		  /* 82194170h */ case   11:  		/* li R31, 0 */
		/* 82194170h case   11:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82194170h case   11:*/		return 0x82194174;
		  /* 82194174h */ case   12:  		/* lwz R11, <#[R29]> */
		/* 82194174h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82194174h case   12:*/		return 0x82194178;
		  /* 82194178h */ case   13:  		/* rlwinm. R28, R11, 7, 29, 31 */
		/* 82194178h case   13:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R28,regs.R11);
		/* 82194178h case   13:*/		return 0x8219417C;
		  /* 8219417Ch */ case   14:  		/* bc 12, CR0_EQ, 80 */
		/* 8219417Ch case   14:*/		if ( regs.CR[0].eq ) { return 0x821941CC;  }
		/* 8219417Ch case   14:*/		return 0x82194180;
		  /* 82194180h */ case   15:  		/* lis R11, -32256 */
		/* 82194180h case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82194180h case   15:*/		return 0x82194184;
		  /* 82194184h */ case   16:  		/* li R30, 0 */
		/* 82194184h case   16:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82194184h case   16:*/		return 0x82194188;
		  /* 82194188h */ case   17:  		/* lfd FR31, <#[R11 + 1848]> */
		/* 82194188h case   17:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000738) );
		/* 82194188h case   17:*/		return 0x8219418C;
		  /* 8219418Ch */ case   18:  		/* lwz R11, <#[R29]> */
		/* 8219418Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8219418Ch case   18:*/		return 0x82194190;
		  /* 82194190h */ case   19:  		/* lwz R10, <#[R29 + 12]> */
		/* 82194190h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000000C) );
		/* 82194190h case   19:*/		return 0x82194194;
		  /* 82194194h */ case   20:  		/* rlwinm R9, R11, 27, 24, 31 */
		/* 82194194h case   20:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R11);
		/* 82194194h case   20:*/		return 0x82194198;
		  /* 82194198h */ case   21:  		/* rlwinm R4, R11, 0, 27, 31 */
		/* 82194198h case   21:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R11);
		/* 82194198h case   21:*/		return 0x8219419C;
		  /* 8219419Ch */ case   22:  		/* srw R11, R9, R30 */
		/* 8219419Ch case   22:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R9,regs.R30);
		/* 8219419Ch case   22:*/		return 0x821941A0;
		  /* 821941A0h */ case   23:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 821941A0h case   23:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 821941A0h case   23:*/		return 0x821941A4;
		  /* 821941A4h */ case   24:  		/* addi R11, R11, 11 */
		/* 821941A4h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xB);
		/* 821941A4h case   24:*/		return 0x821941A8;
		  /* 821941A8h */ case   25:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821941A8h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821941A8h case   25:*/		return 0x821941AC;
		  /* 821941ACh */ case   26:  		/* lfsx FR1, <#[R11 + R10]> */
		/* 821941ACh case   26:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821941ACh case   26:*/		return 0x821941B0;
		  /* 821941B0h */ case   27:  		/* bl 578144 */
		/* 821941B0h case   27:*/		regs.LR = 0x821941B4; return 0x82221410;
		/* 821941B0h case   27:*/		return 0x821941B4;
		  /* 821941B4h */ case   28:  		/* fcmpu CR6, FR1, FR31 */
		/* 821941B4h case   28:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR31);
		/* 821941B4h case   28:*/		return 0x821941B8;
		  /* 821941B8h */ case   29:  		/* bc 4, CR6_EQ, 20 */
		/* 821941B8h case   29:*/		if ( !regs.CR[6].eq ) { return 0x821941CC;  }
		/* 821941B8h case   29:*/		return 0x821941BC;
		  /* 821941BCh */ case   30:  		/* addi R31, R31, 1 */
		/* 821941BCh case   30:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 821941BCh case   30:*/		return 0x821941C0;
		  /* 821941C0h */ case   31:  		/* addi R30, R30, 2 */
		/* 821941C0h case   31:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x2);
		/* 821941C0h case   31:*/		return 0x821941C4;
		  /* 821941C4h */ case   32:  		/* cmplw CR6, R31, R28 */
		/* 821941C4h case   32:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R28);
		/* 821941C4h case   32:*/		return 0x821941C8;
		  /* 821941C8h */ case   33:  		/* bc 12, CR6_LT, -60 */
		/* 821941C8h case   33:*/		if ( regs.CR[6].lt ) { return 0x8219418C;  }
		/* 821941C8h case   33:*/		return 0x821941CC;
	}
	return 0x821941CC;
} // Block from 82194144h-821941CCh (34 instructions)

//////////////////////////////////////////////////////
// Block at 821941CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821941CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821941CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821941CC);
		  /* 821941CCh */ case    0:  		/* cmplw CR6, R31, R28 */
		/* 821941CCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R28);
		/* 821941CCh case    0:*/		return 0x821941D0;
		  /* 821941D0h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 821941D0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821941DC;  }
		/* 821941D0h case    1:*/		return 0x821941D4;
		  /* 821941D4h */ case    2:  		/* li R5, 71 */
		/* 821941D4h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x47);
		/* 821941D4h case    2:*/		return 0x821941D8;
		  /* 821941D8h */ case    3:  		/* b 56 */
		/* 821941D8h case    3:*/		return 0x82194210;
		/* 821941D8h case    3:*/		return 0x821941DC;
	}
	return 0x821941DC;
} // Block from 821941CCh-821941DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821941DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821941DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821941DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821941DC);
		  /* 821941DCh */ case    0:  		/* li R5, 67 */
		/* 821941DCh case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x43);
		/* 821941DCh case    0:*/		return 0x821941E0;
		  /* 821941E0h */ case    1:  		/* b 48 */
		/* 821941E0h case    1:*/		return 0x82194210;
		/* 821941E0h case    1:*/		return 0x821941E4;
		  /* 821941E4h */ case    2:  		/* li R5, 68 */
		/* 821941E4h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x44);
		/* 821941E4h case    2:*/		return 0x821941E8;
		  /* 821941E8h */ case    3:  		/* b 40 */
		/* 821941E8h case    3:*/		return 0x82194210;
		/* 821941E8h case    3:*/		return 0x821941EC;
		  /* 821941ECh */ case    4:  		/* li R5, 69 */
		/* 821941ECh case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x45);
		/* 821941ECh case    4:*/		return 0x821941F0;
		  /* 821941F0h */ case    5:  		/* b 32 */
		/* 821941F0h case    5:*/		return 0x82194210;
		/* 821941F0h case    5:*/		return 0x821941F4;
		  /* 821941F4h */ case    6:  		/* li R5, 70 */
		/* 821941F4h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x46);
		/* 821941F4h case    6:*/		return 0x821941F8;
		  /* 821941F8h */ case    7:  		/* b 24 */
		/* 821941F8h case    7:*/		return 0x82194210;
		/* 821941F8h case    7:*/		return 0x821941FC;
		  /* 821941FCh */ case    8:  		/* li R5, 43 */
		/* 821941FCh case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x2B);
		/* 821941FCh case    8:*/		return 0x82194200;
		  /* 82194200h */ case    9:  		/* b 16 */
		/* 82194200h case    9:*/		return 0x82194210;
		/* 82194200h case    9:*/		return 0x82194204;
		  /* 82194204h */ case   10:  		/* li R5, 44 */
		/* 82194204h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x2C);
		/* 82194204h case   10:*/		return 0x82194208;
		  /* 82194208h */ case   11:  		/* b 8 */
		/* 82194208h case   11:*/		return 0x82194210;
		/* 82194208h case   11:*/		return 0x8219420C;
		  /* 8219420Ch */ case   12:  		/* li R5, 45 */
		/* 8219420Ch case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x2D);
		/* 8219420Ch case   12:*/		return 0x82194210;
	}
	return 0x82194210;
} // Block from 821941DCh-82194210h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82194210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194210);
		  /* 82194210h */ case    0:  		/* mr R6, R17 */
		/* 82194210h case    0:*/		regs.R6 = regs.R17;
		/* 82194210h case    0:*/		return 0x82194214;
		  /* 82194214h */ case    1:  		/* mr R4, R24 */
		/* 82194214h case    1:*/		regs.R4 = regs.R24;
		/* 82194214h case    1:*/		return 0x82194218;
		  /* 82194218h */ case    2:  		/* mr R3, R25 */
		/* 82194218h case    2:*/		regs.R3 = regs.R25;
		/* 82194218h case    2:*/		return 0x8219421C;
		  /* 8219421Ch */ case    3:  		/* bl -4836 */
		/* 8219421Ch case    3:*/		regs.LR = 0x82194220; return 0x82192F38;
		/* 8219421Ch case    3:*/		return 0x82194220;
	}
	return 0x82194220;
} // Block from 82194210h-82194220h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82194220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194220);
		  /* 82194220h */ case    0:  		/* lwz R31, <#[R17 + 4]> */
		/* 82194220h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R17 + 0x00000004) );
		/* 82194220h case    0:*/		return 0x82194224;
		  /* 82194224h */ case    1:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 82194224h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 82194224h case    1:*/		return 0x82194228;
		  /* 82194228h */ case    2:  		/* bc 4, CR0_EQ, 116 */
		/* 82194228h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8219429C;  }
		/* 82194228h case    2:*/		return 0x8219422C;
		  /* 8219422Ch */ case    3:  		/* cmplwi CR0, R31, 0 */
		/* 8219422Ch case    3:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 8219422Ch case    3:*/		return 0x82194230;
		  /* 82194230h */ case    4:  		/* bc 12, CR0_EQ, 108 */
		/* 82194230h case    4:*/		if ( regs.CR[0].eq ) { return 0x8219429C;  }
		/* 82194230h case    4:*/		return 0x82194234;
		  /* 82194234h */ case    5:  		/* rlwinm R30, R31, 0, 0, 30 */
		/* 82194234h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R30,regs.R31);
		/* 82194234h case    5:*/		return 0x82194238;
		  /* 82194238h */ case    6:  		/* lwz R11, <#[R30 + 40]> */
		/* 82194238h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 82194238h case    6:*/		return 0x8219423C;
		  /* 8219423Ch */ case    7:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219423Ch case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219423Ch case    7:*/		return 0x82194240;
		  /* 82194240h */ case    8:  		/* bc 4, CR0_EQ, 92 */
		/* 82194240h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8219429C;  }
		/* 82194240h case    8:*/		return 0x82194244;
		  /* 82194244h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82194244h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82194244h case    9:*/		return 0x82194248;
		  /* 82194248h */ case   10:  		/* bc 12, CR6_EQ, 84 */
		/* 82194248h case   10:*/		if ( regs.CR[6].eq ) { return 0x8219429C;  }
		/* 82194248h case   10:*/		return 0x8219424C;
		  /* 8219424Ch */ case   11:  		/* mr R3, R31 */
		/* 8219424Ch case   11:*/		regs.R3 = regs.R31;
		/* 8219424Ch case   11:*/		return 0x82194250;
		  /* 82194250h */ case   12:  		/* bl -18376 */
		/* 82194250h case   12:*/		regs.LR = 0x82194254; return 0x8218FA88;
		/* 82194250h case   12:*/		return 0x82194254;
		  /* 82194254h */ case   13:  		/* lwz R11, <#[R31 + 8]> */
		/* 82194254h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82194254h case   13:*/		return 0x82194258;
		  /* 82194258h */ case   14:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82194258h case   14:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82194258h case   14:*/		return 0x8219425C;
		  /* 8219425Ch */ case   15:  		/* cmplwi CR6, R11, 14080 */
		/* 8219425Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 8219425Ch case   15:*/		return 0x82194260;
		  /* 82194260h */ case   16:  		/* bc 4, CR6_EQ, 20 */
		/* 82194260h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82194274;  }
		/* 82194260h case   16:*/		return 0x82194264;
		  /* 82194264h */ case   17:  		/* mr R4, R31 */
		/* 82194264h case   17:*/		regs.R4 = regs.R31;
		/* 82194264h case   17:*/		return 0x82194268;
		  /* 82194268h */ case   18:  		/* mr R3, R25 */
		/* 82194268h case   18:*/		regs.R3 = regs.R25;
		/* 82194268h case   18:*/		return 0x8219426C;
		  /* 8219426Ch */ case   19:  		/* bl 139644 */
		/* 8219426Ch case   19:*/		regs.LR = 0x82194270; return 0x821B63E8;
		/* 8219426Ch case   19:*/		return 0x82194270;
		  /* 82194270h */ case   20:  		/* b 12 */
		/* 82194270h case   20:*/		return 0x8219427C;
		/* 82194270h case   20:*/		return 0x82194274;
	}
	return 0x82194274;
} // Block from 82194220h-82194274h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82194274h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194274( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194274) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194274);
		  /* 82194274h */ case    0:  		/* mr R3, R31 */
		/* 82194274h case    0:*/		regs.R3 = regs.R31;
		/* 82194274h case    0:*/		return 0x82194278;
		  /* 82194278h */ case    1:  		/* bl -114432 */
		/* 82194278h case    1:*/		regs.LR = 0x8219427C; return 0x82178378;
		/* 82194278h case    1:*/		return 0x8219427C;
	}
	return 0x8219427C;
} // Block from 82194274h-8219427Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219427Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219427C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219427C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219427C);
		  /* 8219427Ch */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8219427Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219427Ch case    0:*/		return 0x82194280;
		  /* 82194280h */ case    1:  		/* oris R11, R11, 256 */
		/* 82194280h case    1:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82194280h case    1:*/		return 0x82194284;
		  /* 82194284h */ case    2:  		/* stw R11, <#[R31 + 8]> */
		/* 82194284h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82194284h case    2:*/		return 0x82194288;
		  /* 82194288h */ case    3:  		/* lwz R31, <#[R30 + 40]> */
		/* 82194288h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000028) );
		/* 82194288h case    3:*/		return 0x8219428C;
		  /* 8219428Ch */ case    4:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 8219428Ch case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 8219428Ch case    4:*/		return 0x82194290;
		  /* 82194290h */ case    5:  		/* bc 4, CR0_EQ, 12 */
		/* 82194290h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8219429C;  }
		/* 82194290h case    5:*/		return 0x82194294;
		  /* 82194294h */ case    6:  		/* cmplwi CR6, R31, 0 */
		/* 82194294h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82194294h case    6:*/		return 0x82194298;
		  /* 82194298h */ case    7:  		/* bc 4, CR6_EQ, -100 */
		/* 82194298h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82194234;  }
		/* 82194298h case    7:*/		return 0x8219429C;
	}
	return 0x8219429C;
} // Block from 8219427Ch-8219429Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219429Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219429C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219429C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219429C);
		  /* 8219429Ch */ case    0:  		/* addi R1, R1, 240 */
		/* 8219429Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 8219429Ch case    0:*/		return 0x821942A0;
		  /* 821942A0h */ case    1:  		/* lfd FR31, <#[R1 - 152]> */
		/* 821942A0h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF68) );
		/* 821942A0h case    1:*/		return 0x821942A4;
		  /* 821942A4h */ case    2:  		/* b -1060912 */
		/* 821942A4h case    2:*/		return 0x82091274;
		/* 821942A4h case    2:*/		return 0x821942A8;
	}
	return 0x821942A8;
} // Block from 8219429Ch-821942A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821942A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821942A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821942A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821942A8);
		  /* 821942A8h */ case    0:  		/* lis R11, -32252 */
		/* 821942A8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 821942A8h case    0:*/		return 0x821942AC;
		  /* 821942ACh */ case    1:  		/* li R4, 3500 */
		/* 821942ACh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xDAC);
		/* 821942ACh case    1:*/		return 0x821942B0;
		  /* 821942B0h */ case    2:  		/* addi R5, R11, -16736 */
		/* 821942B0h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFBEA0);
		/* 821942B0h case    2:*/		return 0x821942B4;
		  /* 821942B4h */ case    3:  		/* mr R3, R25 */
		/* 821942B4h case    3:*/		regs.R3 = regs.R25;
		/* 821942B4h case    3:*/		return 0x821942B8;
		  /* 821942B8h */ case    4:  		/* bl -271440 */
		/* 821942B8h case    4:*/		regs.LR = 0x821942BC; return 0x82151E68;
		/* 821942B8h case    4:*/		return 0x821942BC;
		  /* 821942BCh */ case    5:  		/* nop */
		/* 821942BCh case    5:*/		cpu::op::nop();
		/* 821942BCh case    5:*/		return 0x821942C0;
	}
	return 0x821942C0;
} // Block from 821942A8h-821942C0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821942C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821942C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821942C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821942C0);
		  /* 821942C0h */ case    0:  		/* mfspr R12, LR */
		/* 821942C0h case    0:*/		regs.R12 = regs.LR;
		/* 821942C0h case    0:*/		return 0x821942C4;
		  /* 821942C4h */ case    1:  		/* bl -1061024 */
		/* 821942C4h case    1:*/		regs.LR = 0x821942C8; return 0x82091224;
		/* 821942C4h case    1:*/		return 0x821942C8;
		  /* 821942C8h */ case    2:  		/* stwu R1, <#[R1 - 368]> */
		/* 821942C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE90);
		/* 821942C8h case    2:*/		return 0x821942CC;
		  /* 821942CCh */ case    3:  		/* lwz R11, <#[R4 + 20]> */
		/* 821942CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000014) );
		/* 821942CCh case    3:*/		return 0x821942D0;
		  /* 821942D0h */ case    4:  		/* mr R21, R3 */
		/* 821942D0h case    4:*/		regs.R21 = regs.R3;
		/* 821942D0h case    4:*/		return 0x821942D4;
		  /* 821942D4h */ case    5:  		/* mr R15, R4 */
		/* 821942D4h case    5:*/		regs.R15 = regs.R4;
		/* 821942D4h case    5:*/		return 0x821942D8;
		  /* 821942D8h */ case    6:  		/* addi R10, R4, 16 */
		/* 821942D8h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x10);
		/* 821942D8h case    6:*/		return 0x821942DC;
		  /* 821942DCh */ case    7:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 821942DCh case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821942DCh case    7:*/		return 0x821942E0;
		  /* 821942E0h */ case    8:  		/* bc 4, CR0_EQ, 60 */
		/* 821942E0h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8219431C;  }
		/* 821942E0h case    8:*/		return 0x821942E4;
		  /* 821942E4h */ case    9:  		/* cmplwi CR0, R11, 0 */
		/* 821942E4h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821942E4h case    9:*/		return 0x821942E8;
		  /* 821942E8h */ case   10:  		/* bc 12, CR0_EQ, 52 */
		/* 821942E8h case   10:*/		if ( regs.CR[0].eq ) { return 0x8219431C;  }
		/* 821942E8h case   10:*/		return 0x821942EC;
		  /* 821942ECh */ case   11:  		/* lwz R9, <#[R11 + 16]> */
		/* 821942ECh case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 821942ECh case   11:*/		return 0x821942F0;
		  /* 821942F0h */ case   12:  		/* rlwinm R8, R11, 0, 0, 30 */
		/* 821942F0h case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R11);
		/* 821942F0h case   12:*/		return 0x821942F4;
		  /* 821942F4h */ case   13:  		/* lwz R7, <#[R11 + 20]> */
		/* 821942F4h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000014) );
		/* 821942F4h case   13:*/		return 0x821942F8;
		  /* 821942F8h */ case   14:  		/* oris R9, R9, 256 */
		/* 821942F8h case   14:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R9,0x100);
		/* 821942F8h case   14:*/		return 0x821942FC;
		  /* 821942FCh */ case   15:  		/* ori R7, R7, 8191 */
		/* 821942FCh case   15:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R7,0x1FFF);
		/* 821942FCh case   15:*/		return 0x82194300;
		  /* 82194300h */ case   16:  		/* stw R9, <#[R11 + 16]> */
		/* 82194300h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 82194300h case   16:*/		return 0x82194304;
		  /* 82194304h */ case   17:  		/* stw R7, <#[R11 + 20]> */
		/* 82194304h case   17:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000014) );
		/* 82194304h case   17:*/		return 0x82194308;
		  /* 82194308h */ case   18:  		/* lwz R11, <#[R8 + 40]> */
		/* 82194308h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000028) );
		/* 82194308h case   18:*/		return 0x8219430C;
		  /* 8219430Ch */ case   19:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 8219430Ch case   19:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 8219430Ch case   19:*/		return 0x82194310;
		  /* 82194310h */ case   20:  		/* bc 4, CR0_EQ, 12 */
		/* 82194310h case   20:*/		if ( !regs.CR[0].eq ) { return 0x8219431C;  }
		/* 82194310h case   20:*/		return 0x82194314;
		  /* 82194314h */ case   21:  		/* cmplwi CR6, R11, 0 */
		/* 82194314h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82194314h case   21:*/		return 0x82194318;
		  /* 82194318h */ case   22:  		/* bc 4, CR6_EQ, -44 */
		/* 82194318h case   22:*/		if ( !regs.CR[6].eq ) { return 0x821942EC;  }
		/* 82194318h case   22:*/		return 0x8219431C;
	}
	return 0x8219431C;
} // Block from 821942C0h-8219431Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 8219431Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219431C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219431C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219431C);
		  /* 8219431Ch */ case    0:  		/* lwz R11, <#[R10 + 4]> */
		/* 8219431Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8219431Ch case    0:*/		return 0x82194320;
		  /* 82194320h */ case    1:  		/* lis R10, -32215 */
		/* 82194320h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 82194320h case    1:*/		return 0x82194324;
		  /* 82194324h */ case    2:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 82194324h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 82194324h case    2:*/		return 0x82194328;
		  /* 82194328h */ case    3:  		/* addi R16, R10, -26096 */
		/* 82194328h case    3:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R10,0xFFFF9A10);
		/* 82194328h case    3:*/		return 0x8219432C;
		  /* 8219432Ch */ case    4:  		/* bc 4, CR0_EQ, 80 */
		/* 8219432Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x8219437C;  }
		/* 8219432Ch case    4:*/		return 0x82194330;
		  /* 82194330h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 82194330h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82194330h case    5:*/		return 0x82194334;
		  /* 82194334h */ case    6:  		/* bc 12, CR0_EQ, 72 */
		/* 82194334h case    6:*/		if ( regs.CR[0].eq ) { return 0x8219437C;  }
		/* 82194334h case    6:*/		return 0x82194338;
		  /* 82194338h */ case    7:  		/* lwz R9, <#[R11 + 4]> */
		/* 82194338h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82194338h case    7:*/		return 0x8219433C;
		  /* 8219433Ch */ case    8:  		/* addi R10, R11, 4 */
		/* 8219433Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8219433Ch case    8:*/		return 0x82194340;
		  /* 82194340h */ case    9:  		/* b 12 */
		/* 82194340h case    9:*/		return 0x8219434C;
		/* 82194340h case    9:*/		return 0x82194344;
		  /* 82194344h */ case   10:  		/* addi R10, R9, 8 */
		/* 82194344h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 82194344h case   10:*/		return 0x82194348;
		  /* 82194348h */ case   11:  		/* lwz R9, <#[R9 + 8]> */
		/* 82194348h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 82194348h case   11:*/		return 0x8219434C;
	}
	return 0x8219434C;
} // Block from 8219431Ch-8219434Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8219434Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219434C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219434C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219434C);
		  /* 8219434Ch */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 8219434Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8219434Ch case    0:*/		return 0x82194350;
		  /* 82194350h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82194350h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82194344;  }
		/* 82194350h case    1:*/		return 0x82194354;
		  /* 82194354h */ case    2:  		/* stw R16, <#[R10]> */
		/* 82194354h case    2:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R10 + 0x00000000) );
		/* 82194354h case    2:*/		return 0x82194358;
		  /* 82194358h */ case    3:  		/* rlwinm R10, R11, 0, 0, 30 */
		/* 82194358h case    3:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R11);
		/* 82194358h case    3:*/		return 0x8219435C;
		  /* 8219435Ch */ case    4:  		/* lwz R9, <#[R11 + 20]> */
		/* 8219435Ch case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 8219435Ch case    4:*/		return 0x82194360;
		  /* 82194360h */ case    5:  		/* rlwinm R9, R9, 0, 19, 5 */
		/* 82194360h case    5:*/		cpu::op::rlwinm<0,0,19,5>(regs,&regs.R9,regs.R9);
		/* 82194360h case    5:*/		return 0x82194364;
		  /* 82194364h */ case    6:  		/* stw R9, <#[R11 + 20]> */
		/* 82194364h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 82194364h case    6:*/		return 0x82194368;
		  /* 82194368h */ case    7:  		/* lwz R11, <#[R10 + 40]> */
		/* 82194368h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000028) );
		/* 82194368h case    7:*/		return 0x8219436C;
		  /* 8219436Ch */ case    8:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219436Ch case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219436Ch case    8:*/		return 0x82194370;
		  /* 82194370h */ case    9:  		/* bc 4, CR0_EQ, 12 */
		/* 82194370h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8219437C;  }
		/* 82194370h case    9:*/		return 0x82194374;
		  /* 82194374h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 82194374h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82194374h case   10:*/		return 0x82194378;
		  /* 82194378h */ case   11:  		/* bc 4, CR6_EQ, -64 */
		/* 82194378h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82194338;  }
		/* 82194378h case   11:*/		return 0x8219437C;
	}
	return 0x8219437C;
} // Block from 8219434Ch-8219437Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8219437Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219437C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219437C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219437C);
		  /* 8219437Ch */ case    0:  		/* li R5, 36 */
		/* 8219437Ch case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x24);
		/* 8219437Ch case    0:*/		return 0x82194380;
		  /* 82194380h */ case    1:  		/* stw R21, <#[R1 + 100]> */
		/* 82194380h case    1:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000064) );
		/* 82194380h case    1:*/		return 0x82194384;
		  /* 82194384h */ case    2:  		/* li R4, 0 */
		/* 82194384h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82194384h case    2:*/		return 0x82194388;
		  /* 82194388h */ case    3:  		/* addi R3, R1, 104 */
		/* 82194388h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x68);
		/* 82194388h case    3:*/		return 0x8219438C;
		  /* 8219438Ch */ case    4:  		/* bl -1060940 */
		/* 8219438Ch case    4:*/		regs.LR = 0x82194390; return 0x82091340;
		/* 8219438Ch case    4:*/		return 0x82194390;
		  /* 82194390h */ case    5:  		/* li R18, 0 */
		/* 82194390h case    5:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 82194390h case    5:*/		return 0x82194394;
		  /* 82194394h */ case    6:  		/* addi R5, R1, 216 */
		/* 82194394h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xD8);
		/* 82194394h case    6:*/		return 0x82194398;
		  /* 82194398h */ case    7:  		/* stw R21, <#[R1 + 144]> */
		/* 82194398h case    7:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000090) );
		/* 82194398h case    7:*/		return 0x8219439C;
		  /* 8219439Ch */ case    8:  		/* mr R4, R15 */
		/* 8219439Ch case    8:*/		regs.R4 = regs.R15;
		/* 8219439Ch case    8:*/		return 0x821943A0;
		  /* 821943A0h */ case    9:  		/* stw R18, <#[R1 + 140]> */
		/* 821943A0h case    9:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x0000008C) );
		/* 821943A0h case    9:*/		return 0x821943A4;
		  /* 821943A4h */ case   10:  		/* mr R3, R21 */
		/* 821943A4h case   10:*/		regs.R3 = regs.R21;
		/* 821943A4h case   10:*/		return 0x821943A8;
		  /* 821943A8h */ case   11:  		/* stw R18, <#[R1 + 148]> */
		/* 821943A8h case   11:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000094) );
		/* 821943A8h case   11:*/		return 0x821943AC;
		  /* 821943ACh */ case   12:  		/* stw R18, <#[R1 + 96]> */
		/* 821943ACh case   12:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000060) );
		/* 821943ACh case   12:*/		return 0x821943B0;
		  /* 821943B0h */ case   13:  		/* stw R21, <#[R1 + 152]> */
		/* 821943B0h case   13:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000098) );
		/* 821943B0h case   13:*/		return 0x821943B4;
		  /* 821943B4h */ case   14:  		/* bl -7660 */
		/* 821943B4h case   14:*/		regs.LR = 0x821943B8; return 0x821925C8;
		/* 821943B4h case   14:*/		return 0x821943B8;
		  /* 821943B8h */ case   15:  		/* or. R31, R3, R3 */
		/* 821943B8h case   15:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 821943B8h case   15:*/		return 0x821943BC;
		  /* 821943BCh */ case   16:  		/* bc 12, CR0_EQ, 116 */
		/* 821943BCh case   16:*/		if ( regs.CR[0].eq ) { return 0x82194430;  }
		/* 821943BCh case   16:*/		return 0x821943C0;
		  /* 821943C0h */ case   17:  		/* lwz R11, <#[R31 + 28]> */
		/* 821943C0h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 821943C0h case   17:*/		return 0x821943C4;
		  /* 821943C4h */ case   18:  		/* lwz R30, <#[R31 + 32]> */
		/* 821943C4h case   18:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000020) );
		/* 821943C4h case   18:*/		return 0x821943C8;
		  /* 821943C8h */ case   19:  		/* addi R10, R11, 32 */
		/* 821943C8h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x20);
		/* 821943C8h case   19:*/		return 0x821943CC;
		  /* 821943CCh */ case   20:  		/* lwz R11, <#[R11 + 36]> */
		/* 821943CCh case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 821943CCh case   20:*/		return 0x821943D0;
		  /* 821943D0h */ case   21:  		/* b 20 */
		/* 821943D0h case   21:*/		return 0x821943E4;
		/* 821943D0h case   21:*/		return 0x821943D4;
		  /* 821943D4h */ case   22:  		/* addi R9, R11, -36 */
		/* 821943D4h case   22:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFDC);
		/* 821943D4h case   22:*/		return 0x821943D8;
		  /* 821943D8h */ case   23:  		/* cmplw CR6, R31, R9 */
		/* 821943D8h case   23:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R9);
		/* 821943D8h case   23:*/		return 0x821943DC;
		  /* 821943DCh */ case   24:  		/* bc 12, CR6_EQ, 120 */
		/* 821943DCh case   24:*/		if ( regs.CR[6].eq ) { return 0x82194454;  }
		/* 821943DCh case   24:*/		return 0x821943E0;
		  /* 821943E0h */ case   25:  		/* lwz R11, <#[R11 + 4]> */
		/* 821943E0h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821943E0h case   25:*/		return 0x821943E4;
	}
	return 0x821943E4;
} // Block from 8219437Ch-821943E4h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821943E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821943E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821943E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821943E4);
		  /* 821943E4h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821943E4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821943E4h case    0:*/		return 0x821943E8;
		  /* 821943E8h */ case    1:  		/* addi R11, R11, 36 */
		/* 821943E8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821943E8h case    1:*/		return 0x821943EC;
		  /* 821943ECh */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 821943ECh case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821943ECh case    2:*/		return 0x821943F0;
		  /* 821943F0h */ case    3:  		/* bc 4, CR6_EQ, -28 */
		/* 821943F0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821943D4;  }
		/* 821943F0h case    3:*/		return 0x821943F4;
		  /* 821943F4h */ case    4:  		/* mr R11, R18 */
		/* 821943F4h case    4:*/		regs.R11 = regs.R18;
		/* 821943F4h case    4:*/		return 0x821943F8;
		  /* 821943F8h */ case    5:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821943F8h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821943F8h case    5:*/		return 0x821943FC;
		  /* 821943FCh */ case    6:  		/* bc 4, CR0_EQ, 40 */
		/* 821943FCh case    6:*/		if ( !regs.CR[0].eq ) { return 0x82194424;  }
		/* 821943FCh case    6:*/		return 0x82194400;
		  /* 82194400h */ case    7:  		/* li R5, 0 */
		/* 82194400h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82194400h case    7:*/		return 0x82194404;
		  /* 82194404h */ case    8:  		/* mr R4, R31 */
		/* 82194404h case    8:*/		regs.R4 = regs.R31;
		/* 82194404h case    8:*/		return 0x82194408;
		  /* 82194408h */ case    9:  		/* addi R3, R1, 96 */
		/* 82194408h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82194408h case    9:*/		return 0x8219440C;
		  /* 8219440Ch */ case   10:  		/* bl -18364 */
		/* 8219440Ch case   10:*/		regs.LR = 0x82194410; return 0x8218FC50;
		/* 8219440Ch case   10:*/		return 0x82194410;
		  /* 82194410h */ case   11:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82194410h case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82194410h case   11:*/		return 0x82194414;
		  /* 82194414h */ case   12:  		/* bc 12, CR0_EQ, 16 */
		/* 82194414h case   12:*/		if ( regs.CR[0].eq ) { return 0x82194424;  }
		/* 82194414h case   12:*/		return 0x82194418;
		  /* 82194418h */ case   13:  		/* mr R4, R31 */
		/* 82194418h case   13:*/		regs.R4 = regs.R31;
		/* 82194418h case   13:*/		return 0x8219441C;
		  /* 8219441Ch */ case   14:  		/* addi R3, R1, 96 */
		/* 8219441Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8219441Ch case   14:*/		return 0x82194420;
		  /* 82194420h */ case   15:  		/* bl -8784 */
		/* 82194420h case   15:*/		regs.LR = 0x82194424; return 0x821921D0;
		/* 82194420h case   15:*/		return 0x82194424;
	}
	return 0x82194424;
} // Block from 821943E4h-82194424h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82194424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194424);
		  /* 82194424h */ case    0:  		/* mr R31, R30 */
		/* 82194424h case    0:*/		regs.R31 = regs.R30;
		/* 82194424h case    0:*/		return 0x82194428;
		  /* 82194428h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 82194428h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82194428h case    1:*/		return 0x8219442C;
		  /* 8219442Ch */ case    2:  		/* bc 4, CR6_EQ, -108 */
		/* 8219442Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x821943C0;  }
		/* 8219442Ch case    2:*/		return 0x82194430;
	}
	return 0x82194430;
} // Block from 82194424h-82194430h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82194430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194430);
		  /* 82194430h */ case    0:  		/* addi R30, R15, 92 */
		/* 82194430h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R15,0x5C);
		/* 82194430h case    0:*/		return 0x82194434;
		  /* 82194434h */ case    1:  		/* li R29, 4 */
		/* 82194434h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x4);
		/* 82194434h case    1:*/		return 0x82194438;
		  /* 82194438h */ case    2:  		/* lwz R31, <#[R30]> */
		/* 82194438h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 82194438h case    2:*/		return 0x8219443C;
		  /* 8219443Ch */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 8219443Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219443Ch case    3:*/		return 0x82194440;
		  /* 82194440h */ case    4:  		/* bc 12, CR6_EQ, 108 */
		/* 82194440h case    4:*/		if ( regs.CR[6].eq ) { return 0x821944AC;  }
		/* 82194440h case    4:*/		return 0x82194444;
		  /* 82194444h */ case    5:  		/* lwz R11, <#[R31 + 28]> */
		/* 82194444h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 82194444h case    5:*/		return 0x82194448;
		  /* 82194448h */ case    6:  		/* addi R10, R11, 32 */
		/* 82194448h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x20);
		/* 82194448h case    6:*/		return 0x8219444C;
		  /* 8219444Ch */ case    7:  		/* lwz R11, <#[R11 + 36]> */
		/* 8219444Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 8219444Ch case    7:*/		return 0x82194450;
		  /* 82194450h */ case    8:  		/* b 28 */
		/* 82194450h case    8:*/		return 0x8219446C;
		/* 82194450h case    8:*/		return 0x82194454;
	}
	return 0x82194454;
} // Block from 82194430h-82194454h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82194454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194454);
		  /* 82194454h */ case    0:  		/* li R11, 1 */
		/* 82194454h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82194454h case    0:*/		return 0x82194458;
		  /* 82194458h */ case    1:  		/* b -96 */
		/* 82194458h case    1:*/		return 0x821943F8;
		/* 82194458h case    1:*/		return 0x8219445C;
		  /* 8219445Ch */ case    2:  		/* addi R9, R11, -36 */
		/* 8219445Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFDC);
		/* 8219445Ch case    2:*/		return 0x82194460;
		  /* 82194460h */ case    3:  		/* cmplw CR6, R31, R9 */
		/* 82194460h case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R9);
		/* 82194460h case    3:*/		return 0x82194464;
		  /* 82194464h */ case    4:  		/* bc 12, CR6_EQ, 116 */
		/* 82194464h case    4:*/		if ( regs.CR[6].eq ) { return 0x821944D8;  }
		/* 82194464h case    4:*/		return 0x82194468;
		  /* 82194468h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 82194468h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82194468h case    5:*/		return 0x8219446C;
	}
	return 0x8219446C;
} // Block from 82194454h-8219446Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219446Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219446C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219446C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219446C);
		  /* 8219446Ch */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8219446Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8219446Ch case    0:*/		return 0x82194470;
		  /* 82194470h */ case    1:  		/* addi R11, R11, 36 */
		/* 82194470h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82194470h case    1:*/		return 0x82194474;
		  /* 82194474h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 82194474h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82194474h case    2:*/		return 0x82194478;
		  /* 82194478h */ case    3:  		/* bc 4, CR6_EQ, -28 */
		/* 82194478h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8219445C;  }
		/* 82194478h case    3:*/		return 0x8219447C;
		  /* 8219447Ch */ case    4:  		/* mr R11, R18 */
		/* 8219447Ch case    4:*/		regs.R11 = regs.R18;
		/* 8219447Ch case    4:*/		return 0x82194480;
		  /* 82194480h */ case    5:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82194480h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82194480h case    5:*/		return 0x82194484;
		  /* 82194484h */ case    6:  		/* bc 4, CR0_EQ, 40 */
		/* 82194484h case    6:*/		if ( !regs.CR[0].eq ) { return 0x821944AC;  }
		/* 82194484h case    6:*/		return 0x82194488;
		  /* 82194488h */ case    7:  		/* li R5, 0 */
		/* 82194488h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82194488h case    7:*/		return 0x8219448C;
		  /* 8219448Ch */ case    8:  		/* mr R4, R31 */
		/* 8219448Ch case    8:*/		regs.R4 = regs.R31;
		/* 8219448Ch case    8:*/		return 0x82194490;
		  /* 82194490h */ case    9:  		/* addi R3, R1, 96 */
		/* 82194490h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82194490h case    9:*/		return 0x82194494;
		  /* 82194494h */ case   10:  		/* bl -18500 */
		/* 82194494h case   10:*/		regs.LR = 0x82194498; return 0x8218FC50;
		/* 82194494h case   10:*/		return 0x82194498;
		  /* 82194498h */ case   11:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82194498h case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82194498h case   11:*/		return 0x8219449C;
		  /* 8219449Ch */ case   12:  		/* bc 12, CR0_EQ, 16 */
		/* 8219449Ch case   12:*/		if ( regs.CR[0].eq ) { return 0x821944AC;  }
		/* 8219449Ch case   12:*/		return 0x821944A0;
		  /* 821944A0h */ case   13:  		/* mr R4, R31 */
		/* 821944A0h case   13:*/		regs.R4 = regs.R31;
		/* 821944A0h case   13:*/		return 0x821944A4;
		  /* 821944A4h */ case   14:  		/* addi R3, R1, 96 */
		/* 821944A4h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 821944A4h case   14:*/		return 0x821944A8;
		  /* 821944A8h */ case   15:  		/* bl -8920 */
		/* 821944A8h case   15:*/		regs.LR = 0x821944AC; return 0x821921D0;
		/* 821944A8h case   15:*/		return 0x821944AC;
	}
	return 0x821944AC;
} // Block from 8219446Ch-821944ACh (16 instructions)

//////////////////////////////////////////////////////
// Block at 821944ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821944AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821944AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821944AC);
		  /* 821944ACh */ case    0:  		/* addic. R29, R29, -1 */
		/* 821944ACh case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 821944ACh case    0:*/		return 0x821944B0;
		  /* 821944B0h */ case    1:  		/* addi R30, R30, 4 */
		/* 821944B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 821944B0h case    1:*/		return 0x821944B4;
		  /* 821944B4h */ case    2:  		/* bc 4, CR0_EQ, -124 */
		/* 821944B4h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82194438;  }
		/* 821944B4h case    2:*/		return 0x821944B8;
		  /* 821944B8h */ case    3:  		/* lwz R11, <#[R15 + 36]> */
		/* 821944B8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000024) );
		/* 821944B8h case    3:*/		return 0x821944BC;
		  /* 821944BCh */ case    4:  		/* addi R30, R15, 32 */
		/* 821944BCh case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R15,0x20);
		/* 821944BCh case    4:*/		return 0x821944C0;
		  /* 821944C0h */ case    5:  		/* mr R22, R18 */
		/* 821944C0h case    5:*/		regs.R22 = regs.R18;
		/* 821944C0h case    5:*/		return 0x821944C4;
		  /* 821944C4h */ case    6:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821944C4h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821944C4h case    6:*/		return 0x821944C8;
		  /* 821944C8h */ case    7:  		/* mr R17, R18 */
		/* 821944C8h case    7:*/		regs.R17 = regs.R18;
		/* 821944C8h case    7:*/		return 0x821944CC;
		  /* 821944CCh */ case    8:  		/* bc 4, CR0_EQ, 140 */
		/* 821944CCh case    8:*/		if ( !regs.CR[0].eq ) { return 0x82194558;  }
		/* 821944CCh case    8:*/		return 0x821944D0;
		  /* 821944D0h */ case    9:  		/* lwz R11, <#[R30]> */
		/* 821944D0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821944D0h case    9:*/		return 0x821944D4;
		  /* 821944D4h */ case   10:  		/* b 120 */
		/* 821944D4h case   10:*/		return 0x8219454C;
		/* 821944D4h case   10:*/		return 0x821944D8;
	}
	return 0x821944D8;
} // Block from 821944ACh-821944D8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821944D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821944D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821944D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821944D8);
		  /* 821944D8h */ case    0:  		/* li R11, 1 */
		/* 821944D8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821944D8h case    0:*/		return 0x821944DC;
		  /* 821944DCh */ case    1:  		/* b -92 */
		/* 821944DCh case    1:*/		return 0x82194480;
		/* 821944DCh case    1:*/		return 0x821944E0;
		  /* 821944E0h */ case    2:  		/* mr R5, R22 */
		/* 821944E0h case    2:*/		regs.R5 = regs.R22;
		/* 821944E0h case    2:*/		return 0x821944E4;
		  /* 821944E4h */ case    3:  		/* mr R4, R31 */
		/* 821944E4h case    3:*/		regs.R4 = regs.R31;
		/* 821944E4h case    3:*/		return 0x821944E8;
		  /* 821944E8h */ case    4:  		/* mr R3, R21 */
		/* 821944E8h case    4:*/		regs.R3 = regs.R21;
		/* 821944E8h case    4:*/		return 0x821944EC;
		  /* 821944ECh */ case    5:  		/* bl -5676 */
		/* 821944ECh case    5:*/		regs.LR = 0x821944F0; return 0x82192EC0;
		/* 821944ECh case    5:*/		return 0x821944F0;
		  /* 821944F0h */ case    6:  		/* lwz R11, <#[R31 + 8]> */
		/* 821944F0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821944F0h case    6:*/		return 0x821944F4;
		  /* 821944F4h */ case    7:  		/* addi R22, R22, 1 */
		/* 821944F4h case    7:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 821944F4h case    7:*/		return 0x821944F8;
		  /* 821944F8h */ case    8:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821944F8h case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821944F8h case    8:*/		return 0x821944FC;
		  /* 821944FCh */ case    9:  		/* cmplwi CR6, R11, 1 */
		/* 821944FCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821944FCh case    9:*/		return 0x82194500;
		  /* 82194500h */ case   10:  		/* bc 12, CR6_LT, 16 */
		/* 82194500h case   10:*/		if ( regs.CR[6].lt ) { return 0x82194510;  }
		/* 82194500h case   10:*/		return 0x82194504;
		  /* 82194504h */ case   11:  		/* cmplwi CR6, R11, 31 */
		/* 82194504h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001F);
		/* 82194504h case   11:*/		return 0x82194508;
		  /* 82194508h */ case   12:  		/* li R11, 1 */
		/* 82194508h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82194508h case   12:*/		return 0x8219450C;
		  /* 8219450Ch */ case   13:  		/* bc 4, CR6_GT, 8 */
		/* 8219450Ch case   13:*/		if ( !regs.CR[6].gt ) { return 0x82194514;  }
		/* 8219450Ch case   13:*/		return 0x82194510;
	}
	return 0x82194510;
} // Block from 821944D8h-82194510h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82194510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194510);
		  /* 82194510h */ case    0:  		/* mr R11, R18 */
		/* 82194510h case    0:*/		regs.R11 = regs.R18;
		/* 82194510h case    0:*/		return 0x82194514;
	}
	return 0x82194514;
} // Block from 82194510h-82194514h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82194514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194514);
		  /* 82194514h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82194514h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82194514h case    0:*/		return 0x82194518;
		  /* 82194518h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 82194518h case    1:*/		if ( regs.CR[0].eq ) { return 0x82194520;  }
		/* 82194518h case    1:*/		return 0x8219451C;
		  /* 8219451Ch */ case    2:  		/* addi R17, R17, 1 */
		/* 8219451Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 8219451Ch case    2:*/		return 0x82194520;
	}
	return 0x82194520;
} // Block from 82194514h-82194520h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82194520h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194520);
		  /* 82194520h */ case    0:  		/* mr R4, R31 */
		/* 82194520h case    0:*/		regs.R4 = regs.R31;
		/* 82194520h case    0:*/		return 0x82194524;
		  /* 82194524h */ case    1:  		/* addi R3, R1, 100 */
		/* 82194524h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x64);
		/* 82194524h case    1:*/		return 0x82194528;
		  /* 82194528h */ case    2:  		/* bl -18912 */
		/* 82194528h case    2:*/		regs.LR = 0x8219452C; return 0x8218FB48;
		/* 82194528h case    2:*/		return 0x8219452C;
		  /* 8219452Ch */ case    3:  		/* li R5, 1 */
		/* 8219452Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8219452Ch case    3:*/		return 0x82194530;
		  /* 82194530h */ case    4:  		/* mr R4, R31 */
		/* 82194530h case    4:*/		regs.R4 = regs.R31;
		/* 82194530h case    4:*/		return 0x82194534;
		  /* 82194534h */ case    5:  		/* addi R3, R1, 96 */
		/* 82194534h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82194534h case    5:*/		return 0x82194538;
		  /* 82194538h */ case    6:  		/* bl -2416 */
		/* 82194538h case    6:*/		regs.LR = 0x8219453C; return 0x82193BC8;
		/* 82194538h case    6:*/		return 0x8219453C;
		  /* 8219453Ch */ case    7:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8219453Ch case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8219453Ch case    7:*/		return 0x82194540;
		  /* 82194540h */ case    8:  		/* lwz R11, <#[R11 + 36]> */
		/* 82194540h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82194540h case    8:*/		return 0x82194544;
		  /* 82194544h */ case    9:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82194544h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82194544h case    9:*/		return 0x82194548;
		  /* 82194548h */ case   10:  		/* bc 4, CR0_EQ, 16 */
		/* 82194548h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82194558;  }
		/* 82194548h case   10:*/		return 0x8219454C;
	}
	return 0x8219454C;
} // Block from 82194520h-8219454Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219454Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219454C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219454C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219454C);
		  /* 8219454Ch */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8219454Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8219454Ch case    0:*/		return 0x82194550;
		  /* 82194550h */ case    1:  		/* addic. R31, R11, -40 */
		/* 82194550h case    1:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 82194550h case    1:*/		return 0x82194554;
		  /* 82194554h */ case    2:  		/* bc 4, CR0_EQ, -116 */
		/* 82194554h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821944E0;  }
		/* 82194554h case    2:*/		return 0x82194558;
	}
	return 0x82194558;
} // Block from 8219454Ch-82194558h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82194558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194558);
		  /* 82194558h */ case    0:  		/* addi R19, R15, 24 */
		/* 82194558h case    0:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R15,0x18);
		/* 82194558h case    0:*/		return 0x8219455C;
		  /* 8219455Ch */ case    1:  		/* mr R4, R30 */
		/* 8219455Ch case    1:*/		regs.R4 = regs.R30;
		/* 8219455Ch case    1:*/		return 0x82194560;
	}
	return 0x82194560;
} // Block from 82194558h-82194560h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82194560h
// Function '?QueueDependencies@Scheduler@D3DXShader@@QAAXPAVInstruction@2@_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194560);
		  /* 82194560h */ case    0:  		/* addi R23, R19, 4 */
		/* 82194560h case    0:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R19,0x4);
		/* 82194560h case    0:*/		return 0x82194564;
		  /* 82194564h */ case    1:  		/* addi R11, R19, -36 */
		/* 82194564h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R19,0xFFFFFFDC);
		/* 82194564h case    1:*/		return 0x82194568;
		  /* 82194568h */ case    2:  		/* ori R20, R23, 1 */
		/* 82194568h case    2:*/		cpu::op::ori<0>(regs,&regs.R20,regs.R23,0x1);
		/* 82194568h case    2:*/		return 0x8219456C;
		  /* 8219456Ch */ case    3:  		/* ori R11, R11, 1 */
		/* 8219456Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219456Ch case    3:*/		return 0x82194570;
		  /* 82194570h */ case    4:  		/* stw R20, <#[R15 + 24]> */
		/* 82194570h case    4:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R15 + 0x00000018) );
		/* 82194570h case    4:*/		return 0x82194574;
		  /* 82194574h */ case    5:  		/* mr R3, R19 */
		/* 82194574h case    5:*/		regs.R3 = regs.R19;
		/* 82194574h case    5:*/		return 0x82194578;
		  /* 82194578h */ case    6:  		/* stw R11, <#[R15 + 28]> */
		/* 82194578h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R15 + 0x0000001C) );
		/* 82194578h case    6:*/		return 0x8219457C;
		  /* 8219457Ch */ case    7:  		/* bl -11220 */
		/* 8219457Ch case    7:*/		regs.LR = 0x82194580; return 0x821919A8;
		/* 8219457Ch case    7:*/		return 0x82194580;
		  /* 82194580h */ case    8:  		/* lwz R11, <#[R15 + 76]> */
		/* 82194580h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x0000004C) );
		/* 82194580h case    8:*/		return 0x82194584;
		  /* 82194584h */ case    9:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 82194584h case    9:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 82194584h case    9:*/		return 0x82194588;
		  /* 82194588h */ case   10:  		/* bc 12, CR0_EQ, 2352 */
		/* 82194588h case   10:*/		if ( regs.CR[0].eq ) { return 0x82194EB8;  }
		/* 82194588h case   10:*/		return 0x8219458C;
		  /* 8219458Ch */ case   11:  		/* addi R3, R1, 96 */
		/* 8219458Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8219458Ch case   11:*/		return 0x82194590;
		  /* 82194590h */ case   12:  		/* bl -18888 */
		/* 82194590h case   12:*/		regs.LR = 0x82194594; return 0x8218FBC8;
		/* 82194590h case   12:*/		return 0x82194594;
		  /* 82194594h */ case   13:  		/* or. R31, R3, R3 */
		/* 82194594h case   13:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 82194594h case   13:*/		return 0x82194598;
		  /* 82194598h */ case   14:  		/* bc 12, CR0_EQ, 2336 */
		/* 82194598h case   14:*/		if ( regs.CR[0].eq ) { return 0x82194EB8;  }
		/* 82194598h case   14:*/		return 0x8219459C;
		  /* 8219459Ch */ case   15:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8219459Ch case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8219459Ch case   15:*/		return 0x821945A0;
		  /* 821945A0h */ case   16:  		/* lwz R9, <#[R23]> */
		/* 821945A0h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000000) );
		/* 821945A0h case   16:*/		return 0x821945A4;
		  /* 821945A4h */ case   17:  		/* mr R5, R22 */
		/* 821945A4h case   17:*/		regs.R5 = regs.R22;
		/* 821945A4h case   17:*/		return 0x821945A8;
		  /* 821945A8h */ case   18:  		/* addi R11, R11, 36 */
		/* 821945A8h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821945A8h case   18:*/		return 0x821945AC;
		  /* 821945ACh */ case   19:  		/* mr R4, R31 */
		/* 821945ACh case   19:*/		regs.R4 = regs.R31;
		/* 821945ACh case   19:*/		return 0x821945B0;
		  /* 821945B0h */ case   20:  		/* addi R10, R11, 4 */
		/* 821945B0h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821945B0h case   20:*/		return 0x821945B4;
		  /* 821945B4h */ case   21:  		/* addi R8, R11, -36 */
		/* 821945B4h case   21:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821945B4h case   21:*/		return 0x821945B8;
		  /* 821945B8h */ case   22:  		/* mr R3, R21 */
		/* 821945B8h case   22:*/		regs.R3 = regs.R21;
		/* 821945B8h case   22:*/		return 0x821945BC;
		  /* 821945BCh */ case   23:  		/* stw R9, <#[R11 + 4]> */
		/* 821945BCh case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 821945BCh case   23:*/		return 0x821945C0;
		  /* 821945C0h */ case   24:  		/* lwz R9, <#[R23]> */
		/* 821945C0h case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000000) );
		/* 821945C0h case   24:*/		return 0x821945C4;
		  /* 821945C4h */ case   25:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 821945C4h case   25:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 821945C4h case   25:*/		return 0x821945C8;
		  /* 821945C8h */ case   26:  		/* stw R10, <#[R9 + 36]> */
		/* 821945C8h case   26:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000024) );
		/* 821945C8h case   26:*/		return 0x821945CC;
		  /* 821945CCh */ case   27:  		/* stw R20, <#[R11]> */
		/* 821945CCh case   27:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R11 + 0x00000000) );
		/* 821945CCh case   27:*/		return 0x821945D0;
		  /* 821945D0h */ case   28:  		/* stw R8, <#[R23]> */
		/* 821945D0h case   28:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R23 + 0x00000000) );
		/* 821945D0h case   28:*/		return 0x821945D4;
		  /* 821945D4h */ case   29:  		/* bl -5908 */
		/* 821945D4h case   29:*/		regs.LR = 0x821945D8; return 0x82192EC0;
		/* 821945D4h case   29:*/		return 0x821945D8;
		  /* 821945D8h */ case   30:  		/* lwz R11, <#[R31 + 8]> */
		/* 821945D8h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821945D8h case   30:*/		return 0x821945DC;
		  /* 821945DCh */ case   31:  		/* addi R22, R22, 1 */
		/* 821945DCh case   31:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 821945DCh case   31:*/		return 0x821945E0;
		  /* 821945E0h */ case   32:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821945E0h case   32:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821945E0h case   32:*/		return 0x821945E4;
		  /* 821945E4h */ case   33:  		/* cmplwi CR6, R11, 1 */
		/* 821945E4h case   33:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821945E4h case   33:*/		return 0x821945E8;
		  /* 821945E8h */ case   34:  		/* bc 12, CR6_LT, 16 */
		/* 821945E8h case   34:*/		if ( regs.CR[6].lt ) { return 0x821945F8;  }
		/* 821945E8h case   34:*/		return 0x821945EC;
		  /* 821945ECh */ case   35:  		/* cmplwi CR6, R11, 31 */
		/* 821945ECh case   35:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001F);
		/* 821945ECh case   35:*/		return 0x821945F0;
		  /* 821945F0h */ case   36:  		/* li R11, 1 */
		/* 821945F0h case   36:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821945F0h case   36:*/		return 0x821945F4;
		  /* 821945F4h */ case   37:  		/* bc 4, CR6_GT, 8 */
		/* 821945F4h case   37:*/		if ( !regs.CR[6].gt ) { return 0x821945FC;  }
		/* 821945F4h case   37:*/		return 0x821945F8;
	}
	return 0x821945F8;
} // Block from 82194560h-821945F8h (38 instructions)

//////////////////////////////////////////////////////
// Block at 821945F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821945F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821945F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821945F8);
		  /* 821945F8h */ case    0:  		/* mr R11, R18 */
		/* 821945F8h case    0:*/		regs.R11 = regs.R18;
		/* 821945F8h case    0:*/		return 0x821945FC;
	}
	return 0x821945FC;
} // Block from 821945F8h-821945FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821945FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821945FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821945FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821945FC);
		  /* 821945FCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821945FCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821945FCh case    0:*/		return 0x82194600;
		  /* 82194600h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 82194600h case    1:*/		if ( regs.CR[0].eq ) { return 0x82194608;  }
		/* 82194600h case    1:*/		return 0x82194604;
		  /* 82194604h */ case    2:  		/* addi R17, R17, 1 */
		/* 82194604h case    2:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 82194604h case    2:*/		return 0x82194608;
	}
	return 0x82194608;
} // Block from 821945FCh-82194608h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82194608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194608);
		  /* 82194608h */ case    0:  		/* mr R4, R31 */
		/* 82194608h case    0:*/		regs.R4 = regs.R31;
		/* 82194608h case    0:*/		return 0x8219460C;
		  /* 8219460Ch */ case    1:  		/* b 2208 */
		/* 8219460Ch case    1:*/		return 0x82194EAC;
		/* 8219460Ch case    1:*/		return 0x82194610;
		  /* 82194610h */ case    2:  		/* addi R5, R1, 100 */
		/* 82194610h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x64);
		/* 82194610h case    2:*/		return 0x82194614;
		  /* 82194614h */ case    3:  		/* li R4, 0 */
		/* 82194614h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82194614h case    3:*/		return 0x82194618;
		  /* 82194618h */ case    4:  		/* addi R3, R1, 96 */
		/* 82194618h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82194618h case    4:*/		return 0x8219461C;
		  /* 8219461Ch */ case    5:  		/* bl -3836 */
		/* 8219461Ch case    5:*/		regs.LR = 0x82194620; return 0x82193720;
		/* 8219461Ch case    5:*/		return 0x82194620;
		  /* 82194620h */ case    6:  		/* mr R24, R3 */
		/* 82194620h case    6:*/		regs.R24 = regs.R3;
		/* 82194620h case    6:*/		return 0x82194624;
		  /* 82194624h */ case    7:  		/* mr R25, R18 */
		/* 82194624h case    7:*/		regs.R25 = regs.R18;
		/* 82194624h case    7:*/		return 0x82194628;
	}
	return 0x82194628;
} // Block from 82194608h-82194628h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82194628h
// Function '?SmashToScalars@Compiler@D3DXShader@@AAAXPAVInstruction@2@PAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194628);
		  /* 82194628h */ case    0:  		/* cmplwi CR6, R17, 0 */
		/* 82194628h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 82194628h case    0:*/		return 0x8219462C;
		  /* 8219462Ch */ case    1:  		/* bc 12, CR6_EQ, 220 */
		/* 8219462Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82194708;  }
		/* 8219462Ch case    1:*/		return 0x82194630;
		  /* 82194630h */ case    2:  		/* lwz R10, <#[R3 + 8]> */
		/* 82194630h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82194630h case    2:*/		return 0x82194634;
		  /* 82194634h */ case    3:  		/* rlwinm R11, R10, 25, 25, 31 */
		/* 82194634h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R10);
		/* 82194634h case    3:*/		return 0x82194638;
		  /* 82194638h */ case    4:  		/* cmplwi CR6, R11, 1 */
		/* 82194638h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82194638h case    4:*/		return 0x8219463C;
		  /* 8219463Ch */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 8219463Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x8219464C;  }
		/* 8219463Ch case    5:*/		return 0x82194640;
		  /* 82194640h */ case    6:  		/* cmplwi CR6, R11, 31 */
		/* 82194640h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001F);
		/* 82194640h case    6:*/		return 0x82194644;
		  /* 82194644h */ case    7:  		/* li R11, 1 */
		/* 82194644h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82194644h case    7:*/		return 0x82194648;
		  /* 82194648h */ case    8:  		/* bc 4, CR6_GT, 8 */
		/* 82194648h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82194650;  }
		/* 82194648h case    8:*/		return 0x8219464C;
	}
	return 0x8219464C;
} // Block from 82194628h-8219464Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219464Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219464C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219464C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219464C);
		  /* 8219464Ch */ case    0:  		/* mr R11, R18 */
		/* 8219464Ch case    0:*/		regs.R11 = regs.R18;
		/* 8219464Ch case    0:*/		return 0x82194650;
	}
	return 0x82194650;
} // Block from 8219464Ch-82194650h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82194650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194650);
		  /* 82194650h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82194650h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82194650h case    0:*/		return 0x82194654;
		  /* 82194654h */ case    1:  		/* bc 12, CR0_EQ, 180 */
		/* 82194654h case    1:*/		if ( regs.CR[0].eq ) { return 0x82194708;  }
		/* 82194654h case    1:*/		return 0x82194658;
		  /* 82194658h */ case    2:  		/* rlwinm. R11, R10, 7, 31, 31 */
		/* 82194658h case    2:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R10);
		/* 82194658h case    2:*/		return 0x8219465C;
		  /* 8219465Ch */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 8219465Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x82194668;  }
		/* 8219465Ch case    3:*/		return 0x82194660;
		  /* 82194660h */ case    4:  		/* li R29, -1 */
		/* 82194660h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0xFFFFFFFF);
		/* 82194660h case    4:*/		return 0x82194664;
		  /* 82194664h */ case    5:  		/* b 16 */
		/* 82194664h case    5:*/		return 0x82194674;
		/* 82194664h case    5:*/		return 0x82194668;
	}
	return 0x82194668;
} // Block from 82194650h-82194668h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82194668h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194668);
		  /* 82194668h */ case    0:  		/* mr R3, R24 */
		/* 82194668h case    0:*/		regs.R3 = regs.R24;
		/* 82194668h case    0:*/		return 0x8219466C;
		  /* 8219466Ch */ case    1:  		/* bl -14492 */
		/* 8219466Ch case    1:*/		regs.LR = 0x82194670; return 0x82190DD0;
		/* 8219466Ch case    1:*/		return 0x82194670;
		  /* 82194670h */ case    2:  		/* mr R29, R3 */
		/* 82194670h case    2:*/		regs.R29 = regs.R3;
		/* 82194670h case    2:*/		return 0x82194674;
	}
	return 0x82194674;
} // Block from 82194668h-82194674h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82194674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194674);
		  /* 82194674h */ case    0:  		/* addi R11, R17, 1 */
		/* 82194674h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R17,0x1);
		/* 82194674h case    0:*/		return 0x82194678;
		  /* 82194678h */ case    1:  		/* cmplw CR6, R11, R29 */
		/* 82194678h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 82194678h case    1:*/		return 0x8219467C;
		  /* 8219467Ch */ case    2:  		/* bc 12, CR6_LT, 140 */
		/* 8219467Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x82194708;  }
		/* 8219467Ch case    2:*/		return 0x82194680;
		  /* 82194680h */ case    3:  		/* lwz R8, <#[R24 + 4]> */
		/* 82194680h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R24 + 0x00000004) );
		/* 82194680h case    3:*/		return 0x82194684;
		  /* 82194684h */ case    4:  		/* mr R9, R18 */
		/* 82194684h case    4:*/		regs.R9 = regs.R18;
		/* 82194684h case    4:*/		return 0x82194688;
		  /* 82194688h */ case    5:  		/* mr R30, R18 */
		/* 82194688h case    5:*/		regs.R30 = regs.R18;
		/* 82194688h case    5:*/		return 0x8219468C;
		  /* 8219468Ch */ case    6:  		/* cmplwi CR6, R8, 0 */
		/* 8219468Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8219468Ch case    6:*/		return 0x82194690;
		  /* 82194690h */ case    7:  		/* bc 12, CR6_EQ, 76 */
		/* 82194690h case    7:*/		if ( regs.CR[6].eq ) { return 0x821946DC;  }
		/* 82194690h case    7:*/		return 0x82194694;
		  /* 82194694h */ case    8:  		/* lwz R11, <#[R8 + 16]> */
		/* 82194694h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000010) );
		/* 82194694h case    8:*/		return 0x82194698;
		  /* 82194698h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82194698h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82194698h case    9:*/		return 0x8219469C;
		  /* 8219469Ch */ case   10:  		/* bc 12, CR6_EQ, 56 */
		/* 8219469Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x821946D4;  }
		/* 8219469Ch case   10:*/		return 0x821946A0;
		  /* 821946A0h */ case   11:  		/* lwz R10, <#[R11 + 28]> */
		/* 821946A0h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000001C) );
		/* 821946A0h case   11:*/		return 0x821946A4;
		  /* 821946A4h */ case   12:  		/* cmplw CR6, R10, R15 */
		/* 821946A4h case   12:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R15);
		/* 821946A4h case   12:*/		return 0x821946A8;
		  /* 821946A8h */ case   13:  		/* bc 4, CR6_EQ, 44 */
		/* 821946A8h case   13:*/		if ( !regs.CR[6].eq ) { return 0x821946D4;  }
		/* 821946A8h case   13:*/		return 0x821946AC;
		  /* 821946ACh */ case   14:  		/* lwz R10, <#[R11 + 8]> */
		/* 821946ACh case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821946ACh case   14:*/		return 0x821946B0;
		  /* 821946B0h */ case   15:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 821946B0h case   15:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 821946B0h case   15:*/		return 0x821946B4;
		  /* 821946B4h */ case   16:  		/* cmplwi CR6, R10, 14336 */
		/* 821946B4h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003800);
		/* 821946B4h case   16:*/		return 0x821946B8;
		  /* 821946B8h */ case   17:  		/* bc 12, CR6_EQ, 28 */
		/* 821946B8h case   17:*/		if ( regs.CR[6].eq ) { return 0x821946D4;  }
		/* 821946B8h case   17:*/		return 0x821946BC;
		  /* 821946BCh */ case   18:  		/* lwz R10, <#[R11 + 20]> */
		/* 821946BCh case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 821946BCh case   18:*/		return 0x821946C0;
		  /* 821946C0h */ case   19:  		/* rlwinm R10, R10, 0, 19, 31 */
		/* 821946C0h case   19:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R10,regs.R10);
		/* 821946C0h case   19:*/		return 0x821946C4;
		  /* 821946C4h */ case   20:  		/* cmplw CR6, R10, R9 */
		/* 821946C4h case   20:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821946C4h case   20:*/		return 0x821946C8;
		  /* 821946C8h */ case   21:  		/* bc 12, CR6_LT, 12 */
		/* 821946C8h case   21:*/		if ( regs.CR[6].lt ) { return 0x821946D4;  }
		/* 821946C8h case   21:*/		return 0x821946CC;
		  /* 821946CCh */ case   22:  		/* mr R9, R10 */
		/* 821946CCh case   22:*/		regs.R9 = regs.R10;
		/* 821946CCh case   22:*/		return 0x821946D0;
		  /* 821946D0h */ case   23:  		/* mr R30, R11 */
		/* 821946D0h case   23:*/		regs.R30 = regs.R11;
		/* 821946D0h case   23:*/		return 0x821946D4;
	}
	return 0x821946D4;
} // Block from 82194674h-821946D4h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821946D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821946D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821946D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821946D4);
		  /* 821946D4h */ case    0:  		/* lwz R8, <#[R8 + 8]> */
		/* 821946D4h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000008) );
		/* 821946D4h case    0:*/		return 0x821946D8;
		  /* 821946D8h */ case    1:  		/* b -76 */
		/* 821946D8h case    1:*/		return 0x8219468C;
		/* 821946D8h case    1:*/		return 0x821946DC;
	}
	return 0x821946DC;
} // Block from 821946D4h-821946DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821946DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821946DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821946DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821946DC);
		  /* 821946DCh */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 821946DCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821946DCh case    0:*/		return 0x821946E0;
		  /* 821946E0h */ case    1:  		/* bc 12, CR6_EQ, 408 */
		/* 821946E0h case    1:*/		if ( regs.CR[6].eq ) { return 0x82194878;  }
		/* 821946E0h case    1:*/		return 0x821946E4;
		  /* 821946E4h */ case    2:  		/* add R11, R9, R29 */
		/* 821946E4h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R29);
		/* 821946E4h case    2:*/		return 0x821946E8;
		  /* 821946E8h */ case    3:  		/* addi R11, R11, 1 */
		/* 821946E8h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821946E8h case    3:*/		return 0x821946EC;
		  /* 821946ECh */ case    4:  		/* cmplw CR6, R11, R22 */
		/* 821946ECh case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R22);
		/* 821946ECh case    4:*/		return 0x821946F0;
		  /* 821946F0h */ case    5:  		/* bc 4, CR6_GT, 372 */
		/* 821946F0h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82194864;  }
		/* 821946F0h case    5:*/		return 0x821946F4;
		  /* 821946F4h */ case    6:  		/* cmplwi CR6, R29, 1 */
		/* 821946F4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000001);
		/* 821946F4h case    6:*/		return 0x821946F8;
		  /* 821946F8h */ case    7:  		/* bc 4, CR6_GT, 16 */
		/* 821946F8h case    7:*/		if ( !regs.CR[6].gt ) { return 0x82194708;  }
		/* 821946F8h case    7:*/		return 0x821946FC;
		  /* 821946FCh */ case    8:  		/* addi R10, R22, 1 */
		/* 821946FCh case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R22,0x1);
		/* 821946FCh case    8:*/		return 0x82194700;
		  /* 82194700h */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 82194700h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82194700h case    9:*/		return 0x82194704;
		  /* 82194704h */ case   10:  		/* bc 4, CR6_GT, 352 */
		/* 82194704h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82194864;  }
		/* 82194704h case   10:*/		return 0x82194708;
	}
	return 0x82194708;
} // Block from 821946DCh-82194708h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82194708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194708);
		  /* 82194708h */ case    0:  		/* lwz R11, <#[R24 + 8]> */
		/* 82194708h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 82194708h case    0:*/		return 0x8219470C;
		  /* 8219470Ch */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219470Ch case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219470Ch case    1:*/		return 0x82194710;
		  /* 82194710h */ case    2:  		/* cmplwi CR6, R11, 1 */
		/* 82194710h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82194710h case    2:*/		return 0x82194714;
		  /* 82194714h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 82194714h case    3:*/		if ( regs.CR[6].lt ) { return 0x82194724;  }
		/* 82194714h case    3:*/		return 0x82194718;
		  /* 82194718h */ case    4:  		/* cmplwi CR6, R11, 82 */
		/* 82194718h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 82194718h case    4:*/		return 0x8219471C;
		  /* 8219471Ch */ case    5:  		/* li R11, 1 */
		/* 8219471Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219471Ch case    5:*/		return 0x82194720;
		  /* 82194720h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 82194720h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82194728;  }
		/* 82194720h case    6:*/		return 0x82194724;
	}
	return 0x82194724;
} // Block from 82194708h-82194724h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82194724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194724);
		  /* 82194724h */ case    0:  		/* mr R11, R18 */
		/* 82194724h case    0:*/		regs.R11 = regs.R18;
		/* 82194724h case    0:*/		return 0x82194728;
	}
	return 0x82194728;
} // Block from 82194724h-82194728h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82194728h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194728);
		  /* 82194728h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 82194728h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82194728h case    0:*/		return 0x8219472C;
		  /* 8219472Ch */ case    1:  		/* addic R10, R11, -1 */
		/* 8219472Ch case    1:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 8219472Ch case    1:*/		return 0x82194730;
		  /* 82194730h */ case    2:  		/* subfe R11, R10, R11 */
		/* 82194730h case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82194730h case    2:*/		return 0x82194734;
		  /* 82194734h */ case    3:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82194734h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82194734h case    3:*/		return 0x82194738;
		  /* 82194738h */ case    4:  		/* bc 12, CR0_EQ, 108 */
		/* 82194738h case    4:*/		if ( regs.CR[0].eq ) { return 0x821947A4;  }
		/* 82194738h case    4:*/		return 0x8219473C;
		  /* 8219473Ch */ case    5:  		/* mr R4, R24 */
		/* 8219473Ch case    5:*/		regs.R4 = regs.R24;
		/* 8219473Ch case    5:*/		return 0x82194740;
		  /* 82194740h */ case    6:  		/* addi R3, R1, 100 */
		/* 82194740h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x64);
		/* 82194740h case    6:*/		return 0x82194744;
		  /* 82194744h */ case    7:  		/* bl -152428 */
		/* 82194744h case    7:*/		regs.LR = 0x82194748; return 0x8216F3D8;
		/* 82194744h case    7:*/		return 0x82194748;
		  /* 82194748h */ case    8:  		/* addi R5, R1, 100 */
		/* 82194748h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x64);
		/* 82194748h case    8:*/		return 0x8219474C;
		  /* 8219474Ch */ case    9:  		/* mr R4, R24 */
		/* 8219474Ch case    9:*/		regs.R4 = regs.R24;
		/* 8219474Ch case    9:*/		return 0x82194750;
		  /* 82194750h */ case   10:  		/* addi R3, R1, 96 */
		/* 82194750h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82194750h case   10:*/		return 0x82194754;
		  /* 82194754h */ case   11:  		/* bl -4148 */
		/* 82194754h case   11:*/		regs.LR = 0x82194758; return 0x82193720;
		/* 82194754h case   11:*/		return 0x82194758;
		  /* 82194758h */ case   12:  		/* mr R31, R3 */
		/* 82194758h case   12:*/		regs.R31 = regs.R3;
		/* 82194758h case   12:*/		return 0x8219475C;
		  /* 8219475Ch */ case   13:  		/* mr R4, R24 */
		/* 8219475Ch case   13:*/		regs.R4 = regs.R24;
		/* 8219475Ch case   13:*/		return 0x82194760;
		  /* 82194760h */ case   14:  		/* addi R3, R1, 100 */
		/* 82194760h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x64);
		/* 82194760h case   14:*/		return 0x82194764;
		  /* 82194764h */ case   15:  		/* bl -17068 */
		/* 82194764h case   15:*/		regs.LR = 0x82194768; return 0x821904B8;
		/* 82194764h case   15:*/		return 0x82194768;
		  /* 82194768h */ case   16:  		/* mr R25, R31 */
		/* 82194768h case   16:*/		regs.R25 = regs.R31;
		/* 82194768h case   16:*/		return 0x8219476C;
		  /* 8219476Ch */ case   17:  		/* cmplwi CR6, R31, 0 */
		/* 8219476Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219476Ch case   17:*/		return 0x82194770;
		  /* 82194770h */ case   18:  		/* bc 12, CR6_EQ, 52 */
		/* 82194770h case   18:*/		if ( regs.CR[6].eq ) { return 0x821947A4;  }
		/* 82194770h case   18:*/		return 0x82194774;
		  /* 82194774h */ case   19:  		/* lwz R11, <#[R31 + 8]> */
		/* 82194774h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82194774h case   19:*/		return 0x82194778;
		  /* 82194778h */ case   20:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82194778h case   20:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82194778h case   20:*/		return 0x8219477C;
		  /* 8219477Ch */ case   21:  		/* cmplwi CR6, R11, 1 */
		/* 8219477Ch case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8219477Ch case   21:*/		return 0x82194780;
		  /* 82194780h */ case   22:  		/* bc 12, CR6_LT, 16 */
		/* 82194780h case   22:*/		if ( regs.CR[6].lt ) { return 0x82194790;  }
		/* 82194780h case   22:*/		return 0x82194784;
		  /* 82194784h */ case   23:  		/* cmplwi CR6, R11, 31 */
		/* 82194784h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001F);
		/* 82194784h case   23:*/		return 0x82194788;
		  /* 82194788h */ case   24:  		/* li R11, 1 */
		/* 82194788h case   24:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82194788h case   24:*/		return 0x8219478C;
		  /* 8219478Ch */ case   25:  		/* bc 4, CR6_GT, 8 */
		/* 8219478Ch case   25:*/		if ( !regs.CR[6].gt ) { return 0x82194794;  }
		/* 8219478Ch case   25:*/		return 0x82194790;
	}
	return 0x82194790;
} // Block from 82194728h-82194790h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82194790h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194790);
		  /* 82194790h */ case    0:  		/* mr R11, R18 */
		/* 82194790h case    0:*/		regs.R11 = regs.R18;
		/* 82194790h case    0:*/		return 0x82194794;
	}
	return 0x82194794;
} // Block from 82194790h-82194794h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82194794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194794);
		  /* 82194794h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82194794h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82194794h case    0:*/		return 0x82194798;
		  /* 82194798h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82194798h case    1:*/		if ( regs.CR[0].eq ) { return 0x821947A4;  }
		/* 82194798h case    1:*/		return 0x8219479C;
		  /* 8219479Ch */ case    2:  		/* mr R25, R24 */
		/* 8219479Ch case    2:*/		regs.R25 = regs.R24;
		/* 8219479Ch case    2:*/		return 0x821947A0;
		  /* 821947A0h */ case    3:  		/* mr R24, R31 */
		/* 821947A0h case    3:*/		regs.R24 = regs.R31;
		/* 821947A0h case    3:*/		return 0x821947A4;
	}
	return 0x821947A4;
} // Block from 82194794h-821947A4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821947A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821947A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821947A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821947A4);
		  /* 821947A4h */ case    0:  		/* mr R4, R24 */
		/* 821947A4h case    0:*/		regs.R4 = regs.R24;
		/* 821947A4h case    0:*/		return 0x821947A8;
		  /* 821947A8h */ case    1:  		/* addi R3, R1, 100 */
		/* 821947A8h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x64);
		/* 821947A8h case    1:*/		return 0x821947AC;
		  /* 821947ACh */ case    2:  		/* bl -19556 */
		/* 821947ACh case    2:*/		regs.LR = 0x821947B0; return 0x8218FB48;
		/* 821947ACh case    2:*/		return 0x821947B0;
		  /* 821947B0h */ case    3:  		/* rlwinm R11, R24, 0, 0, 30 */
		/* 821947B0h case    3:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R24);
		/* 821947B0h case    3:*/		return 0x821947B4;
		  /* 821947B4h */ case    4:  		/* lwz R9, <#[R23]> */
		/* 821947B4h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000000) );
		/* 821947B4h case    4:*/		return 0x821947B8;
		  /* 821947B8h */ case    5:  		/* mr R5, R22 */
		/* 821947B8h case    5:*/		regs.R5 = regs.R22;
		/* 821947B8h case    5:*/		return 0x821947BC;
		  /* 821947BCh */ case    6:  		/* addi R31, R11, 36 */
		/* 821947BCh case    6:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x24);
		/* 821947BCh case    6:*/		return 0x821947C0;
		  /* 821947C0h */ case    7:  		/* mr R4, R24 */
		/* 821947C0h case    7:*/		regs.R4 = regs.R24;
		/* 821947C0h case    7:*/		return 0x821947C4;
		  /* 821947C4h */ case    8:  		/* addi R11, R31, 4 */
		/* 821947C4h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x4);
		/* 821947C4h case    8:*/		return 0x821947C8;
		  /* 821947C8h */ case    9:  		/* addi R10, R31, -36 */
		/* 821947C8h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFDC);
		/* 821947C8h case    9:*/		return 0x821947CC;
		  /* 821947CCh */ case   10:  		/* mr R3, R21 */
		/* 821947CCh case   10:*/		regs.R3 = regs.R21;
		/* 821947CCh case   10:*/		return 0x821947D0;
		  /* 821947D0h */ case   11:  		/* stw R9, <#[R31 + 4]> */
		/* 821947D0h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 821947D0h case   11:*/		return 0x821947D4;
		  /* 821947D4h */ case   12:  		/* lwz R9, <#[R23]> */
		/* 821947D4h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000000) );
		/* 821947D4h case   12:*/		return 0x821947D8;
		  /* 821947D8h */ case   13:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 821947D8h case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 821947D8h case   13:*/		return 0x821947DC;
		  /* 821947DCh */ case   14:  		/* stw R11, <#[R9 + 36]> */
		/* 821947DCh case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000024) );
		/* 821947DCh case   14:*/		return 0x821947E0;
		  /* 821947E0h */ case   15:  		/* stw R20, <#[R31]> */
		/* 821947E0h case   15:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R31 + 0x00000000) );
		/* 821947E0h case   15:*/		return 0x821947E4;
		  /* 821947E4h */ case   16:  		/* stw R10, <#[R23]> */
		/* 821947E4h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R23 + 0x00000000) );
		/* 821947E4h case   16:*/		return 0x821947E8;
		  /* 821947E8h */ case   17:  		/* bl -6440 */
		/* 821947E8h case   17:*/		regs.LR = 0x821947EC; return 0x82192EC0;
		/* 821947E8h case   17:*/		return 0x821947EC;
		  /* 821947ECh */ case   18:  		/* cmplwi CR6, R25, 0 */
		/* 821947ECh case   18:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 821947ECh case   18:*/		return 0x821947F0;
		  /* 821947F0h */ case   19:  		/* bc 12, CR6_EQ, 1640 */
		/* 821947F0h case   19:*/		if ( regs.CR[6].eq ) { return 0x82194E58;  }
		/* 821947F0h case   19:*/		return 0x821947F4;
		  /* 821947F4h */ case   20:  		/* mr R4, R25 */
		/* 821947F4h case   20:*/		regs.R4 = regs.R25;
		/* 821947F4h case   20:*/		return 0x821947F8;
		  /* 821947F8h */ case   21:  		/* addi R3, R1, 100 */
		/* 821947F8h case   21:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x64);
		/* 821947F8h case   21:*/		return 0x821947FC;
		  /* 821947FCh */ case   22:  		/* bl -19636 */
		/* 821947FCh case   22:*/		regs.LR = 0x82194800; return 0x8218FB48;
		/* 821947FCh case   22:*/		return 0x82194800;
		  /* 82194800h */ case   23:  		/* rlwinm R11, R25, 0, 0, 30 */
		/* 82194800h case   23:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R25);
		/* 82194800h case   23:*/		return 0x82194804;
		  /* 82194804h */ case   24:  		/* lwz R7, <#[R31 + 4]> */
		/* 82194804h case   24:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000004) );
		/* 82194804h case   24:*/		return 0x82194808;
		  /* 82194808h */ case   25:  		/* addi R10, R31, 4 */
		/* 82194808h case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x4);
		/* 82194808h case   25:*/		return 0x8219480C;
		  /* 8219480Ch */ case   26:  		/* addi R11, R11, 36 */
		/* 8219480Ch case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 8219480Ch case   26:*/		return 0x82194810;
		  /* 82194810h */ case   27:  		/* mr R5, R22 */
		/* 82194810h case   27:*/		regs.R5 = regs.R22;
		/* 82194810h case   27:*/		return 0x82194814;
		  /* 82194814h */ case   28:  		/* addi R9, R11, 4 */
		/* 82194814h case   28:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 82194814h case   28:*/		return 0x82194818;
		  /* 82194818h */ case   29:  		/* addi R8, R11, -36 */
		/* 82194818h case   29:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 82194818h case   29:*/		return 0x8219481C;
		  /* 8219481Ch */ case   30:  		/* mr R4, R25 */
		/* 8219481Ch case   30:*/		regs.R4 = regs.R25;
		/* 8219481Ch case   30:*/		return 0x82194820;
		  /* 82194820h */ case   31:  		/* stw R7, <#[R11 + 4]> */
		/* 82194820h case   31:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82194820h case   31:*/		return 0x82194824;
		  /* 82194824h */ case   32:  		/* mr R3, R21 */
		/* 82194824h case   32:*/		regs.R3 = regs.R21;
		/* 82194824h case   32:*/		return 0x82194828;
		  /* 82194828h */ case   33:  		/* lwz R7, <#[R31 + 4]> */
		/* 82194828h case   33:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000004) );
		/* 82194828h case   33:*/		return 0x8219482C;
		  /* 8219482Ch */ case   34:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 8219482Ch case   34:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 8219482Ch case   34:*/		return 0x82194830;
		  /* 82194830h */ case   35:  		/* stw R9, <#[R7 + 36]> */
		/* 82194830h case   35:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + 0x00000024) );
		/* 82194830h case   35:*/		return 0x82194834;
		  /* 82194834h */ case   36:  		/* stw R10, <#[R11]> */
		/* 82194834h case   36:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82194834h case   36:*/		return 0x82194838;
		  /* 82194838h */ case   37:  		/* stw R8, <#[R31 + 4]> */
		/* 82194838h case   37:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 82194838h case   37:*/		return 0x8219483C;
		  /* 8219483Ch */ case   38:  		/* bl -6524 */
		/* 8219483Ch case   38:*/		regs.LR = 0x82194840; return 0x82192EC0;
		/* 8219483Ch case   38:*/		return 0x82194840;
		  /* 82194840h */ case   39:  		/* b 1604 */
		/* 82194840h case   39:*/		return 0x82194E84;
		/* 82194840h case   39:*/		return 0x82194844;
		  /* 82194844h */ case   40:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82194844h case   40:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82194844h case   40:*/		return 0x82194848;
		  /* 82194848h */ case   41:  		/* lwz R11, <#[R11 + 36]> */
		/* 82194848h case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82194848h case   41:*/		return 0x8219484C;
		  /* 8219484Ch */ case   42:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219484Ch case   42:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219484Ch case   42:*/		return 0x82194850;
		  /* 82194850h */ case   43:  		/* bc 12, CR0_EQ, 12 */
		/* 82194850h case   43:*/		if ( regs.CR[0].eq ) { return 0x8219485C;  }
		/* 82194850h case   43:*/		return 0x82194854;
		  /* 82194854h */ case   44:  		/* mr R30, R18 */
		/* 82194854h case   44:*/		regs.R30 = regs.R18;
		/* 82194854h case   44:*/		return 0x82194858;
		  /* 82194858h */ case   45:  		/* b 12 */
		/* 82194858h case   45:*/		return 0x82194864;
		/* 82194858h case   45:*/		return 0x8219485C;
	}
	return 0x8219485C;
} // Block from 821947A4h-8219485Ch (46 instructions)

//////////////////////////////////////////////////////
// Block at 8219485Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219485C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219485C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219485C);
		  /* 8219485Ch */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8219485Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8219485Ch case    0:*/		return 0x82194860;
		  /* 82194860h */ case    1:  		/* addi R30, R11, -40 */
		/* 82194860h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFD8);
		/* 82194860h case    1:*/		return 0x82194864;
	}
	return 0x82194864;
} // Block from 8219485Ch-82194864h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82194864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194864);
		  /* 82194864h */ case    0:  		/* lwz R11, <#[R30 + 20]> */
		/* 82194864h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 82194864h case    0:*/		return 0x82194868;
		  /* 82194868h */ case    1:  		/* rlwinm R11, R11, 0, 19, 31 */
		/* 82194868h case    1:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R11);
		/* 82194868h case    1:*/		return 0x8219486C;
		  /* 8219486Ch */ case    2:  		/* cmplw CR6, R11, R9 */
		/* 8219486Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8219486Ch case    2:*/		return 0x82194870;
		  /* 82194870h */ case    3:  		/* bc 12, CR6_EQ, -44 */
		/* 82194870h case    3:*/		if ( regs.CR[6].eq ) { return 0x82194844;  }
		/* 82194870h case    3:*/		return 0x82194874;
		  /* 82194874h */ case    4:  		/* b 36 */
		/* 82194874h case    4:*/		return 0x82194898;
		/* 82194874h case    4:*/		return 0x82194878;
	}
	return 0x82194878;
} // Block from 82194864h-82194878h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82194878h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194878);
		  /* 82194878h */ case    0:  		/* lwz R11, <#[R23]> */
		/* 82194878h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 82194878h case    0:*/		return 0x8219487C;
		  /* 8219487Ch */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8219487Ch case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8219487Ch case    1:*/		return 0x82194880;
		  /* 82194880h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 82194880h case    2:*/		if ( regs.CR[0].eq ) { return 0x8219488C;  }
		/* 82194880h case    2:*/		return 0x82194884;
		  /* 82194884h */ case    3:  		/* mr R30, R18 */
		/* 82194884h case    3:*/		regs.R30 = regs.R18;
		/* 82194884h case    3:*/		return 0x82194888;
		  /* 82194888h */ case    4:  		/* b 16 */
		/* 82194888h case    4:*/		return 0x82194898;
		/* 82194888h case    4:*/		return 0x8219488C;
	}
	return 0x8219488C;
} // Block from 82194878h-8219488Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219488Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219488C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219488C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219488C);
		  /* 8219488Ch */ case    0:  		/* lwz R11, <#[R19]> */
		/* 8219488Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8219488Ch case    0:*/		return 0x82194890;
		  /* 82194890h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82194890h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82194890h case    1:*/		return 0x82194894;
		  /* 82194894h */ case    2:  		/* addi R30, R11, -40 */
		/* 82194894h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFD8);
		/* 82194894h case    2:*/		return 0x82194898;
	}
	return 0x82194898;
} // Block from 8219488Ch-82194898h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82194898h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194898);
		  /* 82194898h */ case    0:  		/* mr R6, R30 */
		/* 82194898h case    0:*/		regs.R6 = regs.R30;
		/* 82194898h case    0:*/		return 0x8219489C;
		  /* 8219489Ch */ case    1:  		/* mr R5, R19 */
		/* 8219489Ch case    1:*/		regs.R5 = regs.R19;
		/* 8219489Ch case    1:*/		return 0x821948A0;
		  /* 821948A0h */ case    2:  		/* addi R4, R1, 96 */
		/* 821948A0h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 821948A0h case    2:*/		return 0x821948A4;
		  /* 821948A4h */ case    3:  		/* addi R3, R1, 160 */
		/* 821948A4h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 821948A4h case    3:*/		return 0x821948A8;
		  /* 821948A8h */ case    4:  		/* bl -16824 */
		/* 821948A8h case    4:*/		regs.LR = 0x821948AC; return 0x821906F0;
		/* 821948A8h case    4:*/		return 0x821948AC;
		  /* 821948ACh */ case    5:  		/* mr R31, R18 */
		/* 821948ACh case    5:*/		regs.R31 = regs.R18;
		/* 821948ACh case    5:*/		return 0x821948B0;
		  /* 821948B0h */ case    6:  		/* addi R3, R1, 160 */
		/* 821948B0h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 821948B0h case    6:*/		return 0x821948B4;
		  /* 821948B4h */ case    7:  		/* bl -16644 */
		/* 821948B4h case    7:*/		regs.LR = 0x821948B8; return 0x821907B0;
		/* 821948B4h case    7:*/		return 0x821948B8;
		  /* 821948B8h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821948B8h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821948B8h case    8:*/		return 0x821948BC;
		  /* 821948BCh */ case    9:  		/* bc 12, CR0_EQ, 8 */
		/* 821948BCh case    9:*/		if ( regs.CR[0].eq ) { return 0x821948C4;  }
		/* 821948BCh case    9:*/		return 0x821948C0;
		  /* 821948C0h */ case   10:  		/* addi R31, R31, 1 */
		/* 821948C0h case   10:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 821948C0h case   10:*/		return 0x821948C4;
	}
	return 0x821948C4;
} // Block from 82194898h-821948C4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821948C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821948C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821948C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821948C4);
		  /* 821948C4h */ case    0:  		/* cmplw CR6, R31, R29 */
		/* 821948C4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 821948C4h case    0:*/		return 0x821948C8;
		  /* 821948C8h */ case    1:  		/* bc 4, CR6_LT, 20 */
		/* 821948C8h case    1:*/		if ( !regs.CR[6].lt ) { return 0x821948DC;  }
		/* 821948C8h case    1:*/		return 0x821948CC;
		  /* 821948CCh */ case    2:  		/* addi R3, R1, 160 */
		/* 821948CCh case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 821948CCh case    2:*/		return 0x821948D0;
		  /* 821948D0h */ case    3:  		/* bl -16168 */
		/* 821948D0h case    3:*/		regs.LR = 0x821948D4; return 0x821909A8;
		/* 821948D0h case    3:*/		return 0x821948D4;
		  /* 821948D4h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821948D4h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821948D4h case    4:*/		return 0x821948D8;
		  /* 821948D8h */ case    5:  		/* bc 4, CR0_EQ, -40 */
		/* 821948D8h case    5:*/		if ( !regs.CR[0].eq ) { return 0x821948B0;  }
		/* 821948D8h case    5:*/		return 0x821948DC;
	}
	return 0x821948DC;
} // Block from 821948C4h-821948DCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821948DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821948DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821948DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821948DC);
		  /* 821948DCh */ case    0:  		/* addi R11, R31, 1 */
		/* 821948DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x1);
		/* 821948DCh case    0:*/		return 0x821948E0;
		  /* 821948E0h */ case    1:  		/* cmplw CR6, R29, R11 */
		/* 821948E0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 821948E0h case    1:*/		return 0x821948E4;
		  /* 821948E4h */ case    2:  		/* bc 12, CR6_GT, -476 */
		/* 821948E4h case    2:*/		if ( regs.CR[6].gt ) { return 0x82194708;  }
		/* 821948E4h case    2:*/		return 0x821948E8;
		  /* 821948E8h */ case    3:  		/* addi R11, R1, 44 */
		/* 821948E8h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x2C);
		/* 821948E8h case    3:*/		return 0x821948EC;
		  /* 821948ECh */ case    4:  		/* addi R10, R1, 84 */
		/* 821948ECh case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x54);
		/* 821948ECh case    4:*/		return 0x821948F0;
		  /* 821948F0h */ case    5:  		/* ori R10, R10, 1 */
		/* 821948F0h case    5:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821948F0h case    5:*/		return 0x821948F4;
		  /* 821948F4h */ case    6:  		/* ori R11, R11, 1 */
		/* 821948F4h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821948F4h case    6:*/		return 0x821948F8;
		  /* 821948F8h */ case    7:  		/* stw R10, <#[R1 + 80]> */
		/* 821948F8h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 821948F8h case    7:*/		return 0x821948FC;
		  /* 821948FCh */ case    8:  		/* addi R5, R1, 80 */
		/* 821948FCh case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 821948FCh case    8:*/		return 0x82194900;
		  /* 82194900h */ case    9:  		/* stw R11, <#[R1 + 84]> */
		/* 82194900h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82194900h case    9:*/		return 0x82194904;
		  /* 82194904h */ case   10:  		/* mr R4, R24 */
		/* 82194904h case   10:*/		regs.R4 = regs.R24;
		/* 82194904h case   10:*/		return 0x82194908;
		  /* 82194908h */ case   11:  		/* mr R3, R21 */
		/* 82194908h case   11:*/		regs.R3 = regs.R21;
		/* 82194908h case   11:*/		return 0x8219490C;
		  /* 8219490Ch */ case   12:  		/* bl -3196 */
		/* 8219490Ch case   12:*/		regs.LR = 0x82194910; return 0x82193C90;
		/* 8219490Ch case   12:*/		return 0x82194910;
		  /* 82194910h */ case   13:  		/* lwz R11, <#[R1 + 84]> */
		/* 82194910h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82194910h case   13:*/		return 0x82194914;
		  /* 82194914h */ case   14:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82194914h case   14:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82194914h case   14:*/		return 0x82194918;
		  /* 82194918h */ case   15:  		/* bc 4, CR0_EQ, -528 */
		/* 82194918h case   15:*/		if ( !regs.CR[0].eq ) { return 0x82194708;  }
		/* 82194918h case   15:*/		return 0x8219491C;
		  /* 8219491Ch */ case   16:  		/* lwz R11, <#[R1 + 80]> */
		/* 8219491Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8219491Ch case   16:*/		return 0x82194920;
		  /* 82194920h */ case   17:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82194920h case   17:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82194920h case   17:*/		return 0x82194924;
		  /* 82194924h */ case   18:  		/* addic. R26, R11, -40 */
		/* 82194924h case   18:*/		cpu::op::addic<1>(regs,&regs.R26,regs.R11,0xFFFFFFD8);
		/* 82194924h case   18:*/		return 0x82194928;
		  /* 82194928h */ case   19:  		/* bc 12, CR0_EQ, -544 */
		/* 82194928h case   19:*/		if ( regs.CR[0].eq ) { return 0x82194708;  }
		/* 82194928h case   19:*/		return 0x8219492C;
		  /* 8219492Ch */ case   20:  		/* mr R28, R26 */
		/* 8219492Ch case   20:*/		regs.R28 = regs.R26;
		/* 8219492Ch case   20:*/		return 0x82194930;
		  /* 82194930h */ case   21:  		/* lwz R11, <#[R28 + 8]> */
		/* 82194930h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 82194930h case   21:*/		return 0x82194934;
		  /* 82194934h */ case   22:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82194934h case   22:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82194934h case   22:*/		return 0x82194938;
		  /* 82194938h */ case   23:  		/* cmplwi CR6, R11, 1 */
		/* 82194938h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82194938h case   23:*/		return 0x8219493C;
		  /* 8219493Ch */ case   24:  		/* bc 12, CR6_LT, 16 */
		/* 8219493Ch case   24:*/		if ( regs.CR[6].lt ) { return 0x8219494C;  }
		/* 8219493Ch case   24:*/		return 0x82194940;
		  /* 82194940h */ case   25:  		/* cmplwi CR6, R11, 102 */
		/* 82194940h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000066);
		/* 82194940h case   25:*/		return 0x82194944;
		  /* 82194944h */ case   26:  		/* li R11, 1 */
		/* 82194944h case   26:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82194944h case   26:*/		return 0x82194948;
		  /* 82194948h */ case   27:  		/* bc 4, CR6_GT, 8 */
		/* 82194948h case   27:*/		if ( !regs.CR[6].gt ) { return 0x82194950;  }
		/* 82194948h case   27:*/		return 0x8219494C;
	}
	return 0x8219494C;
} // Block from 821948DCh-8219494Ch (28 instructions)

//////////////////////////////////////////////////////
// Block at 8219494Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219494C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219494C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219494C);
		  /* 8219494Ch */ case    0:  		/* mr R11, R18 */
		/* 8219494Ch case    0:*/		regs.R11 = regs.R18;
		/* 8219494Ch case    0:*/		return 0x82194950;
	}
	return 0x82194950;
} // Block from 8219494Ch-82194950h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82194950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194950);
		  /* 82194950h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82194950h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82194950h case    0:*/		return 0x82194954;
		  /* 82194954h */ case    1:  		/* bc 4, CR0_EQ, 40 */
		/* 82194954h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219497C;  }
		/* 82194954h case    1:*/		return 0x82194958;
		  /* 82194958h */ case    2:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 82194958h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 82194958h case    2:*/		return 0x8219495C;
		  /* 8219495Ch */ case    3:  		/* lwz R11, <#[R11 + 36]> */
		/* 8219495Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 8219495Ch case    3:*/		return 0x82194960;
		  /* 82194960h */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82194960h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82194960h case    4:*/		return 0x82194964;
		  /* 82194964h */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 82194964h case    5:*/		if ( regs.CR[0].eq ) { return 0x82194970;  }
		/* 82194964h case    5:*/		return 0x82194968;
		  /* 82194968h */ case    6:  		/* mr R28, R18 */
		/* 82194968h case    6:*/		regs.R28 = regs.R18;
		/* 82194968h case    6:*/		return 0x8219496C;
		  /* 8219496Ch */ case    7:  		/* b -60 */
		/* 8219496Ch case    7:*/		return 0x82194930;
		/* 8219496Ch case    7:*/		return 0x82194970;
	}
	return 0x82194970;
} // Block from 82194950h-82194970h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82194970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194970);
		  /* 82194970h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82194970h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82194970h case    0:*/		return 0x82194974;
		  /* 82194974h */ case    1:  		/* addi R28, R11, -40 */
		/* 82194974h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0xFFFFFFD8);
		/* 82194974h case    1:*/		return 0x82194978;
		  /* 82194978h */ case    2:  		/* b -72 */
		/* 82194978h case    2:*/		return 0x82194930;
		/* 82194978h case    2:*/		return 0x8219497C;
	}
	return 0x8219497C;
} // Block from 82194970h-8219497Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219497Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219497C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219497C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219497C);
		  /* 8219497Ch */ case    0:  		/* mr R6, R30 */
		/* 8219497Ch case    0:*/		regs.R6 = regs.R30;
		/* 8219497Ch case    0:*/		return 0x82194980;
		  /* 82194980h */ case    1:  		/* mr R5, R19 */
		/* 82194980h case    1:*/		regs.R5 = regs.R19;
		/* 82194980h case    1:*/		return 0x82194984;
		  /* 82194984h */ case    2:  		/* addi R4, R1, 96 */
		/* 82194984h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 82194984h case    2:*/		return 0x82194988;
		  /* 82194988h */ case    3:  		/* addi R3, R1, 160 */
		/* 82194988h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 82194988h case    3:*/		return 0x8219498C;
		  /* 8219498Ch */ case    4:  		/* mr R30, R28 */
		/* 8219498Ch case    4:*/		regs.R30 = regs.R28;
		/* 8219498Ch case    4:*/		return 0x82194990;
		  /* 82194990h */ case    5:  		/* bl -17056 */
		/* 82194990h case    5:*/		regs.LR = 0x82194994; return 0x821906F0;
		/* 82194990h case    5:*/		return 0x82194994;
		  /* 82194994h */ case    6:  		/* mr R27, R18 */
		/* 82194994h case    6:*/		regs.R27 = regs.R18;
		/* 82194994h case    6:*/		return 0x82194998;
		  /* 82194998h */ case    7:  		/* mr R4, R30 */
		/* 82194998h case    7:*/		regs.R4 = regs.R30;
		/* 82194998h case    7:*/		return 0x8219499C;
		  /* 8219499Ch */ case    8:  		/* addi R3, R1, 160 */
		/* 8219499Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 8219499Ch case    8:*/		return 0x821949A0;
		  /* 821949A0h */ case    9:  		/* bl -16680 */
		/* 821949A0h case    9:*/		regs.LR = 0x821949A4; return 0x82190878;
		/* 821949A0h case    9:*/		return 0x821949A4;
		  /* 821949A4h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821949A4h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821949A4h case   10:*/		return 0x821949A8;
		  /* 821949A8h */ case   11:  		/* bc 12, CR0_EQ, 124 */
		/* 821949A8h case   11:*/		if ( regs.CR[0].eq ) { return 0x82194A24;  }
		/* 821949A8h case   11:*/		return 0x821949AC;
		  /* 821949ACh */ case   12:  		/* lwz R4, <#[R1 + 160]> */
		/* 821949ACh case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000A0) );
		/* 821949ACh case   12:*/		return 0x821949B0;
		  /* 821949B0h */ case   13:  		/* cmplwi CR6, R27, 0 */
		/* 821949B0h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 821949B0h case   13:*/		return 0x821949B4;
		  /* 821949B4h */ case   14:  		/* bc 4, CR6_EQ, 8 */
		/* 821949B4h case   14:*/		if ( !regs.CR[6].eq ) { return 0x821949BC;  }
		/* 821949B4h case   14:*/		return 0x821949B8;
		  /* 821949B8h */ case   15:  		/* mr R27, R4 */
		/* 821949B8h case   15:*/		regs.R27 = regs.R4;
		/* 821949B8h case   15:*/		return 0x821949BC;
	}
	return 0x821949BC;
} // Block from 8219497Ch-821949BCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 821949BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821949BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821949BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821949BC);
		  /* 821949BCh */ case    0:  		/* addi R3, R1, 164 */
		/* 821949BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA4);
		/* 821949BCh case    0:*/		return 0x821949C0;
		  /* 821949C0h */ case    1:  		/* mr R31, R4 */
		/* 821949C0h case    1:*/		regs.R31 = regs.R4;
		/* 821949C0h case    1:*/		return 0x821949C4;
		  /* 821949C4h */ case    2:  		/* bl -17676 */
		/* 821949C4h case    2:*/		regs.LR = 0x821949C8; return 0x821904B8;
		/* 821949C4h case    2:*/		return 0x821949C8;
		  /* 821949C8h */ case    3:  		/* mr R4, R30 */
		/* 821949C8h case    3:*/		regs.R4 = regs.R30;
		/* 821949C8h case    3:*/		return 0x821949CC;
		  /* 821949CCh */ case    4:  		/* addi R3, R1, 164 */
		/* 821949CCh case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA4);
		/* 821949CCh case    4:*/		return 0x821949D0;
		  /* 821949D0h */ case    5:  		/* bl -153080 */
		/* 821949D0h case    5:*/		regs.LR = 0x821949D4; return 0x8216F3D8;
		/* 821949D0h case    5:*/		return 0x821949D4;
		  /* 821949D4h */ case    6:  		/* mr R4, R31 */
		/* 821949D4h case    6:*/		regs.R4 = regs.R31;
		/* 821949D4h case    6:*/		return 0x821949D8;
		  /* 821949D8h */ case    7:  		/* addi R3, R1, 164 */
		/* 821949D8h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA4);
		/* 821949D8h case    7:*/		return 0x821949DC;
		  /* 821949DCh */ case    8:  		/* bl -153092 */
		/* 821949DCh case    8:*/		regs.LR = 0x821949E0; return 0x8216F3D8;
		/* 821949DCh case    8:*/		return 0x821949E0;
		  /* 821949E0h */ case    9:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 821949E0h case    9:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 821949E0h case    9:*/		return 0x821949E4;
		  /* 821949E4h */ case   10:  		/* lwz R11, <#[R11 + 36]> */
		/* 821949E4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 821949E4h case   10:*/		return 0x821949E8;
		  /* 821949E8h */ case   11:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821949E8h case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821949E8h case   11:*/		return 0x821949EC;
		  /* 821949ECh */ case   12:  		/* bc 4, CR0_EQ, 272 */
		/* 821949ECh case   12:*/		if ( !regs.CR[0].eq ) { return 0x82194AFC;  }
		/* 821949ECh case   12:*/		return 0x821949F0;
		  /* 821949F0h */ case   13:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821949F0h case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821949F0h case   13:*/		return 0x821949F4;
		  /* 821949F4h */ case   14:  		/* addic. R30, R11, -40 */
		/* 821949F4h case   14:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R11,0xFFFFFFD8);
		/* 821949F4h case   14:*/		return 0x821949F8;
		  /* 821949F8h */ case   15:  		/* bc 12, CR0_EQ, 264 */
		/* 821949F8h case   15:*/		if ( regs.CR[0].eq ) { return 0x82194B00;  }
		/* 821949F8h case   15:*/		return 0x821949FC;
		  /* 821949FCh */ case   16:  		/* lwz R11, <#[R30 + 8]> */
		/* 821949FCh case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821949FCh case   16:*/		return 0x82194A00;
		  /* 82194A00h */ case   17:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82194A00h case   17:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82194A00h case   17:*/		return 0x82194A04;
		  /* 82194A04h */ case   18:  		/* cmplwi CR6, R11, 1 */
		/* 82194A04h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82194A04h case   18:*/		return 0x82194A08;
		  /* 82194A08h */ case   19:  		/* bc 12, CR6_LT, 16 */
		/* 82194A08h case   19:*/		if ( regs.CR[6].lt ) { return 0x82194A18;  }
		/* 82194A08h case   19:*/		return 0x82194A0C;
		  /* 82194A0Ch */ case   20:  		/* cmplwi CR6, R11, 102 */
		/* 82194A0Ch case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000066);
		/* 82194A0Ch case   20:*/		return 0x82194A10;
		  /* 82194A10h */ case   21:  		/* li R11, 1 */
		/* 82194A10h case   21:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82194A10h case   21:*/		return 0x82194A14;
		  /* 82194A14h */ case   22:  		/* bc 4, CR6_GT, 8 */
		/* 82194A14h case   22:*/		if ( !regs.CR[6].gt ) { return 0x82194A1C;  }
		/* 82194A14h case   22:*/		return 0x82194A18;
	}
	return 0x82194A18;
} // Block from 821949BCh-82194A18h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82194A18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194A18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194A18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194A18);
		  /* 82194A18h */ case    0:  		/* mr R11, R18 */
		/* 82194A18h case    0:*/		regs.R11 = regs.R18;
		/* 82194A18h case    0:*/		return 0x82194A1C;
	}
	return 0x82194A1C;
} // Block from 82194A18h-82194A1Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82194A1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194A1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194A1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194A1C);
		  /* 82194A1Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82194A1Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82194A1Ch case    0:*/		return 0x82194A20;
		  /* 82194A20h */ case    1:  		/* bc 12, CR0_EQ, -64 */
		/* 82194A20h case    1:*/		if ( regs.CR[0].eq ) { return 0x821949E0;  }
		/* 82194A20h case    1:*/		return 0x82194A24;
	}
	return 0x82194A24;
} // Block from 82194A1Ch-82194A24h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82194A24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194A24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194A24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194A24);
		  /* 82194A24h */ case    0:  		/* addi R3, R1, 160 */
		/* 82194A24h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 82194A24h case    0:*/		return 0x82194A28;
		  /* 82194A28h */ case    1:  		/* bl -16512 */
		/* 82194A28h case    1:*/		regs.LR = 0x82194A2C; return 0x821909A8;
		/* 82194A28h case    1:*/		return 0x82194A2C;
		  /* 82194A2Ch */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82194A2Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82194A2Ch case    2:*/		return 0x82194A30;
		  /* 82194A30h */ case    3:  		/* bc 4, CR0_EQ, -152 */
		/* 82194A30h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82194998;  }
		/* 82194A30h case    3:*/		return 0x82194A34;
		  /* 82194A34h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 82194A34h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82194A34h case    4:*/		return 0x82194A38;
		  /* 82194A38h */ case    5:  		/* bc 12, CR6_EQ, 200 */
		/* 82194A38h case    5:*/		if ( regs.CR[6].eq ) { return 0x82194B00;  }
		/* 82194A38h case    5:*/		return 0x82194A3C;
		  /* 82194A3Ch */ case    6:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82194A3Ch case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82194A3Ch case    6:*/		return 0x82194A40;
		  /* 82194A40h */ case    7:  		/* lwz R11, <#[R11 + 36]> */
		/* 82194A40h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82194A40h case    7:*/		return 0x82194A44;
		  /* 82194A44h */ case    8:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82194A44h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82194A44h case    8:*/		return 0x82194A48;
		  /* 82194A48h */ case    9:  		/* bc 4, CR0_EQ, 16 */
		/* 82194A48h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82194A58;  }
		/* 82194A48h case    9:*/		return 0x82194A4C;
		  /* 82194A4Ch */ case   10:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82194A4Ch case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82194A4Ch case   10:*/		return 0x82194A50;
		  /* 82194A50h */ case   11:  		/* addic. R11, R11, -40 */
		/* 82194A50h case   11:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFD8);
		/* 82194A50h case   11:*/		return 0x82194A54;
		  /* 82194A54h */ case   12:  		/* bc 4, CR0_EQ, 232 */
		/* 82194A54h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82194B3C;  }
		/* 82194A54h case   12:*/		return 0x82194A58;
	}
	return 0x82194A58;
} // Block from 82194A24h-82194A58h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82194A58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194A58);
		  /* 82194A58h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 82194A58h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82194A58h case    0:*/		return 0x82194A5C;
		  /* 82194A5Ch */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82194A5Ch case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82194A5Ch case    1:*/		return 0x82194A60;
		  /* 82194A60h */ case    2:  		/* cmplwi CR6, R11, 32 */
		/* 82194A60h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 82194A60h case    2:*/		return 0x82194A64;
		  /* 82194A64h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 82194A64h case    3:*/		if ( regs.CR[6].lt ) { return 0x82194A74;  }
		/* 82194A64h case    3:*/		return 0x82194A68;
		  /* 82194A68h */ case    4:  		/* cmplwi CR6, R11, 82 */
		/* 82194A68h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 82194A68h case    4:*/		return 0x82194A6C;
		  /* 82194A6Ch */ case    5:  		/* li R11, 1 */
		/* 82194A6Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82194A6Ch case    5:*/		return 0x82194A70;
		  /* 82194A70h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 82194A70h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82194A78;  }
		/* 82194A70h case    6:*/		return 0x82194A74;
	}
	return 0x82194A74;
} // Block from 82194A58h-82194A74h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82194A74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194A74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194A74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194A74);
		  /* 82194A74h */ case    0:  		/* mr R11, R18 */
		/* 82194A74h case    0:*/		regs.R11 = regs.R18;
		/* 82194A74h case    0:*/		return 0x82194A78;
	}
	return 0x82194A78;
} // Block from 82194A74h-82194A78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82194A78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194A78);
		  /* 82194A78h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82194A78h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82194A78h case    0:*/		return 0x82194A7C;
		  /* 82194A7Ch */ case    1:  		/* bc 12, CR0_EQ, 192 */
		/* 82194A7Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82194B3C;  }
		/* 82194A7Ch case    1:*/		return 0x82194A80;
		  /* 82194A80h */ case    2:  		/* mr R4, R30 */
		/* 82194A80h case    2:*/		regs.R4 = regs.R30;
		/* 82194A80h case    2:*/		return 0x82194A84;
		  /* 82194A84h */ case    3:  		/* addi R3, R1, 164 */
		/* 82194A84h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA4);
		/* 82194A84h case    3:*/		return 0x82194A88;
		  /* 82194A88h */ case    4:  		/* bl -153904 */
		/* 82194A88h case    4:*/		regs.LR = 0x82194A8C; return 0x8216F158;
		/* 82194A88h case    4:*/		return 0x82194A8C;
		  /* 82194A8Ch */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82194A8Ch case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82194A8Ch case    5:*/		return 0x82194A90;
		  /* 82194A90h */ case    6:  		/* bc 12, CR0_EQ, 172 */
		/* 82194A90h case    6:*/		if ( regs.CR[0].eq ) { return 0x82194B3C;  }
		/* 82194A90h case    6:*/		return 0x82194A94;
		  /* 82194A94h */ case    7:  		/* addi R5, R1, 164 */
		/* 82194A94h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xA4);
		/* 82194A94h case    7:*/		return 0x82194A98;
		  /* 82194A98h */ case    8:  		/* mr R4, R30 */
		/* 82194A98h case    8:*/		regs.R4 = regs.R30;
		/* 82194A98h case    8:*/		return 0x82194A9C;
		  /* 82194A9Ch */ case    9:  		/* addi R3, R1, 96 */
		/* 82194A9Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82194A9Ch case    9:*/		return 0x82194AA0;
		  /* 82194AA0h */ case   10:  		/* bl -4992 */
		/* 82194AA0h case   10:*/		regs.LR = 0x82194AA4; return 0x82193720;
		/* 82194AA0h case   10:*/		return 0x82194AA4;
		  /* 82194AA4h */ case   11:  		/* or. R31, R3, R3 */
		/* 82194AA4h case   11:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 82194AA4h case   11:*/		return 0x82194AA8;
		  /* 82194AA8h */ case   12:  		/* bc 12, CR0_EQ, 148 */
		/* 82194AA8h case   12:*/		if ( regs.CR[0].eq ) { return 0x82194B3C;  }
		/* 82194AA8h case   12:*/		return 0x82194AAC;
		  /* 82194AACh */ case   13:  		/* mr R4, R31 */
		/* 82194AACh case   13:*/		regs.R4 = regs.R31;
		/* 82194AACh case   13:*/		return 0x82194AB0;
		  /* 82194AB0h */ case   14:  		/* addi R3, R1, 164 */
		/* 82194AB0h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA4);
		/* 82194AB0h case   14:*/		return 0x82194AB4;
		  /* 82194AB4h */ case   15:  		/* bl -153308 */
		/* 82194AB4h case   15:*/		regs.LR = 0x82194AB8; return 0x8216F3D8;
		/* 82194AB4h case   15:*/		return 0x82194AB8;
		  /* 82194AB8h */ case   16:  		/* stw R31, <#[R1 + 160]> */
		/* 82194AB8h case   16:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x000000A0) );
		/* 82194AB8h case   16:*/		return 0x82194ABC;
		  /* 82194ABCh */ case   17:  		/* mr R4, R30 */
		/* 82194ABCh case   17:*/		regs.R4 = regs.R30;
		/* 82194ABCh case   17:*/		return 0x82194AC0;
		  /* 82194AC0h */ case   18:  		/* addi R3, R1, 160 */
		/* 82194AC0h case   18:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 82194AC0h case   18:*/		return 0x82194AC4;
		  /* 82194AC4h */ case   19:  		/* bl -16972 */
		/* 82194AC4h case   19:*/		regs.LR = 0x82194AC8; return 0x82190878;
		/* 82194AC4h case   19:*/		return 0x82194AC8;
		  /* 82194AC8h */ case   20:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82194AC8h case   20:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82194AC8h case   20:*/		return 0x82194ACC;
		  /* 82194ACCh */ case   21:  		/* addi R3, R1, 96 */
		/* 82194ACCh case   21:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82194ACCh case   21:*/		return 0x82194AD0;
		  /* 82194AD0h */ case   22:  		/* bc 12, CR0_EQ, 124 */
		/* 82194AD0h case   22:*/		if ( regs.CR[0].eq ) { return 0x82194B4C;  }
		/* 82194AD0h case   22:*/		return 0x82194AD4;
		  /* 82194AD4h */ case   23:  		/* lwz R11, <#[R24 + 20]> */
		/* 82194AD4h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000014) );
		/* 82194AD4h case   23:*/		return 0x82194AD8;
		  /* 82194AD8h */ case   24:  		/* mr R4, R24 */
		/* 82194AD8h case   24:*/		regs.R4 = regs.R24;
		/* 82194AD8h case   24:*/		return 0x82194ADC;
		  /* 82194ADCh */ case   25:  		/* rlwinm R11, R11, 0, 6, 4 */
		/* 82194ADCh case   25:*/		cpu::op::rlwinm<0,0,6,4>(regs,&regs.R11,regs.R11);
		/* 82194ADCh case   25:*/		return 0x82194AE0;
		  /* 82194AE0h */ case   26:  		/* stw R11, <#[R24 + 20]> */
		/* 82194AE0h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x00000014) );
		/* 82194AE0h case   26:*/		return 0x82194AE4;
		  /* 82194AE4h */ case   27:  		/* bl -10516 */
		/* 82194AE4h case   27:*/		regs.LR = 0x82194AE8; return 0x821921D0;
		/* 82194AE4h case   27:*/		return 0x82194AE8;
		  /* 82194AE8h */ case   28:  		/* addi R4, R1, 80 */
		/* 82194AE8h case   28:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82194AE8h case   28:*/		return 0x82194AEC;
		  /* 82194AECh */ case   29:  		/* mr R3, R21 */
		/* 82194AECh case   29:*/		regs.R3 = regs.R21;
		/* 82194AECh case   29:*/		return 0x82194AF0;
		  /* 82194AF0h */ case   30:  		/* mr R24, R31 */
		/* 82194AF0h case   30:*/		regs.R24 = regs.R31;
		/* 82194AF0h case   30:*/		return 0x82194AF4;
		  /* 82194AF4h */ case   31:  		/* bl -12788 */
		/* 82194AF4h case   31:*/		regs.LR = 0x82194AF8; return 0x82191900;
		/* 82194AF4h case   31:*/		return 0x82194AF8;
		  /* 82194AF8h */ case   32:  		/* b -852 */
		/* 82194AF8h case   32:*/		return 0x821947A4;
		/* 82194AF8h case   32:*/		return 0x82194AFC;
	}
	return 0x82194AFC;
} // Block from 82194A78h-82194AFCh (33 instructions)

//////////////////////////////////////////////////////
// Block at 82194AFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194AFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194AFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194AFC);
		  /* 82194AFCh */ case    0:  		/* mr R30, R18 */
		/* 82194AFCh case    0:*/		regs.R30 = regs.R18;
		/* 82194AFCh case    0:*/		return 0x82194B00;
	}
	return 0x82194B00;
} // Block from 82194AFCh-82194B00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82194B00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194B00);
		  /* 82194B00h */ case    0:  		/* addi R3, R1, 160 */
		/* 82194B00h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 82194B00h case    0:*/		return 0x82194B04;
		  /* 82194B04h */ case    1:  		/* bl -16732 */
		/* 82194B04h case    1:*/		regs.LR = 0x82194B08; return 0x821909A8;
		/* 82194B04h case    1:*/		return 0x82194B08;
		  /* 82194B08h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82194B08h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82194B08h case    2:*/		return 0x82194B0C;
		  /* 82194B0Ch */ case    3:  		/* bc 4, CR0_EQ, -12 */
		/* 82194B0Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x82194B00;  }
		/* 82194B0Ch case    3:*/		return 0x82194B10;
		  /* 82194B10h */ case    4:  		/* lwz R11, <#[R1 + 160]> */
		/* 82194B10h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A0) );
		/* 82194B10h case    4:*/		return 0x82194B14;
		  /* 82194B14h */ case    5:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82194B14h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82194B14h case    5:*/		return 0x82194B18;
		  /* 82194B18h */ case    6:  		/* lwz R11, <#[R11 + 36]> */
		/* 82194B18h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82194B18h case    6:*/		return 0x82194B1C;
		  /* 82194B1Ch */ case    7:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82194B1Ch case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82194B1Ch case    7:*/		return 0x82194B20;
		  /* 82194B20h */ case    8:  		/* bc 4, CR0_EQ, 20 */
		/* 82194B20h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82194B34;  }
		/* 82194B20h case    8:*/		return 0x82194B24;
		  /* 82194B24h */ case    9:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82194B24h case    9:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82194B24h case    9:*/		return 0x82194B28;
		  /* 82194B28h */ case   10:  		/* addic. R11, R11, -40 */
		/* 82194B28h case   10:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFD8);
		/* 82194B28h case   10:*/		return 0x82194B2C;
		  /* 82194B2Ch */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 82194B2Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x82194B34;  }
		/* 82194B2Ch case   11:*/		return 0x82194B30;
		  /* 82194B30h */ case   12:  		/* li R30, 1 */
		/* 82194B30h case   12:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82194B30h case   12:*/		return 0x82194B34;
	}
	return 0x82194B34;
} // Block from 82194B00h-82194B34h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82194B34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194B34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194B34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194B34);
		  /* 82194B34h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 82194B34h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82194B34h case    0:*/		return 0x82194B38;
		  /* 82194B38h */ case    1:  		/* bc 12, CR6_EQ, 44 */
		/* 82194B38h case    1:*/		if ( regs.CR[6].eq ) { return 0x82194B64;  }
		/* 82194B38h case    1:*/		return 0x82194B3C;
	}
	return 0x82194B3C;
} // Block from 82194B34h-82194B3Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82194B3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194B3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194B3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194B3C);
		  /* 82194B3Ch */ case    0:  		/* addi R4, R1, 80 */
		/* 82194B3Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82194B3Ch case    0:*/		return 0x82194B40;
		  /* 82194B40h */ case    1:  		/* mr R3, R21 */
		/* 82194B40h case    1:*/		regs.R3 = regs.R21;
		/* 82194B40h case    1:*/		return 0x82194B44;
		  /* 82194B44h */ case    2:  		/* bl -12868 */
		/* 82194B44h case    2:*/		regs.LR = 0x82194B48; return 0x82191900;
		/* 82194B44h case    2:*/		return 0x82194B48;
		  /* 82194B48h */ case    3:  		/* b -1088 */
		/* 82194B48h case    3:*/		return 0x82194708;
		/* 82194B48h case    3:*/		return 0x82194B4C;
	}
	return 0x82194B4C;
} // Block from 82194B3Ch-82194B4Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82194B4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194B4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194B4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194B4C);
		  /* 82194B4Ch */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 82194B4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82194B4Ch case    0:*/		return 0x82194B50;
		  /* 82194B50h */ case    1:  		/* mr R4, R31 */
		/* 82194B50h case    1:*/		regs.R4 = regs.R31;
		/* 82194B50h case    1:*/		return 0x82194B54;
		  /* 82194B54h */ case    2:  		/* rlwinm R11, R11, 0, 6, 4 */
		/* 82194B54h case    2:*/		cpu::op::rlwinm<0,0,6,4>(regs,&regs.R11,regs.R11);
		/* 82194B54h case    2:*/		return 0x82194B58;
		  /* 82194B58h */ case    3:  		/* stw R11, <#[R31 + 20]> */
		/* 82194B58h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82194B58h case    3:*/		return 0x82194B5C;
		  /* 82194B5Ch */ case    4:  		/* bl -10636 */
		/* 82194B5Ch case    4:*/		regs.LR = 0x82194B60; return 0x821921D0;
		/* 82194B5Ch case    4:*/		return 0x82194B60;
		  /* 82194B60h */ case    5:  		/* b -36 */
		/* 82194B60h case    5:*/		return 0x82194B3C;
		/* 82194B60h case    5:*/		return 0x82194B64;
	}
	return 0x82194B64;
} // Block from 82194B4Ch-82194B64h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82194B64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194B64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194B64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194B64);
		  /* 82194B64h */ case    0:  		/* mr R6, R27 */
		/* 82194B64h case    0:*/		regs.R6 = regs.R27;
		/* 82194B64h case    0:*/		return 0x82194B68;
		  /* 82194B68h */ case    1:  		/* mr R5, R19 */
		/* 82194B68h case    1:*/		regs.R5 = regs.R19;
		/* 82194B68h case    1:*/		return 0x82194B6C;
		  /* 82194B6Ch */ case    2:  		/* addi R4, R1, 96 */
		/* 82194B6Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 82194B6Ch case    2:*/		return 0x82194B70;
		  /* 82194B70h */ case    3:  		/* addi R3, R1, 160 */
		/* 82194B70h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 82194B70h case    3:*/		return 0x82194B74;
		  /* 82194B74h */ case    4:  		/* bl -17540 */
		/* 82194B74h case    4:*/		regs.LR = 0x82194B78; return 0x821906F0;
		/* 82194B74h case    4:*/		return 0x82194B78;
		  /* 82194B78h */ case    5:  		/* lwz R11, <#[R27 + 20]> */
		/* 82194B78h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000014) );
		/* 82194B78h case    5:*/		return 0x82194B7C;
		  /* 82194B7Ch */ case    6:  		/* mr R31, R26 */
		/* 82194B7Ch case    6:*/		regs.R31 = regs.R26;
		/* 82194B7Ch case    6:*/		return 0x82194B80;
		  /* 82194B80h */ case    7:  		/* cmplw CR6, R26, R28 */
		/* 82194B80h case    7:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R28);
		/* 82194B80h case    7:*/		return 0x82194B84;
		  /* 82194B84h */ case    8:  		/* rlwinm R29, R11, 0, 19, 31 */
		/* 82194B84h case    8:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R29,regs.R11);
		/* 82194B84h case    8:*/		return 0x82194B88;
		  /* 82194B88h */ case    9:  		/* bc 12, CR6_EQ, 108 */
		/* 82194B88h case    9:*/		if ( regs.CR[6].eq ) { return 0x82194BF4;  }
		/* 82194B88h case    9:*/		return 0x82194B8C;
		  /* 82194B8Ch */ case   10:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82194B8Ch case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82194B8Ch case   10:*/		return 0x82194B90;
		  /* 82194B90h */ case   11:  		/* lwz R10, <#[R11 + 36]> */
		/* 82194B90h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000024) );
		/* 82194B90h case   11:*/		return 0x82194B94;
		  /* 82194B94h */ case   12:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 82194B94h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 82194B94h case   12:*/		return 0x82194B98;
		  /* 82194B98h */ case   13:  		/* bc 12, CR0_EQ, 12 */
		/* 82194B98h case   13:*/		if ( regs.CR[0].eq ) { return 0x82194BA4;  }
		/* 82194B98h case   13:*/		return 0x82194B9C;
		  /* 82194B9Ch */ case   14:  		/* mr R30, R18 */
		/* 82194B9Ch case   14:*/		regs.R30 = regs.R18;
		/* 82194B9Ch case   14:*/		return 0x82194BA0;
		  /* 82194BA0h */ case   15:  		/* b 12 */
		/* 82194BA0h case   15:*/		return 0x82194BAC;
		/* 82194BA0h case   15:*/		return 0x82194BA4;
	}
	return 0x82194BA4;
} // Block from 82194B64h-82194BA4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82194BA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194BA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194BA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194BA4);
		  /* 82194BA4h */ case    0:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82194BA4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82194BA4h case    0:*/		return 0x82194BA8;
		  /* 82194BA8h */ case    1:  		/* addi R30, R10, -40 */
		/* 82194BA8h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R10,0xFFFFFFD8);
		/* 82194BA8h case    1:*/		return 0x82194BAC;
	}
	return 0x82194BAC;
} // Block from 82194BA4h-82194BACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82194BACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194BAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194BAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194BAC);
		  /* 82194BACh */ case    0:  		/* lwz R10, <#[R11 + 40]> */
		/* 82194BACh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000028) );
		/* 82194BACh case    0:*/		return 0x82194BB0;
		  /* 82194BB0h */ case    1:  		/* mr R4, R31 */
		/* 82194BB0h case    1:*/		regs.R4 = regs.R31;
		/* 82194BB0h case    1:*/		return 0x82194BB4;
		  /* 82194BB4h */ case    2:  		/* lwz R9, <#[R11 + 36]> */
		/* 82194BB4h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000024) );
		/* 82194BB4h case    2:*/		return 0x82194BB8;
		  /* 82194BB8h */ case    3:  		/* addi R3, R1, 160 */
		/* 82194BB8h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 82194BB8h case    3:*/		return 0x82194BBC;
		  /* 82194BBCh */ case    4:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82194BBCh case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82194BBCh case    4:*/		return 0x82194BC0;
		  /* 82194BC0h */ case    5:  		/* stw R9, <#[R10 + 36]> */
		/* 82194BC0h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000024) );
		/* 82194BC0h case    5:*/		return 0x82194BC4;
		  /* 82194BC4h */ case    6:  		/* lwz R10, <#[R11 + 40]> */
		/* 82194BC4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000028) );
		/* 82194BC4h case    6:*/		return 0x82194BC8;
		  /* 82194BC8h */ case    7:  		/* lwz R11, <#[R11 + 36]> */
		/* 82194BC8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82194BC8h case    7:*/		return 0x82194BCC;
		  /* 82194BCCh */ case    8:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82194BCCh case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82194BCCh case    8:*/		return 0x82194BD0;
		  /* 82194BD0h */ case    9:  		/* stw R10, <#[R11]> */
		/* 82194BD0h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82194BD0h case    9:*/		return 0x82194BD4;
		  /* 82194BD4h */ case   10:  		/* bl -16588 */
		/* 82194BD4h case   10:*/		regs.LR = 0x82194BD8; return 0x82190B08;
		/* 82194BD4h case   10:*/		return 0x82194BD8;
		  /* 82194BD8h */ case   11:  		/* mr R5, R29 */
		/* 82194BD8h case   11:*/		regs.R5 = regs.R29;
		/* 82194BD8h case   11:*/		return 0x82194BDC;
		  /* 82194BDCh */ case   12:  		/* mr R4, R31 */
		/* 82194BDCh case   12:*/		regs.R4 = regs.R31;
		/* 82194BDCh case   12:*/		return 0x82194BE0;
		  /* 82194BE0h */ case   13:  		/* mr R3, R21 */
		/* 82194BE0h case   13:*/		regs.R3 = regs.R21;
		/* 82194BE0h case   13:*/		return 0x82194BE4;
		  /* 82194BE4h */ case   14:  		/* bl -7460 */
		/* 82194BE4h case   14:*/		regs.LR = 0x82194BE8; return 0x82192EC0;
		/* 82194BE4h case   14:*/		return 0x82194BE8;
		  /* 82194BE8h */ case   15:  		/* mr R31, R30 */
		/* 82194BE8h case   15:*/		regs.R31 = regs.R30;
		/* 82194BE8h case   15:*/		return 0x82194BEC;
		  /* 82194BECh */ case   16:  		/* cmplw CR6, R30, R28 */
		/* 82194BECh case   16:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R28);
		/* 82194BECh case   16:*/		return 0x82194BF0;
		  /* 82194BF0h */ case   17:  		/* bc 4, CR6_EQ, -100 */
		/* 82194BF0h case   17:*/		if ( !regs.CR[6].eq ) { return 0x82194B8C;  }
		/* 82194BF0h case   17:*/		return 0x82194BF4;
	}
	return 0x82194BF4;
} // Block from 82194BACh-82194BF4h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82194BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194BF4);
		  /* 82194BF4h */ case    0:  		/* mr R4, R31 */
		/* 82194BF4h case    0:*/		regs.R4 = regs.R31;
		/* 82194BF4h case    0:*/		return 0x82194BF8;
		  /* 82194BF8h */ case    1:  		/* addi R3, R1, 160 */
		/* 82194BF8h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 82194BF8h case    1:*/		return 0x82194BFC;
		  /* 82194BFCh */ case    2:  		/* bl -17284 */
		/* 82194BFCh case    2:*/		regs.LR = 0x82194C00; return 0x82190878;
		/* 82194BFCh case    2:*/		return 0x82194C00;
		  /* 82194C00h */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82194C00h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82194C00h case    3:*/		return 0x82194C04;
		  /* 82194C04h */ case    4:  		/* bc 12, CR0_EQ, 324 */
		/* 82194C04h case    4:*/		if ( regs.CR[0].eq ) { return 0x82194D48;  }
		/* 82194C04h case    4:*/		return 0x82194C08;
		  /* 82194C08h */ case    5:  		/* lwz R10, <#[R1 + 160]> */
		/* 82194C08h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000A0) );
		/* 82194C08h case    5:*/		return 0x82194C0C;
		  /* 82194C0Ch */ case    6:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82194C0Ch case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82194C0Ch case    6:*/		return 0x82194C10;
		  /* 82194C10h */ case    7:  		/* mr R28, R10 */
		/* 82194C10h case    7:*/		regs.R28 = regs.R10;
		/* 82194C10h case    7:*/		return 0x82194C14;
		  /* 82194C14h */ case    8:  		/* lwz R9, <#[R10 + 20]> */
		/* 82194C14h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000014) );
		/* 82194C14h case    8:*/		return 0x82194C18;
		  /* 82194C18h */ case    9:  		/* lwz R10, <#[R11 + 36]> */
		/* 82194C18h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000024) );
		/* 82194C18h case    9:*/		return 0x82194C1C;
		  /* 82194C1Ch */ case   10:  		/* rlwinm R29, R9, 0, 19, 31 */
		/* 82194C1Ch case   10:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R29,regs.R9);
		/* 82194C1Ch case   10:*/		return 0x82194C20;
		  /* 82194C20h */ case   11:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 82194C20h case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 82194C20h case   11:*/		return 0x82194C24;
		  /* 82194C24h */ case   12:  		/* bc 12, CR0_EQ, 12 */
		/* 82194C24h case   12:*/		if ( regs.CR[0].eq ) { return 0x82194C30;  }
		/* 82194C24h case   12:*/		return 0x82194C28;
		  /* 82194C28h */ case   13:  		/* mr R30, R18 */
		/* 82194C28h case   13:*/		regs.R30 = regs.R18;
		/* 82194C28h case   13:*/		return 0x82194C2C;
		  /* 82194C2Ch */ case   14:  		/* b 12 */
		/* 82194C2Ch case   14:*/		return 0x82194C38;
		/* 82194C2Ch case   14:*/		return 0x82194C30;
	}
	return 0x82194C30;
} // Block from 82194BF4h-82194C30h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82194C30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194C30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194C30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194C30);
		  /* 82194C30h */ case    0:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82194C30h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82194C30h case    0:*/		return 0x82194C34;
		  /* 82194C34h */ case    1:  		/* addi R30, R10, -40 */
		/* 82194C34h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R10,0xFFFFFFD8);
		/* 82194C34h case    1:*/		return 0x82194C38;
	}
	return 0x82194C38;
} // Block from 82194C30h-82194C38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82194C38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194C38);
		  /* 82194C38h */ case    0:  		/* lwz R10, <#[R11 + 40]> */
		/* 82194C38h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000028) );
		/* 82194C38h case    0:*/		return 0x82194C3C;
		  /* 82194C3Ch */ case    1:  		/* mr R4, R31 */
		/* 82194C3Ch case    1:*/		regs.R4 = regs.R31;
		/* 82194C3Ch case    1:*/		return 0x82194C40;
		  /* 82194C40h */ case    2:  		/* lwz R9, <#[R11 + 36]> */
		/* 82194C40h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000024) );
		/* 82194C40h case    2:*/		return 0x82194C44;
		  /* 82194C44h */ case    3:  		/* addi R3, R1, 160 */
		/* 82194C44h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 82194C44h case    3:*/		return 0x82194C48;
		  /* 82194C48h */ case    4:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82194C48h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82194C48h case    4:*/		return 0x82194C4C;
		  /* 82194C4Ch */ case    5:  		/* stw R9, <#[R10 + 36]> */
		/* 82194C4Ch case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000024) );
		/* 82194C4Ch case    5:*/		return 0x82194C50;
		  /* 82194C50h */ case    6:  		/* lwz R10, <#[R11 + 36]> */
		/* 82194C50h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000024) );
		/* 82194C50h case    6:*/		return 0x82194C54;
		  /* 82194C54h */ case    7:  		/* lwz R11, <#[R11 + 40]> */
		/* 82194C54h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82194C54h case    7:*/		return 0x82194C58;
	}
	return 0x82194C58;
} // Block from 82194C38h-82194C58h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82194C58h
// Function '?ScheduleInBlock@Compiler@D3DXShader@@AAAXPAVBlock@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194C58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194C58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194C58);
		  /* 82194C58h */ case    0:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82194C58h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82194C58h case    0:*/		return 0x82194C5C;
		  /* 82194C5Ch */ case    1:  		/* stw R11, <#[R10]> */
		/* 82194C5Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82194C5Ch case    1:*/		return 0x82194C60;
		  /* 82194C60h */ case    2:  		/* bl -16856 */
		/* 82194C60h case    2:*/		regs.LR = 0x82194C64; return 0x82190A88;
		/* 82194C60h case    2:*/		return 0x82194C64;
		  /* 82194C64h */ case    3:  		/* mr R5, R29 */
		/* 82194C64h case    3:*/		regs.R5 = regs.R29;
		/* 82194C64h case    3:*/		return 0x82194C68;
		  /* 82194C68h */ case    4:  		/* mr R4, R31 */
		/* 82194C68h case    4:*/		regs.R4 = regs.R31;
		/* 82194C68h case    4:*/		return 0x82194C6C;
		  /* 82194C6Ch */ case    5:  		/* mr R3, R21 */
		/* 82194C6Ch case    5:*/		regs.R3 = regs.R21;
		/* 82194C6Ch case    5:*/		return 0x82194C70;
		  /* 82194C70h */ case    6:  		/* bl -7600 */
		/* 82194C70h case    6:*/		regs.LR = 0x82194C74; return 0x82192EC0;
		/* 82194C70h case    6:*/		return 0x82194C74;
		  /* 82194C74h */ case    7:  		/* mr R31, R30 */
		/* 82194C74h case    7:*/		regs.R31 = regs.R30;
		/* 82194C74h case    7:*/		return 0x82194C78;
		  /* 82194C78h */ case    8:  		/* addi R17, R17, -1 */
		/* 82194C78h case    8:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0xFFFFFFFF);
		/* 82194C78h case    8:*/		return 0x82194C7C;
		  /* 82194C7Ch */ case    9:  		/* cmplwi CR6, R30, 0 */
		/* 82194C7Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82194C7Ch case    9:*/		return 0x82194C80;
		  /* 82194C80h */ case   10:  		/* bc 12, CR6_EQ, 224 */
		/* 82194C80h case   10:*/		if ( regs.CR[6].eq ) { return 0x82194D60;  }
		/* 82194C80h case   10:*/		return 0x82194C84;
		  /* 82194C84h */ case   11:  		/* lwz R11, <#[R31 + 8]> */
		/* 82194C84h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82194C84h case   11:*/		return 0x82194C88;
		  /* 82194C88h */ case   12:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82194C88h case   12:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82194C88h case   12:*/		return 0x82194C8C;
		  /* 82194C8Ch */ case   13:  		/* cmplwi CR6, R11, 1 */
		/* 82194C8Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82194C8Ch case   13:*/		return 0x82194C90;
		  /* 82194C90h */ case   14:  		/* bc 12, CR6_LT, 16 */
		/* 82194C90h case   14:*/		if ( regs.CR[6].lt ) { return 0x82194CA0;  }
		/* 82194C90h case   14:*/		return 0x82194C94;
		  /* 82194C94h */ case   15:  		/* cmplwi CR6, R11, 102 */
		/* 82194C94h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000066);
		/* 82194C94h case   15:*/		return 0x82194C98;
		  /* 82194C98h */ case   16:  		/* li R11, 1 */
		/* 82194C98h case   16:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82194C98h case   16:*/		return 0x82194C9C;
		  /* 82194C9Ch */ case   17:  		/* bc 4, CR6_GT, 8 */
		/* 82194C9Ch case   17:*/		if ( !regs.CR[6].gt ) { return 0x82194CA4;  }
		/* 82194C9Ch case   17:*/		return 0x82194CA0;
	}
	return 0x82194CA0;
} // Block from 82194C58h-82194CA0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82194CA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194CA0);
		  /* 82194CA0h */ case    0:  		/* mr R11, R18 */
		/* 82194CA0h case    0:*/		regs.R11 = regs.R18;
		/* 82194CA0h case    0:*/		return 0x82194CA4;
	}
	return 0x82194CA4;
} // Block from 82194CA0h-82194CA4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82194CA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194CA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194CA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194CA4);
		  /* 82194CA4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82194CA4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82194CA4h case    0:*/		return 0x82194CA8;
		  /* 82194CA8h */ case    1:  		/* bc 4, CR0_EQ, 152 */
		/* 82194CA8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82194D40;  }
		/* 82194CA8h case    1:*/		return 0x82194CAC;
		  /* 82194CACh */ case    2:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82194CACh case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82194CACh case    2:*/		return 0x82194CB0;
		  /* 82194CB0h */ case    3:  		/* addi R11, R11, 36 */
		/* 82194CB0h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82194CB0h case    3:*/		return 0x82194CB4;
		  /* 82194CB4h */ case    4:  		/* lwz R10, <#[R11]> */
		/* 82194CB4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82194CB4h case    4:*/		return 0x82194CB8;
		  /* 82194CB8h */ case    5:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 82194CB8h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 82194CB8h case    5:*/		return 0x82194CBC;
		  /* 82194CBCh */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 82194CBCh case    6:*/		if ( regs.CR[0].eq ) { return 0x82194CC8;  }
		/* 82194CBCh case    6:*/		return 0x82194CC0;
		  /* 82194CC0h */ case    7:  		/* mr R30, R18 */
		/* 82194CC0h case    7:*/		regs.R30 = regs.R18;
		/* 82194CC0h case    7:*/		return 0x82194CC4;
		  /* 82194CC4h */ case    8:  		/* b 12 */
		/* 82194CC4h case    8:*/		return 0x82194CD0;
		/* 82194CC4h case    8:*/		return 0x82194CC8;
	}
	return 0x82194CC8;
} // Block from 82194CA4h-82194CC8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82194CC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194CC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194CC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194CC8);
		  /* 82194CC8h */ case    0:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82194CC8h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82194CC8h case    0:*/		return 0x82194CCC;
		  /* 82194CCCh */ case    1:  		/* addi R30, R10, -40 */
		/* 82194CCCh case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R10,0xFFFFFFD8);
		/* 82194CCCh case    1:*/		return 0x82194CD0;
	}
	return 0x82194CD0;
} // Block from 82194CC8h-82194CD0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82194CD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194CD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194CD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194CD0);
		  /* 82194CD0h */ case    0:  		/* lwz R9, <#[R11 + 4]> */
		/* 82194CD0h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82194CD0h case    0:*/		return 0x82194CD4;
		  /* 82194CD4h */ case    1:  		/* rlwinm R10, R28, 0, 0, 30 */
		/* 82194CD4h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R28);
		/* 82194CD4h case    1:*/		return 0x82194CD8;
		  /* 82194CD8h */ case    2:  		/* lwz R8, <#[R11]> */
		/* 82194CD8h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82194CD8h case    2:*/		return 0x82194CDC;
		  /* 82194CDCh */ case    3:  		/* addi R7, R11, -36 */
		/* 82194CDCh case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 82194CDCh case    3:*/		return 0x82194CE0;
		  /* 82194CE0h */ case    4:  		/* rlwinm R6, R9, 0, 0, 30 */
		/* 82194CE0h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R9);
		/* 82194CE0h case    4:*/		return 0x82194CE4;
		  /* 82194CE4h */ case    5:  		/* addi R10, R10, 36 */
		/* 82194CE4h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 82194CE4h case    5:*/		return 0x82194CE8;
		  /* 82194CE8h */ case    6:  		/* addi R9, R11, 4 */
		/* 82194CE8h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 82194CE8h case    6:*/		return 0x82194CEC;
		  /* 82194CECh */ case    7:  		/* addi R28, R10, -36 */
		/* 82194CECh case    7:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R10,0xFFFFFFDC);
		/* 82194CECh case    7:*/		return 0x82194CF0;
		  /* 82194CF0h */ case    8:  		/* addi R5, R29, 1 */
		/* 82194CF0h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R29,0x1);
		/* 82194CF0h case    8:*/		return 0x82194CF4;
		  /* 82194CF4h */ case    9:  		/* stw R8, <#[R6 + 36]> */
		/* 82194CF4h case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000024) );
		/* 82194CF4h case    9:*/		return 0x82194CF8;
		  /* 82194CF8h */ case   10:  		/* mr R4, R31 */
		/* 82194CF8h case   10:*/		regs.R4 = regs.R31;
		/* 82194CF8h case   10:*/		return 0x82194CFC;
		  /* 82194CFCh */ case   11:  		/* lwz R6, <#[R11 + 4]> */
		/* 82194CFCh case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82194CFCh case   11:*/		return 0x82194D00;
		  /* 82194D00h */ case   12:  		/* mr R3, R21 */
		/* 82194D00h case   12:*/		regs.R3 = regs.R21;
		/* 82194D00h case   12:*/		return 0x82194D04;
		  /* 82194D04h */ case   13:  		/* lwz R8, <#[R11]> */
		/* 82194D04h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82194D04h case   13:*/		return 0x82194D08;
		  /* 82194D08h */ case   14:  		/* rlwinm R8, R8, 0, 0, 30 */
		/* 82194D08h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R8);
		/* 82194D08h case   14:*/		return 0x82194D0C;
		  /* 82194D0Ch */ case   15:  		/* stw R6, <#[R8]> */
		/* 82194D0Ch case   15:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R8 + 0x00000000) );
		/* 82194D0Ch case   15:*/		return 0x82194D10;
		  /* 82194D10h */ case   16:  		/* lwz R8, <#[R10]> */
		/* 82194D10h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82194D10h case   16:*/		return 0x82194D14;
		  /* 82194D14h */ case   17:  		/* stw R8, <#[R11]> */
		/* 82194D14h case   17:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82194D14h case   17:*/		return 0x82194D18;
		  /* 82194D18h */ case   18:  		/* lwz R8, <#[R10]> */
		/* 82194D18h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82194D18h case   18:*/		return 0x82194D1C;
		  /* 82194D1Ch */ case   19:  		/* rlwinm R8, R8, 0, 0, 30 */
		/* 82194D1Ch case   19:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R8);
		/* 82194D1Ch case   19:*/		return 0x82194D20;
		  /* 82194D20h */ case   20:  		/* stw R7, <#[R8]> */
		/* 82194D20h case   20:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R8 + 0x00000000) );
		/* 82194D20h case   20:*/		return 0x82194D24;
		  /* 82194D24h */ case   21:  		/* stw R28, <#[R11 + 4]> */
		/* 82194D24h case   21:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000004) );
		/* 82194D24h case   21:*/		return 0x82194D28;
		  /* 82194D28h */ case   22:  		/* stw R9, <#[R10]> */
		/* 82194D28h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82194D28h case   22:*/		return 0x82194D2C;
		  /* 82194D2Ch */ case   23:  		/* bl -7788 */
		/* 82194D2Ch case   23:*/		regs.LR = 0x82194D30; return 0x82192EC0;
		/* 82194D2Ch case   23:*/		return 0x82194D30;
		  /* 82194D30h */ case   24:  		/* mr R28, R31 */
		/* 82194D30h case   24:*/		regs.R28 = regs.R31;
		/* 82194D30h case   24:*/		return 0x82194D34;
		  /* 82194D34h */ case   25:  		/* mr R31, R30 */
		/* 82194D34h case   25:*/		regs.R31 = regs.R30;
		/* 82194D34h case   25:*/		return 0x82194D38;
		  /* 82194D38h */ case   26:  		/* cmplwi CR6, R30, 0 */
		/* 82194D38h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82194D38h case   26:*/		return 0x82194D3C;
		  /* 82194D3Ch */ case   27:  		/* bc 4, CR6_EQ, -184 */
		/* 82194D3Ch case   27:*/		if ( !regs.CR[6].eq ) { return 0x82194C84;  }
		/* 82194D3Ch case   27:*/		return 0x82194D40;
	}
	return 0x82194D40;
} // Block from 82194CD0h-82194D40h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82194D40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194D40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194D40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194D40);
		  /* 82194D40h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82194D40h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82194D40h case    0:*/		return 0x82194D44;
		  /* 82194D44h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 82194D44h case    1:*/		if ( regs.CR[6].eq ) { return 0x82194D60;  }
		/* 82194D44h case    1:*/		return 0x82194D48;
	}
	return 0x82194D48;
} // Block from 82194D40h-82194D48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82194D48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194D48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194D48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194D48);
		  /* 82194D48h */ case    0:  		/* addi R3, R1, 160 */
		/* 82194D48h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 82194D48h case    0:*/		return 0x82194D4C;
		  /* 82194D4Ch */ case    1:  		/* bl -17316 */
		/* 82194D4Ch case    1:*/		regs.LR = 0x82194D50; return 0x821909A8;
		/* 82194D4Ch case    1:*/		return 0x82194D50;
		  /* 82194D50h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82194D50h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82194D50h case    2:*/		return 0x82194D54;
		  /* 82194D54h */ case    3:  		/* bc 4, CR0_EQ, -352 */
		/* 82194D54h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82194BF4;  }
		/* 82194D54h case    3:*/		return 0x82194D58;
		  /* 82194D58h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 82194D58h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82194D58h case    4:*/		return 0x82194D5C;
		  /* 82194D5Ch */ case    5:  		/* bc 4, CR6_EQ, 368 */
		/* 82194D5Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x82194ECC;  }
		/* 82194D5Ch case    5:*/		return 0x82194D60;
	}
	return 0x82194D60;
} // Block from 82194D48h-82194D60h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82194D60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194D60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194D60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194D60);
		  /* 82194D60h */ case    0:  		/* lwz R11, <#[R24 + 4]> */
		/* 82194D60h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 82194D60h case    0:*/		return 0x82194D64;
		  /* 82194D64h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82194D64h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82194D64h case    1:*/		return 0x82194D68;
		  /* 82194D68h */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 82194D68h case    2:*/		if ( regs.CR[6].eq ) { return 0x82194DA4;  }
		/* 82194D68h case    2:*/		return 0x82194D6C;
		  /* 82194D6Ch */ case    3:  		/* lwz R10, <#[R11 + 16]> */
		/* 82194D6Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82194D6Ch case    3:*/		return 0x82194D70;
		  /* 82194D70h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 82194D70h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82194D70h case    4:*/		return 0x82194D74;
		  /* 82194D74h */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 82194D74h case    5:*/		if ( regs.CR[6].eq ) { return 0x82194D94;  }
		/* 82194D74h case    5:*/		return 0x82194D78;
		  /* 82194D78h */ case    6:  		/* lwz R9, <#[R10 + 8]> */
		/* 82194D78h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 82194D78h case    6:*/		return 0x82194D7C;
		  /* 82194D7Ch */ case    7:  		/* rlwinm R9, R9, 0, 18, 24 */
		/* 82194D7Ch case    7:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R9);
		/* 82194D7Ch case    7:*/		return 0x82194D80;
		  /* 82194D80h */ case    8:  		/* cmplwi CR6, R9, 14080 */
		/* 82194D80h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00003700);
		/* 82194D80h case    8:*/		return 0x82194D84;
		  /* 82194D84h */ case    9:  		/* bc 4, CR6_EQ, 16 */
		/* 82194D84h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82194D94;  }
		/* 82194D84h case    9:*/		return 0x82194D88;
		  /* 82194D88h */ case   10:  		/* lwz R9, <#[R11]> */
		/* 82194D88h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82194D88h case   10:*/		return 0x82194D8C;
		  /* 82194D8Ch */ case   11:  		/* rlwinm. R9, R9, 0, 4, 6 */
		/* 82194D8Ch case   11:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R9);
		/* 82194D8Ch case   11:*/		return 0x82194D90;
		  /* 82194D90h */ case   12:  		/* bc 4, CR0_EQ, 12 */
		/* 82194D90h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82194D9C;  }
		/* 82194D90h case   12:*/		return 0x82194D94;
	}
	return 0x82194D94;
} // Block from 82194D60h-82194D94h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82194D94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194D94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194D94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194D94);
		  /* 82194D94h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82194D94h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82194D94h case    0:*/		return 0x82194D98;
		  /* 82194D98h */ case    1:  		/* b -52 */
		/* 82194D98h case    1:*/		return 0x82194D64;
		/* 82194D98h case    1:*/		return 0x82194D9C;
	}
	return 0x82194D9C;
} // Block from 82194D94h-82194D9Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82194D9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194D9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194D9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194D9C);
		  /* 82194D9Ch */ case    0:  		/* mr R30, R10 */
		/* 82194D9Ch case    0:*/		regs.R30 = regs.R10;
		/* 82194D9Ch case    0:*/		return 0x82194DA0;
		  /* 82194DA0h */ case    1:  		/* b 8 */
		/* 82194DA0h case    1:*/		return 0x82194DA8;
		/* 82194DA0h case    1:*/		return 0x82194DA4;
	}
	return 0x82194DA4;
} // Block from 82194D9Ch-82194DA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82194DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194DA4);
		  /* 82194DA4h */ case    0:  		/* mr R30, R18 */
		/* 82194DA4h case    0:*/		regs.R30 = regs.R18;
		/* 82194DA4h case    0:*/		return 0x82194DA8;
	}
	return 0x82194DA8;
} // Block from 82194DA4h-82194DA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82194DA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194DA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194DA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194DA8);
		  /* 82194DA8h */ case    0:  		/* mr R5, R26 */
		/* 82194DA8h case    0:*/		regs.R5 = regs.R26;
		/* 82194DA8h case    0:*/		return 0x82194DAC;
		  /* 82194DACh */ case    1:  		/* mr R4, R24 */
		/* 82194DACh case    1:*/		regs.R4 = regs.R24;
		/* 82194DACh case    1:*/		return 0x82194DB0;
		  /* 82194DB0h */ case    2:  		/* mr R3, R21 */
		/* 82194DB0h case    2:*/		regs.R3 = regs.R21;
		/* 82194DB0h case    2:*/		return 0x82194DB4;
		  /* 82194DB4h */ case    3:  		/* bl -14716 */
		/* 82194DB4h case    3:*/		regs.LR = 0x82194DB8; return 0x82191438;
		/* 82194DB4h case    3:*/		return 0x82194DB8;
		  /* 82194DB8h */ case    4:  		/* li R5, 8191 */
		/* 82194DB8h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x1FFF);
		/* 82194DB8h case    4:*/		return 0x82194DBC;
		  /* 82194DBCh */ case    5:  		/* mr R4, R24 */
		/* 82194DBCh case    5:*/		regs.R4 = regs.R24;
		/* 82194DBCh case    5:*/		return 0x82194DC0;
		  /* 82194DC0h */ case    6:  		/* mr R3, R21 */
		/* 82194DC0h case    6:*/		regs.R3 = regs.R21;
		/* 82194DC0h case    6:*/		return 0x82194DC4;
		  /* 82194DC4h */ case    7:  		/* bl -7940 */
		/* 82194DC4h case    7:*/		regs.LR = 0x82194DC8; return 0x82192EC0;
		/* 82194DC4h case    7:*/		return 0x82194DC8;
		  /* 82194DC8h */ case    8:  		/* li R5, 0 */
		/* 82194DC8h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82194DC8h case    8:*/		return 0x82194DCC;
		  /* 82194DCCh */ case    9:  		/* mr R4, R24 */
		/* 82194DCCh case    9:*/		regs.R4 = regs.R24;
		/* 82194DCCh case    9:*/		return 0x82194DD0;
		  /* 82194DD0h */ case   10:  		/* addi R3, R1, 96 */
		/* 82194DD0h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82194DD0h case   10:*/		return 0x82194DD4;
		  /* 82194DD4h */ case   11:  		/* bl -4620 */
		/* 82194DD4h case   11:*/		regs.LR = 0x82194DD8; return 0x82193BC8;
		/* 82194DD4h case   11:*/		return 0x82194DD8;
		  /* 82194DD8h */ case   12:  		/* li R6, 0 */
		/* 82194DD8h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82194DD8h case   12:*/		return 0x82194DDC;
		  /* 82194DDCh */ case   13:  		/* li R5, 0 */
		/* 82194DDCh case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82194DDCh case   13:*/		return 0x82194DE0;
		  /* 82194DE0h */ case   14:  		/* mr R4, R24 */
		/* 82194DE0h case   14:*/		regs.R4 = regs.R24;
		/* 82194DE0h case   14:*/		return 0x82194DE4;
		  /* 82194DE4h */ case   15:  		/* mr R3, R21 */
		/* 82194DE4h case   15:*/		regs.R3 = regs.R21;
		/* 82194DE4h case   15:*/		return 0x82194DE8;
		  /* 82194DE8h */ case   16:  		/* bl 615904 */
		/* 82194DE8h case   16:*/		regs.LR = 0x82194DEC; return 0x8222B3C8;
		/* 82194DE8h case   16:*/		return 0x82194DEC;
		  /* 82194DECh */ case   17:  		/* lwz R11, <#[R23]> */
		/* 82194DECh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 82194DECh case   17:*/		return 0x82194DF0;
		  /* 82194DF0h */ case   18:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82194DF0h case   18:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82194DF0h case   18:*/		return 0x82194DF4;
		  /* 82194DF4h */ case   19:  		/* bc 4, CR0_EQ, 76 */
		/* 82194DF4h case   19:*/		if ( !regs.CR[0].eq ) { return 0x82194E40;  }
		/* 82194DF4h case   19:*/		return 0x82194DF8;
		  /* 82194DF8h */ case   20:  		/* mr R31, R11 */
		/* 82194DF8h case   20:*/		regs.R31 = regs.R11;
		/* 82194DF8h case   20:*/		return 0x82194DFC;
		  /* 82194DFCh */ case   21:  		/* cmplwi CR0, R11, 0 */
		/* 82194DFCh case   21:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82194DFCh case   21:*/		return 0x82194E00;
		  /* 82194E00h */ case   22:  		/* bc 12, CR0_EQ, 64 */
		/* 82194E00h case   22:*/		if ( regs.CR[0].eq ) { return 0x82194E40;  }
		/* 82194E00h case   22:*/		return 0x82194E04;
		  /* 82194E04h */ case   23:  		/* lwz R11, <#[R31 + 8]> */
		/* 82194E04h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82194E04h case   23:*/		return 0x82194E08;
		  /* 82194E08h */ case   24:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82194E08h case   24:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82194E08h case   24:*/		return 0x82194E0C;
		  /* 82194E0Ch */ case   25:  		/* cmplwi CR6, R11, 14080 */
		/* 82194E0Ch case   25:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 82194E0Ch case   25:*/		return 0x82194E10;
		  /* 82194E10h */ case   26:  		/* bc 4, CR6_EQ, 16 */
		/* 82194E10h case   26:*/		if ( !regs.CR[6].eq ) { return 0x82194E20;  }
		/* 82194E10h case   26:*/		return 0x82194E14;
		  /* 82194E14h */ case   27:  		/* mr R4, R31 */
		/* 82194E14h case   27:*/		regs.R4 = regs.R31;
		/* 82194E14h case   27:*/		return 0x82194E18;
		  /* 82194E18h */ case   28:  		/* mr R3, R21 */
		/* 82194E18h case   28:*/		regs.R3 = regs.R21;
		/* 82194E18h case   28:*/		return 0x82194E1C;
		  /* 82194E1Ch */ case   29:  		/* bl -16932 */
		/* 82194E1Ch case   29:*/		regs.LR = 0x82194E20; return 0x82190BF8;
		/* 82194E1Ch case   29:*/		return 0x82194E20;
	}
	return 0x82194E20;
} // Block from 82194DA8h-82194E20h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82194E20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194E20);
		  /* 82194E20h */ case    0:  		/* cmplw CR6, R31, R27 */
		/* 82194E20h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R27);
		/* 82194E20h case    0:*/		return 0x82194E24;
		  /* 82194E24h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 82194E24h case    1:*/		if ( regs.CR[6].eq ) { return 0x82194E40;  }
		/* 82194E24h case    1:*/		return 0x82194E28;
		  /* 82194E28h */ case    2:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82194E28h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82194E28h case    2:*/		return 0x82194E2C;
		  /* 82194E2Ch */ case    3:  		/* lwz R31, <#[R11 + 40]> */
		/* 82194E2Ch case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000028) );
		/* 82194E2Ch case    3:*/		return 0x82194E30;
		  /* 82194E30h */ case    4:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 82194E30h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 82194E30h case    4:*/		return 0x82194E34;
		  /* 82194E34h */ case    5:  		/* bc 4, CR0_EQ, 12 */
		/* 82194E34h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82194E40;  }
		/* 82194E34h case    5:*/		return 0x82194E38;
		  /* 82194E38h */ case    6:  		/* cmplwi CR6, R31, 0 */
		/* 82194E38h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82194E38h case    6:*/		return 0x82194E3C;
		  /* 82194E3Ch */ case    7:  		/* bc 4, CR6_EQ, -56 */
		/* 82194E3Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x82194E04;  }
		/* 82194E3Ch case    7:*/		return 0x82194E40;
	}
	return 0x82194E40;
} // Block from 82194E20h-82194E40h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82194E40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194E40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194E40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194E40);
		  /* 82194E40h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 82194E40h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82194E40h case    0:*/		return 0x82194E44;
		  /* 82194E44h */ case    1:  		/* bc 12, CR6_EQ, 116 */
		/* 82194E44h case    1:*/		if ( regs.CR[6].eq ) { return 0x82194EB8;  }
		/* 82194E44h case    1:*/		return 0x82194E48;
		  /* 82194E48h */ case    2:  		/* mr R4, R30 */
		/* 82194E48h case    2:*/		regs.R4 = regs.R30;
		/* 82194E48h case    2:*/		return 0x82194E4C;
		  /* 82194E4Ch */ case    3:  		/* mr R3, R21 */
		/* 82194E4Ch case    3:*/		regs.R3 = regs.R21;
		/* 82194E4Ch case    3:*/		return 0x82194E50;
		  /* 82194E50h */ case    4:  		/* bl -16984 */
		/* 82194E50h case    4:*/		regs.LR = 0x82194E54; return 0x82190BF8;
		/* 82194E50h case    4:*/		return 0x82194E54;
		  /* 82194E54h */ case    5:  		/* b 100 */
		/* 82194E54h case    5:*/		return 0x82194EB8;
		/* 82194E54h case    5:*/		return 0x82194E58;
	}
	return 0x82194E58;
} // Block from 82194E40h-82194E58h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82194E58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194E58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194E58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194E58);
		  /* 82194E58h */ case    0:  		/* lwz R11, <#[R24 + 8]> */
		/* 82194E58h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 82194E58h case    0:*/		return 0x82194E5C;
		  /* 82194E5Ch */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82194E5Ch case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82194E5Ch case    1:*/		return 0x82194E60;
		  /* 82194E60h */ case    2:  		/* cmplwi CR6, R11, 1 */
		/* 82194E60h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82194E60h case    2:*/		return 0x82194E64;
		  /* 82194E64h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 82194E64h case    3:*/		if ( regs.CR[6].lt ) { return 0x82194E74;  }
		/* 82194E64h case    3:*/		return 0x82194E68;
		  /* 82194E68h */ case    4:  		/* cmplwi CR6, R11, 31 */
		/* 82194E68h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001F);
		/* 82194E68h case    4:*/		return 0x82194E6C;
		  /* 82194E6Ch */ case    5:  		/* li R11, 1 */
		/* 82194E6Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82194E6Ch case    5:*/		return 0x82194E70;
		  /* 82194E70h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 82194E70h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82194E78;  }
		/* 82194E70h case    6:*/		return 0x82194E74;
	}
	return 0x82194E74;
} // Block from 82194E58h-82194E74h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82194E74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194E74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194E74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194E74);
		  /* 82194E74h */ case    0:  		/* mr R11, R18 */
		/* 82194E74h case    0:*/		regs.R11 = regs.R18;
		/* 82194E74h case    0:*/		return 0x82194E78;
	}
	return 0x82194E78;
} // Block from 82194E74h-82194E78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82194E78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194E78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194E78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194E78);
		  /* 82194E78h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82194E78h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82194E78h case    0:*/		return 0x82194E7C;
		  /* 82194E7Ch */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 82194E7Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82194E84;  }
		/* 82194E7Ch case    1:*/		return 0x82194E80;
		  /* 82194E80h */ case    2:  		/* addi R17, R17, 1 */
		/* 82194E80h case    2:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 82194E80h case    2:*/		return 0x82194E84;
	}
	return 0x82194E84;
} // Block from 82194E78h-82194E84h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82194E84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194E84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194E84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194E84);
		  /* 82194E84h */ case    0:  		/* addi R22, R22, 1 */
		/* 82194E84h case    0:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 82194E84h case    0:*/		return 0x82194E88;
		  /* 82194E88h */ case    1:  		/* cmplwi CR6, R22, 8191 */
		/* 82194E88h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00001FFF);
		/* 82194E88h case    1:*/		return 0x82194E8C;
		  /* 82194E8Ch */ case    2:  		/* bc 12, CR6_EQ, 76 */
		/* 82194E8Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82194ED8;  }
		/* 82194E8Ch case    2:*/		return 0x82194E90;
		  /* 82194E90h */ case    3:  		/* li R5, 0 */
		/* 82194E90h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82194E90h case    3:*/		return 0x82194E94;
		  /* 82194E94h */ case    4:  		/* mr R4, R24 */
		/* 82194E94h case    4:*/		regs.R4 = regs.R24;
		/* 82194E94h case    4:*/		return 0x82194E98;
		  /* 82194E98h */ case    5:  		/* addi R3, R1, 96 */
		/* 82194E98h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82194E98h case    5:*/		return 0x82194E9C;
		  /* 82194E9Ch */ case    6:  		/* bl -4820 */
		/* 82194E9Ch case    6:*/		regs.LR = 0x82194EA0; return 0x82193BC8;
		/* 82194E9Ch case    6:*/		return 0x82194EA0;
		  /* 82194EA0h */ case    7:  		/* cmplwi CR6, R25, 0 */
		/* 82194EA0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82194EA0h case    7:*/		return 0x82194EA4;
		  /* 82194EA4h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 82194EA4h case    8:*/		if ( regs.CR[6].eq ) { return 0x82194EB8;  }
		/* 82194EA4h case    8:*/		return 0x82194EA8;
		  /* 82194EA8h */ case    9:  		/* mr R4, R25 */
		/* 82194EA8h case    9:*/		regs.R4 = regs.R25;
		/* 82194EA8h case    9:*/		return 0x82194EAC;
	}
	return 0x82194EAC;
} // Block from 82194E84h-82194EACh (10 instructions)

//////////////////////////////////////////////////////
// Block at 82194EACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194EAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194EAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194EAC);
		  /* 82194EACh */ case    0:  		/* li R5, 0 */
		/* 82194EACh case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82194EACh case    0:*/		return 0x82194EB0;
		  /* 82194EB0h */ case    1:  		/* addi R3, R1, 96 */
		/* 82194EB0h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82194EB0h case    1:*/		return 0x82194EB4;
		  /* 82194EB4h */ case    2:  		/* bl -4844 */
		/* 82194EB4h case    2:*/		regs.LR = 0x82194EB8; return 0x82193BC8;
		/* 82194EB4h case    2:*/		return 0x82194EB8;
	}
	return 0x82194EB8;
} // Block from 82194EACh-82194EB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82194EB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194EB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194EB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194EB8);
		  /* 82194EB8h */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 82194EB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82194EB8h case    0:*/		return 0x82194EBC;
		  /* 82194EBCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82194EBCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82194EBCh case    1:*/		return 0x82194EC0;
		  /* 82194EC0h */ case    2:  		/* bc 4, CR6_EQ, -2224 */
		/* 82194EC0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82194610;  }
		/* 82194EC0h case    2:*/		return 0x82194EC4;
		  /* 82194EC4h */ case    3:  		/* lwz R31, <#[R1 + 216]> */
		/* 82194EC4h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x000000D8) );
		/* 82194EC4h case    3:*/		return 0x82194EC8;
		  /* 82194EC8h */ case    4:  		/* b 156 */
		/* 82194EC8h case    4:*/		return 0x82194F64;
		/* 82194EC8h case    4:*/		return 0x82194ECC;
	}
	return 0x82194ECC;
} // Block from 82194EB8h-82194ECCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82194ECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194ECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194ECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194ECC);
		  /* 82194ECCh */ case    0:  		/* li R4, 4800 */
		/* 82194ECCh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82194ECCh case    0:*/		return 0x82194ED0;
		  /* 82194ED0h */ case    1:  		/* mr R3, R21 */
		/* 82194ED0h case    1:*/		regs.R3 = regs.R21;
		/* 82194ED0h case    1:*/		return 0x82194ED4;
		  /* 82194ED4h */ case    2:  		/* bl -274540 */
		/* 82194ED4h case    2:*/		regs.LR = 0x82194ED8; return 0x82151E68;
		/* 82194ED4h case    2:*/		return 0x82194ED8;
	}
	return 0x82194ED8;
} // Block from 82194ECCh-82194ED8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82194ED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194ED8);
		  /* 82194ED8h */ case    0:  		/* li R4, 3641 */
		/* 82194ED8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xE39);
		/* 82194ED8h case    0:*/		return 0x82194EDC;
		  /* 82194EDCh */ case    1:  		/* mr R3, R21 */
		/* 82194EDCh case    1:*/		regs.R3 = regs.R21;
		/* 82194EDCh case    1:*/		return 0x82194EE0;
		  /* 82194EE0h */ case    2:  		/* bl -274552 */
		/* 82194EE0h case    2:*/		regs.LR = 0x82194EE4; return 0x82151E68;
		/* 82194EE0h case    2:*/		return 0x82194EE4;
		  /* 82194EE4h */ case    3:  		/* lwz R10, <#[R31 + 4]> */
		/* 82194EE4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82194EE4h case    3:*/		return 0x82194EE8;
		  /* 82194EE8h */ case    4:  		/* addi R11, R31, 4 */
		/* 82194EE8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x4);
		/* 82194EE8h case    4:*/		return 0x82194EEC;
		  /* 82194EECh */ case    5:  		/* b 20 */
		/* 82194EECh case    5:*/		return 0x82194F00;
		/* 82194EECh case    5:*/		return 0x82194EF0;
		  /* 82194EF0h */ case    6:  		/* cmplw CR6, R10, R16 */
		/* 82194EF0h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R16);
		/* 82194EF0h case    6:*/		return 0x82194EF4;
		  /* 82194EF4h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 82194EF4h case    7:*/		if ( regs.CR[6].eq ) { return 0x82194F08;  }
		/* 82194EF4h case    7:*/		return 0x82194EF8;
		  /* 82194EF8h */ case    8:  		/* addi R11, R10, 8 */
		/* 82194EF8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 82194EF8h case    8:*/		return 0x82194EFC;
		  /* 82194EFCh */ case    9:  		/* lwz R10, <#[R10 + 8]> */
		/* 82194EFCh case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82194EFCh case    9:*/		return 0x82194F00;
	}
	return 0x82194F00;
} // Block from 82194ED8h-82194F00h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82194F00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194F00);
		  /* 82194F00h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 82194F00h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82194F00h case    0:*/		return 0x82194F04;
		  /* 82194F04h */ case    1:  		/* bc 4, CR6_EQ, -20 */
		/* 82194F04h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82194EF0;  }
		/* 82194F04h case    1:*/		return 0x82194F08;
	}
	return 0x82194F08;
} // Block from 82194F00h-82194F08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82194F08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194F08);
		  /* 82194F08h */ case    0:  		/* stw R18, <#[R11]> */
		/* 82194F08h case    0:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R11 + 0x00000000) );
		/* 82194F08h case    0:*/		return 0x82194F0C;
		  /* 82194F0Ch */ case    1:  		/* mr R4, R31 */
		/* 82194F0Ch case    1:*/		regs.R4 = regs.R31;
		/* 82194F0Ch case    1:*/		return 0x82194F10;
		  /* 82194F10h */ case    2:  		/* addi R3, R1, 100 */
		/* 82194F10h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x64);
		/* 82194F10h case    2:*/		return 0x82194F14;
		  /* 82194F14h */ case    3:  		/* bl -21452 */
		/* 82194F14h case    3:*/		regs.LR = 0x82194F18; return 0x8218FB48;
		/* 82194F14h case    3:*/		return 0x82194F18;
		  /* 82194F18h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82194F18h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82194F18h case    4:*/		return 0x82194F1C;
		  /* 82194F1Ch */ case    5:  		/* lwz R8, <#[R23]> */
		/* 82194F1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R23 + 0x00000000) );
		/* 82194F1Ch case    5:*/		return 0x82194F20;
		  /* 82194F20h */ case    6:  		/* mr R5, R22 */
		/* 82194F20h case    6:*/		regs.R5 = regs.R22;
		/* 82194F20h case    6:*/		return 0x82194F24;
		  /* 82194F24h */ case    7:  		/* addi R11, R11, 36 */
		/* 82194F24h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82194F24h case    7:*/		return 0x82194F28;
		  /* 82194F28h */ case    8:  		/* mr R4, R31 */
		/* 82194F28h case    8:*/		regs.R4 = regs.R31;
		/* 82194F28h case    8:*/		return 0x82194F2C;
		  /* 82194F2Ch */ case    9:  		/* addi R10, R11, 4 */
		/* 82194F2Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82194F2Ch case    9:*/		return 0x82194F30;
		  /* 82194F30h */ case   10:  		/* addi R9, R11, -36 */
		/* 82194F30h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFDC);
		/* 82194F30h case   10:*/		return 0x82194F34;
		  /* 82194F34h */ case   11:  		/* mr R3, R21 */
		/* 82194F34h case   11:*/		regs.R3 = regs.R21;
		/* 82194F34h case   11:*/		return 0x82194F38;
		  /* 82194F38h */ case   12:  		/* stw R8, <#[R11 + 4]> */
		/* 82194F38h case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82194F38h case   12:*/		return 0x82194F3C;
		  /* 82194F3Ch */ case   13:  		/* lwz R8, <#[R23]> */
		/* 82194F3Ch case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R23 + 0x00000000) );
		/* 82194F3Ch case   13:*/		return 0x82194F40;
		  /* 82194F40h */ case   14:  		/* rlwinm R8, R8, 0, 0, 30 */
		/* 82194F40h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R8);
		/* 82194F40h case   14:*/		return 0x82194F44;
		  /* 82194F44h */ case   15:  		/* stw R10, <#[R8 + 36]> */
		/* 82194F44h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000024) );
		/* 82194F44h case   15:*/		return 0x82194F48;
		  /* 82194F48h */ case   16:  		/* stw R20, <#[R11]> */
		/* 82194F48h case   16:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R11 + 0x00000000) );
		/* 82194F48h case   16:*/		return 0x82194F4C;
		  /* 82194F4Ch */ case   17:  		/* stw R9, <#[R23]> */
		/* 82194F4Ch case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R23 + 0x00000000) );
		/* 82194F4Ch case   17:*/		return 0x82194F50;
		  /* 82194F50h */ case   18:  		/* bl -8336 */
		/* 82194F50h case   18:*/		regs.LR = 0x82194F54; return 0x82192EC0;
		/* 82194F50h case   18:*/		return 0x82194F54;
		  /* 82194F54h */ case   19:  		/* addi R22, R22, 1 */
		/* 82194F54h case   19:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 82194F54h case   19:*/		return 0x82194F58;
		  /* 82194F58h */ case   20:  		/* cmplwi CR6, R22, 8191 */
		/* 82194F58h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00001FFF);
		/* 82194F58h case   20:*/		return 0x82194F5C;
		  /* 82194F5Ch */ case   21:  		/* bc 12, CR6_EQ, 44 */
		/* 82194F5Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x82194F88;  }
		/* 82194F5Ch case   21:*/		return 0x82194F60;
		  /* 82194F60h */ case   22:  		/* lwz R31, <#[R31 + 32]> */
		/* 82194F60h case   22:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000020) );
		/* 82194F60h case   22:*/		return 0x82194F64;
	}
	return 0x82194F64;
} // Block from 82194F08h-82194F64h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82194F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194F64);
		  /* 82194F64h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82194F64h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82194F64h case    0:*/		return 0x82194F68;
		  /* 82194F68h */ case    1:  		/* bc 4, CR6_EQ, -132 */
		/* 82194F68h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82194EE4;  }
		/* 82194F68h case    1:*/		return 0x82194F6C;
		  /* 82194F6Ch */ case    2:  		/* cmplwi CR6, R17, 0 */
		/* 82194F6Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 82194F6Ch case    2:*/		return 0x82194F70;
		  /* 82194F70h */ case    3:  		/* bc 12, CR6_EQ, 432 */
		/* 82194F70h case    3:*/		if ( regs.CR[6].eq ) { return 0x82195120;  }
		/* 82194F70h case    3:*/		return 0x82194F74;
		  /* 82194F74h */ case    4:  		/* lwz R11, <#[R23]> */
		/* 82194F74h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 82194F74h case    4:*/		return 0x82194F78;
		  /* 82194F78h */ case    5:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82194F78h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82194F78h case    5:*/		return 0x82194F7C;
		  /* 82194F7Ch */ case    6:  		/* bc 12, CR0_EQ, 24 */
		/* 82194F7Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x82194F94;  }
		/* 82194F7Ch case    6:*/		return 0x82194F80;
		  /* 82194F80h */ case    7:  		/* mr R6, R18 */
		/* 82194F80h case    7:*/		regs.R6 = regs.R18;
		/* 82194F80h case    7:*/		return 0x82194F84;
		  /* 82194F84h */ case    8:  		/* b 28 */
		/* 82194F84h case    8:*/		return 0x82194FA0;
		/* 82194F84h case    8:*/		return 0x82194F88;
	}
	return 0x82194F88;
} // Block from 82194F64h-82194F88h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82194F88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194F88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194F88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194F88);
		  /* 82194F88h */ case    0:  		/* li R4, 3641 */
		/* 82194F88h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xE39);
		/* 82194F88h case    0:*/		return 0x82194F8C;
		  /* 82194F8Ch */ case    1:  		/* mr R3, R21 */
		/* 82194F8Ch case    1:*/		regs.R3 = regs.R21;
		/* 82194F8Ch case    1:*/		return 0x82194F90;
		  /* 82194F90h */ case    2:  		/* bl -274728 */
		/* 82194F90h case    2:*/		regs.LR = 0x82194F94; return 0x82151E68;
		/* 82194F90h case    2:*/		return 0x82194F94;
	}
	return 0x82194F94;
} // Block from 82194F88h-82194F94h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82194F94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194F94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194F94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194F94);
		  /* 82194F94h */ case    0:  		/* lwz R11, <#[R19]> */
		/* 82194F94h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 82194F94h case    0:*/		return 0x82194F98;
		  /* 82194F98h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82194F98h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82194F98h case    1:*/		return 0x82194F9C;
		  /* 82194F9Ch */ case    2:  		/* addi R6, R11, -40 */
		/* 82194F9Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFFD8);
		/* 82194F9Ch case    2:*/		return 0x82194FA0;
	}
	return 0x82194FA0;
} // Block from 82194F94h-82194FA0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82194FA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82194FA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82194FA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82194FA0);
		  /* 82194FA0h */ case    0:  		/* mr R5, R19 */
		/* 82194FA0h case    0:*/		regs.R5 = regs.R19;
		/* 82194FA0h case    0:*/		return 0x82194FA4;
		  /* 82194FA4h */ case    1:  		/* addi R4, R1, 96 */
		/* 82194FA4h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 82194FA4h case    1:*/		return 0x82194FA8;
		  /* 82194FA8h */ case    2:  		/* addi R3, R1, 160 */
		/* 82194FA8h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 82194FA8h case    2:*/		return 0x82194FAC;
		  /* 82194FACh */ case    3:  		/* bl -18620 */
		/* 82194FACh case    3:*/		regs.LR = 0x82194FB0; return 0x821906F0;
		/* 82194FACh case    3:*/		return 0x82194FB0;
		  /* 82194FB0h */ case    4:  		/* addi R3, R1, 160 */
		/* 82194FB0h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 82194FB0h case    4:*/		return 0x82194FB4;
		  /* 82194FB4h */ case    5:  		/* bl -18436 */
		/* 82194FB4h case    5:*/		regs.LR = 0x82194FB8; return 0x821907B0;
		/* 82194FB4h case    5:*/		return 0x82194FB8;
		  /* 82194FB8h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82194FB8h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82194FB8h case    6:*/		return 0x82194FBC;
		  /* 82194FBCh */ case    7:  		/* bc 12, CR0_EQ, 340 */
		/* 82194FBCh case    7:*/		if ( regs.CR[0].eq ) { return 0x82195110;  }
		/* 82194FBCh case    7:*/		return 0x82194FC0;
		  /* 82194FC0h */ case    8:  		/* lwz R30, <#[R1 + 160]> */
		/* 82194FC0h case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x000000A0) );
		/* 82194FC0h case    8:*/		return 0x82194FC4;
		  /* 82194FC4h */ case    9:  		/* lwz R11, <#[R30 + 8]> */
		/* 82194FC4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82194FC4h case    9:*/		return 0x82194FC8;
		  /* 82194FC8h */ case   10:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 82194FC8h case   10:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82194FC8h case   10:*/		return 0x82194FCC;
		  /* 82194FCCh */ case   11:  		/* bc 12, CR0_EQ, 324 */
		/* 82194FCCh case   11:*/		if ( regs.CR[0].eq ) { return 0x82195110;  }
		/* 82194FCCh case   11:*/		return 0x82194FD0;
		  /* 82194FD0h */ case   12:  		/* mr R3, R30 */
		/* 82194FD0h case   12:*/		regs.R3 = regs.R30;
		/* 82194FD0h case   12:*/		return 0x82194FD4;
		  /* 82194FD4h */ case   13:  		/* bl -16900 */
		/* 82194FD4h case   13:*/		regs.LR = 0x82194FD8; return 0x82190DD0;
		/* 82194FD4h case   13:*/		return 0x82194FD8;
		  /* 82194FD8h */ case   14:  		/* cmplwi CR6, R3, 1 */
		/* 82194FD8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000001);
		/* 82194FD8h case   14:*/		return 0x82194FDC;
		  /* 82194FDCh */ case   15:  		/* bc 4, CR6_EQ, 308 */
		/* 82194FDCh case   15:*/		if ( !regs.CR[6].eq ) { return 0x82195110;  }
		/* 82194FDCh case   15:*/		return 0x82194FE0;
		  /* 82194FE0h */ case   16:  		/* addi R11, R1, 52 */
		/* 82194FE0h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x34);
		/* 82194FE0h case   16:*/		return 0x82194FE4;
		  /* 82194FE4h */ case   17:  		/* addi R10, R1, 92 */
		/* 82194FE4h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x5C);
		/* 82194FE4h case   17:*/		return 0x82194FE8;
		  /* 82194FE8h */ case   18:  		/* ori R10, R10, 1 */
		/* 82194FE8h case   18:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82194FE8h case   18:*/		return 0x82194FEC;
		  /* 82194FECh */ case   19:  		/* ori R11, R11, 1 */
		/* 82194FECh case   19:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82194FECh case   19:*/		return 0x82194FF0;
		  /* 82194FF0h */ case   20:  		/* stw R10, <#[R1 + 88]> */
		/* 82194FF0h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82194FF0h case   20:*/		return 0x82194FF4;
		  /* 82194FF4h */ case   21:  		/* addi R5, R1, 88 */
		/* 82194FF4h case   21:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 82194FF4h case   21:*/		return 0x82194FF8;
		  /* 82194FF8h */ case   22:  		/* stw R11, <#[R1 + 92]> */
		/* 82194FF8h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 82194FF8h case   22:*/		return 0x82194FFC;
		  /* 82194FFCh */ case   23:  		/* mr R4, R30 */
		/* 82194FFCh case   23:*/		regs.R4 = regs.R30;
		/* 82194FFCh case   23:*/		return 0x82195000;
		  /* 82195000h */ case   24:  		/* mr R3, R21 */
		/* 82195000h case   24:*/		regs.R3 = regs.R21;
		/* 82195000h case   24:*/		return 0x82195004;
		  /* 82195004h */ case   25:  		/* bl -4980 */
		/* 82195004h case   25:*/		regs.LR = 0x82195008; return 0x82193C90;
		/* 82195004h case   25:*/		return 0x82195008;
		  /* 82195008h */ case   26:  		/* lwz R29, <#[R1 + 92]> */
		/* 82195008h case   26:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x0000005C) );
		/* 82195008h case   26:*/		return 0x8219500C;
		  /* 8219500Ch */ case   27:  		/* rlwinm. R11, R29, 0, 31, 31 */
		/* 8219500Ch case   27:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R29);
		/* 8219500Ch case   27:*/		return 0x82195010;
		  /* 82195010h */ case   28:  		/* bc 4, CR0_EQ, 256 */
		/* 82195010h case   28:*/		if ( !regs.CR[0].eq ) { return 0x82195110;  }
		/* 82195010h case   28:*/		return 0x82195014;
		  /* 82195014h */ case   29:  		/* cmplwi CR6, R29, 0 */
		/* 82195014h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82195014h case   29:*/		return 0x82195018;
		  /* 82195018h */ case   30:  		/* bc 12, CR6_EQ, 248 */
		/* 82195018h case   30:*/		if ( regs.CR[6].eq ) { return 0x82195110;  }
		/* 82195018h case   30:*/		return 0x8219501C;
		  /* 8219501Ch */ case   31:  		/* rlwinm R31, R29, 0, 0, 30 */
		/* 8219501Ch case   31:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R31,regs.R29);
		/* 8219501Ch case   31:*/		return 0x82195020;
		  /* 82195020h */ case   32:  		/* lwz R11, <#[R31 + 40]> */
		/* 82195020h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 82195020h case   32:*/		return 0x82195024;
		  /* 82195024h */ case   33:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82195024h case   33:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82195024h case   33:*/		return 0x82195028;
		  /* 82195028h */ case   34:  		/* bc 4, CR0_EQ, 12 */
		/* 82195028h case   34:*/		if ( !regs.CR[0].eq ) { return 0x82195034;  }
		/* 82195028h case   34:*/		return 0x8219502C;
		  /* 8219502Ch */ case   35:  		/* cmplwi CR6, R11, 0 */
		/* 8219502Ch case   35:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219502Ch case   35:*/		return 0x82195030;
		  /* 82195030h */ case   36:  		/* bc 4, CR6_EQ, 212 */
		/* 82195030h case   36:*/		if ( !regs.CR[6].eq ) { return 0x82195104;  }
		/* 82195030h case   36:*/		return 0x82195034;
	}
	return 0x82195034;
} // Block from 82194FA0h-82195034h (37 instructions)

//////////////////////////////////////////////////////
// Block at 82195034h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195034( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195034) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195034);
		  /* 82195034h */ case    0:  		/* mr R4, R30 */
		/* 82195034h case    0:*/		regs.R4 = regs.R30;
		/* 82195034h case    0:*/		return 0x82195038;
		  /* 82195038h */ case    1:  		/* addi R3, R1, 164 */
		/* 82195038h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA4);
		/* 82195038h case    1:*/		return 0x8219503C;
		  /* 8219503Ch */ case    2:  		/* bl -19332 */
		/* 8219503Ch case    2:*/		regs.LR = 0x82195040; return 0x821904B8;
		/* 8219503Ch case    2:*/		return 0x82195040;
		  /* 82195040h */ case    3:  		/* mr R4, R29 */
		/* 82195040h case    3:*/		regs.R4 = regs.R29;
		/* 82195040h case    3:*/		return 0x82195044;
		  /* 82195044h */ case    4:  		/* addi R3, R1, 164 */
		/* 82195044h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA4);
		/* 82195044h case    4:*/		return 0x82195048;
		  /* 82195048h */ case    5:  		/* bl -155376 */
		/* 82195048h case    5:*/		regs.LR = 0x8219504C; return 0x8216F158;
		/* 82195048h case    5:*/		return 0x8219504C;
		  /* 8219504Ch */ case    6:  		/* mr R28, R3 */
		/* 8219504Ch case    6:*/		regs.R28 = regs.R3;
		/* 8219504Ch case    6:*/		return 0x82195050;
		  /* 82195050h */ case    7:  		/* addi R3, R1, 164 */
		/* 82195050h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA4);
		/* 82195050h case    7:*/		return 0x82195054;
		  /* 82195054h */ case    8:  		/* lwz R4, <#[R1 + 160]> */
		/* 82195054h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000A0) );
		/* 82195054h case    8:*/		return 0x82195058;
		  /* 82195058h */ case    9:  		/* bl -154752 */
		/* 82195058h case    9:*/		regs.LR = 0x8219505C; return 0x8216F3D8;
		/* 82195058h case    9:*/		return 0x8219505C;
		  /* 8219505Ch */ case   10:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 8219505Ch case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 8219505Ch case   10:*/		return 0x82195060;
		  /* 82195060h */ case   11:  		/* bc 12, CR0_EQ, 164 */
		/* 82195060h case   11:*/		if ( regs.CR[0].eq ) { return 0x82195104;  }
		/* 82195060h case   11:*/		return 0x82195064;
		  /* 82195064h */ case   12:  		/* lwz R9, <#[R31 + 40]> */
		/* 82195064h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000028) );
		/* 82195064h case   12:*/		return 0x82195068;
		  /* 82195068h */ case   13:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82195068h case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82195068h case   13:*/		return 0x8219506C;
		  /* 8219506Ch */ case   14:  		/* lwz R7, <#[R31 + 36]> */
		/* 8219506Ch case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000024) );
		/* 8219506Ch case   14:*/		return 0x82195070;
		  /* 82195070h */ case   15:  		/* addi R10, R31, 36 */
		/* 82195070h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x24);
		/* 82195070h case   15:*/		return 0x82195074;
		  /* 82195074h */ case   16:  		/* rlwinm R6, R9, 0, 0, 30 */
		/* 82195074h case   16:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R9);
		/* 82195074h case   16:*/		return 0x82195078;
		  /* 82195078h */ case   17:  		/* addi R11, R11, 36 */
		/* 82195078h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82195078h case   17:*/		return 0x8219507C;
		  /* 8219507Ch */ case   18:  		/* addi R8, R10, 4 */
		/* 8219507Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x4);
		/* 8219507Ch case   18:*/		return 0x82195080;
		  /* 82195080h */ case   19:  		/* addi R9, R11, 4 */
		/* 82195080h case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 82195080h case   19:*/		return 0x82195084;
		  /* 82195084h */ case   20:  		/* addi R10, R10, -36 */
		/* 82195084h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFDC);
		/* 82195084h case   20:*/		return 0x82195088;
		  /* 82195088h */ case   21:  		/* stw R7, <#[R6 + 36]> */
		/* 82195088h case   21:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + 0x00000024) );
		/* 82195088h case   21:*/		return 0x8219508C;
		  /* 8219508Ch */ case   22:  		/* mr R5, R29 */
		/* 8219508Ch case   22:*/		regs.R5 = regs.R29;
		/* 8219508Ch case   22:*/		return 0x82195090;
		  /* 82195090h */ case   23:  		/* lwz R6, <#[R31 + 36]> */
		/* 82195090h case   23:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000024) );
		/* 82195090h case   23:*/		return 0x82195094;
		  /* 82195094h */ case   24:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 82195094h case   24:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 82195094h case   24:*/		return 0x82195098;
		  /* 82195098h */ case   25:  		/* lwz R7, <#[R31 + 40]> */
		/* 82195098h case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000028) );
		/* 82195098h case   25:*/		return 0x8219509C;
		  /* 8219509Ch */ case   26:  		/* mr R4, R30 */
		/* 8219509Ch case   26:*/		regs.R4 = regs.R30;
		/* 8219509Ch case   26:*/		return 0x821950A0;
		  /* 821950A0h */ case   27:  		/* mr R3, R21 */
		/* 821950A0h case   27:*/		regs.R3 = regs.R21;
		/* 821950A0h case   27:*/		return 0x821950A4;
		  /* 821950A4h */ case   28:  		/* stw R7, <#[R6]> */
		/* 821950A4h case   28:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + 0x00000000) );
		/* 821950A4h case   28:*/		return 0x821950A8;
		  /* 821950A8h */ case   29:  		/* lwz R7, <#[R11 + 4]> */
		/* 821950A8h case   29:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 821950A8h case   29:*/		return 0x821950AC;
		  /* 821950ACh */ case   30:  		/* stw R7, <#[R31 + 40]> */
		/* 821950ACh case   30:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x00000028) );
		/* 821950ACh case   30:*/		return 0x821950B0;
		  /* 821950B0h */ case   31:  		/* lwz R7, <#[R11 + 4]> */
		/* 821950B0h case   31:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 821950B0h case   31:*/		return 0x821950B4;
		  /* 821950B4h */ case   32:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821950B4h case   32:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821950B4h case   32:*/		return 0x821950B8;
		  /* 821950B8h */ case   33:  		/* stw R8, <#[R7 + 36]> */
		/* 821950B8h case   33:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000024) );
		/* 821950B8h case   33:*/		return 0x821950BC;
		  /* 821950BCh */ case   34:  		/* stw R9, <#[R31 + 36]> */
		/* 821950BCh case   34:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000024) );
		/* 821950BCh case   34:*/		return 0x821950C0;
		  /* 821950C0h */ case   35:  		/* stw R10, <#[R11 + 4]> */
		/* 821950C0h case   35:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821950C0h case   35:*/		return 0x821950C4;
		  /* 821950C4h */ case   36:  		/* bl -15500 */
		/* 821950C4h case   36:*/		regs.LR = 0x821950C8; return 0x82191438;
		/* 821950C4h case   36:*/		return 0x821950C8;
		  /* 821950C8h */ case   37:  		/* lwz R11, <#[R30 + 20]> */
		/* 821950C8h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 821950C8h case   37:*/		return 0x821950CC;
		  /* 821950CCh */ case   38:  		/* mr R4, R29 */
		/* 821950CCh case   38:*/		regs.R4 = regs.R29;
		/* 821950CCh case   38:*/		return 0x821950D0;
		  /* 821950D0h */ case   39:  		/* mr R3, R21 */
		/* 821950D0h case   39:*/		regs.R3 = regs.R21;
		/* 821950D0h case   39:*/		return 0x821950D4;
		  /* 821950D4h */ case   40:  		/* rlwinm R5, R11, 0, 19, 31 */
		/* 821950D4h case   40:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R5,regs.R11);
		/* 821950D4h case   40:*/		return 0x821950D8;
		  /* 821950D8h */ case   41:  		/* bl -8728 */
		/* 821950D8h case   41:*/		regs.LR = 0x821950DC; return 0x82192EC0;
		/* 821950D8h case   41:*/		return 0x821950DC;
		  /* 821950DCh */ case   42:  		/* lwz R11, <#[R1 + 160]> */
		/* 821950DCh case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A0) );
		/* 821950DCh case   42:*/		return 0x821950E0;
		  /* 821950E0h */ case   43:  		/* cmplw CR6, R30, R11 */
		/* 821950E0h case   43:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 821950E0h case   43:*/		return 0x821950E4;
		  /* 821950E4h */ case   44:  		/* bc 4, CR6_EQ, 8 */
		/* 821950E4h case   44:*/		if ( !regs.CR[6].eq ) { return 0x821950EC;  }
		/* 821950E4h case   44:*/		return 0x821950E8;
		  /* 821950E8h */ case   45:  		/* stw R29, <#[R1 + 160]> */
		/* 821950E8h case   45:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x000000A0) );
		/* 821950E8h case   45:*/		return 0x821950EC;
	}
	return 0x821950EC;
} // Block from 82195034h-821950ECh (46 instructions)

//////////////////////////////////////////////////////
// Block at 821950ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821950EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821950EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821950EC);
		  /* 821950ECh */ case    0:  		/* li R6, 1 */
		/* 821950ECh case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821950ECh case    0:*/		return 0x821950F0;
		  /* 821950F0h */ case    1:  		/* li R5, 0 */
		/* 821950F0h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821950F0h case    1:*/		return 0x821950F4;
		  /* 821950F4h */ case    2:  		/* mr R4, R30 */
		/* 821950F4h case    2:*/		regs.R4 = regs.R30;
		/* 821950F4h case    2:*/		return 0x821950F8;
		  /* 821950F8h */ case    3:  		/* mr R3, R21 */
		/* 821950F8h case    3:*/		regs.R3 = regs.R21;
		/* 821950F8h case    3:*/		return 0x821950FC;
		  /* 821950FCh */ case    4:  		/* bl 615116 */
		/* 821950FCh case    4:*/		regs.LR = 0x82195100; return 0x8222B3C8;
		/* 821950FCh case    4:*/		return 0x82195100;
		  /* 82195100h */ case    5:  		/* b 16 */
		/* 82195100h case    5:*/		return 0x82195110;
		/* 82195100h case    5:*/		return 0x82195104;
	}
	return 0x82195104;
} // Block from 821950ECh-82195104h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82195104h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195104( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195104) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195104);
		  /* 82195104h */ case    0:  		/* addi R4, R1, 88 */
		/* 82195104h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x58);
		/* 82195104h case    0:*/		return 0x82195108;
		  /* 82195108h */ case    1:  		/* mr R3, R21 */
		/* 82195108h case    1:*/		regs.R3 = regs.R21;
		/* 82195108h case    1:*/		return 0x8219510C;
		  /* 8219510Ch */ case    2:  		/* bl -14348 */
		/* 8219510Ch case    2:*/		regs.LR = 0x82195110; return 0x82191900;
		/* 8219510Ch case    2:*/		return 0x82195110;
	}
	return 0x82195110;
} // Block from 82195104h-82195110h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82195110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195110);
		  /* 82195110h */ case    0:  		/* addi R3, R1, 160 */
		/* 82195110h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 82195110h case    0:*/		return 0x82195114;
		  /* 82195114h */ case    1:  		/* bl -18284 */
		/* 82195114h case    1:*/		regs.LR = 0x82195118; return 0x821909A8;
		/* 82195114h case    1:*/		return 0x82195118;
		  /* 82195118h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82195118h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82195118h case    2:*/		return 0x8219511C;
		  /* 8219511Ch */ case    3:  		/* bc 4, CR0_EQ, -364 */
		/* 8219511Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x82194FB0;  }
		/* 8219511Ch case    3:*/		return 0x82195120;
	}
	return 0x82195120;
} // Block from 82195110h-82195120h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82195120h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195120);
		  /* 82195120h */ case    0:  		/* li R6, 0 */
		/* 82195120h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82195120h case    0:*/		return 0x82195124;
		  /* 82195124h */ case    1:  		/* li R5, 1 */
		/* 82195124h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82195124h case    1:*/		return 0x82195128;
		  /* 82195128h */ case    2:  		/* mr R4, R15 */
		/* 82195128h case    2:*/		regs.R4 = regs.R15;
		/* 82195128h case    2:*/		return 0x8219512C;
		  /* 8219512Ch */ case    3:  		/* mr R3, R21 */
		/* 8219512Ch case    3:*/		regs.R3 = regs.R21;
		/* 8219512Ch case    3:*/		return 0x82195130;
		  /* 82195130h */ case    4:  		/* bl -153488 */
		/* 82195130h case    4:*/		regs.LR = 0x82195134; return 0x8216F9A0;
		/* 82195130h case    4:*/		return 0x82195134;
		  /* 82195134h */ case    5:  		/* addi R1, R1, 368 */
		/* 82195134h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x170);
		/* 82195134h case    5:*/		return 0x82195138;
		  /* 82195138h */ case    6:  		/* b -1064644 */
		/* 82195138h case    6:*/		return 0x82091274;
		/* 82195138h case    6:*/		return 0x8219513C;
		  /* 8219513Ch */ case    7:  		/* nop */
		/* 8219513Ch case    7:*/		cpu::op::nop();
		/* 8219513Ch case    7:*/		return 0x82195140;
	}
	return 0x82195140;
} // Block from 82195120h-82195140h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82195140h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195140);
		  /* 82195140h */ case    0:  		/* mfspr R12, LR */
		/* 82195140h case    0:*/		regs.R12 = regs.LR;
		/* 82195140h case    0:*/		return 0x82195144;
		  /* 82195144h */ case    1:  		/* bl -1064728 */
		/* 82195144h case    1:*/		regs.LR = 0x82195148; return 0x8209122C;
		/* 82195144h case    1:*/		return 0x82195148;
		  /* 82195148h */ case    2:  		/* stwu R1, <#[R1 - 256]> */
		/* 82195148h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 82195148h case    2:*/		return 0x8219514C;
		  /* 8219514Ch */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 8219514Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8219514Ch case    3:*/		return 0x82195150;
		  /* 82195150h */ case    4:  		/* mr R18, R3 */
		/* 82195150h case    4:*/		regs.R18 = regs.R3;
		/* 82195150h case    4:*/		return 0x82195154;
		  /* 82195154h */ case    5:  		/* li R17, 1 */
		/* 82195154h case    5:*/		cpu::op::li<0>(regs,&regs.R17,0x1);
		/* 82195154h case    5:*/		return 0x82195158;
		  /* 82195158h */ case    6:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82195158h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82195158h case    6:*/		return 0x8219515C;
		  /* 8219515Ch */ case    7:  		/* bc 4, CR0_EQ, 228 */
		/* 8219515Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x82195240;  }
		/* 8219515Ch case    7:*/		return 0x82195160;
		  /* 82195160h */ case    8:  		/* mr R7, R11 */
		/* 82195160h case    8:*/		regs.R7 = regs.R11;
		/* 82195160h case    8:*/		return 0x82195164;
		  /* 82195164h */ case    9:  		/* cmplwi CR0, R11, 0 */
		/* 82195164h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82195164h case    9:*/		return 0x82195168;
		  /* 82195168h */ case   10:  		/* bc 12, CR0_EQ, 216 */
		/* 82195168h case   10:*/		if ( regs.CR[0].eq ) { return 0x82195240;  }
		/* 82195168h case   10:*/		return 0x8219516C;
		  /* 8219516Ch */ case   11:  		/* lwz R11, <#[R7 + 20]> */
		/* 8219516Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000014) );
		/* 8219516Ch case   11:*/		return 0x82195170;
		  /* 82195170h */ case   12:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82195170h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82195170h case   12:*/		return 0x82195174;
		  /* 82195174h */ case   13:  		/* bc 12, CR0_EQ, 40 */
		/* 82195174h case   13:*/		if ( regs.CR[0].eq ) { return 0x8219519C;  }
		/* 82195174h case   13:*/		return 0x82195178;
		  /* 82195178h */ case   14:  		/* lwz R11, <#[R7 + 28]> */
		/* 82195178h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x0000001C) );
		/* 82195178h case   14:*/		return 0x8219517C;
		  /* 8219517Ch */ case   15:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8219517Ch case   15:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8219517Ch case   15:*/		return 0x82195180;
		  /* 82195180h */ case   16:  		/* bc 12, CR0_EQ, 16 */
		/* 82195180h case   16:*/		if ( regs.CR[0].eq ) { return 0x82195190;  }
		/* 82195180h case   16:*/		return 0x82195184;
		  /* 82195184h */ case   17:  		/* lwz R11, <#[R7 + 36]> */
		/* 82195184h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000024) );
		/* 82195184h case   17:*/		return 0x82195188;
		  /* 82195188h */ case   18:  		/* addi R10, R7, 32 */
		/* 82195188h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R7,0x20);
		/* 82195188h case   18:*/		return 0x8219518C;
		  /* 8219518Ch */ case   19:  		/* b 24 */
		/* 8219518Ch case   19:*/		return 0x821951A4;
		/* 8219518Ch case   19:*/		return 0x82195190;
	}
	return 0x82195190;
} // Block from 82195140h-82195190h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82195190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195190);
		  /* 82195190h */ case    0:  		/* lwz R11, <#[R7 + 28]> */
		/* 82195190h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x0000001C) );
		/* 82195190h case    0:*/		return 0x82195194;
		  /* 82195194h */ case    1:  		/* addi R10, R7, 24 */
		/* 82195194h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R7,0x18);
		/* 82195194h case    1:*/		return 0x82195198;
		  /* 82195198h */ case    2:  		/* b 12 */
		/* 82195198h case    2:*/		return 0x821951A4;
		/* 82195198h case    2:*/		return 0x8219519C;
	}
	return 0x8219519C;
} // Block from 82195190h-8219519Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219519Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219519C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219519C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219519C);
		  /* 8219519Ch */ case    0:  		/* lwz R11, <#[R7 + 20]> */
		/* 8219519Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000014) );
		/* 8219519Ch case    0:*/		return 0x821951A0;
		  /* 821951A0h */ case    1:  		/* addi R10, R7, 16 */
		/* 821951A0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R7,0x10);
		/* 821951A0h case    1:*/		return 0x821951A4;
	}
	return 0x821951A4;
} // Block from 8219519Ch-821951A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821951A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821951A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821951A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821951A4);
		  /* 821951A4h */ case    0:  		/* rlwinm R9, R11, 0, 31, 31 */
		/* 821951A4h case    0:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821951A4h case    0:*/		return 0x821951A8;
		  /* 821951A8h */ case    1:  		/* addic R9, R9, -1 */
		/* 821951A8h case    1:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 821951A8h case    1:*/		return 0x821951AC;
		  /* 821951ACh */ case    2:  		/* subfe R9, R9, R9 */
		/* 821951ACh case    2:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821951ACh case    2:*/		return 0x821951B0;
		  /* 821951B0h */ case    3:  		/* and R11, R9, R11 */
		/* 821951B0h case    3:*/		cpu::op::and<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821951B0h case    3:*/		return 0x821951B4;
		  /* 821951B4h */ case    4:  		/* b 104 */
		/* 821951B4h case    4:*/		return 0x8219521C;
		/* 821951B4h case    4:*/		return 0x821951B8;
		  /* 821951B8h */ case    5:  		/* lwz R9, <#[R11 + 20]> */
		/* 821951B8h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 821951B8h case    5:*/		return 0x821951BC;
		  /* 821951BCh */ case    6:  		/* rlwinm R8, R11, 0, 0, 30 */
		/* 821951BCh case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R11);
		/* 821951BCh case    6:*/		return 0x821951C0;
		  /* 821951C0h */ case    7:  		/* rlwimi R9, R17, 29, 2, 5 */
		/* 821951C0h case    7:*/		cpu::op::rlwimi<0,29,2,5>(regs,&regs.R9,regs.R17);
		/* 821951C0h case    7:*/		return 0x821951C4;
		  /* 821951C4h */ case    8:  		/* stw R9, <#[R11 + 20]> */
		/* 821951C4h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 821951C4h case    8:*/		return 0x821951C8;
		  /* 821951C8h */ case    9:  		/* lwz R11, <#[R8 + 40]> */
		/* 821951C8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000028) );
		/* 821951C8h case    9:*/		return 0x821951CC;
		  /* 821951CCh */ case   10:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 821951CCh case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821951CCh case   10:*/		return 0x821951D0;
		  /* 821951D0h */ case   11:  		/* bc 4, CR0_EQ, 12 */
		/* 821951D0h case   11:*/		if ( !regs.CR[0].eq ) { return 0x821951DC;  }
		/* 821951D0h case   11:*/		return 0x821951D4;
		  /* 821951D4h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 821951D4h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821951D4h case   12:*/		return 0x821951D8;
		  /* 821951D8h */ case   13:  		/* bc 4, CR6_EQ, -32 */
		/* 821951D8h case   13:*/		if ( !regs.CR[6].eq ) { return 0x821951B8;  }
		/* 821951D8h case   13:*/		return 0x821951DC;
	}
	return 0x821951DC;
} // Block from 821951A4h-821951DCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 821951DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821951DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821951DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821951DC);
		  /* 821951DCh */ case    0:  		/* addi R8, R7, 32 */
		/* 821951DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R7,0x20);
		/* 821951DCh case    0:*/		return 0x821951E0;
		  /* 821951E0h */ case    1:  		/* cmplw CR6, R10, R8 */
		/* 821951E0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 821951E0h case    1:*/		return 0x821951E4;
		  /* 821951E4h */ case    2:  		/* bc 12, CR6_EQ, 64 */
		/* 821951E4h case    2:*/		if ( regs.CR[6].eq ) { return 0x82195224;  }
		/* 821951E4h case    2:*/		return 0x821951E8;
		  /* 821951E8h */ case    3:  		/* addi R9, R7, 24 */
		/* 821951E8h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R7,0x18);
		/* 821951E8h case    3:*/		return 0x821951EC;
		  /* 821951ECh */ case    4:  		/* cmplw CR6, R10, R9 */
		/* 821951ECh case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821951ECh case    4:*/		return 0x821951F0;
		  /* 821951F0h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 821951F0h case    5:*/		if ( regs.CR[6].eq ) { return 0x8219520C;  }
		/* 821951F0h case    5:*/		return 0x821951F4;
		  /* 821951F4h */ case    6:  		/* lwz R11, <#[R7 + 28]> */
		/* 821951F4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x0000001C) );
		/* 821951F4h case    6:*/		return 0x821951F8;
		  /* 821951F8h */ case    7:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821951F8h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821951F8h case    7:*/		return 0x821951FC;
		  /* 821951FCh */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 821951FCh case    8:*/		if ( !regs.CR[0].eq ) { return 0x8219520C;  }
		/* 821951FCh case    8:*/		return 0x82195200;
		  /* 82195200h */ case    9:  		/* lwz R11, <#[R9 + 4]> */
		/* 82195200h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 82195200h case    9:*/		return 0x82195204;
		  /* 82195204h */ case   10:  		/* mr R10, R9 */
		/* 82195204h case   10:*/		regs.R10 = regs.R9;
		/* 82195204h case   10:*/		return 0x82195208;
		  /* 82195208h */ case   11:  		/* b 12 */
		/* 82195208h case   11:*/		return 0x82195214;
		/* 82195208h case   11:*/		return 0x8219520C;
	}
	return 0x8219520C;
} // Block from 821951DCh-8219520Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8219520Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219520C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219520C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219520C);
		  /* 8219520Ch */ case    0:  		/* lwz R11, <#[R8 + 4]> */
		/* 8219520Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 8219520Ch case    0:*/		return 0x82195210;
		  /* 82195210h */ case    1:  		/* mr R10, R8 */
		/* 82195210h case    1:*/		regs.R10 = regs.R8;
		/* 82195210h case    1:*/		return 0x82195214;
	}
	return 0x82195214;
} // Block from 8219520Ch-82195214h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82195214h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195214( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195214) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195214);
		  /* 82195214h */ case    0:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 82195214h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 82195214h case    0:*/		return 0x82195218;
		  /* 82195218h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 82195218h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82195224;  }
		/* 82195218h case    1:*/		return 0x8219521C;
	}
	return 0x8219521C;
} // Block from 82195214h-8219521Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219521Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219521C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219521C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219521C);
		  /* 8219521Ch */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8219521Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219521Ch case    0:*/		return 0x82195220;
		  /* 82195220h */ case    1:  		/* bc 4, CR6_EQ, -104 */
		/* 82195220h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821951B8;  }
		/* 82195220h case    1:*/		return 0x82195224;
	}
	return 0x82195224;
} // Block from 8219521Ch-82195224h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82195224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195224);
		  /* 82195224h */ case    0:  		/* rlwinm R11, R7, 0, 0, 30 */
		/* 82195224h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R7);
		/* 82195224h case    0:*/		return 0x82195228;
		  /* 82195228h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 82195228h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82195228h case    1:*/		return 0x8219522C;
		  /* 8219522Ch */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219522Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219522Ch case    2:*/		return 0x82195230;
		  /* 82195230h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82195230h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82195240;  }
		/* 82195230h case    3:*/		return 0x82195234;
		  /* 82195234h */ case    4:  		/* mr R7, R11 */
		/* 82195234h case    4:*/		regs.R7 = regs.R11;
		/* 82195234h case    4:*/		return 0x82195238;
		  /* 82195238h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82195238h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82195238h case    5:*/		return 0x8219523C;
		  /* 8219523Ch */ case    6:  		/* bc 4, CR6_EQ, -208 */
		/* 8219523Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x8219516C;  }
		/* 8219523Ch case    6:*/		return 0x82195240;
	}
	return 0x82195240;
} // Block from 82195224h-82195240h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82195240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195240);
		  /* 82195240h */ case    0:  		/* lwz R11, <#[R18 + 4]> */
		/* 82195240h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000004) );
		/* 82195240h case    0:*/		return 0x82195244;
		  /* 82195244h */ case    1:  		/* li R23, 0 */
		/* 82195244h case    1:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82195244h case    1:*/		return 0x82195248;
		  /* 82195248h */ case    2:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82195248h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82195248h case    2:*/		return 0x8219524C;
		  /* 8219524Ch */ case    3:  		/* bc 4, CR0_EQ, 1700 */
		/* 8219524Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x821958F0;  }
		/* 8219524Ch case    3:*/		return 0x82195250;
		  /* 82195250h */ case    4:  		/* lwz R11, <#[R18]> */
		/* 82195250h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 82195250h case    4:*/		return 0x82195254;
		  /* 82195254h */ case    5:  		/* b 1680 */
		/* 82195254h case    5:*/		return 0x821958E4;
		/* 82195254h case    5:*/		return 0x82195258;
		  /* 82195258h */ case    6:  		/* lwz R11, <#[R25 + 36]> */
		/* 82195258h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000024) );
		/* 82195258h case    6:*/		return 0x8219525C;
		  /* 8219525Ch */ case    7:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8219525Ch case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8219525Ch case    7:*/		return 0x82195260;
		  /* 82195260h */ case    8:  		/* bc 12, CR0_EQ, 40 */
		/* 82195260h case    8:*/		if ( regs.CR[0].eq ) { return 0x82195288;  }
		/* 82195260h case    8:*/		return 0x82195264;
		  /* 82195264h */ case    9:  		/* lwz R11, <#[R25 + 28]> */
		/* 82195264h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000001C) );
		/* 82195264h case    9:*/		return 0x82195268;
		  /* 82195268h */ case   10:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82195268h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82195268h case   10:*/		return 0x8219526C;
		  /* 8219526Ch */ case   11:  		/* bc 12, CR0_EQ, 16 */
		/* 8219526Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x8219527C;  }
		/* 8219526Ch case   11:*/		return 0x82195270;
		  /* 82195270h */ case   12:  		/* lwz R10, <#[R25 + 20]> */
		/* 82195270h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000014) );
		/* 82195270h case   12:*/		return 0x82195274;
		  /* 82195274h */ case   13:  		/* addi R11, R25, 16 */
		/* 82195274h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R25,0x10);
		/* 82195274h case   13:*/		return 0x82195278;
		  /* 82195278h */ case   14:  		/* b 24 */
		/* 82195278h case   14:*/		return 0x82195290;
		/* 82195278h case   14:*/		return 0x8219527C;
	}
	return 0x8219527C;
} // Block from 82195240h-8219527Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8219527Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219527C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219527C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219527C);
		  /* 8219527Ch */ case    0:  		/* lwz R10, <#[R25 + 28]> */
		/* 8219527Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x0000001C) );
		/* 8219527Ch case    0:*/		return 0x82195280;
		  /* 82195280h */ case    1:  		/* addi R11, R25, 24 */
		/* 82195280h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R25,0x18);
		/* 82195280h case    1:*/		return 0x82195284;
		  /* 82195284h */ case    2:  		/* b 12 */
		/* 82195284h case    2:*/		return 0x82195290;
		/* 82195284h case    2:*/		return 0x82195288;
	}
	return 0x82195288;
} // Block from 8219527Ch-82195288h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82195288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195288);
		  /* 82195288h */ case    0:  		/* lwz R10, <#[R25 + 36]> */
		/* 82195288h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000024) );
		/* 82195288h case    0:*/		return 0x8219528C;
		  /* 8219528Ch */ case    1:  		/* addi R11, R25, 32 */
		/* 8219528Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R25,0x20);
		/* 8219528Ch case    1:*/		return 0x82195290;
	}
	return 0x82195290;
} // Block from 82195288h-82195290h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82195290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195290);
		  /* 82195290h */ case    0:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82195290h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82195290h case    0:*/		return 0x82195294;
		  /* 82195294h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82195294h case    1:*/		if ( regs.CR[0].eq ) { return 0x821952A0;  }
		/* 82195294h case    1:*/		return 0x82195298;
		  /* 82195298h */ case    2:  		/* li R27, 0 */
		/* 82195298h case    2:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82195298h case    2:*/		return 0x8219529C;
		  /* 8219529Ch */ case    3:  		/* b 16 */
		/* 8219529Ch case    3:*/		return 0x821952AC;
		/* 8219529Ch case    3:*/		return 0x821952A0;
	}
	return 0x821952A0;
} // Block from 82195290h-821952A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821952A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821952A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821952A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821952A0);
		  /* 821952A0h */ case    0:  		/* lwz R10, <#[R11]> */
		/* 821952A0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821952A0h case    0:*/		return 0x821952A4;
		  /* 821952A4h */ case    1:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821952A4h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821952A4h case    1:*/		return 0x821952A8;
		  /* 821952A8h */ case    2:  		/* addi R27, R10, -40 */
		/* 821952A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R10,0xFFFFFFD8);
		/* 821952A8h case    2:*/		return 0x821952AC;
	}
	return 0x821952AC;
} // Block from 821952A0h-821952ACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821952ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821952AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821952AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821952AC);
		  /* 821952ACh */ case    0:  		/* mr R24, R11 */
		/* 821952ACh case    0:*/		regs.R24 = regs.R11;
		/* 821952ACh case    0:*/		return 0x821952B0;
		  /* 821952B0h */ case    1:  		/* b 1564 */
		/* 821952B0h case    1:*/		return 0x821958CC;
		/* 821952B0h case    1:*/		return 0x821952B4;
		  /* 821952B4h */ case    2:  		/* lwz R11, <#[R27 + 8]> */
		/* 821952B4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 821952B4h case    2:*/		return 0x821952B8;
		  /* 821952B8h */ case    3:  		/* li R28, 0 */
		/* 821952B8h case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 821952B8h case    3:*/		return 0x821952BC;
		  /* 821952BCh */ case    4:  		/* li R26, 0 */
		/* 821952BCh case    4:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 821952BCh case    4:*/		return 0x821952C0;
		  /* 821952C0h */ case    5:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821952C0h case    5:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821952C0h case    5:*/		return 0x821952C4;
		  /* 821952C4h */ case    6:  		/* li R29, 0 */
		/* 821952C4h case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821952C4h case    6:*/		return 0x821952C8;
		  /* 821952C8h */ case    7:  		/* cmplwi CR6, R11, 100 */
		/* 821952C8h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000064);
		/* 821952C8h case    7:*/		return 0x821952CC;
		  /* 821952CCh */ case    8:  		/* bc 12, CR6_EQ, 276 */
		/* 821952CCh case    8:*/		if ( regs.CR[6].eq ) { return 0x821953E0;  }
		/* 821952CCh case    8:*/		return 0x821952D0;
		  /* 821952D0h */ case    9:  		/* cmplwi CR6, R11, 97 */
		/* 821952D0h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000061);
		/* 821952D0h case    9:*/		return 0x821952D4;
		  /* 821952D4h */ case   10:  		/* bc 12, CR6_EQ, 16 */
		/* 821952D4h case   10:*/		if ( regs.CR[6].eq ) { return 0x821952E4;  }
		/* 821952D4h case   10:*/		return 0x821952D8;
		  /* 821952D8h */ case   11:  		/* cmplwi CR6, R11, 99 */
		/* 821952D8h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000063);
		/* 821952D8h case   11:*/		return 0x821952DC;
		  /* 821952DCh */ case   12:  		/* li R10, 0 */
		/* 821952DCh case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821952DCh case   12:*/		return 0x821952E0;
		  /* 821952E0h */ case   13:  		/* bc 4, CR6_EQ, 8 */
		/* 821952E0h case   13:*/		if ( !regs.CR[6].eq ) { return 0x821952E8;  }
		/* 821952E0h case   13:*/		return 0x821952E4;
	}
	return 0x821952E4;
} // Block from 821952ACh-821952E4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821952E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821952E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821952E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821952E4);
		  /* 821952E4h */ case    0:  		/* mr R10, R17 */
		/* 821952E4h case    0:*/		regs.R10 = regs.R17;
		/* 821952E4h case    0:*/		return 0x821952E8;
	}
	return 0x821952E8;
} // Block from 821952E4h-821952E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821952E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821952E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821952E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821952E8);
		  /* 821952E8h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 821952E8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 821952E8h case    0:*/		return 0x821952EC;
		  /* 821952ECh */ case    1:  		/* bc 12, CR0_EQ, 80 */
		/* 821952ECh case    1:*/		if ( regs.CR[0].eq ) { return 0x8219533C;  }
		/* 821952ECh case    1:*/		return 0x821952F0;
		  /* 821952F0h */ case    2:  		/* lwz R11, <#[R27 + 8]> */
		/* 821952F0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 821952F0h case    2:*/		return 0x821952F4;
		  /* 821952F4h */ case    3:  		/* mr R3, R18 */
		/* 821952F4h case    3:*/		regs.R3 = regs.R18;
		/* 821952F4h case    3:*/		return 0x821952F8;
		  /* 821952F8h */ case    4:  		/* mr R29, R17 */
		/* 821952F8h case    4:*/		regs.R29 = regs.R17;
		/* 821952F8h case    4:*/		return 0x821952FC;
		  /* 821952FCh */ case    5:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821952FCh case    5:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821952FCh case    5:*/		return 0x82195300;
		  /* 82195300h */ case    6:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 82195300h case    6:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 82195300h case    6:*/		return 0x82195304;
		  /* 82195304h */ case    7:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 82195304h case    7:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 82195304h case    7:*/		return 0x82195308;
		  /* 82195308h */ case    8:  		/* bl -200408 */
		/* 82195308h case    8:*/		regs.LR = 0x8219530C; return 0x82164430;
		/* 82195308h case    8:*/		return 0x8219530C;
		  /* 8219530Ch */ case    9:  		/* addi R11, R27, -24 */
		/* 8219530Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0xFFFFFFE8);
		/* 8219530Ch case    9:*/		return 0x82195310;
		  /* 82195310h */ case   10:  		/* add R11, R3, R11 */
		/* 82195310h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 82195310h case   10:*/		return 0x82195314;
		  /* 82195314h */ case   11:  		/* lwz R10, <#[R11 + 4]> */
		/* 82195314h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82195314h case   11:*/		return 0x82195318;
		  /* 82195318h */ case   12:  		/* rlwinm. R10, R10, 0, 3, 3 */
		/* 82195318h case   12:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R10,regs.R10);
		/* 82195318h case   12:*/		return 0x8219531C;
		  /* 8219531Ch */ case   13:  		/* bc 12, CR0_EQ, 20 */
		/* 8219531Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x82195330;  }
		/* 8219531Ch case   13:*/		return 0x82195320;
		  /* 82195320h */ case   14:  		/* lwz R11, <#[R11 + 8]> */
		/* 82195320h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82195320h case   14:*/		return 0x82195324;
		  /* 82195324h */ case   15:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82195324h case   15:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82195324h case   15:*/		return 0x82195328;
		  /* 82195328h */ case   16:  		/* mr R11, R17 */
		/* 82195328h case   16:*/		regs.R11 = regs.R17;
		/* 82195328h case   16:*/		return 0x8219532C;
		  /* 8219532Ch */ case   17:  		/* bc 12, CR0_EQ, 8 */
		/* 8219532Ch case   17:*/		if ( regs.CR[0].eq ) { return 0x82195334;  }
		/* 8219532Ch case   17:*/		return 0x82195330;
	}
	return 0x82195330;
} // Block from 821952E8h-82195330h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82195330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195330);
		  /* 82195330h */ case    0:  		/* li R11, 0 */
		/* 82195330h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82195330h case    0:*/		return 0x82195334;
	}
	return 0x82195334;
} // Block from 82195330h-82195334h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82195334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195334);
		  /* 82195334h */ case    0:  		/* rlwinm R26, R11, 0, 24, 31 */
		/* 82195334h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R26,regs.R11);
		/* 82195334h case    0:*/		return 0x82195338;
		  /* 82195338h */ case    1:  		/* b 176 */
		/* 82195338h case    1:*/		return 0x821953E8;
		/* 82195338h case    1:*/		return 0x8219533C;
	}
	return 0x8219533C;
} // Block from 82195334h-8219533Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219533Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219533C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219533C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219533C);
		  /* 8219533Ch */ case    0:  		/* cmplwi CR6, R11, 98 */
		/* 8219533Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000062);
		/* 8219533Ch case    0:*/		return 0x82195340;
		  /* 82195340h */ case    1:  		/* bc 4, CR6_EQ, 168 */
		/* 82195340h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821953E8;  }
		/* 82195340h case    1:*/		return 0x82195344;
		  /* 82195344h */ case    2:  		/* lwz R30, <#[R27 + 4]> */
		/* 82195344h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x00000004) );
		/* 82195344h case    2:*/		return 0x82195348;
		  /* 82195348h */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 82195348h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82195348h case    3:*/		return 0x8219534C;
		  /* 8219534Ch */ case    4:  		/* bc 12, CR6_EQ, 156 */
		/* 8219534Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x821953E8;  }
		/* 8219534Ch case    4:*/		return 0x82195350;
		  /* 82195350h */ case    5:  		/* lwz R31, <#[R30 + 16]> */
		/* 82195350h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000010) );
		/* 82195350h case    5:*/		return 0x82195354;
		  /* 82195354h */ case    6:  		/* cmplwi CR6, R31, 0 */
		/* 82195354h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82195354h case    6:*/		return 0x82195358;
		  /* 82195358h */ case    7:  		/* bc 12, CR6_EQ, 128 */
		/* 82195358h case    7:*/		if ( regs.CR[6].eq ) { return 0x821953D8;  }
		/* 82195358h case    7:*/		return 0x8219535C;
		  /* 8219535Ch */ case    8:  		/* lwz R11, <#[R30]> */
		/* 8219535Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8219535Ch case    8:*/		return 0x82195360;
		  /* 82195360h */ case    9:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 82195360h case    9:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 82195360h case    9:*/		return 0x82195364;
		  /* 82195364h */ case   10:  		/* bc 4, CR0_EQ, 16 */
		/* 82195364h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82195374;  }
		/* 82195364h case   10:*/		return 0x82195368;
		  /* 82195368h */ case   11:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82195368h case   11:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82195368h case   11:*/		return 0x8219536C;
		  /* 8219536Ch */ case   12:  		/* li R11, 0 */
		/* 8219536Ch case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219536Ch case   12:*/		return 0x82195370;
		  /* 82195370h */ case   13:  		/* bc 12, CR0_EQ, 8 */
		/* 82195370h case   13:*/		if ( regs.CR[0].eq ) { return 0x82195378;  }
		/* 82195370h case   13:*/		return 0x82195374;
	}
	return 0x82195374;
} // Block from 8219533Ch-82195374h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82195374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195374);
		  /* 82195374h */ case    0:  		/* mr R11, R17 */
		/* 82195374h case    0:*/		regs.R11 = regs.R17;
		/* 82195374h case    0:*/		return 0x82195378;
	}
	return 0x82195378;
} // Block from 82195374h-82195378h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82195378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195378);
		  /* 82195378h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82195378h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82195378h case    0:*/		return 0x8219537C;
		  /* 8219537Ch */ case    1:  		/* bc 12, CR0_EQ, 92 */
		/* 8219537Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821953D8;  }
		/* 8219537Ch case    1:*/		return 0x82195380;
		  /* 82195380h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 82195380h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82195380h case    2:*/		return 0x82195384;
		  /* 82195384h */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82195384h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82195384h case    3:*/		return 0x82195388;
		  /* 82195388h */ case    4:  		/* cmplwi CR6, R11, 97 */
		/* 82195388h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000061);
		/* 82195388h case    4:*/		return 0x8219538C;
		  /* 8219538Ch */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 8219538Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x821953A4;  }
		/* 8219538Ch case    5:*/		return 0x82195390;
		  /* 82195390h */ case    6:  		/* cmplwi CR6, R11, 99 */
		/* 82195390h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000063);
		/* 82195390h case    6:*/		return 0x82195394;
		  /* 82195394h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 82195394h case    7:*/		if ( regs.CR[6].eq ) { return 0x821953A4;  }
		/* 82195394h case    7:*/		return 0x82195398;
		  /* 82195398h */ case    8:  		/* cmplwi CR6, R11, 100 */
		/* 82195398h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000064);
		/* 82195398h case    8:*/		return 0x8219539C;
		  /* 8219539Ch */ case    9:  		/* li R11, 0 */
		/* 8219539Ch case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219539Ch case    9:*/		return 0x821953A0;
		  /* 821953A0h */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 821953A0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x821953A8;  }
		/* 821953A0h case   10:*/		return 0x821953A4;
	}
	return 0x821953A4;
} // Block from 82195378h-821953A4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821953A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821953A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821953A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821953A4);
		  /* 821953A4h */ case    0:  		/* mr R11, R17 */
		/* 821953A4h case    0:*/		regs.R11 = regs.R17;
		/* 821953A4h case    0:*/		return 0x821953A8;
	}
	return 0x821953A8;
} // Block from 821953A4h-821953A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821953A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821953A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821953A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821953A8);
		  /* 821953A8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821953A8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821953A8h case    0:*/		return 0x821953AC;
		  /* 821953ACh */ case    1:  		/* bc 12, CR0_EQ, 52 */
		/* 821953ACh case    1:*/		if ( regs.CR[0].eq ) { return 0x821953E0;  }
		/* 821953ACh case    1:*/		return 0x821953B0;
		  /* 821953B0h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 821953B0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821953B0h case    2:*/		return 0x821953B4;
		  /* 821953B4h */ case    3:  		/* mr R3, R18 */
		/* 821953B4h case    3:*/		regs.R3 = regs.R18;
		/* 821953B4h case    3:*/		return 0x821953B8;
		  /* 821953B8h */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821953B8h case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821953B8h case    4:*/		return 0x821953BC;
		  /* 821953BCh */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821953BCh case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821953BCh case    5:*/		return 0x821953C0;
		  /* 821953C0h */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821953C0h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821953C0h case    6:*/		return 0x821953C4;
		  /* 821953C4h */ case    7:  		/* bl -200596 */
		/* 821953C4h case    7:*/		regs.LR = 0x821953C8; return 0x82164430;
		/* 821953C4h case    7:*/		return 0x821953C8;
		  /* 821953C8h */ case    8:  		/* addi R11, R31, -20 */
		/* 821953C8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFEC);
		/* 821953C8h case    8:*/		return 0x821953CC;
		  /* 821953CCh */ case    9:  		/* lwzx R11, <#[R3 + R11]> */
		/* 821953CCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 821953CCh case    9:*/		return 0x821953D0;
		  /* 821953D0h */ case   10:  		/* rlwinm. R11, R11, 0, 11, 13 */
		/* 821953D0h case   10:*/		cpu::op::rlwinm<1,0,11,13>(regs,&regs.R11,regs.R11);
		/* 821953D0h case   10:*/		return 0x821953D4;
		  /* 821953D4h */ case   11:  		/* bc 4, CR0_EQ, 12 */
		/* 821953D4h case   11:*/		if ( !regs.CR[0].eq ) { return 0x821953E0;  }
		/* 821953D4h case   11:*/		return 0x821953D8;
	}
	return 0x821953D8;
} // Block from 821953A8h-821953D8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821953D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821953D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821953D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821953D8);
		  /* 821953D8h */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 821953D8h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 821953D8h case    0:*/		return 0x821953DC;
		  /* 821953DCh */ case    1:  		/* b -148 */
		/* 821953DCh case    1:*/		return 0x82195348;
		/* 821953DCh case    1:*/		return 0x821953E0;
	}
	return 0x821953E0;
} // Block from 821953D8h-821953E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821953E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821953E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821953E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821953E0);
		  /* 821953E0h */ case    0:  		/* mr R26, R17 */
		/* 821953E0h case    0:*/		regs.R26 = regs.R17;
		/* 821953E0h case    0:*/		return 0x821953E4;
		  /* 821953E4h */ case    1:  		/* mr R29, R17 */
		/* 821953E4h case    1:*/		regs.R29 = regs.R17;
		/* 821953E4h case    1:*/		return 0x821953E8;
	}
	return 0x821953E8;
} // Block from 821953E0h-821953E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821953E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821953E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821953E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821953E8);
		  /* 821953E8h */ case    0:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 821953E8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 821953E8h case    0:*/		return 0x821953EC;
		  /* 821953ECh */ case    1:  		/* bc 12, CR0_EQ, 228 */
		/* 821953ECh case    1:*/		if ( regs.CR[0].eq ) { return 0x821954D0;  }
		/* 821953ECh case    1:*/		return 0x821953F0;
		  /* 821953F0h */ case    2:  		/* lwz R9, <#[R27]> */
		/* 821953F0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000000) );
		/* 821953F0h case    2:*/		return 0x821953F4;
		  /* 821953F4h */ case    3:  		/* mr R28, R17 */
		/* 821953F4h case    3:*/		regs.R28 = regs.R17;
		/* 821953F4h case    3:*/		return 0x821953F8;
		  /* 821953F8h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 821953F8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821953F8h case    4:*/		return 0x821953FC;
		  /* 821953FCh */ case    5:  		/* bc 12, CR6_EQ, 212 */
		/* 821953FCh case    5:*/		if ( regs.CR[6].eq ) { return 0x821954D0;  }
		/* 821953FCh case    5:*/		return 0x82195400;
		  /* 82195400h */ case    6:  		/* lwz R11, <#[R9]> */
		/* 82195400h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 82195400h case    6:*/		return 0x82195404;
		  /* 82195404h */ case    7:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 82195404h case    7:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 82195404h case    7:*/		return 0x82195408;
		  /* 82195408h */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 82195408h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82195418;  }
		/* 82195408h case    8:*/		return 0x8219540C;
		  /* 8219540Ch */ case    9:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 8219540Ch case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 8219540Ch case    9:*/		return 0x82195410;
		  /* 82195410h */ case   10:  		/* li R11, 0 */
		/* 82195410h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82195410h case   10:*/		return 0x82195414;
		  /* 82195414h */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 82195414h case   11:*/		if ( regs.CR[0].eq ) { return 0x8219541C;  }
		/* 82195414h case   11:*/		return 0x82195418;
	}
	return 0x82195418;
} // Block from 821953E8h-82195418h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82195418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195418);
		  /* 82195418h */ case    0:  		/* mr R11, R17 */
		/* 82195418h case    0:*/		regs.R11 = regs.R17;
		/* 82195418h case    0:*/		return 0x8219541C;
	}
	return 0x8219541C;
} // Block from 82195418h-8219541Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219541Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219541C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219541C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219541C);
		  /* 8219541Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219541Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219541Ch case    0:*/		return 0x82195420;
		  /* 82195420h */ case    1:  		/* bc 12, CR0_EQ, 168 */
		/* 82195420h case    1:*/		if ( regs.CR[0].eq ) { return 0x821954C8;  }
		/* 82195420h case    1:*/		return 0x82195424;
		  /* 82195424h */ case    2:  		/* lwz R11, <#[R9 + 12]> */
		/* 82195424h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 82195424h case    2:*/		return 0x82195428;
		  /* 82195428h */ case    3:  		/* lwz R10, <#[R11 + 20]> */
		/* 82195428h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 82195428h case    3:*/		return 0x8219542C;
		  /* 8219542Ch */ case    4:  		/* rlwinm. R8, R10, 0, 4, 4 */
		/* 8219542Ch case    4:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R8,regs.R10);
		/* 8219542Ch case    4:*/		return 0x82195430;
		  /* 82195430h */ case    5:  		/* bc 4, CR0_EQ, 68 */
		/* 82195430h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82195474;  }
		/* 82195430h case    5:*/		return 0x82195434;
		  /* 82195434h */ case    6:  		/* lwz R8, <#[R11 + 28]> */
		/* 82195434h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000001C) );
		/* 82195434h case    6:*/		return 0x82195438;
		  /* 82195438h */ case    7:  		/* oris R10, R10, 2048 */
		/* 82195438h case    7:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x800);
		/* 82195438h case    7:*/		return 0x8219543C;
		  /* 8219543Ch */ case    8:  		/* cmplw CR6, R8, R25 */
		/* 8219543Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R25);
		/* 8219543Ch case    8:*/		return 0x82195440;
		  /* 82195440h */ case    9:  		/* stw R10, <#[R11 + 20]> */
		/* 82195440h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 82195440h case    9:*/		return 0x82195444;
		  /* 82195444h */ case   10:  		/* bc 12, CR6_EQ, 48 */
		/* 82195444h case   10:*/		if ( regs.CR[6].eq ) { return 0x82195474;  }
		/* 82195444h case   10:*/		return 0x82195448;
		  /* 82195448h */ case   11:  		/* lwz R10, <#[R11 + 8]> */
		/* 82195448h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82195448h case   11:*/		return 0x8219544C;
		  /* 8219544Ch */ case   12:  		/* rlwinm R10, R10, 25, 25, 31 */
		/* 8219544Ch case   12:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R10);
		/* 8219544Ch case   12:*/		return 0x82195450;
		  /* 82195450h */ case   13:  		/* cmplwi CR6, R10, 125 */
		/* 82195450h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007D);
		/* 82195450h case   13:*/		return 0x82195454;
		  /* 82195454h */ case   14:  		/* bc 12, CR6_EQ, 16 */
		/* 82195454h case   14:*/		if ( regs.CR[6].eq ) { return 0x82195464;  }
		/* 82195454h case   14:*/		return 0x82195458;
		  /* 82195458h */ case   15:  		/* cmplwi CR6, R10, 124 */
		/* 82195458h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007C);
		/* 82195458h case   15:*/		return 0x8219545C;
		  /* 8219545Ch */ case   16:  		/* li R10, 0 */
		/* 8219545Ch case   16:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8219545Ch case   16:*/		return 0x82195460;
		  /* 82195460h */ case   17:  		/* bc 4, CR6_EQ, 8 */
		/* 82195460h case   17:*/		if ( !regs.CR[6].eq ) { return 0x82195468;  }
		/* 82195460h case   17:*/		return 0x82195464;
	}
	return 0x82195464;
} // Block from 8219541Ch-82195464h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82195464h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195464);
		  /* 82195464h */ case    0:  		/* mr R10, R17 */
		/* 82195464h case    0:*/		regs.R10 = regs.R17;
		/* 82195464h case    0:*/		return 0x82195468;
	}
	return 0x82195468;
} // Block from 82195464h-82195468h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82195468h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195468);
		  /* 82195468h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82195468h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82195468h case    0:*/		return 0x8219546C;
		  /* 8219546Ch */ case    1:  		/* bc 4, CR0_EQ, 8 */
		/* 8219546Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x82195474;  }
		/* 8219546Ch case    1:*/		return 0x82195470;
		  /* 82195470h */ case    2:  		/* mr R23, R17 */
		/* 82195470h case    2:*/		regs.R23 = regs.R17;
		/* 82195470h case    2:*/		return 0x82195474;
	}
	return 0x82195474;
} // Block from 82195468h-82195474h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82195474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195474);
		  /* 82195474h */ case    0:  		/* rlwinm. R10, R26, 0, 24, 31 */
		/* 82195474h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R26);
		/* 82195474h case    0:*/		return 0x82195478;
		  /* 82195478h */ case    1:  		/* bc 12, CR0_EQ, 80 */
		/* 82195478h case    1:*/		if ( regs.CR[0].eq ) { return 0x821954C8;  }
		/* 82195478h case    1:*/		return 0x8219547C;
		  /* 8219547Ch */ case    2:  		/* lwz R10, <#[R11 + 20]> */
		/* 8219547Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 8219547Ch case    2:*/		return 0x82195480;
		  /* 82195480h */ case    3:  		/* rlwinm. R8, R10, 0, 3, 3 */
		/* 82195480h case    3:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R8,regs.R10);
		/* 82195480h case    3:*/		return 0x82195484;
		  /* 82195484h */ case    4:  		/* bc 4, CR0_EQ, 68 */
		/* 82195484h case    4:*/		if ( !regs.CR[0].eq ) { return 0x821954C8;  }
		/* 82195484h case    4:*/		return 0x82195488;
		  /* 82195488h */ case    5:  		/* lwz R8, <#[R11 + 28]> */
		/* 82195488h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000001C) );
		/* 82195488h case    5:*/		return 0x8219548C;
		  /* 8219548Ch */ case    6:  		/* oris R10, R10, 4096 */
		/* 8219548Ch case    6:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x1000);
		/* 8219548Ch case    6:*/		return 0x82195490;
		  /* 82195490h */ case    7:  		/* cmplw CR6, R8, R25 */
		/* 82195490h case    7:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R25);
		/* 82195490h case    7:*/		return 0x82195494;
		  /* 82195494h */ case    8:  		/* stw R10, <#[R11 + 20]> */
		/* 82195494h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 82195494h case    8:*/		return 0x82195498;
		  /* 82195498h */ case    9:  		/* bc 12, CR6_EQ, 48 */
		/* 82195498h case    9:*/		if ( regs.CR[6].eq ) { return 0x821954C8;  }
		/* 82195498h case    9:*/		return 0x8219549C;
		  /* 8219549Ch */ case   10:  		/* lwz R11, <#[R11 + 8]> */
		/* 8219549Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8219549Ch case   10:*/		return 0x821954A0;
		  /* 821954A0h */ case   11:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821954A0h case   11:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821954A0h case   11:*/		return 0x821954A4;
		  /* 821954A4h */ case   12:  		/* cmplwi CR6, R11, 125 */
		/* 821954A4h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821954A4h case   12:*/		return 0x821954A8;
		  /* 821954A8h */ case   13:  		/* bc 12, CR6_EQ, 16 */
		/* 821954A8h case   13:*/		if ( regs.CR[6].eq ) { return 0x821954B8;  }
		/* 821954A8h case   13:*/		return 0x821954AC;
		  /* 821954ACh */ case   14:  		/* cmplwi CR6, R11, 124 */
		/* 821954ACh case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821954ACh case   14:*/		return 0x821954B0;
		  /* 821954B0h */ case   15:  		/* li R11, 0 */
		/* 821954B0h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821954B0h case   15:*/		return 0x821954B4;
		  /* 821954B4h */ case   16:  		/* bc 4, CR6_EQ, 8 */
		/* 821954B4h case   16:*/		if ( !regs.CR[6].eq ) { return 0x821954BC;  }
		/* 821954B4h case   16:*/		return 0x821954B8;
	}
	return 0x821954B8;
} // Block from 82195474h-821954B8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821954B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821954B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821954B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821954B8);
		  /* 821954B8h */ case    0:  		/* mr R11, R17 */
		/* 821954B8h case    0:*/		regs.R11 = regs.R17;
		/* 821954B8h case    0:*/		return 0x821954BC;
	}
	return 0x821954BC;
} // Block from 821954B8h-821954BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821954BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821954BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821954BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821954BC);
		  /* 821954BCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821954BCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821954BCh case    0:*/		return 0x821954C0;
		  /* 821954C0h */ case    1:  		/* bc 4, CR0_EQ, 8 */
		/* 821954C0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821954C8;  }
		/* 821954C0h case    1:*/		return 0x821954C4;
		  /* 821954C4h */ case    2:  		/* mr R23, R17 */
		/* 821954C4h case    2:*/		regs.R23 = regs.R17;
		/* 821954C4h case    2:*/		return 0x821954C8;
	}
	return 0x821954C8;
} // Block from 821954BCh-821954C8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821954C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821954C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821954C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821954C8);
		  /* 821954C8h */ case    0:  		/* lwz R9, <#[R9 + 4]> */
		/* 821954C8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 821954C8h case    0:*/		return 0x821954CC;
		  /* 821954CCh */ case    1:  		/* b -212 */
		/* 821954CCh case    1:*/		return 0x821953F8;
		/* 821954CCh case    1:*/		return 0x821954D0;
	}
	return 0x821954D0;
} // Block from 821954C8h-821954D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821954D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821954D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821954D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821954D0);
		  /* 821954D0h */ case    0:  		/* lwz R9, <#[R27 + 20]> */
		/* 821954D0h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000014) );
		/* 821954D0h case    0:*/		return 0x821954D4;
		  /* 821954D4h */ case    1:  		/* rlwinm. R11, R9, 0, 4, 4 */
		/* 821954D4h case    1:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R11,regs.R9);
		/* 821954D4h case    1:*/		return 0x821954D8;
		  /* 821954D8h */ case    2:  		/* bc 12, CR0_EQ, 356 */
		/* 821954D8h case    2:*/		if ( regs.CR[0].eq ) { return 0x8219563C;  }
		/* 821954D8h case    2:*/		return 0x821954DC;
		  /* 821954DCh */ case    3:  		/* lwz R11, <#[R27 + 8]> */
		/* 821954DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 821954DCh case    3:*/		return 0x821954E0;
		  /* 821954E0h */ case    4:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 821954E0h case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 821954E0h case    4:*/		return 0x821954E4;
		  /* 821954E4h */ case    5:  		/* cmplwi CR6, R10, 1 */
		/* 821954E4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 821954E4h case    5:*/		return 0x821954E8;
		  /* 821954E8h */ case    6:  		/* bc 12, CR6_LT, 16 */
		/* 821954E8h case    6:*/		if ( regs.CR[6].lt ) { return 0x821954F8;  }
		/* 821954E8h case    6:*/		return 0x821954EC;
		  /* 821954ECh */ case    7:  		/* cmplwi CR6, R10, 102 */
		/* 821954ECh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000066);
		/* 821954ECh case    7:*/		return 0x821954F0;
		  /* 821954F0h */ case    8:  		/* mr R11, R17 */
		/* 821954F0h case    8:*/		regs.R11 = regs.R17;
		/* 821954F0h case    8:*/		return 0x821954F4;
		  /* 821954F4h */ case    9:  		/* bc 4, CR6_GT, 8 */
		/* 821954F4h case    9:*/		if ( !regs.CR[6].gt ) { return 0x821954FC;  }
		/* 821954F4h case    9:*/		return 0x821954F8;
	}
	return 0x821954F8;
} // Block from 821954D0h-821954F8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821954F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821954F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821954F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821954F8);
		  /* 821954F8h */ case    0:  		/* li R11, 0 */
		/* 821954F8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821954F8h case    0:*/		return 0x821954FC;
	}
	return 0x821954FC;
} // Block from 821954F8h-821954FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821954FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821954FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821954FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821954FC);
		  /* 821954FCh */ case    0:  		/* rlwinm. R9, R9, 0, 3, 3 */
		/* 821954FCh case    0:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R9,regs.R9);
		/* 821954FCh case    0:*/		return 0x82195500;
		  /* 82195500h */ case    1:  		/* rlwinm R28, R11, 0, 24, 31 */
		/* 82195500h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R28,regs.R11);
		/* 82195500h case    1:*/		return 0x82195504;
		  /* 82195504h */ case    2:  		/* bc 12, CR0_EQ, 88 */
		/* 82195504h case    2:*/		if ( regs.CR[0].eq ) { return 0x8219555C;  }
		/* 82195504h case    2:*/		return 0x82195508;
		  /* 82195508h */ case    3:  		/* cmplwi CR6, R10, 97 */
		/* 82195508h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000061);
		/* 82195508h case    3:*/		return 0x8219550C;
		  /* 8219550Ch */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 8219550Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82195524;  }
		/* 8219550Ch case    4:*/		return 0x82195510;
		  /* 82195510h */ case    5:  		/* cmplwi CR6, R10, 99 */
		/* 82195510h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000063);
		/* 82195510h case    5:*/		return 0x82195514;
		  /* 82195514h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 82195514h case    6:*/		if ( regs.CR[6].eq ) { return 0x82195524;  }
		/* 82195514h case    6:*/		return 0x82195518;
		  /* 82195518h */ case    7:  		/* cmplwi CR6, R10, 100 */
		/* 82195518h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000064);
		/* 82195518h case    7:*/		return 0x8219551C;
		  /* 8219551Ch */ case    8:  		/* li R11, 0 */
		/* 8219551Ch case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219551Ch case    8:*/		return 0x82195520;
		  /* 82195520h */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 82195520h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82195528;  }
		/* 82195520h case    9:*/		return 0x82195524;
	}
	return 0x82195524;
} // Block from 821954FCh-82195524h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82195524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195524);
		  /* 82195524h */ case    0:  		/* mr R11, R17 */
		/* 82195524h case    0:*/		regs.R11 = regs.R17;
		/* 82195524h case    0:*/		return 0x82195528;
	}
	return 0x82195528;
} // Block from 82195524h-82195528h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82195528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195528);
		  /* 82195528h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82195528h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82195528h case    0:*/		return 0x8219552C;
		  /* 8219552Ch */ case    1:  		/* bc 12, CR0_EQ, 48 */
		/* 8219552Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8219555C;  }
		/* 8219552Ch case    1:*/		return 0x82195530;
		  /* 82195530h */ case    2:  		/* lwz R11, <#[R27 + 8]> */
		/* 82195530h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 82195530h case    2:*/		return 0x82195534;
		  /* 82195534h */ case    3:  		/* mr R3, R18 */
		/* 82195534h case    3:*/		regs.R3 = regs.R18;
		/* 82195534h case    3:*/		return 0x82195538;
		  /* 82195538h */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 82195538h case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 82195538h case    4:*/		return 0x8219553C;
		  /* 8219553Ch */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8219553Ch case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8219553Ch case    5:*/		return 0x82195540;
		  /* 82195540h */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 82195540h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 82195540h case    6:*/		return 0x82195544;
		  /* 82195544h */ case    7:  		/* bl -200980 */
		/* 82195544h case    7:*/		regs.LR = 0x82195548; return 0x82164430;
		/* 82195544h case    7:*/		return 0x82195548;
		  /* 82195548h */ case    8:  		/* addi R11, R27, -24 */
		/* 82195548h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0xFFFFFFE8);
		/* 82195548h case    8:*/		return 0x8219554C;
		  /* 8219554Ch */ case    9:  		/* add R11, R3, R11 */
		/* 8219554Ch case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 8219554Ch case    9:*/		return 0x82195550;
		  /* 82195550h */ case   10:  		/* lwz R10, <#[R11]> */
		/* 82195550h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82195550h case   10:*/		return 0x82195554;
		  /* 82195554h */ case   11:  		/* rlwinm R10, R10, 0, 13, 11 */
		/* 82195554h case   11:*/		cpu::op::rlwinm<0,0,13,11>(regs,&regs.R10,regs.R10);
		/* 82195554h case   11:*/		return 0x82195558;
		  /* 82195558h */ case   12:  		/* stw R10, <#[R11]> */
		/* 82195558h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82195558h case   12:*/		return 0x8219555C;
	}
	return 0x8219555C;
} // Block from 82195528h-8219555Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219555Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219555C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219555C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219555C);
		  /* 8219555Ch */ case    0:  		/* lwz R9, <#[R27]> */
		/* 8219555Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000000) );
		/* 8219555Ch case    0:*/		return 0x82195560;
		  /* 82195560h */ case    1:  		/* cmplwi CR6, R9, 0 */
		/* 82195560h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82195560h case    1:*/		return 0x82195564;
		  /* 82195564h */ case    2:  		/* bc 12, CR6_EQ, 216 */
		/* 82195564h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219563C;  }
		/* 82195564h case    2:*/		return 0x82195568;
		  /* 82195568h */ case    3:  		/* lwz R11, <#[R9]> */
		/* 82195568h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 82195568h case    3:*/		return 0x8219556C;
		  /* 8219556Ch */ case    4:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 8219556Ch case    4:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 8219556Ch case    4:*/		return 0x82195570;
		  /* 82195570h */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 82195570h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82195580;  }
		/* 82195570h case    5:*/		return 0x82195574;
		  /* 82195574h */ case    6:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82195574h case    6:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82195574h case    6:*/		return 0x82195578;
		  /* 82195578h */ case    7:  		/* li R11, 0 */
		/* 82195578h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82195578h case    7:*/		return 0x8219557C;
		  /* 8219557Ch */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 8219557Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x82195584;  }
		/* 8219557Ch case    8:*/		return 0x82195580;
	}
	return 0x82195580;
} // Block from 8219555Ch-82195580h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82195580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195580);
		  /* 82195580h */ case    0:  		/* mr R11, R17 */
		/* 82195580h case    0:*/		regs.R11 = regs.R17;
		/* 82195580h case    0:*/		return 0x82195584;
	}
	return 0x82195584;
} // Block from 82195580h-82195584h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82195584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195584);
		  /* 82195584h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82195584h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82195584h case    0:*/		return 0x82195588;
		  /* 82195588h */ case    1:  		/* bc 12, CR0_EQ, 172 */
		/* 82195588h case    1:*/		if ( regs.CR[0].eq ) { return 0x82195634;  }
		/* 82195588h case    1:*/		return 0x8219558C;
		  /* 8219558Ch */ case    2:  		/* lwz R11, <#[R9 + 12]> */
		/* 8219558Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 8219558Ch case    2:*/		return 0x82195590;
		  /* 82195590h */ case    3:  		/* lwz R10, <#[R11 + 20]> */
		/* 82195590h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 82195590h case    3:*/		return 0x82195594;
		  /* 82195594h */ case    4:  		/* rlwinm. R8, R10, 0, 4, 4 */
		/* 82195594h case    4:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R8,regs.R10);
		/* 82195594h case    4:*/		return 0x82195598;
		  /* 82195598h */ case    5:  		/* bc 4, CR0_EQ, 68 */
		/* 82195598h case    5:*/		if ( !regs.CR[0].eq ) { return 0x821955DC;  }
		/* 82195598h case    5:*/		return 0x8219559C;
		  /* 8219559Ch */ case    6:  		/* lwz R8, <#[R11 + 28]> */
		/* 8219559Ch case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000001C) );
		/* 8219559Ch case    6:*/		return 0x821955A0;
		  /* 821955A0h */ case    7:  		/* oris R10, R10, 2048 */
		/* 821955A0h case    7:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x800);
		/* 821955A0h case    7:*/		return 0x821955A4;
		  /* 821955A4h */ case    8:  		/* cmplw CR6, R8, R25 */
		/* 821955A4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R25);
		/* 821955A4h case    8:*/		return 0x821955A8;
		  /* 821955A8h */ case    9:  		/* stw R10, <#[R11 + 20]> */
		/* 821955A8h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 821955A8h case    9:*/		return 0x821955AC;
		  /* 821955ACh */ case   10:  		/* bc 12, CR6_EQ, 48 */
		/* 821955ACh case   10:*/		if ( regs.CR[6].eq ) { return 0x821955DC;  }
		/* 821955ACh case   10:*/		return 0x821955B0;
		  /* 821955B0h */ case   11:  		/* lwz R10, <#[R11 + 8]> */
		/* 821955B0h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821955B0h case   11:*/		return 0x821955B4;
		  /* 821955B4h */ case   12:  		/* rlwinm R10, R10, 25, 25, 31 */
		/* 821955B4h case   12:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R10);
		/* 821955B4h case   12:*/		return 0x821955B8;
		  /* 821955B8h */ case   13:  		/* cmplwi CR6, R10, 125 */
		/* 821955B8h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007D);
		/* 821955B8h case   13:*/		return 0x821955BC;
		  /* 821955BCh */ case   14:  		/* bc 12, CR6_EQ, 16 */
		/* 821955BCh case   14:*/		if ( regs.CR[6].eq ) { return 0x821955CC;  }
		/* 821955BCh case   14:*/		return 0x821955C0;
		  /* 821955C0h */ case   15:  		/* cmplwi CR6, R10, 124 */
		/* 821955C0h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007C);
		/* 821955C0h case   15:*/		return 0x821955C4;
		  /* 821955C4h */ case   16:  		/* li R10, 0 */
		/* 821955C4h case   16:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821955C4h case   16:*/		return 0x821955C8;
		  /* 821955C8h */ case   17:  		/* bc 4, CR6_EQ, 8 */
		/* 821955C8h case   17:*/		if ( !regs.CR[6].eq ) { return 0x821955D0;  }
		/* 821955C8h case   17:*/		return 0x821955CC;
	}
	return 0x821955CC;
} // Block from 82195584h-821955CCh (18 instructions)

//////////////////////////////////////////////////////
// Block at 821955CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821955CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821955CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821955CC);
		  /* 821955CCh */ case    0:  		/* mr R10, R17 */
		/* 821955CCh case    0:*/		regs.R10 = regs.R17;
		/* 821955CCh case    0:*/		return 0x821955D0;
	}
	return 0x821955D0;
} // Block from 821955CCh-821955D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821955D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821955D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821955D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821955D0);
		  /* 821955D0h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 821955D0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 821955D0h case    0:*/		return 0x821955D4;
		  /* 821955D4h */ case    1:  		/* bc 4, CR0_EQ, 8 */
		/* 821955D4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821955DC;  }
		/* 821955D4h case    1:*/		return 0x821955D8;
		  /* 821955D8h */ case    2:  		/* mr R23, R17 */
		/* 821955D8h case    2:*/		regs.R23 = regs.R17;
		/* 821955D8h case    2:*/		return 0x821955DC;
	}
	return 0x821955DC;
} // Block from 821955D0h-821955DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821955DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821955DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821955DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821955DC);
		  /* 821955DCh */ case    0:  		/* lwz R10, <#[R27 + 20]> */
		/* 821955DCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000014) );
		/* 821955DCh case    0:*/		return 0x821955E0;
		  /* 821955E0h */ case    1:  		/* rlwinm. R10, R10, 0, 3, 3 */
		/* 821955E0h case    1:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R10,regs.R10);
		/* 821955E0h case    1:*/		return 0x821955E4;
		  /* 821955E4h */ case    2:  		/* bc 12, CR0_EQ, 80 */
		/* 821955E4h case    2:*/		if ( regs.CR[0].eq ) { return 0x82195634;  }
		/* 821955E4h case    2:*/		return 0x821955E8;
		  /* 821955E8h */ case    3:  		/* lwz R10, <#[R11 + 20]> */
		/* 821955E8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 821955E8h case    3:*/		return 0x821955EC;
		  /* 821955ECh */ case    4:  		/* rlwinm. R8, R10, 0, 3, 3 */
		/* 821955ECh case    4:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R8,regs.R10);
		/* 821955ECh case    4:*/		return 0x821955F0;
		  /* 821955F0h */ case    5:  		/* bc 4, CR0_EQ, 68 */
		/* 821955F0h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82195634;  }
		/* 821955F0h case    5:*/		return 0x821955F4;
		  /* 821955F4h */ case    6:  		/* lwz R8, <#[R11 + 28]> */
		/* 821955F4h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000001C) );
		/* 821955F4h case    6:*/		return 0x821955F8;
		  /* 821955F8h */ case    7:  		/* oris R10, R10, 4096 */
		/* 821955F8h case    7:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x1000);
		/* 821955F8h case    7:*/		return 0x821955FC;
		  /* 821955FCh */ case    8:  		/* cmplw CR6, R8, R25 */
		/* 821955FCh case    8:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R25);
		/* 821955FCh case    8:*/		return 0x82195600;
		  /* 82195600h */ case    9:  		/* stw R10, <#[R11 + 20]> */
		/* 82195600h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 82195600h case    9:*/		return 0x82195604;
		  /* 82195604h */ case   10:  		/* bc 12, CR6_EQ, 48 */
		/* 82195604h case   10:*/		if ( regs.CR[6].eq ) { return 0x82195634;  }
		/* 82195604h case   10:*/		return 0x82195608;
		  /* 82195608h */ case   11:  		/* lwz R11, <#[R11 + 8]> */
		/* 82195608h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82195608h case   11:*/		return 0x8219560C;
		  /* 8219560Ch */ case   12:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219560Ch case   12:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219560Ch case   12:*/		return 0x82195610;
		  /* 82195610h */ case   13:  		/* cmplwi CR6, R11, 125 */
		/* 82195610h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82195610h case   13:*/		return 0x82195614;
		  /* 82195614h */ case   14:  		/* bc 12, CR6_EQ, 16 */
		/* 82195614h case   14:*/		if ( regs.CR[6].eq ) { return 0x82195624;  }
		/* 82195614h case   14:*/		return 0x82195618;
		  /* 82195618h */ case   15:  		/* cmplwi CR6, R11, 124 */
		/* 82195618h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82195618h case   15:*/		return 0x8219561C;
		  /* 8219561Ch */ case   16:  		/* li R11, 0 */
		/* 8219561Ch case   16:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219561Ch case   16:*/		return 0x82195620;
		  /* 82195620h */ case   17:  		/* bc 4, CR6_EQ, 8 */
		/* 82195620h case   17:*/		if ( !regs.CR[6].eq ) { return 0x82195628;  }
		/* 82195620h case   17:*/		return 0x82195624;
	}
	return 0x82195624;
} // Block from 821955DCh-82195624h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82195624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195624);
		  /* 82195624h */ case    0:  		/* mr R11, R17 */
		/* 82195624h case    0:*/		regs.R11 = regs.R17;
		/* 82195624h case    0:*/		return 0x82195628;
	}
	return 0x82195628;
} // Block from 82195624h-82195628h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82195628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195628);
		  /* 82195628h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82195628h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82195628h case    0:*/		return 0x8219562C;
		  /* 8219562Ch */ case    1:  		/* bc 4, CR0_EQ, 8 */
		/* 8219562Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x82195634;  }
		/* 8219562Ch case    1:*/		return 0x82195630;
		  /* 82195630h */ case    2:  		/* mr R23, R17 */
		/* 82195630h case    2:*/		regs.R23 = regs.R17;
		/* 82195630h case    2:*/		return 0x82195634;
	}
	return 0x82195634;
} // Block from 82195628h-82195634h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82195634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195634);
		  /* 82195634h */ case    0:  		/* lwz R9, <#[R9 + 4]> */
		/* 82195634h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 82195634h case    0:*/		return 0x82195638;
		  /* 82195638h */ case    1:  		/* b -216 */
		/* 82195638h case    1:*/		return 0x82195560;
		/* 82195638h case    1:*/		return 0x8219563C;
	}
	return 0x8219563C;
} // Block from 82195634h-8219563Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219563Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219563C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219563C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219563C);
		  /* 8219563Ch */ case    0:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 8219563Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 8219563Ch case    0:*/		return 0x82195640;
		  /* 82195640h */ case    1:  		/* bc 12, CR0_EQ, 544 */
		/* 82195640h case    1:*/		if ( regs.CR[0].eq ) { return 0x82195860;  }
		/* 82195640h case    1:*/		return 0x82195644;
		  /* 82195644h */ case    2:  		/* lwz R11, <#[R25 + 76]> */
		/* 82195644h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000004C) );
		/* 82195644h case    2:*/		return 0x82195648;
		  /* 82195648h */ case    3:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 82195648h case    3:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 82195648h case    3:*/		return 0x8219564C;
		  /* 8219564Ch */ case    4:  		/* bc 12, CR0_EQ, 188 */
		/* 8219564Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x82195708;  }
		/* 8219564Ch case    4:*/		return 0x82195650;
		  /* 82195650h */ case    5:  		/* lwz R11, <#[R25 + 112]> */
		/* 82195650h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000070) );
		/* 82195650h case    5:*/		return 0x82195654;
		  /* 82195654h */ case    6:  		/* lwz R10, <#[R11 + 48]> */
		/* 82195654h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82195654h case    6:*/		return 0x82195658;
		  /* 82195658h */ case    7:  		/* rlwinm. R10, R10, 10, 31, 31 */
		/* 82195658h case    7:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R10,regs.R10);
		/* 82195658h case    7:*/		return 0x8219565C;
		  /* 8219565Ch */ case    8:  		/* bc 12, CR0_EQ, 48 */
		/* 8219565Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x8219568C;  }
		/* 8219565Ch case    8:*/		return 0x82195660;
		  /* 82195660h */ case    9:  		/* b 16 */
		/* 82195660h case    9:*/		return 0x82195670;
		/* 82195660h case    9:*/		return 0x82195664;
		  /* 82195664h */ case   10:  		/* lwz R10, <#[R11 + 48]> */
		/* 82195664h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82195664h case   10:*/		return 0x82195668;
		  /* 82195668h */ case   11:  		/* rlwinm. R10, R10, 0, 9, 9 */
		/* 82195668h case   11:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R10,regs.R10);
		/* 82195668h case   11:*/		return 0x8219566C;
		  /* 8219566Ch */ case   12:  		/* bc 12, CR0_EQ, 16 */
		/* 8219566Ch case   12:*/		if ( regs.CR[0].eq ) { return 0x8219567C;  }
		/* 8219566Ch case   12:*/		return 0x82195670;
	}
	return 0x82195670;
} // Block from 8219563Ch-82195670h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82195670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195670);
		  /* 82195670h */ case    0:  		/* lwz R11, <#[R11 + 80]> */
		/* 82195670h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82195670h case    0:*/		return 0x82195674;
		  /* 82195674h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82195674h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82195674h case    1:*/		return 0x82195678;
		  /* 82195678h */ case    2:  		/* bc 4, CR6_EQ, -20 */
		/* 82195678h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82195664;  }
		/* 82195678h case    2:*/		return 0x8219567C;
	}
	return 0x8219567C;
} // Block from 82195670h-8219567Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219567Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219567C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219567C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219567C);
		  /* 8219567Ch */ case    0:  		/* lwz R10, <#[R11 + 48]> */
		/* 8219567Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 8219567Ch case    0:*/		return 0x82195680;
		  /* 82195680h */ case    1:  		/* rlwinm. R10, R10, 10, 31, 31 */
		/* 82195680h case    1:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R10,regs.R10);
		/* 82195680h case    1:*/		return 0x82195684;
		  /* 82195684h */ case    2:  		/* bc 4, CR0_EQ, -20 */
		/* 82195684h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82195670;  }
		/* 82195684h case    2:*/		return 0x82195688;
		  /* 82195688h */ case    3:  		/* stw R11, <#[R25 + 112]> */
		/* 82195688h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000070) );
		/* 82195688h case    3:*/		return 0x8219568C;
	}
	return 0x8219568C;
} // Block from 8219567Ch-8219568Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219568Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219568C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219568C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219568C);
		  /* 8219568Ch */ case    0:  		/* lwz R11, <#[R25 + 112]> */
		/* 8219568Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000070) );
		/* 8219568Ch case    0:*/		return 0x82195690;
		  /* 82195690h */ case    1:  		/* lwz R10, <#[R11 + 28]> */
		/* 82195690h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000001C) );
		/* 82195690h case    1:*/		return 0x82195694;
		  /* 82195694h */ case    2:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82195694h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82195694h case    2:*/		return 0x82195698;
		  /* 82195698h */ case    3:  		/* bc 4, CR0_EQ, 892 */
		/* 82195698h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82195A14;  }
		/* 82195698h case    3:*/		return 0x8219569C;
		  /* 8219569Ch */ case    4:  		/* lwz R11, <#[R11 + 24]> */
		/* 8219569Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8219569Ch case    4:*/		return 0x821956A0;
		  /* 821956A0h */ case    5:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821956A0h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821956A0h case    5:*/		return 0x821956A4;
		  /* 821956A4h */ case    6:  		/* addic. R31, R11, -40 */
		/* 821956A4h case    6:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 821956A4h case    6:*/		return 0x821956A8;
		  /* 821956A8h */ case    7:  		/* bc 12, CR0_EQ, 876 */
		/* 821956A8h case    7:*/		if ( regs.CR[0].eq ) { return 0x82195A14;  }
		/* 821956A8h case    7:*/		return 0x821956AC;
		  /* 821956ACh */ case    8:  		/* mr R3, R31 */
		/* 821956ACh case    8:*/		regs.R3 = regs.R31;
		/* 821956ACh case    8:*/		return 0x821956B0;
		  /* 821956B0h */ case    9:  		/* bl -202240 */
		/* 821956B0h case    9:*/		regs.LR = 0x821956B4; return 0x821640B0;
		/* 821956B0h case    9:*/		return 0x821956B4;
		  /* 821956B4h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821956B4h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821956B4h case   10:*/		return 0x821956B8;
		  /* 821956B8h */ case   11:  		/* bc 4, CR0_EQ, 32 */
		/* 821956B8h case   11:*/		if ( !regs.CR[0].eq ) { return 0x821956D8;  }
		/* 821956B8h case   11:*/		return 0x821956BC;
		  /* 821956BCh */ case   12:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821956BCh case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821956BCh case   12:*/		return 0x821956C0;
		  /* 821956C0h */ case   13:  		/* lwz R11, <#[R11 + 36]> */
		/* 821956C0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 821956C0h case   13:*/		return 0x821956C4;
		  /* 821956C4h */ case   14:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821956C4h case   14:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821956C4h case   14:*/		return 0x821956C8;
		  /* 821956C8h */ case   15:  		/* bc 4, CR0_EQ, 844 */
		/* 821956C8h case   15:*/		if ( !regs.CR[0].eq ) { return 0x82195A14;  }
		/* 821956C8h case   15:*/		return 0x821956CC;
		  /* 821956CCh */ case   16:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821956CCh case   16:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821956CCh case   16:*/		return 0x821956D0;
		  /* 821956D0h */ case   17:  		/* addic. R31, R11, -40 */
		/* 821956D0h case   17:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 821956D0h case   17:*/		return 0x821956D4;
		  /* 821956D4h */ case   18:  		/* bc 4, CR0_EQ, -40 */
		/* 821956D4h case   18:*/		if ( !regs.CR[0].eq ) { return 0x821956AC;  }
		/* 821956D4h case   18:*/		return 0x821956D8;
	}
	return 0x821956D8;
} // Block from 8219568Ch-821956D8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821956D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821956D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821956D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821956D8);
		  /* 821956D8h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 821956D8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821956D8h case    0:*/		return 0x821956DC;
		  /* 821956DCh */ case    1:  		/* bc 12, CR6_EQ, 824 */
		/* 821956DCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82195A14;  }
		/* 821956DCh case    1:*/		return 0x821956E0;
		  /* 821956E0h */ case    2:  		/* lwz R11, <#[R31 + 20]> */
		/* 821956E0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 821956E0h case    2:*/		return 0x821956E4;
		  /* 821956E4h */ case    3:  		/* rlwinm R10, R26, 28, 0, 3 */
		/* 821956E4h case    3:*/		cpu::op::rlwinm<0,28,0,3>(regs,&regs.R10,regs.R26);
		/* 821956E4h case    3:*/		return 0x821956E8;
		  /* 821956E8h */ case    4:  		/* oris R11, R11, 2048 */
		/* 821956E8h case    4:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x800);
		/* 821956E8h case    4:*/		return 0x821956EC;
		  /* 821956ECh */ case    5:  		/* stw R11, <#[R31 + 20]> */
		/* 821956ECh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 821956ECh case    5:*/		return 0x821956F0;
		  /* 821956F0h */ case    6:  		/* lwz R9, <#[R27 + 20]> */
		/* 821956F0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000014) );
		/* 821956F0h case    6:*/		return 0x821956F4;
		  /* 821956F4h */ case    7:  		/* or R10, R10, R9 */
		/* 821956F4h case    7:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 821956F4h case    7:*/		return 0x821956F8;
		  /* 821956F8h */ case    8:  		/* or R10, R10, R11 */
		/* 821956F8h case    8:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 821956F8h case    8:*/		return 0x821956FC;
		  /* 821956FCh */ case    9:  		/* rlwimi R10, R11, 0, 4, 2 */
		/* 821956FCh case    9:*/		cpu::op::rlwimi<0,0,4,2>(regs,&regs.R10,regs.R11);
		/* 821956FCh case    9:*/		return 0x82195700;
		  /* 82195700h */ case   10:  		/* stw R10, <#[R31 + 20]> */
		/* 82195700h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 82195700h case   10:*/		return 0x82195704;
		  /* 82195704h */ case   11:  		/* b 348 */
		/* 82195704h case   11:*/		return 0x82195860;
		/* 82195704h case   11:*/		return 0x82195708;
	}
	return 0x82195708;
} // Block from 821956D8h-82195708h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82195708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195708);
		  /* 82195708h */ case    0:  		/* lwz R30, <#[R25 + 52]> */
		/* 82195708h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R25 + 0x00000034) );
		/* 82195708h case    0:*/		return 0x8219570C;
		  /* 8219570Ch */ case    1:  		/* b 332 */
		/* 8219570Ch case    1:*/		return 0x82195858;
		/* 8219570Ch case    1:*/		return 0x82195710;
		  /* 82195710h */ case    2:  		/* lwz R11, <#[R30 + 36]> */
		/* 82195710h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 82195710h case    2:*/		return 0x82195714;
		  /* 82195714h */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82195714h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82195714h case    3:*/		return 0x82195718;
		  /* 82195718h */ case    4:  		/* bc 4, CR0_EQ, 316 */
		/* 82195718h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82195854;  }
		/* 82195718h case    4:*/		return 0x8219571C;
		  /* 8219571Ch */ case    5:  		/* lwz R11, <#[R30 + 32]> */
		/* 8219571Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000020) );
		/* 8219571Ch case    5:*/		return 0x82195720;
		  /* 82195720h */ case    6:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82195720h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82195720h case    6:*/		return 0x82195724;
		  /* 82195724h */ case    7:  		/* addic. R31, R11, -40 */
		/* 82195724h case    7:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 82195724h case    7:*/		return 0x82195728;
		  /* 82195728h */ case    8:  		/* bc 12, CR0_EQ, 300 */
		/* 82195728h case    8:*/		if ( regs.CR[0].eq ) { return 0x82195854;  }
		/* 82195728h case    8:*/		return 0x8219572C;
		  /* 8219572Ch */ case    9:  		/* lwz R11, <#[R31 + 8]> */
		/* 8219572Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219572Ch case    9:*/		return 0x82195730;
		  /* 82195730h */ case   10:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82195730h case   10:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82195730h case   10:*/		return 0x82195734;
		  /* 82195734h */ case   11:  		/* cmplwi CR6, R11, 86 */
		/* 82195734h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000056);
		/* 82195734h case   11:*/		return 0x82195738;
		  /* 82195738h */ case   12:  		/* bc 12, CR6_EQ, 48 */
		/* 82195738h case   12:*/		if ( regs.CR[6].eq ) { return 0x82195768;  }
		/* 82195738h case   12:*/		return 0x8219573C;
		  /* 8219573Ch */ case   13:  		/* cmplwi CR6, R11, 87 */
		/* 8219573Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000057);
		/* 8219573Ch case   13:*/		return 0x82195740;
		  /* 82195740h */ case   14:  		/* bc 12, CR6_EQ, 40 */
		/* 82195740h case   14:*/		if ( regs.CR[6].eq ) { return 0x82195768;  }
		/* 82195740h case   14:*/		return 0x82195744;
		  /* 82195744h */ case   15:  		/* cmplwi CR6, R11, 89 */
		/* 82195744h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000059);
		/* 82195744h case   15:*/		return 0x82195748;
		  /* 82195748h */ case   16:  		/* bc 12, CR6_EQ, 32 */
		/* 82195748h case   16:*/		if ( regs.CR[6].eq ) { return 0x82195768;  }
		/* 82195748h case   16:*/		return 0x8219574C;
		  /* 8219574Ch */ case   17:  		/* cmplwi CR6, R11, 90 */
		/* 8219574Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005A);
		/* 8219574Ch case   17:*/		return 0x82195750;
		  /* 82195750h */ case   18:  		/* bc 12, CR6_EQ, 24 */
		/* 82195750h case   18:*/		if ( regs.CR[6].eq ) { return 0x82195768;  }
		/* 82195750h case   18:*/		return 0x82195754;
		  /* 82195754h */ case   19:  		/* cmplwi CR6, R11, 84 */
		/* 82195754h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000054);
		/* 82195754h case   19:*/		return 0x82195758;
		  /* 82195758h */ case   20:  		/* bc 12, CR6_EQ, 16 */
		/* 82195758h case   20:*/		if ( regs.CR[6].eq ) { return 0x82195768;  }
		/* 82195758h case   20:*/		return 0x8219575C;
		  /* 8219575Ch */ case   21:  		/* cmplwi CR6, R11, 85 */
		/* 8219575Ch case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000055);
		/* 8219575Ch case   21:*/		return 0x82195760;
		  /* 82195760h */ case   22:  		/* li R11, 0 */
		/* 82195760h case   22:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82195760h case   22:*/		return 0x82195764;
		  /* 82195764h */ case   23:  		/* bc 4, CR6_EQ, 8 */
		/* 82195764h case   23:*/		if ( !regs.CR[6].eq ) { return 0x8219576C;  }
		/* 82195764h case   23:*/		return 0x82195768;
	}
	return 0x82195768;
} // Block from 82195708h-82195768h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82195768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195768);
		  /* 82195768h */ case    0:  		/* mr R11, R17 */
		/* 82195768h case    0:*/		regs.R11 = regs.R17;
		/* 82195768h case    0:*/		return 0x8219576C;
	}
	return 0x8219576C;
} // Block from 82195768h-8219576Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219576Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219576C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219576C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219576C);
		  /* 8219576Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219576Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219576Ch case    0:*/		return 0x82195770;
		  /* 82195770h */ case    1:  		/* bc 12, CR0_EQ, 228 */
		/* 82195770h case    1:*/		if ( regs.CR[0].eq ) { return 0x82195854;  }
		/* 82195770h case    1:*/		return 0x82195774;
		  /* 82195774h */ case    2:  		/* addi R8, R1, 92 */
		/* 82195774h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x5C);
		/* 82195774h case    2:*/		return 0x82195778;
		  /* 82195778h */ case    3:  		/* addi R7, R1, 88 */
		/* 82195778h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x58);
		/* 82195778h case    3:*/		return 0x8219577C;
		  /* 8219577Ch */ case    4:  		/* addi R6, R1, 80 */
		/* 8219577Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 8219577Ch case    4:*/		return 0x82195780;
		  /* 82195780h */ case    5:  		/* mr R5, R31 */
		/* 82195780h case    5:*/		regs.R5 = regs.R31;
		/* 82195780h case    5:*/		return 0x82195784;
		  /* 82195784h */ case    6:  		/* mr R4, R30 */
		/* 82195784h case    6:*/		regs.R4 = regs.R30;
		/* 82195784h case    6:*/		return 0x82195788;
		  /* 82195788h */ case    7:  		/* mr R3, R18 */
		/* 82195788h case    7:*/		regs.R3 = regs.R18;
		/* 82195788h case    7:*/		return 0x8219578C;
		  /* 8219578Ch */ case    8:  		/* bl -111628 */
		/* 8219578Ch case    8:*/		regs.LR = 0x82195790; return 0x8217A380;
		/* 8219578Ch case    8:*/		return 0x82195790;
		  /* 82195790h */ case    9:  		/* cmpwi CR6, R3, 3 */
		/* 82195790h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000003);
		/* 82195790h case    9:*/		return 0x82195794;
		  /* 82195794h */ case   10:  		/* bc 4, CR6_EQ, 56 */
		/* 82195794h case   10:*/		if ( !regs.CR[6].eq ) { return 0x821957CC;  }
		/* 82195794h case   10:*/		return 0x82195798;
		  /* 82195798h */ case   11:  		/* lwz R11, <#[R1 + 88]> */
		/* 82195798h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82195798h case   11:*/		return 0x8219579C;
		  /* 8219579Ch */ case   12:  		/* lwz R10, <#[R25 + 40]> */
		/* 8219579Ch case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000028) );
		/* 8219579Ch case   12:*/		return 0x821957A0;
		  /* 821957A0h */ case   13:  		/* lwz R11, <#[R11 + 48]> */
		/* 821957A0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 821957A0h case   13:*/		return 0x821957A4;
		  /* 821957A4h */ case   14:  		/* rlwinm R9, R11, 0, 13, 31 */
		/* 821957A4h case   14:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R9,regs.R11);
		/* 821957A4h case   14:*/		return 0x821957A8;
		  /* 821957A8h */ case   15:  		/* rlwinm R11, R9, 27, 5, 31 */
		/* 821957A8h case   15:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R9);
		/* 821957A8h case   15:*/		return 0x821957AC;
		  /* 821957ACh */ case   16:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 821957ACh case   16:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 821957ACh case   16:*/		return 0x821957B0;
		  /* 821957B0h */ case   17:  		/* addi R11, R11, 1 */
		/* 821957B0h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821957B0h case   17:*/		return 0x821957B4;
		  /* 821957B4h */ case   18:  		/* slw R9, R17, R9 */
		/* 821957B4h case   18:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R17,regs.R9);
		/* 821957B4h case   18:*/		return 0x821957B8;
		  /* 821957B8h */ case   19:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821957B8h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821957B8h case   19:*/		return 0x821957BC;
		  /* 821957BCh */ case   20:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821957BCh case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821957BCh case   20:*/		return 0x821957C0;
		  /* 821957C0h */ case   21:  		/* and. R11, R11, R9 */
		/* 821957C0h case   21:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821957C0h case   21:*/		return 0x821957C4;
		  /* 821957C4h */ case   22:  		/* bc 4, CR0_EQ, 144 */
		/* 821957C4h case   22:*/		if ( !regs.CR[0].eq ) { return 0x82195854;  }
		/* 821957C4h case   22:*/		return 0x821957C8;
		  /* 821957C8h */ case   23:  		/* b 104 */
		/* 821957C8h case   23:*/		return 0x82195830;
		/* 821957C8h case   23:*/		return 0x821957CC;
	}
	return 0x821957CC;
} // Block from 8219576Ch-821957CCh (24 instructions)

//////////////////////////////////////////////////////
// Block at 821957CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821957CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821957CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821957CC);
		  /* 821957CCh */ case    0:  		/* cmpwi CR6, R3, 4 */
		/* 821957CCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000004);
		/* 821957CCh case    0:*/		return 0x821957D0;
		  /* 821957D0h */ case    1:  		/* bc 4, CR6_EQ, 132 */
		/* 821957D0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82195854;  }
		/* 821957D0h case    1:*/		return 0x821957D4;
		  /* 821957D4h */ case    2:  		/* lwz R10, <#[R1 + 88]> */
		/* 821957D4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 821957D4h case    2:*/		return 0x821957D8;
		  /* 821957D8h */ case    3:  		/* lwz R11, <#[R25 + 40]> */
		/* 821957D8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000028) );
		/* 821957D8h case    3:*/		return 0x821957DC;
		  /* 821957DCh */ case    4:  		/* lwz R10, <#[R10 + 48]> */
		/* 821957DCh case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 821957DCh case    4:*/		return 0x821957E0;
		  /* 821957E0h */ case    5:  		/* rlwinm R9, R10, 0, 13, 31 */
		/* 821957E0h case    5:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R9,regs.R10);
		/* 821957E0h case    5:*/		return 0x821957E4;
		  /* 821957E4h */ case    6:  		/* rlwinm R10, R9, 27, 5, 31 */
		/* 821957E4h case    6:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R9);
		/* 821957E4h case    6:*/		return 0x821957E8;
		  /* 821957E8h */ case    7:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 821957E8h case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 821957E8h case    7:*/		return 0x821957EC;
		  /* 821957ECh */ case    8:  		/* addi R10, R10, 1 */
		/* 821957ECh case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821957ECh case    8:*/		return 0x821957F0;
		  /* 821957F0h */ case    9:  		/* slw R9, R17, R9 */
		/* 821957F0h case    9:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R17,regs.R9);
		/* 821957F0h case    9:*/		return 0x821957F4;
		  /* 821957F4h */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821957F4h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821957F4h case   10:*/		return 0x821957F8;
		  /* 821957F8h */ case   11:  		/* lwzx R10, <#[R10 + R11]> */
		/* 821957F8h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821957F8h case   11:*/		return 0x821957FC;
		  /* 821957FCh */ case   12:  		/* and. R10, R9, R10 */
		/* 821957FCh case   12:*/		cpu::op::and<1>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821957FCh case   12:*/		return 0x82195800;
		  /* 82195800h */ case   13:  		/* bc 4, CR0_EQ, 48 */
		/* 82195800h case   13:*/		if ( !regs.CR[0].eq ) { return 0x82195830;  }
		/* 82195800h case   13:*/		return 0x82195804;
		  /* 82195804h */ case   14:  		/* lwz R10, <#[R1 + 92]> */
		/* 82195804h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 82195804h case   14:*/		return 0x82195808;
		  /* 82195808h */ case   15:  		/* lwz R10, <#[R10 + 48]> */
		/* 82195808h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 82195808h case   15:*/		return 0x8219580C;
		  /* 8219580Ch */ case   16:  		/* rlwinm R9, R10, 0, 13, 31 */
		/* 8219580Ch case   16:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R9,regs.R10);
		/* 8219580Ch case   16:*/		return 0x82195810;
		  /* 82195810h */ case   17:  		/* rlwinm R10, R9, 27, 5, 31 */
		/* 82195810h case   17:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R9);
		/* 82195810h case   17:*/		return 0x82195814;
		  /* 82195814h */ case   18:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 82195814h case   18:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 82195814h case   18:*/		return 0x82195818;
		  /* 82195818h */ case   19:  		/* addi R10, R10, 1 */
		/* 82195818h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82195818h case   19:*/		return 0x8219581C;
		  /* 8219581Ch */ case   20:  		/* slw R9, R17, R9 */
		/* 8219581Ch case   20:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R17,regs.R9);
		/* 8219581Ch case   20:*/		return 0x82195820;
		  /* 82195820h */ case   21:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82195820h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82195820h case   21:*/		return 0x82195824;
		  /* 82195824h */ case   22:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82195824h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82195824h case   22:*/		return 0x82195828;
		  /* 82195828h */ case   23:  		/* and. R11, R9, R11 */
		/* 82195828h case   23:*/		cpu::op::and<1>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82195828h case   23:*/		return 0x8219582C;
		  /* 8219582Ch */ case   24:  		/* bc 12, CR0_EQ, 40 */
		/* 8219582Ch case   24:*/		if ( regs.CR[0].eq ) { return 0x82195854;  }
		/* 8219582Ch case   24:*/		return 0x82195830;
	}
	return 0x82195830;
} // Block from 821957CCh-82195830h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82195830h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195830);
		  /* 82195830h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 82195830h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82195830h case    0:*/		return 0x82195834;
		  /* 82195834h */ case    1:  		/* rlwinm R10, R26, 28, 0, 3 */
		/* 82195834h case    1:*/		cpu::op::rlwinm<0,28,0,3>(regs,&regs.R10,regs.R26);
		/* 82195834h case    1:*/		return 0x82195838;
		  /* 82195838h */ case    2:  		/* oris R11, R11, 2048 */
		/* 82195838h case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x800);
		/* 82195838h case    2:*/		return 0x8219583C;
		  /* 8219583Ch */ case    3:  		/* stw R11, <#[R31 + 20]> */
		/* 8219583Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8219583Ch case    3:*/		return 0x82195840;
		  /* 82195840h */ case    4:  		/* lwz R9, <#[R27 + 20]> */
		/* 82195840h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000014) );
		/* 82195840h case    4:*/		return 0x82195844;
		  /* 82195844h */ case    5:  		/* or R10, R10, R9 */
		/* 82195844h case    5:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82195844h case    5:*/		return 0x82195848;
		  /* 82195848h */ case    6:  		/* or R10, R10, R11 */
		/* 82195848h case    6:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82195848h case    6:*/		return 0x8219584C;
		  /* 8219584Ch */ case    7:  		/* rlwimi R10, R11, 0, 4, 2 */
		/* 8219584Ch case    7:*/		cpu::op::rlwimi<0,0,4,2>(regs,&regs.R10,regs.R11);
		/* 8219584Ch case    7:*/		return 0x82195850;
		  /* 82195850h */ case    8:  		/* stw R10, <#[R31 + 20]> */
		/* 82195850h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 82195850h case    8:*/		return 0x82195854;
	}
	return 0x82195854;
} // Block from 82195830h-82195854h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82195854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195854);
		  /* 82195854h */ case    0:  		/* lwz R30, <#[R30 + 52]> */
		/* 82195854h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000034) );
		/* 82195854h case    0:*/		return 0x82195858;
	}
	return 0x82195858;
} // Block from 82195854h-82195858h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82195858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195858);
		  /* 82195858h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 82195858h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82195858h case    0:*/		return 0x8219585C;
		  /* 8219585Ch */ case    1:  		/* bc 4, CR6_EQ, -332 */
		/* 8219585Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82195710;  }
		/* 8219585Ch case    1:*/		return 0x82195860;
	}
	return 0x82195860;
} // Block from 82195858h-82195860h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82195860h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195860);
		  /* 82195860h */ case    0:  		/* rlwinm R11, R27, 0, 0, 30 */
		/* 82195860h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R27);
		/* 82195860h case    0:*/		return 0x82195864;
		  /* 82195864h */ case    1:  		/* lwz R11, <#[R11 + 36]> */
		/* 82195864h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82195864h case    1:*/		return 0x82195868;
		  /* 82195868h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82195868h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82195868h case    2:*/		return 0x8219586C;
		  /* 8219586Ch */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 8219586Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219587C;  }
		/* 8219586Ch case    3:*/		return 0x82195870;
		  /* 82195870h */ case    4:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82195870h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82195870h case    4:*/		return 0x82195874;
		  /* 82195874h */ case    5:  		/* addic. R27, R11, -40 */
		/* 82195874h case    5:*/		cpu::op::addic<1>(regs,&regs.R27,regs.R11,0xFFFFFFD8);
		/* 82195874h case    5:*/		return 0x82195878;
		  /* 82195878h */ case    6:  		/* bc 4, CR0_EQ, -1476 */
		/* 82195878h case    6:*/		if ( !regs.CR[0].eq ) { return 0x821952B4;  }
		/* 82195878h case    6:*/		return 0x8219587C;
	}
	return 0x8219587C;
} // Block from 82195860h-8219587Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219587Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219587C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219587C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219587C);
		  /* 8219587Ch */ case    0:  		/* addi R10, R25, 16 */
		/* 8219587Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R25,0x10);
		/* 8219587Ch case    0:*/		return 0x82195880;
		  /* 82195880h */ case    1:  		/* cmplw CR6, R24, R10 */
		/* 82195880h case    1:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R10);
		/* 82195880h case    1:*/		return 0x82195884;
		  /* 82195884h */ case    2:  		/* bc 12, CR6_EQ, 80 */
		/* 82195884h case    2:*/		if ( regs.CR[6].eq ) { return 0x821958D4;  }
		/* 82195884h case    2:*/		return 0x82195888;
		  /* 82195888h */ case    3:  		/* addi R11, R25, 24 */
		/* 82195888h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R25,0x18);
		/* 82195888h case    3:*/		return 0x8219588C;
		  /* 8219588Ch */ case    4:  		/* cmplw CR6, R24, R11 */
		/* 8219588Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R11);
		/* 8219588Ch case    4:*/		return 0x82195890;
		  /* 82195890h */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 82195890h case    5:*/		if ( regs.CR[6].eq ) { return 0x821958B0;  }
		/* 82195890h case    5:*/		return 0x82195894;
		  /* 82195894h */ case    6:  		/* lwz R9, <#[R25 + 28]> */
		/* 82195894h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x0000001C) );
		/* 82195894h case    6:*/		return 0x82195898;
		  /* 82195898h */ case    7:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 82195898h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 82195898h case    7:*/		return 0x8219589C;
		  /* 8219589Ch */ case    8:  		/* bc 4, CR0_EQ, 20 */
		/* 8219589Ch case    8:*/		if ( !regs.CR[0].eq ) { return 0x821958B0;  }
		/* 8219589Ch case    8:*/		return 0x821958A0;
		  /* 821958A0h */ case    9:  		/* lwz R10, <#[R11 + 4]> */
		/* 821958A0h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821958A0h case    9:*/		return 0x821958A4;
		  /* 821958A4h */ case   10:  		/* mr R24, R11 */
		/* 821958A4h case   10:*/		regs.R24 = regs.R11;
		/* 821958A4h case   10:*/		return 0x821958A8;
		  /* 821958A8h */ case   11:  		/* rlwinm. R11, R10, 0, 31, 31 */
		/* 821958A8h case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R10);
		/* 821958A8h case   11:*/		return 0x821958AC;
		  /* 821958ACh */ case   12:  		/* b 16 */
		/* 821958ACh case   12:*/		return 0x821958BC;
		/* 821958ACh case   12:*/		return 0x821958B0;
	}
	return 0x821958B0;
} // Block from 8219587Ch-821958B0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821958B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821958B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821958B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821958B0);
		  /* 821958B0h */ case    0:  		/* lwz R11, <#[R10 + 4]> */
		/* 821958B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 821958B0h case    0:*/		return 0x821958B4;
		  /* 821958B4h */ case    1:  		/* mr R24, R10 */
		/* 821958B4h case    1:*/		regs.R24 = regs.R10;
		/* 821958B4h case    1:*/		return 0x821958B8;
		  /* 821958B8h */ case    2:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821958B8h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821958B8h case    2:*/		return 0x821958BC;
	}
	return 0x821958BC;
} // Block from 821958B0h-821958BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821958BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821958BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821958BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821958BC);
		  /* 821958BCh */ case    0:  		/* bc 4, CR0_EQ, 24 */
		/* 821958BCh case    0:*/		if ( !regs.CR[0].eq ) { return 0x821958D4;  }
		/* 821958BCh case    0:*/		return 0x821958C0;
		  /* 821958C0h */ case    1:  		/* lwz R11, <#[R24]> */
		/* 821958C0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 821958C0h case    1:*/		return 0x821958C4;
		  /* 821958C4h */ case    2:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821958C4h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821958C4h case    2:*/		return 0x821958C8;
		  /* 821958C8h */ case    3:  		/* addi R27, R11, -40 */
		/* 821958C8h case    3:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFFFFD8);
		/* 821958C8h case    3:*/		return 0x821958CC;
	}
	return 0x821958CC;
} // Block from 821958BCh-821958CCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821958CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821958CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821958CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821958CC);
		  /* 821958CCh */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 821958CCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 821958CCh case    0:*/		return 0x821958D0;
		  /* 821958D0h */ case    1:  		/* bc 4, CR6_EQ, -1564 */
		/* 821958D0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821952B4;  }
		/* 821958D0h case    1:*/		return 0x821958D4;
	}
	return 0x821958D4;
} // Block from 821958CCh-821958D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821958D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821958D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821958D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821958D4);
		  /* 821958D4h */ case    0:  		/* rlwinm R11, R25, 0, 0, 30 */
		/* 821958D4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R25);
		/* 821958D4h case    0:*/		return 0x821958D8;
		  /* 821958D8h */ case    1:  		/* lwz R11, <#[R11]> */
		/* 821958D8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821958D8h case    1:*/		return 0x821958DC;
		  /* 821958DCh */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821958DCh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821958DCh case    2:*/		return 0x821958E0;
		  /* 821958E0h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821958E0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821958F0;  }
		/* 821958E0h case    3:*/		return 0x821958E4;
	}
	return 0x821958E4;
} // Block from 821958D4h-821958E4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821958E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821958E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821958E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821958E4);
		  /* 821958E4h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821958E4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821958E4h case    0:*/		return 0x821958E8;
		  /* 821958E8h */ case    1:  		/* addic. R25, R11, -4 */
		/* 821958E8h case    1:*/		cpu::op::addic<1>(regs,&regs.R25,regs.R11,0xFFFFFFFC);
		/* 821958E8h case    1:*/		return 0x821958EC;
		  /* 821958ECh */ case    2:  		/* bc 4, CR0_EQ, -1684 */
		/* 821958ECh case    2:*/		if ( !regs.CR[0].eq ) { return 0x82195258;  }
		/* 821958ECh case    2:*/		return 0x821958F0;
	}
	return 0x821958F0;
} // Block from 821958E4h-821958F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821958F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821958F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821958F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821958F0);
		  /* 821958F0h */ case    0:  		/* rlwinm. R11, R23, 0, 24, 31 */
		/* 821958F0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R23);
		/* 821958F0h case    0:*/		return 0x821958F4;
		  /* 821958F4h */ case    1:  		/* bc 4, CR0_EQ, -1716 */
		/* 821958F4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82195240;  }
		/* 821958F4h case    1:*/		return 0x821958F8;
		  /* 821958F8h */ case    2:  		/* lwz R11, <#[R18 + 4]> */
		/* 821958F8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000004) );
		/* 821958F8h case    2:*/		return 0x821958FC;
		  /* 821958FCh */ case    3:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821958FCh case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821958FCh case    3:*/		return 0x82195900;
		  /* 82195900h */ case    4:  		/* bc 4, CR0_EQ, 492 */
		/* 82195900h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82195AEC;  }
		/* 82195900h case    4:*/		return 0x82195904;
		  /* 82195904h */ case    5:  		/* mr R25, R11 */
		/* 82195904h case    5:*/		regs.R25 = regs.R11;
		/* 82195904h case    5:*/		return 0x82195908;
		  /* 82195908h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 82195908h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82195908h case    6:*/		return 0x8219590C;
		  /* 8219590Ch */ case    7:  		/* bc 12, CR0_EQ, 480 */
		/* 8219590Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x82195AEC;  }
		/* 8219590Ch case    7:*/		return 0x82195910;
		  /* 82195910h */ case    8:  		/* lwz R11, <#[R25 + 28]> */
		/* 82195910h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000001C) );
		/* 82195910h case    8:*/		return 0x82195914;
		  /* 82195914h */ case    9:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82195914h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82195914h case    9:*/		return 0x82195918;
		  /* 82195918h */ case   10:  		/* bc 4, CR0_EQ, 440 */
		/* 82195918h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82195AD0;  }
		/* 82195918h case   10:*/		return 0x8219591C;
		  /* 8219591Ch */ case   11:  		/* mr R30, R11 */
		/* 8219591Ch case   11:*/		regs.R30 = regs.R11;
		/* 8219591Ch case   11:*/		return 0x82195920;
		  /* 82195920h */ case   12:  		/* cmplwi CR0, R11, 0 */
		/* 82195920h case   12:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82195920h case   12:*/		return 0x82195924;
		  /* 82195924h */ case   13:  		/* bc 12, CR0_EQ, 428 */
		/* 82195924h case   13:*/		if ( regs.CR[0].eq ) { return 0x82195AD0;  }
		/* 82195924h case   13:*/		return 0x82195928;
		  /* 82195928h */ case   14:  		/* lwz R11, <#[R30 + 20]> */
		/* 82195928h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 82195928h case   14:*/		return 0x8219592C;
		  /* 8219592Ch */ case   15:  		/* rlwinm. R11, R11, 0, 4, 4 */
		/* 8219592Ch case   15:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R11,regs.R11);
		/* 8219592Ch case   15:*/		return 0x82195930;
		  /* 82195930h */ case   16:  		/* bc 12, CR0_EQ, 388 */
		/* 82195930h case   16:*/		if ( regs.CR[0].eq ) { return 0x82195AB4;  }
		/* 82195930h case   16:*/		return 0x82195934;
		  /* 82195934h */ case   17:  		/* lwz R11, <#[R30 + 8]> */
		/* 82195934h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82195934h case   17:*/		return 0x82195938;
		  /* 82195938h */ case   18:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82195938h case   18:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82195938h case   18:*/		return 0x8219593C;
		  /* 8219593Ch */ case   19:  		/* cmplwi CR6, R11, 96 */
		/* 8219593Ch case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000060);
		/* 8219593Ch case   19:*/		return 0x82195940;
		  /* 82195940h */ case   20:  		/* bc 12, CR6_LT, 16 */
		/* 82195940h case   20:*/		if ( regs.CR[6].lt ) { return 0x82195950;  }
		/* 82195940h case   20:*/		return 0x82195944;
		  /* 82195944h */ case   21:  		/* cmplwi CR6, R11, 102 */
		/* 82195944h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000066);
		/* 82195944h case   21:*/		return 0x82195948;
		  /* 82195948h */ case   22:  		/* mr R11, R17 */
		/* 82195948h case   22:*/		regs.R11 = regs.R17;
		/* 82195948h case   22:*/		return 0x8219594C;
		  /* 8219594Ch */ case   23:  		/* bc 4, CR6_GT, 8 */
		/* 8219594Ch case   23:*/		if ( !regs.CR[6].gt ) { return 0x82195954;  }
		/* 8219594Ch case   23:*/		return 0x82195950;
	}
	return 0x82195950;
} // Block from 821958F0h-82195950h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82195950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195950);
		  /* 82195950h */ case    0:  		/* li R11, 0 */
		/* 82195950h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82195950h case    0:*/		return 0x82195954;
	}
	return 0x82195954;
} // Block from 82195950h-82195954h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82195954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195954);
		  /* 82195954h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82195954h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82195954h case    0:*/		return 0x82195958;
		  /* 82195958h */ case    1:  		/* bc 12, CR0_EQ, 348 */
		/* 82195958h case    1:*/		if ( regs.CR[0].eq ) { return 0x82195AB4;  }
		/* 82195958h case    1:*/		return 0x8219595C;
		  /* 8219595Ch */ case    2:  		/* addi R26, R30, 4 */
		/* 8219595Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R30,0x4);
		/* 8219595Ch case    2:*/		return 0x82195960;
		  /* 82195960h */ case    3:  		/* li R31, 0 */
		/* 82195960h case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82195960h case    3:*/		return 0x82195964;
		  /* 82195964h */ case    4:  		/* mr R27, R26 */
		/* 82195964h case    4:*/		regs.R27 = regs.R26;
		/* 82195964h case    4:*/		return 0x82195968;
		  /* 82195968h */ case    5:  		/* lwz R28, <#[R27]> */
		/* 82195968h case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R27 + 0x00000000) );
		/* 82195968h case    5:*/		return 0x8219596C;
		  /* 8219596Ch */ case    6:  		/* cmplwi CR6, R28, 0 */
		/* 8219596Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8219596Ch case    6:*/		return 0x82195970;
		  /* 82195970h */ case    7:  		/* bc 12, CR6_EQ, 324 */
		/* 82195970h case    7:*/		if ( regs.CR[6].eq ) { return 0x82195AB4;  }
		/* 82195970h case    7:*/		return 0x82195974;
		  /* 82195974h */ case    8:  		/* lwz R29, <#[R28 + 16]> */
		/* 82195974h case    8:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R28 + 0x00000010) );
		/* 82195974h case    8:*/		return 0x82195978;
		  /* 82195978h */ case    9:  		/* cmplwi CR6, R29, 0 */
		/* 82195978h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82195978h case    9:*/		return 0x8219597C;
		  /* 8219597Ch */ case   10:  		/* bc 12, CR6_EQ, 292 */
		/* 8219597Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x82195AA0;  }
		/* 8219597Ch case   10:*/		return 0x82195980;
		  /* 82195980h */ case   11:  		/* mr R3, R28 */
		/* 82195980h case   11:*/		regs.R3 = regs.R28;
		/* 82195980h case   11:*/		return 0x82195984;
		  /* 82195984h */ case   12:  		/* bl -201044 */
		/* 82195984h case   12:*/		regs.LR = 0x82195988; return 0x82164830;
		/* 82195984h case   12:*/		return 0x82195988;
		  /* 82195988h */ case   13:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82195988h case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82195988h case   13:*/		return 0x8219598C;
		  /* 8219598Ch */ case   14:  		/* bc 12, CR0_EQ, 276 */
		/* 8219598Ch case   14:*/		if ( regs.CR[0].eq ) { return 0x82195AA0;  }
		/* 8219598Ch case   14:*/		return 0x82195990;
		  /* 82195990h */ case   15:  		/* lwz R11, <#[R29 + 8]> */
		/* 82195990h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82195990h case   15:*/		return 0x82195994;
		  /* 82195994h */ case   16:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82195994h case   16:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82195994h case   16:*/		return 0x82195998;
		  /* 82195998h */ case   17:  		/* cmplwi CR6, R11, 96 */
		/* 82195998h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000060);
		/* 82195998h case   17:*/		return 0x8219599C;
		  /* 8219599Ch */ case   18:  		/* bc 12, CR6_LT, 16 */
		/* 8219599Ch case   18:*/		if ( regs.CR[6].lt ) { return 0x821959AC;  }
		/* 8219599Ch case   18:*/		return 0x821959A0;
		  /* 821959A0h */ case   19:  		/* cmplwi CR6, R11, 102 */
		/* 821959A0h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000066);
		/* 821959A0h case   19:*/		return 0x821959A4;
		  /* 821959A4h */ case   20:  		/* mr R11, R17 */
		/* 821959A4h case   20:*/		regs.R11 = regs.R17;
		/* 821959A4h case   20:*/		return 0x821959A8;
		  /* 821959A8h */ case   21:  		/* bc 4, CR6_GT, 8 */
		/* 821959A8h case   21:*/		if ( !regs.CR[6].gt ) { return 0x821959B0;  }
		/* 821959A8h case   21:*/		return 0x821959AC;
	}
	return 0x821959AC;
} // Block from 82195954h-821959ACh (22 instructions)

//////////////////////////////////////////////////////
// Block at 821959ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821959AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821959AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821959AC);
		  /* 821959ACh */ case    0:  		/* li R11, 0 */
		/* 821959ACh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821959ACh case    0:*/		return 0x821959B0;
	}
	return 0x821959B0;
} // Block from 821959ACh-821959B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821959B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821959B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821959B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821959B0);
		  /* 821959B0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821959B0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821959B0h case    0:*/		return 0x821959B4;
		  /* 821959B4h */ case    1:  		/* bc 12, CR0_EQ, 236 */
		/* 821959B4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82195AA0;  }
		/* 821959B4h case    1:*/		return 0x821959B8;
		  /* 821959B8h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 821959B8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821959B8h case    2:*/		return 0x821959BC;
		  /* 821959BCh */ case    3:  		/* bc 4, CR6_EQ, 212 */
		/* 821959BCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x82195A90;  }
		/* 821959BCh case    3:*/		return 0x821959C0;
		  /* 821959C0h */ case    4:  		/* lwz R10, <#[R26]> */
		/* 821959C0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 821959C0h case    4:*/		return 0x821959C4;
		  /* 821959C4h */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 821959C4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821959C4h case    5:*/		return 0x821959C8;
		  /* 821959C8h */ case    6:  		/* bc 12, CR6_EQ, 88 */
		/* 821959C8h case    6:*/		if ( regs.CR[6].eq ) { return 0x82195A20;  }
		/* 821959C8h case    6:*/		return 0x821959CC;
		  /* 821959CCh */ case    7:  		/* lwz R31, <#[R10 + 16]> */
		/* 821959CCh case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x00000010) );
		/* 821959CCh case    7:*/		return 0x821959D0;
		  /* 821959D0h */ case    8:  		/* cmplwi CR6, R31, 0 */
		/* 821959D0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821959D0h case    8:*/		return 0x821959D4;
		  /* 821959D4h */ case    9:  		/* bc 12, CR6_EQ, 56 */
		/* 821959D4h case    9:*/		if ( regs.CR[6].eq ) { return 0x82195A0C;  }
		/* 821959D4h case    9:*/		return 0x821959D8;
		  /* 821959D8h */ case   10:  		/* lwz R11, <#[R10]> */
		/* 821959D8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821959D8h case   10:*/		return 0x821959DC;
		  /* 821959DCh */ case   11:  		/* rlwinm. R9, R11, 0, 1, 1 */
		/* 821959DCh case   11:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R9,regs.R11);
		/* 821959DCh case   11:*/		return 0x821959E0;
		  /* 821959E0h */ case   12:  		/* bc 4, CR0_EQ, 16 */
		/* 821959E0h case   12:*/		if ( !regs.CR[0].eq ) { return 0x821959F0;  }
		/* 821959E0h case   12:*/		return 0x821959E4;
		  /* 821959E4h */ case   13:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821959E4h case   13:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821959E4h case   13:*/		return 0x821959E8;
		  /* 821959E8h */ case   14:  		/* mr R11, R17 */
		/* 821959E8h case   14:*/		regs.R11 = regs.R17;
		/* 821959E8h case   14:*/		return 0x821959EC;
		  /* 821959ECh */ case   15:  		/* bc 12, CR0_EQ, 8 */
		/* 821959ECh case   15:*/		if ( regs.CR[0].eq ) { return 0x821959F4;  }
		/* 821959ECh case   15:*/		return 0x821959F0;
	}
	return 0x821959F0;
} // Block from 821959B0h-821959F0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821959F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821959F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821959F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821959F0);
		  /* 821959F0h */ case    0:  		/* li R11, 0 */
		/* 821959F0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821959F0h case    0:*/		return 0x821959F4;
	}
	return 0x821959F4;
} // Block from 821959F0h-821959F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821959F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821959F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821959F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821959F4);
		  /* 821959F4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821959F4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821959F4h case    0:*/		return 0x821959F8;
		  /* 821959F8h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 821959F8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82195A0C;  }
		/* 821959F8h case    1:*/		return 0x821959FC;
		  /* 821959FCh */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 821959FCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821959FCh case    2:*/		return 0x82195A00;
		  /* 82195A00h */ case    3:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82195A00h case    3:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82195A00h case    3:*/		return 0x82195A04;
		  /* 82195A04h */ case    4:  		/* cmplwi CR6, R11, 15744 */
		/* 82195A04h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003D80);
		/* 82195A04h case    4:*/		return 0x82195A08;
		  /* 82195A08h */ case    5:  		/* bc 12, CR6_EQ, 136 */
		/* 82195A08h case    5:*/		if ( regs.CR[6].eq ) { return 0x82195A90;  }
		/* 82195A08h case    5:*/		return 0x82195A0C;
	}
	return 0x82195A0C;
} // Block from 821959F4h-82195A0Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82195A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195A0C);
		  /* 82195A0Ch */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 82195A0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82195A0Ch case    0:*/		return 0x82195A10;
		  /* 82195A10h */ case    1:  		/* b -76 */
		/* 82195A10h case    1:*/		return 0x821959C4;
		/* 82195A10h case    1:*/		return 0x82195A14;
	}
	return 0x82195A14;
} // Block from 82195A0Ch-82195A14h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82195A14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195A14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195A14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195A14);
		  /* 82195A14h */ case    0:  		/* li R4, 4800 */
		/* 82195A14h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82195A14h case    0:*/		return 0x82195A18;
		  /* 82195A18h */ case    1:  		/* mr R3, R18 */
		/* 82195A18h case    1:*/		regs.R3 = regs.R18;
		/* 82195A18h case    1:*/		return 0x82195A1C;
		  /* 82195A1Ch */ case    2:  		/* bl -277428 */
		/* 82195A1Ch case    2:*/		regs.LR = 0x82195A20; return 0x82151E68;
		/* 82195A1Ch case    2:*/		return 0x82195A20;
	}
	return 0x82195A20;
} // Block from 82195A14h-82195A20h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82195A20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195A20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195A20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195A20);
		  /* 82195A20h */ case    0:  		/* li R8, 0 */
		/* 82195A20h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82195A20h case    0:*/		return 0x82195A24;
		  /* 82195A24h */ case    1:  		/* li R7, 0 */
		/* 82195A24h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82195A24h case    1:*/		return 0x82195A28;
		  /* 82195A28h */ case    2:  		/* li R6, 123 */
		/* 82195A28h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x7B);
		/* 82195A28h case    2:*/		return 0x82195A2C;
		  /* 82195A2Ch */ case    3:  		/* li R5, 0 */
		/* 82195A2Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82195A2Ch case    3:*/		return 0x82195A30;
		  /* 82195A30h */ case    4:  		/* mr R4, R25 */
		/* 82195A30h case    4:*/		regs.R4 = regs.R25;
		/* 82195A30h case    4:*/		return 0x82195A34;
		  /* 82195A34h */ case    5:  		/* mr R3, R18 */
		/* 82195A34h case    5:*/		regs.R3 = regs.R18;
		/* 82195A34h case    5:*/		return 0x82195A38;
		  /* 82195A38h */ case    6:  		/* bl 585568 */
		/* 82195A38h case    6:*/		regs.LR = 0x82195A3C; return 0x82224998;
		/* 82195A38h case    6:*/		return 0x82195A3C;
		  /* 82195A3Ch */ case    7:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82195A3Ch case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82195A3Ch case    7:*/		return 0x82195A40;
		  /* 82195A40h */ case    8:  		/* rlwinm R10, R3, 0, 0, 30 */
		/* 82195A40h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R3);
		/* 82195A40h case    8:*/		return 0x82195A44;
		  /* 82195A44h */ case    9:  		/* lwz R7, <#[R3 + 8]> */
		/* 82195A44h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000008) );
		/* 82195A44h case    9:*/		return 0x82195A48;
		  /* 82195A48h */ case   10:  		/* addi R11, R11, 36 */
		/* 82195A48h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82195A48h case   10:*/		return 0x82195A4C;
		  /* 82195A4Ch */ case   11:  		/* addi R10, R10, 36 */
		/* 82195A4Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 82195A4Ch case   11:*/		return 0x82195A50;
		  /* 82195A50h */ case   12:  		/* oris R7, R7, 768 */
		/* 82195A50h case   12:*/		cpu::op::oris<0>(regs,&regs.R7,regs.R7,0x300);
		/* 82195A50h case   12:*/		return 0x82195A54;
		  /* 82195A54h */ case   13:  		/* addi R8, R10, 4 */
		/* 82195A54h case   13:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x4);
		/* 82195A54h case   13:*/		return 0x82195A58;
		  /* 82195A58h */ case   14:  		/* stw R7, <#[R3 + 8]> */
		/* 82195A58h case   14:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000008) );
		/* 82195A58h case   14:*/		return 0x82195A5C;
		  /* 82195A5Ch */ case   15:  		/* addi R9, R11, 4 */
		/* 82195A5Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 82195A5Ch case   15:*/		return 0x82195A60;
		  /* 82195A60h */ case   16:  		/* lwz R7, <#[R11 + 4]> */
		/* 82195A60h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82195A60h case   16:*/		return 0x82195A64;
		  /* 82195A64h */ case   17:  		/* addi R6, R10, -36 */
		/* 82195A64h case   17:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 82195A64h case   17:*/		return 0x82195A68;
		  /* 82195A68h */ case   18:  		/* stw R7, <#[R10 + 4]> */
		/* 82195A68h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 82195A68h case   18:*/		return 0x82195A6C;
		  /* 82195A6Ch */ case   19:  		/* mr R5, R18 */
		/* 82195A6Ch case   19:*/		regs.R5 = regs.R18;
		/* 82195A6Ch case   19:*/		return 0x82195A70;
		  /* 82195A70h */ case   20:  		/* lwz R7, <#[R11 + 4]> */
		/* 82195A70h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82195A70h case   20:*/		return 0x82195A74;
		  /* 82195A74h */ case   21:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 82195A74h case   21:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 82195A74h case   21:*/		return 0x82195A78;
		  /* 82195A78h */ case   22:  		/* stw R8, <#[R7 + 36]> */
		/* 82195A78h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000024) );
		/* 82195A78h case   22:*/		return 0x82195A7C;
		  /* 82195A7Ch */ case   23:  		/* mr R4, R30 */
		/* 82195A7Ch case   23:*/		regs.R4 = regs.R30;
		/* 82195A7Ch case   23:*/		return 0x82195A80;
		  /* 82195A80h */ case   24:  		/* stw R9, <#[R10]> */
		/* 82195A80h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82195A80h case   24:*/		return 0x82195A84;
		  /* 82195A84h */ case   25:  		/* mr R31, R3 */
		/* 82195A84h case   25:*/		regs.R31 = regs.R3;
		/* 82195A84h case   25:*/		return 0x82195A88;
		  /* 82195A88h */ case   26:  		/* stw R6, <#[R11 + 4]> */
		/* 82195A88h case   26:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82195A88h case   26:*/		return 0x82195A8C;
		  /* 82195A8Ch */ case   27:  		/* bl -120828 */
		/* 82195A8Ch case   27:*/		regs.LR = 0x82195A90; return 0x82178290;
		/* 82195A8Ch case   27:*/		return 0x82195A90;
	}
	return 0x82195A90;
} // Block from 82195A20h-82195A90h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82195A90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195A90);
		  /* 82195A90h */ case    0:  		/* mr R5, R18 */
		/* 82195A90h case    0:*/		regs.R5 = regs.R18;
		/* 82195A90h case    0:*/		return 0x82195A94;
		  /* 82195A94h */ case    1:  		/* mr R4, R31 */
		/* 82195A94h case    1:*/		regs.R4 = regs.R31;
		/* 82195A94h case    1:*/		return 0x82195A98;
		  /* 82195A98h */ case    2:  		/* mr R3, R29 */
		/* 82195A98h case    2:*/		regs.R3 = regs.R29;
		/* 82195A98h case    2:*/		return 0x82195A9C;
		  /* 82195A9Ch */ case    3:  		/* bl -120844 */
		/* 82195A9Ch case    3:*/		regs.LR = 0x82195AA0; return 0x82178290;
		/* 82195A9Ch case    3:*/		return 0x82195AA0;
	}
	return 0x82195AA0;
} // Block from 82195A90h-82195AA0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82195AA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195AA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195AA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195AA0);
		  /* 82195AA0h */ case    0:  		/* lwz R11, <#[R27]> */
		/* 82195AA0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82195AA0h case    0:*/		return 0x82195AA4;
		  /* 82195AA4h */ case    1:  		/* cmplw CR6, R11, R28 */
		/* 82195AA4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 82195AA4h case    1:*/		return 0x82195AA8;
		  /* 82195AA8h */ case    2:  		/* bc 4, CR6_EQ, -320 */
		/* 82195AA8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82195968;  }
		/* 82195AA8h case    2:*/		return 0x82195AAC;
		  /* 82195AACh */ case    3:  		/* addi R27, R28, 8 */
		/* 82195AACh case    3:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R28,0x8);
		/* 82195AACh case    3:*/		return 0x82195AB0;
		  /* 82195AB0h */ case    4:  		/* b -328 */
		/* 82195AB0h case    4:*/		return 0x82195968;
		/* 82195AB0h case    4:*/		return 0x82195AB4;
	}
	return 0x82195AB4;
} // Block from 82195AA0h-82195AB4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82195AB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195AB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195AB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195AB4);
		  /* 82195AB4h */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82195AB4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82195AB4h case    0:*/		return 0x82195AB8;
		  /* 82195AB8h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 82195AB8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82195AB8h case    1:*/		return 0x82195ABC;
		  /* 82195ABCh */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82195ABCh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82195ABCh case    2:*/		return 0x82195AC0;
		  /* 82195AC0h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82195AC0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82195AD0;  }
		/* 82195AC0h case    3:*/		return 0x82195AC4;
		  /* 82195AC4h */ case    4:  		/* mr R30, R11 */
		/* 82195AC4h case    4:*/		regs.R30 = regs.R11;
		/* 82195AC4h case    4:*/		return 0x82195AC8;
		  /* 82195AC8h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82195AC8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82195AC8h case    5:*/		return 0x82195ACC;
		  /* 82195ACCh */ case    6:  		/* bc 4, CR6_EQ, -420 */
		/* 82195ACCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x82195928;  }
		/* 82195ACCh case    6:*/		return 0x82195AD0;
	}
	return 0x82195AD0;
} // Block from 82195AB4h-82195AD0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82195AD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195AD0);
		  /* 82195AD0h */ case    0:  		/* rlwinm R11, R25, 0, 0, 30 */
		/* 82195AD0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R25);
		/* 82195AD0h case    0:*/		return 0x82195AD4;
		  /* 82195AD4h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 82195AD4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82195AD4h case    1:*/		return 0x82195AD8;
	}
	return 0x82195AD8;
} // Block from 82195AD0h-82195AD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82195AD8h
// Function '?LocalScheduling@Compiler@D3DXShader@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195AD8);
		  /* 82195AD8h */ case    0:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82195AD8h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82195AD8h case    0:*/		return 0x82195ADC;
		  /* 82195ADCh */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 82195ADCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x82195AEC;  }
		/* 82195ADCh case    1:*/		return 0x82195AE0;
		  /* 82195AE0h */ case    2:  		/* mr R25, R11 */
		/* 82195AE0h case    2:*/		regs.R25 = regs.R11;
		/* 82195AE0h case    2:*/		return 0x82195AE4;
		  /* 82195AE4h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82195AE4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82195AE4h case    3:*/		return 0x82195AE8;
		  /* 82195AE8h */ case    4:  		/* bc 4, CR6_EQ, -472 */
		/* 82195AE8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82195910;  }
		/* 82195AE8h case    4:*/		return 0x82195AEC;
	}
	return 0x82195AEC;
} // Block from 82195AD8h-82195AECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82195AECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195AEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195AEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195AEC);
		  /* 82195AECh */ case    0:  		/* lwz R11, <#[R18 + 4]> */
		/* 82195AECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000004) );
		/* 82195AECh case    0:*/		return 0x82195AF0;
		  /* 82195AF0h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82195AF0h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82195AF0h case    1:*/		return 0x82195AF4;
		  /* 82195AF4h */ case    2:  		/* bc 4, CR0_EQ, 1500 */
		/* 82195AF4h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821960D0;  }
		/* 82195AF4h case    2:*/		return 0x82195AF8;
		  /* 82195AF8h */ case    3:  		/* lwz R11, <#[R18]> */
		/* 82195AF8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 82195AF8h case    3:*/		return 0x82195AFC;
		  /* 82195AFCh */ case    4:  		/* b 1480 */
		/* 82195AFCh case    4:*/		return 0x821960C4;
		/* 82195AFCh case    4:*/		return 0x82195B00;
		  /* 82195B00h */ case    5:  		/* lwz R11, <#[R19 + 20]> */
		/* 82195B00h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82195B00h case    5:*/		return 0x82195B04;
		  /* 82195B04h */ case    6:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82195B04h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82195B04h case    6:*/		return 0x82195B08;
		  /* 82195B08h */ case    7:  		/* bc 4, CR0_EQ, 1452 */
		/* 82195B08h case    7:*/		if ( !regs.CR[0].eq ) { return 0x821960B4;  }
		/* 82195B08h case    7:*/		return 0x82195B0C;
		  /* 82195B0Ch */ case    8:  		/* mr R21, R11 */
		/* 82195B0Ch case    8:*/		regs.R21 = regs.R11;
		/* 82195B0Ch case    8:*/		return 0x82195B10;
		  /* 82195B10h */ case    9:  		/* cmplwi CR0, R11, 0 */
		/* 82195B10h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82195B10h case    9:*/		return 0x82195B14;
		  /* 82195B14h */ case   10:  		/* bc 12, CR0_EQ, 1440 */
		/* 82195B14h case   10:*/		if ( regs.CR[0].eq ) { return 0x821960B4;  }
		/* 82195B14h case   10:*/		return 0x82195B18;
		  /* 82195B18h */ case   11:  		/* lwz R11, <#[R21 + 8]> */
		/* 82195B18h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 82195B18h case   11:*/		return 0x82195B1C;
		  /* 82195B1Ch */ case   12:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82195B1Ch case   12:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82195B1Ch case   12:*/		return 0x82195B20;
		  /* 82195B20h */ case   13:  		/* cmplwi CR6, R11, 14336 */
		/* 82195B20h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 82195B20h case   13:*/		return 0x82195B24;
		  /* 82195B24h */ case   14:  		/* bc 4, CR6_EQ, 1396 */
		/* 82195B24h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82196098;  }
		/* 82195B24h case   14:*/		return 0x82195B28;
		  /* 82195B28h */ case   15:  		/* lwz R11, <#[R21]> */
		/* 82195B28h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 82195B28h case   15:*/		return 0x82195B2C;
		  /* 82195B2Ch */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 82195B2Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82195B2Ch case   16:*/		return 0x82195B30;
		  /* 82195B30h */ case   17:  		/* bc 12, CR6_EQ, 20 */
		/* 82195B30h case   17:*/		if ( regs.CR[6].eq ) { return 0x82195B44;  }
		/* 82195B30h case   17:*/		return 0x82195B34;
		  /* 82195B34h */ case   18:  		/* lwz R11, <#[R11 + 4]> */
		/* 82195B34h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82195B34h case   18:*/		return 0x82195B38;
		  /* 82195B38h */ case   19:  		/* cmplwi CR6, R11, 0 */
		/* 82195B38h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82195B38h case   19:*/		return 0x82195B3C;
		  /* 82195B3Ch */ case   20:  		/* mr R11, R17 */
		/* 82195B3Ch case   20:*/		regs.R11 = regs.R17;
		/* 82195B3Ch case   20:*/		return 0x82195B40;
		  /* 82195B40h */ case   21:  		/* bc 4, CR6_EQ, 8 */
		/* 82195B40h case   21:*/		if ( !regs.CR[6].eq ) { return 0x82195B48;  }
		/* 82195B40h case   21:*/		return 0x82195B44;
	}
	return 0x82195B44;
} // Block from 82195AECh-82195B44h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82195B44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195B44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195B44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195B44);
		  /* 82195B44h */ case    0:  		/* li R11, 0 */
		/* 82195B44h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82195B44h case    0:*/		return 0x82195B48;
	}
	return 0x82195B48;
} // Block from 82195B44h-82195B48h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82195B48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195B48);
		  /* 82195B48h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82195B48h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82195B48h case    0:*/		return 0x82195B4C;
		  /* 82195B4Ch */ case    1:  		/* bc 12, CR0_EQ, 1356 */
		/* 82195B4Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82196098;  }
		/* 82195B4Ch case    1:*/		return 0x82195B50;
		  /* 82195B50h */ case    2:  		/* lwz R20, <#[R19 + 8]> */
		/* 82195B50h case    2:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R19 + 0x00000008) );
		/* 82195B50h case    2:*/		return 0x82195B54;
		  /* 82195B54h */ case    3:  		/* cmplwi CR6, R20, 0 */
		/* 82195B54h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 82195B54h case    3:*/		return 0x82195B58;
		  /* 82195B58h */ case    4:  		/* bc 12, CR6_EQ, 1344 */
		/* 82195B58h case    4:*/		if ( regs.CR[6].eq ) { return 0x82196098;  }
		/* 82195B58h case    4:*/		return 0x82195B5C;
		  /* 82195B5Ch */ case    5:  		/* lwz R22, <#[R20 + 4]> */
		/* 82195B5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R20 + 0x00000004) );
		/* 82195B5Ch case    5:*/		return 0x82195B60;
		  /* 82195B60h */ case    6:  		/* li R7, 1 */
		/* 82195B60h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82195B60h case    6:*/		return 0x82195B64;
		  /* 82195B64h */ case    7:  		/* li R6, 0 */
		/* 82195B64h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82195B64h case    7:*/		return 0x82195B68;
		  /* 82195B68h */ case    8:  		/* mr R5, R22 */
		/* 82195B68h case    8:*/		regs.R5 = regs.R22;
		/* 82195B68h case    8:*/		return 0x82195B6C;
		  /* 82195B6Ch */ case    9:  		/* mr R4, R21 */
		/* 82195B6Ch case    9:*/		regs.R4 = regs.R21;
		/* 82195B6Ch case    9:*/		return 0x82195B70;
		  /* 82195B70h */ case   10:  		/* mr R3, R18 */
		/* 82195B70h case   10:*/		regs.R3 = regs.R18;
		/* 82195B70h case   10:*/		return 0x82195B74;
		  /* 82195B74h */ case   11:  		/* bl 338316 */
		/* 82195B74h case   11:*/		regs.LR = 0x82195B78; return 0x821E8500;
		/* 82195B74h case   11:*/		return 0x82195B78;
		  /* 82195B78h */ case   12:  		/* or. R30, R3, R3 */
		/* 82195B78h case   12:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 82195B78h case   12:*/		return 0x82195B7C;
		  /* 82195B7Ch */ case   13:  		/* bc 12, CR0_EQ, 1300 */
		/* 82195B7Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x82196090;  }
		/* 82195B7Ch case   13:*/		return 0x82195B80;
		  /* 82195B80h */ case   14:  		/* lwz R11, <#[R22 + 76]> */
		/* 82195B80h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x0000004C) );
		/* 82195B80h case   14:*/		return 0x82195B84;
		  /* 82195B84h */ case   15:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 82195B84h case   15:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 82195B84h case   15:*/		return 0x82195B88;
		  /* 82195B88h */ case   16:  		/* bc 12, CR0_EQ, 1288 */
		/* 82195B88h case   16:*/		if ( regs.CR[0].eq ) { return 0x82196090;  }
		/* 82195B88h case   16:*/		return 0x82195B8C;
		  /* 82195B8Ch */ case   17:  		/* lwz R31, <#[R22 + 28]> */
		/* 82195B8Ch case   17:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R22 + 0x0000001C) );
		/* 82195B8Ch case   17:*/		return 0x82195B90;
		  /* 82195B90h */ case   18:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 82195B90h case   18:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 82195B90h case   18:*/		return 0x82195B94;
		  /* 82195B94h */ case   19:  		/* bc 4, CR0_EQ, 64 */
		/* 82195B94h case   19:*/		if ( !regs.CR[0].eq ) { return 0x82195BD4;  }
		/* 82195B94h case   19:*/		return 0x82195B98;
		  /* 82195B98h */ case   20:  		/* cmplwi CR0, R31, 0 */
		/* 82195B98h case   20:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 82195B98h case   20:*/		return 0x82195B9C;
		  /* 82195B9Ch */ case   21:  		/* bc 12, CR0_EQ, 56 */
		/* 82195B9Ch case   21:*/		if ( regs.CR[0].eq ) { return 0x82195BD4;  }
		/* 82195B9Ch case   21:*/		return 0x82195BA0;
		  /* 82195BA0h */ case   22:  		/* mr R3, R31 */
		/* 82195BA0h case   22:*/		regs.R3 = regs.R31;
		/* 82195BA0h case   22:*/		return 0x82195BA4;
		  /* 82195BA4h */ case   23:  		/* bl -167452 */
		/* 82195BA4h case   23:*/		regs.LR = 0x82195BA8; return 0x8216CD88;
		/* 82195BA4h case   23:*/		return 0x82195BA8;
		  /* 82195BA8h */ case   24:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82195BA8h case   24:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82195BA8h case   24:*/		return 0x82195BAC;
		  /* 82195BACh */ case   25:  		/* bc 4, CR0_EQ, 32 */
		/* 82195BACh case   25:*/		if ( !regs.CR[0].eq ) { return 0x82195BCC;  }
		/* 82195BACh case   25:*/		return 0x82195BB0;
		  /* 82195BB0h */ case   26:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82195BB0h case   26:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82195BB0h case   26:*/		return 0x82195BB4;
		  /* 82195BB4h */ case   27:  		/* lwz R31, <#[R11 + 40]> */
		/* 82195BB4h case   27:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000028) );
		/* 82195BB4h case   27:*/		return 0x82195BB8;
		  /* 82195BB8h */ case   28:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 82195BB8h case   28:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 82195BB8h case   28:*/		return 0x82195BBC;
		  /* 82195BBCh */ case   29:  		/* bc 4, CR0_EQ, 24 */
		/* 82195BBCh case   29:*/		if ( !regs.CR[0].eq ) { return 0x82195BD4;  }
		/* 82195BBCh case   29:*/		return 0x82195BC0;
		  /* 82195BC0h */ case   30:  		/* cmplwi CR6, R31, 0 */
		/* 82195BC0h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82195BC0h case   30:*/		return 0x82195BC4;
		  /* 82195BC4h */ case   31:  		/* bc 4, CR6_EQ, -36 */
		/* 82195BC4h case   31:*/		if ( !regs.CR[6].eq ) { return 0x82195BA0;  }
		/* 82195BC4h case   31:*/		return 0x82195BC8;
		  /* 82195BC8h */ case   32:  		/* b 12 */
		/* 82195BC8h case   32:*/		return 0x82195BD4;
		/* 82195BC8h case   32:*/		return 0x82195BCC;
	}
	return 0x82195BCC;
} // Block from 82195B48h-82195BCCh (33 instructions)

//////////////////////////////////////////////////////
// Block at 82195BCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195BCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195BCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195BCC);
		  /* 82195BCCh */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82195BCCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82195BCCh case    0:*/		return 0x82195BD0;
		  /* 82195BD0h */ case    1:  		/* bc 4, CR6_EQ, 1216 */
		/* 82195BD0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82196090;  }
		/* 82195BD0h case    1:*/		return 0x82195BD4;
	}
	return 0x82195BD4;
} // Block from 82195BCCh-82195BD4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82195BD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195BD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195BD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195BD4);
		  /* 82195BD4h */ case    0:  		/* li R10, 0 */
		/* 82195BD4h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82195BD4h case    0:*/		return 0x82195BD8;
		  /* 82195BD8h */ case    1:  		/* li R9, 0 */
		/* 82195BD8h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82195BD8h case    1:*/		return 0x82195BDC;
		  /* 82195BDCh */ case    2:  		/* li R8, 0 */
		/* 82195BDCh case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82195BDCh case    2:*/		return 0x82195BE0;
		  /* 82195BE0h */ case    3:  		/* addi R7, R1, 112 */
		/* 82195BE0h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x70);
		/* 82195BE0h case    3:*/		return 0x82195BE4;
		  /* 82195BE4h */ case    4:  		/* addi R6, R1, 104 */
		/* 82195BE4h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x68);
		/* 82195BE4h case    4:*/		return 0x82195BE8;
		  /* 82195BE8h */ case    5:  		/* addi R5, R1, 96 */
		/* 82195BE8h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 82195BE8h case    5:*/		return 0x82195BEC;
		  /* 82195BECh */ case    6:  		/* li R4, 0 */
		/* 82195BECh case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82195BECh case    6:*/		return 0x82195BF0;
		  /* 82195BF0h */ case    7:  		/* mr R3, R30 */
		/* 82195BF0h case    7:*/		regs.R3 = regs.R30;
		/* 82195BF0h case    7:*/		return 0x82195BF4;
		  /* 82195BF4h */ case    8:  		/* bl 579804 */
		/* 82195BF4h case    8:*/		regs.LR = 0x82195BF8; return 0x822234D0;
		/* 82195BF4h case    8:*/		return 0x82195BF8;
		  /* 82195BF8h */ case    9:  		/* lwz R23, <#[R19 + 8]> */
		/* 82195BF8h case    9:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R19 + 0x00000008) );
		/* 82195BF8h case    9:*/		return 0x82195BFC;
		  /* 82195BFCh */ case   10:  		/* cmplwi CR6, R23, 0 */
		/* 82195BFCh case   10:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 82195BFCh case   10:*/		return 0x82195C00;
		  /* 82195C00h */ case   11:  		/* bc 12, CR6_EQ, 1168 */
		/* 82195C00h case   11:*/		if ( regs.CR[6].eq ) { return 0x82196090;  }
		/* 82195C00h case   11:*/		return 0x82195C04;
		  /* 82195C04h */ case   12:  		/* lwz R31, <#[R23 + 4]> */
		/* 82195C04h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R23 + 0x00000004) );
		/* 82195C04h case   12:*/		return 0x82195C08;
		  /* 82195C08h */ case   13:  		/* cmplw CR6, R31, R22 */
		/* 82195C08h case   13:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R22);
		/* 82195C08h case   13:*/		return 0x82195C0C;
		  /* 82195C0Ch */ case   14:  		/* bc 12, CR6_EQ, 1148 */
		/* 82195C0Ch case   14:*/		if ( regs.CR[6].eq ) { return 0x82196088;  }
		/* 82195C0Ch case   14:*/		return 0x82195C10;
		  /* 82195C10h */ case   15:  		/* lwz R11, <#[R31 + 48]> */
		/* 82195C10h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82195C10h case   15:*/		return 0x82195C14;
		  /* 82195C14h */ case   16:  		/* lwz R10, <#[R19 + 40]> */
		/* 82195C14h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R19 + 0x00000028) );
		/* 82195C14h case   16:*/		return 0x82195C18;
		  /* 82195C18h */ case   17:  		/* rlwinm R9, R11, 0, 13, 31 */
		/* 82195C18h case   17:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R9,regs.R11);
		/* 82195C18h case   17:*/		return 0x82195C1C;
		  /* 82195C1Ch */ case   18:  		/* rlwinm R11, R9, 27, 5, 31 */
		/* 82195C1Ch case   18:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R9);
		/* 82195C1Ch case   18:*/		return 0x82195C20;
		  /* 82195C20h */ case   19:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 82195C20h case   19:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 82195C20h case   19:*/		return 0x82195C24;
		  /* 82195C24h */ case   20:  		/* addi R11, R11, 1 */
		/* 82195C24h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82195C24h case   20:*/		return 0x82195C28;
		  /* 82195C28h */ case   21:  		/* slw R9, R17, R9 */
		/* 82195C28h case   21:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R17,regs.R9);
		/* 82195C28h case   21:*/		return 0x82195C2C;
		  /* 82195C2Ch */ case   22:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82195C2Ch case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82195C2Ch case   22:*/		return 0x82195C30;
		  /* 82195C30h */ case   23:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82195C30h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82195C30h case   23:*/		return 0x82195C34;
		  /* 82195C34h */ case   24:  		/* and. R11, R11, R9 */
		/* 82195C34h case   24:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82195C34h case   24:*/		return 0x82195C38;
		  /* 82195C38h */ case   25:  		/* bc 4, CR0_EQ, 1104 */
		/* 82195C38h case   25:*/		if ( !regs.CR[0].eq ) { return 0x82196088;  }
		/* 82195C38h case   25:*/		return 0x82195C3C;
		  /* 82195C3Ch */ case   26:  		/* li R7, 1 */
		/* 82195C3Ch case   26:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82195C3Ch case   26:*/		return 0x82195C40;
		  /* 82195C40h */ case   27:  		/* li R6, 0 */
		/* 82195C40h case   27:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82195C40h case   27:*/		return 0x82195C44;
		  /* 82195C44h */ case   28:  		/* mr R5, R31 */
		/* 82195C44h case   28:*/		regs.R5 = regs.R31;
		/* 82195C44h case   28:*/		return 0x82195C48;
		  /* 82195C48h */ case   29:  		/* mr R4, R21 */
		/* 82195C48h case   29:*/		regs.R4 = regs.R21;
		/* 82195C48h case   29:*/		return 0x82195C4C;
		  /* 82195C4Ch */ case   30:  		/* mr R3, R18 */
		/* 82195C4Ch case   30:*/		regs.R3 = regs.R18;
		/* 82195C4Ch case   30:*/		return 0x82195C50;
		  /* 82195C50h */ case   31:  		/* bl 338096 */
		/* 82195C50h case   31:*/		regs.LR = 0x82195C54; return 0x821E8500;
		/* 82195C50h case   31:*/		return 0x82195C54;
		  /* 82195C54h */ case   32:  		/* cmplwi CR0, R3, 0 */
		/* 82195C54h case   32:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82195C54h case   32:*/		return 0x82195C58;
		  /* 82195C58h */ case   33:  		/* bc 12, CR0_EQ, 1072 */
		/* 82195C58h case   33:*/		if ( regs.CR[0].eq ) { return 0x82196088;  }
		/* 82195C58h case   33:*/		return 0x82195C5C;
		  /* 82195C5Ch */ case   34:  		/* li R10, 0 */
		/* 82195C5Ch case   34:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82195C5Ch case   34:*/		return 0x82195C60;
		  /* 82195C60h */ case   35:  		/* li R9, 0 */
		/* 82195C60h case   35:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82195C60h case   35:*/		return 0x82195C64;
		  /* 82195C64h */ case   36:  		/* li R8, 0 */
		/* 82195C64h case   36:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82195C64h case   36:*/		return 0x82195C68;
		  /* 82195C68h */ case   37:  		/* addi R7, R1, 120 */
		/* 82195C68h case   37:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x78);
		/* 82195C68h case   37:*/		return 0x82195C6C;
		  /* 82195C6Ch */ case   38:  		/* addi R6, R1, 124 */
		/* 82195C6Ch case   38:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x7C);
		/* 82195C6Ch case   38:*/		return 0x82195C70;
		  /* 82195C70h */ case   39:  		/* addi R5, R1, 84 */
		/* 82195C70h case   39:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 82195C70h case   39:*/		return 0x82195C74;
		  /* 82195C74h */ case   40:  		/* li R4, 0 */
		/* 82195C74h case   40:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82195C74h case   40:*/		return 0x82195C78;
		  /* 82195C78h */ case   41:  		/* bl 579672 */
		/* 82195C78h case   41:*/		regs.LR = 0x82195C7C; return 0x822234D0;
		/* 82195C78h case   41:*/		return 0x82195C7C;
		  /* 82195C7Ch */ case   42:  		/* lwz R11, <#[R1 + 84]> */
		/* 82195C7Ch case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82195C7Ch case   42:*/		return 0x82195C80;
		  /* 82195C80h */ case   43:  		/* lwz R11, <#[R11 + 28]> */
		/* 82195C80h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82195C80h case   43:*/		return 0x82195C84;
		  /* 82195C84h */ case   44:  		/* cmplw CR6, R11, R31 */
		/* 82195C84h case   44:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 82195C84h case   44:*/		return 0x82195C88;
		  /* 82195C88h */ case   45:  		/* bc 4, CR6_EQ, 1024 */
		/* 82195C88h case   45:*/		if ( !regs.CR[6].eq ) { return 0x82196088;  }
		/* 82195C88h case   45:*/		return 0x82195C8C;
		  /* 82195C8Ch */ case   46:  		/* li R5, 28 */
		/* 82195C8Ch case   46:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 82195C8Ch case   46:*/		return 0x82195C90;
		  /* 82195C90h */ case   47:  		/* li R4, 8 */
		/* 82195C90h case   47:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 82195C90h case   47:*/		return 0x82195C94;
		  /* 82195C94h */ case   48:  		/* mr R3, R18 */
		/* 82195C94h case   48:*/		regs.R3 = regs.R18;
		/* 82195C94h case   48:*/		return 0x82195C98;
		  /* 82195C98h */ case   49:  		/* bl -201640 */
		/* 82195C98h case   49:*/		regs.LR = 0x82195C9C; return 0x821648F0;
		/* 82195C98h case   49:*/		return 0x82195C9C;
		  /* 82195C9Ch */ case   50:  		/* addi R24, R3, 4 */
		/* 82195C9Ch case   50:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R3,0x4);
		/* 82195C9Ch case   50:*/		return 0x82195CA0;
		  /* 82195CA0h */ case   51:  		/* ori R11, R3, 1 */
		/* 82195CA0h case   51:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R3,0x1);
		/* 82195CA0h case   51:*/		return 0x82195CA4;
		  /* 82195CA4h */ case   52:  		/* ori R10, R24, 1 */
		/* 82195CA4h case   52:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R24,0x1);
		/* 82195CA4h case   52:*/		return 0x82195CA8;
		  /* 82195CA8h */ case   53:  		/* stw R11, <#[R3 + 4]> */
		/* 82195CA8h case   53:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82195CA8h case   53:*/		return 0x82195CAC;
		  /* 82195CACh */ case   54:  		/* mr R27, R3 */
		/* 82195CACh case   54:*/		regs.R27 = regs.R3;
		/* 82195CACh case   54:*/		return 0x82195CB0;
		  /* 82195CB0h */ case   55:  		/* stw R10, <#[R3]> */
		/* 82195CB0h case   55:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82195CB0h case   55:*/		return 0x82195CB4;
		  /* 82195CB4h */ case   56:  		/* li R5, 38 */
		/* 82195CB4h case   56:*/		cpu::op::li<0>(regs,&regs.R5,0x26);
		/* 82195CB4h case   56:*/		return 0x82195CB8;
		  /* 82195CB8h */ case   57:  		/* li R4, 8 */
		/* 82195CB8h case   57:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 82195CB8h case   57:*/		return 0x82195CBC;
		  /* 82195CBCh */ case   58:  		/* mr R3, R18 */
		/* 82195CBCh case   58:*/		regs.R3 = regs.R18;
		/* 82195CBCh case   58:*/		return 0x82195CC0;
		  /* 82195CC0h */ case   59:  		/* bl -201680 */
		/* 82195CC0h case   59:*/		regs.LR = 0x82195CC4; return 0x821648F0;
		/* 82195CC0h case   59:*/		return 0x82195CC4;
		  /* 82195CC4h */ case   60:  		/* addi R26, R3, 4 */
		/* 82195CC4h case   60:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R3,0x4);
		/* 82195CC4h case   60:*/		return 0x82195CC8;
		  /* 82195CC8h */ case   61:  		/* ori R11, R3, 1 */
		/* 82195CC8h case   61:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R3,0x1);
		/* 82195CC8h case   61:*/		return 0x82195CCC;
		  /* 82195CCCh */ case   62:  		/* ori R10, R26, 1 */
		/* 82195CCCh case   62:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R26,0x1);
		/* 82195CCCh case   62:*/		return 0x82195CD0;
		  /* 82195CD0h */ case   63:  		/* stw R11, <#[R3 + 4]> */
		/* 82195CD0h case   63:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82195CD0h case   63:*/		return 0x82195CD4;
		  /* 82195CD4h */ case   64:  		/* mr R28, R3 */
		/* 82195CD4h case   64:*/		regs.R28 = regs.R3;
		/* 82195CD4h case   64:*/		return 0x82195CD8;
		  /* 82195CD8h */ case   65:  		/* stw R10, <#[R3]> */
		/* 82195CD8h case   65:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82195CD8h case   65:*/		return 0x82195CDC;
		  /* 82195CDCh */ case   66:  		/* lwz R11, <#[R31 + 20]> */
		/* 82195CDCh case   66:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82195CDCh case   66:*/		return 0x82195CE0;
		  /* 82195CE0h */ case   67:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82195CE0h case   67:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82195CE0h case   67:*/		return 0x82195CE4;
		  /* 82195CE4h */ case   68:  		/* bc 4, CR0_EQ, 732 */
		/* 82195CE4h case   68:*/		if ( !regs.CR[0].eq ) { return 0x82195FC0;  }
		/* 82195CE4h case   68:*/		return 0x82195CE8;
		  /* 82195CE8h */ case   69:  		/* mr R25, R11 */
		/* 82195CE8h case   69:*/		regs.R25 = regs.R11;
		/* 82195CE8h case   69:*/		return 0x82195CEC;
		  /* 82195CECh */ case   70:  		/* cmplwi CR0, R11, 0 */
		/* 82195CECh case   70:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82195CECh case   70:*/		return 0x82195CF0;
		  /* 82195CF0h */ case   71:  		/* bc 12, CR0_EQ, 720 */
		/* 82195CF0h case   71:*/		if ( regs.CR[0].eq ) { return 0x82195FC0;  }
		/* 82195CF0h case   71:*/		return 0x82195CF4;
		  /* 82195CF4h */ case   72:  		/* lwz R11, <#[R25 + 8]> */
		/* 82195CF4h case   72:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 82195CF4h case   72:*/		return 0x82195CF8;
		  /* 82195CF8h */ case   73:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82195CF8h case   73:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82195CF8h case   73:*/		return 0x82195CFC;
		  /* 82195CFCh */ case   74:  		/* cmplwi CR6, R11, 14336 */
		/* 82195CFCh case   74:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 82195CFCh case   74:*/		return 0x82195D00;
		  /* 82195D00h */ case   75:  		/* bc 4, CR6_EQ, 676 */
		/* 82195D00h case   75:*/		if ( !regs.CR[6].eq ) { return 0x82195FA4;  }
		/* 82195D00h case   75:*/		return 0x82195D04;
		  /* 82195D04h */ case   76:  		/* lwz R3, <#[R25]> */
		/* 82195D04h case   76:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R25 + 0x00000000) );
		/* 82195D04h case   76:*/		return 0x82195D08;
		  /* 82195D08h */ case   77:  		/* cmplwi CR6, R3, 0 */
		/* 82195D08h case   77:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82195D08h case   77:*/		return 0x82195D0C;
		  /* 82195D0Ch */ case   78:  		/* bc 12, CR6_EQ, 20 */
		/* 82195D0Ch case   78:*/		if ( regs.CR[6].eq ) { return 0x82195D20;  }
		/* 82195D0Ch case   78:*/		return 0x82195D10;
		  /* 82195D10h */ case   79:  		/* lwz R11, <#[R3 + 4]> */
		/* 82195D10h case   79:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82195D10h case   79:*/		return 0x82195D14;
		  /* 82195D14h */ case   80:  		/* cmplwi CR6, R11, 0 */
		/* 82195D14h case   80:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82195D14h case   80:*/		return 0x82195D18;
		  /* 82195D18h */ case   81:  		/* mr R11, R17 */
		/* 82195D18h case   81:*/		regs.R11 = regs.R17;
		/* 82195D18h case   81:*/		return 0x82195D1C;
		  /* 82195D1Ch */ case   82:  		/* bc 4, CR6_EQ, 8 */
		/* 82195D1Ch case   82:*/		if ( !regs.CR[6].eq ) { return 0x82195D24;  }
		/* 82195D1Ch case   82:*/		return 0x82195D20;
	}
	return 0x82195D20;
} // Block from 82195BD4h-82195D20h (83 instructions)

//////////////////////////////////////////////////////
// Block at 82195D20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195D20);
		  /* 82195D20h */ case    0:  		/* li R11, 0 */
		/* 82195D20h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82195D20h case    0:*/		return 0x82195D24;
	}
	return 0x82195D24;
} // Block from 82195D20h-82195D24h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82195D24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195D24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195D24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195D24);
		  /* 82195D24h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82195D24h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82195D24h case    0:*/		return 0x82195D28;
		  /* 82195D28h */ case    1:  		/* bc 4, CR0_EQ, 636 */
		/* 82195D28h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82195FA4;  }
		/* 82195D28h case    1:*/		return 0x82195D2C;
		  /* 82195D2Ch */ case    2:  		/* cmpwi CR6, R3, 0 */
		/* 82195D2Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82195D2Ch case    2:*/		return 0x82195D30;
		  /* 82195D30h */ case    3:  		/* bc 12, CR6_EQ, 968 */
		/* 82195D30h case    3:*/		if ( regs.CR[6].eq ) { return 0x821960F8;  }
		/* 82195D30h case    3:*/		return 0x82195D34;
		  /* 82195D34h */ case    4:  		/* li R10, 0 */
		/* 82195D34h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82195D34h case    4:*/		return 0x82195D38;
		  /* 82195D38h */ case    5:  		/* li R9, 0 */
		/* 82195D38h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82195D38h case    5:*/		return 0x82195D3C;
		  /* 82195D3Ch */ case    6:  		/* li R8, 0 */
		/* 82195D3Ch case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82195D3Ch case    6:*/		return 0x82195D40;
		  /* 82195D40h */ case    7:  		/* addi R7, R1, 116 */
		/* 82195D40h case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x74);
		/* 82195D40h case    7:*/		return 0x82195D44;
		  /* 82195D44h */ case    8:  		/* addi R6, R1, 108 */
		/* 82195D44h case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x6C);
		/* 82195D44h case    8:*/		return 0x82195D48;
		  /* 82195D48h */ case    9:  		/* addi R5, R1, 100 */
		/* 82195D48h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x64);
		/* 82195D48h case    9:*/		return 0x82195D4C;
		  /* 82195D4Ch */ case   10:  		/* li R4, 0 */
		/* 82195D4Ch case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82195D4Ch case   10:*/		return 0x82195D50;
		  /* 82195D50h */ case   11:  		/* bl 579456 */
		/* 82195D50h case   11:*/		regs.LR = 0x82195D54; return 0x822234D0;
		/* 82195D50h case   11:*/		return 0x82195D54;
		  /* 82195D54h */ case   12:  		/* lwz R11, <#[R1 + 96]> */
		/* 82195D54h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82195D54h case   12:*/		return 0x82195D58;
		  /* 82195D58h */ case   13:  		/* lwz R10, <#[R1 + 100]> */
		/* 82195D58h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000064) );
		/* 82195D58h case   13:*/		return 0x82195D5C;
		  /* 82195D5Ch */ case   14:  		/* cmplw CR6, R10, R11 */
		/* 82195D5Ch case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82195D5Ch case   14:*/		return 0x82195D60;
		  /* 82195D60h */ case   15:  		/* bc 4, CR6_EQ, 580 */
		/* 82195D60h case   15:*/		if ( !regs.CR[6].eq ) { return 0x82195FA4;  }
		/* 82195D60h case   15:*/		return 0x82195D64;
		  /* 82195D64h */ case   16:  		/* lwz R11, <#[R1 + 104]> */
		/* 82195D64h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 82195D64h case   16:*/		return 0x82195D68;
		  /* 82195D68h */ case   17:  		/* lwz R10, <#[R1 + 108]> */
		/* 82195D68h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000006C) );
		/* 82195D68h case   17:*/		return 0x82195D6C;
		  /* 82195D6Ch */ case   18:  		/* cmpw CR6, R10, R11 */
		/* 82195D6Ch case   18:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 82195D6Ch case   18:*/		return 0x82195D70;
		  /* 82195D70h */ case   19:  		/* bc 4, CR6_EQ, 564 */
		/* 82195D70h case   19:*/		if ( !regs.CR[6].eq ) { return 0x82195FA4;  }
		/* 82195D70h case   19:*/		return 0x82195D74;
		  /* 82195D74h */ case   20:  		/* lwz R11, <#[R1 + 112]> */
		/* 82195D74h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 82195D74h case   20:*/		return 0x82195D78;
		  /* 82195D78h */ case   21:  		/* lwz R10, <#[R1 + 116]> */
		/* 82195D78h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000074) );
		/* 82195D78h case   21:*/		return 0x82195D7C;
		  /* 82195D7Ch */ case   22:  		/* cmplw CR6, R10, R11 */
		/* 82195D7Ch case   22:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82195D7Ch case   22:*/		return 0x82195D80;
		  /* 82195D80h */ case   23:  		/* bc 4, CR6_EQ, 548 */
		/* 82195D80h case   23:*/		if ( !regs.CR[6].eq ) { return 0x82195FA4;  }
		/* 82195D80h case   23:*/		return 0x82195D84;
		  /* 82195D84h */ case   24:  		/* mr R7, R18 */
		/* 82195D84h case   24:*/		regs.R7 = regs.R18;
		/* 82195D84h case   24:*/		return 0x82195D88;
		  /* 82195D88h */ case   25:  		/* lwz R3, <#[R1 + 84]> */
		/* 82195D88h case   25:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 82195D88h case   25:*/		return 0x82195D8C;
		  /* 82195D8Ch */ case   26:  		/* li R6, 1 */
		/* 82195D8Ch case   26:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82195D8Ch case   26:*/		return 0x82195D90;
		  /* 82195D90h */ case   27:  		/* li R5, 0 */
		/* 82195D90h case   27:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82195D90h case   27:*/		return 0x82195D94;
		  /* 82195D94h */ case   28:  		/* mr R4, R25 */
		/* 82195D94h case   28:*/		regs.R4 = regs.R25;
		/* 82195D94h case   28:*/		return 0x82195D98;
		  /* 82195D98h */ case   29:  		/* bl 613536 */
		/* 82195D98h case   29:*/		regs.LR = 0x82195D9C; return 0x8222BA38;
		/* 82195D98h case   29:*/		return 0x82195D9C;
		  /* 82195D9Ch */ case   30:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82195D9Ch case   30:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82195D9Ch case   30:*/		return 0x82195DA0;
		  /* 82195DA0h */ case   31:  		/* bc 12, CR0_EQ, 516 */
		/* 82195DA0h case   31:*/		if ( regs.CR[0].eq ) { return 0x82195FA4;  }
		/* 82195DA0h case   31:*/		return 0x82195DA4;
		  /* 82195DA4h */ case   32:  		/* lwz R30, <#[R25 + 4]> */
		/* 82195DA4h case   32:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R25 + 0x00000004) );
		/* 82195DA4h case   32:*/		return 0x82195DA8;
		  /* 82195DA8h */ case   33:  		/* li R29, 0 */
		/* 82195DA8h case   33:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82195DA8h case   33:*/		return 0x82195DAC;
		  /* 82195DACh */ case   34:  		/* cmplwi CR6, R30, 0 */
		/* 82195DACh case   34:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82195DACh case   34:*/		return 0x82195DB0;
		  /* 82195DB0h */ case   35:  		/* bc 12, CR6_EQ, 148 */
		/* 82195DB0h case   35:*/		if ( regs.CR[6].eq ) { return 0x82195E44;  }
		/* 82195DB0h case   35:*/		return 0x82195DB4;
		  /* 82195DB4h */ case   36:  		/* lwz R31, <#[R30 + 16]> */
		/* 82195DB4h case   36:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000010) );
		/* 82195DB4h case   36:*/		return 0x82195DB8;
		  /* 82195DB8h */ case   37:  		/* cmplwi CR6, R31, 0 */
		/* 82195DB8h case   37:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82195DB8h case   37:*/		return 0x82195DBC;
		  /* 82195DBCh */ case   38:  		/* bc 12, CR6_EQ, 128 */
		/* 82195DBCh case   38:*/		if ( regs.CR[6].eq ) { return 0x82195E3C;  }
		/* 82195DBCh case   38:*/		return 0x82195DC0;
		  /* 82195DC0h */ case   39:  		/* lwz R11, <#[R31 + 8]> */
		/* 82195DC0h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82195DC0h case   39:*/		return 0x82195DC4;
		  /* 82195DC4h */ case   40:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82195DC4h case   40:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82195DC4h case   40:*/		return 0x82195DC8;
		  /* 82195DC8h */ case   41:  		/* cmplwi CR6, R11, 14080 */
		/* 82195DC8h case   41:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 82195DC8h case   41:*/		return 0x82195DCC;
		  /* 82195DCCh */ case   42:  		/* bc 4, CR6_EQ, 12 */
		/* 82195DCCh case   42:*/		if ( !regs.CR[6].eq ) { return 0x82195DD8;  }
		/* 82195DCCh case   42:*/		return 0x82195DD0;
		  /* 82195DD0h */ case   43:  		/* mr R29, R31 */
		/* 82195DD0h case   43:*/		regs.R29 = regs.R31;
		/* 82195DD0h case   43:*/		return 0x82195DD4;
		  /* 82195DD4h */ case   44:  		/* b 104 */
		/* 82195DD4h case   44:*/		return 0x82195E3C;
		/* 82195DD4h case   44:*/		return 0x82195DD8;
	}
	return 0x82195DD8;
} // Block from 82195D24h-82195DD8h (45 instructions)

//////////////////////////////////////////////////////
// Block at 82195DD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195DD8);
		  /* 82195DD8h */ case    0:  		/* mr R3, R31 */
		/* 82195DD8h case    0:*/		regs.R3 = regs.R31;
		/* 82195DD8h case    0:*/		return 0x82195DDC;
		  /* 82195DDCh */ case    1:  		/* bl -149044 */
		/* 82195DDCh case    1:*/		regs.LR = 0x82195DE0; return 0x821717A8;
		/* 82195DDCh case    1:*/		return 0x82195DE0;
		  /* 82195DE0h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82195DE0h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82195DE0h case    2:*/		return 0x82195DE4;
		  /* 82195DE4h */ case    3:  		/* bc 12, CR0_EQ, 88 */
		/* 82195DE4h case    3:*/		if ( regs.CR[0].eq ) { return 0x82195E3C;  }
		/* 82195DE4h case    3:*/		return 0x82195DE8;
		  /* 82195DE8h */ case    4:  		/* lwz R11, <#[R26]> */
		/* 82195DE8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82195DE8h case    4:*/		return 0x82195DEC;
		  /* 82195DECh */ case    5:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82195DECh case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82195DECh case    5:*/		return 0x82195DF0;
		  /* 82195DF0h */ case    6:  		/* bc 4, CR0_EQ, 40 */
		/* 82195DF0h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82195E18;  }
		/* 82195DF0h case    6:*/		return 0x82195DF4;
		  /* 82195DF4h */ case    7:  		/* lwz R11, <#[R28]> */
		/* 82195DF4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82195DF4h case    7:*/		return 0x82195DF8;
		  /* 82195DF8h */ case    8:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82195DF8h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82195DF8h case    8:*/		return 0x82195DFC;
		  /* 82195DFCh */ case    9:  		/* addic. R3, R11, -4 */
		/* 82195DFCh case    9:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R11,0xFFFFFFFC);
		/* 82195DFCh case    9:*/		return 0x82195E00;
		  /* 82195E00h */ case   10:  		/* bc 12, CR0_EQ, 24 */
		/* 82195E00h case   10:*/		if ( regs.CR[0].eq ) { return 0x82195E18;  }
		/* 82195E00h case   10:*/		return 0x82195E04;
		  /* 82195E04h */ case   11:  		/* lwz R11, <#[R3 + 8]> */
		/* 82195E04h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82195E04h case   11:*/		return 0x82195E08;
		  /* 82195E08h */ case   12:  		/* lwz R10, <#[R3 + 12]> */
		/* 82195E08h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 82195E08h case   12:*/		return 0x82195E0C;
		  /* 82195E0Ch */ case   13:  		/* addi R11, R11, 1 */
		/* 82195E0Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82195E0Ch case   13:*/		return 0x82195E10;
		  /* 82195E10h */ case   14:  		/* cmplw CR6, R11, R10 */
		/* 82195E10h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82195E10h case   14:*/		return 0x82195E14;
		  /* 82195E14h */ case   15:  		/* bc 4, CR6_GT, 16 */
		/* 82195E14h case   15:*/		if ( !regs.CR[6].gt ) { return 0x82195E24;  }
		/* 82195E14h case   15:*/		return 0x82195E18;
	}
	return 0x82195E18;
} // Block from 82195DD8h-82195E18h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82195E18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195E18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195E18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195E18);
		  /* 82195E18h */ case    0:  		/* li R4, 1 */
		/* 82195E18h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82195E18h case    0:*/		return 0x82195E1C;
		  /* 82195E1Ch */ case    1:  		/* mr R3, R28 */
		/* 82195E1Ch case    1:*/		regs.R3 = regs.R28;
		/* 82195E1Ch case    1:*/		return 0x82195E20;
		  /* 82195E20h */ case    2:  		/* bl -36184 */
		/* 82195E20h case    2:*/		regs.LR = 0x82195E24; return 0x8218D0C8;
		/* 82195E20h case    2:*/		return 0x82195E24;
	}
	return 0x82195E24;
} // Block from 82195E18h-82195E24h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82195E24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195E24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195E24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195E24);
		  /* 82195E24h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82195E24h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82195E24h case    0:*/		return 0x82195E28;
		  /* 82195E28h */ case    1:  		/* addi R10, R11, 4 */
		/* 82195E28h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82195E28h case    1:*/		return 0x82195E2C;
		  /* 82195E2Ch */ case    2:  		/* addi R9, R11, 1 */
		/* 82195E2Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 82195E2Ch case    2:*/		return 0x82195E30;
		  /* 82195E30h */ case    3:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 82195E30h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 82195E30h case    3:*/		return 0x82195E34;
		  /* 82195E34h */ case    4:  		/* stw R9, <#[R3 + 8]> */
		/* 82195E34h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 82195E34h case    4:*/		return 0x82195E38;
		  /* 82195E38h */ case    5:  		/* stwx R31, <#[R11 + R3]> */
		/* 82195E38h case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82195E38h case    5:*/		return 0x82195E3C;
	}
	return 0x82195E3C;
} // Block from 82195E24h-82195E3Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82195E3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195E3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195E3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195E3C);
		  /* 82195E3Ch */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 82195E3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 82195E3Ch case    0:*/		return 0x82195E40;
		  /* 82195E40h */ case    1:  		/* b -148 */
		/* 82195E40h case    1:*/		return 0x82195DAC;
		/* 82195E40h case    1:*/		return 0x82195E44;
	}
	return 0x82195E44;
} // Block from 82195E3Ch-82195E44h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82195E44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195E44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195E44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195E44);
		  /* 82195E44h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 82195E44h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82195E44h case    0:*/		return 0x82195E48;
		  /* 82195E48h */ case    1:  		/* bc 12, CR6_EQ, 136 */
		/* 82195E48h case    1:*/		if ( regs.CR[6].eq ) { return 0x82195ED0;  }
		/* 82195E48h case    1:*/		return 0x82195E4C;
		  /* 82195E4Ch */ case    2:  		/* lwz R30, <#[R29 + 4]> */
		/* 82195E4Ch case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000004) );
		/* 82195E4Ch case    2:*/		return 0x82195E50;
		  /* 82195E50h */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 82195E50h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82195E50h case    3:*/		return 0x82195E54;
		  /* 82195E54h */ case    4:  		/* bc 12, CR6_EQ, 124 */
		/* 82195E54h case    4:*/		if ( regs.CR[6].eq ) { return 0x82195ED0;  }
		/* 82195E54h case    4:*/		return 0x82195E58;
		  /* 82195E58h */ case    5:  		/* lwz R31, <#[R30 + 16]> */
		/* 82195E58h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000010) );
		/* 82195E58h case    5:*/		return 0x82195E5C;
		  /* 82195E5Ch */ case    6:  		/* cmplwi CR6, R31, 0 */
		/* 82195E5Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82195E5Ch case    6:*/		return 0x82195E60;
		  /* 82195E60h */ case    7:  		/* bc 12, CR6_EQ, 104 */
		/* 82195E60h case    7:*/		if ( regs.CR[6].eq ) { return 0x82195EC8;  }
		/* 82195E60h case    7:*/		return 0x82195E64;
		  /* 82195E64h */ case    8:  		/* mr R3, R31 */
		/* 82195E64h case    8:*/		regs.R3 = regs.R31;
		/* 82195E64h case    8:*/		return 0x82195E68;
		  /* 82195E68h */ case    9:  		/* bl -149184 */
		/* 82195E68h case    9:*/		regs.LR = 0x82195E6C; return 0x821717A8;
		/* 82195E68h case    9:*/		return 0x82195E6C;
		  /* 82195E6Ch */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82195E6Ch case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82195E6Ch case   10:*/		return 0x82195E70;
		  /* 82195E70h */ case   11:  		/* bc 12, CR0_EQ, 88 */
		/* 82195E70h case   11:*/		if ( regs.CR[0].eq ) { return 0x82195EC8;  }
		/* 82195E70h case   11:*/		return 0x82195E74;
		  /* 82195E74h */ case   12:  		/* lwz R11, <#[R26]> */
		/* 82195E74h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82195E74h case   12:*/		return 0x82195E78;
		  /* 82195E78h */ case   13:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82195E78h case   13:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82195E78h case   13:*/		return 0x82195E7C;
		  /* 82195E7Ch */ case   14:  		/* bc 4, CR0_EQ, 40 */
		/* 82195E7Ch case   14:*/		if ( !regs.CR[0].eq ) { return 0x82195EA4;  }
		/* 82195E7Ch case   14:*/		return 0x82195E80;
		  /* 82195E80h */ case   15:  		/* lwz R11, <#[R28]> */
		/* 82195E80h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82195E80h case   15:*/		return 0x82195E84;
		  /* 82195E84h */ case   16:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82195E84h case   16:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82195E84h case   16:*/		return 0x82195E88;
		  /* 82195E88h */ case   17:  		/* addic. R3, R11, -4 */
		/* 82195E88h case   17:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R11,0xFFFFFFFC);
		/* 82195E88h case   17:*/		return 0x82195E8C;
		  /* 82195E8Ch */ case   18:  		/* bc 12, CR0_EQ, 24 */
		/* 82195E8Ch case   18:*/		if ( regs.CR[0].eq ) { return 0x82195EA4;  }
		/* 82195E8Ch case   18:*/		return 0x82195E90;
		  /* 82195E90h */ case   19:  		/* lwz R11, <#[R3 + 8]> */
		/* 82195E90h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82195E90h case   19:*/		return 0x82195E94;
		  /* 82195E94h */ case   20:  		/* lwz R10, <#[R3 + 12]> */
		/* 82195E94h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 82195E94h case   20:*/		return 0x82195E98;
		  /* 82195E98h */ case   21:  		/* addi R11, R11, 1 */
		/* 82195E98h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82195E98h case   21:*/		return 0x82195E9C;
		  /* 82195E9Ch */ case   22:  		/* cmplw CR6, R11, R10 */
		/* 82195E9Ch case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82195E9Ch case   22:*/		return 0x82195EA0;
		  /* 82195EA0h */ case   23:  		/* bc 4, CR6_GT, 16 */
		/* 82195EA0h case   23:*/		if ( !regs.CR[6].gt ) { return 0x82195EB0;  }
		/* 82195EA0h case   23:*/		return 0x82195EA4;
	}
	return 0x82195EA4;
} // Block from 82195E44h-82195EA4h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82195EA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195EA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195EA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195EA4);
		  /* 82195EA4h */ case    0:  		/* li R4, 1 */
		/* 82195EA4h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82195EA4h case    0:*/		return 0x82195EA8;
		  /* 82195EA8h */ case    1:  		/* mr R3, R28 */
		/* 82195EA8h case    1:*/		regs.R3 = regs.R28;
		/* 82195EA8h case    1:*/		return 0x82195EAC;
		  /* 82195EACh */ case    2:  		/* bl -36324 */
		/* 82195EACh case    2:*/		regs.LR = 0x82195EB0; return 0x8218D0C8;
		/* 82195EACh case    2:*/		return 0x82195EB0;
	}
	return 0x82195EB0;
} // Block from 82195EA4h-82195EB0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82195EB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195EB0);
		  /* 82195EB0h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82195EB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82195EB0h case    0:*/		return 0x82195EB4;
		  /* 82195EB4h */ case    1:  		/* addi R10, R11, 4 */
		/* 82195EB4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82195EB4h case    1:*/		return 0x82195EB8;
		  /* 82195EB8h */ case    2:  		/* addi R9, R11, 1 */
		/* 82195EB8h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 82195EB8h case    2:*/		return 0x82195EBC;
		  /* 82195EBCh */ case    3:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 82195EBCh case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 82195EBCh case    3:*/		return 0x82195EC0;
		  /* 82195EC0h */ case    4:  		/* stw R9, <#[R3 + 8]> */
		/* 82195EC0h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 82195EC0h case    4:*/		return 0x82195EC4;
		  /* 82195EC4h */ case    5:  		/* stwx R31, <#[R11 + R3]> */
		/* 82195EC4h case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82195EC4h case    5:*/		return 0x82195EC8;
	}
	return 0x82195EC8;
} // Block from 82195EB0h-82195EC8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82195EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195EC8);
		  /* 82195EC8h */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 82195EC8h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 82195EC8h case    0:*/		return 0x82195ECC;
		  /* 82195ECCh */ case    1:  		/* b -124 */
		/* 82195ECCh case    1:*/		return 0x82195E50;
		/* 82195ECCh case    1:*/		return 0x82195ED0;
	}
	return 0x82195ED0;
} // Block from 82195EC8h-82195ED0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82195ED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195ED0);
		  /* 82195ED0h */ case    0:  		/* lwz R11, <#[R26]> */
		/* 82195ED0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82195ED0h case    0:*/		return 0x82195ED4;
		  /* 82195ED4h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82195ED4h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82195ED4h case    1:*/		return 0x82195ED8;
		  /* 82195ED8h */ case    2:  		/* bc 4, CR0_EQ, 184 */
		/* 82195ED8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82195F90;  }
		/* 82195ED8h case    2:*/		return 0x82195EDC;
		  /* 82195EDCh */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 82195EDCh case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82195EDCh case    3:*/		return 0x82195EE0;
		  /* 82195EE0h */ case    4:  		/* bc 12, CR0_EQ, 176 */
		/* 82195EE0h case    4:*/		if ( regs.CR[0].eq ) { return 0x82195F90;  }
		/* 82195EE0h case    4:*/		return 0x82195EE4;
		  /* 82195EE4h */ case    5:  		/* lwz R11, <#[R28]> */
		/* 82195EE4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82195EE4h case    5:*/		return 0x82195EE8;
		  /* 82195EE8h */ case    6:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82195EE8h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82195EE8h case    6:*/		return 0x82195EEC;
		  /* 82195EECh */ case    7:  		/* addi R4, R11, -4 */
		/* 82195EECh case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 82195EECh case    7:*/		return 0x82195EF0;
		  /* 82195EF0h */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 82195EF0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82195EF0h case    8:*/		return 0x82195EF4;
		  /* 82195EF4h */ case    9:  		/* addi R10, R11, 3 */
		/* 82195EF4h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x3);
		/* 82195EF4h case    9:*/		return 0x82195EF8;
		  /* 82195EF8h */ case   10:  		/* addic. R11, R11, -1 */
		/* 82195EF8h case   10:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82195EF8h case   10:*/		return 0x82195EFC;
		  /* 82195EFCh */ case   11:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82195EFCh case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82195EFCh case   11:*/		return 0x82195F00;
		  /* 82195F00h */ case   12:  		/* lwzx R31, <#[R10 + R4]> */
		/* 82195F00h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 82195F00h case   12:*/		return 0x82195F04;
		  /* 82195F04h */ case   13:  		/* stw R11, <#[R4 + 8]> */
		/* 82195F04h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 82195F04h case   13:*/		return 0x82195F08;
		  /* 82195F08h */ case   14:  		/* bc 4, CR0_EQ, 60 */
		/* 82195F08h case   14:*/		if ( !regs.CR[0].eq ) { return 0x82195F44;  }
		/* 82195F08h case   14:*/		return 0x82195F0C;
		  /* 82195F0Ch */ case   15:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 82195F0Ch case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 82195F0Ch case   15:*/		return 0x82195F10;
		  /* 82195F10h */ case   16:  		/* mr R3, R28 */
		/* 82195F10h case   16:*/		regs.R3 = regs.R28;
		/* 82195F10h case   16:*/		return 0x82195F14;
		  /* 82195F14h */ case   17:  		/* lwz R10, <#[R11 + 4]> */
		/* 82195F14h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82195F14h case   17:*/		return 0x82195F18;
		  /* 82195F18h */ case   18:  		/* lwz R9, <#[R11]> */
		/* 82195F18h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82195F18h case   18:*/		return 0x82195F1C;
		  /* 82195F1Ch */ case   19:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82195F1Ch case   19:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82195F1Ch case   19:*/		return 0x82195F20;
		  /* 82195F20h */ case   20:  		/* stw R9, <#[R10]> */
		/* 82195F20h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82195F20h case   20:*/		return 0x82195F24;
		  /* 82195F24h */ case   21:  		/* lwz R10, <#[R11]> */
		/* 82195F24h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82195F24h case   21:*/		return 0x82195F28;
		  /* 82195F28h */ case   22:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82195F28h case   22:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82195F28h case   22:*/		return 0x82195F2C;
		  /* 82195F2Ch */ case   23:  		/* lwz R11, <#[R11 + 4]> */
		/* 82195F2Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82195F2Ch case   23:*/		return 0x82195F30;
		  /* 82195F30h */ case   24:  		/* stw R11, <#[R10]> */
		/* 82195F30h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82195F30h case   24:*/		return 0x82195F34;
		  /* 82195F34h */ case   25:  		/* lwz R11, <#[R4 + 12]> */
		/* 82195F34h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 82195F34h case   25:*/		return 0x82195F38;
		  /* 82195F38h */ case   26:  		/* addi R11, R11, 4 */
		/* 82195F38h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82195F38h case   26:*/		return 0x82195F3C;
		  /* 82195F3Ch */ case   27:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82195F3Ch case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82195F3Ch case   27:*/		return 0x82195F40;
		  /* 82195F40h */ case   28:  		/* bl -278840 */
		/* 82195F40h case   28:*/		regs.LR = 0x82195F44; return 0x82151E08;
		/* 82195F40h case   28:*/		return 0x82195F44;
	}
	return 0x82195F44;
} // Block from 82195ED0h-82195F44h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82195F44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195F44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195F44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195F44);
		  /* 82195F44h */ case    0:  		/* lwz R5, <#[R1 + 84]> */
		/* 82195F44h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 82195F44h case    0:*/		return 0x82195F48;
		  /* 82195F48h */ case    1:  		/* cmplw CR6, R31, R5 */
		/* 82195F48h case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R5);
		/* 82195F48h case    1:*/		return 0x82195F4C;
		  /* 82195F4Ch */ case    2:  		/* bc 12, CR6_EQ, -124 */
		/* 82195F4Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82195ED0;  }
		/* 82195F4Ch case    2:*/		return 0x82195F50;
		  /* 82195F50h */ case    3:  		/* li R6, 0 */
		/* 82195F50h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82195F50h case    3:*/		return 0x82195F54;
		  /* 82195F54h */ case    4:  		/* mr R4, R31 */
		/* 82195F54h case    4:*/		regs.R4 = regs.R31;
		/* 82195F54h case    4:*/		return 0x82195F58;
		  /* 82195F58h */ case    5:  		/* mr R3, R18 */
		/* 82195F58h case    5:*/		regs.R3 = regs.R18;
		/* 82195F58h case    5:*/		return 0x82195F5C;
		  /* 82195F5Ch */ case    6:  		/* bl 615692 */
		/* 82195F5Ch case    6:*/		regs.LR = 0x82195F60; return 0x8222C468;
		/* 82195F5Ch case    6:*/		return 0x82195F60;
		  /* 82195F60h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82195F60h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82195F60h case    7:*/		return 0x82195F64;
		  /* 82195F64h */ case    8:  		/* bc 12, CR0_EQ, 44 */
		/* 82195F64h case    8:*/		if ( regs.CR[0].eq ) { return 0x82195F90;  }
		/* 82195F64h case    8:*/		return 0x82195F68;
		  /* 82195F68h */ case    9:  		/* li R6, 0 */
		/* 82195F68h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82195F68h case    9:*/		return 0x82195F6C;
		  /* 82195F6Ch */ case   10:  		/* lwz R5, <#[R1 + 84]> */
		/* 82195F6Ch case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 82195F6Ch case   10:*/		return 0x82195F70;
		  /* 82195F70h */ case   11:  		/* mr R4, R31 */
		/* 82195F70h case   11:*/		regs.R4 = regs.R31;
		/* 82195F70h case   11:*/		return 0x82195F74;
		  /* 82195F74h */ case   12:  		/* mr R3, R18 */
		/* 82195F74h case   12:*/		regs.R3 = regs.R18;
		/* 82195F74h case   12:*/		return 0x82195F78;
		  /* 82195F78h */ case   13:  		/* bl 621768 */
		/* 82195F78h case   13:*/		regs.LR = 0x82195F7C; return 0x8222DC40;
		/* 82195F78h case   13:*/		return 0x82195F7C;
		  /* 82195F7Ch */ case   14:  		/* mr R5, R18 */
		/* 82195F7Ch case   14:*/		regs.R5 = regs.R18;
		/* 82195F7Ch case   14:*/		return 0x82195F80;
		  /* 82195F80h */ case   15:  		/* mr R4, R31 */
		/* 82195F80h case   15:*/		regs.R4 = regs.R31;
		/* 82195F80h case   15:*/		return 0x82195F84;
		  /* 82195F84h */ case   16:  		/* lwz R3, <#[R1 + 84]> */
		/* 82195F84h case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 82195F84h case   16:*/		return 0x82195F88;
		  /* 82195F88h */ case   17:  		/* bl -122104 */
		/* 82195F88h case   17:*/		regs.LR = 0x82195F8C; return 0x82178290;
		/* 82195F88h case   17:*/		return 0x82195F8C;
		  /* 82195F8Ch */ case   18:  		/* b -188 */
		/* 82195F8Ch case   18:*/		return 0x82195ED0;
		/* 82195F8Ch case   18:*/		return 0x82195F90;
	}
	return 0x82195F90;
} // Block from 82195F44h-82195F90h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82195F90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195F90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195F90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195F90);
		  /* 82195F90h */ case    0:  		/* lwz R11, <#[R26]> */
		/* 82195F90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82195F90h case    0:*/		return 0x82195F94;
		  /* 82195F94h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82195F94h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82195F94h case    1:*/		return 0x82195F98;
		  /* 82195F98h */ case    2:  		/* bc 4, CR0_EQ, 12 */
		/* 82195F98h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82195FA4;  }
		/* 82195F98h case    2:*/		return 0x82195F9C;
		  /* 82195F9Ch */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 82195F9Ch case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82195F9Ch case    3:*/		return 0x82195FA0;
		  /* 82195FA0h */ case    4:  		/* bc 4, CR0_EQ, 32 */
		/* 82195FA0h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82195FC0;  }
		/* 82195FA0h case    4:*/		return 0x82195FA4;
	}
	return 0x82195FA4;
} // Block from 82195F90h-82195FA4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82195FA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195FA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195FA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195FA4);
		  /* 82195FA4h */ case    0:  		/* rlwinm R11, R25, 0, 0, 30 */
		/* 82195FA4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R25);
		/* 82195FA4h case    0:*/		return 0x82195FA8;
		  /* 82195FA8h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 82195FA8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82195FA8h case    1:*/		return 0x82195FAC;
		  /* 82195FACh */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82195FACh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82195FACh case    2:*/		return 0x82195FB0;
		  /* 82195FB0h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82195FB0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82195FC0;  }
		/* 82195FB0h case    3:*/		return 0x82195FB4;
		  /* 82195FB4h */ case    4:  		/* mr R25, R11 */
		/* 82195FB4h case    4:*/		regs.R25 = regs.R11;
		/* 82195FB4h case    4:*/		return 0x82195FB8;
		  /* 82195FB8h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82195FB8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82195FB8h case    5:*/		return 0x82195FBC;
		  /* 82195FBCh */ case    6:  		/* bc 4, CR6_EQ, -712 */
		/* 82195FBCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x82195CF4;  }
		/* 82195FBCh case    6:*/		return 0x82195FC0;
	}
	return 0x82195FC0;
} // Block from 82195FA4h-82195FC0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82195FC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82195FC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82195FC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82195FC0);
		  /* 82195FC0h */ case    0:  		/* lwz R11, <#[R26]> */
		/* 82195FC0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82195FC0h case    0:*/		return 0x82195FC4;
		  /* 82195FC4h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82195FC4h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82195FC4h case    1:*/		return 0x82195FC8;
		  /* 82195FC8h */ case    2:  		/* bc 4, CR0_EQ, 156 */
		/* 82195FC8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82196064;  }
		/* 82195FC8h case    2:*/		return 0x82195FCC;
		  /* 82195FCCh */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 82195FCCh case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82195FCCh case    3:*/		return 0x82195FD0;
		  /* 82195FD0h */ case    4:  		/* bc 12, CR0_EQ, 148 */
		/* 82195FD0h case    4:*/		if ( regs.CR[0].eq ) { return 0x82196064;  }
		/* 82195FD0h case    4:*/		return 0x82195FD4;
		  /* 82195FD4h */ case    5:  		/* mr R3, R28 */
		/* 82195FD4h case    5:*/		regs.R3 = regs.R28;
		/* 82195FD4h case    5:*/		return 0x82195FD8;
		  /* 82195FD8h */ case    6:  		/* bl 375304 */
		/* 82195FD8h case    6:*/		regs.LR = 0x82195FDC; return 0x821F19E0;
		/* 82195FD8h case    6:*/		return 0x82195FDC;
		  /* 82195FDCh */ case    7:  		/* lwz R11, <#[R24]> */
		/* 82195FDCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 82195FDCh case    7:*/		return 0x82195FE0;
		  /* 82195FE0h */ case    8:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82195FE0h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82195FE0h case    8:*/		return 0x82195FE4;
		  /* 82195FE4h */ case    9:  		/* bc 4, CR0_EQ, 128 */
		/* 82195FE4h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82196064;  }
		/* 82195FE4h case    9:*/		return 0x82195FE8;
		  /* 82195FE8h */ case   10:  		/* cmplwi CR0, R11, 0 */
		/* 82195FE8h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82195FE8h case   10:*/		return 0x82195FEC;
		  /* 82195FECh */ case   11:  		/* bc 12, CR0_EQ, 120 */
		/* 82195FECh case   11:*/		if ( regs.CR[0].eq ) { return 0x82196064;  }
		/* 82195FECh case   11:*/		return 0x82195FF0;
		  /* 82195FF0h */ case   12:  		/* lwz R11, <#[R27]> */
		/* 82195FF0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82195FF0h case   12:*/		return 0x82195FF4;
		  /* 82195FF4h */ case   13:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82195FF4h case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82195FF4h case   13:*/		return 0x82195FF8;
		  /* 82195FF8h */ case   14:  		/* addi R4, R11, -4 */
		/* 82195FF8h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 82195FF8h case   14:*/		return 0x82195FFC;
		  /* 82195FFCh */ case   15:  		/* lwz R11, <#[R11 + 4]> */
		/* 82195FFCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82195FFCh case   15:*/		return 0x82196000;
		  /* 82196000h */ case   16:  		/* addi R10, R11, 3 */
		/* 82196000h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x3);
		/* 82196000h case   16:*/		return 0x82196004;
		  /* 82196004h */ case   17:  		/* addic. R11, R11, -1 */
		/* 82196004h case   17:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82196004h case   17:*/		return 0x82196008;
		  /* 82196008h */ case   18:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82196008h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82196008h case   18:*/		return 0x8219600C;
		  /* 8219600Ch */ case   19:  		/* lwzx R31, <#[R10 + R4]> */
		/* 8219600Ch case   19:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 8219600Ch case   19:*/		return 0x82196010;
		  /* 82196010h */ case   20:  		/* stw R11, <#[R4 + 8]> */
		/* 82196010h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 82196010h case   20:*/		return 0x82196014;
		  /* 82196014h */ case   21:  		/* bc 4, CR0_EQ, 60 */
		/* 82196014h case   21:*/		if ( !regs.CR[0].eq ) { return 0x82196050;  }
		/* 82196014h case   21:*/		return 0x82196018;
		  /* 82196018h */ case   22:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 82196018h case   22:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 82196018h case   22:*/		return 0x8219601C;
		  /* 8219601Ch */ case   23:  		/* mr R3, R27 */
		/* 8219601Ch case   23:*/		regs.R3 = regs.R27;
		/* 8219601Ch case   23:*/		return 0x82196020;
		  /* 82196020h */ case   24:  		/* lwz R10, <#[R11 + 4]> */
		/* 82196020h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82196020h case   24:*/		return 0x82196024;
		  /* 82196024h */ case   25:  		/* lwz R9, <#[R11]> */
		/* 82196024h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82196024h case   25:*/		return 0x82196028;
		  /* 82196028h */ case   26:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82196028h case   26:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82196028h case   26:*/		return 0x8219602C;
		  /* 8219602Ch */ case   27:  		/* stw R9, <#[R10]> */
		/* 8219602Ch case   27:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8219602Ch case   27:*/		return 0x82196030;
		  /* 82196030h */ case   28:  		/* lwz R10, <#[R11]> */
		/* 82196030h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82196030h case   28:*/		return 0x82196034;
		  /* 82196034h */ case   29:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82196034h case   29:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82196034h case   29:*/		return 0x82196038;
		  /* 82196038h */ case   30:  		/* lwz R11, <#[R11 + 4]> */
		/* 82196038h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82196038h case   30:*/		return 0x8219603C;
		  /* 8219603Ch */ case   31:  		/* stw R11, <#[R10]> */
		/* 8219603Ch case   31:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8219603Ch case   31:*/		return 0x82196040;
		  /* 82196040h */ case   32:  		/* lwz R11, <#[R4 + 12]> */
		/* 82196040h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 82196040h case   32:*/		return 0x82196044;
		  /* 82196044h */ case   33:  		/* addi R11, R11, 4 */
		/* 82196044h case   33:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82196044h case   33:*/		return 0x82196048;
		  /* 82196048h */ case   34:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82196048h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82196048h case   34:*/		return 0x8219604C;
		  /* 8219604Ch */ case   35:  		/* bl -279108 */
		/* 8219604Ch case   35:*/		regs.LR = 0x82196050; return 0x82151E08;
		/* 8219604Ch case   35:*/		return 0x82196050;
	}
	return 0x82196050;
} // Block from 82195FC0h-82196050h (36 instructions)

//////////////////////////////////////////////////////
// Block at 82196050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196050);
		  /* 82196050h */ case    0:  		/* mr R5, R18 */
		/* 82196050h case    0:*/		regs.R5 = regs.R18;
		/* 82196050h case    0:*/		return 0x82196054;
		  /* 82196054h */ case    1:  		/* lwz R3, <#[R1 + 84]> */
		/* 82196054h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 82196054h case    1:*/		return 0x82196058;
		  /* 82196058h */ case    2:  		/* mr R4, R31 */
		/* 82196058h case    2:*/		regs.R4 = regs.R31;
		/* 82196058h case    2:*/		return 0x8219605C;
		  /* 8219605Ch */ case    3:  		/* bl -120652 */
		/* 8219605Ch case    3:*/		regs.LR = 0x82196060; return 0x82178910;
		/* 8219605Ch case    3:*/		return 0x82196060;
		  /* 82196060h */ case    4:  		/* b -132 */
		/* 82196060h case    4:*/		return 0x82195FDC;
		/* 82196060h case    4:*/		return 0x82196064;
	}
	return 0x82196064;
} // Block from 82196050h-82196064h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82196064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196064);
		  /* 82196064h */ case    0:  		/* lwz R10, <#[R18 + 976]> */
		/* 82196064h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R18 + 0x000003D0) );
		/* 82196064h case    0:*/		return 0x82196068;
		  /* 82196068h */ case    1:  		/* mr R3, R27 */
		/* 82196068h case    1:*/		regs.R3 = regs.R27;
		/* 82196068h case    1:*/		return 0x8219606C;
		  /* 8219606Ch */ case    2:  		/* addi R11, R18, 972 */
		/* 8219606Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R18,0x3CC);
		/* 8219606Ch case    2:*/		return 0x82196070;
		  /* 82196070h */ case    3:  		/* stw R10, <#[R28]> */
		/* 82196070h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 82196070h case    3:*/		return 0x82196074;
		  /* 82196074h */ case    4:  		/* stw R28, <#[R18 + 976]> */
		/* 82196074h case    4:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R18 + 0x000003D0) );
		/* 82196074h case    4:*/		return 0x82196078;
		  /* 82196078h */ case    5:  		/* bl 375144 */
		/* 82196078h case    5:*/		regs.LR = 0x8219607C; return 0x821F19E0;
		/* 82196078h case    5:*/		return 0x8219607C;
		  /* 8219607Ch */ case    6:  		/* lwz R11, <#[R18 + 976]> */
		/* 8219607Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x000003D0) );
		/* 8219607Ch case    6:*/		return 0x82196080;
		  /* 82196080h */ case    7:  		/* stw R11, <#[R27]> */
		/* 82196080h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82196080h case    7:*/		return 0x82196084;
		  /* 82196084h */ case    8:  		/* stw R27, <#[R18 + 976]> */
		/* 82196084h case    8:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R18 + 0x000003D0) );
		/* 82196084h case    8:*/		return 0x82196088;
	}
	return 0x82196088;
} // Block from 82196064h-82196088h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82196088h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196088);
		  /* 82196088h */ case    0:  		/* lwz R23, <#[R23 + 12]> */
		/* 82196088h case    0:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R23 + 0x0000000C) );
		/* 82196088h case    0:*/		return 0x8219608C;
		  /* 8219608Ch */ case    1:  		/* b -1168 */
		/* 8219608Ch case    1:*/		return 0x82195BFC;
		/* 8219608Ch case    1:*/		return 0x82196090;
	}
	return 0x82196090;
} // Block from 82196088h-82196090h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82196090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196090);
		  /* 82196090h */ case    0:  		/* lwz R20, <#[R20 + 12]> */
		/* 82196090h case    0:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R20 + 0x0000000C) );
		/* 82196090h case    0:*/		return 0x82196094;
		  /* 82196094h */ case    1:  		/* b -1344 */
		/* 82196094h case    1:*/		return 0x82195B54;
		/* 82196094h case    1:*/		return 0x82196098;
	}
	return 0x82196098;
} // Block from 82196090h-82196098h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82196098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196098);
		  /* 82196098h */ case    0:  		/* rlwinm R11, R21, 0, 0, 30 */
		/* 82196098h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R21);
		/* 82196098h case    0:*/		return 0x8219609C;
		  /* 8219609Ch */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8219609Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8219609Ch case    1:*/		return 0x821960A0;
		  /* 821960A0h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821960A0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821960A0h case    2:*/		return 0x821960A4;
		  /* 821960A4h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821960A4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821960B4;  }
		/* 821960A4h case    3:*/		return 0x821960A8;
		  /* 821960A8h */ case    4:  		/* mr R21, R11 */
		/* 821960A8h case    4:*/		regs.R21 = regs.R11;
		/* 821960A8h case    4:*/		return 0x821960AC;
		  /* 821960ACh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821960ACh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821960ACh case    5:*/		return 0x821960B0;
		  /* 821960B0h */ case    6:  		/* bc 4, CR6_EQ, -1432 */
		/* 821960B0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82195B18;  }
		/* 821960B0h case    6:*/		return 0x821960B4;
	}
	return 0x821960B4;
} // Block from 82196098h-821960B4h (7 instructions)

